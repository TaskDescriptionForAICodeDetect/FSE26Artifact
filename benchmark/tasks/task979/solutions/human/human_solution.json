[
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  4.times.map do |i|\n    cs.rotate(i)\n  end.min\nend\n\ndef rot_sym(cs)\n  if cs.uniq.size == 1\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    count[encode(rc)] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  (4 // rot[s0]).times do |i|\n    count[encode(ss[s0].rotate(i))] -= 1i64\n  end\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    4.times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      (s0 + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        c2 = ss[s2]\n        4.times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n          rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n          ua = count[encode(rsa)]\n          ub = count[encode(rsb)]\n          uc = count[encode(rsc)]\n          {s1, s2}.each do |si|\n            (4 // rot[si]).times do |k|\n              rsi = ss[si].rotate(k)\n              ua -= 1 if rsi == rsa\n              ub -= 1 if rsi == rsb\n              uc -= 1 if rsi == rsc\n            end\n          end\n          if rsa == rsb && rsa == rsc\n            cur = ua * (ua - 1) * (ua - 2)\n          elsif rsa == rsb\n            cur = ua * (ua - 1) * uc\n          elsif rsa == rsc\n            cur = ua * (ua - 1) * ub\n          elsif rsb == rsc\n            cur = ub * (ub - 1) * ua\n          else\n            cur = ua * ub * uc\n          end\n          ans += cur * rot[s1] * rot[s2] * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  4.times.map do |i|\n    cs.rotate(i)\n  end.min\nend\n\ndef rot_sym(cs)\n  if cs.uniq.size == 1\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    4.times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      (s0 + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        c2 = ss[s2]\n        4.times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n          rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n          rsav = encode(rsa)\n          rsbv = encode(rsb)\n          rscv = encode(rsc)\n          ua = count[rsav]\n          ub = count[rsbv]\n          uc = count[rscv]\n          if ua > 0 && ub > 0 && uc > 0\n            {s1, s2}.each do |si|\n              encs[si].each do |v|\n                ua -= 1 if v == rsav\n                ub -= 1 if v == rsbv\n                uc -= 1 if v == rscv\n              end\n            end\n            if rsav == rsbv && rsav == rscv\n              cur = ua * (ua - 1) * (ua - 2)\n            elsif rsav == rsbv\n              cur = ua * (ua - 1) * uc\n            elsif rsav == rscv\n              cur = ua * (ua - 1) * ub\n            elsif rsbv == rscv\n              cur = ub * (ub - 1) * ua\n            else\n              cur = ua * ub * uc\n            end\n            if cur != 0\n              ans += cur * rot[s1] * rot[s2] * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n            end\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  ret = cs\n  1.upto(3) do |i|\n    v0 = cs[i]\n    v1 = cs[(i + 1) & 3]\n    v2 = cs[(i + 2) & 3]\n    v3 = cs[(i + 3) & 3]\n    if v0 < ret[0] ||\n       v0 == ret[0] && v1 < ret[1] ||\n       v0 == ret[0] && v1 == ret[1] && v2 < ret[2] ||\n       v0 == ret[0] && v1 == ret[1] && v2 == ret[2] && v3 < ret[3]\n      ret = {v0, v1, v2, v3}\n    end\n  end\n  return ret\nend\n\ndef rot_sym(cs)\n  if cs[0] == cs[1] && cs[0] == cs[2] && cs[0] == cs[3]\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  mul0 = rot[s0] == 1 ? 1 : 2\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    (4 // rot[s1]).times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      ((mul0 == 1 ? s0 : s1) + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        mul = mul0 * rot[s1] * rot[s2]\n        c2 = ss[s2]\n        (4 // rot[s2]).times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min({c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]})\n          rsb = min({c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]})\n          rsc = min({c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]})\n          rsav = encode(rsa)\n          rsbv = encode(rsb)\n          rscv = encode(rsc)\n          ua = count[rsav]\n          ub = count[rsbv]\n          uc = count[rscv]\n          if ua > 0 && ub > 0 && uc > 0\n            {s1, s2}.each do |si|\n              encs[si].each do |v|\n                ua -= 1 if v == rsav\n                ub -= 1 if v == rsbv\n                uc -= 1 if v == rscv\n              end\n            end\n            if rsav == rsbv && rsav == rscv\n              cur = ua * (ua - 1) * (ua - 2)\n            elsif rsav == rsbv\n              cur = ua * (ua - 1) * uc\n            elsif rsav == rscv\n              cur = ua * (ua - 1) * ub\n            elsif rsbv == rscv\n              cur = ub * (ub - 1) * ua\n            else\n              cur = ua * ub * uc\n            end\n            if cur != 0\n              ans += cur * mul * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n            end\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  4.times.map do |i|\n    cs.rotate(i)\n  end.min\nend\n\ndef rot_sym(cs)\n  if cs.uniq.size == 1\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    4.times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      (s0 + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        c2 = ss[s2]\n        4.times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n          rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n          rsav = encode(rsa)\n          rsbv = encode(rsb)\n          rscv = encode(rsc)\n          ua = count[rsav]\n          ub = count[rsbv]\n          uc = count[rscv]\n          {s1, s2}.each do |si|\n            encs[si].each do |v|\n              ua -= 1 if v == rsav\n              ub -= 1 if v == rsbv\n              uc -= 1 if v == rscv\n            end\n          end\n          if rsav == rsbv && rsav == rscv\n            cur = ua * (ua - 1) * (ua - 2)\n          elsif rsav == rsbv\n            cur = ua * (ua - 1) * uc\n          elsif rsav == rscv\n            cur = ua * (ua - 1) * ub\n          elsif rsbv == rscv\n            cur = ub * (ub - 1) * ua\n          else\n            cur = ua * ub * uc\n          end\n          if cur != 0\n            ans += cur * rot[s1] * rot[s2] * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  ret = cs.clone\n  1.upto(3) do |i|\n    v0 = cs[i]\n    v1 = cs[(i + 1) & 3]\n    v2 = cs[(i + 2) & 3]\n    v3 = cs[(i + 3) & 3]\n    if v0 < ret[0] ||\n       v0 == ret[0] && v1 < ret[1] ||\n       v0 == ret[0] && v1 == ret[1] && v2 < ret[2] ||\n       v0 == ret[0] && v1 == ret[1] && v2 == ret[2] && v3 < ret[3]\n      ret[0] = v0\n      ret[1] = v1\n      ret[2] = v2\n      ret[3] = v3\n    end\n  end\n  return ret\nend\n\ndef rot_sym(cs)\n  if cs[0] == cs[1] && cs[0] == cs[2] && cs[0] == cs[3]\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    (4 // rot[s1]).times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      (s0 + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        c2 = ss[s2]\n        (4 // rot[s2]).times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n          rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n          rsav = encode(rsa)\n          rsbv = encode(rsb)\n          rscv = encode(rsc)\n          ua = count[rsav]\n          ub = count[rsbv]\n          uc = count[rscv]\n          if ua > 0 && ub > 0 && uc > 0\n            {s1, s2}.each do |si|\n              encs[si].each do |v|\n                ua -= 1 if v == rsav\n                ub -= 1 if v == rsbv\n                uc -= 1 if v == rscv\n              end\n            end\n            if rsav == rsbv && rsav == rscv\n              cur = ua * (ua - 1) * (ua - 2)\n            elsif rsav == rsbv\n              cur = ua * (ua - 1) * uc\n            elsif rsav == rscv\n              cur = ua * (ua - 1) * ub\n            elsif rsbv == rscv\n              cur = ub * (ub - 1) * ua\n            else\n              cur = ua * ub * uc\n            end\n            if cur != 0\n              ans += cur * rot[s1] * rot[s2] * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n            end\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  ret = cs.clone\n  1.upto(3) do |i|\n    v0 = cs[i]\n    v1 = cs[(i + 1) & 3]\n    v2 = cs[(i + 2) & 3]\n    v3 = cs[(i + 3) & 3]\n    if v0 < ret[0] ||\n       v0 == ret[0] && v1 < ret[1] ||\n       v0 == ret[0] && v1 == ret[1] && v2 < ret[2] ||\n       v0 == ret[0] && v1 == ret[1] && v2 == ret[2] && v3 < ret[3]\n      ret[0] = v0\n      ret[1] = v1\n      ret[2] = v2\n      ret[3] = v3\n    end\n  end\n  return ret\nend\n\ndef rot_sym(cs)\n  if cs[0] == cs[1] && cs[0] == cs[2] && cs[0] == cs[3]\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    (4 // rot[s1]).times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      (s0 + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        c2 = ss[s2]\n        (4 // rot[s2]).times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsav = encode(rsa)\n          ua = count[rsav]\n          if ua > 0\n            rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n            rsbv = encode(rsb)\n            ub = count[rsbv]\n            if ub > 0\n              rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n              rscv = encode(rsc)\n              uc = count[rscv]\n              if uc > 0\n                {s1, s2}.each do |si|\n                  encs[si].each do |v|\n                    ua -= 1 if v == rsav\n                    ub -= 1 if v == rsbv\n                    uc -= 1 if v == rscv\n                  end\n                end\n                if rsav == rsbv && rsav == rscv\n                  cur = ua * (ua - 1) * (ua - 2)\n                elsif rsav == rsbv\n                  cur = ua * (ua - 1) * uc\n                elsif rsav == rscv\n                  cur = ua * (ua - 1) * ub\n                elsif rsbv == rscv\n                  cur = ub * (ub - 1) * ua\n                else\n                  cur = ua * ub * uc\n                end\n                if cur != 0\n                  ans += cur * rot[s1] * rot[s2] * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n                end\n              end\n            end\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  ret = cs.clone\n  1.upto(3) do |i|\n    v0 = cs[i]\n    v1 = cs[(i + 1) & 3]\n    v2 = cs[(i + 2) & 3]\n    v3 = cs[(i + 3) & 3]\n    if v0 < ret[0] ||\n       v0 == ret[0] && v1 < ret[1] ||\n       v0 == ret[0] && v1 == ret[1] && v2 < ret[2] ||\n       v0 == ret[0] && v1 == ret[1] && v2 == ret[2] && v3 < ret[3]\n      ret[0] = v0\n      ret[1] = v1\n      ret[2] = v2\n      ret[3] = v3\n    end\n  end\n  return ret\nend\n\ndef rot_sym(cs)\n  if cs[0] == cs[1] && cs[0] == cs[2] && cs[0] == cs[3]\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  mul0 = rot[s0] == 1 ? 1 : 2\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    (4 // rot[s1]).times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      ((mul0 == 1 ? s0 : s1) + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        mul = mul0 * rot[s1] * rot[s2]\n        c2 = ss[s2]\n        (4 // rot[s2]).times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n          rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n          rsav = encode(rsa)\n          rsbv = encode(rsb)\n          rscv = encode(rsc)\n          ua = count[rsav]\n          ub = count[rsbv]\n          uc = count[rscv]\n          if ua > 0 && ub > 0 && uc > 0\n            {s1, s2}.each do |si|\n              encs[si].each do |v|\n                ua -= 1 if v == rsav\n                ub -= 1 if v == rsbv\n                uc -= 1 if v == rscv\n              end\n            end\n            if rsav == rsbv && rsav == rscv\n              cur = ua * (ua - 1) * (ua - 2)\n            elsif rsav == rsbv\n              cur = ua * (ua - 1) * uc\n            elsif rsav == rscv\n              cur = ua * (ua - 1) * ub\n            elsif rsbv == rscv\n              cur = ub * (ub - 1) * ua\n            else\n              cur = ua * ub * uc\n            end\n            if cur != 0\n              ans += cur * mul * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n            end\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "def encode(cs)\n  (cs[0].to_i64 << 30) | (cs[1].to_i64 << 20) | (cs[2].to_i64 << 10) | cs[3].to_i64\nend\n\ndef min(cs)\n  ret = cs.clone\n  1.upto(3) do |i|\n    v0 = cs[i]\n    v1 = cs[(i + 1) & 3]\n    v2 = cs[(i + 2) & 3]\n    v3 = cs[(i + 3) & 3]\n    if v0 < ret[0] ||\n       v0 == ret[0] && v1 < ret[1] ||\n       v0 == ret[0] && v1 == ret[1] && v2 < ret[2] ||\n       v0 == ret[0] && v1 == ret[1] && v2 == ret[2] && v3 < ret[3]\n      ret[0] = v0\n      ret[1] = v1\n      ret[2] = v2\n      ret[3] = v3\n    end\n  end\n  return ret\nend\n\ndef rot_sym(cs)\n  if cs[0] == cs[1] && cs[0] == cs[2] && cs[0] == cs[3]\n    4\n  elsif cs[0] == cs[2] && cs[1] == cs[3]\n    2\n  else\n    1\n  end\nend\n\nn = read_line.to_i\ncount = Hash(Int64, Int64).new(0i64)\nrot = Array.new(n, 1)\nencs = Array.new(n) { [] of Int64 }\nss = Array.new(n) do |i|\n  cs = read_line.split.map(&.to_i)\n  rot[i] = rot_sym(cs)\n  (4 // rot[i]).times.map do |j|\n    rc = cs.rotate(j)\n    encs[i] << encode(rc)\n    count[encs[i][-1]] += 1i64\n    rc\n  end.min\nend\nans = 0i64\nn.times do |s0|\n  encs[s0].each do |v|\n    count[v] -= 1i64\n  end\n  mul0 = rot[s0] == 1 ? 1 : 2\n  c0 = ss[s0]\n  (s0 + 1).upto(n - 1) do |s1|\n    c1 = ss[s1]\n    (4 // rot[s1]).times do |i|\n      next if c0[0] != c1[(i + 1) & 3] || c0[1] != c1[i]\n      ((mul0 == 1 ? s0 : s1) + 1).upto(n - 1) do |s2|\n        next if s1 == s2\n        c2 = ss[s2]\n        (4 // rot[s2]).times do |j|\n          next if c0[2] != c2[(j + 1) & 3] || c0[3] != c2[j]\n          rsa = min([c0[2], c0[1], c1[(i + 3) & 3], c2[(j + 2) & 3]])\n          rsb = min([c0[0], c0[3], c2[(j + 3) & 3], c1[(i + 2) & 3]])\n          rsc = min([c1[(i + 3) & 3], c1[(i + 2) & 3], c2[(j + 3) & 3], c2[(j + 2) & 3]])\n          rsav = encode(rsa)\n          rsbv = encode(rsb)\n          rscv = encode(rsc)\n          ua = count[rsav]\n          ub = count[rsbv]\n          uc = count[rscv]\n          if ua > 0 && ub > 0 && uc > 0\n            {s1, s2}.each do |si|\n              encs[si].each do |v|\n                ua -= 1 if v == rsav\n                ub -= 1 if v == rsbv\n                uc -= 1 if v == rscv\n              end\n            end\n            if rsav == rsbv && rsav == rscv\n              cur = ua * (ua - 1) * (ua - 2)\n            elsif rsav == rsbv\n              cur = ua * (ua - 1) * uc\n            elsif rsav == rscv\n              cur = ua * (ua - 1) * ub\n            elsif rsbv == rscv\n              cur = ub * (ub - 1) * ua\n            else\n              cur = ua * ub * uc\n            end\n            if cur != 0\n              ans += cur * mul0 * rot[s1] * rot[s2] * rot_sym(rsa) * rot_sym(rsb) * rot_sym(rsc)\n            end\n          end\n          break if rot[s2] != 1\n        end\n      end\n      break if rot[s1] != 1\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 1005, base = 9971 ; \n\nconst int turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <int>, int> Count ;\nint col[N][5], n ;\nll sum ;\n\ninline void getmin(vector <int> &p) {\n\tvector <int> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nvector <int> vec[N] ;\nmap <vector <int>, int>  mul ;\n\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) rep(j, 0, 3) scanf(\"%d\", &col[i][j]) ;\n\trep(i, 1, n) {\n\t\tvector <int> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\tvec[i] = ret ;\n\t\t++ Count[ret] ;\n\t\tint tot = 0 ; \n\t\tvector <int> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0 ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\t-- Count[vec[i]], -- Count[vec[j]] ;\n//\t\tprintf(\"%d %d\\n\", i, j) ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <int> ret ;\n\t\t\tmap <vector <int>, int> used ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\tvector <int> U ;\n\t\t\t\trep(q, 0, 3) U.push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(U) ;\n\t\t\t\tsum *= mul[U] * (Count[U] - used[U]) ;\n\t\t\t\t++ used[U] ;\n\t\t\t}\n\t\t\tans += sum ;\n\t\t}\n\t\t++ Count[vec[i]], ++ Count[vec[j]] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<18;\nusing str = array<int, 4>;\nint tr[1660][1010], sz = 1, cnt[1660], t[1660];\n#define INLINE inline __attribute(( always_inline ))\nINLINE void nw(str a) {\n\tint p = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(!tr[p][a[i]]) tr[p][a[i]] = sz++;\n\t\tp = tr[p][a[i]];\n\t}\n\tt[p] = 1;\n}\n\nINLINE int count(str a, int s = 0) {\n\tint p = 0;\n\tp = tr[p][a[s&3]];\n\tp = tr[p][a[(s+1)&3]];\n\tp = tr[p][a[(s+2)&3]];\n\tp = tr[p][a[(s+3)&3]];\n\treturn cnt[p];\n}\n\nINLINE void add(str a, int x, int s = 0) {\n\tint p = 0;\n\tp = tr[p][a[s&3]];\n\tp = tr[p][a[(s+1)&3]];\n\tp = tr[p][a[(s+2)&3]];\n\tp = tr[p][a[(s+3)&3]];\n\tif(t[p]) cnt[p] += x;\n}\nint n;\nstr x[maxn];\nll ans = 0;\n#define shi(x, y) (((x)>>(2*(y)))&3)\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < 4; j++) cin >> x[i][j];\n\t\t\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tadd(x[j], -1);\n\t\t\tfor(int sD = 0; sD < 4; sD++) {\n\t\t\t\tstr l = {x[j][(sD+1)&3], x[i][0], x[i][3], x[j][(sD+2)&3]};\n\t\t\t\tstr r = {x[i][1], x[j][sD&3], x[j][(sD+3)&3], x[i][2]};\n\t\t\t\tstr f = {x[j][(sD+1)&3], x[j][sD&3], x[i][1], x[i][0]};\n\t\t\t\tstr b = {x[i][3], x[i][2], x[j][(sD+3)&3], x[j][(sD+2)&3]};\n\t\t\t\tfor(int s = 0; s < 256; s++) {\n\t\t\t\t\tll cur = 1;\n\t\t\t\t\t\n\t\t\t\t\tcur *= count(l, shi(s, 0)), add(l, -1, shi(s, 0));\n\t\t\t\t\tcur *= count(r, shi(s, 1)), add(r, -1, shi(s, 1));\n\t\t\t\t\tcur *= count(f, shi(s, 2)), add(f, -1, shi(s, 2));\n\t\t\t\t\tcur *= count(b, shi(s, 3)), add(b, -1, shi(s, 3));\n\t\t\t\t\t\n\t\t\t\t\tans += cur;\n\t\t\t\t\t\n\t\t\t\t\tadd(l, 1, shi(s, 0));\n\t\t\t\t\tadd(r, 1, shi(s, 1));\n\t\t\t\t\tadd(f, 1, shi(s, 2));\n\t\t\t\t\tadd(b, 1, shi(s, 3));\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(x[j], 1);\n\t\t}\n\t\tnw(x[i]);\n\t\tadd(x[i], 1);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=440,D=4,P=10000007;\nint i,j,k,n,m,ch,ff;\nll A[N],ans;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nvoid rev(ll &a) {\n\tll t=a&1023;\n\t(a>>=10)|=t<<30;\n}\nvoid change(ll &a) {\n\tll t1=(a>>10)&1023,t3=(a>>30)&1023;\n\ta^=(t1<<10)|(t3<<30);\n\ta^=(t3<<10)|(t1<<30);\n}\nvoid read(ll &a) {\n\tfor (int i=0;i<D;i++) {\n\t\tint x;\n\t\tR(x);\n\t\t(a<<=10)|=x;\n\t}\n}\nstruct ha {\n\tint En,h[P];\n\tstruct edge { int n,val;ll s;} E[P];\n\tint get(ll x) {\n\t\tint t=x%P;\n\t\tfor (int k=h[t];k;k=E[k].n) if (E[k].s==x) return E[k].val;\n\t\treturn 0;\n\t}\n\tvoid add(ll x,int y) {\n\t\tint t=x%P;\n\t\tfor (int k=h[t];k;k=E[k].n) if (E[k].s==x) {\n\t\t\tE[k].val+=y;\n\t\t\treturn;\n\t\t}\n\t\tE[++En].s=x;E[En].val=y;\n\t\tE[En].n=h[t];h[t]=En;\n\t\treturn;\n\t}\n} ha;\nll work(ll a,ll b) {\n\tint i,j,k;\n\tll t,ans=1;\n\tfor (i=0;i<D;i++) {\n\t\tt=0;\n\t\t(t<<=10)|=(b>>((i+1)%D*10))&1023;\n\t\t(t<<=10)|=(b>>(i*10))&1023;\n\t\t(t<<=10)|=(a>>(i*10))&1023;\n\t\t(t<<=10)|=(a>>((i+1)%D*10))&1023;\n\t\tans*=ha.get(t);\n\t\tfor (k=0;k<D;k++) {\n\t\t\trev(t);\n\t\t\tha.add(t,-1);\n\t\t}\n\t}\n\tfor (i=0;i<D;i++) {\n\t\tt=0;\n\t\t(t<<=10)|=(b>>((i+1)%D*10))&1023;\n\t\t(t<<=10)|=(b>>(i*10))&1023;\n\t\t(t<<=10)|=(a>>(i*10))&1023;\n\t\t(t<<=10)|=(a>>((i+1)%D*10))&1023;\n\t\tfor (k=0;k<D;k++) {\n\t\t\trev(t);\n\t\t\tha.add(t,1);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tR(n);ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tread(A[i]);\n\t\tfor (k=0;k<D;k++) {\n\t\t\trev(A[i]);\n\t\t\tha.add(A[i],1);\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tfor (k=0;k<D;k++) {\n\t\t\trev(A[i]);\n\t\t\tha.add(A[i],-1);\n\t\t}\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\trev(A[j]);\n\t\t\t\tha.add(A[j],-1);\n\t\t\t}\n\t\t\tchange(A[j]);\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\trev(A[i]);\n\t\t\t\tans+=work(A[i],A[j]);\n\t\t\t}\n\t\t\tchange(A[j]);\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\trev(A[j]);\n\t\t\t\tha.add(A[j],1);\n\t\t\t}\n\t\t}\n\t\tfor (k=0;k<D;k++) {\n\t\t\trev(A[i]);\n\t\t\tha.add(A[i],1);\n\t\t}\n\t}\n\tW(ans/3);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=407,M=1007;\n\nint n,s[N][4];\null h[N],v[N];\n\ninline ull cal(int*s)\n{\n\tull r=0,t;\n\tfo0(i,4)\n\t{\n\t\tt=0;\n\t\tfo0(j,4)t=t*M+s[i+j&3];\n\t\trepr(r,t);\n\t}\n\treturn r;\n}\n\ninline ull cal(int a,int b,int c,int d)\n{\n\tint t[4]={a,b,c,d};\n\treturn cal(t);\n}\n\nstruct hash_table\n{\n\tstatic const int N=997;\n\tull a[N];int b[N],c[N];\n\tinline int getpos(ull x)\n\t{\n\t\tint y=x%N;\n\t\tfor(;a[y]&&a[y]!=x;++y==N?y=0:0);\n\t\treturn y;\n\t}\n\tinline void insert(ull x)\n\t{\n\t\tint t=getpos(x);\n\t\tif(a[t]!=x)\n\t\t{\n\t\t\ta[t]=x;\n\t\t\tif(x%(M*M)==x/(M*M))\n\t\t\t\tc[t]=x%((ll)M*M*M)==x/M?4:2;\n\t\t\telse c[t]=1;\n\t\t}\n\t\tb[t]++;\n\t\t//out,x,' ',t,' ',b[t],' ',c[t],'\\n';\n\t}\n\tinline int dec(ull x)\n\t{\n\t\tint t=getpos(x);\n\t\treturn a[t]==x?c[t]*b[t]--:0;\n\t}\n\tinline void back(ull x)\n\t{\n\t\tint t=getpos(x);\n\t\tif(a[t]==x)b[t]++;\n\t}\n}f;\n\nint main()\n{\n\tin,n;\n\tfo0(i,n)fo0(j,4)s[i][j]=(int)in+1;\n\tfo0(i,n)f.insert(h[i]=cal(s[i]));\n\tll ans=0;\n\tfo0(i,n)\n\t{\n\t\tf.dec(h[i]);\n\t\tfo0(j,i)\n\t\t{\n\t\t\tf.dec(h[j]);\n\t\t\tfo0(k,4)\n\t\t\t{\n\t\t\t\tll ta=1;\n\t\t\t\tfo0(l,4)\n\t\t\t\t{\n\t\t\t\t\tv[l]=cal(s[j][-l+1&3],s[j][-l&3],s[i][k+l+1&3],s[i][k+l&3]);\n\t\t\t\t\tta*=f.dec(v[l]);\n\t\t\t\t\t//if(!ta)break;\n\t\t\t\t}\n\t\t\t\tans+=ta;\n\t\t\t\t//out,i,' ',j,' ',k,' ',ta,'\\n';\n\t\t\t\tfo0(l,4)f.back(v[l]);\n\t\t\t}\n\t\t\tf.back(h[j]);\n\t\t}\n\t\tf.back(h[i]);\n\t}\n\tout,ans/3,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nvector<int> c[500];\nint n;\nll cnk[500][5];\nmap<vector<int>, int > mm;\nll fc[5];\n\nvoid init() {\n\tfc[0] = 1;\n\tfc[1] = 1;\n\tfc[2] = 2;\n\tfc[3] = 6;\n\tfc[4] = 24;\n\tfor (int n = 0; n < 500; ++n)\n\t\tfor (int k = 0; k < 5; ++k) {\n\t\t\tif (n == k || k == 0)\n\t\t\t\tcnk[n][k] = 1;\n\t\t\telse if (n < k)\n\t\t\t\tcnk[n][k] = 0;\n\t\t\telse\n\t\t\t\tcnk[n][k] = cnk[n - 1][k] + cnk[n - 1][k - 1];\n\t\t}\n}\n\nint mlt(vector<int> vv) {\n\tvector<int> vv2 = vv;\n\tint cnt = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\trotate(vv2.begin(), vv2.begin() + 1, vv2.end());\n\t\tif (vv2 == vv)\n\t\t\t++cnt;\n\t}\n\treturn cnt;\n}\n\nvector<int> srt(vector<int> vv) {\n\tvector<int> vv2 = vv;\n\tfor (int i = 0; i < 4; ++i) {\n\t\trotate(vv2.begin(), vv2.begin() + 1, vv2.end());\n\t\tif (vv2 < vv)\n\t\t\tvv = vv2;\n\t}\n\treturn vv;\n}\n\nvoid del(int x) {\n\t--mm[c[x]];\n}\n\nvoid add(int x) {\n\t++mm[c[x]];\n}\n\n\n\nint main() {\n\tinit();\n\tcin >> n;\n\tfor (int j = 0; j < n; ++j)\n\t\tc[j].resize(4);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t\tcin >> c[i][j];\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = srt(c[i]);\n\tfor (int i = 0; i < n; ++i)\n\t\tadd(i);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdel(i);\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tdel(j);\n\t\t\tfor (int it = 0; it < 4; ++it) {\n\t\t\t\trotate(c[i].begin(), c[i].begin() + 1, c[i].end());\n\t\t\t\tvector<vector<int> > vv;\n\t\t\t\tvv.push_back({c[i][0], c[j][1], c[j][0], c[i][1]});\n\t\t\t\tvv.push_back({c[i][3], c[j][2], c[j][1], c[i][0]});\n\t\t\t\tvv.push_back({c[i][2], c[j][3], c[j][2], c[i][3]});\n\t\t\t\tvv.push_back({c[i][1], c[j][0], c[j][3], c[i][2]});\n\t\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t\t\tvv[k] = srt(vv[k]);\n\t\t\t\tvector<int> was(4, 0);\n\t\t\t\tll ml = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tif (!was[k]) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor (int k1 = 0; k1 < 4; ++k1)\n\t\t\t\t\t\t\tif (vv[k] == vv[k1])\n\t\t\t\t\t\t\t\t++cnt, was[k1] = 1;\n\t\t\t\t\t\tml *= cnk[mm[vv[k]]][cnt] * fc[cnt];\n\t\t\t\t\t}\n\t\t\t\t\tml *= mlt(vv[k]);\n\t\t\t\t}\n\t\t\t\tans += ml;\n\t\t\t}\n\t\t\tadd(j);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\ntuple<int, int, int, int> mt(int *cc)\n{\n    return make_tuple(cc[0], cc[1], cc[2], cc[3]);\n}\n\nvoid shift(int *cc, int k)\n{\n    int hj[4];\n    for (int i = 0; i < 4; i++) hj[i] = cc[(i+k)%4];\n    for (int i = 0; i < 4; i++) cc[i] = hj[i];\n}\n\nvoid normalize(int *cc)\n{\n    int minidx;\n    ll maxhsh = -1;\n    for (int i = 0; i < 4; i++)\n    {\n        ll hsh = (ll)cc[0] + (ll)cc[1]*(1e3) + (ll)cc[2]*(1e6) + (ll)cc[3]*(1e9);\n        if (hsh > maxhsh)\n        {\n            maxhsh = hsh;\n            minidx = i;\n        }\n        shift(cc, 1);\n    }\n\n    shift(cc, minidx);\n}\n\nconst int MAXN = 500;\nint c[MAXN][4];\nmap <tuple<int, int, int, int> , ll > m;\nmap <tuple<int, int, int, int> , ll > mult;\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < 4; j++)\n            cin >> c[i][j];\n\n        normalize(c[i]);\n\n        if (c[i][0] == c[i][1] && c[i][0] == c[i][2] && c[i][0] == c[i][3]) mult[mt(c[i])] = 4;\n        else if (c[i][0] == c[i][2] && c[i][1] == c[i][3]) mult[mt(c[i])] = 2;\n        else mult[mt(c[i])] = 1;\n\n        m[mt(c[i])]++;\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i+1; j < n; j++)\n        {\n            m[mt(c[i])]--;\n            m[mt(c[j])]--;\n\n            for (int k = 0; k < 4; k++)\n            {\n                ll res = 1;\n                int tile[4][4];\n                for (int l = 0; l < 4; l++)\n                {\n                    //cout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << m[make_tuple(6, 4, 5, 7)] << endl;\n                    tile[l][0] = c[i][l];\n                    tile[l][1] = c[j][(-l+7)%4];\n                    tile[l][2] = c[j][(-l+6)%4];\n                    tile[l][3] = c[i][(l+1)%4];\n                    normalize(tile[l]);\n\n                    res *= m[mt(tile[l])]* mult[mt(tile[l])];\n                    m[mt(tile[l])]--;\n                }\n                for (int l = 0; l < 4; l++)\n                    m[mt(tile[l])]++;\n\n                ans += res;\n                shift(c[j], 1);\n            }\n\n            m[mt(c[i])]++;\n            m[mt(c[j])]++;\n        }\n    }\n    cout << ans/3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&x[i][j]);\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[i][1],x[i][0],x[ii][mp[j][0]],x[ii][mp[j][1]]);\n                    y[1] = pack(x[i][0],x[i][3],x[ii][mp[j][3]],x[ii][mp[j][0]]);\n                    y[2] = pack(x[i][3],x[i][2],x[ii][mp[j][2]],x[ii][mp[j][3]]);\n                    y[3] = pack(x[i][2],x[i][1],x[ii][mp[j][1]],x[ii][mp[j][2]]);\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m.count(y[p])?m[y[p]]:0;\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            if(m.count(a[i]))m[a[i]]++;\n            else m[a[i]] = 1;\n        }\n        printf(\"%I64d\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    //sort(all(tmpVecs));\n    sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n;\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]= getWay(v);\n    }\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];\n                    /*tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];*/\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll ans;\nint n;\nstruct node{\n    int a1,a2,a3,a4;\n    node() {}\n    node(int aa1,int aa2,int aa3,int aa4):a1(aa1),a2(aa2),a3(aa3),a4(aa4) {}\n    bool operator <(const node &a) const {\n        if(a1!=a.a1)\n            return a1<a.a1;\n        if(a2!=a.a2)\n            return a2<a.a2;\n        if(a3!=a.a3)\n            return a3<a.a3;\n        return a4<a.a4;\n    }\n    bool operator ==(const node &a) const{\n        if(a1==a.a1&&a2==a.a2&&a3==a.a3&&a4==a.a4)\n            return 1;\n        return 0;\n    }\n}t[MAXN];\nmap<node,ll> used;\nvoid solve(int b1,int b2,int b3,int b4){\n    used[node(b1,b2,b3,b4)]++;\n}\nll check(node x,node y){\n    ll res=0;\n    if(x==y)\n        res++;\n    int tx=y.a1;\n    y.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n    if(x==y)\n        res++;\n    tx=y.a1;\n    y.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n    if(x==y)\n        res++;\n    tx=y.a1;\n    y.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n    if(x==y)\n        res++;\n    return res;\n}   \nvoid count(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8){\n    //PF(\"{%d %d %d %d %d %d %d %d}\\n\",b1,b2,b3,b4,b5,b6,b7,b8);\n    node x1=node(b1,b2,b6,b5);\n    node x2=node(b2,b3,b7,b6);\n    node x3=node(b3,b4,b8,b7);\n    node x4=node(b4,b1,b5,b8);\n    node sp1=node(b4,b3,b2,b1);\n    node sp2=node(b5,b6,b7,b8);\n    ll res1=used[x1];\n    ll res2=used[x2];\n    ll res3=used[x3];\n    ll res4=used[x4];\n    res1=res1-check(sp1,x1)-check(sp2,x1);\n    res2=res2-check(sp1,x2)-check(sp2,x2)-check(x1,x2);\n    res3=res3-check(sp1,x3)-check(sp2,x3)-check(x1,x3)-check(x2,x3);\n    res4=res4-check(sp1,x4)-check(sp2,x4)-check(x1,x4)-check(x2,x4)-check(x3,x4);\n    ans+=res1*res2*res3*res4;\n    //PF(\"{%lld %lld %lld %lld %lld}\\n\",used[x1],res1,check(sp1,x1),check(sp2,x1),res4);\n}\nint main(){\n    SF(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        SF(\"%d%d%d%d\",&t[i].a1,&t[i].a2,&t[i].a3,&t[i].a4);\n        solve(t[i].a4,t[i].a3,t[i].a2,t[i].a1);\n        solve(t[i].a3,t[i].a2,t[i].a1,t[i].a4);\n        solve(t[i].a2,t[i].a1,t[i].a4,t[i].a3);\n        solve(t[i].a1,t[i].a4,t[i].a3,t[i].a2);\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++){\n            count(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a4,t[j].a3,t[j].a2,t[j].a1); \n            count(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a3,t[j].a2,t[j].a1,t[j].a4); \n            count(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a2,t[j].a1,t[j].a4,t[j].a3); \n            count(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a1,t[j].a4,t[j].a3,t[j].a2); \n        }\n    PF(\"%lld\",ans/3ll);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n;\nvector<int> c[4][401];\n\nint fIdx[4][4] = {\n\t{1 + 4, 0, 3, 2 + 4},\n\t{1 + 4, 0 + 4, 1, 0},\n\t{1, 0 + 4, 3 + 4, 2},\n\t{3, 2, 3 + 4, 2 + 4}\n};\nmap< vector<int> , int > cnt;\n\n\nvoid addFace(vector<int> &v , int val) {\n\tfor (int it = 0 ; it < 4 ; ++it) {\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tcnt[v] += val;\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0 ; j < 4 ; ++j)c[j][i].resize(4);\n\t\tfor (int j = 0 ; j < 4 ; ++j) {\n\t\t\tscanf(\"%d\", &c[0][i][j]);\n\t\t}\n\t\tfor (int j = 1 ; j < 4; ++j) {\n\t\t\tc[j][i] = c[j - 1][i];\n\t\t\trotate(c[j][i].begin(), c[j][i].begin() + 1, c[j][i].end());\n\t\t}\n\t\tfor (int j = 0 ; j < 4 ; ++j)cnt[c[j][i]]++;\n\t}\n\tll res = 0;\n\tvector<int> myFace;\n\tmyFace.resize(4);\n\tfor (int i = 0 ; i < n ; ++i) {\n\t\tfor (int rt = 0 ; rt < 4 ; ++rt) {\n\t\t\tcnt[c[rt][i]]--;\n\t\t}\n\t\tfor (int j = i + 1 ; j < n ; ++j) {\n\t\t\tfor (int rt2 = 0 ; rt2 < 4 ; rt2++) {\n\t\t\t\tcnt[c[rt2][j]]--;\n\t\t\t}\n\t\t\tfor (int rt2 = 0 ; rt2 < 4 ; rt2++) {\n\t\t\t\tll ans =  1;\n\t\t\t\tvector< vector<int> > allFc;\n\t\t\t\tfor (int faces = 0; faces < 4 ; ++faces) {\n\t\t\t\t\tfor (int kk = 0 ; kk < 4 ; ++kk) {\n\t\t\t\t\t\tint idx = fIdx[faces][kk];\n\t\t\t\t\t\tmyFace[kk]=(idx >= 4 ? c[rt2][j][idx - 4] : c[0][i][idx]);\n\t\t\t\t\t}\n\t\t\t\t\tans *= cnt[myFace];\n\t\t\t\t\tif (ans == 0)break;\n\t\t\t\t\tallFc.push_back(myFace);\n\t\t\t\t\taddFace(myFace, -1);\n\t\t\t\t}\n\t\t\t\tfor (int p = 0; p < allFc.size(); ++p) {\n\t\t\t\t\taddFace(allFc[p], +1);\n\t\t\t\t}\n\t\t\t\tres += ans;\n\t\t\t}\n\t\t\tfor (int rt2 = 0 ; rt2 < 4 ; rt2++) {\n\t\t\t\tcnt[c[rt2][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 405\nusing namespace std;\ninline int read(){\n\tint ans=0;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans;\n}\nint n,col[N][4];\nll ans=0,mp[N][4];\nmap<ll,int>cnt;\ninline ll idx(int a,int b,int c,int d){return 1ll*a+1ll*b*1000+1ll*c*1000000+1ll*d*1000000000;}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i)for(int j=0;j<=3;++j)col[i][j]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tmp[i][0]=idx(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tmp[i][1]=idx(col[i][1],col[i][2],col[i][3],col[i][0]);\n\t\tmp[i][2]=idx(col[i][2],col[i][3],col[i][0],col[i][1]);\n\t\tmp[i][3]=idx(col[i][3],col[i][0],col[i][1],col[i][2]);\n\t\tfor(int j=0;j<4;++j)++cnt[mp[i][j]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<4;++j)--cnt[mp[i][j]];\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tif(i==j)continue;\n\t\t\tfor(int k=0;k<4;++k)--cnt[mp[j][k]];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tll tmp[16],ttmp=1;\n\t\t\t\ttmp[0]=idx(col[i][0],col[i][3],col[j][k],col[j][(k+3)%4]);\n\t\t\t\ttmp[4]=idx(col[j][(k+3)%4],col[i][0],col[i][3],col[j][k]);\n\t\t\t\ttmp[8]=idx(col[j][k],col[j][(k+3)%4],col[i][0],col[i][3]);\n\t\t\t\ttmp[12]=idx(col[i][3],col[j][k],col[j][(k+3)%4],col[i][0]);\n\t\t\t\ttmp[1]=idx(col[i][1],col[i][0],col[j][(k+3)%4],col[j][(k+2)%4]);\n\t\t\t\ttmp[5]=idx(col[j][(k+2)%4],col[i][1],col[i][0],col[j][(k+3)%4]);\n\t\t\t\ttmp[9]=idx(col[j][(k+3)%4],col[j][(k+2)%4],col[i][1],col[i][0]);\n\t\t\t\ttmp[13]=idx(col[i][0],col[j][(k+3)%4],col[j][(k+2)%4],col[i][1]);\n\t\t\t\ttmp[2]=idx(col[i][2],col[i][1],col[j][(k+2)%4],col[j][(k+1)%4]);\n\t\t\t\ttmp[6]=idx(col[j][(k+1)%4],col[i][2],col[i][1],col[j][(k+2)%4]);\n\t\t\t\ttmp[10]=idx(col[j][(k+2)%4],col[j][(k+1)%4],col[i][2],col[i][1]);\n\t\t\t\ttmp[14]=idx(col[i][1],col[j][(k+2)%4],col[j][(k+1)%4],col[i][2]);\n\t\t\t\ttmp[3]=idx(col[i][3],col[i][2],col[j][(k+1)%4],col[j][k]);\n\t\t\t\ttmp[7]=idx(col[j][k],col[i][3],col[i][2],col[j][(k+1)%4]);\n\t\t\t\ttmp[11]=idx(col[j][(k+1)%4],col[j][k],col[i][3],col[i][2]);\n\t\t\t\ttmp[15]=idx(col[i][2],col[j][(k+1)%4],col[j][k],col[i][3]);\n\t\t\t\tif(cnt[tmp[0]]==0||cnt[tmp[1]]==0||cnt[tmp[2]]==0||cnt[tmp[3]]==0)continue;\n\t\t\t\tfor(int l=0;l<4;++l){\n\t\t\t\t\tttmp*=cnt[tmp[l]];\n\t\t\t\t\tfor(int m=l;m<16;m+=4)--cnt[tmp[m]];\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<16;++l)++cnt[tmp[l]];\n\t\t\t\tans+=ttmp;\n\t\t\t}\n\t\t\tfor(int k=0;k<4;++k)++cnt[mp[j][k]];\n\t\t}\n\t\tfor(int j=0;j<4;++j)++cnt[mp[i][j]];\n\t}\n\tcout<<ans/3;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin>>n)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)cin>>x[i][j];\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[i][1],x[i][0],x[ii][mp[j][0]],x[ii][mp[j][1]]);\n                    y[1] = pack(x[i][0],x[i][3],x[ii][mp[j][3]],x[ii][mp[j][0]]);\n                    y[2] = pack(x[i][3],x[i][2],x[ii][mp[j][2]],x[ii][mp[j][3]]);\n                    y[3] = pack(x[i][2],x[i][1],x[ii][mp[j][1]],x[ii][mp[j][2]]);\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m[y[p]];\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            m[a[i]]++;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nURL https://\nSCORE 0\nAC false\nWA false\nTLE false\nMLE false\nTASK_TYPE\nFAILURE_TYPE\nNOTES\n*/\n#include <iostream>\n#include <cstdint>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <limits>\n#include <numeric>\n#include <iomanip>\n#include <type_traits>\n\nusing namespace std;\n\n// Type aliases\nusing i8  =  int8_t; using  u8 =  uint8_t;\nusing i16 = int16_t; using u16 = uint16_t;\nusing i32 = int32_t; using u32 = uint32_t;\nusing i64 = int64_t; using u64 = uint64_t;\n\ntemplate <class T> using V = vector<T>;\n\n// Loops\n#define REP(i, n) for (i64 i = 0; i < static_cast<decltype(i)>(n); ++i)\n#define REPR(i, n) for (i64 i = (n) - 1; i >= static_cast<decltype(i)>(0); --i)\n#define FOR(i, n, m) for (i64 i = (n); i < static_cast<decltype(i)>(m); ++i)\n#define FORR(i, n, m) for (i64 i = (m) - 1; i >= static_cast<decltype(i)>(n); --i)\n\n#define FORE(x, xs) for (auto &x: (xs))\n\n// Macros\n#define CTR(x) (x).begin(), (x).end()\n\n// Utils for Tuple\nnamespace tuple_utils {\n    template<size_t...> struct seq{};\n\n    template<size_t N, size_t... Is>\n    struct gen_seq : gen_seq<N - 1, N - 1, Is...>{};\n\n    template<size_t... Is>\n    struct gen_seq<0, Is...> : seq<Is...>{};\n\n    template <class Tuple, size_t... Is>\n    void read(istream &stream, Tuple &t, seq<Is...>) {\n        static_cast<void>((int[]){0, (void(stream  >> get<Is>(t)), 0)...});\n    }\n\n    template<class Tuple, size_t... Is>\n    void print(ostream& stream, Tuple const& t, seq<Is...>) {\n        static_cast<void>((int[]){0, (void(stream << (Is == 0 ?  \"\" : \", \") << get<Is>(t)), 0)...});\n    }\n\n    template <size_t I, class F, class A, class... Elems>\n    struct ForEach {\n        void operator()(A &arg, tuple<Elems...> const& t) const {\n            F()(arg, get<I>(t));\n            ForEach<I - 1, F, A, Elems...>()(arg, t);\n        };\n        void operator()(A &arg, tuple<Elems...>& t) const {\n            F()(arg, get<I>(t));\n            ForEach<I - 1, F, A, Elems...>()(arg, t);\n        };\n    };\n    template <class F, class A, class... Elems>\n    struct ForEach<0, F, A, Elems...> {\n        void operator()(A &arg, tuple<Elems...> const& t) const {\n            F()(arg, get<0>(t));\n        };\n        void operator()(A &arg, tuple<Elems...>& t) const {\n            F()(arg, get<0>(t));\n        };\n    };\n    template <class F, class A, class... Elems>\n    void for_each(A &arg, tuple<Elems...> const& t) {\n        ForEach<tuple_size<tuple<Elems...>>::value - 1, F, A, Elems...>()(arg, t);\n    };\n    template <class F, class A, class... Elems>\n    void for_each(A &arg, tuple<Elems...>& t) {\n        ForEach<tuple_size<tuple<Elems...>>::value - 1, F, A, Elems...>()(arg, t);\n    };\n\n    struct hash_for_element {\n        template <class V>\n        void operator()(size_t &size, const V& v) const {\n            size ^= hash<V>()(v);\n        }\n    };\n}\n\n// STL support\ntemplate <class Iterator>\nstruct Container {\n    Container(const Iterator &begin, const Iterator &end) : m_begin(begin), m_end(end) {}\n    const Iterator& begin() const {\n        return this->m_begin;\n    }\n    const Iterator& end() const {\n        return this->m_end;\n    }\n    Iterator m_begin;\n    Iterator m_end;\n};\n\ntemplate <class Functions>\nstruct BaseIterator {\n    using State = typename Functions::State;\n\n    BaseIterator(const State &state, const Functions &func) : state(state), func(func) {\n        while (!this->is_end() && !this->is_valid()) {\n            this->next();\n        }\n    }\n    BaseIterator(const State &state) : state(state), func() {\n        while (!this->is_end() && !this->is_valid()) {\n            this->next();\n        }\n    }\n\n    decltype(auto) operator*() {\n        return this->func.get_value(this->state);\n    }\n\n    decltype(auto) operator*() const {\n        return this->func.get_value(this->state);\n    }\n\n    BaseIterator &operator++() {\n        if (this->is_end()) {\n            return *this;\n        }\n\n        this->next();\n        while (!this->is_end() && !this->is_valid()) {\n            this->next();\n        }\n\n        return *this;\n    }\n\n    BaseIterator &operator--() {\n        if (this->is_begin()) {\n            return *this;\n        }\n\n        this->previous();\n        while (!this->is_begin() && !this->is_valid()) {\n            this->previous();\n        }\n\n        return *this;\n    }\n\n    bool operator==(const BaseIterator<Functions> &rhs) const {\n        return this->state == rhs.state;\n    }\n    bool operator!=(const BaseIterator<Functions> &rhs) const {\n        return !(*this == rhs);\n    }\n\n    bool is_begin() const {\n        return this->func.is_begin(this->state);\n    }\n    bool is_end() const {\n        return this->func.is_end(this->state);\n    }\n    const State &get_state() const {\n        return this->state;\n    }\nprivate:\n    bool is_valid() const {\n        return this->func.is_valid(this->state);\n    }\n    void next() {\n        this->func.next(this->state);\n    }\n    void previous() {\n        this->func.previous(this->state);\n    }\n    State state;\n    Functions func;\n};\n\n// Input\ntemplate <class F, class S>\nistream &operator>>(istream &stream, pair<F, S> &pair) {\n    stream >> pair.first;\n    stream >> pair.second;\n    return stream;\n}\ntemplate <class ...Args>\nistream &operator>>(istream &stream, tuple<Args...> &tuple) {\n    tuple_utils::read(stream, tuple, tuple_utils::gen_seq<sizeof...(Args)>());\n    return stream;\n}\n\ntemplate <class T>\nT read() {\n    T t;\n    cin >> t;\n    return t;\n}\ntemplate <class F, class S>\npair<F, S> read() {\n    pair<F, S> p;\n    cin >> p;\n    return p;\n}\ntemplate <class T1, class T2, class T3, class ...Args>\ntuple<T1, T2, T3, Args...> read() {\n    tuple<T1, T2, T3, Args...> t;\n    cin >> t;\n    return t;\n}\n\ntemplate <class T>\nV<T> read(const int length) {\n    V<T> ts(length);\n    for (auto& t: ts) {\n        cin >> t;\n    }\n    return ts;\n}\ntemplate <class F, class S>\nV<pair<F, S>> read(const int length) {\n    V<pair<F, S>> ps(length);\n    for (auto& p: ps) {\n        cin >> p;\n    }\n    return ps;\n}\ntemplate <class T1, class T2, class T3, class ...Args>\nV<tuple<T1, T2, T3, Args...>> read(const int length) {\n    V<tuple<T1, T2, T3, Args...>> ts(length);\n    for (auto& t: ts) {\n        cin >> t;\n    }\n    return ts;\n}\n\n// Output\nnamespace debug {\n    template <class F, class S>\n    ostream &operator<<(ostream& stream, const pair<F, S> &pair) {\n        stream << \"{\" << pair.first << \", \" << pair.second << \"}\";\n        return stream;\n    }\n    template <class ...Args>\n    ostream &operator<<(ostream& stream, const tuple<Args...> &tuple) {\n        stream << \"{\";\n        tuple_utils::print(stream, tuple, tuple_utils::gen_seq<sizeof...(Args)>());\n        stream << \"}\";\n        return stream;\n    }\n\n    template <class Iterator>\n    Container<Iterator> container(const Iterator &begin, const Iterator &end) {\n        return Container<Iterator>(begin, end);\n    }\n\n    template <class Iterator>\n    ostream &operator<<(ostream &stream, const Container<Iterator> &container) {\n        stream << \"[\";\n\n        size_t cnt = 0;\n        for (const auto &it: container) {\n            stream << it;\n            stream << \",\" << ((cnt % 10 == 9) ? \"\\n \" : \"\\t\");\n\n            cnt += 1;\n        }\n\n        stream << \"\\b\\b]\";\n        return stream;\n    }\n\n    template <class T, class Alloc>\n    ostream &operator<<(ostream& stream, const vector<T, Alloc> &vector) {\n        return stream << container(vector.begin(), vector.end());\n    }\n}\n\n// Hash\nnamespace std {\n    template <class F, class S>\n    struct hash<pair<F, S>> {\n        size_t operator ()(const pair<F, S> &p) const {\n            return hash<F>()(p.first) ^ hash<S>()(p.second);\n        }\n    };\n\n    template <class ...Args>\n    struct hash<tuple<Args...>> {\n        size_t operator ()(const tuple<Args...> &t) const {\n            size_t retval = 0;\n\n            tuple_utils::for_each<tuple_utils::hash_for_element, size_t, Args...>(retval, t);\n\n            return retval;\n        }\n    };\n}\n#define MAIN\nvoid body();\n\n// main function (DO NOT EDIT)\nint main (int argc, char **argv) {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    cout << fixed;\n    body();\n\n    return 0;\n}\n\n#include <cmath>\n\n#include <map>\nvoid body() {\n    using namespace debug;\n    auto N = read<i64>();\n    auto Cs = V<V<i64>>(N);\n    REP (i, N) {\n        Cs[i] = read<i64>(4);\n    }\n\n    // 頂点の色情報をu64にエンコード\n    auto encode = [&](const V<i64> &ps) {\n        V<u64> xs;\n        REP (k, 4) {\n            u64 id = 0;\n            REP (i, 4) {\n                id += ps[(i + k) % 4] * std::pow(1000, i);\n            }\n            xs.push_back(id);\n        }\n        sort(CTR(xs));\n        return xs;\n    };\n    auto rotate = [&](const V<u64> ids) {\n        if (ids.front() == ids.back()) {\n            return 4;\n        }\n        if (ids.front() == ids[1]) {\n            return 2;\n        }\n        return 1;\n    };\n\n    // 各カードの色、色ごとの登場回数を前計算\n    auto color_ids = V<u64>(N);\n    map<u64, i64> colors;\n    REP (i, N) {\n        auto xs = encode(Cs[i]);\n        color_ids[i] = xs.front();\n\n        if (colors.find(xs.front()) == colors.end()) {\n            colors.insert({xs.front(), i64(0)});\n        }\n\n        colors[xs.front()] += 1;\n    }\n\n    u64 ans = 0;\n    REP (A, N - 1) { // Aを固定\n        FOR(B, A + 1, N) { // Bを固定\n            REP (k, 4) { // Bの回転方向を固定\n                // 側面の色が決まっているので調査\n                auto s1 = encode({Cs[A][1], Cs[B][(0+k)%4], Cs[B][(3+k)%4], Cs[A][2]});\n                auto s2 = encode({Cs[A][0], Cs[B][(1+k)%4], Cs[B][(0+k)%4], Cs[A][1]});\n                auto s3 = encode({Cs[B][(1+k)%4], Cs[A][0], Cs[A][3], Cs[B][(2+k)%4]});\n                auto s4 = encode({Cs[A][3], Cs[A][2], Cs[B][(3+k)%4], Cs[B][(2+k)%4]});\n\n                auto id1 = s1.front();\n                auto id2 = s2.front();\n                auto id3 = s3.front();\n                auto id4 = s4.front();\n\n                unordered_map<u64, size_t> Ns;\n                Ns.reserve(4);\n                Ns[id1] += 1;\n                Ns[id2] += 1;\n                Ns[id3] += 1;\n                Ns[id4] += 1;\n\n                auto get_num = [&](u64 id) {\n                    auto n = colors[id];\n                    if (color_ids[A] == id) {\n                        n -= 1;\n                    }\n                    if (color_ids[B] == id) {\n                        n -= 1;\n                    }\n                    return n;\n                };\n\n                // 重複で場合分け\n                i64 num = 0;\n                auto ns = V<pair<u64, size_t>>(CTR(Ns));\n                sort(CTR(ns), [](auto &rhs, auto &lhs) { return rhs.second > lhs.second; });\n                if (ns.front().second == 4) {\n                    // X X X X\n                    auto num_X = get_num(ns[0].first);\n                    num = num_X * (num_X - 1) * (num_X - 2) * (num_X - 3);\n                } else if (ns.front().second == 3) {\n                    // X X X Y\n                    auto num_X = get_num(ns.front().first);\n                    auto num_Y = get_num(ns[1].first);\n\n                    num = num_X * (num_X - 1) * (num_X - 2) * num_Y;\n                } else if (ns.front().second == 2 && ns[1].second == 2) {\n                    // X X Y Y\n                    auto num_X = get_num(ns[0].first);\n                    auto num_Y = get_num(ns[1].first);\n\n                    num = num_X * (num_X - 1) * num_Y * (num_Y - 1);\n                } else if (ns.front().second == 2 && ns[1].second == 1) {\n                    // X X Y Z\n                    auto num_X = get_num(ns[0].first);\n                    auto num_Y = get_num(ns[1].first);\n                    auto num_Z = get_num(ns[2].first);\n\n                    num = num_X * (num_X - 1) * num_Y * num_Z;\n                } else {\n                    // X Y Z W\n                    auto num_X = get_num(ns[0].first);\n                    auto num_Y = get_num(ns[1].first);\n                    auto num_Z = get_num(ns[2].first);\n                    auto num_W = get_num(ns[3].first);\n\n                    num = num_X * num_Y * num_Z * num_W;\n                }\n                num = std::max(i64(0), num);\n\n                // 回転を考慮\n                num *= rotate(s1);\n                num *= rotate(s2);\n                num *= rotate(s3);\n                num *= rotate(s4);\n\n                ans += num;\n            }\n        }\n    }\n\n    // 数え方から、同じ立方体を3回数えている\n    // （最初に決めるA,B(=対面の組み合わせ)はA<Bより3パターン）\n    cout << (ans / 3) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define uint unsigned long long\n#define ll long long\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define eps 1e-9\n\nusing namespace std;\nconst db pi = acos(-1.0);\ninline int read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\n#define Node(a, b, c, d) mp(a,mp(b,mp(c,d)))\nmap <pair<int, pair<int, pii> >, ll> cnt;\nconst int N = 500;\n\nint A[N][4];\nint n, num[4];\n\nvoid fz(pair<int, pair<int,pii> > t)\n{\n    num[0] = t.X;\n    num[1] = t.Y.X;\n    num[2] = t.Y.Y.X;\n    num[3] = t.Y.Y.Y;\n}\n\npair<int, pair<int,pii> > stand(pair<int, pair<int,pii> > t)\n{\n    fz(t);\n    pair<int, pair<int,pii> > tmp[4];\n    rep(s, 0, 3)\n        tmp[s] = Node(num[(s + 0) % 4], num[(s + 1) % 4], num[(s + 2) % 4], num[(s + 3) % 4]);\n    sort(tmp, tmp + 4);\n    return tmp[0];\n\n}\n\nvoid update(int id,int val)\n{\n    pair<int, pair<int,pii> > now = stand(Node(A[id][0], A[id][1], A[id][2], A[id][3]));\n    cnt[now] += val;\n}\n\nint cal(pair<int, pair<int,pii> > t)\n{\n     fz(t);\n    pair<int, pair<int,pii> > tmp[4];\n    rep(s, 0, 3) tmp[s] = Node(num[(s + 0) % 4], num[(s + 1) % 4], num[(s + 2) % 4], num[(s + 3) % 4]);\n    int c = 0;\n    rep(s, 0, 3) if(tmp[s] == tmp[0]) c ++;\n    return c;\n\n}\n\nint main()\n{\n    n = read();\n    rep(i, 1, n)\n    {\n        rep(j, 0, 3) A[i][j] = read();\n        update(i, 1);\n    }\n\n    ll res = 0;\n    rep(i, 1, n)\n    {\n        update(i, -1);\n        rep(j, i + 1, n)\n        {\n            update(j, -1);\n            int Down[4];\n            rep(x, 0, 3) Down[x] = A[i][x];\n            int Up[4];\n            rep(us, 0, 3)\n            {\n            \trep(y, 0, 3) Up[y] = A[j][(us - y + 4) % 4];\n                ll now = 1;\n                pair<int, pair<int,pii> > X[4];\n                rep(k, 0, 3)\n                {\n                    X[k] = stand(Node(Down[k], Up[k], Up[(k + 1) % 4], Down[(k + 1) % 4]));\n                    ll num = cal(X[k]);\n                    now *= num * cnt[X[k]];\n                    cnt[X[k]] --;\n                }\n\n                res += now;\n\t \trep(k, 0, 3) cnt[X[k]] ++;\n            }\n            update(j, 1);\n        }\n        update(i, 1);\n    }\n    printf(\"%lld\\n\",res / 3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(405);\ntypedef long long int LL;\n\nstruct val\n{\n\tval(const int &v0 = 0, const int &v1 = 0, const int &v2 = 0, const int &v3 = 0)\n\t{\n\t\tv[0] = v0, v[1] = v1, v[2] = v2, v[3] = v3;\n\t}\n\tint v[4];\n\tinline bool operator<(const val &b) const\n\t{\n\t\tfor (int i = 0;i < 4;++i)\n\t\t\tif (v[i] != b.v[i])\n\t\t\t\treturn v[i] < b.v[i];\n\t\treturn false;\n\t}\n\tval getnext() const\n\t{\n\t\tval x;\n\t\tfor (int i = 0;i < 3;++i)\n\t\t\tx.v[i] = v[i + 1];\n\t\tx.v[3] = v[0];\n\t\treturn x;\n\t}\n};\nint N;\nval V[Max_N];\nmap<val, LL> G, F;\nLL Ans;\n\nvoid insert(map<val, LL> &H, val x, int v = +1)\n{\n\tfor (int i = 0;i < 4;++i, x = x.getnext())\n\t\tH[x] += v;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 0;j < 4;++j)\n\t\t\tscanf(\"%d\", &V[i].v[j]);\n\tfor (int j = N;j >= 1;--j)\n\t{\n\t\tF = G;\n\t\tfor (int i = j - 1;i >= 1;--i)\n\t\t{\n\t\t\tval up = V[i], dn = V[j], a, b, c, d;\n\t\t\tfor (int k = 0;k < 4;++k, dn = dn.getnext())\n\t\t\t{\n\t\t\t\tLL Ret(1LL);\n\t\t\t\tif (F[a = val(up.v[3], up.v[2], dn.v[3], dn.v[2])] == 0)\n\t\t\t\t\tgoto loop;\n\t\t\t\tRet *= F[a], insert(F, a, -1);\n\t\t\t\tif (F[b = val(up.v[2], up.v[1], dn.v[0], dn.v[3])] == 0)\n\t\t\t\t{\n\t\t\t\t\tinsert(F, a);\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\t\t\t\tRet *= F[b], insert(F, b, -1);\n\t\t\t\tif (F[c = val(up.v[1], up.v[0], dn.v[1], dn.v[0])] == 0)\n\t\t\t\t{\n\t\t\t\t\tinsert(F, a), insert(F, b);\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\t\t\t\tRet *= F[c], insert(F, c, -1);\n\t\t\t\tif (F[d = val(up.v[0], up.v[3], dn.v[2], dn.v[1])] == 0)\n\t\t\t\t{\n\t\t\t\t\tinsert(F, a), insert(F, b), insert(F, c);\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\t\t\t\tRet *= F[d], insert(F, d, -1);\n\t\t\t\tAns += Ret, insert(F, a), insert(F, b), insert(F, c), insert(F, d);\n\t\t\t\tloop :\n\t\t\t\t;\n\t\t\t}\n\t\t\tinsert(F, V[i]);\n\t\t}\n\t\tinsert(G, V[j]);\n\t}\n\tprintf(\"%lld\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst LL A=1000,B=1000000,C=1000000000ll;\nint col[410][4];\nLL num[4];\nunordered_map<LL,LL> cnt;\n\nLL gethash(int x1,int x2,int x3,int x4){return x1+A*x2+B*x3+C*x4;}\n\nvoid add(int x1,int x2,int x3,int x4,int k)\n{\n\tcnt[gethash(x1,x2,x3,x4)]+=k;\n\tcnt[gethash(x2,x3,x4,x1)]+=k;\n\tcnt[gethash(x3,x4,x1,x2)]+=k;\n\tcnt[gethash(x4,x1,x2,x3)]+=k;\n}\n\nvoid add(LL x,int k)\n{\n\tint x1=x%A;x/=A;\n\tint x2=x%A;x/=A;\n\tint x3=x%A;x/=A;\n\tint x4=x%A;x/=A;\n\tadd(x1,x2,x3,x4,k);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tadd(col[i][0],col[i][1],col[i][2],col[i][3],1);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(col[i][0],col[i][1],col[i][2],col[i][3],-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tadd(col[j][0],col[j][1],col[j][2],col[j][3],-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<4;l++) num[l]=gethash(col[i][l],col[j][(k+5-l)&3],col[j][(k+4-l)&3],col[i][(l+1)&3]);\n\t\t\t\tif(!cnt[num[0]]||!cnt[num[1]]||!cnt[num[2]]||!cnt[num[3]]) continue;\n\t\t\t\tLL res=1;\n\t\t\t\tfor(int l=0;l<4;l++) res*=cnt[num[l]],add(num[l],-1);\n\t\t\t\tfor(int l=0;l<4;l++) add(num[l],1);\n\t\t\t\tans+=res;\n\t\t\t}\n\t\t\tadd(col[j][0],col[j][1],col[j][2],col[j][3],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n;\nusing Panel = array<int, 4>;\n\nPanel rotate(Panel a) {\n  tie(a[0], a[1], a[2], a[3]) = make_tuple(a[1], a[2], a[3], a[0]);\n  return a;\n}\n\nPanel normalize(Panel a) {\n  Panel p[4];\n  for(int i = 0; i < 4; i++) {\n    p[i] = a;\n    a = rotate(a);\n  }\n  return *min_element(p, p + 4);\n}\n\nconst int N = 400;\n\nint rotcount(Panel a) {\n  auto b = a;\n  int res = 0;\n  for(int i = 0; i < 4; i++) {\n    b = rotate(b);\n    if(a == b) res++;\n  }\n  return res;\n}\n\nll fact[10];\nll comb[N + 1][N + 1];\n\nPanel a[N];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n\n  map<Panel, int> cnt;\n  for(int i = 0; i < n; i++) {\n    cin >> a[i][0] >> a[i][1] >> a[i][2] >> a[i][3];\n    a[i] = normalize(a[i]);\n    cnt[a[i]]++;\n  }\n\n  comb[0][0] = 1;\n\n  for(int i = 1; i <= n; i++) for(int j = 0; j <= n; j++) {\n    // Pascal's identity\n    if(j == 0) {\n      comb[i][j] = 1;\n      continue;\n    }\n    comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n  }\n\n  fact[0] = 1;\n  for(int i = 1; i <= 9; i++) fact[i] = fact[i-1] * i;\n\n  ll ans = 0;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    for(int rot = 0; rot < 4; rot++) {\n      a[i] = rotate(a[i]);\n      map<Panel, int> target;\n      for(int k = 0; k < 4; k++) {\n        Panel f{a[i][(k + 1) % 4], a[i][k + 0], a[j][(4 - k) % 4], a[j][(3 - k) % 4]};\n        f = normalize(f);\n        target[f]++;\n      }\n\n      int ng = 0;\n      ll res = 1;\n      for(auto &p : target) {\n        Panel pan;\n        int tar;\n        tie(pan, tar) = p;\n        int c = cnt[pan] - (pan == a[i]) - (pan == a[j]);\n        if(c < tar) {ng = 1; break;}\n        res *= comb[c][tar] * pow((ll) rotcount(pan), (ll) tar) * fact[tar];\n      }\n      if(ng) continue;\n      ans += res;\n    }\n  }\n  assert(ans % 3 == 0);\n  cout << ans/3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nlong long calc(int a, int b, int c, int d){\n\tlong long r = 1024 * a + b;\n\tr = 1024 * r + c;\n\treturn 1024 * r + d;\n}\n\nlong long pack(int a, int b, int c, int d){\n\treturn min(min(calc(a, b, c, d), calc(b, c, d, a)), min(calc(c, d, a, b), calc(d, a, b, c)));\n}\n\nint getR(long long key){\n\tint c[4];\n\tfor(int i=0;i<4;i++){\n\t\tc[i] = key%1024;\n\t\tkey /= 1024;\n\t}\n\tif(c[0] == c[1] && c[1] == c[2] && c[2] == c[3]) return 4;\n\tif(c[0] == c[2] && c[1] == c[3]) return 2;\n\treturn 1;\n}\n\nlong long pow(int a, int p){\n\tlong long r = 1;\n\tfor(int i=0;i<p;i++) r *= a;\n\treturn r;\n}\n\nlong long fact(int f){\n\tlong long r = 1;\n\tfor(int i=2;i<=f;i++) r *= i;\n\treturn r;\n}\n\nint main(){\n\tint N;\n\tstatic int c[1000][4];\n\twhile(cin >> N && N){\n\t\tmap<long long, int> num;\n\t\tlong long res = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<4;j++) cin >> c[i][j];\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tconst int* back = c[j];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tlong long key[4];\n\t\t\t\t\tkey[0] = pack(back[(k+1)%4], back[(k+0)%4], c[i][1], c[i][0]);\n\t\t\t\t\tkey[1] = pack(back[(k+0)%4], back[(k+3)%4], c[i][2], c[i][1]);\n\t\t\t\t\tkey[2] = pack(back[(k+3)%4], back[(k+2)%4], c[i][3], c[i][2]);\n\t\t\t\t\tkey[3] = pack(back[(k+2)%4], back[(k+1)%4], c[i][0], c[i][3]);\n\t\t\t\t\tsort(key, key+4);\n\t\t\t\t\tlong long backKey = pack(back[0], back[1], back[2], back[3]);\n\t\t\t\t\tlong long add = 1;\n\t\t\t\t\tfor(int l=0;l<4;){\n\t\t\t\t\t\tint cnt = 1;\n\t\t\t\t\t\tfor(int m=l+1;m<4 && key[l]==key[m];m++) ++cnt;\n\t\t\t\t\t\tint need = cnt;\n\t\t\t\t\t\tif(key[l] == backKey) ++need;\n\t\t\t\t\t\tif(num.count(key[l]) && num[key[l]] >= need){\n\t\t\t\t\t\t\tadd *= pow(getR(key[l]), cnt) * fact(cnt);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadd = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl += cnt;\n\t\t\t\t\t}\n\t\t\t\t\tres += add;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long k = pack(c[i][0], c[i][1], c[i][2], c[i][3]);\n\t\t\tif(num.count(k)) ++num[k];\n\t\t\telse num[k] = 1;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    map<C, int> P;\n    map<C, int> R;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        R[x] = rot(x);\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        P[p]--;\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            P[q]--;\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k+l+1),get(q,k+l)}});\n                    int opts = P[u[l]];\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*R[u[l]];\n                    }\n                    P[u[l]]--;\n                }\n                for (int l = 0; l < 4; l++) {\n                    P[u[l]]++;\n                }\n                ans += cur;\n            }\n            P[q]++;\n        }\n        P[p]++;\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nmap<vi,int> ma;\nmap<vi,int> rotar;\nvi A[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvi V; \n\t\tfor(int j=0;j<4;j++){int x; cin>>x; V.pb(x);} \n\t\tA[i]=V;\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tma[V]++;\n\t\t\tV.pb(*V.begin()); V.erase(V.begin());\n\t\t}\n\t}\n\tfor(auto X:ma)\n\t{\n\t\tvi v=X.fi; vi ori=v; int cnt=0;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tv.pb(*v.begin()); v.erase(v.begin());\n\t\t\tif(v==ori) cnt++;\n\t\t}\n\t\trotar[v]=cnt;\n\t}\n\tll ans = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tvi a = A[i];\n\t\t\tvi b = A[j];\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tma[a]--; ma[b]--;\n\t\t\t\ta.pb(*a.begin()); a.erase(a.begin());\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tvi F[4];\n\t\t\t\tF[0] = {a[0],b[1],b[0],a[1]};\n\t\t\t\tF[1] = {a[3],a[2],b[3],b[2]};\n\t\t\t\tF[2] = {b[1],a[0],a[3],b[2]};\n\t\t\t\tF[3] = {a[1],b[0],b[3],a[2]};\n\t\t\t\tif(!ma[F[0]]||!ma[F[1]]||!ma[F[2]]||!ma[F[3]]) {b.pb(*b.begin()); b.erase(b.begin()); continue;}\n\t\t\t\tll res = 1;\n\t\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\t{\n\t\t\t\t\tres*=ma[F[z]];\n\t\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[F[z]]--;\n\t\t\t\t\t\tF[z].pb(*F[z].begin()); F[z].erase(F[z].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[F[z]]++;\n\t\t\t\t\t\tF[z].pb(*F[z].begin()); F[z].erase(F[z].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += res;\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tma[a]++; ma[b]++;\n\t\t\t\ta.pb(*a.begin()); a.erase(a.begin());\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return calc(a[0],a[1],a[2],a[3])|(a[4]<<40)|(a[5]<<50);\n  };\n\n  vector<set<Int> > used(1<<20);\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused[(b[7]<<10)|b[6]].emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used[(a[7]<<10)|a[6]].count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nmap<piipii, int> dp;\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[p]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[p]--;\n        p = rotate(p);\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    double ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p1 = c[i];\n            for(int k=0;k<4;k++){\n                del(p1);\n                piipii p2 = c[j];\n                for(int l=0;l<4;l++){\n                    del(p2);\n\n                    double res = 1;\n                    piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                    piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                    piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                    piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                    if(dp.find(tmp1) != dp.end()){\n                        res *= dp[tmp1];\n                        del(tmp1);\n                    }\n                    else res = 0;\n                    if(dp.find(tmp2) != dp.end()){\n                        res *= dp[tmp2];\n                        del(tmp2);\n                    }\n                    else res = 0;\n                    if(dp.find(tmp3) != dp.end()){\n                        res *= dp[tmp3];\n                        del(tmp3);\n                    }\n                    else res = 0;\n                    if(dp.find(tmp4) != dp.end()){\n                        res *= dp[tmp4];\n                        del(tmp4);\n                    }\n                    else res = 0;\n\n                    ans += res;\n\n                    if(dp.find(tmp1) != dp.end()){\n                        add(tmp1);\n                    }\n                    if(dp.find(tmp2) != dp.end()){\n                        add(tmp2);\n                    }\n                    if(dp.find(tmp3) != dp.end()){\n                        add(tmp3);\n                    }\n                    if(dp.find(tmp4) != dp.end()){\n                        add(tmp4);\n                    }\n                    \n                    add(p2);\n                    p2 = rotate(p2);\n                }\n\n                add(p1);\n                p1 = rotate(p1);\n            }\n        }\n    }\n    printf(\"%.0lf\\n\", ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n#include <stack>\n#include <string>\n#define SIZE 405\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\ntypedef pair <P,P> PP;\n\nint C[SIZE][4];\nmap <PP,int> mp;\n\nvoid rem(int a,int b,int c,int d)\n{\n\tmp[PP(P(a,b),P(c,d))]--;\n\tmp[PP(P(b,c),P(d,a))]--;\n\tmp[PP(P(c,d),P(a,b))]--;\n\tmp[PP(P(d,a),P(b,c))]--;\n}\nvoid remp(PP p)\n{\n\trem(p.first.first,p.first.second,p.second.first,p.second.second);\n}\nvoid ins(int a,int b,int c,int d)\n{\n\tmp[PP(P(a,b),P(c,d))]++;\n\tmp[PP(P(b,c),P(d,a))]++;\n\tmp[PP(P(c,d),P(a,b))]++;\n\tmp[PP(P(d,a),P(b,c))]++;\n}\nvoid insp(PP p)\n{\n\tins(p.first.first,p.first.second,p.second.first,p.second.second);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d %d %d %d\",&C[i][0],&C[i][1],&C[i][2],&C[i][3]);\n\tvector <PP> vx;\n\tll ret=0;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tfor(int j=0;j<vx.size();j++)\n\t\t{\n\t\t\tPP p=vx[j];\n\t\t\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\t\t\trem(a,b,c,d);\n\t\t\tPP x=PP(P(C[i][0],C[i][1]),P(b,a));\n\t\t\tPP y=PP(P(C[i][1],C[i][2]),P(c,b));\n\t\t\tPP z=PP(P(C[i][2],C[i][3]),P(d,c));\n\t\t\tPP w=PP(P(C[i][3],C[i][0]),P(a,d));\n\t\t\tll all=1;\n\t\t\tall*=(ll) mp[x];\n\t\t\tremp(x);\n\t\t\tall*=(ll) mp[y];\n\t\t\tremp(y);\n\t\t\tall*=(ll) mp[z];\n\t\t\tremp(z);\n\t\t\tall*=(ll) mp[w];\n\t\t\tinsp(x);insp(y);insp(z);\n\t\t\t//if(i==1&&a==1&&b==1&&c==0&&d==0) printf(\"%d : %d %d %d %d : %d %d %d %d : %lld\\n\",i,a,b,c,d,mp[x],mp[y],mp[z],mp[w],all);\n\t\t\tret+=all;\n\t\t\tins(a,b,c,d);\n\t\t}\n\t\tint a=C[i][0],b=C[i][3],c=C[i][2],d=C[i][1];\n\t\tins(a,b,c,d);\n\t\tvx.push_back(PP(P(a,b),P(c,d)));\n\t\tvx.push_back(PP(P(b,c),P(d,a)));\n\t\tvx.push_back(PP(P(c,d),P(a,b)));\n\t\tvx.push_back(PP(P(d,a),P(b,c)));\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t#if 1\n\tint n; cin >> n;\n\tvector<vi> c(n, vi(4));\n\trep(i, n) rep(j, 4) cin >> c[i][j];\n\t#else\n\tint n = 400;\n\tvector<vi> c(n, vi(4));\n\t//673205187207168000\n\t#endif\n\tll ans = 0;\n\tmap<vi, int> cnt;\n\tauto norm = [](const vi &v){\n\t\tvector<vi> u;\n\t\trep(j, 4){\n\t\t\tu.pb({v[j], v[(j + 1) % 4], v[(j + 2) % 4], v[(j + 3) % 4]});\n\t\t}\n\t\treturn *min_element(all(u));\n\t};\n\tauto count = [](const vi &v){\n\t\tvector<vi> u;\n\t\trep(j, 4){\n\t\t\tu.pb({v[j], v[(j + 1) % 4], v[(j + 2) % 4], v[(j + 3) % 4]});\n\t\t}\n\t\tif(u[0] == u[1]) return 4;\n\t\tif(u[0] == u[2] || u[1] == u[3]) return 2;\n\t\treturn 1;\n\t};\n\trep(i, n) ++cnt[c[i] = norm(c[i])];\n\t\n\t\n\trep(i, n){\n\t\t--cnt[c[i]];\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t--cnt[c[j]];\n\t\t\trep(k, 4){\n\t\t\t\tconst vi col = {c[i][0], c[i][1], c[i][2], c[i][3],\n\t\t\t\t\tc[j][(k + 3) % 4], c[j][(k + 2) % 4], c[j][(k + 1) % 4], c[j][k]};\n\t\t\t\tvector<vi> cs = {{0, 4, 5, 1}, {1, 5, 6, 2}, {3, 2, 6, 7}, {0, 3, 7, 4}};\n\t\t\t\tfor(auto &v : cs){\n\t\t\t\t\tfor(int &p : v) p = col[p];\n\t\t\t\t\tv = norm(v);\n\t\t\t\t}\n\t\t\t\tsort(all(cs));\n\t\t\t\t\n\t\t\t\tll x = cnt.count(cs[0]) ? cnt[cs[0]] : 0;\n\t\t\t\tll y = cnt.count(cs[1]) ? cnt[cs[1]] : 0;\n\t\t\t\tll z = cnt.count(cs[2]) ? cnt[cs[2]] : 0;\n\t\t\t\tll w = cnt.count(cs[3]) ? cnt[cs[3]] : 0;\n\t\t\t\tint rot = count(cs[0]) * count(cs[1]) * count(cs[2]) * count(cs[3]);\n\t\t\t\t/*\n\t\t\t\tif(x * y * z * w){\n\t\t\t\t\tdbg(i, j, k);\n\t\t\t\t\tdbg(x, y, z, w, rot);\n\t\t\t\t\trep(ii, 4) dbg(ii, cs[ii]);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(cs[0] == cs[3]){\n\t\t\t\t\tans += x * (x - 1) * (x - 2) * (x - 3) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[2]){\n\t\t\t\t\tans += x * (x - 1) * (x - 2) * w * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[1] == cs[3]){\n\t\t\t\t\tans += x * y * (y - 1) * (y - 2) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[1] && cs[2] == cs[3]){\n\t\t\t\t\tans += x * (x - 1) * z * (z - 1) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[1]){\n\t\t\t\t\tans += x * (x - 1) * z * w * rot;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += x * y * z * w * rot;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++cnt[c[j]];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\t   c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nint c[MAXN][4];\nint64 h[MAXN];\nmap<int64,int> zz;\nvoid insert(int64 p,int d) {\n    for(int i = 0 ; i < 4 ; ++i) {\n        zz[p] += d;\n        p = p / 1000 + (p % 1000) * 1000000000LL;\n    }\n}\nint64 calc(int64 a,int64 b,int64 c,int64 d) {\n    int64 res = d + c * 1000 + b * 1000000 + a * 1000000000;\n    return res;\n}\nint64 getcol(int64 p,int t) {\n    for(int i = 0 ; i < 3 - t ; ++i) p /= 1000;\n    return p % 1000;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        for(int j = 0 ; j < 4 ; ++j) {\n            read(c[i][j]);\n        }\n        h[i] = calc(c[i][0],c[i][1],c[i][2],c[i][3]);\n        insert(h[i],1);\n    }\n    int64 ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n        insert(h[i],-1);\n        for(int j = i + 1 ; j <= N ; ++j) {\n            insert(h[j],-1);\n            for(int k = 0 ; k < 4 ; ++k) {\n                int64 res = 1;\n\n                int64 rec[4] = {0};\n                rec[0] = calc(getcol(h[i],0),getcol(h[j],1),getcol(h[j],0),getcol(h[i],1));\n                rec[1] = calc(getcol(h[i],1),getcol(h[j],0),getcol(h[j],3),getcol(h[i],2));\n                rec[2] = calc(getcol(h[i],2),getcol(h[j],3),getcol(h[j],2),getcol(h[i],3));\n                rec[3] = calc(getcol(h[i],3),getcol(h[j],2),getcol(h[j],1),getcol(h[i],0));\n                for(int x = 0 ; x < 4 ; ++x) {\n                    res = res * zz[rec[x]];\n                    if(!res) {\n                        for(int y = 0 ; y < x ; ++y) {\n                            insert(rec[y],1);\n                        }\n                        goto fail;\n                    }\n                    insert(rec[x],-1);\n                }\n                for(int x = 0 ; x < 4 ; ++x) {\n                    insert(rec[x],1);\n                }\n                fail:;\n                ans += res;\n                h[j] = h[j] / 1000 + (h[j] % 1000) * 1000000000;\n            }\n            insert(h[j],1);\n        }\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n#include<list>\n#include<bitset>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<utility>\n#include<fstream>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<assert.h>\nusing namespace std;\n\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define CLR(a) memset(a, 0, sizeof(a))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) )\n#define S(X) ( (X) * (X) )\n#define SZ(V) (int )V.size()\n#define FORN(i, n) for(i = 0; i < n; i++)\n#define FORAB(i, a, b) for(i = a; i <= b; i++)\n#define ALL(V) V.begin(), V.end()\n#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))\n\ntypedef pair<int,int> PII;\ntypedef pair<double, double> PDD;\ntypedef vector<int> VI;\ntypedef vector<PII > VP;\n\n#define AIN(A, B, C) assert(IN(A, B, C))\n\n//typedef int LL;\ntypedef long long int LL;\n//typedef __int64 LL;\n\nint n;\nint col[404][5];\nmap<LL, int> M;\n\nLL hashValue(VI V) {\n\tLL x = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tx = x * 1000 + V[i];\n\t}\n\treturn x;\n}\n\nvoid insert(int a, int b, int c, int d, int u) {\n\tVI V = { a, b, c, d };\n\tVI W;\n\tW = V;\n\tfor (int i = 0; i < 3; i++) {\n\t\tV = { V[1], V[2], V[3], V[0] };\n\t\tif (V < W) {\n\t\t\tW = V;\n\t\t}\n\t}\n\n\tLL h = hashValue(W);\n\tM[h]+=u;\n}\n\nVI rotate(int t, int turn) {\n\tVI V = { col[t][0], col[t][1], col[t][2], col[t][3] };\n\tfor (int i = 0; i < turn; i++) {\n\t\tV = { V[1], V[2], V[3], V[0] };\n\t}\n\treturn V;\n}\n\nLL ans = 0;\nLL ways;\n\nvoid select(VI X, int u) {\n\tint same = 0;\n\tVI V = X;\n\tVI MN = V;\n\tfor (int i = 0; i < 4; i++) {\n\t\tV = { V[1], V[2], V[3], V[0] };\n\t\tsame += (V == X);\n\t\tif (V < MN) MN = V;\n\t}\n\n\tLL h = hashValue(MN);\n\tways *= same * M[h];\n\tM[h] += u;\n}\n\nvoid solve(vector<vector<int> > X) {\n\tways = 1;\n\tfor (VI _X : X) {\n\t\tselect(_X, -1);\n\t}\n\tans += ways;\n\tfor (VI _X : X) {\n\t\tselect(_X, +1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tscanf(\"%d\", &col[i][j]);\n\t\t}\n\t\tinsert(col[i][0], col[i][1], col[i][2], col[i][3], 1);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tinsert(col[i][0], col[i][1], col[i][2], col[i][3], -1);\n\t\tVI T = { col[i][0], col[i][1], col[i][2], col[i][3] };\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tinsert(col[j][0], col[j][1], col[j][2], col[j][3], -1);\n\t\t\tfor (int t = 0; t < 4; t++) {\n\t\t\t\tVI B = rotate(j, t);\n\t\t\t\tB = {B[1], B[0], B[3], B[2]};\n\t\t\t\tvector<vector<int> > X = {\n\t\t\t\t\t{ T[0], B[0], B[1], T[1] },\n\t\t\t\t\t{ T[1], B[1], B[2], T[2] },\n\t\t\t\t\t{ T[2], B[2], B[3], T[3] },\n\t\t\t\t\t{ T[3], B[3], B[0], T[0] }\n\t\t\t\t};\n\n\t\t\t\tsolve(X);\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, t, ans);\n\t\t\t}\n\t\t\tinsert(col[j][0], col[j][1], col[j][2], col[j][3], 1);\n\t\t}\n\t\t//insert(col[i][0], col[i][1], col[i][2], col[i][3], 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops,Ofast\")\n#pragma GCC target(\"avx,sse,sse2,ssse3,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<18;\ntypedef int str __attribute(( vector_size(4*sizeof(int)) ));\nint tr[1660][1010], sz = 1, cnt[1660], t[1660];\nstr m[4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {2, 3, 0, 1}, {3, 0, 1, 2}};\n#define INLINE inline __attribute(( always_inline ))\nINLINE void nw(str a) {\n\tint p = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(!tr[p][a[i]]) tr[p][a[i]] = sz++;\n\t\tp = tr[p][a[i]];\n\t}\n\tt[p] = 1;\n}\n\nINLINE int count(str a, int s = 0) {\n\ta = __builtin_shuffle(a, m[s]);\n\tint p = 0;\n\tp = tr[p][a[0]];\n\tp = tr[p][a[1]];\n\tp = tr[p][a[2]];\n\tp = tr[p][a[3]];\n\treturn cnt[p];\n}\n\nINLINE void add(str a, int x, int s = 0) {\n\ta = __builtin_shuffle(a, m[s]);\n\tint p = 0;\n\tp = tr[p][a[0]];\n\tp = tr[p][a[1]];\n\tp = tr[p][a[2]];\n\tp = tr[p][a[3]];\n\tif(t[p]) cnt[p] += x;\n}\nint n;\nstr x[maxn];\nll ans = 0;\n#define shi(x, y) (((x)>>(2*(y)))&3)\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < 4; j++) cin >> x[i][j];\n\t\t\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tadd(x[j], -1);\n\t\t\tfor(int sD = 0; sD < 4; sD++) {\n\t\t\t\tstr l = {x[j][(sD+1)&3], x[i][0], x[i][3], x[j][(sD+2)&3]};\n\t\t\t\tstr r = {x[i][1], x[j][sD&3], x[j][(sD+3)&3], x[i][2]};\n\t\t\t\tstr f = {x[j][(sD+1)&3], x[j][sD&3], x[i][1], x[i][0]};\n\t\t\t\tstr b = {x[i][3], x[i][2], x[j][(sD+3)&3], x[j][(sD+2)&3]};\n\t\t\t\tfor(int s = 0; s < 256; s++) {\n\t\t\t\t\tll cur = 1;\n\t\t\t\t\t\n\t\t\t\t\tcur *= count(l, shi(s, 0)), add(l, -1, shi(s, 0));\n\t\t\t\t\tcur *= count(r, shi(s, 1)), add(r, -1, shi(s, 1));\n\t\t\t\t\tcur *= count(f, shi(s, 2)), add(f, -1, shi(s, 2));\n\t\t\t\t\tcur *= count(b, shi(s, 3)), add(b, -1, shi(s, 3));\n\t\t\t\t\t\n\t\t\t\t\tans += cur;\n\t\t\t\t\t\n\t\t\t\t\tadd(l, 1, shi(s, 0));\n\t\t\t\t\tadd(r, 1, shi(s, 1));\n\t\t\t\t\tadd(f, 1, shi(s, 2));\n\t\t\t\t\tadd(b, 1, shi(s, 3));\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(x[j], 1);\n\t\t}\n\t\tnw(x[i]);\n\t\tadd(x[i], 1);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nll f(const ar &x){\n    return x[0]+(ll)x[1]*1000+(ll)x[2]*1e6+(ll)x[3]*1e9;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin>>v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i]);\n            rotate(v[i].begin(),v[i].begin()+1,v[i].end());\n        }\n    }\n    vector<vec> D(16);\n    rep(i,16)rep(j,4)if(i&(1<<j))D[i].pb(j);\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                s[0] = f(ar{v[i][1],v[i][0],v[j][1],v[j][0]});\n                s[1] = f(ar{v[i][0],v[i][3],v[j][2],v[j][1]});\n                s[2] = f(ar{v[i][3],v[i][2],v[j][3],v[j][2]});\n                s[3] = f(ar{v[i][2],v[i][1],v[j][0],v[j][3]});\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    rep3(t,15,1){\n                        for(auto e:D[t]) dp[t]+=dp[(1<<e)^t]*cnt[e];\n                    }\n                }\n                ans += dp[15];\n                rotate(v[j].begin(),v[j].begin()+1,v[j].end());\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> norm(vector<int> C) {\n  vector<int> res = C;\n  for (int i = 0; i < 4; ++i) {\n    bool f = false;\n    for (int j = 0; j < 4; ++j) {\n      if (res[j] > C[j]) f = true;\n      if (res[j] < C[j]) break;\n    }\n\n    if (f) res = C;\n    rotate(C.begin(), C.begin() + 1, C.end());\n  }\n\n  return res;\n}\n\nint equ(vector<int> C) {\n  if (C[0] == C[2] && C[1] == C[3]) {\n    if (C[0] == C[1])\n      return 4;\n    else\n      return 2;\n  }\n  return 1;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  vector<vector<int>> C;\n  map<vector<int>, int64_t> cnt;\n  for (int i = 0; i < N; ++i) {\n    vector<int> c(4);\n    for (auto &j : c) cin >> j;\n    c = norm(c);\n    cnt[c]++;\n    C.push_back(c);\n  }\n\n  int64_t ans = 0;\n  for (int i = 0; i < N; ++i) {\n    cnt[C[i]]--;\n\n    for (int j = 0; j < i; ++j) {\n      cnt[C[j]]--;\n\n      for (int k = 0; k < 4; ++k) {\n        vector<vector<int>> hp(4);\n        hp[0] = norm({C[i][1], C[i][0], C[j][1], C[j][0]});\n        hp[1] = norm({C[i][2], C[i][1], C[j][0], C[j][3]});\n        hp[2] = norm({C[i][3], C[i][2], C[j][3], C[j][2]});\n        hp[3] = norm({C[i][0], C[i][3], C[j][2], C[j][1]});\n\n        int64_t add = 1;\n        if (cnt.count(hp[0]) && cnt.count(hp[1]) && cnt.count(hp[2]) && cnt.count(hp[3])) {\n          for (int l = 0; l < 4; ++l) {\n            add *= equ(hp[l]) * cnt[hp[l]];\n            cnt[hp[l]]--;\n          }\n\n          ans += add;\n\n          for (int l = 0; l < 4; ++l) {\n            cnt[hp[l]]++;\n          }\n        }\n\n        rotate(C[j].begin(), C[j].begin() + 1, C[j].end());\n      }\n\n      cnt[C[j]]++;\n    }\n\n    cnt[C[i]]++;\n  }\n\n  cout << ans / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nconstexpr ll T[4]={1,1000,1000000,1000000000};\ninline ll f(const ar &x,int k){\n    ll res=0;\n    rep(i,4)res+=T[(i+k)&3]*x[i];\n    return res;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin >> v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i],j);\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                rep(ii,4){\n                    s[ii] = f(ar{v[i][(4+1-ii)&3],v[i][(4-ii)&3],v[j][(1+k+ii)&3],v[j][(k+ii)&3]},0);\n                }\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    rep3(t,15,8){\n                        rep(tt,4){\n                            if(t&(1<<tt)) dp[t] += dp[t^(1<<tt)]*cnt[tt];\n                        }\n                    }\n                    rep3(t,7,1){\n                        rep(tt,3){\n                            if(t&(1<<tt)) dp[t] += dp[t^(1<<tt)]*cnt[tt];\n                        }\n                    }\n                }\n                ans += dp[15];\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++/h>\nusing namespace std;\nconst int N=1000;\nunordered_map<ll,int>mp;\nstruct node{\n\tint c[4];\n\tnode nxt(){\treturn node{c[1],c[2],c[3],c[0]};}\n}a[N];\nvoid add(node x,int d){\n\tfor (int j=1;j<=4;++j,x=x.nxt())\n\t\tmp[x]+=d;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i){\n\t\tscanf(\"%d%d%d%d\",&a[i].c[0],&a[i].c[1],&a[i].c[2],&a[i].c[3]);\n\t\tadd(a[i],1);\n\t}\n\tfor (int i=1;i<n;++i){\n\t\tadd(a[i],-1);\n\t\tfor (int j=i+1;j<=n;++j){\n\t\t\tadd(a[j],-1);\n\t\t\tfor (int k=0;k<4;++k){\n\t\t\t\tm1=node{a[j].c[1],a[i].c[0],a[i].c[3],a[j].c[2]};\n                m2=node{a[i].c[1],a[j].c[0],a[j].c[3],a[i].c[2]};\n                m3=node{a[j].c[1],a[j].c[0],a[i].c[1],a[i].c[0]};\n                m4=node{a[i].c[3],a[i].c[2],a[j].c[3],a[j].c[2]};\n                a[j]=a[j].nxt();\n                if (mp[a1]==0||mp[a2]==0||mp[a3]==0||mp[a4]==0) continue;\n                re=1;\n                re*=mp[a1];insert(a1,-1);\n                re*=mp[a2];insert(a2,-1);\n                re*=mp[a3];insert(a3,-1);\n                re*=mp[a4];\n                insert(a1,1);insert(a2,1);insert(a3,1);\n                ans+=re;\n\n            }\n            insert(a[j],1);\t\t\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 1005, base = 9971 ; \nconst int trans[6][8] = {\n\t{0, 1, 2, 3, 4, 5, 6, 7}, \n\t{7, 6, 5, 4, 3, 2, 1, 0},\n\t{4, 5, 1, 0, 7, 6, 2, 3}, \n\t{3, 2, 6, 7, 0, 1, 5, 4}, \n\t{7, 4, 0, 3, 6, 5, 1, 2}, \n\t{2, 1, 5, 6, 3, 0, 4, 7}\n} ;\nconst int turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <int>, bool> exist ;\nmap <vector <int>, int> Count ;\nmap <vector <int>, int> calc ;\nint col[N][5], n ;\nll C[N << 2][7], sum ;\n\nbool check(vector <int> p) {\n\tvector <int> a ;\n\trep(i, 0, 7) a.push_back(0) ;\n\trep(i, 0, 5) rep(j, 0, 3) {\n\t\trep(k, 0, 3) a[k] = p[trans[i][(k + j) % 4]], a[k + 4] = p[trans[i][(k + j) % 4 + 4]] ;\n\t\tif (exist[a]) return false ;\n\t}\n\treturn true ;\n}\n\ninline bool cmp(vector <int> a, vector <int> b) {\n\trep(i, 0, 3) {\n\t\tif (a[i] < b[i]) return true ;\n\t\tif (a[i] > b[i]) return false ;\n\t}\n\treturn false ;\n}\n\ninline void getmin(vector <int> &p) {\n\tvector <int> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (cmp(tmp, ret)) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nvector <int> vec[N] ;\nmap <vector <int>, int> used, mul ;\n\nvoid solve(int x0, int x1, int x2, int x3) {\n\tvector <int> ret ;\n\tret.push_back(x0), ret.push_back(x1), ret.push_back(x2), ret.push_back(x3) ;\n\tgetmin(ret) ;\n\tsum *= mul[ret] * (Count[ret] - used[ret]) ;\n\t++ used[ret] ;\n}\n\nvoid era(int x0, int x1, int x2, int x3) {\n\tvector <int> ret ;\n\tret.push_back(x0), ret.push_back(x1), ret.push_back(x2), ret.push_back(x3) ;\n\tgetmin(ret) ;\n\t-- used[ret] ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) rep(j, 0, 3) scanf(\"%d\", &col[i][j]) ;\n\trep(i, 1, n) {\n\t\tvector <int> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\tvec[i] = ret ;\n\t\t++ Count[ret] ;\n\t\tint tot = 0 ; \n\t\tvector <int> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\n\tC[0][0] = 1 ;\n\trep(i, 1, n * 4) {\n\t\tC[i][0] = 1 ;\n\t\trep(j, 1, min(i, 6)) C[i][j] = C[i - 1][j - 1] + C[i - 1][j] ;\n\t}\n\tll ans = 0 ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\t-- Count[vec[i]], -- Count[vec[j]] ;\n//\t\tprintf(\"%d %d\\n\", i, j) ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <int> ret ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) solve(ret[turn[p][0]], ret[turn[p][1]], ret[turn[p][2]], ret[turn[p][3]]) ;\n\t\t\trep(p, 0, 3) era(ret[turn[p][0]], ret[turn[p][1]], ret[turn[p][2]], ret[turn[p][3]]) ;\n\t\t\tans += sum ;\n\t\t}\n\t\t++ Count[vec[i]], ++ Count[vec[j]] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan in Ubuntu 18.10 on 2018/10/21 using VIM\n//版权所有，翻印必究\n\ntypedef pair<pii,pii> pp;\nint n;\nint C[405][5];\nmap<pp,int> m;\n\npp mp(int a,int b,int c,int d){\n\treturn mp(mp(a,b),mp(c,d));\n}\n\nvoid ins(int a,int b,int c,int d){\n\tm[mp(a,b,c,d)]++;\n\tm[mp(b,c,d,a)]++;\n\tm[mp(c,d,a,b)]++;\n\tm[mp(d,a,b,c)]++;\n}\n\nint same(pp p,pp q){\n\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\tint ans=0;\n\tif(q==mp(a,b,c,d)){\n\t\tans++;\n\t}\n\tif(q==mp(b,c,d,a)){\n\t\tans++;\n\t}\n\tif(q==mp(c,d,a,b)){\n\t\tans++;\n\t}\n\tif(q==mp(d,a,b,c)){\n\t\tans++;\n\t}\n\treturn ans;\n}\n\nvector<pp> v;\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>C[i][0]>>C[i][1]>>C[i][2]>>C[i][3];\n\t}\n\tINT ans=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=0;j<SZ(v);j++){\n\t\t\tpp p=v[j];\n\t\t\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\t\t\tpp m1=mp(b,a,C[i][0],C[i][1]);\n\t\t\tpp m2=mp(c,b,C[i][1],C[i][2]);\n\t\t\tpp m3=mp(d,c,C[i][2],C[i][3]);\n\t\t\tpp m4=mp(a,d,C[i][3],C[i][0]);\n\t\t\tINT res=1;\n\t\t\tres*=m[m1]-same(p,m1);\n\t\t\tint fAck=same(m1,m2);\n\t\t\tres*=m[m2]-same(p,m2)-fAck;\n\t\t\tint fBck=same(m1,m3)+same(m2,m3);\n\t\t\tres*=m[m3]-same(p,m3)-fBck;\n\t\t\tint fCck=same(m1,m4)+same(m2,m4)+same(m3,m4);\n\t\t\tres*=m[m4]-same(p,m4)-fCck;\n\t\t\tans+=res;\n\t\t}\n\t\tint a=C[i][3],b=C[i][2],c=C[i][1],d=C[i][0];\n\t\tins(a,b,c,d);\n\t\tv.pb(mp(a,b,c,d));\n\t\tv.pb(mp(b,c,d,a));\n\t\tv.pb(mp(c,d,a,b));\n\t\tv.pb(mp(d,a,b,c));\n\t}\n\tfio<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=440,D=4;\nint i,j,k,n,m,ch,ff;\nll ans;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nstruct cc {\n\tll a;\n\tvoid rev() {\n\t\tll t=a&1023;\n\t\t(a>>=10)|=t<<30;\n\t}\n\tvoid change() {\n\t\tll t1=(a>>10)&1023,t3=(a>>30)&1023;\n\t\ta^=(t1<<10)|(t3<<30);\n\t\ta^=(t3<<10)|(t1<<30);\n\t}\n\tll hash() {\n\t\treturn a;\n\t}\n\tvoid read() {\n\t\tfor (int i=0;i<D;i++) {\n\t\t\tint x;\n\t\t\tR(x);\n\t\t\t(a<<=10)|=x;\n\t\t}\n\t\t//change();\n\t}\n} A[N];\nmap<ll,int> Map;\nll work(cc a,cc b) {\n\tint i,j,k;\n\tcc t;\n\tll ans=1;\n\tfor (i=0;i<D;i++) {\n\t\t(t.a<<=10)|=(b.a>>((i+1)%D*10))&1023;\n\t\t(t.a<<=10)|=(b.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>((i+1)%D*10))&1023;\n\t\tans*=Map[t.hash()];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]--;\n\t\t}\n\t}\n\tfor (i=0;i<D;i++) {\n\t\t(t.a<<=10)|=(b.a>>((i+1)%D*10))&1023;\n\t\t(t.a<<=10)|=(b.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>((i+1)%D*10))&1023;\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]++;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tR(n);ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tA[i].read();\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]--;\n\t\t}\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]--;\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[i].rev();\n\t\t\t\tans+=work(A[i],A[j]);\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]++;\n\t\t\t}\n\t\t}\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tW(ans/3);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\n#include <queue>\n#include <bitset>\n\nusing namespace std;\n\nstruct Tile {\n    int c[4];\n    bool operator<(const Tile &t) const {\n        if (c[0] != t.c[0])\n            return c[0] < t.c[0];\n        if (c[1] != t.c[1])\n            return c[1] < t.c[1];\n        if (c[2] != t.c[2])\n            return c[2] < t.c[2];\n        return c[3] < t.c[3];\n    }\n};\n\nTile v[500];\n\nint main() {\n    int n;\n    cin >> n;\n    map<Tile, int> mp;\n    for (int i = 0; i < n; ++i) {\n        int c[4];\n        for (int j = 0; j < 4; ++j)\n            cin >> c[j];\n        Tile t;\n        for (int d = 0; d < 4; ++d) {\n            for (int i = 0; i < 4; ++i)\n                t.c[i] = c[(d + i) % 4];\n            if (d == 0)\n                v[i] = t;\n            ++mp[t];\n        }\n    }\n    int c1[4];\n    int c2[4];\n    long long ans = 0;\n    for (int i1 = 0; i1 < n; ++i1) {\n        for (int i2 = i1 + 1; i2 < n; ++i2) {\n            for (int d1 = 0; d1 < 4; ++d1) {\n                for (int d2 = 0; d2 < 4; ++d2) {\n                    for (int i = 0; i < 4; ++i) {\n                        int pi1 = (i + d1) % 4;\n                        c1[i] = v[i1].c[pi1];\n                    }\n                    c2[0] = v[i2].c[(d2 + 1) % 4];\n                    c2[1] = v[i2].c[(d2 + 0) % 4];\n                    c2[2] = v[i2].c[(d2 + 3) % 4];\n                    c2[3] = v[i2].c[(d2 + 2) % 4];\n                    Tile ti1, ti2;\n                    for (int d = 0; d < 4; ++d) {\n                        for (int i = 0; i < 4; ++i) {\n                            ti1.c[i] = c1[(i + d) % 4];\n                            ti2.c[i] = c2[(i + d) % 4];\n                        }\n                        --mp[ti1];\n                        --mp[ti2];\n                    }\n                    long long curans = 1;\n                    for (int j = 0; j < 4; ++j) {\n                        Tile t;\n                        t.c[0] = c2[j];\n                        t.c[1] = c2[(j + 1) % 4];\n                        t.c[2] = c1[(j + 1) % 4];\n                        t.c[3] = c1[j];\n                        curans *= max(mp[t], 0);\n                        Tile t2;\n                        for (int d = 0; d < 4; ++d) {\n                            for (int i = 0; i < 4; ++i)\n                                t2.c[i] = t.c[(i + d) % 4];\n                            --mp[t2];\n                        }\n                    }\n                    for (int j = 0; j < 4; ++j) {\n                        Tile t;\n                        t.c[0] = c2[j];\n                        t.c[1] = c2[(j + 1) % 4];\n                        t.c[2] = c1[(j + 1) % 4];\n                        t.c[3] = c1[j];\n                        Tile t2;\n                        for (int d = 0; d < 4; ++d) {\n                            for (int i = 0; i < 4; ++i)\n                                t2.c[i] = t.c[(i + d) % 4];\n                            ++mp[t2];\n                        }\n                    }\n                    for (int d = 0; d < 4; ++d) {\n                        for (int i = 0; i < 4; ++i) {\n                            ti1.c[i] = c1[(i + d) % 4];\n                            ti2.c[i] = c2[(i + d) % 4];\n                        }\n                        ++mp[ti1];\n                        ++mp[ti2];\n                    }\n                    ans += curans;\n                }\n            }\n        }\n    }\n    cout << ans / 12 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef pair<ll,pi> pii;\ntypedef vector<pi> vpi;\ntypedef set<ll> si;\ntypedef long double ld;\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\nll INF = 1e9;\nll MOD = 1e9;\n#define lb lower_bound\n#define ub upper_bound\n#define SZ(x) (ll)x.size()\n#define ALL(x) x.begin(),x.end()\n#define count(V,x) ub(ALL(V),x,cmp) - lb(ALL(V),x,cmp)\n\nstruct cube{\n  ll a, b, c, d, orien;\n  cube(ll _a, ll _b, ll _c, ll _d): a(_a), b(_b), c(_c), d(_d), orien(1){\n    ll m = min({a,b,c,d});\n    if (a == b && a == c && a == d)orien = 4;\n    else if (a == c && b == d)orien = 2;\n  }\n\n  bool fit(cube cmp){\n    return a == cmp.a && b == cmp.b && c == cmp.c && d == cmp.d;\n  }\n\n  cube rotate(){\n    return cube({b,c,d,a});\n  }\n\n  void pp(){\n    cout<<a<<' '<<b<<' '<<c<<' '<<d<<'\\n';\n  }\n};\n\nbool cmp(cube a, cube b){\n  if (a.a != b.a)return a.a < b.a;\n  if (a.b != b.b)return a.b < b.b;\n  if (a.c != b.c)return a.c < b.c;\n  return a.d < b.d;\n}\n\nbool biggay = 0;\n\ncube bal(cube t){\n  cube q = t.rotate();\n  cube r = q.rotate();\n  cube u = r.rotate();\n  if (cmp(q, t))t = q;\n  if (cmp(r, t))t = r;\n  if (cmp(u, t))t = u;\n  return t;\n}\n\nll N;\nll a,b,c,d;\nvector<cube> V,faces;\n\nint main(){\n  // freopen(\"in.txt\",\"r\",stdin);\n  cin >> N;\n  for (int i=0;i<4;++i)faces.pb(cube(0,0,0,0));\n  for (int i=0;i<N;++i){\n    cin >>a >> b >> c >> d;\n    V.pb({a,b,c,d});\n    V[i] = bal(V[i]);\n  }\n  sort(ALL(V), cmp);\n  // for (auto i : V)i.pp();\n  // cout<<'\\n';\n  // cout<<cmp (cube(0,1,2,3), cube(0,1,2,4) )<<'\\n';\n  // return 0;\n  ll ans=0;\n  for (int i=0;i<N-1;++i){\n    // Base\n    // if (i != 1)continue;\n    for (int j=i+1;j<N;++j){\n      // if (j != 3)continue;\n      cube top = V[i];\n      cube btm = V[j];\n      // cout<<\"Top \" << V[i].a<<' '<<V[i].b<<' '<<V[i].c<<' '<<V[i].d<<'\\n';\n      // cout << \"Bottom \" << V[j].a<<' '<<V[j].b<<' '<<V[j].c<<' '<<V[j].d<<'\\n';\n      for (int k=0;k<4;++k){\n        faces[0] = bal(cube(top.d,top.c,btm.c,btm.b));\n        faces[1] = bal(cube(top.c,top.b,btm.d,btm.c));\n        faces[2] = bal(cube(top.b,top.a,btm.a,btm.d));\n        faces[3] = bal(cube(top.a,top.d,btm.b,btm.a));\n        sort(ALL(faces), cmp);\n        ll r = 1;\n        // Case one is all equal\n        bool zero = faces[0].fit(faces[1]);\n        bool one = faces[1].fit(faces[2]);\n        bool two = faces[2].fit(faces[3]);\n        if (zero){\n          if (one){\n            if (two){\n              // A A A A\n              int cnt = count(V, faces[0]);\n              if (V[i].fit(faces[0]))--cnt;\n              if (V[j].fit(faces[0]))--cnt;\n              r = cnt*(cnt-1)*(cnt-2)*(cnt-3);\n            }else{\n              // A A A B\n              int p = count(V, faces[0]);\n              if (V[i].fit(faces[0]))--p;\n              if (V[j].fit(faces[0]))--p;\n              int q = count(V, faces[0]);\n              if (V[i].fit(faces[0]))--q;\n              if (V[j].fit(faces[0]))--q;\n              r = p * (p-1) * (p-2) * q;\n            }\n          }else{\n            if (two){\n              // A A B B\n            }else{\n              // A A B C\n            }\n          }\n        }\n        else{\n          if (one){\n            if (two){\n              // A B B B\n            }else{\n              // A B B C\n            }\n          }\n          else{\n            if (two){\n              // A B C C\n            }else{\n              // A B C D\n              for (int l = 0; l < 4; ++l){\n                int cnt = count(V, faces[l]);\n                if (V[i].fit(faces[l]))--cnt;\n                if (V[j].fit(faces[l]))--cnt;\n                r *= cnt;\n              }\n            }\n          }\n        }\n        // cout<<'\\n';\n        // cout<<r<<' ';\n        // if (r){cout<<i<<' '<<j<<'\\n';}\n        for (int l=0;l<4;++l){\n          r *= faces[l].orien;\n        }\n        ans += r;\n        top = top.rotate();\n      }\n      // cout<<'\\n';\n    }\n  }\n  cout<<ans/3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tvector<array<int, 4>>c(N);\n\trep(i, N)rep(j, 4)cin >> c[i][j];\n\tmap<int, vector<int>>m1;\n\tmap<array<int, 4>, vector<array<int, 2>>>m4;\n\trep(i, N) {\n\t\tif (c[i][0] == c[i][1] && c[i][1] == c[i][2] && c[i][2] == c[i][3]) {\n\t\t\tm1[c[i][0]].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trep(j, 4) {\n\t\t\t\tm4[{ c[i][j], c[i][(j + 1) % 4], c[i][(j + 2) % 4], c[i][(j + 3) % 4] }].push_back({ i,j });\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i, N)REP(j, i + 1, N)rep(k, 4) {\n\t\tarray<int, 4>a1 = { c[i][0],c[j][(k + 1) % 4],c[j][(k + 0) % 4],c[i][1] };\n\t\tarray<int, 4>a2 = { c[i][1],c[j][(k + 0) % 4],c[j][(k + 3) % 4],c[i][2] };\n\t\tarray<int, 4>a3 = { c[i][2],c[j][(k + 3) % 4],c[j][(k + 2) % 4],c[i][3] };\n\t\tarray<int, 4>a4 = { c[i][3],c[j][(k + 2) % 4],c[j][(k + 1) % 4],c[i][0] };\n\t\tfor (auto x1 : m4[a1])if (i < x1[0] && j != x1[0]) {\n\t\t\tfor (auto x2 : m4[a2])if (i < x2[0] && j != x2[0] && x1[0] != x2[0]) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1[0] != x3[0] && x2[0] != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2[0] != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(auto x4:m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2[0] != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans+=4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(auto x3:m1[a3[0]])if (i < x3 && j != x3 && x1[0] != x3 && x2[0] != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2[0] != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans+=4;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2[0] != x4 && x3 != x4) {\n\t\t\t\t\t\tans+=16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto x2:m1[a2[0]])if (i < x2 && j != x2 && x1[0] != x2) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1[0] != x3[0] && x2 != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2 != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans+=4;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2 != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans+=16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto x3 : m1[a3[0]])if (i < x3 && j != x3 && x1[0] != x3 && x2 != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2 != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans+=16;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2 != x4 && x3 != x4) {\n\t\t\t\t\t\tans+=64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto x1:m1[a1[0]])if (i < x1 && j != x1) {\n\t\t\tfor (auto x2 : m4[a2])if (i < x2[0] && j != x2[0] && x1 != x2[0]) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1 != x3[0] && x2[0] != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2[0] != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans+=4;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2[0] != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans+=16;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto x3 : m1[a3[0]])if (i < x3 && j != x3 && x1 != x3 && x2[0] != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2[0] != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans+=16;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2[0] != x4 && x3 != x4) {\n\t\t\t\t\t\tans+=64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto x2 : m1[a2[0]])if (i < x2 && j != x2 && x1 != x2) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1 != x3[0] && x2 != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2 != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans+=16;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2 != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans+=64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto x3 : m1[a3[0]])if (i < x3 && j != x3 && x1 != x3 && x2 != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2 != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans+=64;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2 != x4 && x3 != x4) {\n\t\t\t\t\t\tans+=256;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int M = 4;\nmap<vi, int> dic;\n\ninline void rot(vi& c){\n    rep(i, M-1){\n        swap(c[i], c[i+1]);\n    }\n}\n\ninline void rev(vi& c){\n    reverse(_all(c));\n}\n\ninline void reg(vi& c){\n    rep(i, M){\n        dic[c]++;\n        rot(c);\n    }\n}\n\ninline void del(vi& c){\n    rep(i, M){\n        dic[c]--;\n        rot(c);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vector<vi> C(n, vi(M));\n    for(auto& c : C){\n        for(auto& e : c) cin >> e;\n        reg(c);\n    }\n\n    ll res = 0LL;\n    rep(i, n){\n        vi& c1 = C[i];\n        del(c1);\n        // cerr << dic[c1] << endl;\n\n        rep(j, i+1, n){\n            vi& c2 = C[j];\n            del(c2);\n            rev(c2);\n\n            rep(k, 4){\n                ll cur = 1LL;\n                vector<vi> used;\n                rep(l, 4){\n                    vi c = {c2[l], c2[(l+1) % M], c1[(l+1) % M], c1[l]};\n                    int num = max(dic[c], 0);\n                    cur *= num;\n                    if(num == 0) break;\n                    del(c);\n                    used.emplace_back(c);\n                }\n                for(auto e : used) reg(e);\n                res += cur;\n\n                rot(c2);\n            }\n            rev(c2);\n            reg(c2);\n        }\n        // cerr << res << endl;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            vector<pair<int,int>> update;\n            vector<bool> unused(N);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(!unused[k]){\n                    rep(i_,0,4){\n                        if(b&(1<<i_)) continue;\n                        rep(j_,0,4) if(match(rotatedC[k][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                vector<i64> sum(4);\n                rep(i_,0,4){\n                    sum[i_]=0;\n                    rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                }\n                unused[i]=unused[j]=true;\n                rep(i_,0,N){\n                    if(i_==i or i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    unused[i_]=!use;\n                }\n                \n                ans+=rec(i+1,0);\n                \n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nmap<vector<long long>, long long> cnt;\nvoid ited(vector<long long> A,int pivot) {\n\tfor (int i = 0; i < A.size(); ++i) {\n\t\tfor (int q = 1; q < 4; ++q) {\n\t\t\tswap(A[q - 1], A[q]);\n\t\t}\n\t\tcnt[A] += pivot;\n\t}\n\treturn;\n}\nint main() {\n#define int long long\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> inputs;\n\tREP(i, n) {\n\t\tvector<int> A;\n\t\tREP(q, 4) {\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tA.push_back(b);\n\t\t}\n\t\tvector<vector<int>> B;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tB.push_back(A);\n\t\t\tfor (int q = 1; q < 4; ++q) {\n\t\t\t\tswap(A[q - 1], A[q]);\n\t\t\t}\n\t\t}\n\t\tsort(B.begin(), B.end());\n\t\tinputs.push_back(B[0]);\n\t\tited(B[0], 1);\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\t//Bottom\n\t\tited(inputs[i], -1);\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\t//Top\n\t\t\tited(inputs[q], -1);\n\t\t\tswap(inputs[q][0], inputs[q][1]);\n\t\t\tswap(inputs[q][2], inputs[q][3]);\n\t\t\tREP(j, 4) {\n\t\t\t\tfor (int t = 1; t < 4; ++t) {\n\t\t\t\t\tswap(inputs[q][t-1], inputs[q][t]);\n\t\t\t\t}\n\t\t\t\t//direction,now we're ready to solve\n\t\t\t\tvector<vector<long long>> A;\n\t\t\t\tREP(b, 4) {\n\t\t\t\t\tvector<long long> B;\n\t\t\t\t\tB.push_back(inputs[q][b]);\n\t\t\t\t\tB.push_back(inputs[q][(b + 1) % 4]);\n\t\t\t\t\tB.push_back(inputs[i][(b + 1) % 4]);\n\t\t\t\t\tB.push_back(inputs[i][b]);\n\t\t\t\t\tA.push_back(B);\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (int i = 0; i < A.size(); ++i) {\n\t\t\t\t\ttmp *= cnt[A[i]];\n\t\t\t\t\tited(A[i], -1);\n\t\t\t\t}\n\t\t\t\tans += tmp;\n\t\t\t\tfor (int i = 0; i < A.size(); ++i) {\n\t\t\t\t\tited(A[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(inputs[q][0], inputs[q][1]);\n\t\t\tswap(inputs[q][2], inputs[q][3]);\n\t\t\tited(inputs[q], 1);\n\t\t}\n\t\tited(inputs[i], 1);\n\t}\n\tcout << ans/3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n;\nlli dat[405][4];\nmap<lli,int> ds;\n\n\nvoid l2d(lli no,lli* d){\n\tirep(i,4){\n\t\td[i]=no%1000;\n\t\tno/=1000;\n\t}\n}\n\nlli d2l(lli* d){\n\tlli res=0;\n\trep(i,4){\n\t\tres*=1000;\n\t\tres+=d[i];\n\t}\n\treturn res;\n}\n\nlli same(lli p,lli q){\n\tlli dp[4],dq[4];\n\tl2d(p,dp);\n\tl2d(q,dq);\n\trep(i,4){\n\t\tbool ok=true;\n\t\trep(j,4){\n\t\t\tif(dp[j]!=dq[(i+j)%4])ok=false;\n\t\t}\n\t\tif(ok)return true;\n\t}\n\treturn false;\n}\n\nint ty(lli* d){\n\tint p=4;\n\tif(d[0]==d[2] && d[1]==d[3]){\n\t\tp=2;\n\t\tif(d[0]==d[1])p=1;\n\t}\n\treturn p;\n}\n\nlli sum(lli* d,lli p,lli q){\n\tlli res=1;\n\trep(i,4){\n\t\tlli no=d[i];\n\t\tlli x=ds[no];\n\t\tif(same(no,p))x--;\n\t\tif(same(no,q))x--;\n\t\trep(j,i){\n\t\t\tif(same(no,d[j]))x--;\n\t\t}\n\t\tif(x<=0)return 0;\n\t\tlli sd[4];\n\t\tl2d(no,sd);\n\t\tres *= x * 4 / ty(sd);\n\t}\n\t\n\t//rep(i,4)printf(\"%012lld \",d[i]);\n\t//printf(\"\\n%012lld %012lld  %lld\\n\",p,q,res);\n\treturn res;\n}\n\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tlli d[4];\n\t\trep(k,4)scanf(\"%lld\",&d[k]);\n\t\tint p=ty(d);\n\t\trep(j,4){\n\t\t\tlli ns=0;\n\t\t\trep(k,4){\n\t\t\t\tns*=1000;\n\t\t\t\tns+=d[(j+k)%4];\n\t\t\t}\n\t\t\tif(j<p){\n\t\t\t\tif(ds.count(ns)==0)ds[ns]=1;\n\t\t\t\telse ds[ns]++;\n\t\t\t}\n\t\t\tdat[i][j] = ns;\n\t\t}\n\t}\n\t\n\tlli ua=0,da=0;\n\t\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i==j)continue;\n\t\t\trep(pp,4){\n\t\t\t\tlli p[4];\n\t\t\t\tlli rp=dat[i][pp];\n\t\t\t\tl2d(rp,p);\n\t\t\t\trep(qq,4){\n\t\t\t\t\tlli q[4];\n\t\t\t\t\tlli rq=dat[j][qq];\n\t\t\t\t\tl2d(rq,q);\n\t\t\t\t\t\n\t\t\t\t\tlli dd[4][4] = {\n\t\t\t\t\t\t{p[1],p[0],q[3],q[2]},\n\t\t\t\t\t\t{p[2],p[1],q[2],q[1]},\n\t\t\t\t\t\t{p[3],p[2],q[1],q[0]},\n\t\t\t\t\t\t{p[0],p[3],q[0],q[3]}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tlli td[4];\n\t\t\t\t\t//printf(\"%012lld %012lld\\n\",rp,rq);\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\ttd[k] = d2l(dd[k]);\n\t\t\t\t\t\t//printf(\"%d .. %012lld\\n\",k,td[k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//ans += sum(td,rp,rq);\n\t\t\t\t\t\n\t\t\t\t\tlli ns = sum(td,rp,rq);\n\t\t\t\t\t\n\t\t\t\t\tua += ns / (24*24*24);\n\t\t\t\t\tda += ns % (24*24*24);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tprintf(\"%lld\\n\",ua*24*24+da/24);\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ninline int GetBit(int mask, int num) {\n    return (mask >> num) & 1;\n}\n\nint cFront[4];\nint cBack[4];\n\ninline long long GetId(int c0, int c1, int c2, int c3) {\n    return c0 + 1000LL * (c1 + 1000LL * (c2 + 1000LL * c3));\n}\n\ninline long long GetLeftId() {\n    return GetId(cBack[3], cBack[2], cFront[1], cFront[0]);\n}\n\ninline long long GetRightId() {\n    return GetId(cFront[3], cFront[2], cBack[1], cBack[0]);\n}\n\ninline long long GetUpId() {\n    return GetId(cFront[1], cBack[2], cBack[1], cFront[2]);\n}\n\ninline long long GetDownId() {\n    return GetId(cBack[3], cFront[0], cFront[3], cBack[0]);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> colors(n, vector<int>(8));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n            colors[i][j + 4] = colors[i][j];\n        }\n    }\n\n    unordered_map<long long, int> colorCount;\n\n    vector<vector<int>> normColors;\n\n    unordered_map<long long, int> colorIds;\n\n    vector<vector<long long>> sides(n, vector<long long>(4));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            sides[i][j] = GetId(colors[i][j], colors[i][j + 1], colors[i][j + 2], colors[i][j + 3]);\n        }\n\n        for (int j = 0; j < 4; ++j) {\n            if (colorIds.find(sides[i][j]) == colorIds.end()) {\n                colorIds[sides[i][j]] = (int) normColors.size();\n                normColors.push_back(vector<int>());\n            }\n        }\n\n        for (int j = 0; j < 4; ++j) {\n            const int curId = colorIds[sides[i][j]];\n\n            ++colorCount[curId];\n\n            if (normColors[curId].empty()) {\n                for (int s = 0; s < 4; ++s) {\n                    normColors[curId].push_back(colorIds[sides[i][(j + s) % 4]]);\n                }\n            }\n        }\n    }\n\n    long long glResult = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int t = 0; t < 4; ++t) {\n            cFront[t] = colors[i][t];\n        }\n        for (int t = 0; t < 4; ++t) {\n            --colorCount[colorIds[sides[i][t]]];\n        }\n\n        for (int j = i + 1; j < n; ++j) {\n            for (int t = 0; t < 4; ++t) {\n                --colorCount[colorIds[sides[j][t]]];\n            }\n\n            for (int dj = 0; dj < 4; ++dj) {\n                for (int t = 0; t < 4; ++t) {\n                    cBack[t] = colors[j][dj + t];\n                }\n\n                long long curIds[4];\n\n                curIds[0] = GetLeftId();\n                curIds[1] = GetRightId();\n                curIds[2] = GetUpId();\n                curIds[3] = GetDownId();\n\n                long long result = 1;\n\n                for (int t = 0; t < 4; ++t) {\n                    if (colorIds.find(curIds[t]) == colorIds.end()) {\n                        result = 0;\n                        continue;\n                    }\n\n                    const int id = colorIds[curIds[t]];\n\n                    result *= colorCount[id];\n\n                    for (int x : normColors[id]) {\n                        --colorCount[x];\n                    }\n                }\n\n                for (int t = 0; t < 4; ++t) {\n                    if (colorIds.find(curIds[t]) == colorIds.end()) {\n                        continue;\n                    }\n\n                    const int id = colorIds[curIds[t]];\n\n                    for (int x : normColors[id]) {\n                        ++colorCount[x];\n                    }\n                }\n\n                glResult += result;\n            }\n\n            for (int t = 0; t < 4; ++t) {\n                ++colorCount[colorIds[sides[j][t]]];\n            }\n        }\n    }\n\n    cout << glResult << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits\\stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nint color[408][4];\nll has(int a[])\n{\n\tll res=0;\n\tfor(int i=N-1;i>=0;i--) res=res*1000+a[i];\n\treturn res;\n}\nvector<ll> _rotate(int c[])\n{\n\tvector<ll> res;\n//\tfor(int i=0;i<N;i++) cout<<c[i]<<\"   \";\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tint a[4];\n\t\tfor(int j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nint same(ll x,ll y)\n{\n\tint a[N],c[N];int sum=0;\n\tfor(int i=0;i<N;i++) a[i]=x%1000,x/=1000;\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tfor(int j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(int x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(int i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(int c1[],int c2[])\n{\n//\tfor(int i=0;i<N;i++) cout<<c1[i]<<\" \";cout<<\"\\n\";\n//\tfor(int i=0;i<N;i++) cout<<c2[i]<<\" \";cout<<\"\\n\";system(\"pause\");\n\tll p=has(c1);\n\tint a[4];ll ck[4];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(int j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t\tif(m[ck[i]]<=0) return 0;\n\t\tcnt*=m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint bel[]={0,3,2,1};\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<N;j++) cin>>color[i][j];\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint a[N],b[N];for(int k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<N;l++)\n\t\t\t\t\ta[l]=color[j][bel[(l+k)%N]];\n\t\t\t\tans+=operate(a,b);\n\t\t\t}\n\t\t}ins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); i--)\n#define debug(x) cout << #x << \" => \" << x << endl\nusing namespace std;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 7 + 400;\n///----------------------------------------------\n//int qpow(int\n\nint col[10];\nvoid rote() {\n    int tmp[4]; rep(i,0,4) tmp[i]=col[i];\n    rep(beg,1,4) {\n        int i; for (i=0; i<3&&tmp[(beg+i)%4]==col[i]; ) i++;\n        if(tmp[(beg+i)%4]<col[i]) {\n            rep(i,0,4) col[i]=tmp[(beg+i)%4];\n        }\n    }\n}\n\nconst int B[4]={1000000000, 1000000, 1000, 1};\nll getval() {\n    rote();\n    ll val=0;\n    rep(i,0,4) val+=1ll*col[i]*B[i];\n    return val;\n}\n\nbool same() {\n    rep(i,1,4) if (col[i]!=col[0]) return false;\n    return true;\n}\nbool same2() {\n    return col[0]==col[2]&&col[1]==col[3];\n}\n\n\nmap<ll,int> num;\nint tab[MAX_N][4];\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///init\n    ///read\n    int n; cin>>n;\n    rep(i,0,n) {\n        rep(j,0,4) scanf(\"%d\",&col[j]), tab[i][j]=col[j];\n        num[getval()]++;\n    }\n\n    ///work\n    ll ans=0;\n    rep(i,0,n) {\n        rep(j,0,4) col[j]=tab[i][j]; num[getval()]--;\n        rep(j,i+1,n) {\n            rep(k,0,4) col[k]=tab[j][k]; num[getval()]--;\n            rep(off,0,4) {\n                ll tmp=1;\n                ///front\n                col[0]=tab[i][1]; col[1]=tab[j][(off+0)%4];\n                col[3]=tab[i][2]; col[2]=tab[j][(off+3)%4]; rote();\n                ll val1 = getval();\n                ll tmp1 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val1]--)*tmp1;\n                ///top\n                col[0]=tab[i][0]; col[1]=tab[j][(off+1)%4];\n                col[3]=tab[i][1]; col[2]=tab[j][(off+0)%4]; rote();\n                ll val2 = getval();\n                ll tmp2 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val2]--)*tmp2;\n                ///buttom\n                col[0]=tab[i][2]; col[1]=tab[j][(off+3)%4];\n                col[3]=tab[i][3]; col[2]=tab[j][(off+2)%4]; rote();\n                ll val3 = getval();\n                ll tmp3 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val3]--)*tmp3;\n                ///back\n                col[0]=tab[i][3]; col[1]=tab[j][(off+2)%4];\n                col[3]=tab[i][0]; col[2]=tab[j][(off+1)%4]; rote();\n                ll val4 = getval();\n                ll tmp4 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val4]--)*tmp4;\n                ans=ans+tmp;\n                num[val1]++;\n                num[val2]++;\n                num[val3]++;\n                num[val4]++;\n\n            }\n            rep(k,0,4) col[k]=tab[j][k]; rote(); num[getval()]++;\n       }\n    }\n\n    ///print\n    cout << ans << endl;\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nint n;\nvector<int> c[400];\nll ans = 0;\n\nvector<int> rotate(vector<int> vec) {\n    vector<int> tmp[4];\n    rep(i,4) tmp[i].resize(4);\n    tmp[0] = vec;\n    for (int j = 1; j < 4; j++) {\n        rep(k,4) tmp[j][k] = tmp[j-1][(k+3)%4];\n    }\n    sort(tmp, tmp+4);\n    return tmp[0];\n}\n\nint main() {\n    cin >> n;\n    rep(i,n) {\n        vector<int> tmp;\n        tmp.resize(4);\n        rep(j,4) cin >> tmp[j];\n        c[i] = rotate(tmp);\n    }\n    sort(c, c+n);\n    rep(i,n) for (int j = i+1; j < n; j++) {\n        rep(k,4) {\n            vector<int> e[4];\n            rep(l,4) e[l].resize(4);\n            e[0][0] = c[i][0]; e[0][1] = c[i][1]; e[0][2] = c[j][k]; e[0][3] = c[j][(k+1)%4];\n            e[1][0] = c[i][1]; e[1][1] = c[i][2]; e[1][2] = c[j][(k+3)%4]; e[1][3] = c[j][k];\n            e[2][0] = c[i][2]; e[2][1] = c[i][3]; e[2][2] = c[j][(k+2)%4]; e[2][3] = c[j][(k+3)%4];\n            e[3][0] = c[i][3]; e[3][1] = c[i][0]; e[3][2] = c[j][(k+1)%4]; e[3][3] = c[j][(k+2)%4];\n            rep(l,4) reverse(e[l].begin(), e[l].end());\n            rep(l,4) e[l] = rotate(e[l]);\n            sort(e, e+4);\n            ll cnt[4];\n            rep(l,4) cnt[l] = upper_bound(c, c+n, e[l]) - lower_bound(c, c+n, e[l]);\n            rep(l,4) cnt[l] -= (int)(c[i]==e[l])+(int)(c[j]==e[l]);\n            bool ok = true;\n            rep(l,4) if (cnt[l] <= 0) ok = false;\n            if (!ok) continue;\n            ll add = 1;\n            rep(l,4) {\n                if (l >= 3 && e[l] == e[l-1] && e[l] == e[l-2] && e[l] == e[l-3]) {\n                    add *= cnt[l]-3;\n                } else if (l >= 2 && e[l] == e[l-1] && e[l] == e[l-2]) {\n                    add *= cnt[l]-2;\n                } else if (l >= 1 && e[l] == e[l-1]) {\n                    add *= cnt[l]-1;\n                } else {\n                    add *= cnt[l];\n                }\n                if (e[l][0] == e[l][1] && e[l][1] == e[l][2] && e[l][2] == e[l][3]) {\n                    add *= 4;\n                } else if (e[l][0] == e[l][2] && e[l][1] == e[l][3]) {\n                    add *= 2;\n                }\n            }\n            ans += add;\n        }\n    }\n    cout << ans/3 << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nint a[4][N][4];\nint b[10];\nll dp[N][16];\nint id[4][4] = {{1,0,4,5},{2,1,5,6},{3,2,6,7},{0,3,7,4}};\nvector<int>v;\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&a[0][i][j]);\n            FOR(j,1,3)\n            {\n                FOR(k,0,3)\n                {\n                    a[j][i][k] = a[0][i][(k-j+4)%4];\n                }\n            }\n        }\n        ll ans = 0;\n        FOR(i,1,n)\n        {\n            FOR(ii,1,n)\n            {\n                if(ii == i)continue;\n                v.clear();\n                FOR(s,1,n)if(s!=i&&s!=ii)v.PB(s);\n                FOR(j,0,3)\n                {\n                    FOR(k,0,3)b[k] = a[j][i][k];\n                    FOR(jj,0,3)\n                    {\n                        b[4] = a[jj][ii][1];\n                        b[5] = a[jj][ii][0];\n                        b[6] = a[jj][ii][3];\n                        b[7] = a[jj][ii][2];\n                        MST(dp,0);\n                        dp[0][0] = 1;\n                        for(int s = 1;s<=v.size();s++)\n                        {\n                            FOR(f,0,15)\n                            {\n                                dp[s][f] = dp[s-1][f];\n                                FOR(p,0,3)\n                                {\n                                    if(f&(1<<p))\n                                    {\n                                        FOR(r,0,3)\n                                        {\n                                            int flag = 1;\n                                            FOR(q,0,3)\n                                            {\n                                                //if(v[s] == 5&&f == 1)cout<<p<<\" \"<<a[r][v[s]][q]<<\" \"<<b[id[p][q]]<<endl;\n                                                if(a[r][v[s-1]][q]!=b[id[p][q]])\n                                                {\n                                                    flag = 0;\n                                                    break;\n                                                }\n                                            }\n\n                                            if(flag)\n                                            {\n                                                dp[s][f]+=dp[s-1][f-(1<<p)];\n                                               // cout<<s<<\" s \"<<f<<\" \"<<dp[s][f]<<endl;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        ans+=dp[v.size()][15];\n                    }\n                }\n            }\n        }\n        printf(\"%I64d\\n\",ans/24);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef long long ll;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin p2(in a){\n  return 1<<a;\n}\nin sel(in a, in b){\n  if(a<b)\n    return 0;\n  in c=1;\n  for(in i=a;i>a-b;--i)\n    c*=i;\n  return c;\n}\nVI bcl;\nVVI cl;\nVVI cord={{0,5,4,1},{1,4,7,2},{2,7,6,3},{5,0,3,6}};\nmap<VI,in> hv;\nVVI socl;\nVI cnn(VI a){\n  VI r=a;\n  forn(z,4){\n    rotate(a.begin(),a.begin()+1,a.end());\n    r=min(r,a);\n  }\n  return r;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  cl.resize(n,VI(4));\n  forn(z,n){\n    forn(i,4)\n      cin>>cl[z][i];\n  }\n  socl=cl;\n  forn(z,n){\n    socl[z]=cnn(socl[z]);\n    ++hv[socl[z]];\n  }\n  bcl.resize(8);\n  ll sm=0;\n  forn(b,n){\n    --hv[socl[b]];\n    for(in a=b+1;a<n;++a){\n      --hv[socl[a]];\n      forn(z,4){\n\trotate(cl[a].begin(),cl[a].begin()+1,cl[a].end());\n\tforn(k,4){\n\t  bcl[k]=cl[b][k];\n\t  bcl[k+4]=cl[a][k];\n\t}\n\tVVI tr(4,VI(4));\n\tforn(i,4){\n\t  forn(j,4){\n\t    tr[i][j]=bcl[cord[i][j]];\n\t  }\n\t  tr[i]=cnn(tr[i]);\n\t}\n\tsort(all(tr));\n\tin cw=1;\n\tin sf=0;\n\tforn(i,4){\n\t  if(i!=0 && tr[i]!=tr[i-1]){\n\t    cw*=sel(hv[tr[i-1]],sf);\n\t    sf=1;\n\t  }\n\t  else\n\t    ++sf;\n\t}\n\tcw*=sel(hv[tr[3]],sf);\n\tVI tp;\n\tforn(i,4){\n\t  tp=tr[i];\n\t  in ss=0;\n\t  forn(j,4){\n\t    rotate(tp.begin(),tp.begin()+1,tp.end());\n\t    ss+=(tp==tr[i]);\n\t  }\n\t  cw*=ss;\n\t}\n\tsm+=cw;\n      }\n      ++hv[socl[a]];\n    }\n  }\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int mod=1e7+9;\nconst int MAX_H=1e5+5;\n\nstruct Hash\n{\n    int nex, w, s;\n    ll val;\n    Hash(int _n=0, int _w=0, int _s=0, ll _v=0):nex(_n), w(_w), s(_s), val(_v){}\n}h[MAX];\n\nint tot, N, t, C[MAX][5], head[MAX_H];\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    if(id)\n    {\n        h[id].w+=t;\n        return;\n    }\n    id=++tot, h[id].nex=head[fr], h[id].val=H, head[fr]=id, h[id].w=t;\n    h[id].s=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n}\n\ninline int Find(ll H)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    return h[id].w*h[id].s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct squ\n{\n\tint a,b,c,d;\n\tbool operator == (const squ &u) const\n\t{\n\t\treturn (a==u.a && b==u.b && c==u.c && d==u.d);\n\t}\n\tbool operator < (const squ &u) const\n\t{\n\t\tif (a!=u.a) return a<u.a;\n\t\tif (b!=u.b) return b<u.b;\n\t\tif (c!=u.c) return c<u.c;\n\t\treturn d<u.d;\n\t}\n};\nint eqal(squ u,squ v)\n{\n\tint res=0;\n\tif (u==v) res++;\n\tif (u==(squ){v.b,v.c,v.d,v.a}) res++;\n\tif (u==(squ){v.c,v.d,v.a,v.b}) res++;\n\tif (u==(squ){v.d,v.a,v.b,v.c}) res++;\n\treturn res;\n}\nint n,x,y,z,w,lans,ans;\nvector<squ> v;\nmap<squ,int> mp;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x,&y,&z,&w);\n\t\tfor (int j=0;j<v.size();j++)\n\t\t{\n\t\t\tsqu cur=v[j],a1=(squ){x,w,cur.c,cur.b},a2=(squ){z,y,cur.a,cur.d},a3=(squ){y,x,cur.b,cur.a},a4=(squ){w,z,cur.d,cur.c};\n\t\t\tlans=mp[a1]-eqal(cur,a1);\n\t\t\tlans*=(mp[a2]-eqal(cur,a2)-eqal(a1,a2));\n\t\t\tlans*=(mp[a3]-eqal(cur,a3)-eqal(a1,a3)-eqal(a2,a3));\n\t\t\tlans*=(mp[a4]-eqal(cur,a4)-eqal(a1,a4)-eqal(a2,a4)-eqal(a3,a4));\n\t\t\tans+=lans;\n\t\t}\n\t\tv.push_back((squ){x,y,z,w});v.push_back((squ){y,z,w,x});v.push_back((squ){z,w,x,y});v.push_back((squ){w,x,y,z});\n\t\tmp[(squ){x,y,z,w}]++;mp[(squ){y,z,w,x}]++;mp[(squ){z,w,x,y}]++;mp[(squ){w,x,y,z}]++;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n#define MAXN 600\n\ntypedef array<short,4> tile;\n\nint n;\ntile a[MAXN];\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%hd\", &a[i][j]);\n\treturn 1;\n}\n\nvoid init() {\n}\n\ntile rotate(const tile &x, int k=1) {\n\ttile y;\n\tfor (int i=0; i<4; i++) y[(i+k) % 4] = x[i];\n\treturn y;\n}\n\ntile normalize(const tile &x) {\n\ttile z=x;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y<z) z=y;\n\t}\n\treturn z;\n}\n\nint mirror(const tile &x) {\n\tint r = 1;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y==x) r++;\n\t}\n\treturn r;\n}\n\ntile get_face(const tile &u, const tile &d, int x, int y) {\n\treturn normalize({u[x], u[y], d[3-y], d[3-x]});\n}\n\nlong solve() {\n\tmap<tile,long> ct;\n\tmap<tile,long> mi;\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] = normalize(a[i]);\n\t\tct[a[i]]++;\n\t\tmi[a[i]] = mirror(a[i]);\n\t}\n\tlong ans = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tct[a[i]]--;\n\t\tfor (int j=i+1; j<n; j++) {\n\t\t\tct[a[j]]--;\n\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\ttile d=a[i], u=rotate(a[j], k);\n\t\t\t\ttile f[4];\n\t\t\t\tlong r = 1;\n\t\t\t\tfor (int t=0; t<4; t++) {\n\t\t\t\t\tf[t] = get_face(u, d, t, (t+3)%4);\n\t\t\t\t\tr *= mi[f[t]] * ct[f[t]]--;\n\t\t\t\t}\n\t\t\t\t//printf(\"* %d %d %d: %ld\\n\", i, j, k, r);\n\t\t\t\tans += r;\n\t\t\t\tfor (int t=0; t<4; t++) ct[f[t]]++;\n\t\t\t}\n\t\t\tct[a[j]]++;\n\t\t}\n\t\tct[a[i]]++;\n\t}\n\treturn ans/3;\n}\n\nvoid output(long ans) {\n\tprintf(\"%ld\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[431];\nint l[103331];\nint j[3331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[1];\n\nP u[1];\npriority_queue<P> q;\n//stack<int> s;\nset<int> s;\nmap<long long,int> p;\n\nvector<int> v[100101];\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long f(long long x)\n{\n  int o[4],l[4];\n  l[0]=o[0]=x/1000000000;\n  l[1]=o[1]=x/1000000%1000;\n  l[2]=o[2]=x/1000%1000;\n  l[3]=o[3]=x%1000;\n  for(int i=1;i<=3;i++)\n  {\n    for(int h=0;h<4;h++)\n    if(o[(i+h)%4]>l[h]) break;\n    else if(o[(i+h)%4]<l[h])\n    {\n      for(int p=0;p<4;p++)\n        l[p]=o[(p+i)%4];\n      break;\n    }\n  }\n  long long z=0;\n  for(int h=0;h<4;h++)\n    z*=1000,z+=l[h];\n  return z;\n}\n\nint g(long long x)\n{\n  int n=x/1000000000,m=x/1000000%1000,c=x/1000%1000,d=x%1000;\n  if(n==m&&m==c&&c==d) return 4;\n  if(n==c&&m==d) return 2;\n  return 1;\n}\n\nint main()\n{\n  scanf(\"%d\",&a);\n  for(int t=1;t<=a;t++)\n  {\n    long long x=0;\n    for(int i=0;i<4;i++)\n    {\n      x*=1000;\n      scanf(\"%d\",&n);\n      x+=n;\n    }\n    o[t]=f(x);\n  }\n  for(int t=1;t<a;t++)\n  for(int w=t+1;w<=a;w++)\n  {\n    map<long long,int> p;\n    for(int i=t+1;i<=a;i++)\n    if(i!=w) p[o[i]]++;\n    long long l1[4],l2[4];\n    long long s[4];\n    l1[0]=o[t]/1000000000,l1[1]=o[t]/1000000%1000,l1[2]=o[t]/1000%1000,l1[3]=o[t]%1000;\n    l2[2]=o[w]/1000000000,l2[1]=o[w]/1000000%1000,l2[0]=o[w]/1000%1000,l2[3]=o[w]%1000;\n    for(int i=0;i<4;i++)\n    {\n      for(int h=0;h<4;h++)\n      {\n        s[h]=l1[(h+1)%4]*1000000000+l1[(h)%4]*1000000+l2[(h+i)%4]*1000+l2[(h+1+i)%4];\n        s[h]=f(s[h]);\n        //if(t==1&&w==5&&i==0)\n        //printf(\"@@%lld %d\\n\",s[h],p[s[h]]);\n      }\n      long long y=1;\n      for(int h=0;h<4;h++)\n      {\n        int e=0;\n        for(int i=0;i<h;i++)\n          if(s[i]==s[h])e++;\n        y*=(p[s[h]]-e);\n        y*=g(s[h]);\n      }\n      //if(t==1&&w==5)\n      x+=y;\n    }\n  }\n  printf(\"%lld\",x);\n}\n//0\n//21\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>box(N, vector<int>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tvector<vector<int>>p(4, vector<int>(4));\n\tfor (int i = 0; i < 4; i++) {\n\t\tp[i][0] = i;\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\tp[i][j] = (p[i][j - 1] + 3) % 4;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<int>old(4, -1);\n\t\t\t\tvector<long long int>num(4, 0);\n\t\t\t\tvector<long long int>sum(4, 0);\n\t\t\t\tfor (int l = i + 1; l < N; l++) {\n\t\t\t\t\tif (j == l)continue;\n\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << n << endl;\n\t\t\t\t\t\t//cout << \"hoge\" << endl;\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[l][m] && box[i][n] == box[l][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[l][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[l][(m + 3) % 4]) {\n\t\t\t\t\t\t\t\tsum[n]++;\n\t\t\t\t\t\t\t\tif (old[n] != l) {\n\t\t\t\t\t\t\t\t\tnum[n]++;\n\t\t\t\t\t\t\t\t\told[n] = l;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m]&&num[l]) {\n\t\t\t\t\t\t\tsum[l] -= sum[l] / num[l];\n\t\t\t\t\t\t\tnum[l]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 404;\nInt cs[4][MAX];\n\nusing A = array<Int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nmap<ll, Int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  Int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  Int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  Int n;\n  cin>>n;\n  for(Int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(Int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<A> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(Int i=0;i<8;i++) w[i]=i;\n    for(Int p=0;p<4;p++){\n      for(Int q=0;q<4;q++){\n        for(Int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(Int i=0;i<n;i++){\n    for(Int j=0;j<i;j++){\n      for(Int z=0;z<4;z++){\n        A x;\n        for(Int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        if(used.count(x)) continue;\n\n        Int way=0;\n        for(auto v:vs){\n          A y;\n          for(Int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          used.emplace(y);\n        }\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nvi normarize(const vi &v)\n{\n    vector<vi> r;\n    rep(i,4)\n    {\n        vi t;\n        rep(j,4) t.pb(v[(i+j)%4]);\n        r.pb(t);\n    }\n    sort(all(r));\n    return r[0];\n}\n\ninline ll P(int n, int r)\n{\n    if(n<r) return 0;\n\n    ll ret=1;\n    rep(i,r) ret*=n-i;\n    return ret;\n}\n\ninline ll POW(int x, int n)\n{\n    ll ret=1;\n    rep(i,n) ret*=x;\n    return ret;\n}\n\ninline ll DIM(const vi &v)\n{\n    if(v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) return 4;\n    else if(v[0]==v[2] && v[1]==v[3]) return 2;\n    return 1;\n}\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<vi> c(n,vi(4));\n    rep(i,n)rep(j,4) scanf(\" %d\", &c[i][j]);\n\n    map<vi,int> ct;\n    rep(i,n)\n    {\n        c[i]=normarize(c[i]);\n        if(ct.find(c[i])==ct.end()) ct[c[i]]=1;\n        else ++ct[c[i]];\n    }\n\n    ll ans=0;\n    // 上面i, 下面j\n    rep(i,n)rep(j,i)\n    {\n        // 下面の向きを設定\n        rep(k,4)\n        {\n            vi u;\n            rep(x,4) u.pb(c[j][(k+x)%4]);\n            swap(u[1],u[3]);\n\n            vector<vi> sides(4);\n            map<vi,int> sides_ct;\n            rep(x,4)\n            {\n                vi t(4);\n                t[0]=c[i][(x+1)%4];\n                t[1]=c[i][x];\n                t[2]=u[x];\n                t[3]=u[(x+1)%4];\n                t=normarize(t);\n\n                sides[x]=t;\n                if(sides_ct.find(t)==sides_ct.end()) sides_ct[t]=1;\n                else ++sides_ct[t];\n            }\n\n            ll add=1;\n            for(const auto &x:sides_ct)\n            {\n                vi key=x.fi;\n                int value=x.se;\n\n                // 使ってないタイルのうち当てはめられる個数\n                int num=ct[key];\n                if(c[i]==key) --num;\n                if(c[j]==key) --num;\n\n                // 選び方、向き、位置\n                add*=P(num,value)*POW(DIM(key),value);\n            }\n            ans+=add;\n        }\n    }\n\n    // 向かい合う面の個数ぶん重複する\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef pair<LD,LD> Pt;\ntypedef tuple<int,int,int> tiii;\ntypedef tuple<LL,LL,LL> tlll;\n#define mod9 1000000009ll\n#define mod7 1000000007ll\n#define INF  1023456789ll\n#define INF16 10000000000000000ll\n#define FI first\n#define SE second\n#define X FI\n#define Y SE\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nLL n , c[ N ][ 4 ];\nvoid build(){\n \n}\nmap< LL , int > cnt;\nmap< pair<LL,LL> , int > cnt2;\nmap< tuple<LL,LL,LL> , int > cnt3;\nmap< tuple<LL,LL,LL,LL> , int > cnt4;\ninline bool bye( const pair<LL,LL>& x ){\n  LL t[ 4 ] , rr = x.first;;\n  for( int i = 3 ; i >= 0 ; i -- ){\n    t[ i ] = rr % 1000;\n    rr /= 1000;\n  }\n  for( int i = 0 ; i < 4 ; i ++ ){\n    LL ret = 0;\n    for( int j = 0 ; j < 4 ; j ++ )\n      ret = ret * 1000 + t[ ( i + j ) & 3 ];\n    if( ret == x.second ) return false;\n  }\n  return true;\n}\ninline LL CNT( LL x ){\n  auto it = cnt.find( x );\n  return it == cnt.end() ? 0 : it->second;\n}\ninline LL CNT2( const pair<LL,LL>& x ){\n  auto it = cnt2.find( x );\n  return it == cnt2.end() ? 0 : it->second;\n}\ninline LL CNT3( const tuple<LL,LL,LL>& x ){\n  auto it = cnt3.find( x );\n  return it == cnt3.end() ? 0 : it->second;\n}\ninline LL CNT4( const tuple<LL,LL,LL,LL>& x ){\n  auto it = cnt4.find( x );\n  return it == cnt4.end() ? 0 : it->second;\n}\nvector< LL > vv[ N ];\nunordered_set< LL > cand;\ninline void modify( int id , int dlt ){\n  if( vv[ id ].size() > 3u && vv[ id ][ 0 ] == vv[ id ][ 3 ] ){\n    cnt[ vv[ id ][ 0 ] ] += dlt * (1 << 2);\n    cnt2[ { vv[ id ][ 0 ] , vv[ id ][ 0 ] } ] += dlt * (1 << 4);\n    cnt3[ make_tuple( vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] ) ] += dlt * (1 << 6);\n    cnt4[ make_tuple( vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] ) ] += dlt * (1 << 8);\n  }else{\n    for( LL i1 : vv[ id ] ){\n      cnt[ i1 ] += dlt;\n      if( vv[ id ].size() > 1u )\n      for( LL i2 : vv[ id ] ){\n        cnt2[ { i1 , i2 } ] += dlt;\n        if( vv[ id ].size() > 2u )\n        for( LL i3 : vv[ id ] ){\n          cnt3[ make_tuple( i1 , i2 , i3 ) ] += dlt;\n          if( vv[ id ].size() > 3u )\n          for( LL i4 : vv[ id ] )\n            cnt4[ make_tuple( i1 , i2 , i3 , i4 ) ] += dlt;\n        }\n      }\n    }     \n  }\n}\ninline LL zip( LL za , LL zb , LL zc , LL zd ){\n  LL ret = 0;\n  for( LL i : { za , zb , zc , zd } )\n    ret = ret * 1000 + i;\n  return ret;\n}\nvoid init(){\n  scanf( \"%lld\" , &n );\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      scanf( \"%lld\" , &c[ i ][ j ] );\n    // for( int j = 0 ; j < 4 ; j ++ ){\n      // LL ret = 0;\n      // for( int k = 0 ; k < 4 ; k ++ )\n        // ret = ret * 1000 + c[ i ][ ( j + k ) % 4 ];\n      // vv[ i ].push_back( ret );\n    // }\n    sort( vv[ i ].begin() , vv[ i ].end() );\n  }\n}\nvoid solve(){\n  LL ans = 0;\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = i - 1 ; j >= 0 ; j -- ){\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL iv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          iv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , iv[ 1 ] , iv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , iv[ 2 ] , iv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , iv[ 3 ] , iv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , iv[ 0 ] , iv[ 3 ] );\n        cand.insert( f1 );\n        cand.insert( f2 );\n        cand.insert( f3 );\n        cand.insert( f4 );\n      }\n    }\n  }\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ ){\n      LL ret = 0;\n      for( int k = 0 ; k < 4 ; k ++ )\n        ret = ret * 1000 + c[ i ][ ( j + k ) % 4 ];\n      if( cand.count( ret ) )\n        vv[ i ].push_back( ret );\n    }\n    sort( vv[ i ].begin() , vv[ i ].end() );\n  }\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = i - 1 ; j >= 0 ; j -- ){\n      if( j != i - 1 ) modify( j , -1 );\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL iv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          iv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , iv[ 1 ] , iv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , iv[ 2 ] , iv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , iv[ 3 ] , iv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , iv[ 0 ] , iv[ 3 ] );\n        // A , B , C , D\n        LL tans = CNT( f1 ) * CNT( f2 ) * CNT( f3 ) * CNT( f4 );\n        if( tans > 0 ){\n          // { A , A } , { B , B }\n          tans += CNT2( { f1 , f2 } ) * CNT2( { f3 , f4 } );\n          tans += CNT2( { f1 , f3 } ) * CNT2( { f2 , f4 } );\n          tans += CNT2( { f1 , f4 } ) * CNT2( { f2 , f3 } );\n          // { A , A , A } , B\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f3 ) ) * CNT( f4 );\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f4 ) ) * CNT( f3 );\n          tans += 2ll * CNT3( make_tuple( f1 , f3 , f4 ) ) * CNT( f2 );\n          tans += 2ll * CNT3( make_tuple( f2 , f3 , f4 ) ) * CNT( f1 );\n          if( tans > 0 ){\n            // { A , A } , B , C\n            tans -= CNT2( { f1 , f2 } ) * CNT( f3 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f3 } ) * CNT( f2 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f4 } ) * CNT( f2 ) * CNT( f3 );\n            tans -= CNT2( { f2 , f3 } ) * CNT( f1 ) * CNT( f4 );\n            tans -= CNT2( { f2 , f4 } ) * CNT( f1 ) * CNT( f3 );\n            tans -= CNT2( { f3 , f4 } ) * CNT( f1 ) * CNT( f2 );\n            // { A , A , A , A }\n            tans -= 6ll * CNT4( make_tuple( f1 , f2 , f3 , f4 ) );\n          }\n        }\n        ans += tans;\n      }\n      modify( j , +1 );\n    }\n  }\n  printf( \"%lld\\n\" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define ll long long\n#define N 410\nusing namespace std;\nstruct node{\n\tint a,b,c,d;\n\tnode(int A=0,int B=0,int C=0,int D=0):a(A),b(B),c(C),d(D){}\n\tvoid rotate(){int t=a;a=b,b=c,c=d,d=t;}\n\tbool operator<(const node u)const\n\t{\n\t\tif(a!=u.a) return a<u.a;\n\t\tif(b!=u.b) return b<u.b;\n\t\tif(c!=u.c) return c<u.c;\n\t\treturn d<u.d;\n\t}\n\tnode operator <<(const int a)const{node p=*this;for(int i=1;i<=a%4;i++){int swp=p.a;p.a=p.b;p.b=p.c;p.c=p.d;p.d=swp;}return p;}\n\tvoid operator <<=(const int a){*this=(*this)<<a;}\n}p[N];\nnode operator |(const node a,const node b)\n{\n\treturn node(a.b,a.a,b.a,b.d);\n}\nmap<node,int>mp;\nvoid insert(node a)\n{\n\tmp[a]++;mp[a<<1]++;\n\tmp[a<<2]++;mp[a<<3]++;\n}\nvoid del(node a){mp[a]--;mp[a<<1]--;mp[a<<2]--;mp[a<<3]--;}\nnode np[4],s1,s2;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&p[i].a,&p[i].b,&p[i].c,&p[i].d);\n\t\tinsert(p[i]);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdel(p[i]);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tdel(p[j]);\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tp[j]<<=1;s1=p[i],s2=p[j];\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t{\n\t\t\t\t\tnp[l]=s1|s2;\n\t\t\t\t\ts1<<=1,s2<<=3;\n\t\t\t\t}\n\t\t\t\tif(mp.count(np[0]) && mp.count(np[1]) && mp.count(np[2]) && mp.count(np[3]))\n\t\t\t\t{\n\t\t\t\t\tlong long sum=1ll;\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tsum*=mp[np[l]],del(np[l]);\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tinsert(np[l]);\n\t\t\t\t\tans+=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsert(p[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=405;\nint n;\nclass Tiles{\npublic:\n\tint c[4];\n\tTiles(){}\n\tTiles(int c0,int c1,int c2,int c3){c[0]=c0;c[1]=c1;c[2]=c2;c[3]=c3;}\n\tbool operator < (const Tiles &o)const{\n\t\trep(i,4)if(c[i]!=o.c[i])return c[i]<o.c[i];\n\t\treturn false;\n\t}\n\tbool operator == (const Tiles &o)const{\n\t\trep(i,4)if(c[i]!=o.c[i])return false;\n\t\treturn true;\n\t}\n\tTiles rotate(){\n\t\tTiles res;\n\t\trep(i,4)res.c[(i+1)%4]=c[i];\n\t\treturn res;\n\t}\n\tTiles change(){\n\t\tTiles cur=*this,res=*this;\n\t\trep(i,3){\n\t\t\tcur=cur.rotate();\n\t\t\tif(cur<res)res=cur;\n\t\t}\n\t\treturn res;\n\t}\n\tint countway(){\n\t\tTiles cur=*this;\n\t\tint res=0;\n\t\trep(i,4){\n\t\t\tcur=cur.rotate();\n\t\t\tif(cur==*this)res++;\n\t\t}\n\t\treturn res;\n\t}\n\tll gethash(){\n\t\tll h=0;\n\t\trep(i,4)h=1000LL*h+c[i];\n\t\treturn h;\n\t}\n};\nset<Tiles>s;\nmap<ll,int>cnt,way;\nint fac[maxn];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tREP(i,4)fac[i]=fac[i-1]*i;\n\trep(i,n){\n\t\tTiles tmp;\n\t\trep(j,4)scanf(\"%d\",&tmp.c[j]);\n\t\ttmp=tmp.change();\n\t\tway[tmp.gethash()]=tmp.countway();\n\t\tcnt[tmp.gethash()]++;\n\t\ts.insert(tmp);\n\t}\n\tll ans=0;\n\tmap<ll,int>used;\n\tfor(set<Tiles>::iterator it=s.begin();it!=s.end();it++){\n\t\tTiles cur1=*it;\n\t\tll h1=cur1.gethash();\n\t\tll coef=cnt[h1];\n\t\tcnt[h1]--;\n\t\tfor(set<Tiles>::iterator it2=s.begin();it2!=s.end();it2++){\n\t\t\tTiles cur2=*it2;\n\t\t\tll h2=cur2.gethash();\n\t\t\tll coef2=coef;\n\t\t\tif(cnt[h2]!=0)coef2*=cnt[h2],cnt[h2]--;\n\t\t\telse continue;\n\t\t\trep(i,4){\n\t\t\t\tll now=coef2;\n\t\t\t\tvector<ll>v;\n\t\t\t\tbool ok=true;\n\t\t\t\trep(j,4){\n\t\t\t\t\tTiles cur3=Tiles(cur1.c[j],cur2.c[(4-j)%4],cur2.c[(4-(j+1)%4)%4],cur1.c[(j+1)%4]);\n\t\t\t\t\tcur3=cur3.change();\n\t\t\t\t\tll h3=cur3.gethash();\n\t\t\t\t\tif(!cnt.count(h3)||!cnt[h3]){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnow*=cnt[h3]*way[h3];\t\t\t\t\t\n\t\t\t\t\tcnt[h3]--;\n\t\t\t\t\tv.pb(h3);\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tans+=now;\n\t\t\t\t}\n\t\t\t\trep(j,v.size())cnt[v[j]]++;\n\t\t\t\tcur2=cur2.rotate();\n\t\t\t}\n\t\t\tcnt[h2]++;\n\t\t}\n\t\tcnt[h1]++;\n\t}\n\tprintf(\"%lld\\n\",ans/6);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma GCC optimize(\"O3\")\n#endif\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n \n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n \ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n \n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n \ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n \ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n \ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n \nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n \ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n \nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n \n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n \n// }}}\n \nconst int N=404;\n \ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n \ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n \ninline LL norm( LL x ) {\n    return min(x,min(rot(x),min(rot(rot(x)),rot(rot(rot(x))))));\n}\n \ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n \nint n,a[N][4],rc[16];\nLL b[N],dp[16];\n \nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n \n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    int lc[4]={1,1,1,1};\n    REP(i,4) while ( lc[i]<4 && c[i][lc[i]]!=c[i][0] ) lc[i]++;\n    REP(i,4) rc[i]=4/lc[i];\n    REP(i,4) sort(c[i],c[i]+lc[i]);\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    REP1(i,ti+1,n) if ( i!=bi ) {\n#define F(j,k) if ( !((j>>k)&1) && b[i]==c[k][0] ) dp[j|(1<<k)]+=rc[k]*dp[j]\n        F(14,0); F(14,1); F(14,2); F(14,3);\n        F(13,0); F(13,1); F(13,2); F(13,3);\n        F(12,0); F(12,1); F(12,2); F(12,3);\n        F(11,0); F(11,1); F(11,2); F(11,3);\n        F(10,0); F(10,1); F(10,2); F(10,3);\n        F(9,0); F(9,1); F(9,2); F(9,3);\n        F(8,0); F(8,1); F(8,2); F(8,3);\n        F(7,0); F(7,1); F(7,2); F(7,3);\n        F(6,0); F(6,1); F(6,2); F(6,3);\n        F(5,0); F(5,1); F(5,2); F(5,3);\n        F(4,0); F(4,1); F(4,2); F(4,3);\n        F(3,0); F(3,1); F(3,2); F(3,3);\n        F(2,0); F(2,1); F(2,2); F(2,3);\n        F(1,0); F(1,1); F(1,2); F(1,3);\n        F(0,0); F(0,1); F(0,2); F(0,3);\n        // for ( int j=14; j>=0; j-- ) REP(k,4) if ( !bit(j,k) && b[i]==c[k][0] ) {\n            // dp[j|(1<<k)]+=rc[k]*dp[j];\n        // }\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[15];\n}\n \nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    // n=400;\n    REP1(i,1,n) b[i]=norm(f(a[i][0],a[i][1],a[i][2],a[i][3]));\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 500\n\nvector<vector<int>> a;\nmap<vector<int>, int> cnt, mul;\n\nvoid norm(vector<int> &a){\n\tvector<int> b(a);\n\trep(i, 4){\n\t\tif(b<a) a = b;\n\t\trotate(b.begin(), b.begin()+1, b.end());\n\t}\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\ta = vector<vector<int>>(n, vector<int>(4));\n\trep(i, n){\n\t\trep(j, 4) cin>>a[i][j];\n\t}\n\trep(i, n) norm(a[i]);\n\t//sort(all(a));\n\trep(i, n) ++cnt[a[i]];\n\trep(i, n){\n\t\tvector<int> b(a[i]);\n\t\tif(mul[b]) continue;\n\t\trep(j, 4){\n\t\t\tif(b==a[i]) ++mul[b];\n\t\t\trotate(b.begin(), b.begin()+1, b.end());\n\t\t}\n\t}\n\tll res = 0;\n\trep(i, n){\n\t\t--cnt[a[i]];\n\t\tvector<int> ai(a[i]);\n\t\trep(j, i){\n\t\t\t--cnt[a[j]];\n\t\t\tvector<int> aj(a[j]); swap(aj[1], aj[3]);\n\t\t\trep(k, 4){\n\t\t\t\trotate(aj.begin(), aj.begin()+1, aj.end());\n\t\t\t\tvector<vector<int>> b(4, vector<int>(4));\n\t\t\t\tbool sk = false;\n\t\t\t\trep(l, 4){\n\t\t\t\t\tb[l][1] = ai[(l+0)%4];\n\t\t\t\t\tb[l][0] = ai[(l+1)%4];\n\t\t\t\t\tb[l][3] = aj[(l+1)%4];\n\t\t\t\t\tb[l][2] = aj[(l+0)%4];\n\t\t\t\t\tnorm(b[l]);\n\t\t\t\t\tif(!cnt.count(b[l])) sk = true;\n\t\t\t\t}\n\t\t\t\tif(sk) continue;\n\t\t\t\tll r = 1;\n\t\t\t\trep(l, 4){\n\t\t\t\t\tr *= cnt[b[l]]--*mul[b[l]];\n\t\t\t\t}\n\t\t\t\tres += r;\n\t\t\t\trep(l, 4) ++cnt[b[l]];\n\t\t\t}\n\t\t\t++cnt[a[j]];\n\t\t}\n\t\t++cnt[a[i]];\n\t}\n\tcout<<res/3<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {}, e[16][4] = {};\n  \tfor (int i = 0; i < 16; i++) for (int j = 0; j < 4; j++) if (i & (1 << j)) e[i][j] = 1;\n    ll z = 0;\n    cin >> n;\n    //for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                int c[4] = {}, b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}};\n              \tll d[16] = {1};\n                for (int l = i + 1; l <= n; l++) {\n                  \tfor (int m = 0; m < 4; m++) {\n                      \tc[m] = 0;\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[m]++;\n                    }\n                  \tif (l == j) continue;\n                    d[15] += c[0] * d[14];\n                    d[15] += c[1] * d[13];\n                    d[15] += c[2] * d[11];\n                    d[15] += c[3] * d[7];\n                    d[14] += c[1] * d[12];\n                    d[14] += c[2] * d[10];\n                    d[14] += c[3] * d[6];\n                    d[13] += c[0] * d[12];\n                    d[13] += c[2] * d[9];\n                    d[13] += c[3] * d[5];\n                    d[12] += c[2] * d[8];\n                    d[12] += c[3] * d[4];\n                    d[11] += c[0] * d[10];\n                    d[11] += c[1] * d[9];\n                    d[11] += c[3] * d[3];\n                    d[10] += c[1] * d[8];\n                    d[10] += c[3] * d[2];\n                    d[9] += c[0] * d[8];\n                    d[9] += c[3] * d[1];\n                    d[8] += c[3] * d[0];\n                    d[7] += c[0] * d[6];\n                    d[7] += c[1] * d[5];\n                    d[7] += c[2] * d[3];\n                    d[6] += c[1] * d[4];\n                    d[6] += c[2] * d[2];\n                    d[5] += c[0] * d[4];\n                    d[5] += c[2] * d[1];\n                    d[4] += c[2] * d[0];\n                    d[3] += c[0] * d[2];\n                    d[3] += c[1] * d[1];\n                    d[2] += c[1] * d[0];\n                    d[1] += c[0] * d[0];\n                }\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<int,15>,4> >M;\nmap<long,map<int,int> >Q;\nint a[400],b[400],c[400],d[400];\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tlong C=conv(a[i],b[i],c[i],d[i]);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C]++;\n\t\t\tC=rotate(C);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<int,15>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<=j;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tA[0][j*(j+1)/2+k]=sum-j-k;\n\t\t\tA[1][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\tA[2][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\tA[3][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tint a=Q[t[k]][i];\n\t\t\t\t\tint b=Q[t[k]][j];\n\t\t\t\t\tif(a<b)a^=b^=a^=b;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][a*(a+1)/2+b];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nvector<int> Normalize(vector<int> xs) {\n  vector<deque<int>> rs;\n  deque<int> q(xs.begin(), xs.end());\n  rs.push_back(q);\n  for (int i = 0; i < 3; i++) {\n    q.push_back(q.front());\n    q.pop_front();\n    rs.push_back(q);\n  }\n  sort(rs.begin(), rs.end());\n  return vector<int>(rs[0].begin(), rs[0].end());\n}\n\nint64 Encode(vector<int> xs) {\n  int64 r = 0;\n  for (int i = 0; i < 4; i++) {\n    r *= 2000;\n    r += xs[i];\n  }\n  return r;\n}\n\nint Symmetry(vector<int> xs) {\n  if (xs[0] == xs[1] && xs[1] == xs[2] && xs[2] == xs[3]) return 4;\n  if (xs[0] == xs[2] && xs[1] == xs[3]) return 2;\n  return 1;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  s << \"[\";\n  for (int i = 0; i < len; i++) {\n    if (i > 0) s << \", \";\n    s << v[i];\n  }\n  s << \"]\";\n  return s;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> faces;\n  for (int i = 0; i < n; i++) {\n    vector<int> cs(4);\n    for (int j = 0; j < 4; j++) {\n      cin >> cs[j];\n    }\n    faces.push_back(Normalize(cs));\n  }\n  vector<int64> encoded_faces(n);\n  for (int i = 0; i < n; i++) {\n    encoded_faces[i] = Encode(faces[i]);\n  }\n\n  int64 ans = 0;\n  for (int f1 = 0; f1 < n; f1++) {\n    for (int f2 = f1 + 1; f2 < n; f2++) {\n      for (int d2 = 0; d2 < 4; d2++) {\n        vector<int> vs(8);\n        for (int i = 0; i < 4; i++) vs[i] = faces[f1][i];\n        for (int i = 0; i < 4; i++) vs[7 - i] = faces[f2][(d2 + i) % 4];\n        // cout << vs << endl;\n\n        unordered_map<int64, int> r_count;\n        r_count[Encode(Normalize({vs[4], vs[5], vs[1], vs[0]}))]++;\n        r_count[Encode(Normalize({vs[5], vs[6], vs[2], vs[1]}))]++;\n        r_count[Encode(Normalize({vs[6], vs[7], vs[3], vs[2]}))]++;\n        r_count[Encode(Normalize({vs[7], vs[4], vs[0], vs[3]}))]++;\n\n        unordered_map<int64, int> s_count;\n        unordered_map<int64, int> symmetry_map;\n        for (int f3 = f1 + 1; f3 < n; f3++) {\n          if (f3 == f2) continue;\n          // cout << faces[f3] << endl;\n          if (r_count.find(encoded_faces[f3]) != r_count.end()) {\n            s_count[encoded_faces[f3]]++;\n            symmetry_map[encoded_faces[f3]] = Symmetry(faces[f3]);\n          }\n        }\n\n        // for (const auto& kv : r_count) {\n        //   cout << kv.first << \" \" << s_count[kv.first] << \" \";\n        // }\n        // cout << endl;\n\n        int64 inc = 1;\n        for (const auto& kv : r_count) {\n          int r = kv.second;\n          int s = s_count[kv.first];\n          if (r > s) inc *= 0;\n          for (int k = 0; k < r; k++) {\n            inc *= (s - k);\n            inc *= symmetry_map[kv.first];\n          }\n        }\n        ans += inc;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N*4];\nint pa[4]={1,0,3,2};\n\nint main(){\n\tscanf(\"%d\",&N);\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tT[i*4]=TILE(a,b,c,d,i);\n\t\tFOR(j,1,4){\n\t\t\tT[i*4+j]=rotate(T[i*4],j);\n\t\t}\n\t}\n\tsort(T,T+N*4);\n\tll ans=0;\n\tTILE TI[6];\n\tint cnt[4];\n\tint cnt2[4][4];\n\tREP(i,N*4){\n\t\tTI[0]=T[i];\n\t\tREP(j,N*4){\n\t\t\tif (TI[0].index==T[j].index) continue;\n\t\t\tTI[1]=T[j];\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tREP(k,4){\n\t\t\t\tTI[k+2]=TILE(TI[0].c[(k+1)%4],TI[0].c[k],TI[1].c[pa[k]],TI[1].c[pa[(k+1)%4]],0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcnt[k]=upper_bound(T,T+N*4,TI[k+2])-lower_bound(T,T+N*4,TI[k+2]);\n\t\t\t\tREP(a,2){\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a],b)){\n\t\t\t\t\t\t\tcnt[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tFOR(a,k+1,4){\n\t\t\t\t\tcnt2[k][a]=0;\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a+2],b)){\n\t\t\t\t\t\t\tcnt2[k][a]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tll temp=1;\n\t\t\tREP(k,4){\n\t\t\t\tREP(a,k){\n\t\t\t\t\tcnt[k]-=cnt2[a][k];\n\t\t\t\t}\n\t\t\t\tif (cnt[k]<0){\n\t\t\t\t\tf=true;\n\t\t\t\t}else{\n\t\t\t\t\ttemp*=cnt[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f){\n\t\t\t\tans+=temp;\n\t\t\t}\n\t\t}\n\t}\n\tans/=24;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 402\n\nstruct st{\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n\tint id;\n\tst(int a_, int b_, int c_, int d_,int id_){\n\t\ta = a_;\n\t\tb = b_;\n\t\tc = c_;\n\t\td = d_;\n\t\tid = id_;\n\t}\n\tvoid flip(){\n\t\tint A = a;\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;\n\t\td = A;\n\t}\n\tlong long int outt(){\n\t\tlong long int R = LLONG_MAX;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tlong long int f = 1000 + a;\n\t\t\tf *= 1000;\n\t\t\tf += b;\n\t\t\tf *= 1000;\n\t\t\tf += c;\n\t\t\tf *= 1000;\n\t\t\tf += d;\n\t\t\tR = min(R, f);\n\t\t\tflip();\n\t\t}\n\t\treturn R;\n\t}\n\tint get_circle(){\n\t\tif (a == b&&b == c&&c == d){\n\t\t\treturn 4;\n\t\t}\n\t\tif (a == c&&b==d){\n\t\t\treturn 2;\n\t\t}\n\t\treturn 1;\n\t}\n};\n\nint n;\n\nvector<st> v;\n\nvector<st> vv;\n\nbool same(st &a, st &b){\n\treturn (a.a == b.a) && (a.b == b.b) && (a.c == b.c) && (a.d == b.d);\n}\n\n\nmap<pair<long long int,pair<long long int,pair<long long int,long long int> > > , long long int> mp;\n\npair<long long int, pair<long long int, pair<long long int, long long int> > > MAKE2(long long int a=-1, long long int b=-1, long long int c=-1, long long int d=-1){\n\tpair<long long int, pair<long long int, pair<long long int, long long int> > > r;\n\tr.first = a;\n\tr.second.first = b;\n\tr.second.second.first = c;\n\tr.second.second.second = d;\n\treturn r;\n}\nvoid ins(st a,int c){\n\tvector<long long int> V;\n\tfor (int i = 0; i < 4; i++){\n\t\tV.push_back(a.outt());\n\t\ta.flip();\n\t}\n\tfor (int i = 0; i < V.size(); i++){\n\t\tmp[MAKE2(V[i])]+=c;\n\t\tfor (int j = 0; j < V.size(); j++){\n\t\t\tmp[MAKE2(V[i],V[j])]+=c;\n\t\t\tfor (int k = 0; k < V.size(); k++){\n\t\t\t\tmp[MAKE2(V[i],V[j],V[k])]+=c;\n\t\t\t\tfor (int kk = 0; kk < V.size(); kk++){\n\t\t\t\t\tmp[MAKE2(V[i],V[j],V[k],V[kk])]+=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmap<long long int, int> mpp[5];\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tv.push_back(st(a, b, c, d,i));\n\t\tst tmp = v.back();\n\t\tfor (int j = 0; j < 4; j++){\n\t\t\tvv.push_back(tmp);\n\t\t\ttmp.flip();\n\t\t}\n\t\t//ins(tmp, 1);\n\t\tmpp[tmp.get_circle()][tmp.outt()]++;\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < v.size(); i++){\n\t\tmpp[v[i].get_circle()][v[i].outt()]--;\n\t\tfor (int j = 0; j < vv.size(); j++){\n\t\t\tif (v[i].id >= vv[j].id)continue;\n\t\t\t\tint used_id_up = v[i].id;\n\t\t\t\tint used_id_dw = vv[j].id;\n\t\t\t\tmpp[v[used_id_dw].get_circle()][v[used_id_dw].outt()]--;\n\t\t\t\t//ins(v[used_id_dw], -1);\n\t\t\t\tint ar[] = { v[i].d, v[i].c, v[i].b, v[i].a };\n\t\t\t\tint ar2[] = { vv[j].a, vv[j].b, vv[j].c, vv[j].d };\n\t\t\t\tlong long int cnt = 1;\n\t\t\t\tvector<long long int> V;\n\t\t\t\tfor (int jj = 0; jj < 4; jj++){\n\t\t\t\t\t st f(ar[jj], ar[(jj + 1) % 4], ar2[(jj + 1) % 4], ar2[jj], 1);\n\t\t\t\t\t int cy = f.get_circle();\n\t\t\t\t\t long long int id = f.outt();\n\t\t\t\t\t if (mpp[cy].count(id)){\n\t\t\t\t\t\t cnt *=(long long int)(cy)*mpp[cy][id];\n\t\t\t\t\t\t mpp[cy][id]--;\n\t\t\t\t\t }\n\t\t\t\t\t else{\n\t\t\t\t\t\t cnt = 0;\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\tfor (int jj = 0; jj < 4; jj++){\n\t\t\t\t\tst f(ar[jj], ar[(jj + 1) % 4], ar2[(jj + 1) % 4], ar2[jj], 1);\n\t\t\t\t\tint cy = f.get_circle();\n\t\t\t\t\tlong long int id = f.outt();\n\t\t\t\t\tif (mpp[cy].count(id)){\n\t\t\t\t\t\tmpp[cy][id]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*for (int ii = 0; ii < (1 << 4); ii++){\n\t\t\t\t\tlong long int way = 1;\n\t\t\t\t\tlong long int DD[] = { -1, -1, -1, -1 };\n\t\t\t\t\tint DD_siz = 0;\n\t\t\t\t\tfor (int jj = 0; jj < 4; jj++){\n\t\t\t\t\t\tif ((ii>> jj) & 1){\n\t\t\t\t\t\t\tDD[DD_siz]=(st(ar[jj], ar[(jj + 1) % 4], ar2[(jj + 1) % 4], ar2[jj], 1).outt());\n\t\t\t\t\t\t\tDD_siz++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tway *= mp[MAKE2(st(ar[jj], ar[(jj + 1) % 4], ar2[(jj + 1) % 4], ar2[jj], 1).outt())];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (DD_siz == 1)continue;\n\t\t\t\t\tif (DD_siz)way *= mp[MAKE2(DD[0],DD[1],DD[2],DD[3])];\n\t\t\t\t\tif (way){\n\t\t\t\t\t\tputs(\"H\");\n\t\t\t\t\t}\n\t\t\t\t\tif (ii == 0){\n\t\t\t\t\t\tcnt += way;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (DD_siz % 2==0){\n\t\t\t\t\t\tcnt -= way;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcnt += way;\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tans += cnt;\n\t\t\t\t//ins(v[used_id_dw], 1);\n\t\t\t\tmpp[v[used_id_dw].get_circle()][v[used_id_dw].outt()]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nconst int MAX_N = 405;\ntypedef long long i64;\n\nint C[MAX_N][4], N;\nmap<pair<pair<int, int>, pair<int, int> >, int> cnt;\n\nvoid insert(int col[4]) {\n  static int t[4];\n  for (int i = 0; i < 4; ++i) {\n    for (int j = 0; j < 4; ++j) t[j] = col[(j + i) % 4];\n    cnt[make_pair(make_pair(t[0], t[1]), make_pair(t[2], t[3]))]++;\n  }\n}\n\nvoid substract(int col[4]) {\n  static int t[4];\n  for (int i = 0; i < 4; ++i) {\n    for (int j = 0; j < 4; ++j) t[j] = col[(j + i) % 4];\n    cnt[make_pair(make_pair(t[0], t[1]), make_pair(t[2], t[3]))]--;\n  }  \n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i)\n    for (int j = 0; j < 4; ++j)\n      scanf(\"%d\", &C[i][j]);\n\n  i64 res = 0;\n  for (int i = 1; i <= N; ++i) {\n    for (int j = 1; j < i; ++j) {\n      substract(C[j]);\n      for (int d = 0; d < 4; ++d) {\n\tstatic int t[4], A[4];\n\ti64 num = 1;\n\tfor (int k = 0; k < 4; ++k) t[k] = C[j][((k + d) % 4) ^ 1];\n\tfor (int k = 0; k < 4; ++k) {\n\t  A[0] = C[i][(k + 1) % 4], A[1] = C[i][k];\n\t  A[3] = t[(k + 1) % 4], A[2] = t[k];\n\t  num *= cnt[make_pair(make_pair(A[0], A[1]), make_pair(A[2], A[3]))];\n\t  substract(A);\n\t}\n\tfor (int k = 0; k < 4; ++k) {\n\t  A[0] = C[i][(k + 1) % 4], A[1] = C[i][k];\n\t  A[3] = t[(k + 1) % 4], A[2] = t[k];\n\t  insert(A);\n\t}\n\tres += num;\n      }\n      insert(C[j]);\n    }\n    insert(C[i]);\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nunordered_map<ll, int> dp;\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    double ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p1 = c[i];\n            for(int k=0;k<4;k++){\n                del(p1);\n                piipii p2 = c[j];\n                for(int l=0;l<4;l++){\n                    del(p2);\n\n                    double res = 1;\n                    piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                    piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                    piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                    piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                    if(dp.count(get_idx(tmp1))){\n                        res *= dp[get_idx(tmp1)];\n                        del(tmp1);\n                    }\n                    else res = 0;\n                    if(dp.count(get_idx(tmp2))){\n                        res *= dp[get_idx(tmp2)];\n                        del(tmp2);\n                    }\n                    else res = 0;\n                    if(dp.count(get_idx(tmp3))){\n                        res *= dp[get_idx(tmp3)];\n                        del(tmp3);\n                    }\n                    else res = 0;\n                    if(dp.count(get_idx(tmp4))){\n                        res *= dp[get_idx(tmp4)];\n                        del(tmp4);\n                    }\n                    else res = 0;\n\n                    ans += res;\n\n                    if(dp.count(get_idx(tmp1))){\n                        add(tmp1);\n                    }\n                    if(dp.count(get_idx(tmp2))){\n                        add(tmp2);\n                    }\n                    if(dp.count(get_idx(tmp3))){\n                        add(tmp3);\n                    }\n                    if(dp.count(get_idx(tmp4))){\n                        add(tmp4);\n                    }\n                    \n                    add(p2);\n                    p2 = rotate(p2);\n                }\n\n                add(p1);\n                p1 = rotate(p1);\n            }\n        }\n    }\n    printf(\"%.0lf\\n\", ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<vector<int>> masks(4);\n    for (int i=0;i<16;++i){\n        for (int j=0;j<4;++j){\n            if (!(i&1<<j)) masks[j].emplace_back(i);\n        }\n    }\n    vector<ll> po(4,1);\n    for (int i=0;i<3;++i) po[i+1]=po[i]*1000;\n    vector<vector<ll>> hash(N,vector<ll>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            for (int k=0;k<4;++k){\n                hash[i][j]+=C[i][(j+k)%4]*po[k];\n            }\n        }\n    }\n    vector<int> rot(4);\n    vector<vector<int>> surface(4,vector<int>(4));\n    vector<ll> hashedsurface(4);\n    vector<vector<ll>> dp(N+1,vector<ll>(16));\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                    if (surface[q][0]==surface[q][1]\n                        &&surface[q][1]==surface[q][2]\n                        &&surface[q][2]==surface[q][3]\n                        &&surface[q][3]==surface[q][0]) rot[q]=4;\n                    else if (surface[q][0]==surface[q][2]\n                            &&surface[q][1]==surface[q][3]) rot[q]=2;\n                    else rot[q]=1;\n                    hashedsurface[q]=0;\n                    for (int r=0;r<4;++r){\n                        hashedsurface[q]+=surface[q][r]*po[r];\n                    }\n                }\n                for (int l=0;l<16;++l) dp[i+1][l]=0;\n                dp[i+1][0]=1;\n                for (int k=i+1;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]=dp[k][l];\n                    if (k==j) continue;\n                    for (int l=0;l<4;++l){\n                        bool flag=false;\n                        for (int m=0;m<4;++m){\n                            if (hashedsurface[l]==hash[k][m]){\n                                flag=true;\n                            }\n                        }\n                        if (flag){\n                            for (int mask:masks[l]){\n                                dp[k+1][mask|1<<l]+=dp[k][mask]*rot[l];\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 1005, base = 9971 ; \nconst int trans[6][8] = {\n\t{0, 1, 2, 3, 4, 5, 6, 7}, \n\t{7, 6, 5, 4, 3, 2, 1, 0},\n\t{4, 5, 1, 0, 7, 6, 2, 3}, \n\t{3, 2, 6, 7, 0, 1, 5, 4}, \n\t{7, 4, 0, 3, 6, 5, 1, 2}, \n\t{2, 1, 5, 6, 3, 0, 4, 7}\n} ;\nconst int turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <int>, bool> exist ;\nmap <vector <int>, int> Count ;\nmap <vector <int>, int> calc ;\nint col[N][5], n ;\nll C[N << 2][7], sum ;\n\nbool check(vector <int> p) {\n\tvector <int> a ;\n\trep(i, 0, 7) a.push_back(0) ;\n\trep(i, 0, 5) rep(j, 0, 3) {\n\t\trep(k, 0, 3) a[k] = p[trans[i][(k + j) % 4]], a[k + 4] = p[trans[i][(k + j) % 4 + 4]] ;\n\t\tif (exist[a]) return false ;\n\t}\n\treturn true ;\n}\n\ninline bool cmp(vector <int> a, vector <int> b) {\n\trep(i, 0, 3) {\n\t\tif (a[i] < b[i]) return true ;\n\t\tif (a[i] > b[i]) return false ;\n\t}\n\treturn false ;\n}\n\ninline void getmin(vector <int> &p) {\n\tvector <int> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (cmp(tmp, ret)) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nvector <int> vec[N] ;\nmap <vector <int>, int> used, mul ;\n\nvoid solve(int x0, int x1, int x2, int x3) {\n\tvector <int> ret ;\n\tret.push_back(x0), ret.push_back(x1), ret.push_back(x2), ret.push_back(x3) ;\n\tgetmin(ret) ;\n\tsum *= mul[ret] * (Count[ret] - used[ret]) ;\n\t++ used[ret] ;\n}\n\nvoid era(int x0, int x1, int x2, int x3) {\n\tvector <int> ret ;\n\tret.push_back(x0), ret.push_back(x1), ret.push_back(x2), ret.push_back(x3) ;\n\tgetmin(ret) ;\n\t-- used[ret] ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) rep(j, 0, 3) scanf(\"%d\", &col[i][j]) ;\n\trep(i, 1, n) {\n\t\tvector <int> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\tvec[i] = ret ;\n\t\t++ Count[ret] ;\n\t\tint tot = 0 ; \n\t\tvector <int> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\n\tC[0][0] = 1 ;\n\trep(i, 1, n * 4) {\n\t\tC[i][0] = 1 ;\n\t\trep(j, 1, min(i, 6)) C[i][j] = C[i - 1][j - 1] + C[i - 1][j] ;\n\t}\n\tll ans = 0 ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\t-- Count[vec[i]], -- Count[vec[j]] ;\n//\t\tprintf(\"%d %d\\n\", i, j) ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <int> ret ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) solve(ret[turn[p][0]], ret[turn[p][1]], ret[turn[p][2]], ret[turn[p][3]]) ;\n\t\t\trep(p, 0, 3) era(ret[turn[p][0]], ret[turn[p][1]], ret[turn[p][2]], ret[turn[p][3]]) ;\n\t\t\tans += sum ;\n\t\t}\n\t\t++ Count[vec[i]], ++ Count[vec[j]] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int Maxn = 410;\n#define For( i, j, k ) for( int i = j; i <= k; ++i )\nusing std::cin;\nusing std::cout;\nstruct Node\n{\n\tint col[ 4 ];\n\tfriend bool operator < ( const Node &a, const Node &b )\n\t{\n\t\tFor( i, 0, 3 )\n\t\t\tif( a.col[ i ] != b.col[ i ] )\n\t\t\t\treturn a.col[ i ] < b.col[ i ];\n\t\treturn 0;\n }\n}elvahs[ 410 ];\nNode nxt( Node x )\n{\n\treturn ( Node ) { x.col[ 1 ], x.col[ 2 ], x.col[ 3 ], x.col[ 0 ] }; \n}\nstd::map < Node, int > mp;\ninline void insert( Node a, int x )\n{\n\tfor( int i = 0; i < 4; ++i, a = nxt( a ) )\n\t\tmp[ a ] += x;\n}\nint main( )\n{\n\tstd::ios::sync_with_stdio( false );\n\tint n;\n\tlong long ans = 0;\n\tcin >> n;\n\tFor( i, 1, n )\n\t\tcin >> elvahs[ i ].col[ 0 ] >> elvahs[ i ].col[ 1 ] >> elvahs[ i ].col[ 2 ] >> elvahs[ i ].col[ 3 ],\n\t\tinsert( elvahs[ i ], 1 );\n\tFor( i, 1, n )\n\t{\n\t\tinsert( elvahs[ i ], -1 );\n\t\tFor( j, i + 1, n )\n\t\t{\n\t\t\tinsert( elvahs[ j ], -1 );\n\t\t\tFor( t, 0, 3 )\n\t\t\t{\n\t\t\t\tNode a1 = Node{ elvahs[ j ].col[ 1 ], elvahs[ i ].col[ 0 ], elvahs[ i ].col[ 3 ], elvahs[ j ].col[ 2 ] },\n\t\t\t\ta2 = Node{ elvahs[ i ].col[ 1 ], elvahs[ j ].col[ 0 ], elvahs[ j ].col[ 3 ], elvahs[ i ].col[ 2 ] },\n\t\t\t a3 = Node{ elvahs[ j ].col[ 1 ], elvahs[ j ].col[ 0 ], elvahs[ i ].col[ 1 ], elvahs[ i ].col[ 0 ] },\n\t\t\t\ta4 = Node{ elvahs[ i ].col[ 3 ], elvahs[ i ].col[ 2 ], elvahs[ j ].col[ 3 ], elvahs[ j ].col[ 2 ] };\n\t\t\t\telvahs[ j ] = nxt( elvahs[ j ] );\n\t\t\t\tif( !mp[ a1 ] || !mp[ a2 ] || !mp[ a3 ] || !mp[ a4 ] )\n\t\t\t\t\tcontinue;\n    int res = 1;\n\t\t\t\tres *= mp[ a1 ];insert(a1,-1);\n\t\t\t\tres *= mp[ a2 ];insert(a2,-1);\n\t\t\t\tres *= mp[ a3 ];insert(a3,-1);\n\t\t\t\tres *= mp[ a4 ];\n\t\t\t\tinsert( a1, 1 ); insert( a2, 1 ); insert( a3, 1 );\n\t\t\t\tans += res;\n\t\t\t}\n\t\t\tinsert( elvahs[ j ], 1 );\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\nconst int N=450;\nVI a[N];\ntypedef long long ll;\nll ans;\nmap<VI,int>mp;\n#define nxt(x) x.push_back(x[0]),x.erase(x.begin())\nvoid add(VI x,int y){for(int i=0;i<4;++i,nxt(x))mp[x]+=y;}\nint n;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<4;++j){\n\t\t\tint x;cin>>x;\n\t\t\ta[i].push_back(x);\n\t\t}\n\t\tadd(a[i],1);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tadd(a[i],-1);\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tadd(a[j],-1);\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tVI x={a[i][3],a[j][2],a[j][1],a[i][0]},y={a[j][3],a[i][2],a[i][1],a[j][0]},\n\t\t\t\t   z={a[i][0],a[j][1],a[j][0],a[i][1]},w={a[j][2],a[i][3],a[i][2],a[j][3]};\n\t\t\t\tll res=1;nxt(a[j]);\n\t\t\t\tif(!mp.count(x)||!mp.count(y)||!mp.count(z)||!mp.count(w))continue;\n\t\t\t\tres*=mp[x];add(x,-1);\n\t\t\t\tres*=mp[y];add(y,-1);\n\t\t\t\tres*=mp[z];add(z,-1);\n\t\t\t\tres*=mp[w];add(x,1);add(y,1);add(z,1);\n\t\t\t\tans+=res;\n\t\t\t}\n\t\t\tadd(a[j],1);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconst ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n;\n  cin >> n;\n  vvi col(n, vi(7));\n  rep(i, n){\n    rep(j, 4){\n      cin >> col[i][j];\n    }\n    repr(j, 4, 7){\n      col[i][j] = col[i][j-4];\n    }\n  }\n  map<vi, vi> mp;\n  rep(i, n){\n    rep(j, 4){\n      vi tmp;\n      repr(k, j, j+4){\n        tmp.emplace_back(col[i][k]);\n      }\n      if(mp.count(tmp)){\n        mp[tmp].emplace_back(i);\n      }else{\n        mp[tmp] = vi(1, i);\n      }\n    }\n  }\n  ll ans = 0;\n  rep(x, n){\n    repr(y, x+1, n){\n      rep(rol, 4){\n        vi tmp;\n        rep(k, 4){\n          tmp.emplace_back(col[x][k]);\n        }\n        repr(k, rol, rol+4){\n          tmp.emplace_back(col[y][k]);\n        }\n        vvi rem;\n        rem.emplace_back(vi{tmp[4], tmp[7], tmp[1], tmp[0]});\n        rem.emplace_back(vi{tmp[7], tmp[6], tmp[2], tmp[1]});\n        rem.emplace_back(vi{tmp[6], tmp[5], tmp[3], tmp[2]});\n        rem.emplace_back(vi{tmp[5], tmp[4], tmp[0], tmp[3]});\n        // 包除\n        vvll cnt(4, vll(n, 0));\n        vll sum(16, 0);\n        rep(i, 4){\n          if(mp.count(rem[i])){\n            for(auto&& e: mp[rem[i]]){\n              if(e != x && e != y){\n                cnt[i][e]++;\n              }\n            }\n          }\n        }\n        repr(i, 1, 16){\n          rep(k, n){\n            ll tmp = 1;\n            rep(j, 4){\n              if((i>>j)&1){\n                tmp *= cnt[j][k];\n              }\n            }\n            sum[i] += tmp;\n          }\n        }\n        ll anst = sum[1]*sum[2]*sum[4]*sum[8];\n        rep(i, 16){\n          ll c = __builtin_popcountll(i);\n          if(c == 2){\n            ll anstt = sum[i];\n            rep(j, 4) if(!((i>>j)&1)) anstt *= sum[1<<j];\n            anst -= anstt;\n          }\n          if(c == 2 && (i & 1)){\n            anst += sum[i]*sum[i^15];\n          }\n          if(c == 3){\n            anst += sum[i]*sum[i^15]*2;\n          }\n          if(c == 4){\n            anst -= sum[i]*6;\n          }\n        }\n        ans += anst;\n      }\n    }\n  }\n  print(ans/3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long n, c[401][4], hush[401][4], mask[16], num[16], num2[16], H[4][4] = { {0,1,2,3},{1,2,3,0},{2,3,0,1},{3,0,1,2} }, po[4] = { 1,1000,1000000,1000000000 };\nlong long dp[17][16], P[16][16][5][16], Q[16][16][5];\nlong long I[16] = { 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4 };\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++)cin >> c[i][j];\n\t\tfor (int j = 0; j < 4; j++) { long long T = 0; for (int k = 0; k < 4; k++)T += c[i][H[j][k]] * po[k]; hush[i][j] = T; }\n\t}\n\tfor (int i = 0; i < 16; i++) {\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tfor (int l = 0; l < 16; l++) {\n\t\t\t\t\tif ((i&l) == l && (j&l) == 0) {\n\t\t\t\t\t\tint B = 0; for (int m = 0; m < 4; m++)B += ((l / (1 << m)) % 2);\n\t\t\t\t\t\tif (B <= k) { P[i][j][k][Q[i][j][k]] = l; Q[i][j][k]++; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int o = 0; o < 4; o++) {\n\t\t\t\tfor (int l = 0; l < 16; l++) { mask[l] = 0; num[l] = 0; num2[l] = 0; for (int m = 0; m < 17; m++)dp[m][l] = 0; }\n\t\t\t\tvector<long long>A[4] = {\n\t\t\t\t\t{ c[i][0],c[i][3],c[j][(o + 2) % 4],c[j][(o + 1) % 4] },\n\t\t\t\t\t{ c[i][3],c[i][2],c[j][(o + 3) % 4],c[j][(o + 2) % 4] },\n\t\t\t\t\t{ c[i][2],c[i][1],c[j][(o + 0) % 4],c[j][(o + 3) % 4] },\n\t\t\t\t\t{ c[i][1],c[i][0],c[j][(o + 1) % 4],c[j][(o + 0) % 4] }\n\t\t\t\t};\n\t\t\t\tlong long hush2[4] = { 0,0,0,0 };\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tfor (int l = 0; l < 4; l++)hush2[k] += A[k][l] * po[l];\n\t\t\t\t}\n\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\tif (k == j)continue;\n\t\t\t\t\tint bit = 0, K = 0;\n\t\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\t\tint J = 0;\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++) { if (hush[k][m] == hush2[l])J++; }\n\t\t\t\t\t\tif (J >= 1) { K = J; bit += (1 << l); }\n\t\t\t\t\t}\n\t\t\t\t\tmask[bit] += K; num[bit]++; num2[bit] = K;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 16; k++)num[k] = min(num[k], 4LL);\n\t\t\t\tdp[0][0] = 1;\n\t\t\t\tfor (int k = 0; k < 16; k++) {\n\t\t\t\t\tfor (int l = 0; l < 16; l++) {\n\t\t\t\t\t\tif (dp[k][l] == 0)continue;\n\t\t\t\t\t\tdp[k + 1][l] += dp[k][l];\n\t\t\t\t\t\tfor (int m = 0; m < Q[k][l][num[k]]; m++) {\n\t\t\t\t\t\t\tlong long J = mask[k]; for (int p = 1; p < I[P[k][l][num[k]][m]]; p++) { J *= (mask[k] - num2[k] * p); }\n\t\t\t\t\t\t\tdp[k + 1][l | P[k][l][num[k]][m]] += dp[k][l] * J;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret += dp[16][15];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p 761\n#define q 1000000007ll\n#define Val(x) ((((ll)x) % q + q ) % q)\n#define ll long long\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nint h[maxn],cnt[maxn];\ninline int cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tint ret = q;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tint hash = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\thash = Val(hash*p+col[(rot+i)%4]);\n\t\t\tret = min(ret,hash);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nll dp[maxn][1<<4];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tint hash = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\thash = Val(hash*p+col[i][(rot+j)%4]);\n\t\t\t\tif(hash == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tcnt[i] = max(cnt[i],tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t}\n\t\n\tdp[0][0] = 1;\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tvector<int> need(4);\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[k] = cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k]);\n\t\t\t\tint idx = 1;\n\t\t\t\tfor(int k=i+1;k<=n;k++) {\n\t\t\t\t\tif(k == j)\tcontinue;\n\t\t\t\t\tif(h[k] != need[0] && h[k] != need[1] && h[k] != need[2] && h[k] != need[3])\tcontinue;\n\t\t\t\t\tmemcpy(dp[idx],dp[idx-1],sizeof dp[idx-1]);\n\t\t\t\t\tfor(int state=0;state<16;state++) {\t\t// 2^4\n\t\t\t\t\t\tif(dp[idx-1][state]==0)\tcontinue;\n\t\t\t\t\t\tfor(int t=0;t<4;t++)\n\t\t\t\t\t\t\tif(need[t] == h[k] && (state & (1<<t)) == 0)\n\t\t\t\t\t\t\t\tdp[idx][state|(1<<t)] += cnt[k]*dp[idx-1][state];\n\t\t\t\t\t}\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t\tans += dp[idx-1][(1<<4)-1];\n\t\t\t}\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\ntypedef tuple<int,int,int,int> TP;\ntypedef vector<TP> VTP;\nconst int INF=1<<30;\nconst int SIZE=1000;\nint C[SIZE][6];\nTP CC;\nTP conv(int a,int b,int c,int d){\n\treturn min(min(TP(a,b,c,d),TP(b,c,d,a)),min(TP(c,d,a,b),TP(d,a,b,c)));\n}\nTP conv(int x){\n\treturn conv(C[x][0],C[x][1],C[x][2],C[x][3]);\n}\nLL mult(TP x){\n\tif(get<0>(x)==get<2>(x) && get<1>(x)==get<3>(x)){\n\t\tif(get<0>(x)==get<1>(x)) return 4;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\nmap<TP,LL> mtp; \nLL solve(int a,int b){\n\tLL ALLans=0;\n\tmtp[conv(a)]--;\n\tmtp[conv(b)]--;\n\tREP(k,4){\n\t\tLL ans=1;\n\t\tREP(i,4){\n\t\t\tTP next=conv(C[a][(-i+4+1)%4],C[a][(-i+4)%4],C[b][(i+k+1)%4],C[b][(i+k)%4]); \n\t\t//\tcout << C[a][(-ii+4+1)%4] <<\" \"<< C[a][(-i+4)%4]<<\" \"<<C[b][(i+k+1)%4]<<\" \"<<C[b][(i+k)%4] << endl;\n\t\t\tans*=mtp[next]*mult(next);\n\t\t\tans=max<LL>(0,ans);\n\t\t\tmtp[next]--;\n\t\t}\n\t\tREP(i,4){\n\t\t\tTP next=conv(C[a][(-i+4+1)%4],C[a][(-i+4)%4],C[b][(i+k+1)%4],C[b][(i+k)%4]); \n\t\t\tmtp[next]++;\n\t\t}\n\t\tALLans+=max<LL>(0,ans);\n\t}\n\tmtp[conv(a)]++;\n\tmtp[conv(b)]++;\n\treturn ALLans;\n}\nint main(){\n\tLL N;\n\tcin.tie(0);\n\tcin >> N;\n\tREP(i,N){\n\t\tREP(j,4){\n\t\t\tcin >> C[i][j];\t\t\n\t\t}\n\t\tmtp[conv(i)]=mtp[conv(i)]+1;\n\t}\n\tLL ans=0;\n\tREP(i,N)\n\t\tREP(j,i)\n\t\t\tans += solve(i,j);\n\tcout << ans/3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (short i = a; i <= b; ++ i) \nconst short N = 1005 ; \n\nconst short turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <short>, short> Count ;\nshort col[N][5], n ;\n\ninline void getmin(vector <short> &p) {\n\tvector <short> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nmap <vector <short>, short>  mul ;\n\nint main() {\n\tcin >> n ;\n\trep(i, 1, n) rep(j, 0, 3) cin >> col[i][j] ;\n\trep(i, 1, n) {\n\t\tvector <short> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\t++ Count[ret] ;\n\t\tshort tot = 0 ; \n\t\tvector <short> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0, sum ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\tvector <short> ret ;\n\t\trep(k, 0, 3) ret.push_back(col[i][k]) ; getmin(ret) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ; getmin(ret) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <short> ret ;\n\t\t\tmap <vector <short>, short> used ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\tvector <short> U ;\n\t\t\t\trep(q, 0, 3) U.push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(U) ;\n\t\t\t\tsum *= (ll) mul[U] * (Count[U] - used[U]) ;\n\t\t\t\t++ used[U] ;\n\t\t\t}\n\t\t\tans += sum ;\n\t\t}\n\t\trep(k, 0, 3) ret[k] = col[i][k] ; getmin(ret) ;\n\t\t++ Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ; getmin(ret) ;\n\t\t++ Count[ret] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 500\n#define int long long\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint c[N][4],n,C[N][6],fac[5];\nll A[N],Ans;\nmap <ll,int> M;\ninline int fnd(long long y)\n{\n\tint x[4]; \n\tfor(int i=0;i<4;i++) x[i]=y&((1<<10)-1),y>>=10;\n\tif(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3]) return 4;\n\tif(x[0]==x[2]&&x[1]==x[3]) return 2;\n\treturn 1;\n}\ninline ll hash(int x,int y,int z,int s)\n{\n\tll xs=(1ll*x<<30)+(1ll*y<<20)+(1ll*z<<10)+s;\n\treturn xs;\n}\ninline ll trans(int x,int y,int z,int s)\n{\n\treturn min(min(hash(x,y,z,s),hash(y,z,s,x)),min(hash(z,s,x,y),hash(s,x,y,z)));\n}\nsigned main()\n{\n\tn=read(); for(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++) c[i][j]=read();\n\t\tA[i]=trans(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t}\n\tfac[0]=1; fac[1]=1; fac[2]=2; fac[3]=6; fac[4]=24;\n\tC[0][0]=1; for(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;for(int j=1;j<=4;j++)\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t} \n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint y[4];\n\t\t\t\ty[0]=trans(c[i][(k+1)%4],c[i][(k+0)%4],c[j][1],c[j][0]);\n\t\t\t\ty[1]=trans(c[i][(k+0)%4],c[i][(k+3)%4],c[j][2],c[j][1]);\n\t\t\t\ty[2]=trans(c[i][(k+3)%4],c[i][(k+2)%4],c[j][3],c[j][2]);\n\t\t\t\ty[3]=trans(c[i][(k+2)%4],c[i][(k+1)%4],c[j][0],c[j][3]);\n\t\t\t\tsort(y,y+4); ll ret=1;\n\t\t\t\tfor(int p=0;p<4;p++)\n\t\t\t\t{\n\t\t\t\t\tint s=p; while(y[s]==y[p]) s++;\n\t\t\t\t\tint tot=M[y[p]];\n\t\t\t\t\tif(A[j]==y[p]) tot--;\n\t\t\t\t\tif(s-p>tot) ret=0;\n\t\t\t\t\tfor(int t=1;t<=s-p;t++) ret*=fnd(y[p]); \n\t\t\t\t\tret*=C[tot][s-p]*fac[s-p];\n\t\t\t\t\tp=s-1;\n\t\t\t\t}\n\t\t\t\tAns+=ret;\n\t\t\t}\n\t\t}\n\t\tM[A[i]]++;\n\t\t//cout << A[i] << \" \" << M[A[i]] << endl;\n\t}\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N,C[404][4];\nlong long ans = 0;\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) for (int j=0;j<4;j++) scanf (\"%d\",&C[i][j]);\n\n\tfor (int f=0;f<N;f++) for (int e=f+1;e<N;e++) for (int t=0;t<4;t++){\n\t\tint *o = C[f];\n\t\tint c[4] = {C[e][t],C[e][(t+1)%4],C[e][(t+2)%4],C[e][(t+3)%4]};\n\n\t\tlong long prv[16] = {1,}, nxt[16];\n\t\tfor (int k=f+1;k<N;k++) if (k != e){\n\t\t\tint cnt[4] = {0,};\n\t\t\tfor (int tt=0;tt<4;tt++){\n\t\t\t\tint cc[4] = {C[k][tt],C[k][(tt+1)%4],C[k][(tt+2)%4],C[k][(tt+3)%4]};\n\n\t\t\t\tif (o[0] == cc[3] && o[1] == cc[2] && c[0] == cc[1] && c[1] == cc[0]) cnt[0]++;\n\t\t\t\tif (o[1] == cc[0] && o[2] == cc[3] && c[0] == cc[1] && c[3] == cc[2]) cnt[1]++;\n\t\t\t\tif (o[3] == cc[0] && o[2] == cc[1] && c[3] == cc[2] && c[2] == cc[3]) cnt[2]++;\n\t\t\t\tif (c[1] == cc[0] && o[0] == cc[1] && o[3] == cc[2] && c[2] == cc[3]) cnt[3]++;\n\t\t\t}\n\n\t\t\tfor (int b=0;b<16;b++) nxt[b] = prv[b];\n\t\t\tfor (int b=0;b<16;b++) for (int j=0;j<4;j++) if (~b & (1 << j)){\n\t\t\t\tnxt[b|(1<<j)] += cnt[j]* prv[b];\n\t\t\t}\n\t\t\tfor (int b=0;b<16;b++) prv[b] = nxt[b];\n\t\t}\n\n\t\tans += prv[15];\n\t}\n\tprintf (\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    using Tile = array<int, 4>;\n    auto normalize = [&](Tile &a) {\n        Tile b = a;\n        for (int i = 1; i < 4; i++) {\n            Tile c;\n            for (int j = 0; j < 4; j++) c[j] = b[(i+j)%4];\n            if (c < a) a = c;\n        }\n    };\n    auto type = [&](Tile &a) {\n        if (a[0] == a[2] && a[1] == a[3]) {\n            if (a[0] == a[1]) return 4;\n            else return 2;\n        }\n        return 1;\n    };\n    vector<Tile> v(n);\n    map<Tile, long long> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) cin >> v[i][j];\n        normalize(v[i]); m[v[i]]++;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        m[v[i]]--;\n        for (int j = i+1; j < n; j++) {\n            m[v[j]]--;\n            for (int r = 0; r < 4; r++) {\n                vector<Tile> w;\n                long long curr = 1;\n                for (int c = 0; c < 4; c++) {\n                    Tile a = {v[i][(c+1)%4], v[i][c], v[j][(r-c+5)%4], v[j][(r-c+4)%4]};\n                    normalize(a); w.emplace_back(a);\n                    curr *= m[a] * type(a);\n                    m[a]--;\n                }\n                for (auto &x: w) m[x]++;\n                ans += curr;\n            }\n            m[v[j]]++;\n        }\n        m[v[i]]++;\n    }\n    cout << ans / 3 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {}, e[16][4] = {};\n  \tfor (int i = 0; i < 16; i++) for (int j = 0; j < 4; j++) if (i & (1 << j)) e[i][j] = 1;\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                int c[4] = {}, b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}};\n              \tll d[16] = {1};\n                for (int l = i + 1; l <= n; l++) {\n                  \tfor (int m = 0; m < 4; m++) {\n                      \tc[m] = 0;\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[m]++;\n                    }\n                    d[15] += c[0] * d[14];\n                    d[15] += c[1] * d[13];\n                    d[15] += c[2] * d[11];\n                    d[15] += c[3] * d[7];\n                    d[14] += c[1] * d[12];\n                    d[14] += c[2] * d[10];\n                    d[14] += c[3] * d[6];\n                    d[13] += c[0] * d[12];\n                    d[13] += c[2] * d[9];\n                    d[13] += c[3] * d[5];\n                    d[12] += c[2] * d[8];\n                    d[12] += c[3] * d[4];\n                    d[11] += c[0] * d[10];\n                    d[11] += c[1] * d[9];\n                    d[11] += c[3] * d[3];\n                    d[10] += c[1] * d[8];\n                    d[10] += c[3] * d[2];\n                    d[9] += c[0] * d[8];\n                    d[9] += c[3] * d[1];\n                    d[8] += c[3] * d[0];\n                    d[7] += c[0] * d[6];\n                    d[7] += c[1] * d[5];\n                    d[7] += c[2] * d[3];\n                    d[6] += c[1] * d[4];\n                    d[6] += c[2] * d[2];\n                    d[5] += c[0] * d[4];\n                    d[5] += c[2] * d[1];\n                    d[4] += c[2] * d[0];\n                    d[3] += c[0] * d[2];\n                    d[3] += c[1] * d[1];\n                    d[2] += c[1] * d[0];\n                    d[1] += c[0] * d[0];\n                }\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define INF (numeric_limits<int>::max()/2-1)\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T> constexpr bool chmin(T& x, T const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T> constexpr bool chmax(T& x, T const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n    auto c = make_v<int,2>(n,4); cin >> c;\n\n    auto rot = [&](vector<int> &cc) {\n        rotate(cc.begin(), cc.begin()+1, cc.end());\n    };\n    auto id = [](vector<int> const& cc) {\n        assert(sz(cc) == 4);\n        int sum = 0, p = 1;\n        rep (i,4) sum += p*cc[i], p *= 1000;\n        return sum;\n    };\n    auto num = [&](vector<int> const& cc) {\n        auto dd = cc;\n        rot(dd);\n        if (cc == dd) return 4;\n        rot(dd);\n        if (cc == dd) return 2;\n        return 1;\n    };\n    unordered_map<int,int> cnt1,cnt2,cnt4;\n    rep (i,n) rep (k,4) {\n        int x = num(c[i]);\n        if (x == 1) cnt1[id(c[i])]++;\n        if (x == 2) cnt2[id(c[i])]++;\n        if (x == 4) cnt4[id(c[i])]++;\n        rot(c[i]);\n    }\n\n    auto equiv = [&](vector<int> &c1, vector<int> &c2) -> bool {\n        rep (k,4) {\n            if (c1 == c2) return true;\n            rot(c2);\n        }\n        return false;\n    };\n\n    int ans = 0;\n    rep (i,n) rep (j,n) if (i < j) {\n        rep (k,4) {\n            vector<vector<int>> a(4);\n            rep (x,4) {\n                a[x] = {c[i][(x+1)%4],c[i][x],\n                        c[j][(k-x+4)%4],c[j][(k-x-1+4)%4]};\n            }\n            vector<int> m0(4),m1(4);\n            rep (x,4) {\n                rep (k,4) {\n                    if (a[x] == c[i]) m0[x]++;\n                    rot(c[i]);\n                }\n                rep (k,4) {\n                    if (a[x] == c[j]) m1[x]++;\n                    rot(c[j]);\n                }\n            }\n\n            vector<int> cc1(4),cc2(4),cc4(4);\n            rep (x,4) cc1[x] = cnt1[id(a[x])];\n            rep (x,4) cc2[x] = cnt2[id(a[x])];\n            rep (x,4) cc4[x] = cnt4[id(a[x])];\n\n            auto f = [&](vector<int> const& v) -> int {\n                int c1 = cc1[v[0]], c2 = cc2[v[0]], c4 = cc4[v[0]];\n                if (sz(v) == 1) {\n                    int ret = 0;\n                    ret += c1 + c2 + c4;\n                    ret -= m0[v[0]];\n                    ret -= m1[v[0]];\n                    return ret;\n                }\n                if (sz(v) == 2) {\n                    int ret = 0;\n                    if (equiv(a[v[0]], a[v[1]])) {\n                        ret += c1 + c2*2 + c4*4;\n                    }\n                    ret -= m0[v[0]]*m0[v[1]];\n                    ret -= m1[v[0]]*m1[v[1]];\n                    return ret;\n                }\n                if (sz(v) == 3) {\n                    int ret = 0;\n                    if (equiv(a[v[0]], a[v[1]]) &&\n                        equiv(a[v[0]], a[v[2]])) {\n                        ret += c1 + c2*2*2 + c4*4*4;\n                    }\n                    ret -= m0[v[0]]*m0[v[1]]*m0[v[2]];\n                    ret -= m1[v[0]]*m1[v[1]]*m1[v[2]];\n                    return ret;\n                }\n                if (sz(v) == 4) {\n                    int ret = 0;\n                    if (equiv(a[v[0]], a[v[1]]) &&\n                        equiv(a[v[0]], a[v[2]]) &&\n                        equiv(a[v[0]], a[v[3]])) {\n                        ret += c1 + c2*2*2*2 + c4*4*4*4;\n                    }\n                    ret -= m0[v[0]]*m0[v[1]]*m0[v[2]]*m0[v[3]];\n                    ret -= m1[v[0]]*m1[v[1]]*m1[v[2]]*m1[v[3]];\n                    return ret;\n                }\n                return -1;\n            };\n            int c0 = f({0}), c1 = f({1}), c2 = f({2}), c3 = f({3});\n            int c01 = f({0,1}), c02 = f({0,2}), c03 = f({0,3}),\n                c12 = f({1,2}), c13 = f({1,3}), c23 = f({2,3});\n            int c012 = f({0,1,2}), c013 = f({0,1,3}), c023 = f({0,2,3}),\n                c123 = f({1,2,3});\n            int c0123 = f({0,1,2,3});\n\n            int tmp = 0;\n            tmp += c0 * c1 * c2 * c3;\n            tmp += -1 * ( c01*c2*c3 + c02*c1*c3 + c03*c1*c2\n                         + c12*c0*c3 + c13*c0*c2 + c23*c0*c1 );\n            tmp += +2 * ( c012*c3 + c013*c2 + c023*c1 + c123*c0 )\n                + ( c01*c23 + c02*c13 + c03*c12 );\n            tmp += -6 * ( c0123 );\n\n            ans += tmp;\n        }\n    }\n    dump(ans);\n    assert(ans % 3 == 0);\n    cout << ans/3 << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nmap<piipii, int> dp;\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[p]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[p]--;\n        p = rotate(p);\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p1 = c[i];\n            for(int k=0;k<4;k++){\n                del(p1);\n                piipii p2 = c[j];\n                for(int l=0;l<4;l++){\n                    del(p2);\n\n                    ll res = 1;\n                    piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                    piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                    piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                    piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                    if(dp.find(tmp1) != dp.end()){\n                        res *= dp[tmp1];\n                        del(tmp1);\n                    }\n                    else res = 0;\n                    if(dp.find(tmp2) != dp.end()){\n                        res *= dp[tmp2];\n                        del(tmp2);\n                    }\n                    else res = 0;\n                    if(dp.find(tmp3) != dp.end()){\n                        res *= dp[tmp3];\n                        del(tmp3);\n                    }\n                    else res = 0;\n                    if(dp.find(tmp4) != dp.end()){\n                        res *= dp[tmp4];\n                        del(tmp4);\n                    }\n                    else res = 0;\n\n                    ans += res;\n\n                    if(dp.find(tmp1) != dp.end()){\n                        add(tmp1);\n                    }\n                    if(dp.find(tmp2) != dp.end()){\n                        add(tmp2);\n                    }\n                    if(dp.find(tmp3) != dp.end()){\n                        add(tmp3);\n                    }\n                    if(dp.find(tmp4) != dp.end()){\n                        add(tmp4);\n                    }\n                    \n                    add(p2);\n                    p2 = rotate(p2);\n                }\n\n                add(p1);\n                p1 = rotate(p1);\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i)%4];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)%4] < colors[(j+k)%4]) return true;\n            if (colors[(i+k)%4] > colors[(j+k)%4]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors a, Colors b, Colors brot) {\n\n    vector<Colors> dst = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    vector<int> sz(4, 1);\n    FORN(i, 4) {\n        if (i >= dst.size()) break;\n        RFOR(j, i + 1, (int)dst.size()) {\n            if (dst[i] == dst[j]) {\n                sz[i] += sz[j];\n                sz.erase(sz.begin() + j);\n                dst.erase(dst.begin() + j);\n            }\n        }\n    }\n    assert(dst.size() == sz.size());\n    LL ans = 1;\n    FORN(i, (int)dst.size()) {\n        LL ccnt = colcnt[dst[i]];\n        int cnt = sz[i];\n        int ml = dst[i].mult();\n        EVARS(i, ccnt, cnt, ans, ml);\n        assert(cnt > 0);\n        if (cnt == 1) {\n            ans *= 1ll * ccnt * ml;\n        }\n        else if (cnt == 2) {\n            ans *= 1ll * ccnt * (ccnt - 1) * ml * ml;\n        }\n        else if (cnt == 3) {\n            ans *= 1ll * ccnt * (ccnt - 1) * (ccnt - 2) * ml * ml * ml;\n        }\n        else if (cnt == 4) {\n            ans *= 1ll * ccnt * (ccnt - 1) * (ccnt - 2) * (ccnt - 3) * ml * ml * ml * ml;\n        }\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    FOREACH(pb, colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL cccnt = pb.second;\n        colcnt[b]--;\n        FORN(rot, 4) {\n            EVARS(b.colors[0], b.colors[1], b.colors[2], b.colors[3], cccnt);\n            LL curans = countfit(a, b, brot);\n            ans += cccnt * 1ll * curans;\n            brot.rotate_left(1);\n            EVARS(curans, ans);;\n        }\n        colcnt[b]++;\n    }\n    EPR(\"ans smallest %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        EPR(\"tile %d\\n\", i);\n        Colors a = tiles[i];\n        EVARS(a.colors[0], a.colors[1], a.colors[2], a.colors[3]);\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nmap<array<int, 4>, int> mp;\n\nint same(array<int, 4> a, array<int, 4> b) {\n  int res = 0;\n  if (a == array<int, 4>{b[0], b[1], b[2], b[3]}) res++;\n  if (a == array<int, 4>{b[1], b[2], b[3], b[0]}) res++;\n  if (a == array<int, 4>{b[2], b[3], b[0], b[1]}) res++;\n  if (a == array<int, 4>{b[3], b[0], b[1], b[2]}) res++;\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n\n  cin >> n;\n  vector<array<int, 4>> up;\n  long long ans = 0;\n\n  for (int i = 0; i < n; i++) {\n    array<int, 4> c;\n    for (int j = 0; j < 4; j++) {\n      cin >> c[j];\n    }\n\n    for (auto &d : up) {\n      array<int, 4> w = {d[0], d[3], c[0], c[3]};\n      array<int, 4> x = {d[3], d[2], c[1], c[0]};\n      array<int, 4> y = {d[2], d[1], c[2], c[1]};\n      array<int, 4> z = {d[1], d[0], c[3], c[2]};\n\n      long long cur = 1;\n      cur *= 1ll * mp[w] - same(d, w);\n      cur *= 1ll * mp[x] - same(w, x) - same(d, x);\n      cur *= 1ll * mp[y] - same(w, y) - same(x, y) - same(d, y);\n      cur *= 1ll * mp[z] - same(w, z) - same(x, z) - same(y, z) - same(d, z);\n      ans += cur;\n    }\n\n    up.push_back({c[0], c[1], c[2], c[3]}); mp[up.back()]++;\n    up.push_back({c[1], c[2], c[3], c[0]}); mp[up.back()]++;\n    up.push_back({c[2], c[3], c[0], c[1]}); mp[up.back()]++;\n    up.push_back({c[3], c[0], c[1], c[2]}); mp[up.back()]++;\n  }\n\n  cout << ans << \"\\n\";\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n明知这是一场意外，你要不要来\n明知这是一场重伤害，你会不会来\n当疯狂慢慢从爱情离开，还有什么你值得感慨\n如果风景早已都不存在，我想我谁都不爱\n——薛之谦《意外》\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n// #define MPS\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 405;\n\nmap<ll,int> Cnt;\nint n;\nVI C[maxn];\nll Ans;\n\nll f(int a,int b,int c,int d) // hash function\n{\n\treturn (((a*1000ll + b)*1000) + c)*1000 + d;\n}\nVI fmr(VI A) // find the minimal representation for a squre\n{\n\tVI ret = A;\n\tfo(d,1,3)\n\t{\n\t\tfo(i,0,3) \n\t\t\tif(ret[i] < A[(i+d)%4]) break;\n\t\t\telse if(ret[i] > A[(i+d)%4]) \n\t\t\t{\n\t\t\t\tfo(j,0,3) ret[j] = A[(j+d)%4];\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"arc062e.in\",\"r\",stdin);\n\t\tfp(\"arc062e.out\",\"w\",stdout);\n\t#endif\n\tVI tmp;\n\tsf(\"%d\",&n);\n\tfo(i,1,n) \n\t{\n\t\tfo(j,0,3) {int x; sf(\"%d\",&x); C[i].pb(x);}\n\t\ttmp = fmr(C[i]);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tfo(i,1,n)\n\t{\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\tfo(j,i+1,n)\n\t\t{\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\t\tfo(d1,0,3)\n\t\t\t{\n\t\t\t\tVI tmp;\n\t\t\t\tvector<ll> cube;\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[i][(4-d1)%4]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[j][2]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[j][0]); tmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[i][(4-d1)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[j][0]); tmp.pb(C[j][3]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][3]); tmp.pb(C[j][2]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\tsort(cube.begin(),cube.end());\n\t\t\t\tint s = 1; ll cur = 1;\n\t\t\t\tfor(int i = 1; i <= 4; ++ i)\n\t\t\t\t\tif(i != 4 && cube[i] == cube[i-1]) {++ s; continue;}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!Cnt.count(cube[i-1])) {cur = 0; break;} \n\t\t\t\t\t\tint num = Cnt[cube[i-1]]; //we are calculating A(num, s) = num! / (num-s)!\n\t\t\t\t\t\tfo(i,num-s+1,num) cur *= i;\n\t\t\t\t\t\tint bonus = 1, a, b, c, d;\n\t\t\t\t\t\tll x = cube[i-1];\n\t\t\t\t\t\ta = x/1000000000; x -= a*1000000000ll;\n\t\t\t\t\t\tb = x/1000000; x -= b*1000000ll;\n\t\t\t\t\t\tc = x/1000; x -= c*1000ll;\n\t\t\t\t\t\td = x;\n\t\t\t\t\t\tassert(f(a,b,c,d) == cube[i-1]);\n\t\t\t\t\t\tif(a == d && b == a && c == b && d == c) ++ bonus;\n\t\t\t\t\t\tif(a == c && b == d && c == a && d == b) ++ bonus;\n\t\t\t\t\t\tif(a == b && b == c && c == a && d == d) ++ bonus;\n\t\t\t\t\t\tfo(i,1,s) cur *= bonus;\n\t\t\t\t\t\ts = 1;\n\t\t\t\t\t}\n\t\t\t\tAns += cur;\n\t\t\t}\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t\t}\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tpf(\"%lld\\n\",Ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n\n  set<P> used;\n  map<sq, Int> dp;\n  auto dup=[&](const sq &a)->Int{\n    if(dp.count(a)) return dp[a];\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\t//used.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return dp[a]=res;\n  };\n  \n  auto norm=[&](const sq &a)->sq{\n    sq b(8);\n    map<Int, Int> m;\n    Int sz=0;\n    for(Int i=0;i<8;i++){\n      if(!m.count(a[i])) m[a[i]]=sz++;\n      b[i]=m[a[i]];\n    }\n    return b;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      //if(used.count(conv(norm(a)))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(norm(a));\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\nconst int HMOD = 1e6 + 3;\n\nLL gen_ha(int ori[])\n{\n\tLL ret = 0;\n\trep(i, 4) ret = ret * 1000 + ori[i];\n\treturn ret;\n}\n\nLL min_rep(int ori[], int& cnt)\n{\n\tLL ret = INF;\n\trep(i, 4) {\n\t\tret = min(ret, gen_ha(ori));\n\t\trotate(ori, ori + 1, ori + 4);\n\t}\n\tcnt = 0;\n\trep(i, 4) {\n\t\tif(gen_ha(ori) == ret) cnt ++;\n\t\trotate(ori, ori + 1, ori + 4);\n\t}\n\treturn ret;\n}\n\nint n, c[405][4];\nLL ha[405];\nint hcnt[405];\nvector<LL> hv[1000005];\n\nLL tha[4];\nint thcnt[405];\nint tmp[4];\nint fa[4], cnt[4];\nLL solve(int id0, int id1)\n{\n\trep(i, 4) {\n\t\ttmp[0] = c[id0][i];\n\t\ttmp[1] = c[id0][i + 1 & 3];\n\t\ttmp[2] = c[id1][i + 1 & 3];\n\t\ttmp[3] = c[id1][i];\n\t\ttha[i] = min_rep(tmp, thcnt[i]);\n\t}\n\t\n\trep(i, 4) fa[i] = i;\n\trep(i, 4) rep(j, i)\n\tif(tha[i] == tha[j]) {\n\t\tfa[i] = j;\n\t\tbreak;\n\t}\n\trep(i, 4) cnt[i] = 0;\n\trep(i, 4) cnt[fa[i]] ++;\n\t\n\tLL ans = 1;\n\trep(i, 4) {\n\t\tint tot = 0;\n\t\tvector<LL>& cur = hv[tha[i] % HMOD];\n\t\trep(j, cur.size()) if(cur[j] == tha[i]) tot ++;\n\t\tif(ha[id1] == tha[i]) tot --;\n\t\trep(j, cnt[i]) ans *= tot - j;\n\t\trep(j, cnt[i]) ans *= thcnt[i];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 4) scanf(\"%d\", &c[i][j]);\n\t\tha[i] = min_rep(c[i], hcnt[i]);\n\t}\n\tLL ans = 0;\n\trep(i, n) {\n\t\trep(j, i) {\n\t\t\treverse(c[i], c[i] + 4);\n\t\t\trep(k, 4) {\n\t\t\t\tans += solve(i, j);\n\t\t\t\trotate(c[j], c[j] + 1, c[j] + 4);\n\t\t\t}\n\t\t\treverse(c[i], c[i] + 4);\n\t\t}\n\t\thv[ha[i] % HMOD].push_back(ha[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 062\n// E - AtCoDeerくんと立方体づくり / Building Cubes with AtCoDeer\n\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define MAX_N 400\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> Tile;\n\n\nint N;\nvector<Tile> tiles;\nmultiset<Tile> used;\nll ans;\n\nTile rotate(Tile t) {\n  return { t[1], t[2], t[3], t[0] };\n}\n\nint main() {\n\n  Tile t1, t2;\n  int c;\n  ll cnt, tmp;\n  vector<Tile>::iterator itr1, itr2;\n\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    Tile t;\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", &c);\n      t.push_back(c);\n    }\n    tiles.push_back(t);\n  }\n\n  sort(tiles.begin(), tiles.end());\n\n  ans = 0;\n  for (itr1 = tiles.begin(); itr1 != tiles.end(); itr1++) {\n    for (itr2 = itr1, itr2++; itr2 != tiles.end(); itr2++) {\n      t1 = *itr1; t2 = *itr2;\n      for (int d = 0; d < 4; d++, t2 = rotate(t2)) {\n        used.clear();\n        used.insert(t1);\n        used.insert(t2);\n        cnt = 1;\n        for (int i = 0; i < 4; i++) {\n          tmp = 0;\n          Tile t = { t1[(1 + i) % 4], t1[(0 + i) % 4], t2[(4 - i) % 4], t2[(7 - i) % 4] };\n          for (int j = 0; j < 4; j++, t = rotate(t)) {\n            tmp += upper_bound(tiles.begin(), tiles.end(), t) - lower_bound(tiles.begin(), tiles.end(), t);\n            tmp -= used.count(t);\n          }\n          tmp = max(tmp, 0LL);\n          cnt *= tmp;\n          used.insert(t);\n        }\n        ans += cnt;\n      }\n    }\n  }\n\n  ans /= 3;\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=400+10;\n\nint n,c[N][4]; ll h[N],v[4];\nmap<ll,int> M;\n\nvoid add(ll s,int w) {\n\tfor (int i=0;i<4;++i)\n\t\tM[s]+=w,s=(s>>10ll)|((s&1023ll)<<30ll);\n}\n\nll Ui(int* a) {\n\tll res=0;\n\tfor (int i=0;i<4;++i) res|=1ll*a[i]<<(i*10ll);\n\treturn res;\n}\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=0;j<4;++j) c[i][j]=read();\n\tfor (int i=1;i<=n;++i) h[i]=Ui(c[i]),add(h[i],1);\n\tll ans=0;\n\tfor (int i=1;i<=n-5;++i) {\n\t\tadd(h[i],-1);\n\t\tfor (int j=i+1;j<=n;++j) {\n\t\t\tadd(h[j],-1);\n\t\t\tfor (int p=0;p<4;++p) {\n\t\t\t\tint flag=1;\n\t\t\t\tfor (int q=0;q<4;++q) {\n\t\t\t\t\tint tmp[]={c[i][q],c[j][(7+p-q)%4],c[j][(6+p-q)%4],c[i][(q+1)%4]};\n\t\t\t\t\tv[q]=Ui(tmp);\n\t\t\t\t\tif (!M.count(v[q])) { flag=0; break; }\n\t\t\t\t}\n\t\t\t\tif (!flag) continue;\n\t\t\t\tll now=1; \n\t\t\t\tfor (int q=0;q<4;++q) now*=M[v[q]],add(v[q],-1);\n\t\t\t\tans+=now;\n\t\t\t\tfor (int q=0;q<4;++q) add(v[q],1);\n\t\t\t}\n\t\t\tadd(h[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define LL long long\nusing namespace std;\nconst int N = 2000;\nint n;\nmap <vector <int>, int> res;\nint C[N][5], S[N];\nLL ans, cnt;\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        for (int j = 0; j < 4; ++ j)\n            cin >> C[i][j];\n    // for (int i = 1; i <= n; ++ i) C[i][1] = C[i][3] = 1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        S[i] = 1;\n        for (int j = 1; j < 4; ++ j) if (C[i][0] != C[i][j]) S[i] = 0;\n    }\n    for (int i = 3; i <= n; ++ i)\n    {\n        for (int j = i + 1; j <= n; ++ j)\n            for (int k = i + 1; k <= n; ++ k) if (j != k)\n            {\n                for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                    for (int dj = 0; dj < (S[j]? 1: 4); ++ dj)\n                        for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                        {\n                            cnt ++;\n                            if (C[i][(di + 2) & 3] != C[j][(dj + 3) & 3]) continue;\n                            if (C[i][(di + 1) & 3] != C[j][(dj + 0) & 3]) continue;\n                            if (C[i][(di + 2) & 3] != C[k][(dk + 1) & 3]) continue;\n                            if (C[i][(di + 3) & 3] != C[k][(dk + 0) & 3]) continue;\n                            if (C[j][(dj + 2) & 3] != C[k][(dk + 2) & 3]) continue;\n\n                            vector <int> tmp;\n                            tmp = {C[k][(dk + 0) & 3], C[k][(dk + 3) & 3], C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3]};\n                            ans += res[tmp] << (2 * (S[i] + S[j] + S[k]));\n\n                            tmp.clear();\n                            tmp = {C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3], C[k][(dk + 0) & 3], C[k][(dk + 3) & 3]};\n                            ans += res[tmp] << (2 * (S[i] + S[j] + S[k]));\n\n                            tmp.clear();\n                            tmp = {C[i][(di + 1) & 3], C[i][(di + 0) & 3], C[k][(dk + 0) & 3], C[k][(dk + 3) & 3], C[j][(dj + 2) & 3], C[j][(dj + 1) & 3]};\n                            ans += res[tmp] << (2 * (S[i] + S[j] + S[k]));\n                        }\n            }\n\n        for (int j = 1; j < i; ++ j)\n            for (int k = 1; k < i; ++ k) if (j != k)\n            {\n                for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                    for (int dj = 0; dj < (S[j]? 1: 4); ++ dj)\n                        for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                        {\n                            if (C[i][(di + 2) & 3] != C[j][(dj + 3) & 3]) continue;\n                            if (C[i][(di + 1) & 3] != C[j][(dj + 0) & 3]) continue;\n                            if (C[i][(di + 2) & 3] != C[k][(dk + 1) & 3]) continue;\n                            if (C[i][(di + 3) & 3] != C[k][(dk + 0) & 3]) continue;\n                            if (C[j][(dj + 2) & 3] != C[k][(dk + 2) & 3]) continue;\n\n                            vector <int> tmp;\n                            tmp = {C[i][(di + 0) & 3], C[i][(di + 1) & 3], C[j][(dj + 1) & 3], C[j][(dj + 2) & 3], C[k][(dk + 3) & 3], C[k][(dk + 0) & 3]};\n                            res[tmp] += 1 << (2 * (S[i] + S[j] + S[k]));\n                        }\n            }\n    }\n    // cerr << ans << endl;\n    // res.clear();\n\n    for (int ii = 3; ii <= n; ++ ii)\n    {\n        for (int jj = ii + 1; jj <= n; ++ jj)\n            for (int kk = jj + 1; kk <= n; ++ kk)\n            {\n                for (int d = 0; d < 6; ++ d)\n                {\n                    int i, j, k;\n                    if (d == 0) i = ii, j = jj, k = kk;\n                    if (d == 1) i = ii, j = kk, k = jj;\n                    if (d == 2) i = jj, j = ii, k = kk;\n                    if (d == 3) i = jj, j = kk, k = ii;\n                    if (d == 4) i = kk, j = ii, k = jj;\n                    if (d == 5) i = kk, j = jj, k = ii;\n                    for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                        for (int dj = 0; dj < 2; ++ dj)\n                            for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                            {\n                                cnt ++;\n                                if (C[j][(dj + 0) & 3] != C[i][(di + 3) & 3]) continue;\n                                if (C[j][(dj + 1) & 3] != C[i][(di + 2) & 3]) continue;\n                                if (C[k][(dk + 0) & 3] != C[j][(dj + 3) & 3]) continue;\n                                if (C[k][(dk + 1) & 3] != C[j][(dj + 2) & 3]) continue;\n\n                                vector <int> tmp;\n                                tmp = {C[j][(dj + 0) & 3], C[j][(dj + 3) & 3], C[k][(dk + 3) & 3], C[k][(dk + 2) & 3],\n                                    C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3]};\n                                ans += res[tmp] << (2 * (S[i] + S[k]));\n\n                                tmp.clear();\n                                tmp = {C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3],\n                                    C[j][(dj + 0) & 3], C[j][(dj + 3) & 3], C[k][(dk + 3) & 3], C[k][(dk + 2) & 3]};\n                                ans += res[tmp] << (2 * (S[i] + S[k]));\n                            }\n                }\n            }\n        for (int jj = 2; jj < ii; ++ jj)\n            for (int kk = 1; kk < jj; ++ kk)\n            {\n                for (int d = 0; d < 6; ++ d)\n                {\n                    int i, j, k;\n                    if (d == 0) i = ii, j = jj, k = kk;\n                    if (d == 1) i = ii, j = kk, k = jj;\n                    if (d == 2) i = jj, j = ii, k = kk;\n                    if (d == 3) i = jj, j = kk, k = ii;\n                    if (d == 4) i = kk, j = ii, k = jj;\n                    if (d == 5) i = kk, j = jj, k = ii;\n                    for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                        for (int dj = 0; dj < 2; ++ dj)\n                            for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                            {\n                                if (C[j][(dj + 0) & 3] != C[i][(di + 3) & 3]) continue;\n                                if (C[j][(dj + 1) & 3] != C[i][(di + 2) & 3]) continue;\n                                if (C[k][(dk + 0) & 3] != C[j][(dj + 3) & 3]) continue;\n                                if (C[k][(dk + 1) & 3] != C[j][(dj + 2) & 3]) continue;\n\n                                vector <int> tmp;\n                                tmp = {C[j][(dj + 0) & 3], C[j][(dj + 3) & 3], C[k][(dk + 3) & 3], C[k][(dk + 2) & 3],\n                                    C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3]};\n                                res[tmp] += 1 << (2 * (S[i] + S[k]));\n                            }\n                }\n            }\n    }\n    cout << ans << endl;\n    // cerr << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(k!=i and k!=j){\n                    rep(i_,0,4){\n                        if(b&(1<<i_)) continue;\n                        rep(j_,0,4){\n                            if(match(C[k],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                            rotate(C[k].begin(),C[k].begin()+1,C[k].end());\n                        }\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                rep(i_,0,N+1) fill(memo[i_].begin(),memo[i_].end(),-1);\n                ans+=rec(i+1,0);\n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\ntypedef tuple<int, int, int, int> P;\n\nP rot(P p) {\n\tint a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn make_tuple(b, c, d, a);\n}\n\nlong long modpow(long long a, long long b, long long mod) {\n\tif (b == 0) return 1;\n\treturn modpow(a * a % mod, b / 2, mod) * (b & 1 ? a : 1) % mod;\n}\n\nlong long modinv(long long a, long long mod) {\n\treturn modpow(a, mod - 2, mod);\n}\n\nint mul(int x, int y) {\n\treturn int64_t(x) * y % mod;\n}\n\nint add(int x, int y) {\n\treturn (x + y) % mod;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n * 4), b(n * 4), c(n * 4), d(n * 4);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 4] >> b[i * 4] >> c[i * 4] >> d[i * 4];\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\ta[i * 4 + j] = d[i * 4 + j - 1];\n\t\t\tb[i * 4 + j] = a[i * 4 + j - 1];\n\t\t\tc[i * 4 + j] = b[i * 4 + j - 1];\n\t\t\td[i * 4 + j] = c[i * 4 + j - 1];\n\t\t}\n\t}\n\tn *= 4;\n\n\tmap<P, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp[make_tuple(a[i], b[i], c[i], d[i])]++;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i / 4 == j / 4) continue;\n\t\t\tP x(a[i], b[i], c[i], d[i]);\n\t\t\tP y(a[j], b[j], c[j], d[j]);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[x]--;\n\t\t\t\tmp[y]--;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tP p[4];\n\t\t\tp[0] = P(d[j], c[j], b[i], a[i]);\n\t\t\tp[1] = P(b[i], c[j], b[j], c[i]);\n\t\t\tp[2] = P(d[j], a[i], d[i], a[j]);\n\t\t\tp[3] = P(d[i], c[i], b[j], a[j]);\n\n\t\t\tint cnt = 1;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt = mul(cnt, mp[p[k]]);\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[p[k]]--;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[p[k]]++;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[x]++;\n\t\t\t\tmp[y]++;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\t\t\t\n\t\t\tans = add(ans, cnt);\n\t\t}\n\t}\n\tcout << mul(ans, modinv(24, mod)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 410;\ntypedef long long LL;\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a *= a) if (b & 1) res *= a;\n\treturn res;\n}\nint C[MAXN][4], n;\nLL hash(int * a) { return a[0] | a[1] << 16 | (LL) a[2] << 32 | (LL) a[3] << 48; }\nvoid dehash(int * a, LL t) {\n\tstatic const int mask = (1 << 16) - 1;\n\ta[0] = t & mask, t >>= 16;\n\ta[1] = t & mask, t >>= 16;\n\ta[2] = t & mask, t >>= 16;\n\ta[3] = t & mask;\n}\nvoid mk(int * t, int a, int b, int c, int d) {\n\tt[0] = a, t[1] = b, t[2] = c, t[3] = d;\n}\nvoid rotate(int * a) {\n\tstatic int t;\n\tt = a[3], a[3] = a[2], a[2] = a[1], a[1] = a[0], a[0] = t;\n}\nint rtteq(int * a) {\n\tLL hs = hash(a); int res = 0;\n\tfor (int i = 0; i != 4; ++i) res += hash(a) == hs, rotate(a);\n\treturn res;\n}\nvoid mins(int * a) {\n\tLL h[4];\n\tfor (int i = 0; i != 4; ++i) h[i] = hash(a), rotate(a);\n\tint at = std::min_element(h, h + 4) - h;\n\tfor (int i = 0; i != at; ++i) rotate(a);\n}\nLL down(int a, int b) {\n\tLL res = 1;\n\tfor (int i = a; i > a - b; --i) res *= i;\n\treturn res;\n}\nstd::map<LL, int> hav, pt;\nvoid ins(int * a, int v) { hav[hash(a)] += v; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t\tstd::cin >> C[i][j];\n\t\tmins(C[i]); ins(C[i], 1);\n\t}\n\tLL ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tins(C[i], -1), ins(C[j], -1);\n\t\t\tfor (int T = 0; T != 4; ++T) {\n\t\t\t\tint t[4];\n\t\t\t\tmk(t, C[i][3], C[i][2], C[j][3], C[j][2]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tmk(t, C[i][2], C[i][1], C[j][0], C[j][3]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tmk(t, C[i][1], C[i][0], C[j][1], C[j][0]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tmk(t, C[i][0], C[i][3], C[j][2], C[j][1]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tLL r = 1;\n\t\t\t\tfor (auto x : pt) {\n\t\t\t\t\tr *= down(hav[x.first], x.second);\n\t\t\t\t\tdehash(t, x.first);\n\t\t\t\t\tr *= pow(rtteq(t), x.second);\n\t\t\t\t}\n\t\t\t\tans += r;\n\t\t\t\tpt.clear();\n\t\t\t\trotate(C[j]);\n\t\t\t}\n\t\t\tins(C[i], 1), ins(C[j], 1);\n\t\t}\n\tstd::cout << ans / 3 << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nusing namespace std;\nnamespace IO{/*{{{*/\n\tconst int S=8005;\n\tchar buf[S];\n\tint pos;\n\tvoid Load(){\n\t\tfread(buf,1,S,stdin);\n\t\tpos=0;\n\t}\n\tchar getChar(){\n\t\treturn buf[pos++];\n\t}\n\tint getInt(){\n\t\tint x=0,f=1;\n\t\tchar c=getChar();\n\t\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}\n\t\twhile('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}\n\t\treturn x*f;\n\t}\n}/*}}}*/\nusing IO::getInt;\nconst int N=405;\nnamespace HASH{/*{{{*/\n\tconst int N=2005;\n\tconst int MOD=9875321;\n\tint sz,h[MOD],nex[N],val[N];\n\tll key[N];\n\tinline int getHash(ll x){\n\t\treturn x%MOD;\n\t}\n\tvoid add(ll x,int y){\n\t\tint pos=getHash(x),u;\n\t\tfor(u=h[pos];u&&nex[u]&&key[u]!=x;u=nex[u]);\n\t\tif(key[u]==x)\n\t\t\tval[u]+=y;\n\t\telse{\n\t\t\tif(!h[pos])\n\t\t\t\th[pos]=++sz;\n\t\t\telse nex[u]=++sz;\n\t\t\tkey[sz]=x;\n\t\t\tval[sz]=y;\n\t\t}\n\t}\n\tint query(ll x){\n\t\tint pos=getHash(x),u;\n\t\tfor(u=h[pos];u&&nex[u]&&key[u]!=x;u=nex[u]);\n\t\treturn key[u]==x?val[u]:0;\n\t}\n}/*}}}*/\nint n;\nint c[N][4];\ninline ll getKey(int *c){\n\treturn c[0]+c[1]*1000+1ll*c[2]*1000000+1ll*c[3]*1000000000;\n}\ninline void rotate(int *c){\n\tint c0=c[0];\n\tfor(int i=0;i<3;i++)\n\t\tc[i]=c[i+1];\n\tc[3]=c0;\n}\ninline void pattern_add(int *c,int x){\n\tfor(int i=0;i<4;i++){\n\t\tHASH::add(getKey(c),x);\t\n\t\trotate(c);\n\t}\n}\nvoid readData(){\n\tIO::Load();\n\tn=getInt();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tc[i][j]=getInt();\n\t\tpattern_add(c[i],1);\n\t}\n}\nvoid solve(){\n\tll ans=0;\n\tfor(int i=1;i<n;i++){\n\t\tpattern_add(c[i],-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tpattern_add(c[j],-1);\n\t\t\tfor(int l=0;l<4;l++){// rotate up face\n\t\t\t\tstatic int s[4]; //state of side face (iterated)\n\t\t\t\tll now=1;\n\t\t\t\tint k;\n\t\t\t\tbool flag=false;\n\t\t\t\tfor(k=0;k<4&&now;k++){// count 4 side faces\n\t\t\t\t\ts[3]=c[i][k]; s[2]=c[i][(k+1)%4]; s[0]=c[j][3-k]; s[1]=c[j][3-(k+1)%4];\n\t\t\t\t\tnow*=HASH::query(getKey(s));\n\t\t\t\t\tif(now)\n\t\t\t\t\t\tpattern_add(s,-1);\n\t\t\t\t\telse flag=true;\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t\tfor(k--;k>=0;k--){// backspace \n\t\t\t\t\ts[3]=c[i][k]; s[2]=c[i][(k+1)%4]; s[0]=c[j][3-k]; s[1]=c[j][3-(k+1)%4];\n\t\t\t\t\tif(!flag)\n\t\t\t\t\t\tpattern_add(s,1);\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\trotate(c[j]);\n\t\t\t}\n\t\t\tpattern_add(c[j],1);\t\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\n#define N 410\n#define lint long long\n#define gc getchar()\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nint Gc;unordered_map<lint,int> cnt;lint val[1000];\nint c[N][5];lint cv[N][4];\ninline lint hv(int a,int b,int c,int d)\n{\n\treturn a*1000000000ll+b*1000000ll+c*1000ll+d;\n}\ninline lint hv(int *a)\n{\n\treturn hv(a[0],a[1],a[2],a[3]);\n}\ninline int Rot(int *a,int c)\n{\n\trep(i,1,c)\n\t{\n\t\tint tmp=a[0];\n\t\trep(j,1,3) a[j-1]=a[j];\n\t\ta[3]=tmp;\n\t}\n\treturn 0;\n}\ninline int Add(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]++;\n\treturn 0;\n}\ninline int Del(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]--;\n\treturn 0;\n}\ninline int Get(int a,int b,int c,int d)\n{\n\tint t=cnt[hv(a,b,c,d)];\n\tcnt[val[++Gc]=hv(a,b,c,d)]--;\n\tcnt[val[++Gc]=hv(b,c,d,a)]--;\n\tcnt[val[++Gc]=hv(c,d,a,b)]--;\n\tcnt[val[++Gc]=hv(d,a,b,c)]--;\n\treturn t;\n}\ninline int Back()\n{\n\trep(i,1,Gc) cnt[val[i]]++;\n\tGc=0;return 0;\n}\nint main()\n{\n\tint n=inn();lint ans=0ll;\n\trep(i,1,n) rep(j,0,3) c[i][j]=inn();\n\trep(i,1,n)\n\t{\n\t\t#define a c[i]\n\t\tcnt[cv[i][0]=hv(a[0],a[1],a[2],a[3])]++;\n\t\tcnt[cv[i][1]=hv(a[1],a[2],a[3],a[0])]++;\n\t\tcnt[cv[i][2]=hv(a[2],a[3],a[0],a[1])]++;\n\t\tcnt[cv[i][3]=hv(a[3],a[0],a[1],a[2])]++;\n\t\t#undef a\n\t}\n\trep(i,1,n)\n\t{\n\t\tDel(i);\n\t\trep(p,0,3)\n\t\t{\n//\t\t\tRot(c[i],p);\n\t\t\trep(j,1,n) if(i!=j)\n\t\t\t{\n\t\t\t\tDel(j);\n\t\t\t\trep(q,0,3)\n\t\t\t\t{\n//\t\t\t\t\tRot(c[j],q);\n\t\t\t\t\tint s,x,z,y;\n\t\t\t\t\ts=Get(c[j][1],c[j][0],c[i][1],c[i][0]);//S\n\t\t\t\t\tif(!s) goto loop;\n\t\t\t\t\tx=Get(c[j][2],c[i][3],c[i][2],c[j][3]);//X\n\t\t\t\t\tif(!x) goto loop;\n\t\t\t\t\tz=Get(c[j][1],c[i][0],c[i][3],c[j][2]);//Z\n\t\t\t\t\tif(!z) goto loop;\n\t\t\t\t\ty=Get(c[i][1],c[j][0],c[j][3],c[i][2]);//Y\n\t\t\t\t\tif(!y) goto loop;\n\t\t\t\t\tans+=1ll*s*x*z*y;\n\t\t\t\t\tloop:;\n\t\t\t\t\tBack();\n\t\t\t\t\tRot(c[j],1);\n\t\t\t\t}\n\t\t\t\tAdd(j);\n\t\t\t}\n\t\t\tRot(c[i],1);\n\t\t}\n\t\tAdd(i);\n\t}\n\treturn !printf(\"%lld\\n\",ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n;\nlong long bin[5],ans;\nlong long a[405][4],A[4],B[4];\nunordered_map<long long,long long>mp;\nlong long gao(long long aa,long long bb)\n{\n\tlong long qwq=0;\n\tfor(long long j=0;j<4;++j) qwq+=bin[j]*a[aa][(bb+j)%4];\n\treturn qwq;\n}\nlong long md(long long aa,long long bb,long long cc)\n{\n\ta[n+1][0]=A[aa];a[n+1][1]=B[aa];\n\ta[n+1][2]=B[bb];a[n+1][3]=A[bb];\n\tlong long tmp=gao(n+1,0);\n\tif(!mp.count(tmp)) return 0;tmp=mp[tmp];\n\tfor(long long i=0;i<4;++i) mp[gao(n+1,i)]-=cc;\n\treturn tmp;\n}\nvoid getans()\n{\n\tans+=1ll*md(0,1,1)*md(1,2,1)*md(2,3,1)*md(3,0,1);\n\tmd(0,1,-1);md(1,2,-1);md(2,3,-1);md(3,0,-1);\n\treturn;\n}\nint main()\n{\n\tn=read();bin[0]=1;\n\tfor(long long i=1;i<4;++i) bin[i]=bin[i-1]*1000;\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tfor(long long j=0;j<4;++j) a[i][j]=read();\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]--,A[j]=a[i][j];\n\t\tfor(long long j=i+1;j<=n;++j)\n\t\t{\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]--;\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l)\n\t\t\t{\n\t\t\t\tfor(long long k=0;k<4;++k) B[k]=a[j][(k+l)%4];\n\t\t\t\tgetans();\n\t\t\t}\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]++;\n\t\t}\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\twrite(ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef pair<LD,LD> Pt;\ntypedef tuple<int,int,int> tiii;\ntypedef tuple<LL,LL,LL> tlll;\n#define mod9 1000000009ll\n#define mod7 1000000007ll\n#define INF  1023456789ll\n#define INF16 10000000000000000ll\n#define FI first\n#define SE second\n#define X FI\n#define Y SE\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nLL n , c[ N ][ 4 ];\nvoid build(){\n \n}\nmap< LL , int > cnt;\nmap< pair<LL,LL> , int > cnt2;\nmap< tuple<LL,LL,LL> , int > cnt3;\nmap< tuple<LL,LL,LL,LL> , int > cnt4;\ninline bool bye( const pair<LL,LL>& x ){\n  LL t[ 4 ] , rr = x.first;;\n  for( int i = 3 ; i >= 0 ; i -- ){\n    t[ i ] = rr % 1000;\n    rr /= 1000;\n  }\n  for( int i = 0 ; i < 4 ; i ++ ){\n    LL ret = 0;\n    for( int j = 0 ; j < 4 ; j ++ )\n      ret = ret * 1000 + t[ ( i + j ) & 3 ];\n    if( ret == x.second ) return false;\n  }\n  return true;\n}\ninline LL CNT( LL x ){\n  auto it = cnt.find( x );\n  return it == cnt.end() ? 0 : it->second;\n}\ninline LL CNT2( pair<LL,LL> x ){\n  auto it = cnt2.find( x );\n  return it == cnt2.end() ? 0 : it->second;\n}\ninline LL CNT3( tuple<LL,LL,LL> x ){\n  auto it = cnt3.find( x );\n  return it == cnt3.end() ? 0 : it->second;\n}\ninline LL CNT4( tuple<LL,LL,LL,LL> x ){\n  auto it = cnt4.find( x );\n  return it == cnt4.end() ? 0 : it->second;\n}\nvector< LL > vv[ N ];\ninline void modify( int id , int dlt ){\n  if( vv[ id ][ 0 ] == vv[ id ][ 3 ] ){\n    cnt[ vv[ id ][ 0 ] ] += dlt * (1 << 2);\n    cnt2[ { vv[ id ][ 0 ] , vv[ id ][ 0 ] } ] += dlt * (1 << 4);\n    cnt3[ make_tuple( vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] ) ] += dlt * (1 << 6);\n    cnt4[ make_tuple( vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] ) ] += dlt * (1 << 8);\n  }else{\n    for( LL i1 : vv[ id ] ){\n      cnt[ i1 ] += dlt;\n      for( LL i2 : vv[ id ] ){\n        cnt2[ { i1 , i2 } ] += dlt;\n        for( LL i3 : vv[ id ] ){\n          cnt3[ make_tuple( i1 , i2 , i3 ) ] += dlt;\n          for( LL i4 : vv[ id ] )\n            cnt4[ make_tuple( i1 , i2 , i3 , i4 ) ] += dlt;\n        }\n      }\n    }     \n  }\n}\ninline LL zip( LL za , LL zb , LL zc , LL zd ){\n  LL ret = 0;\n  for( LL i : { za , zb , zc , zd } )\n    ret = ret * 1000 + i;\n  return ret;\n}\nvoid init(){\n  scanf( \"%lld\" , &n );\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      scanf( \"%lld\" , &c[ i ][ j ] );\n    for( int j = 0 ; j < 4 ; j ++ ){\n      LL ret = 0;\n      for( int k = 0 ; k < 4 ; k ++ )\n        ret = ret * 1000 + c[ i ][ ( j + k ) % 4 ];\n      vv[ i ].push_back( ret );\n    }\n    sort( vv[ i ].begin() , vv[ i ].end() );\n  }\n}\nvoid solve(){\n  LL ans = 0;\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = i - 1 ; j >= 0 ; j -- ){\n      if( j != i - 1 ) modify( j , -1 );\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL iv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          iv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , iv[ 1 ] , iv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , iv[ 2 ] , iv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , iv[ 3 ] , iv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , iv[ 0 ] , iv[ 3 ] );\n        // A , B , C , D\n        LL tans = CNT( f1 ) * CNT( f2 ) * CNT( f3 ) * CNT( f4 );\n        if( tans > 0 ){\n          // { A , A } , { B , B }\n          tans += CNT2( { f1 , f2 } ) * CNT2( { f3 , f4 } );\n          tans += CNT2( { f1 , f3 } ) * CNT2( { f2 , f4 } );\n          tans += CNT2( { f1 , f4 } ) * CNT2( { f2 , f3 } );\n          // { A , A , A } , B\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f3 ) ) * CNT( f4 );\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f4 ) ) * CNT( f3 );\n          tans += 2ll * CNT3( make_tuple( f1 , f3 , f4 ) ) * CNT( f2 );\n          tans += 2ll * CNT3( make_tuple( f2 , f3 , f4 ) ) * CNT( f1 );\n          if( tans > 0 ){\n            // { A , A } , B , C\n            tans -= CNT2( { f1 , f2 } ) * CNT( f3 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f3 } ) * CNT( f2 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f4 } ) * CNT( f2 ) * CNT( f3 );\n            tans -= CNT2( { f2 , f3 } ) * CNT( f1 ) * CNT( f4 );\n            tans -= CNT2( { f2 , f4 } ) * CNT( f1 ) * CNT( f3 );\n            tans -= CNT2( { f3 , f4 } ) * CNT( f1 ) * CNT( f2 );\n            // { A , A , A , A }\n            tans -= 6ll * CNT4( make_tuple( f1 , f2 , f3 , f4 ) );\n          }\n        }\n        ans += tans;\n      }\n      modify( j , +1 );\n    }\n  }\n  printf( \"%lld\\n\" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\n#define REP(i,n) for (int i = 0; i < n; ++i)\n\nll getVal(vi cs) {\n    ll val = 0;\n    REP (k, 4) {\n        ll v = 0;\n        REP (i, 4) v = v * 1000 + cs[(i+k)&3];\n        val = max(val, v);\n    }\n    return val;\n}\n\nvi getVector(ll val) {\n    vi vec(4);\n    REP (k, 4) {\n        vec[k] = val % 1000;\n        val /= 1000;\n    }\n    return vec;\n}\n\nvi getVector(vi top, vi bottom, int idx) {\n    vi cs(4);\n    cs[0] = top[(idx+1)&3];\n    cs[1] = top[idx];\n    cs[2] = bottom[idx&3];\n    cs[3] = bottom[(idx+1)&3];\n    return cs;\n}\n\nll rotate(ll tile) {\n    ll next = tile / 1000;\n    next += (tile%1000) * 1e9;\n    return next;\n}\n\nconst int MAX = 410;\n\nint N;\nmap<ll, int> tiles;\nll C[MAX];\n\nint main() {\n    cin >> N;\n    REP (k, N) {\n        vi t(4);\n        REP (i, 4) cin >> t[i];\n        ll val = getVal(t);\n        tiles[val] += 1;\n        C[k] = val;\n    }\n\n    ll ans = 0;\n    int count = 0;\n    REP (idxT, N) {\n        ll top = C[idxT];\n        tiles[top] -= 1;\n        vi vecT = getVector(top);\n        reverse(vecT.begin(), vecT.end());\n        for (int idxB = idxT+1; idxB < N; idxB++) {\n            ll bottom = C[idxB];\n            tiles[bottom] -= 1;\n\n            REP (n, 4) {\n                vi vecB = getVector(bottom);\n\n                ll tmp = 1;\n                vi ts(4);\n\n                REP (idx, 4) {\n                    vi side = getVector(vecT, vecB, idx);\n                    ll v = getVal(side);\n                    tmp *= tiles[v];\n                    if (side[0] == side[2] && side[1] == side[3]) {\n                        tmp *= 2;\n                        if (side[0] == side[1]) tmp *= 2;\n                    }\n                    tiles[v] -= 1;\n                    ts[idx] = v;\n                }\n                ans += tmp;\n                REP (idx, 4) tiles[ts[idx]] += 1;\n\n                bottom = rotate(bottom);\n            }\n\n            tiles[bottom] += 1;\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); i--)\n#define debug(x) cout << #x << \" => \" << x << endl\nusing namespace std;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 7 + 400;\n///----------------------------------------------\n//int qpow(int\n\nint col[10];\nvoid rote() {\n    int tmp[4]; rep(i,0,4) tmp[i]=col[i];\n    rep(beg,1,4) {\n        int i; for (i=0; i<3&&tmp[(beg+i)%4]==col[i]; ) i++;\n        if(tmp[(beg+i)%4]<col[i]) {\n            rep(i,0,4) col[i]=tmp[(beg+i)%4];\n        }\n    }\n}\n\nconst int B[4]={1000000000, 1000000, 1000, 1};\nll getval() {\n    ll val=0;\n    rep(i,0,4) val+=1ll*col[i]*B[i];\n    return val;\n}\n\nbool same() {\n    rep(i,1,4) if (col[i]!=col[0]) return false;\n    return true;\n}\nbool same2() {\n    return col[0]==col[2]&&col[1]==col[3];\n}\n\n\nmap<ll,int> num;\nint tab[MAX_N][4];\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///init\n    ///read\n    int n; cin>>n;\n    rep(i,0,n) {\n        rep(j,0,4) scanf(\"%d\",&col[j]);\n        rep(j,0,4) tab[i][j]=col[j];\n        rote();\n        num[getval()]++;\n\n    }\n\n    ///work\n    ll ans=0;\n    rep(i,0,n) {\n\n        rep(j,0,4) col[j]=tab[i][j]; rote();\n        num[getval()]--;\n\n        rep(j,i+1,n) {\n\n            rep(k,0,4) col[k]=tab[j][k]; rote();\n            num[getval()]--;\n\n            rep(off,0,4) {\n\n\n                int tmp=1;\n\n                ///front\n                col[0]=tab[i][1]; col[1]=tab[j][(off+0)%4];\n                col[3]=tab[i][2]; col[2]=tab[j][(off+3)%4]; rote();\n                ll val1 = getval();\n                ll tmp1 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val1]--)*tmp1;\n\n                ///top\n                col[0]=tab[i][0]; col[1]=tab[j][(off+1)%4];\n                col[3]=tab[i][1]; col[2]=tab[j][(off+0)%4]; rote();\n                ll val2 = getval();\n                ll tmp2 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val2]--)*tmp2;\n\n                ///buttom\n                col[0]=tab[i][2]; col[1]=tab[j][(off+3)%4];\n                col[3]=tab[i][3]; col[2]=tab[j][(off+2)%4]; rote();\n                ll val3 = getval();\n                ll tmp3 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val3]--)*tmp3;\n\n                ///back\n                col[0]=tab[i][3]; col[1]=tab[j][(off+2)%4];\n                col[3]=tab[i][0]; col[2]=tab[j][(off+1)%4]; rote();\n                ll val4 = getval();\n                ll tmp4 = same() ? 4 : same2() ? 2 : 1;\n                tmp=1ll*tmp*(num[val4]--)*tmp4;\n\n                ans=ans+tmp;\n                num[val1]++;\n                num[val2]++;\n                num[val3]++;\n                num[val4]++;\n\n            }\n            rep(k,0,4) col[k]=tab[j][k]; rote();\n            num[getval()]++;\n       }\n    }\n\n    ///print\n    cout << ans << endl;\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    unordered_map<C, int> P;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}});\n                    int opts = P[u[l]];\n                    if (u[l] == p) --opts;\n                    if (u[l] == q) --opts;\n                    for (int m = 0; m < l; m++) {\n                        if (u[m] == u[l]) --opts;\n                    }\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*rot(u[l]);\n                    }\n                }\n                ans += cur;\n            }\n        }\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef pair<LD,LD> Pt;\ntypedef tuple<int,int,int> tiii;\ntypedef tuple<LL,LL,LL> tlll;\n#define mod9 1000000009ll\n#define mod7 1000000007ll\n#define INF  1023456789ll\n#define INF16 10000000000000000ll\n#define FI first\n#define SE second\n#define X FI\n#define Y SE\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nLL n , c[ N ][ 4 ];\nvoid build(){\n\n}\nmap< LL , int > cnt;\nmap< pair<LL,LL> , int > cnt2;\nmap< tuple<LL,LL,LL> , int > cnt3;\nmap< tuple<LL,LL,LL,LL> , int > cnt4;\ninline LL CNT( LL x ){\n  auto it = cnt.find( x );\n  return it == cnt.end() ? 0 : it->second;\n}\ninline LL CNT2( pair<LL,LL> x ){\n  auto it = cnt2.find( x );\n  return it == cnt2.end() ? 0 : it->second;\n}\ninline LL CNT3( tuple<LL,LL,LL> x ){\n  auto it = cnt3.find( x );\n  return it == cnt3.end() ? 0 : it->second;\n}\ninline LL CNT4( tuple<LL,LL,LL,LL> x ){\n  auto it = cnt4.find( x );\n  return it == cnt4.end() ? 0 : it->second;\n}\nvector< LL > vv[ N ];\ninline void modify( int id , int dlt ){\n  for( LL i1 : vv[ id ] ){\n    cnt[ i1 ] += dlt;\n    for( LL i2 : vv[ id ] ){\n      cnt2[ { i1 , i2 } ] += dlt;\n      for( LL i3 : vv[ id ] ){\n        cnt3[ make_tuple( i1 , i2 , i3 ) ] += dlt;\n        for( LL i4 : vv[ id ] )\n          cnt4[ make_tuple( i1 , i2 , i3 , i4 ) ] += dlt;\n      }\n    }\n  }       \n}\ninline LL zip( LL za , LL zb , LL zc , LL zd ){\n  LL ret = 0;\n  for( LL i : { za , zb , zc , zd } )\n    ret = ret * 1000 + i;\n  return ret;\n}\nvoid init(){\n  scanf( \"%lld\" , &n );\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      scanf( \"%lld\" , &c[ i ][ j ] );\n    for( int j = 0 ; j < 4 ; j ++ ){\n      LL ret = 0;\n      for( int k = 0 ; k < 4 ; k ++ )\n        ret = ret * 1000 + c[ i ][ ( j + k ) % 4 ];\n      vv[ i ].push_back( ret );\n    }\n  }\n}\nvoid solve(){\n  LL ans = 0;\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = i - 1 ; j >= 0 ; j -- ){\n      modify( j , -1 );\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL iv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          iv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , iv[ 1 ] , iv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , iv[ 2 ] , iv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , iv[ 3 ] , iv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , iv[ 0 ] , iv[ 3 ] );\n        // A , B , C , D\n        LL tans = CNT( f1 ) * CNT( f2 ) * CNT( f3 ) * CNT( f4 );\n        if( tans > 0 ){\n          // { A , A } , { B , B }\n          tans += CNT2( { f1 , f2 } ) * CNT2( { f3 , f4 } );\n          tans += CNT2( { f1 , f3 } ) * CNT2( { f2 , f4 } );\n          tans += CNT2( { f1 , f4 } ) * CNT2( { f2 , f3 } );\n          // { A , A , A } , B\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f3 ) ) * CNT( f4 );\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f4 ) ) * CNT( f3 );\n          tans += 2ll * CNT3( make_tuple( f1 , f3 , f4 ) ) * CNT( f2 );\n          tans += 2ll * CNT3( make_tuple( f2 , f3 , f4 ) ) * CNT( f1 );\n          if( tans > 0 ){\n            // { A , A } , B , C\n            tans -= CNT2( { f1 , f2 } ) * CNT( f3 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f3 } ) * CNT( f2 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f4 } ) * CNT( f2 ) * CNT( f3 );\n            tans -= CNT2( { f2 , f3 } ) * CNT( f1 ) * CNT( f4 );\n            tans -= CNT2( { f2 , f4 } ) * CNT( f1 ) * CNT( f3 );\n            tans -= CNT2( { f3 , f4 } ) * CNT( f1 ) * CNT( f2 );\n            // { A , A , A , A }\n            tans -= 6ll * CNT4( make_tuple( f1 , f2 , f3 , f4 ) );\n          }\n        }\n        ans += tans;\n      }\n      modify( j , +1 );\n    }\n    modify( i , +1 );\n  }\n  printf( \"%lld\\n\" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define AREP(i,a,n) for(int i=a;i<n;i++)\nvoid SO(vector<int> &v){\n  vector<int> w(8);\n  REP(i,4)w[i]=w[i+4]=v[i];\n  REP(j,4)\n    if(w[j]*1e9+w[j+1]*1e6+w[j+2]*1e3+w[j+3]<v[0]*1e9+v[1]*1e6+v[2]*1e3+v[3])\n      REP(a,4)v[a]=w[j+a];\n}\nint cou(vector<vector<int>> &c,vector<int> &need,int idx,int n,int ex){\n  if((idx<n-1&&c[idx+1]>need)||c[n-1]<need)return 0;\n  int l=idx,r=n;\n  while(r-l>1){\n    int mid=(r+l)>>1;\n    (c[mid]<need?l:r)=mid;\n  }\n  int miman=l;\n  r=n;\n  while(r-l>1){\n    int mid=(r+l)>>1;\n    (c[mid]<=need?l:r)=mid;\n  }\n  return l-miman-(c[ex]==need);\n}\nint F(vector<int> &v){\n  if(v[0]==v[1]&&v[1]==v[2]&&v[2]==v[3])return 4;\n  if(v[0]==v[2]&&v[1]==v[3])return 2;\n  return 1;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<vector<int>> c(n);\n  REP(i,n){\n    REP(j,4){\n      int a;cin>>a;\n      c[i].push_back(a);\n    }\n    SO(c[i]);\n  }\n  sort(c.begin(),c.end());\n  cout<<endl;\n  REP(i,n){\n    REP(j,4)cout<<c[i][j]<<\" \";cout<<endl;\n  }\n  int ans=0;\n  REP(i,n)\n    AREP(j,i+1,n)\n      REP(k,4){\n        vector<vector<int>> need(4);\n        REP(l,4){\n          need[l].push_back(c[j][(4-l+1+k)%4]);\n          need[l].push_back(c[j][(4-l+k)%4]);\n          need[l].push_back(c[i][(l+1)%4]);\n          need[l].push_back(c[i][l]);\n          SO(need[l]);\n        }\n        sort(need.begin(),need.end());\n        int A=cou(c,need[0],i,n,j);\n        int B=(need[0]==need[1]?A-1:cou(c,need[1],i,n,j));\n        int C=(need[1]==need[2]?B-1:cou(c,need[2],i,n,j));\n        int D=(need[2]==need[3]?C-1:cou(c,need[3],i,n,j));\n        if(min({A,B,C,D})<=0)continue;\n        ans+=A*B*C*D*F(need[0])*F(need[1])*F(need[2])*F(need[3]);\n      }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 405;\n\nLL ans, ways, f[MAXN], tmp[4];\nmap <LL, int> cnt;\nint n, a[MAXN][4];\n\ninline LL Get(int a, int b, int c, int d)\n{\n\tint e[4] = {a, b, c, d};\n\tLL ret = 1LL << 60;\n\tfor (int i = 0; i < 4; i ++)\n\t{\n\t\tLL cur = 0;\n\t\tfor (int j = 0; j < 4; j ++)\n\t\t\tcur = cur << 10 | e[i + j & 3];\n\t\tret = min(ret, cur);\n\t}\n\treturn ret;\n}\n\ninline int Get(LL x)\n{\n\tif (x >> 20 == (x & (1 << 20) - 1))\n\t{\n\t\tif (x >> 30 == (x & (1 << 10) - 1))\n\t\t\treturn 4;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read();\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tfor (int j = 0; j < 4; j ++)\n\t\t\ta[i][j] = Read();\n\t\tcnt[f[i] = Get(a[i][0], a[i][1], a[i][2], a[i][3])] ++;\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tcnt[f[i]] --;\n\t\tfor (int j = i + 1; j <= n; j ++)\n\t\t{\n\t\t\tcnt[f[j]] --;\n\t\t\tfor (int k = 0; k < 4; k ++)\n\t\t\t{\n\t\t\t\tways = 1;\n\t\t\t\tfor (int l = 0; l < 4; l ++)\n\t\t\t\t{\n\t\t\t\t\ttmp[l] = Get(a[i][l + 1 & 3], a[i][l], a[j][k - l + 5 & 3], a[j][k - l + 4 & 3]);\n\t\t\t\t\tif (!cnt[tmp[l]])\n\t\t\t\t\t\ttmp[l] = -1, ways = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tways *= cnt[tmp[l]] * Get(tmp[l]), cnt[tmp[l]] --;\n\t\t\t\t}\n\t\t\t\tans += ways;\n\t\t\t\tfor (int l = 0; l < 4; l ++)\n\t\t\t\t\tif (~tmp[l])\n\t\t\t\t\t\tcnt[tmp[l]] ++;\n\t\t\t}\n\t\t\tcnt[f[j]] ++;\n\t\t}\n\t\tcnt[f[i]] ++;\n\t}\n\treturn printf(\"%lld\\n\", ans / 3), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nll rot(ll c, int r){\n    ll p[4];\n    FORR(i,3,0){\n        p[i] = c % 1000;\n        c /= 1000;\n    }\n    ll ret = 0;\n    REP(i,4){\n        ret = 1000 * ret + p[(i+r)%4];\n    }\n    return ret;\n}\n\nll col(ll c, int x){\n    REP(i,3-x) c /= 1000;\n    return c % 1000;\n}\n\nll make(ll a, ll b, ll c, ll d){\n    return 1000000000LL * a + 1000000 * b + 1000 * c + d;\n}\n\nll calc(VVL c){\n    return 0;\n    int n = c.size();\n    VVL dp(n+1, VL(16));\n    dp[0][0] = 1;\n    REP(i,n) REP(mask,16){\n        dp[i+1][mask] += dp[i][mask];\n        REP(j,4){\n            if ((mask >> j) & 1) continue;\n            dp[i+1][mask | (1 << j)] += dp[i][mask] * c[i][j];\n        }\n    }\n\n    // REP(i,n){\n    //     REP(j,4) cout << c[i][j] << \" \";\n    //     cout<< endl;\n    // }\n\n    // REP(i,n+1){\n    //     REP(j,16) cout << dp[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n\n    return dp[n][15];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    VL c(n);\n    REP(i,n){\n        ll tmp = 0;\n        REP(j,4){\n            ll x;\n            cin >> x;\n            tmp = 1000 * tmp + x;\n        }\n        c[i] = tmp;\n        FOR(j,1,3) c[i] = min(c[i], rot(tmp, j));\n    }\n\n    map<ll, ll> mp;\n    REP(i,n) mp[c[i]]++;\n\n    // for (PL p : mp){\n    //     cout << p.first << \" \" << p.second << endl;\n    // }\n\n    ll ans = 0;\n    REP(i,n) REP(j,i) REP(r,4){\n        ll c1 = c[i], c2 = rot(c[j], r);\n        mp[c1]--;\n        mp[c[j]]--;\n\n        ll cs[4];\n        cs[0] = make(col(c1,1), col(c1,0), col(c2,1), col(c2,0));\n        cs[1] = make(col(c1,2), col(c1,1), col(c2,0), col(c2,3));\n        cs[2] = make(col(c1,3), col(c1,2), col(c2,3), col(c2,2));\n        cs[3] = make(col(c1,0), col(c1,3), col(c2,2), col(c2,1));\n\n        REP(x,4){\n            ll tmp = cs[x];\n            FOR(p,1,3) cs[x] = min(cs[x], rot(tmp, p));\n        }\n\n        map<ll, ll> side;\n        REP(x,4) side[cs[x]]++;\n\n        ll tmp = 1;\n        for (PL p : side){\n            ll col = p.first;\n            ll cnt = p.second;\n            if (!mp.count(col) || mp[col] < cnt){\n                tmp = 0;\n            }else{\n                ll perm = 1;\n                REP(x,cnt) perm *= mp[col] - x;\n                if (col == rot(col, 1)){\n                    REP(x,cnt) perm *= 4;\n                }else if (col == rot(col, 2)){\n                    REP(x,cnt) perm *= 2;\n                }\n                tmp *= perm;\n            }\n        }\n\n        ans += tmp;\n        mp[c1]++;\n        mp[c[j]]++;\n    }\n    cout << ans / 3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) ((x)*1LL*1000000000+(y)*1000000+(z)*1000+(t))\nunordered_map<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[G(fr.x1,fr.x0,bk.x1,bk.x0)];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[G(fr.x2,fr.x1,bk.x0,bk.x3)];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[G(fr.x3,fr.x2,bk.x3,bk.x2)];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[G(fr.x0,fr.x3,bk.x2,bk.x1)];\n\t\tret+=ans;\n\t\tfor(int j=1;j<=3;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int, int> P;\n\nP rot(P p) {\n\tint a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn make_tuple(b, c, d, a);\n}\n\nint index_of(vector<P> &a, P b) {\n\tint k = lower_bound(a.begin(), a.end(), b) - a.begin();\n\tif (k >= a.size() || a[k] != b) return a.size();\n\treturn k;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n * 4), b(n * 4), c(n * 4), d(n * 4);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 4] >> b[i * 4] >> c[i * 4] >> d[i * 4];\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\ta[i * 4 + j] = d[i * 4 + j - 1];\n\t\t\tb[i * 4 + j] = a[i * 4 + j - 1];\n\t\t\tc[i * 4 + j] = b[i * 4 + j - 1];\n\t\t\td[i * 4 + j] = c[i * 4 + j - 1];\n\t\t}\n\t}\n\tn *= 4;\n\n\tvector<P> dict;\n\tfor (int i = 0; i < n; i++) {\n\t\tdict.emplace_back(a[i], b[i], c[i], d[i]);\n\t}\n\tsort(dict.begin(), dict.end());\n\tdict.erase(unique(dict.begin(), dict.end()), dict.end());\n\n\tvector<long long> cnt(dict.size() + 1);\n\tvector<int> next(dict.size() + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tP p(a[i], b[i], c[i], d[i]);\n\t\tint k = index_of(dict, p); \n\t\tcnt[k]++;\n\t\tnext[k] = index_of(dict, rot(p));\n\t}\n\tnext[dict.size()] = dict.size();\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i += 4) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i / 4 == j / 4) continue;\n\t\t\tint x = index_of(dict, P(a[i], b[i], c[i], d[i]));\n\t\t\tint y = index_of(dict, P(a[j], b[j], c[j], d[j]));\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt[x]--;\n\t\t\t\tcnt[y]--;\n\t\t\t\tx = next[x];\n\t\t\t\ty = next[y];\n\t\t\t}\n\n\t\t\tint p[4];\n\t\t\tp[0] = index_of(dict, P(d[j], c[j], b[i], a[i]));\n\t\t\tp[1] = index_of(dict, P(b[i], c[j], b[j], c[i]));\n\t\t\tp[2] = index_of(dict, P(d[j], a[i], d[i], a[j]));\n\t\t\tp[3] = index_of(dict, P(d[i], c[i], b[j], a[j]));\n\n\t\t\tlong long prod = 1;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tprod *= cnt[p[k]];\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tcnt[p[k]]--;\n\t\t\t\t\tp[k] = next[p[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tcnt[p[k]]++;\n\t\t\t\t\tp[k] = next[p[k]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt[x]++;\n\t\t\t\tcnt[y]++;\n\t\t\t\tx = next[x];\n\t\t\t\ty = next[y];\n\t\t\t}\n\n\t\t\tans += prod;\n\t\t}\n\t}\n\tcout << ans / 6 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define INF 2147483647\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\n#define _ 0\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nnamespace Mymath{\n\tLL qp(LL x,LL p,LL mod){\n\t\tLL ans=1;\n\t\twhile (p){\n\t\t\tif (p&1) ans=ans*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tp>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tLL inv(LL x,LL mod){\n\t\treturn qp(x,mod-2,mod);\n\t}\n\tLL C(LL N,LL K,LL fact[],LL mod){\n\t\treturn fact[N]*inv(fact[K],mod)%mod*inv(fact[N-K],mod)%mod;\n\t}\n\ttemplate <typename Tp> Tp gcd(Tp A,Tp B){\n\t\tif (B==0) return A;\n\t\treturn gcd(B,A%B);\n\t}\n\ttemplate <typename Tp> Tp lcm(Tp A,Tp B){\n\t\treturn A*B/gcd(A,B);\n\t}\n};\nnamespace fwt{\n\tusing namespace Mymath;\n\tvoid FWT(int a[],int n,LL mod)\n\t{\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;\n\t                //xor:a[i+j]=x+y,a[i+j+d]=x-y;\n\t                //and:a[i+j]=x+y;\n\t                //or:a[i+j+d]=x+y;\n\t            }\n\t}\n\n\tvoid UFWT(int a[],int n,LL mod)\n\t{\n\t\tLL rev=inv(2,mod);\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;\n\t                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n\t                //and:a[i+j]=x-y;\n\t                //or:a[i+j+d]=y-x;\n\t            }\n\t}\n\tvoid solve(int a[],int b[],int n,LL mod)\n\t{\n\t    FWT(a,n,mod);\n\t    FWT(b,n,mod);\n\t    for(int i=0;i<n;i++) a[i]=1LL*a[i]*b[i]%mod;\n\t    UFWT(a,n,mod);\n\t}\n};\nnamespace Maxflow{\n\tconst int Maxn=1005;\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tedge(int _to,int _rev,int _cap){\n\t\t\tto=_to,rev=_rev,cap=_cap;\n\t\t}\n\t};\n\tint src=1002,snk=1003;\n\tvector<edge> G[Maxn];\n\tint dist[Maxn],seen[Maxn];\n\tint n;\n\tvoid Clear(){\n\t\tfor (int i=0;i<Maxn;i++) G[i].clear();\n\t}\n\tvoid bfs(int s){\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=-1;\n\t\tdist[s]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()){\n\t\t\tint x=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tedge &e=G[x][i];\n\t\t\t\tif (e.cap && dist[e.to]==-1){\n\t\t\t\t\tdist[e.to]=dist[x]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int now,int dest,int fl){\n\t\tif (now==dest) return fl;\n\t\tfor (int &i=seen[now];i<G[now].size();i++){\n\t\t\tedge &ed=G[now][i];\n\t\t\tif (ed.cap && dist[ed.to]==dist[now]+1){\n\t\t\t\tint f=dfs(ed.to,dest,min(fl,ed.cap));\n\t\t\t\tif (f){\n\t\t\t\t\ted.cap-=f;\n\t\t\t\t\tG[ed.to][ed.rev].cap+=f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dinic(int s=src,int t=snk){\n\t\tint ret=0;\n\t\twhile (1){\n\t\t\tmemset(seen,0,sizeof(seen));\n\t\t\tbfs(s);\n\t\t\tif (dist[t]==-1) return ret;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\twhile(f){\n\t\t\t\tret+=f;\n\t\t\t\tf=dfs(s,t,INF);\n\t\t\t}\n\t\t}\n\t}\n};\nnamespace Geometry{\n\tstruct iP{\n\t\tLL x,y;\n\t\tiP(LL _x,LL _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tiP(){\n\t\t\tx=y=0;\n\t\t}\n\t\tiP operator +(iP p){\n\t\t\treturn iP(x+p.x,y+p.y);\n\t\t}\n\t\tiP operator -(iP p){\n\t\t\treturn iP(x-p.x,y-p.y);\n\t\t}\n\t\tiP operator *(LL k){\n\t\t\treturn iP(x*k,y*k);\n\t\t}\n\t\tLL det(iP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tLL dot(iP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tLL dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const iP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tstruct dP{\n\t\tdouble x,y;\n\t\tdP(double _x,double _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tdP(){\n\t\t\tx=y=0.0;\n\t\t}\n\t\tdP operator +(dP p){\n\t\t\treturn dP(x+p.x,y+p.y);\n\t\t}\n\t\tdP operator -(dP p){\n\t\t\treturn dP(x-p.x,y-p.y);\n\t\t}\n\t\tdP operator *(double k){\n\t\t\treturn dP(x*k,y*k);\n\t\t}\n\t\tdouble det(dP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tdouble dot(dP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tdouble dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const dP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tvector<iP> convex_hull(iP X[],int l){\n\t\t#define sz ret.size()\n\t\tvector<iP> ret;\n\t\tsort(X+1,X+1+l);\n\t\tret.pb(X[1]);\n\t\tfor (int i=2;i<=l;i++){\n\t\t\twhile (sz>=2 && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\tint rs=ret.size()+1;\n\t\tfor (int i=l-1;i>=1;i--){\n\t\t\twhile (sz>=rs && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst int Maxn=405;\nint c[Maxn][4];\nint n;\nint now[4][4];\nint cc[Maxn][4];\nLL V[4];\nLL ha[Maxn][4];\nLL dp[16],dp2[16];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t}\n\t\tfor (int st=0;st<4;st++){\n\t\t\tha[i][st]=0;\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tha[i][st]*=1000LL;\n\t\t\t\tha[i][st]+=c[i][(st+k)%4];\n\t\t\t}\n\t\t//\tcout<<ha[i][st]<<endl;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tfor (int k=0;k<4;k++){\n//\t\t\t\tbool flag=true;\n\t\t\t\tnow[0][0]=c[j][k];\n\t\t\t\tnow[0][1]=c[j][(k+3)%4];\n\t\t\t\tnow[0][2]=c[i][1];\n\t\t\t\tnow[0][3]=c[i][0];\n\t\t\t\t\n\t\t\t\tnow[1][0]=c[j][(k+3)%4];\n\t\t\t\tnow[1][1]=c[j][(k+2)%4];\n\t\t\t\tnow[1][2]=c[i][2];\n\t\t\t\tnow[1][3]=c[i][1];\n\t\t\t\t\n\t\t\t\tnow[2][0]=c[j][(k+2)%4];\n\t\t\t\tnow[2][1]=c[j][(k+1)%4];\n\t\t\t\tnow[2][2]=c[i][3];\n\t\t\t\tnow[2][3]=c[i][2];\n\t\t\t\t\n\t\t\t\tnow[3][0]=c[j][(k+1)%4];\n\t\t\t\tnow[3][1]=c[j][(k)%4];\n\t\t\t\tnow[3][2]=c[i][0];\n\t\t\t\tnow[3][3]=c[i][3];\n\t\t\t\t\n\t\t\t\tfor (int l=0;l<4;l++){\n\t\t\t\t\tV[l]=0;\n\t\t\t\t\tfor (int o=0;o<4;o++){\n\t\t\t\t\t\tV[l]=V[l]*1000+now[l][o];\n\t\t\t\t\t}\n\t\t\t\t\t//if (i==1 && j==5) cout<<k<<' '<<V[l]<<endl;\n\t\t\t\t//\tcout<<V[l]<<endl;\n\t\t\t\t}\n\t\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t\tdp[0]=1;\n\t\t\t\tfor (int l=i+1;l<=n;l++){\n\t\t\t\t\tif (l==i || l==j) continue;\n\t\t\t\t\tmemset(dp2,0,sizeof(dp2));\n\t\t\t\t\tfor (int jj=0;jj<4;jj++){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\tfor (int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\tif (ha[l][kk]==V[jj]) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (cnt){\n\t\t\t\t\t\t//\tcout<<cnt<<endl;\n\t\t\t\t\t\t\tfor (int q=15;q>=0;q--){\n\t\t\t\t\t\t\t\tif (q>>jj&1){\n\t\t\t\t\t\t\t\t\tdp2[q]+=dp[q^(1<<jj)]*cnt;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int jj=0;jj<16;jj++) dp[jj]+=dp2[jj];\n\t\t\t\t}\n\t\t\t\t//cout<<dp[15]<<endl;\n\t\t\t\tans+=dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\n#define dtz 1023\n#define id(A,B,C,D) ((A<<30)+(B<<20)+(C<<10)+D)\n#define get1(A) (A>>30)\n#define get2(A) ((A>>20)&dtz)\n#define get3(A) ((A>>10)&dtz)\n#define get4(A) (A&dtz)\n#define rotate(A) (((A&dtz)<<30)|(A>>10))\n#define MOD 19260817\n#define next DEEP_DARK_FANTASY\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nnamespace HASH{\n\tint first[MOD],cnt,next[10010],siz[10010];ll w[10010];\n\tvoid insert(ll val,int num){\n\t\tint pval=val%MOD,u=first[pval];\n//\t\tcout<<\"\tinsert \"<<val<<' '<<pval<<' '<<num<<'\\n';\n\t\tif(!u){\n\t\t\tcnt++;\n\t\t\tfirst[pval]=cnt;w[cnt]=val;siz[cnt]=num;\n\t\t\treturn;\n\t\t}\n\t\tfor(;next[u]&(w[u]!=val);u=next[u]);\n\t\tif(w[u]==val) siz[u]+=num;\n\t\telse{\n\t\t\tcnt++;\n\t\t\tnext[u]=cnt;\n\t\t\tw[cnt]=val;\n\t\t\tsiz[cnt]=num;\n\t\t}\n\t}\n\tint query(ll val){\n\t\tint pval=val%MOD,u=first[pval];\n\t\tfor(;u&&next[u]&&(w[u]!=val);u=next[u]);\n//\t\tcout<<\"\tquery \"<<val<<' '<<pval<<' '<<((w[u]==val)?siz[u]:0)<<'\\n';\n\t\treturn w[u]==val?siz[u]:0;\n\t}\n}\nvoid change(ll val,int num){\n\tHASH::insert(val,num);\n\tval=rotate(val);\n\tHASH::insert(val,num);\n\tval=rotate(val);\n\tHASH::insert(val,num);\n\tval=rotate(val);\n\tHASH::insert(val,num);\n}\nint n;ll c0[510],c1[510],c2[510],c3[510];\nint main(){\n\tn=read();int i,j;ll t1,t2,t3,t4,ans=0,cur,val;\n\tfor(i=1;i<=n;i++){\n\t\tt1=read();t2=read();t3=read();t4=read();\n\t\tc0[i]=id(t1,t2,t3,t4);\n\t\tc1[i]=id(t2,t3,t4,t1);\n\t\tc2[i]=id(t3,t4,t1,t2);\n\t\tc3[i]=id(t4,t1,t2,t3);\n\t\tHASH::insert(c0[i],1);\n\t\tHASH::insert(c1[i],1);\n\t\tHASH::insert(c2[i],1);\n\t\tHASH::insert(c3[i],1);\n\t}\n\tfor(i=1;i<n;i++){\n\t\tHASH::insert(c0[i],-1);\n\t\tHASH::insert(c1[i],-1);\n\t\tHASH::insert(c2[i],-1);\n\t\tHASH::insert(c3[i],-1);\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tHASH::insert(c0[j],-1);\n\t\t\tHASH::insert(c1[j],-1);\n\t\t\tHASH::insert(c2[j],-1);\n\t\t\tHASH::insert(c3[j],-1);\n//\t\t\tcout<<\"do \"<<i<<' '<<j<<' '<<ans<<'\\n';\n//\t\t\t**********************************************************************0 degree rotation\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get2(c0[j]),get1(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_0_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get2(c3[j]),get1(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_0_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get2(c2[j]),get1(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_0_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get2(c1[j]),get1(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n//\t\t\tif(!val) goto jump_0_4;\n//\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n//\t\t\tchange(t4,1);\n//\t\t\tjump_0_4:\n\t\t\t//back face 3\n\t\t\tchange(t3,1);\n\t\t\tjump_0_3:\n\t\t\t//back face 2\n\t\t\tchange(t2,1);\n\t\t\tjump_0_2:\n\t\t\t//back face 1\n\t\t\tchange(t1,1);\n\t\t\tjump_0_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 0 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t**********************************************************************90 degree rotation counter-clockwise\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get3(c0[j]),get2(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_90_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get3(c3[j]),get2(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_90_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get3(c2[j]),get2(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_90_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get3(c1[j]),get2(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n//\t\t\tif(!val) goto jump_90_4;\n//\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n//\t\t\tchange(t4,1);\n//\t\t\tjump_90_4:\n\t\t\t//back face 3\n\t\t\tchange(t3,1);\n\t\t\tjump_90_3:\n\t\t\t//back face 2\n\t\t\tchange(t2,1);\n\t\t\tjump_90_2:\n\t\t\t//back face 1\n\t\t\tchange(t1,1);\n\t\t\tjump_90_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 90 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t**********************************************************************180 degree rotation counter-clockwise\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get4(c0[j]),get3(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_180_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get4(c3[j]),get3(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_180_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get4(c2[j]),get3(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_180_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get4(c1[j]),get3(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n//\t\t\tif(!val) goto jump_180_4;\n//\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n//\t\t\tchange(t4,1);\n//\t\t\tjump_180_4:\n\t\t\t//back face 3\n\t\t\tchange(t3,1);\n\t\t\tjump_180_3:\n\t\t\t//back face 2\n\t\t\tchange(t2,1);\n\t\t\tjump_180_2:\n\t\t\t//back face 1\n\t\t\tchange(t1,1);\n\t\t\tjump_180_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 180 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t**********************************************************************270 degree rotation counter-clockwise\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get1(c0[j]),get4(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_270_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get1(c3[j]),get4(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_270_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get1(c2[j]),get4(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_270_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get1(c1[j]),get4(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n//\t\t\tif(!val) goto jump_270_4;\n//\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n//\t\t\tchange(t4,1);\n//\t\t\tjump_270_4:\n\t\t\t//back face 3\n\t\t\tchange(t3,1);\n\t\t\tjump_270_3:\n\t\t\t//back face 2\n\t\t\tchange(t2,1);\n\t\t\tjump_270_2:\n\t\t\t//back face 1\n\t\t\tchange(t1,1);\n\t\t\tjump_270_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 270 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t******************************back j\n\t\t\tHASH::insert(c0[j],1);\n\t\t\tHASH::insert(c1[j],1);\n\t\t\tHASH::insert(c2[j],1);\n\t\t\tHASH::insert(c3[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define ppp pair<pii,pii>\n\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:2\n*Problem:E - AtCoDeerくんと立方体づくり / Building Cubes with AtCoDeer\n*Date:2018-10-21\n*Algorithm:My Brute Force\n*Stats:Unknown*/\n\nbool debug=false;\n\nint n;\nppp a[405];\nll ans;\nvector<ppp> has;\nmap<ppp,int> cnt;\n\ninline ppp bp(int a,int b,int c,int d){\n\treturn make_pair(make_pair(a,b),make_pair(c,d));\n}\n\nvoid Ins(int xa,int xb,int xc,int xd){\n\tcnt[bp(xa,xb,xc,xd)]++;\n\tcnt[bp(xb,xc,xd,xa)]++;\n\tcnt[bp(xc,xd,xa,xb)]++;\n\tcnt[bp(xd,xa,xb,xc)]++;\n}\n\nint cntsame(ppp a,ppp b){\n\tint ba=b.first.first,bb=b.first.second,bc=b.second.first,bd=b.second.second;\n\tint ret=0;\n\tif(a==bp(ba,bb,bc,bd)) ret++;\n\tif(a==bp(bb,bc,bd,ba)) ret++;\n\tif(a==bp(bc,bd,ba,bb)) ret++;\n\tif(a==bp(bd,ba,bb,bc)) ret++;\n\treturn ret;\n}\n\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint x1,x2,x3,x4;\n\t\tcin>>x1>>x2>>x3>>x4;\n\t\ta[i]=bp(x1,x2,x3,x4);\n\t}\n\t\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=0;j<has.size();j++){\n\t\t\tppp ano=has[j];\n\t\t\t\n\t\t\tint ca=ano.first.first,cb=ano.first.second,cc=ano.second.first,cd=ano.second.second;\n\t\t\t\n\t\t\tppp b1=bp(a[i].first.first,a[i].first.second,cb,ca);\n\t\t\tppp b2=bp(a[i].first.second,a[i].second.first,cc,cb);\n\t\t\tppp b3=bp(a[i].second.first,a[i].second.second,cd,cc);\n\t\t\tppp b4=bp(a[i].second.second,a[i].first.first,ca,cd);\n\t\t\t\n\t\t\tll ret=1;\n\t\t\tret*=cnt[b1]-cntsame(ano,b1);\n\t\t\tret*=cnt[b2]-cntsame(b1,b2)-cntsame(ano,b2);\n\t\t\tret*=cnt[b3]-cntsame(b1,b3)-cntsame(b2,b3)-cntsame(ano,b3);\n\t\t\tret*=cnt[b4]-cntsame(b1,b4)-cntsame(b2,b4)-cntsame(b3,b4)-cntsame(ano,b4);\n\t\t\t\n\t\t\tans+=ret;\n\t\t}\n\t\t\n\t\tint xa=a[i].first.first,xb=a[i].second.second,xc=a[i].second.first,xd=a[i].first.second;\n\t\t\n\t\tIns(xa,xb,xc,xd);\n\t\thas.push_back(bp(xa,xb,xc,xd));\n\t\thas.push_back(bp(xb,xc,xd,xa));\n\t\thas.push_back(bp(xc,xd,xa,xb));\n\t\thas.push_back(bp(xd,xa,xb,xc));\n\t\t\n\t}\n\t\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,ll> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,ll delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)%4]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid permutar(vi &nuevo)\n{\n    vper.clear();\n    forr(i,0,4)\n    vper.pb(move(nuevo,i));\n\n}\nvoid add(vi &nuevo,ll delta,map<iiii,ll> &mapa)\n{\n    permutar(nuevo);\n    forr(i,0,vper.size())\n    {\n        mapa[vper[i]]+=delta;\n    }\n}\nvector<iiii> vcaras;\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n        vcaras.clear();\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   ll n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   permutar(V[2]);\n   map<iiii,ll> extra;\n   ll totp,answer=0,auxtotp;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,0,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    fiiv(cara2,move(V[j],kj));\n                    /*<<\"comenzamos\\n\";\n                    prll(cara1);\n                    prll(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prll(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxtotp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxtotp);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //<<answer<<endl;\n   cout<<answer/24<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<int> rot(4);\n    vector<vector<int>> surface(4,vector<int>(4));\n    vector<vector<ll>> dp(N+1,vector<ll>(16));\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                    if (surface[q][0]==surface[q][1]\n                        &&surface[q][1]==surface[q][2]\n                        &&surface[q][2]==surface[q][3]\n                        &&surface[q][3]==surface[q][0]) rot[q]=4;\n                    else if (surface[q][0]==surface[q][2]\n                            &&surface[q][1]==surface[q][3]) rot[q]=2;\n                    else rot[q]=1;\n                }\n                for (int k=i+1;k<=N;++k){\n                    for (int l=0;l<16;++l){\n                        dp[k][l]=0;\n                    }\n                }\n                dp[i+1][0]=1;\n                for (int k=i+1;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]+=dp[k][l];\n                    if (k==i||k==j) continue;\n                    for (int l=0;l<4;++l){\n                        bool flag=false;\n                        for (int m=0;m<4;++m){\n                            bool smallflag=true;\n                            for (int n=0;n<4;++n){\n                                if (surface[l][n]!=C[k][(m+n)%4]){\n                                    smallflag=false;\n                                }\n                            }\n                            flag|=smallflag;\n                        }\n                        if (flag){\n                            for (int mask=15;mask>=0;--mask){\n                                if (!(mask&1<<l)){\n                                    dp[k+1][mask|1<<l]+=dp[k][mask]*rot[l];\n                                }\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\npa4 rot(pa4 z){\n\treturn {z.w,z.x,z.y,z.z};\n}\nint hen(pa4 z){\n\treturn z.x+1000*z.y+1000000*z.z+1000000000*z.w;\n}\npa4 iro[400][4];\nint num[400][4];\nmap<int,int> ma[400]; \n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n  \tcin>>n;\n  \t\n  \tfor(int i=0;i<n;i++){\n  \t\tint y1,y2,y3,y4;\n  \t\tcin>>y1>>y2>>y3>>y4;\n  \t\tiro[i][0]={y1,y2,y3,y4};\n  \t\tfor(int j=1;j<4;j++)iro[i][j]=rot(iro[i][j-1]);\n  \t\tfor(int j=0;j<4;j++){\n  \t\t\tnum[i][j]=hen(iro[i][j]);\n  \t\t\tma[i][num[i][j]]++;\n  \t//\t\tcout<<i<<\" \"<<j<<\"   \"<<num[i][j]<<endl;\n  \t\t}\n  \t}\n  \t\n  \tint ans=0;\n  \tfor(int s=0;s<n;s++)for(int t=0;t<n;t++)if(s!=t)for(int l=0;l<4;l++)for(int r=0;r<4;r++){\n  \t\t\n  \t\tint e[4];\n  \t\te[0]=hen({iro[s][l].x,iro[s][l].w,iro[t][r].x,iro[t][r].w});\n  \t\te[1]=hen({iro[s][l].w,iro[s][l].z,iro[t][r].y,iro[t][r].x});\n  \t\te[2]=hen({iro[s][l].z,iro[s][l].y,iro[t][r].z,iro[t][r].y});\n  \t\te[3]=hen({iro[s][l].y,iro[s][l].x,iro[t][r].w,iro[t][r].z});\n  \t\tint kosuu=0;\n  \t\t//vector<int> ve[4];\n  \t\tint rui[16]={0};\n  \t\tfor(int i=0;i<n;i++)if(i!=s&& i!=t){\n  \t\t\tint g[4]={0};\n  \t\t\tfor(int w=0;w<4;w++){\n  \t\t\t\tif(ma[i].count(e[w]))g[w]=ma[i][e[w]];\n  \t\t\t}\n  \t\t//\tfor(int w=0;w<4;w++)cout<<g[w];\n  \t\t//\tcout<<endl;\n  \t\t\tif(g[0]+g[1]+g[2]+g[3]==0) continue;\n  \t\t\tkosuu++;\n  \t\t\trui[15]+=g[0]*g[1]*g[2]*g[3];\n  \t\t\trui[1]+=g[0];\n  \t\t\trui[2]+=g[1];\n  \t\t\trui[4]+=g[2];\n  \t\t\trui[8]+=g[3];\n  \t\t\t\n  \t\t\trui[3]+=g[0]*g[1];\n  \t\t\trui[5]+=g[0]*g[2];\n  \t\t\trui[9]+=g[0]*g[3];\n  \t\t\trui[6]+=g[1]*g[2];\n  \t\t\trui[10]+=g[1]*g[3];\n  \t\t\trui[12]+=g[2]*g[3];\n  \t\t\t\n  \t\t\trui[14]+=g[1]*g[2]*g[3];\n  \t\t\trui[13]+=g[0]*g[2]*g[3];\n  \t\t\trui[11]+=g[0]*g[1]*g[3];\n  \t\t\trui[7]+=g[0]*g[1]*g[2];\n  \t\t\t\n  \t\t\t\n  \t\t\t\n  \t\t}\n  \t//\tif(kosuu)cout<<kosuu<<endl;\n  \t\tif(kosuu<4) continue;\n  \t\t\n  \t\t\n  \t\tint p_0123=rui[15];\n  \t\t\n  \t\tint p_01_23=rui[3]*rui[12]-p_0123;\n  \t\tint p_02_13=rui[5]*rui[10]-p_0123;\n  \t\tint p_03_12=rui[9]*rui[6]-p_0123;\n  \t\t\n  \t\tint p_0_123=rui[1]*rui[14]-p_0123;\n  \t\tint p_1_023=rui[2]*rui[13]-p_0123;\n  \t\tint p_2_013=rui[4]*rui[11]-p_0123;\n  \t\tint p_3_012=rui[8]*rui[7]-p_0123;\n  \t\t\n  \t\tint p_01_2_3=rui[3]*rui[4]*rui[8]-p_3_012-p_2_013-p_01_23-p_0123;\n  \t\tint p_02_1_3=rui[5]*rui[2]*rui[8]-p_3_012-p_1_023-p_02_13-p_0123;\n  \t\tint p_03_1_2=rui[9]*rui[2]*rui[4]-p_1_023-p_2_013-p_03_12-p_0123;\n  \t\tint p_12_0_3=rui[6]*rui[1]*rui[8]-p_3_012-p_0_123-p_03_12-p_0123;\n  \t\tint p_13_0_2=rui[10]*rui[1]*rui[4]-p_0_123-p_2_013-p_02_13-p_0123;\n  \t\tint p_23_0_1=rui[12]*rui[1]*rui[2]-p_0_123-p_1_023-p_01_23-p_0123;\n  \t\t\n  \t\tint wa=p_0123+p_01_23+p_02_13+p_03_12+p_0_123+p_1_023+p_2_013+p_3_012;\n  \t\twa+=p_01_2_3+p_02_1_3+p_03_1_2+p_12_0_3+p_13_0_2+p_23_0_1;\n  \t\t\n  \t\tint p_0_1_2_3=rui[1]*rui[2]*rui[4]*rui[8];\n  \t//\tcout<<p_0_1_2_3<<endl;\n  \t\tp_0_1_2_3-=wa;\n  \t//\tcout<<p_0_1_2_3<<endl;\n  \t\tans+=p_0_1_2_3;\n  \t\t\n  \t}\n  \t\n  \tcout<<ans/24<<endl;\n  \t\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n,a[405][4],tot[405];\nll h[405][4],hh[405];\nmap<ll,ll> f[5];\nint id[4][4]={{1,0,1,0},{3,2,3,2},{2,1,0,3},{0,3,2,1}};\nint main(){\n\tconst ll inf=ll(1e15);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int p=0;p<4;p++) scanf(\"%d\",&a[i][p]);\n\tfor(int i=1;i<=n;i++){\n\t\tll mn=inf;int sum=0;\n\t\tfor(int p=0;p<4;p++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint x=(p+j)&3;\n\t\t\t\th[i][p]=h[i][p]*1000+a[i][x];\n\t\t\t}\n\t\t\tif(h[i][p]<mn) mn=h[i][p],sum=0;\n\t\t\tif(h[i][p]==mn) sum++;\n\t\t}\n\t\tif(f[0].find(mn)==f[0].end()){\n\t\t\tfor(int p=1;p<=4;p++) f[p][mn]=0;\n\t\t\tf[0][mn]=1;\n\t\t}\n\t\thh[i]=mn;tot[i]=sum;\n\t\tfor(int p=4;p;p--){\n\t\t\tf[p][mn]+=f[p-1][mn]*sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=4;j++) f[j][hh[i]]-=f[j-1][hh[i]]*tot[i];\n\t\tfor(int p=i+1;p<=n;p++){\n\t\t\tfor(int j=1;j<=4;j++) f[j][hh[p]]-=f[j-1][hh[p]]*tot[p];\n\t\t\tfor(int ww=0;ww<4;ww++){\n\t\t\t\tint b[4],c[4];\n\t\t\t\tfor(int k=0;k<4;k++) b[k]=a[p][(k+ww)&3];\n\t\t\t\tll mn[4]={inf,inf,inf,inf};\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tfor(int w=0;w<2;w++) c[w]=a[i][id[j][w]];\n\t\t\t\t\tfor(int w=2;w<4;w++) c[w]=b[id[j][w]];\n\t\t\t\t\tfor(int w=0;w<4;w++){\n\t\t\t\t\t\tll H=0;\n\t\t\t\t\t\tfor(int o=0;o<4;o++) H=H*1000+c[(o+w)&3];\n\t\t\t\t\t\tmn[j]=min(mn[j],H);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tsort(mn,mn+4);\n\t\t\t\tll sum=1;\n\t\t\t\tfor(int j=0;j<4;){\n\t\t\t\t\tint o;\n\t\t\t\t\tfor(o=j;o<4&&mn[o]==mn[j];o++) sum*=(o-j+1);\n\t\t\t\t\tif(f[o-j].find(mn[j])==f[o-j].end()){\n\t\t\t\t\t\tsum=0;break;\n\t\t\t\t\t}\n\t\t\t\t\tsum*=f[o-j][mn[j]];\n\t\t\t\t\tj=o;\n\t\t\t\t}\n\t\t\t\tans+=sum;\n\t\t\t}\n\t\t\tfor(int j=4;j;j--) f[j][hh[p]]+=f[j-1][hh[p]]*tot[p];\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint const N = 1234;\n \nlong long f[N];\nint c[N][4];\nlong long dp[42];\nint can[42];\nlong long cr[N][4];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", c[i] + j);\n    }\n    for (int rot = 0; rot < 4; rot++) {\n      long long z = 0;\n      for (int e = 0; e < 4; e++) {\n        z = z * 1000 + c[i][(e + rot) & 3];\n      }\n      cr[i][rot] = z;\n    }\n  }\n  long long ans = 0;\n  for (int first = 0; first < n; first++) {\n    for (int back = first + 1; back < n; back++) {\n      for (int rb = 0; rb < 4; rb++) {\n        for (int i = 0; i < 4; i++) {\n          f[i] = c[first][(i + 1) & 3];\n          f[i] = f[i] * 1000 + c[first][i];\n          f[i] = f[i] * 1000 + c[back][(-i + rb + 1) & 3];\n          f[i] = f[i] * 1000 + c[back][(-i + rb) & 3];\n        }\n        for (int i = 0; i < 1 << 4; i++) dp[i] = 0;\n        dp[0] = 1;\n        for (int i = first + 1; i < n; i++) {\n          if (i == back) continue;\n          for (int j = 0; j < 4; j++) {\n            can[j] = 0;\n            for (int rot = 0; rot < 4; rot++) {\n              if (f[j] == cr[i][rot]) {\n                ++can[j];\n              }\n            }\n          }\n          \n          dp[15] += dp[14] * can[0];\n          dp[15] += dp[13] * can[1];\n          dp[15] += dp[11] * can[2];\n          dp[15] += dp[7] * can[3];\n          dp[14] += dp[12] * can[1];\n          dp[14] += dp[10] * can[2];\n          dp[14] += dp[6] * can[3];\n          dp[13] += dp[12] * can[0];\n          dp[13] += dp[9] * can[2];\n          dp[13] += dp[5] * can[3];\n          dp[12] += dp[8] * can[2];\n          dp[12] += dp[4] * can[3];\n          dp[11] += dp[10] * can[0];\n          dp[11] += dp[9] * can[1];\n          dp[11] += dp[3] * can[3];\n          dp[10] += dp[8] * can[1];\n          dp[10] += dp[2] * can[3];\n          dp[9] += dp[8] * can[0];\n          dp[9] += dp[1] * can[3];\n          dp[8] += dp[0] * can[3];\n          dp[7] += dp[6] * can[0];\n          dp[7] += dp[5] * can[1];\n          dp[7] += dp[3] * can[2];\n          dp[6] += dp[4] * can[1];\n          dp[6] += dp[2] * can[2];\n          dp[5] += dp[4] * can[0];\n          dp[5] += dp[1] * can[2];\n          dp[4] += dp[0] * can[2];\n          dp[3] += dp[2] * can[0];\n          dp[3] += dp[1] * can[1];\n          dp[2] += dp[0] * can[1];\n          dp[1] += dp[0] * can[0];\n        }\n        ans += dp[15];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nusing face = array<int, 4>;\nlint ans = 0;\nmap<face, lint> mp;\n\nface rot(face f){\n    face g;\n    rep(i, 4) g[i] = f[(i+1)%4];\n    return g;\n}\n\nvoid add(face f){\n    rep(_, 4){\n        ++mp[f];\n        f = rot(f);\n    }\n}\n\nvoid del(face f){\n    rep(_, 4){\n        --mp[f];\n        f = rot(f);\n    }\n}\n\nvoid dfs(int cur, array<face, 4> &a, lint tmp){\n    if(cur == 4){\n        ans += tmp;\n        return;\n    }\n    if(mp.find(a[cur]) == mp.end()) return;\n    tmp *= mp[a[cur]];\n    del(a[cur]);\n    dfs(cur+1, a, tmp);\n    add(a[cur]);\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    face fs[n];\n    rep(i, n){\n        rep(j, 4) scanf(\"%d\", &fs[i][j]);\n        add(fs[i]);\n    }\n    rep(i, n)For(j, i+1, n){\n        auto f = fs[i], g = fs[j];\n        del(f); del(g);\n        rep(_, 4){\n            array<face, 4> a;\n            rep(i, 4) a[i] = {f[i], g[(4-i)%4], g[(7-i)%4], f[(i+1)%4]};\n            dfs(0, a, 1);\n            g = rot(g);\n        }\n        add(f); add(g);\n    }\n    printf(\"%lld\\n\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n#include<iomanip>\n#include<stack>\nusing namespace std;\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nlong long READ(){\n    long long xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nchar one(){\n\tchar ch=getchar();\n\twhile(ch==' '||ch=='\\n')\n\t\tch=getchar();\n\treturn ch;\n}\nconst int maxn=410;\nint N;\nstruct sqr{\n\tint a[4];\n\tsqr(int q=0,int w=0,int e=0,int r=0){\n\t\ta[0]=q,a[1]=w,a[2]=e,a[3]=r;\n\t}\n\tvoid rotate(){\n\t\tint t=a[0];\n\t\tfor(int i=0;i<3;i++)\n\t\t\ta[i]=a[i+1];\n\t\ta[3]=t;\n\t}\n\tbool friend operator<(const sqr&A,const sqr&B){\n\t\tfor(int i=0;i<4;i++)\n\t\t\tif(A.a[i]<B.a[i])\n\t\t\t\treturn 1;\n\t\t\telse if(A.a[i]>B.a[i])\n\t\t\t\treturn 0;\n\t\treturn 0;\n\t}\n}s[maxn];\nmap<sqr,int>mp;\ninline void add(sqr A,int v){\n\tfor(int i=0;i<4;i++){\n\t\tmp[A]+=v;\n\t\tA.rotate();\n\t}\n}\nint main(){\n\t//freopen(\"in\",\"r\",stdin);\n\tN=read();\n\tfor(int i=1;i<=N;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\ts[i].a[j]=read();\n\t\tadd(s[i],1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=N;i++){\n\t\tadd(s[i],-1);\n\t\tfor(int j=i+1;j<=N;j++){\n\t\t\tadd(s[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tlong long now=1;\n\t\t\t\tsqr tmp1(s[j].a[1],s[i].a[0],s[i].a[3],s[j].a[2]);\n\t\t\t\tsqr tmp2(s[i].a[1],s[j].a[0],s[j].a[3],s[i].a[2]);\n\t\t\t\tsqr tmp3(s[j].a[1],s[j].a[0],s[i].a[1],s[i].a[0]);\n\t\t\t\tsqr tmp4(s[i].a[3],s[i].a[2],s[j].a[3],s[j].a[2]);\n\t\t\t\t\n\t\t\t\ts[j].rotate();\n\t\t\t\t\n\t\t\t\tif(!(mp[tmp1]&&mp[tmp2]&&mp[tmp3]&&mp[tmp4]))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tnow*=mp[tmp1];add(tmp1,-1);\n\t\t\t\tnow*=mp[tmp2];add(tmp2,-1);\n\t\t\t\tnow*=mp[tmp3];add(tmp3,-1);\n\t\t\t\tnow*=mp[tmp4];add(tmp4,-1);\n\t\t\t\t\n\t\t\t\tadd(tmp1,1);\n\t\t\t\tadd(tmp2,1);\n\t\t\t\tadd(tmp3,1);\n\t\t\t\tadd(tmp4,1);\n\t\t\t\t\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t\tadd(s[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n\n#ifdef LOCAL\n#define DEBUGMSG()                                                              \\\n{                                                                               \\\n    cerr << \"[调试 @\" << __PRETTY_FUNCTION__ << \":\" << __LINE__ << \"]\" ;        \\\n}\n#define DEBUGVAR(x)                                                             \\\n{                                                                               \\\n    cerr << \"[调试 @\" << __PRETTY_FUNCTION__ << \":\" << __LINE__ << \"]:\" ;       \\\n    cerr << \"([\" << typeid(x).name() << \"]\" << #x << \")\" << x << endl ;         \\\n}\n#define DEBUGARR(l, r)                                                          \\\n{                                                                               \\\n    cerr << \"[调试 @\" << __PRETTY_FUNCTION__ << \":\" << __LINE__ << \"]:\" ;       \\\n    copy(l, r, ostream_iterator<decltype(*l)>(cerr, \" \"));                      \\\n    cerr << endl ;                                                              \\\n}\n#else\n#define DEBUGMSG()\n#define DEBUGVAR(x)\n#define DEBUGARR(l, r)\n#endif // LOCAL\n\n#define getBit(x) (col##x << (10 * (4-x)))\n\nusing i64 = long long;\n\nconst int MAXN = 500 ;\n\nint N;\ni64 COL[MAXN][8], tmp[4], ans;\nmap <i64, i64> mp;\n\ni64 getHash(i64 col1, i64 col2, i64 col3, i64 col4)\n{\n    return getBit(1) | getBit(2) | getBit(3) | getBit(4);\n}\n\nvoid ModifyMap(i64 h, i64 delta)\n{\n    // Rotation\n    for(int i = 0; i < 4; i++)\n    {\n        mp[h] += delta;\n        //DEBUGVAR(h);\n        h = (h >> 10) | ((h & 0x3FF) << 30);\n    }\n\n}\n\n\n\nint main()\n{\n    cin >> N ;\n\n    for(int i = 0; i < N; i++)\n    {\n        for(int c = 0; c < 4; c++)\n            cin >> COL[i][c],\n            COL[i][c+4] = COL[i][c];\n        ModifyMap(getHash(COL[i][0], COL[i][1], COL[i][2], COL[i][3]), 1);\n    }\n\n    for(int i = 0; i < N; i++)\n    {\n        ModifyMap(getHash(COL[i][0], COL[i][1], COL[i][2], COL[i][3]), -1);\n        for(int j = i+1; j < N; j++)\n        {\n            ModifyMap(getHash(COL[j][0], COL[j][1], COL[j][2], COL[j][3]), -1);\n            for(int k = 0; k < 4; k++)\n            {\n                i64 tmpans = 1;\n                tmp[0] = getHash(COL[j][k+1], COL[j][k+0], COL[i][1], COL[i][0]);\n                tmp[1] = getHash(COL[j][k+0], COL[j][k+3], COL[i][2], COL[i][1]);\n                tmp[2] = getHash(COL[j][k+3], COL[j][k+2], COL[i][3], COL[i][2]);\n                tmp[3] = getHash(COL[j][k+2], COL[j][k+1], COL[i][4], COL[i][3]);\n\n                for(int c = 0; c < 4; c++)\n                    if(mp[tmp[c]] == 0)\n                        goto JMP;\n\n                //DEBUGVAR(i);\n                //DEBUGVAR(j);\n                //DEBUGVAR(k);\n\n                for(int c = 0; c < 4; c++)\n                    tmpans *= mp[tmp[c]],\n                    ModifyMap(tmp[c], -1);\n\n                for(int c = 0; c < 4; c++)\n                    ModifyMap(tmp[c], 1);\n                ans += tmpans;\n\n                JMP:\n                    ;\n            }\n\n        }\n    }\n\n    cout << ans << endl ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef pair<ll,pi> pii;\ntypedef vector<pi> vpi;\ntypedef set<ll> si;\ntypedef long double ld;\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\nll INF = 1e9;\nll MOD = 1e9;\n#define lb lower_bound\n#define ub upper_bound\n#define SZ(x) (ll)x.size()\n#define ALL(x) x.begin(),x.end()\n#define count(V,x) ub(ALL(V),x,cmp) - lb(ALL(V),x,cmp)\n\nstruct cube{\n  ll a, b, c, d, orien;\n  cube(ll _a, ll _b, ll _c, ll _d): a(_a), b(_b), c(_c), d(_d), orien(1){\n    ll m = min({a,b,c,d});\n    if (a == b && a == c && a == d)orien = 4;\n    else if (a == c && b == d)orien = 2;\n  }\n\n  bool fit(cube cmp){\n    return a == cmp.a && b == cmp.b && c == cmp.c && d == cmp.d;\n  }\n\n  cube rotate(){\n    return cube({b,c,d,a});\n  }\n\n  void pp(){\n    cout<<a<<' '<<b<<' '<<c<<' '<<d<<'\\n';\n  }\n};\n\nbool cmp(cube a, cube b){\n  if (a.a != b.a)return a.a < b.a;\n  if (a.b != b.b)return a.b < b.b;\n  if (a.c != b.c)return a.c < b.c;\n  return a.d < b.d;\n}\n\nbool biggay = 0;\n\ncube bal(cube t){\n  cube q = t.rotate();\n  cube r = q.rotate();\n  cube u = r.rotate();\n  if (cmp(q, t))t = q;\n  if (cmp(r, t))t = r;\n  if (cmp(u, t))t = u;\n  return t;\n}\n\nll N;\nll a,b,c,d;\nvector<cube> V,faces,comp;\nvi rep;\n\nint main(){\n  // freopen(\"in.txt\",\"r\",stdin);\n  cin >> N;\n  for (int i=0;i<N;++i){\n    cin >>a >> b >> c >> d;\n    V.pb({a,b,c,d});\n    V[i] = bal(V[i]);\n  }\n  sort(ALL(V), cmp);\n\n  ll ans=0;\n  for (int i=0;i<N-1;++i){\n    // Base\n    // if (i != 0)continue;\n    for (int j=i+1;j<N;++j){\n      // if (j != 5)continue;\n      cube top = V[i];\n      cube btm = V[j];\n      for (int k=0;k<4;++k){\n        ll r = 1;\n\n        faces.pb(bal(cube(top.d,top.c,btm.c,btm.b)));\n        faces.pb(bal(cube(top.c,top.b,btm.d,btm.c)));\n        faces.pb(bal(cube(top.b,top.a,btm.a,btm.d)));\n        faces.pb(bal(cube(top.a,top.d,btm.b,btm.a)));\n\n        sort(ALL(faces), cmp);\n\n        r *= faces[0].orien;\n        r *= faces[1].orien;\n        r *= faces[2].orien;\n        r *= faces[3].orien;\n        \n        comp.pb(faces[0]);\n        rep.pb(1);\n\n        if (comp.back().fit(faces[1])){\n          ++rep.back();\n        }else{\n          comp.pb(faces[1]);\n          rep.pb(1);\n        }\n        if (comp.back().fit(faces[2])){\n          ++rep.back();\n        }else{\n          comp.pb(faces[2]);\n          rep.pb(1);\n        }\n        if (comp.back().fit(faces[3])){\n          ++rep.back();\n        }else{\n          comp.pb(faces[3]);\n          rep.pb(1);\n        }\n\n        for (int k=0;k<SZ(comp); ++k){\n          cube it = comp[k];\n          int cnt = count(V, it);\n          if (V[i].fit(it))--cnt;\n          if (V[j].fit(it))--cnt;\n          while(rep[k]){\n            --rep[k];\n            r *= cnt;\n            cnt--;\n          }\n        }\n        ans += r;\n        top = top.rotate();\n        rep.clear();\n        faces.clear();\n        comp.clear();\n      }\n    }\n  }\n  cout<<ans/3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n\nusing namespace std;\ntypedef long long ll;\n//____________________________________________\n//____________________________________________\n//__________________OOOOOOOOOOOOOOOO__________\n//_________________OO_____________OO__________\n//________________O_O____________O_O__________\n//_______________O__O___________O__O__________\n//______________O___O__________O___O__________\n//_____________O____O_________O____O__________\n//____________OOOOOOOOOOOOOOOO_____O__________\n//____________O_____O________O_____O__________\n//____________O_____OOOOOOOOOOOOOOOO__________\n//____________O____O_________O____O___________\n//____________O___O__________O___O____________\n//____________O__O___________O__O_____________\n//____________O_O____________O_O______________\n//____________OO_____________OO_______________\n//____________OOOOOOOOOOOOOOOO________________\n//____________________________________________\n//____________________________________________\n\nconst long long MOD = 1e9 + 7;\nll n;\nll c[500][4];\nll ans;\nmap<vector<int>, int> g;\nmap<vector<int>, int> cubes;\n\nvector<int> reform(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 4; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 4; j++)\n        {\n            x.push_back(c[(i + j) % 4]);\n        }\n        cc.push_back(x);\n    }\n    sort(cc.begin(), cc.end());\n    return *min_element(cc.begin(), cc.end());\n}\n\nvector<int> cube(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 8; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 8; j++)\n        {\n            x.push_back(c[(i + j) % 8]);\n        }\n        cc.push_back(x);\n    }\n    return *min_element(cc.begin(), cc.end());\n}\n\nll cnk(ll k, ll n)\n{\n    if (k > n)\n        return 0;\n    if (k == 0)\n        return 1;\n    if (k == 1)\n        return n;\n    if (k == 2)\n        return n * (n - 1) / 2;\n    if (k == 3)\n        return n * (n - 1) * (n - 2) / 6;\n    if (k == 4)\n        return n * (n - 1) * (n - 2) * (n - 3) / 24;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            for (int o1 = 0; o1 < 4; o1++)\n            {\n                //     c[j][1] ---- c[j][0]\n                //       /|            /|\n                //      / |           / |\n                //     /  c[j][2]    /  c[j][3]\n                // c[i][o1] ---- c[i][o1 + 1]\n                //    | /            |\n                //    |/             |\n                // c[i][o1 + 3] ---- c[i][o1 + 2]\n                int ful = c[i][o1];\n                int fur = c[i][(o1 + 1) % 4];\n                int fdl = c[i][(o1 + 3) % 4];\n                int fdr = c[i][(o1 + 2) % 4];\n\n                int bul = c[j][1];\n                int bur = c[j][0];\n                int bdl = c[j][2];\n                int bdr = c[j][3];\n\n                //vector<int> cuber = cube({ful, fur, fdr, fdl, bdl, bdr, bur, bul});\n                //if (cubes[cuber] == 1)\n                //    continue;\n                //cubes[cuber] = 1;\n\n                vector<int> l = {ful, fdl, bdl, bul};\n                vector<int> u = {fur, ful, bul, bur};\n                vector<int> r = {fur, bur, bdr, fdr};\n                vector<int> d = {fdl, fdr, bdr, bdl};\n\n                ll swappers = 1;\n\n                ll y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (l[y] != l[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (d[y] != d[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (u[y] != u[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (r[y] != r[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                r = reform(r);\n                l = reform(l);\n                u = reform(u);\n                d = reform(d);\n\n                map<vector<int>, int> gg2;\n                gg2[r]++;\n                gg2[l]++;\n                gg2[u]++;\n                gg2[d]++;\n\n                for (auto it : gg2)\n                {\n                    swappers *= cnk(it.second, g[it.first]);\n                }\n\n                //cout << i << \" \" << j << \" \" << swappers << endl;\n\n                ans += swappers;\n            }\n        }\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]--;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint vtoi(int a, int b, int c, int d){\n    return a + 1000 * b + 1000000 * c + 1000000000 * d;\n}\nint vtoi(vec v){\n    return vtoi(v[0], v[1], v[2], v[3]);\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    mat C(N, vec(4));\n    vector<mat> C2(N, mat(4, vec(4)));\n    map<int, int> m;\n    REP(i, N){\n        readv(C[i]);\n        REP(r, 4){\n            REP(j, 4) C2[i][r][j] = C[i][(j + r) % 4];\n            m[vtoi(C2[i][r])] += 1;\n        }\n    }\n\n    int ans = 0;\n    mat side(4, vec(4));\n    REP(i, N){\n        REP(r, 4) m[vtoi(C2[i][r])] -= 1;\n        FOR(j, i + 1, N){\n            REP(r, 4) m[vtoi(C2[j][r])] -= 1;\n\n            REP(r, 4){\n                int tmp = 1;\n                REP(s, 4){\n                    side[s][0] = C2[i][0][(4 - s) % 4];\n                    side[s][1] = C2[i][0][3 - s];\n                    side[s][2] = C2[j][r][(1 + s) % 4];\n                    side[s][3] = C2[j][r][s];\n                }\n                int s0 = 0;\n                REP(s, 4){\n                    if(m[vtoi(side[s])] > 0){\n                        tmp *= m[vtoi(side[s])];\n                        REP(r2, 4) m[vtoi(side[s][(0 + r2) % 4], side[s][(1 + r2) % 4], side[s][(2 + r2) % 4], side[s][(3 + r2) % 4])] -= 1;\n                        s0++;\n                    }else break;\n                }\n                REP(s, s0) REP(r2, 4) m[vtoi(side[s][(0 + r2) % 4], side[s][(1 + r2) % 4], side[s][(2 + r2) % 4], side[s][(3 + r2) % 4])] += 1;\n                if(s0 == 4) ans += tmp;\n            }\n\n            //cout << i << \",\" << j << \",\" << ans << endl;\n\n            REP(r, 4) m[vtoi(C2[j][r])] += 1;\n        }\n        REP(r, 4) m[vtoi(C2[i][r])] += 1;\n    }\n    cout << ans / 3;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<long,15>,4> >M;\nint a[400],b[400],c[400],d[400];\nmap<long,int>COUNT[400];\nset<long>S;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tlong C=conv(a[i],b[i],c[i],d[i]);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tCOUNT[i][C]++;\n\t\t\tS.insert(C);\n\t\t\tC=rotate(C);\n\t\t}\n\t}\n\tfor(long it:S)\n\t{\n\t\tarray<array<long,15>,4>&A=M[it];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint c=COUNT[i][it];\n\t\t\tsum+=c;\n\t\t\tct[c]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<=j;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tA[0][j*(j+1)/2+k]=sum-j-k;\n\t\t\tA[1][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\tA[2][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\tA[3][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tint a=COUNT[i][t[k]];\n\t\t\t\t\tint b=COUNT[j][t[k]];\n\t\t\t\t\tif(a<b)a^=b^=a^=b;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][a*(a+1)/2+b];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef pair<LD,LD> Pt;\ntypedef tuple<int,int,int> tiii;\ntypedef tuple<LL,LL,LL> tlll;\n#define mod9 1000000009ll\n#define mod7 1000000007ll\n#define INF  1023456789ll\n#define INF16 10000000000000000ll\n#define FI first\n#define SE second\n#define X FI\n#define Y SE\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nLL n , c[ N ][ 4 ];\nvoid build(){\n\n}\nmap< LL , int > cnt;\nmap< pair<LL,LL> , int > cnt2;\nmap< tuple<LL,LL,LL> , int > cnt3;\nmap< tuple<LL,LL,LL,LL> , int > cnt4;\ninline LL CNT( LL x ){\n  auto it = cnt.find( x );\n  return it == cnt.end() ? 0 : it->second;\n}\ninline LL CNT2( pair<LL,LL> x ){\n  auto it = cnt2.find( x );\n  return it == cnt2.end() ? 0 : it->second;\n}\ninline LL CNT3( tuple<LL,LL,LL> x ){\n  auto it = cnt3.find( x );\n  return it == cnt3.end() ? 0 : it->second;\n}\ninline LL CNT4( tuple<LL,LL,LL,LL> x ){\n  auto it = cnt4.find( x );\n  return it == cnt4.end() ? 0 : it->second;\n}\ninline void modify( int id , int dlt ){\n  vector< LL > vv;\n  for( int j = 0 ; j < 4 ; j ++ ){\n    LL ret = 0;\n    for( int k = 0 ; k < 4 ; k ++ )\n      ret = ret * 1000 + c[ id ][ ( j + k ) % 4 ];\n    cnt[ ret ] += dlt;\n    vv.push_back( ret );\n  }\n  for( LL i1 : vv )\n    for( LL i2 : vv ){\n      cnt2[ { i1 , i2 } ] += dlt;\n      for( LL i3 : vv ){\n        cnt3[ make_tuple( i1 , i2 , i3 ) ] += dlt;\n        for( LL i4 : vv )\n          cnt4[ make_tuple( i1 , i2 , i3 , i4 ) ] += dlt;\n      }\n    }\n          \n}\ninline LL zip( LL za , LL zb , LL zc , LL zd ){\n  LL ret = 0;\n  for( LL i : { za , zb , zc , zd } )\n    ret = ret * 1000 + i;\n  return ret;\n}\nvoid init(){\n  scanf( \"%lld\" , &n );\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      scanf( \"%lld\" , &c[ i ][ j ] );\n    modify( i , +1 );\n  }\n}\nvoid solve(){\n  LL ans = 0;\n  for( int i = 0 ; i < n ; i ++ ){\n    modify( i , -1 );\n    for( int j = i + 1 ; j < n ; j ++ ){\n      modify( j , -1 );\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL vv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          vv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , vv[ 1 ] , vv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , vv[ 2 ] , vv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , vv[ 3 ] , vv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , vv[ 0 ] , vv[ 3 ] );\n        // A , B , C , D\n        ans += CNT( f1 ) * CNT( f2 ) * CNT( f3 ) * CNT( f4 );\n        // { A , A } , B , C\n        ans -= CNT2( { f1 , f2 } ) * CNT( f3 ) * CNT( f4 );\n        ans -= CNT2( { f1 , f3 } ) * CNT( f2 ) * CNT( f4 );\n        ans -= CNT2( { f1 , f4 } ) * CNT( f2 ) * CNT( f3 );\n        ans -= CNT2( { f2 , f3 } ) * CNT( f1 ) * CNT( f4 );\n        ans -= CNT2( { f2 , f4 } ) * CNT( f1 ) * CNT( f3 );\n        ans -= CNT2( { f3 , f4 } ) * CNT( f1 ) * CNT( f2 );\n        // { A , A } , { B , B }\n        ans += CNT2( { f1 , f2 } ) * CNT2( { f3 , f4 } );\n        ans += CNT2( { f1 , f3 } ) * CNT2( { f2 , f4 } );\n        ans += CNT2( { f1 , f4 } ) * CNT2( { f2 , f3 } );\n        // { A , A , A } , B\n        ans += 2ll * CNT3( make_tuple( f1 , f2 , f3 ) ) * CNT( f4 );\n        ans += 2ll * CNT3( make_tuple( f1 , f2 , f4 ) ) * CNT( f3 );\n        ans += 2ll * CNT3( make_tuple( f1 , f3 , f4 ) ) * CNT( f2 );\n        ans += 2ll * CNT3( make_tuple( f2 , f3 , f4 ) ) * CNT( f1 );\n        // { A , A , A , A }\n        ans -= 6ll * CNT4( make_tuple( f1 , f2 , f3 , f4 ) );\n      }\n      modify( j , +1 );\n    }\n  }\n  printf( \"%lld\\n\" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int Nmax = 400;\nint N, C[4][Nmax];\n\nlong encode(int c0,int c1,int c2,int c3){\n\tlong base=1000;\n\tlong x = c3+base*c2+base*base*c1+base*base*base*c0;\n\tlong m = x;\n\tfor(int i=0; i<3; i++){\n\t\tx = x/base+(x%base)*base*base*base;\n\t\tm = min(m, x);\n\t}\n\treturn m;\n}\n\nint rot(long code){\n\tint c[4];\n\tint base = 1000;\n\tfor(int i=0; i<4; i++) {\n\t\tc[i] = code%base;\n\t\tcode /= base;\n\t}\n\tif(c[0]==c[1]&&c[1]==c[2]&&c[2]==c[3]) return 4;\n\tif(c[0]==c[2]&&c[1]==c[3]) return 2;\n\treturn 1;\n}\n\nlong pow(long a,long n){\n\tif(n==0) return 1;\n\tif(n%2) return pow(a,n-1)*a;\n\treturn pow(a,n/2);\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> C[j][i];\n\t\t}\n\t}\n\n\tmap<long, vector<int> > e2f;\n\tfor(int i=0; i<N; i++){\n\t\tlong x = encode(C[0][i],C[1][i],C[2][i],C[3][i]);\n\t\te2f[x].push_back(i);\n\t}\n\n\tlong ans = 0;\n\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tlong f[4];\n\t\t\t\tf[0] = encode(C[1][i],C[0][i],C[(k+0)%4][j],C[(k+3)%4][j]);\n\t\t\t\tf[1] = encode(C[2][i],C[1][i],C[(k+3)%4][j],C[(k+2)%4][j]);\n\t\t\t\tf[2] = encode(C[3][i],C[2][i],C[(k+2)%4][j],C[(k+1)%4][j]);\n\t\t\t\tf[3] = encode(C[0][i],C[3][i],C[(k+1)%4][j],C[(k+0)%4][j]);\n\t\t\t\tif(e2f.find(f[0]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[1]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[2]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[3]) == e2f.end()) continue;\n\t\t\t\t/*\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tcout << f[0] << endl;\n\t\t\t\tcout << f[1] << endl;\n\t\t\t\tcout << f[2] << endl;\n\t\t\t\tcout << f[3] << endl;\n\t\t\t\t*/\n\t\t\t\tlong c[4];\n\t\t\t\tlong a=0;\n\t\t\t\tfor(int m=0; m<4; m++){\n\t\t\t\t\tc[m]=0;\n\t\t\t\t\tfor(auto l=e2f[f[m]].begin(); l!=e2f[f[m]].end(); l++){\n\t\t\t\t\t\t//cout << \" \" << *l << endl;\n\t\t\t\t\t\tif(*l<=i || *l==j) continue;\n\t\t\t\t\t\tc[m]++;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << c[m] << \" \";\n\t\t\t\t}\n\t\t\t\tif(f[0]==f[1]&&f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=4){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*(c[0]-3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=2&&c[1]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*(c[1]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[3]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[2]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[2]==f[3]){\n\t\t\t\t\tif(c[2]>=2){\n\t\t\t\t\t\ta = c[2]*(c[2]-1)*c[0]*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[3]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta = c[0]*c[1]*c[2]*c[3];\n\t\t\t\t}\n\t\t\t\tfor(int m=0; m<4; m++) a*=rot(f[m]);\n\t\t\t\t//cout << a << endl;\n\t\t\t\tans += a;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\ntypedef array<int, 4> tile;\n\n//タイルを回転させて、色が辞書順最小になるようにする。\nvoid normalize(tile &t) {\n\ttile rt = t;\n\trep(dir, 4) {\n\t\tt = min(t, rt);\n\t\trotate(begin(rt), begin(rt) + 1, end(rt));\n\t}\n}\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\tvector<tile> c(n);\n\tmap<tile, int> cnt;\n\trep(i, n) {\n\t\trep(j, 4) cin >> c[i][j];\n\t\tnormalize(c[i]);\n\t\tcnt[c[i]]++;//同じ色のタイルを区別しない\n\t}\n\n\tint res = 0;\n\trep(i, n) {//cをソートする必要はない。\n\t\tcnt[c[i]]--;\n\t\tREP(j, i + 1, n) {\n\t\t\tcnt[c[j]]--;\n\t\t\trep(dir, 4) {\n\t\t\t\t//c[i]が上面のタイルで、c[j]が底面のタイルとする。\n\t\t\t\t//t[4]は側面のタイル。\n\t\t\t\t//c[j]を回転させるのは、rep(dir,4)節の最後に行っている。\n\t\t\t\ttile t[4];\n\t\t\t\tt[0] = { c[i][0],c[i][3],c[j][0],c[j][3] };\n\t\t\t\tt[1] = { c[i][3],c[i][2],c[j][1],c[j][0] };\n\t\t\t\tt[2] = { c[i][2],c[i][1],c[j][2],c[j][1] };\n\t\t\t\tt[3] = { c[i][1],c[i][0],c[j][3],c[j][2] };\n\t\t\t\tmap<tile, int> ccnt;\n\t\t\t\tint cur = 1;\n\t\t\t\trep(k, 4) {//側面のタイルそれぞれについて\n\t\t\t\t\tnormalize(t[k]), ccnt[t[k]]++;//正規化してmapに加える\n\t\t\t\t\ttile rt = t[k];\n\t\t\t\t\tint rot = 0;\n\t\t\t\t\trep(dir2, 4) {//t[k]の色が回転して同じになるかを調べる。\n\t\t\t\t\t\tif (rt == t[k]) rot++;\n\t\t\t\t\t\trotate(begin(rt), begin(rt) + 1, end(rt));\n\t\t\t\t\t}\n\t\t\t\t\tcur *= rot;\n\t\t\t\t}\n\t\t\t\tfor (const auto &p : ccnt) {\n\t\t\t\t\t//側面のタイルそれぞれについて、必要枚数を持っているのか調べる。\n\t\t\t\t\t//必要枚数より多く持っているなら、curを増やす。\n\t\t\t\t\tint have = HAS(cnt, p.first) ? cnt[p.first] : 0, need = p.second;\n\t\t\t\t\trep(k, need) cur *= have - k;\n\t\t\t\t}\n\t\t\t\tres += cur;\n\t\t\t\trotate(begin(c[j]), begin(c[j]) + 1, end(c[j]));\n\t\t\t}\n\t\t\tcnt[c[j]]++;\n\t\t}\n\t}\n\tstd::cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma GCC optimize(\"O3\")\n#endif\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=404;\n\ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n\ninline LL norm( LL x ) {\n    return min(x,min(rot(x),min(rot(rot(x)),rot(rot(rot(x))))));\n}\n\ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nint n,a[N][4],rc[16];\nLL b[N],dp[2][16];\n\nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n\n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    int lc[4]={1,1,1,1};\n    REP(i,4) while ( lc[i]<4 && c[i][lc[i]]!=c[i][0] ) lc[i]++;\n    REP(i,4) rc[i]=4/lc[i];\n    REP(i,4) sort(c[i],c[i]+lc[i]);\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    int u=0;\n    REP1(i,ti+1,n) if ( i!=bi ) {\n        REP(j,15) REP(k,4) if ( !bit(j,k) && b[i]==c[k][0] ) {\n            REP(d,4) if ( b[i]==c[k][d] ) dp[u^1][j|(1<<k)]+=dp[u][j];\n        }\n        u^=1;\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[u][15];\n}\n\nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    // n=400;\n    REP1(i,1,n) b[i]=norm(f(a[i][0],a[i][1],a[i][2],a[i][3]));\n    // sort(b+1,b+n+1);\n    // if ( n==400 && a[1][0]==a[1][1] && a[1][0]==a[1][2] && a[1][0]==a[1][3] && b[1]==b[n] ) {\n        // W(\"673205187207168000\");\n        // return 0;\n    // }\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nvint rig(vint v){\n    vector<vint>r(4);\n    rep(i,4){\n        r[i]=v;\n        rotate(r[i].begin(),r[i].begin()+i,r[i].end());\n    }\n    sort(all(r));\n    return r[0];\n}\n\nint en(vint v){\n    int r=0;\n    rep(i,v.size())r=r*1000+v[i];\n    return r;\n}\n\nint N;\nvector<int>C[400];\nsigned main(){\n    cin>>N;\n    map<int,int>cnt;\n    map<int,int>way;\n    rep(i,N){\n        C[i].resize(4);\n        rep(j,4)cin>>C[i][j];\n        C[i]=rig(C[i]);\n        cnt[en(C[i])]++;\n\n        vint v=C[i];\n        set<vint>s;\n        rep(k,4){\n            s.insert(v);\n            rotate(v.begin(),v.begin()+1,v.end());\n        }\n        way[en(C[i])]=4/s.size();\n    }\n\n    int ans=0;\n    rep(i,N){\n        cnt[en(C[i])]--;\n        vint X=C[i];\n        reps(j,i+1,N){\n            vint Y=C[j];\n            cnt[en(C[j])]--;\n            reverse(all(Y));\n\n            rep(ii,4){\n\n                vint wanna(4);\n                rep(k,4){\n                    vint v(4);\n                    v[0]=X[(k+1)%4];\n                    v[1]=X[k];\n                    v[2]=Y[k];\n                    v[3]=Y[(k+1)%4];\n                    v=rig(v);\n                    wanna[k]=en(v);\n                }\n                sort(all(wanna));\n                vpint want;\n                rep(k,4){\n                    if(want.size()==0||want.back().fi!=wanna[k]){\n                        want.push_back(pint(wanna[k],1));\n                    }\n                    else{\n                        want[want.size()-1].se++;\n                    }\n                }\n\n                int tmp=1;\n                rep(k,want.size()){\n                    int e=want[k].fi;\n                    int f=want[k].se;\n                    if(cnt.find(e)==cnt.end()){\n                        tmp=0;\n                        continue;\n                    }\n                    int hoge=cnt[e];\n                    int piyo=way[e];\n                    rep(l,f)tmp*=(hoge-l)*piyo;\n                }\n                ans+=tmp;\n                rotate(Y.begin(),Y.begin()+1,Y.end());\n            }\n            cnt[en(C[j])]++;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma GCC optimize(\"O3\")\n#endif\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=404;\n\ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n\ninline LL norm( LL x ) {\n    return min(x,min(rot(x),min(rot(rot(x)),rot(rot(rot(x))))));\n}\n\ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nint n,a[N][4],rc[16];\nLL b[N],dp[2][16];\n\nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n\n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    int lc[4]={1,1,1,1};\n    REP(i,4) while ( lc[i]<4 && c[i][lc[i]]!=c[i][0] ) lc[i]++;\n    REP(i,4) rc[i]=4/lc[i];\n    REP(i,4) sort(c[i],c[i]+lc[i]);\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    int u=0;\n    REP1(i,ti+1,n) if ( i!=bi ) {\n        REP(j,16) dp[u^1][j]=dp[u][j];\n        REP(j,15) REP(k,4) if ( !bit(j,k) && b[i]==c[k][0] ) {\n            dp[u^1][j|(1<<k)]+=rc[k]*dp[u][j];\n        }\n        u^=1;\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[u][15];\n}\n\nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    // n=400;\n    REP1(i,1,n) b[i]=norm(f(a[i][0],a[i][1],a[i][2],a[i][3]));\n    // sort(b+1,b+n+1);\n    // if ( n==400 && a[1][0]==a[1][1] && a[1][0]==a[1][2] && a[1][0]==a[1][3] && b[1]==b[n] ) {\n        // W(\"673205187207168000\");\n        // return 0;\n    // }\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    //sort(all(tmpVecs));\n    sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int>& a,vector<int>& b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n;\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]= getWay(v);\n    }\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];\n                    /*tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];*/\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int Nmax = 400;\nint N, C[4][Nmax];\n\nlong encode(int c0,int c1,int c2,int c3){\n\tlong base=1000;\n\tlong x = c3+base*c2+base*base*c1+base*base*base*c0;\n\tlong m = x;\n\tfor(int i=0; i<3; i++){\n\t\tx = x/base+(x%base)*base*base*base;\n\t\tm = min(m, x);\n\t}\n\treturn m;\n}\n\nint rot(long code){\n\tint c[4];\n\tint base = 1000;\n\tfor(int i=0; i<4; i++) {\n\t\tc[i] = code%base;\n\t\tcode /= base;\n\t}\n\tif(c[0]==c[1]&&c[1]==c[2]&&c[2]==c[3]) return 4;\n\tif(c[0]==c[2]&&c[1]==c[3]) return 2;\n\treturn 1;\n}\n\nlong pow(long a,long n){\n\tif(n==0) return 1;\n\tif(n%2) return pow(a,n-1)*a;\n\treturn pow(a,n/2);\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> C[j][i];\n\t\t}\n\t}\n\n\tmap<long, vector<int> > e2f;\n\tfor(int i=0; i<N; i++){\n\t\tlong x = encode(C[0][i],C[1][i],C[2][i],C[3][i]);\n\t\te2f[x].push_back(i);\n\t}\n\n\tlong ans = 0;\n\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tlong f[4];\n\t\t\t\tf[0] = encode(C[1][i],C[0][i],C[(k+0)%4][j],C[(k+3)%4][j]);\n\t\t\t\tf[1] = encode(C[2][i],C[1][i],C[(k+3)%4][j],C[(k+2)%4][j]);\n\t\t\t\tf[2] = encode(C[3][i],C[2][i],C[(k+2)%4][j],C[(k+1)%4][j]);\n\t\t\t\tf[3] = encode(C[0][i],C[3][i],C[(k+1)%4][j],C[(k+0)%4][j]);\n\t\t\t\tif(e2f.find(f[0]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[1]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[2]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[3]) == e2f.end()) continue;\n\t\t\t\t/*\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tcout << f[0] << endl;\n\t\t\t\tcout << f[1] << endl;\n\t\t\t\tcout << f[2] << endl;\n\t\t\t\tcout << f[3] << endl;\n\t\t\t\t*/\n\t\t\t\tlong c[4];\n\t\t\t\tlong a=0;\n\t\t\t\tfor(int m=0; m<4; m++){\n\t\t\t\t\tc[m]=0;\n\t\t\t\t\tfor(auto l=e2f[f[m]].begin(); l!=e2f[f[m]].end(); l++){\n\t\t\t\t\t\t//cout << \" \" << *l << endl;\n\t\t\t\t\t\tif(*l==i || *l==j) continue;\n\t\t\t\t\t\tc[m]++;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << c[m] << \" \";\n\t\t\t\t}\n\t\t\t\tif(f[0]==f[1]&&f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=4){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*(c[0]-3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=2&&c[1]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*(c[1]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[3]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[2]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[2]==f[3]){\n\t\t\t\t\tif(c[2]>=2){\n\t\t\t\t\t\ta = c[2]*(c[2]-1)*c[0]*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[3]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta = c[0]*c[1]*c[2]*c[3];\n\t\t\t\t}\n\t\t\t\tfor(int m=0; m<4; m++) a*=rot(f[m]);\n\t\t\t\t//cout << a << endl;\n\t\t\t\tans += a;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans/3 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 404;\nint c[maxn][4];\nvoid rotate(int id){\n\tint p0 = c[id][0];\n\tfor(int j = 0; j < 3; j++) c[id][j] = c[id][j + 1];\n\tc[id][3] = p0;\n}\nlong long calc(int id){\n\tlong long val = 0;\n\tfor(int k = 0; k < 4; k++) val = val * 1000 + c[id][k];\n\treturn val;\n}\nlong long has[maxn][4];\nvoid ins(int id){\n\tfor(int rot = 0; rot < 4; rot++){\n\t\thas[id][rot] = calc(id);\n\t\trotate(id);\n\t}\n\tsort(has[id], has[id] + 4);\n}\nint get_msk(int id, long long vals[4]){\n\tint i = 0, j = 0, msk = 0;\n\twhile(i < 4 && j < 4){\n\t\tif(has[id][i] == vals[j]) msk |= 1<<j, j++;\n\t\telse if(has[id][i] < vals[j]) i++;\n\t\telse j++;\n\t}\n\treturn msk;\n}\nlong long need[4];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < 4; j++) cin >> c[i][j];\n\tfor(int i = 0; i < n; i++){\n\t\tins(i);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++){\n\t\tfor(int rotj = 0; rotj < 4; rotj++){\n\t\t\tint prot[4] = {};\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint nik = (k + 1) % 4;\n\t\t\t\tint njk0 = (5 - k) % 4;\n\t\t\t\tint njk1 = (4 - k) % 4; \n\t\t\t\tneed[k] = 0;\n\t\t\t\tfor(int v : {c[i][nik], c[i][k], c[j][njk0], c[j][njk1]}){\n\t\t\t\t\tneed[k] = need[k] * 1000 + v;\n\t\t\t\t}\n\t\t\t\tc[n][0] = c[i][nik];\n\t\t\t\tc[n][1] = c[i][k];\n\t\t\t\tc[n][2] = c[j][njk0];\n\t\t\t\tc[n][3] = c[j][njk1];\n\t\t\t\tfor(int tk = 0; tk < 4; tk++){\n\t\t\t\t\tif(calc(n) == need[k]) prot[k]++;\n\t\t\t\t\trotate(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(need, need + 4);\n\t\t\tvector<int> cnt(1<<4);\n\t\t\tfor(int k = 0; k < n; k++) if(k != i && k != j){\n\t\t\t\tint msk = get_msk(k, need);\n\t\t\t\tcnt[msk]++;\n\t\t\t}\n\t\t\tvector<long long> f(1<<4, 0), nf(1<<4, 0);\n\t\t\tf[0] = 1;\n\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\tif(cnt[k]){\n\t\t\t\t\tnf = f;\n\t\t\t\t\tfor(int sk = k; sk; sk = k & (sk - 1)){\n\t\t\t\t\t\tassert((k&sk) == sk);\n\t\t\t\t\t\tlong long ways = 1;\n\t\t\t\t\t\tint bc = __builtin_popcount(sk);\n\t\t\t\t\t\tfor(int z = 0; z < bc; z++) ways *= (cnt[k] - z);\n\t\t\t\t\t\tif(ways > 0){\n\t\t\t\t\t\t\tfor(int msk = 0; msk < 1<<4; msk++){\n\t\t\t\t\t\t\t\tif((msk&sk) == 0){\n\t\t\t\t\t\t\t\t\tnf[msk|sk] += f[msk] * ways;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf = nf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++) f[15] *= prot[k];\n\t\t\tans += f[15];\n\t\t\trotate(j);\n\t\t}\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=100050;\n//ここまでテンプレ\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\nll fact_mod(ll n, ll mod) {\n    ll f = 1; repq(i,2,n) f = f * (i % MOD) % MOD;\n    return f;\n}\n// 繰り返し二乗法 (再帰バージョン)\nll mod_pow(ll x, ll n, ll mod) {\n    if(n == 0) return 1;\n    ll res = mod_pow((x * x) % mod, n / 2 , mod);\n    if(n & 1) res = (res * x) % mod;\n    return res;\n}\n// 組み合わせ nCr を求める (modあり)\nll combination_mod(ll n, ll r, ll mod) {\n    if(r > n-r) r = n-r;\n    if(r == 0) return 1;\n    ll a = 1;\n    rep(i, 0, r) a = a * ((n-i) % mod) % mod;\n    ll b = mod_pow(fact_mod(r, mod), mod-2, mod);\n    return (a % mod) * (b % mod) % mod;\n}\n//4つの色を辞書順最小の並びで返す\nvint COLOR(int a,int b,int c,int d){\n\tvint A={a,b,c,d},B={b,c,d,a},C={c,d,a,b},D={d,a,b,c};\n\tvector<vint> vec={A,B,C,D};\n\tsort(vec.begin(),vec.end());\n\treturn vec[0];\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tmap<vint,int> pam;\n\tvector<vint> panel;\n\t//それぞれのパネルに含まれる色を、昇順にソートして入れていく\n\tfor(int i=0;i<N;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\t//4つの角の順番を変えないように、辞書順最小の並びに揃える\n\t\tvint v=COLOR(a,b,c,d);\n\t\tpam[v]++;\n\t\tpanel.pb(v);\n\t}\n\tll ans=0;\n\t//立方体の底に使うパネルiと天井に使うパネルjを全探索する\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\t//天井のパネルの向きを全探索する\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvint cei,flo;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tflo.pb(panel[i][l]);\n\t\t\t\t\tcei.pb(panel[j][(k+l)%4]);\n\t\t\t\t}\n\t\t\t\t//側面の4つのパネルになりうるパネルがあるか？\n\t\t\t\tvint A=COLOR(cei[0],flo[0],flo[3],cei[1]);\n\t\t\t\tvint B=COLOR(cei[3],flo[1],flo[0],cei[0]);\n\t\t\t\tvint C=COLOR(cei[2],flo[2],flo[1],cei[3]);\n\t\t\t\tvint D=COLOR(cei[1],flo[3],flo[2],cei[2]);\n\t\t\t\t//pamから底と天井に使ったパネルを引く\n\t\t\t\tpam[panel[i]]--;\n\t\t\t\tpam[panel[j]]--;\n\t\t\t\t//立方体が何通りできるか？\n\t\t\t\t//側面に使うパネル\n\t\t\t\tmap<vint,int> use;\n\t\t\t\tuse[A]++,use[B]++,use[C]++,use[D]++;\n\t\t\t\tif(pam.find(A)==pam.end() || pam.find(B)==pam.end() || pam.find(C)==pam.end() || pam.find(D)==pam.end());\n\t\t\t\telse if(pam[A]<use[A] || pam[B]<use[B] || pam[C]<use[C] || pam[D]<use[D]);\n\t\t\t\telse{\n\t\t\t\t\tll temp=1;\n\t\t\t\t\tfor(pair<vint,int> P:use){\n\t\t\t\t\t\ttemp*=combination_mod(pam[P.first],P.second,INFLL);\n\t\t\t\t\t\tif(P.first[1]==P.first[0] && P.first[2]==P.first[0] && P.first[3]==P.first[0])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=4;\n\t\t\t\t\t\telse if(P.first[0]==P.first[2] && P.first[1]==P.first[3])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=2;\n\t\t\t\t\t\tfor(int l=1;l<=P.second;l++)\n\t\t\t\t\t\t\ttemp*=l;\n\t\t\t\t\t}\n\t\t\t\t\tans+=temp;\n\t\t\t\t}\n\t\t\t\t//pamに底と天井に使ったパネルを足す\n\t\t\t\tpam[panel[i]]++;\n\t\t\t\tpam[panel[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\ntypedef unsigned long long ull;\n\nint n;\n\n#define TUPLE(a,b,c,d) (a | (b<<16) | ((ull)c<<32) | ((ull)d<<48))\n#define UNPACK(t,a,b,c,d) int a=((t)&65535),b=(((t)>>16)&65535),c=(((t)>>32)&65535),d=(((t)>>48)&65535)\n\null normalize(int a,int b,int c,int d){\n  ull r = TUPLE(a,b,c,d);\n  REP(_,3){\n    swap(a,b);\n    swap(b,c);\n    swap(c,d);\n    CHMIN(r,TUPLE(a,b,c,d));\n  }\n  return r;\n}\null normalize(ull s){\n  UNPACK(s,a,b,c,d);\n  return normalize(a,b,c,d);\n}\nvoid debunpack(string po,ull s){\n  UNPACK(s,a,b,c,d);\n  printf(\"%s%5d%5d%5d%5d\\n\",po.c_str(),a,b,c,d);\n}\n\nint main(){\n  // cube, [count,multiply]\n  unordered_map<ull,pii> mp;\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    set<ull> S;\n    S.insert(TUPLE(a,b,c,d));\n    REP(_,3){\n      swap(a,b);\n      swap(b,c);\n      swap(c,d);\n      S.insert(TUPLE(a,b,c,d));\n    }\n    ull s = *S.begin();\n    mp[s].first += 1;\n    mp[s].second = 4/S.size();\n  }\n  ull ans = 0;\n  for(auto& _s1:mp){\n    ull s1 = _s1.first;\n    ull u = _s1.second.first;\n    _s1.second.first--;\n    UNPACK(s1,a,b,c,d);\n    for(auto& _s2:mp){\n      ull s2 = _s2.first;\n      ull v = u * _s2.second.first;\n      _s2.second.first--;\n      UNPACK(s2,h,g,f,e);\n      REP(_,4){\n        ull add = v;\n        ull s3 = normalize(b,a,e,f);\n        ull s4 = normalize(c,b,f,g);\n        ull s5 = normalize(d,c,g,h);\n        ull s6 = normalize(a,d,h,e);\n        bool ok = mp.count(s3) && mp.count(s4) && mp.count(s5) && mp.count(s6);\n        if(ok){\n          add *= mp[s3].first * mp[s3].second;  mp[s3].first--;\n          add *= mp[s4].first * mp[s4].second;  mp[s4].first--;\n          add *= mp[s5].first * mp[s5].second;  mp[s5].first--;\n          add *= mp[s6].first * mp[s6].second;  mp[s6].first--;\n        }else{\n          add = 0;\n        }\n        ans += add;\n        if(ok){\n          mp[s3].first++;\n          mp[s4].first++;\n          mp[s5].first++;\n          mp[s6].first++;\n        }\n        swap(e,f);\n        swap(f,g);\n        swap(g,h);\n      }\n      _s2.second.first++;\n    }\n    _s1.second.first++;\n  }\n  printf(\"%llu\\n\",ans/6);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nmap<ll, vector<int>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                m[msk].PB(i);\n        }\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk= 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (int i : m[msk]) {\n                                cub[i][p]++;\n                        }\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, 0, N) if (i != top && i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                        fo(x, 0, 4) if (cub[i][x]) {\n                                fo(j, 0, 15) if ((j&(1<<x)) == 0 && old[j]) {\n                                        ways[j|(1<<x)] += old[j] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot/3);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <map>\n\nusing tile = std::array<int16_t, 4>;\nconstexpr int coeff[] = { 1, 2, 4 };\n\ntile rotate(const tile &t, int r) {\n  tile res{};\n  for (int i = 0; i < 4; ++i) {\n    res[i] = t[(i + r) & 3];\n  }\n  return res;\n}\n\ntile normalize(const tile &t) {\n  std::array<tile, 4> tmp{};\n  for (int i = 0; i < 4; ++i) {\n    tmp[i] = rotate(t, i);\n  }\n  std::sort(tmp.begin(), tmp.end());\n  return tmp.front();\n}\n\nint type(const tile &t) {\n  if (t[0] == t[1] && t[1] == t[2] && t[2] == t[3]) return 2;\n  if (t[0] == t[2] && t[1] == t[3]) return 1;\n  return 0;\n}\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<tile> C(N);\n  std::map<tile, int> memo;\n  for (int i = 0; i < N; ++i) {\n    for (auto &x: C[i]) {\n      std::cin >> x;\n    }\n    C[i] = normalize(C[i]);\n    memo[C[i]]++;\n  }\n  int64_t ans = 0;\n  for (int i = 0; i < N; ++i) {\n    memo[C[i]]--;\n    const auto &up = C[i];\n    for (int j = i + 1; j < N; ++j) {\n      memo[C[j]]--;\n      for (int k = 0; k < 4; ++k) {\n        auto down = rotate(C[j], k);\n        std::map<tile, int> query;\n        query[normalize(tile{ up[0], up[3], down[2], down[1] })]++;\n        query[normalize(tile{ up[1], up[0], down[1], down[0] })]++;\n        query[normalize(tile{ up[2], up[1], down[0], down[3] })]++;\n        query[normalize(tile{ up[3], up[2], down[3], down[2] })]++;\n        int64_t add = 1;\n        for (auto &q: query) {\n          auto itr = memo.find(q.first);\n          if (itr == memo.end()) {\n            add = 0;\n            break;\n          }\n          int s = itr -> second, t = type(q.first);\n          for (int i = 0; i < q.second; ++i) {\n            add *= (s - i) * coeff[t];\n          }\n        }\n        ans += add;\n      }\n      memo[C[j]]++;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nll f(const ar &x){\n    return x[0]+(ll)x[1]*1000+(ll)x[2]*1e6+(ll)x[3]*1e9;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin>>v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i]);\n            if(j==3)break;\n            rotate(v[i].begin(),v[i].begin()+1,v[i].end());\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                s[0] = f(ar{v[i][1],v[i][0],v[j][1],v[j][0]});\n                s[1] = f(ar{v[i][0],v[i][3],v[j][2],v[j][1]});\n                s[2] = f(ar{v[i][3],v[i][2],v[j][3],v[j][2]});\n                s[3] = f(ar{v[i][2],v[i][1],v[j][0],v[j][3]});\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    rep3(t,15,0){\n                        rep(tt,4){\n                            if(t&(1<<tt)){\n                                dp[t]+=dp[t^(1<<tt)]*cnt[tt];\n                            }\n                        }\n                    }\n                }\n                ans += dp[15];\n                rotate(v[j].begin(),v[j].begin()+1,v[j].end());\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int mo=1e9+7;\n\nint n,t1[5],t2[5],Ans;\nLL tmp[4],s[410];\nmap<LL,int> S;\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nLL gethash(int a,int b,int c,int d)\n{\n\tLL A=a*1000000000ll+b*1000000ll+c*1000ll+d;\n\tLL B=b*1000000000ll+c*1000000ll+d*1000ll+a;\n\tLL C=c*1000000000ll+d*1000000ll+a*1000ll+b;\n\tLL D=d*1000000000ll+a*1000000ll+b*1000ll+c;\n\treturn min(min(A,B),min(C,D));\n}\n\nvoid getcolor(LL hs,int &a,int &b,int &c,int &d)\n{\n\td=hs%1000; hs/=1000;\n\tc=hs%1000; hs/=1000;\n\tb=hs%1000; hs/=1000;\n\ta=hs%1000;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j,x,y,a,b,c,d;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ts[i]=gethash(a,b,c,d);\n\t}\n\tsort(s+1,s+n+1);\n\tfor (i=1;i<=n;i++) S[s[i]]++;\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t{\n\t\tgetcolor(s[i],t1[0],t1[1],t1[2],t1[3]);\n\t\tgetcolor(s[j],t2[0],t2[1],t2[2],t2[3]);\n\t\tS[s[i]]--; S[s[j]]--;\n\t\tfor (x=0;x<4;x++)\n\t\t{\n\t\t\ttmp[0]=gethash(t2[1],t2[0],t1[1],t1[0]);\n\t\t\ttmp[1]=gethash(t2[0],t2[3],t1[2],t1[1]);\n\t\t\ttmp[2]=gethash(t2[3],t2[2],t1[3],t1[2]);\n\t\t\ttmp[3]=gethash(t2[2],t2[1],t1[0],t1[3]);\n\t\t\tsort(tmp,tmp+4);\n\t\t\tint way,Sum=1;\n\t\t\tfor (y=0;y<4;y++)\n\t\t\t{\n\t\t\t\tif (!y||tmp[y]!=tmp[y-1])\n\t\t\t\t\tway=S[tmp[y]];\n\t\t\t\telse\n\t\t\t\t\tway--;\n\t\t\t\tSum=(LL)Sum*way%mo;\n\t\t\t\tgetcolor(tmp[y],a,b,c,d);\n\t\t\t\tif (a==c&&b==d)\n\t\t\t\t{\n\t\t\t\t\tSum+=Sum%=mo;\n\t\t\t\t\tif (a==b) Sum+=Sum%=mo;\n\t\t\t\t}\n\t\t\t}\n\t\t\t(Ans+=Sum)%=mo;\n\t\t\tt1[4]=t1[0];\n\t\t\tfor (y=0;y<4;y++) t1[y]=t1[y+1];\n\t\t}\n\t\tS[s[i]]++; S[s[j]]++;\n\t}\n\tAns=(LL)Ans*power(3,mo-2)%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst i64 M=(1ll<<40)-1;\nint n,a[407][4],t[407],tx[407];\ni64 f[407],f0[407],_cnt,ans=0;\ni64 min(i64 a,i64 b){return a<b?a:b;}\ni64 cal(i64 a,i64 b,i64 c,i64 d){\n\ti64 ab=a<<10|b,abc=ab<<10|c;\n\ti64 cd=c<<10|d,bcd=b<<20|cd;\n\treturn min(min(abc<<10|d,d<<30|abc),min(cd<<20|ab,bcd<<10|a));\n}\nint $(i64 x){\n\tint p=std::lower_bound(f,f+n,x)-f;\n\treturn f[p]==x?p:-1;\n}\nvoid dec(i64 x){\n\tint p=$(x);\n\tif(p!=-1)--t[p];\n}\nvoid inc(i64 x){\n\tint p=$(x);\n\tif(p!=-1)++t[p];\n}\nvoid cal(i64 x){\n\tint p=$(x);\n\tif(p!=-1){\n\t\t_cnt*=t[p]*tx[p];\n\t\t--t[p];\n\t}else _cnt=0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i){\n\t\tint*A=a[i];\n\t\tfor(int j=0;j<4;++j)scanf(\"%d\",A+j);\n\t\tf0[i]=f[i]=cal(A[0],A[1],A[2],A[3]);\n\t}\n\tstd::sort(f,f+n);\n\tf[n]=M;\n\tfor(int i=0,j=0;i<n;i=j){\n\t\tfor(++j;f[i]==f[j];++j);\n\t\tt[i]=j-i;\n\t\ttx[i]=1;\n\t\ti64 x=f[i];\n\t\tif(x==((x>>20|x<<20)&M)){\n\t\t\ttx[i]=2;\n\t\t\tif(x==((x>>30|x<<10)&M))tx[i]=4;\n\t\t}\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tdec(f0[i]);\n\t\tfor(int j=0;j<i;++j){\n\t\t\tdec(f0[j]);\n\t\t\tint*A=a[i],*B=a[j];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\ti64 vs[4];\n\t\t\t\t_cnt=1;\n\t\t\t\tfor(int t=0;t<4;++t){\n\t\t\t\t\tvs[t]=cal(A[k-t&3],A[k-t-1&3],B[t&3],B[t-1&3]);\n\t\t\t\t\tcal(vs[t]);\n\t\t\t\t}\n\t\t\t\tfor(int t=0;t<4;++t)inc(vs[t]);\n\t\t\t\tans+=_cnt;\n\t\t\t}\n\t\t\tinc(f0[j]);\n\t\t}\n\t\tinc(f0[i]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n#define MAXN 600\n\ntypedef array<short,4> tile;\n\nint n;\ntile a[MAXN];\nlong d[MAXN];\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%hd\", &a[i][j]);\n\treturn 1;\n}\n\nvoid init() {\n}\n\ntile rotate(const tile &x, int k=1) {\n\ttile y;\n\tfor (int i=0; i<4; i++) y[(i+k) % 4] = x[i];\n\treturn y;\n}\n\ntile normalize(const tile &x) {\n\ttile z=x;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y<z) z=y;\n\t}\n\treturn z;\n}\n\nint mirror(const tile &x) {\n\tint r = 1;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y==x) r++;\n\t}\n\treturn r;\n}\n\ntile get_face(const tile &u, const tile &d, int x, int y) {\n\treturn normalize({u[x], u[y], d[3-y], d[3-x]});\n}\n\n//use id to speed up\nlong id(const tile &x) {\n\treturn x[0]*1000000000L + x[1]*1000000L + x[2]*1000L + x[3];\n}\n\nlong get_face_id(const tile &u, const tile &d, int x, int y) {\n\tlong z = id({u[x], u[y], d[3-y], d[3-x]});\n\tlong r = z;\n\tfor (int i=0; i<3; i++) {\n\t\tz = z/1000L + z%1000L * 1000000000L;\n\t\tif (z<r) r = z;\n\t}\n\treturn r;\n}\n\nlong solve() {\n\tmap<long,long> ct;\n\tmap<long,long> mi;\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] = normalize(a[i]);\n\t\td[i] = id(a[i]);\n\t\tct[d[i]]++;\n\t\tmi[d[i]] = mirror(a[i]);\n\t}\n\tlong ans = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tct[d[i]]--;\n\t\tfor (int j=i+1; j<n; j++) {\n\t\t\tct[d[j]]--;\n\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\ttile d=a[i], u=rotate(a[j], k);\n\t\t\t\t//tile f[4];\n\t\t\t\tlong g[4];\n\t\t\t\tlong r = 1;\n\t\t\t\tfor (int t=0; t<4; t++) {\n\t\t\t\t\t//f[t] = get_face(u, d, t, (t+3)%4);\n\t\t\t\t\t//g[t] = id(f[t]);\n\t\t\t\t\tg[t] = get_face_id(u, d, t, (t+3)%4);\n\t\t\t\t\tauto p = ct.find(g[t]);\n\t\t\t\t\tif (p == ct.end()) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr *= mi[g[t]] * (p->second--);\n\t\t\t\t}\n\t\t\t\t//printf(\"* %d %d %d: %ld\\n\", i, j, k, r);\n\t\t\t\tans += r;\n\t\t\t\tfor (int t=0; t<4; t++) {\n\t\t\t\t\tauto p = ct.find(g[t]);\n\t\t\t\t\tif (p == ct.end()) break;\n\t\t\t\t\tp->second++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tct[d[j]]++;\n\t\t}\n\t\tct[d[i]]++;\n\t}\n\treturn ans/3;\n}\n\nvoid output(long ans) {\n\tprintf(\"%ld\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i) for(int i=0;i<4;i++)\nusing ll=long long;\nusing Token=array<int,4>;\nvoid norm(Token& t){\n    Token res = t;\n    rep(_){\n        Token sft = {t[(1+_)%4],t[(2+_)%4],t[(3+_)%4],t[_]};\n        res = min(res, sft);\n    }\n    t = res;\n}\nll repeat(const Token& t) {\n    if (t[0] != t[2]) return 1;\n    if (t[1] != t[3]) return 1;\n    return t[0]==t[1]?4:2;\n}\nvoid solve() {\n    int n; cin >> n;\n    vector<Token> a(n);\n    map<Token, ll> cnt;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i][0] >> a[i][1] >> a[i][2] >> a[i][3];\n        norm(a[i]);\n        cnt[a[i]]++;\n    }\n    ll res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            rep(k){\n                Token U = {a[j][(1+k)%4], a[j][(0+k)%4], a[i][1], a[i][0]}; norm(U);\n                Token R = {a[i][1], a[j][(0+k)%4], a[j][(3+k)%4], a[i][2]}; norm(R);\n                Token D = {a[i][2], a[j][(3+k)%4], a[j][(2+k)%4], a[i][3]}; norm(D);\n                Token L = {a[j][(1+k)%4], a[i][0], a[i][3], a[j][(2+k)%4]}; norm(L);\n                ll tmp = 1;\n                ll d = cnt[U] - (a[i]==U) - (a[j]==U);\n                tmp *= d>0?d:0;\n                d = cnt[R] - (a[i]==R) - (a[j]==R) - (U==R);\n                tmp *= d>0?d:0;\n                d = cnt[D] - (a[i]==D) - (a[j]==D) - (U==D) - (R==D);\n                tmp *= d>0?d:0;\n                d = cnt[L] - (a[i]==L) - (a[j]==L) - (U==L) - (R==L) - (D==L);\n                tmp *= d>0?d:0;\n                tmp *= repeat(U);\n                tmp *= repeat(R);\n                tmp *= repeat(D);\n                tmp *= repeat(L);\n                res += tmp;\n            }\n        }\n    }\n    res /= 3;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin p2(in a){\n  return 1<<a;\n}\nin sel(in a, in b){\n  if(a<b)\n    return 0;\n  in c=1;\n  for(in i=a;i>a-b;--i)\n    c*=i;\n  return c;\n}\nVI bcl;\nVVI cl;\nVVI cord={{0,5,4,1},{1,4,7,2},{2,7,6,3},{5,0,3,6}};\nmap<VI,in> hv;\nVVI socl;\nVI cnn(VI a){\n  VI r=a;\n  forn(z,4){\n    rotate(a.begin(),a.begin()+1,a.end());\n    r=min(r,a);\n  }\n  return r;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  cl.resize(n,VI(4));\n  forn(z,n){\n    forn(i,4)\n      cin>>cl[z][i];\n  }\n  socl=cl;\n  forn(z,n){\n    socl[z]=cnn(socl[z]);\n    ++hv[socl[z]];\n  }\n  bcl.resize(8);\n  in sm=0;\n  forn(b,n){\n    --hv[socl[b]];\n    for(in a=b+1;a<n;++a){\n      --hv[socl[a]];\n      forn(z,4){\n\trotate(cl[a].begin(),cl[a].begin()+1,cl[a].end());\n\tforn(k,4){\n\t  bcl[k]=cl[b][k];\n\t  bcl[k+4]=cl[a][k];\n\t}\n\tVVI tr(4,VI(4));\n\tforn(i,4){\n\t  forn(j,4){\n\t    tr[i][j]=bcl[cord[i][j]];\n\t  }\n\t  tr[i]=cnn(tr[i]);\n\t}\n\tsort(all(tr));\n\tin cw=1;\n\tin sf=0;\n\tforn(i,4){\n\t  if(i!=0 && tr[i]!=tr[i-1]){\n\t    cw*=sel(hv[tr[i-1]],sf);\n\t    sf=1;\n\t  }\n\t  else\n\t    ++sf;\n\t}\n\tcw*=sel(hv[tr[3]],sf);\n\tVI tp;\n\tforn(i,4){\n\t  tp=tr[i];\n\t  in ss=0;\n\t  forn(j,4){\n\t    rotate(tp.begin(),tp.begin()+1,tp.end());\n\t    ss+=(tp==tr[i]);\n\t  }\n\t  cw*=ss;\n\t}\n\tsm+=cw;\n      }\n      ++hv[socl[a]];\n    }\n  }\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\ngp_hash_table<ll, int> dp;\n\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        piipii p1 = c[i];\n        del(p1);\n        for(int j=i+1;j<=n;j++){\n            piipii p2 = c[j];\n            del(p2);\n            for(int k=0;k<4;k++){\n                ll res = 1;\n                piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                if(dp.find(get_idx(tmp1)) != dp.end()){\n                    res *= dp[get_idx(tmp1)];\n                    del(tmp1);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp2)) != dp.end()){\n                    res *= dp[get_idx(tmp2)];\n                    del(tmp2);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp3)) != dp.end()){\n                    res *= dp[get_idx(tmp3)];\n                    del(tmp3);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp4)) != dp.end()){\n                    res *= dp[get_idx(tmp4)];\n                    del(tmp4);\n                }\n                else res = 0;\n\n                ans += res;\n\n                if(dp.find(get_idx(tmp1)) != dp.end()){\n                    add(tmp1);\n                }\n                if(dp.find(get_idx(tmp2)) != dp.end()){\n                    add(tmp2);\n                }\n                if(dp.find(get_idx(tmp3)) != dp.end()){\n                    add(tmp3);\n                }\n                if(dp.find(get_idx(tmp4)) != dp.end()){\n                    add(tmp4);\n                }\n\n                p2 = rotate(p2);\n            }\n            add(p2);\n        }\n        add(p1);\n    }\n    printf(\"%lld\\n\", ans/3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n/*//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n        //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    *//*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*//*\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,int> cnt;\nunordered_map<LL,int> way;*/\n\nvector<int> rig(vector<int> v){\n    vector<vector<int>> r(4);\n    for (int i = 0; i < 4; ++i) {\n        r[i]=v;\n        rotate(r[i].begin(),r[i].begin()+i,r[i].end());\n    }\n    sort(all(r));\n    return r[0];\n}\n\nLL en(vector<int> v){\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\nint n;\nvector<int>C[400];\nsigned main(){\n    cin>>n;\n    map<LL,int>cnt;\n    map<LL,int>way;\n    for (int i = 0; i < n; ++i) {\n        C[i].resize(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>C[i][j];\n        }\n        C[i]=rig(C[i]);\n        cnt[en(C[i])]++;\n\n        vector<int> v=C[i];\n        set<vector<int>>s;\n        for (int k = 0; k <4 ; ++k) {\n            s.insert(v);\n            rotate(v.begin(),v.begin()+1,v.end());\n        }\n        way[en(C[i])]=4/s.size();\n    }\n\n    int ans=0;\n    for (int i = 0; i < n; ++i) {\n        cnt[en(C[i])]--;\n        vector<int> X=C[i];\n        for (int j = i+1; j < n; ++j) {\n            vector<int> Y=C[j];\n            cnt[en(C[j])]--;\n            reverse(all(Y));\n\n            for (int ii = 0; ii < 4; ++ii) {\n                vector<LL> wanna(4);\n                for(int k=0;k<4;k++){\n                    vector<int> v(4);\n                    v[0]=X[(k+1)%4];\n                    v[1]=X[k];\n                    v[2]=Y[k];\n                    v[3]=Y[(k+1)%4];\n                    v=rig(v);\n                    wanna[k]=en(v);\n                }\n                sort(all(wanna));\n                vector<pair<int,int>> want;\n                for(int k=0;k<4;k++){\n                    if(want.size()==0||want.back().first!=wanna[k]){\n                        want.push_back(mp(wanna[k],1));\n                    }\n                    else{\n                        want[want.size()-1].second++;\n                    }\n                }\n\n                int tmp=1;\n                for(int k=0;k<want.size();k++){\n                    int e=want[k].first;\n                    int f=want[k].second;\n                    if(cnt.find(e)==cnt.end()){\n                        tmp=0;\n                        continue;\n                    }\n                    int hoge=cnt[e];\n                    int piyo=way[e];\n                    for(int l=0;l<f;l++)\n                        tmp*=(hoge-l)*piyo;\n                }\n                ans+=tmp;\n                rotate(Y.begin(),Y.begin()+1,Y.end());\n            }\n            cnt[en(C[j])]++;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<map>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=410;\nstruct State {\n\tint a,b,c,d;\n\tbool operator < (const State& S) const {\n\t\tif(a!=S.a) return a<S.a;\n\t\tif(b!=S.b) return b<S.b;\n\t\tif(c!=S.c) return c<S.c;\n\t\treturn d<S.d;\n\t}\n\tbool operator == (const State& S) {\n\t\treturn a==S.a&&b==S.b&&c==S.c&&d==S.d;\n\t}\n}A[maxn][4];\nconst int HASH=152501;\nstruct Hash_Table {\n\tint first[HASH],nxt[maxn*4],sum[maxn*4],cnt;\n\tll val[maxn*4];\n\tint find(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) return sum[i];\n\t\treturn -1;\n\t}\n\tvoid add(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) {sum[i]++;return;}\n\t\tval[++cnt]=x;sum[cnt]=1;nxt[cnt]=first[p];first[p]=cnt;\n\t}\n\tvoid del(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) {sum[i]--;return;}\n\t}\n}M;\n#define hash(a,b,c,d) ((a+1)*201525010ll+(b+1)*252501ll+(c+1)*2501+d+1)\nvoid del(State x) {\n\tM.del(hash(x.a,x.b,x.c,x.d));\n\tM.del(hash(x.b,x.c,x.d,x.a));\n\tM.del(hash(x.c,x.d,x.a,x.b));\n\tM.del(hash(x.d,x.a,x.b,x.c));\n}\nvoid add(State x) {\n\tM.add(hash(x.a,x.b,x.c,x.d));\n\tM.add(hash(x.b,x.c,x.d,x.a));\n\tM.add(hash(x.c,x.d,x.a,x.b));\n\tM.add(hash(x.d,x.a,x.b,x.c));\n}\nint main() {\n\tint n=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tA[i][0]=(State){a,b,c,d};\n\t\tA[i][1]=(State){b,c,d,a};\n\t\tA[i][2]=(State){c,d,a,b};\n\t\tA[i][3]=(State){d,a,b,c};\n\t\tM.add(hash(a,b,c,d));M.add(hash(c,d,a,b));\n\t\tM.add(hash(b,c,d,a));M.add(hash(d,a,b,c));\n\t}\n\tll ans=0;\n\trep(i,1,n) rep(j,i+1,n) if(i!=j) {\n\t\tdel(A[i][0]);del(A[j][0]);\n\t\trep(y,0,3) {\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t\tState S[4];\n\t\t\tS[0]=(State){A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b};\n\t\t\tS[1]=(State){A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b};\n\t\t\tS[2]=(State){A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d};\n\t\t\tS[3]=(State){A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d};\n\t\t\tint c1=M.find(hash(A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b));del(S[0]);\n\t\t\tint c2=M.find(hash(A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b));del(S[1]);\n\t\t\tint c3=M.find(hash(A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d));del(S[2]);\n\t\t\tint c4=M.find(hash(A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d));del(S[3]);\n\t\t\tif(c1>0&&c2>0&&c3>0&&c4>0) ans+=(ll)c1*c2*c3*c4;\n\t\t\tif(c1!=-1) add(S[0]);\n\t\t\tif(c2!=-1) add(S[1]);\n\t\t\tif(c3!=-1) add(S[2]);\n\t\t\tif(c4!=-1) add(S[3]);\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t}\n\t\tadd(A[i][0]);add(A[j][0]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nmap<vi,int> ma;\nmap<vi,int> rotar;\nvi A[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvi V; \n\t\tfor(int j=0;j<4;j++){int x; cin>>x; V.pb(x);} \n\t\tA[i]=V;\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tma[V]++;\n\t\t\tV.pb(*V.begin()); V.erase(V.begin());\n\t\t}\n\t}\n\tfor(auto X:ma)\n\t{\n\t\tvi v=X.fi; vi ori=v; int cnt=0;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tv.pb(*v.begin()); v.erase(v.begin());\n\t\t\tif(v==ori) cnt++;\n\t\t}\n\t\trotar[v]=cnt;\n\t}\n\tll ans = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tvi a = A[i];\n\t\t\tvi b = A[j];\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tma[a]--; ma[b]--;\n\t\t\t\ta.pb(*a.begin()); a.erase(a.begin());\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tvi F[4];\n\t\t\t\tF[0] = {a[0],b[1],b[0],a[1]};\n\t\t\t\tF[1] = {a[3],a[2],b[3],b[2]};\n\t\t\t\tF[2] = {b[1],a[0],a[3],b[2]};\n\t\t\t\tF[3] = {a[1],b[0],b[3],a[2]};\n\t\t\t\tll res = 1;\n\t\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\t{\n\t\t\t\t\tres*=ma[F[z]];\n\t\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[F[z]]--;\n\t\t\t\t\t\tF[z].pb(*F[z].begin()); F[z].erase(F[z].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[F[z]]++;\n\t\t\t\t\t\tF[z].pb(*F[z].begin()); F[z].erase(F[z].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += res;\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tma[a]++; ma[b]++;\n\t\t\t\ta.pb(*a.begin()); a.erase(a.begin());\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 402;\nconst ll MAXC = 10000003;\n\ntypedef array<int, 4> a4;\nostream& operator << (ostream &_s,const a4 &_p){return _s<<\"(\"<<_p[0]<<\",\"<<_p[1]<<\",\"<<_p[2]<<\",\"<<_p[3]<<\")\";}\n\nint n, cnt[MAXC];\na4 til[MAXN];\n\na4 reg (const a4 &state) {\n    a4 rot[4];\n    REP (i, 4) {\n        REP (j, 4) {\n            rot[i][j] = state[i+j >= 4 ? i+j-4 : i+j];\n        }\n    }\n\n    sort(rot, rot+4);\n    return rot[0];\n}\n\nint toInt (const a4 &state) {\n    a4 rot = reg(state);\n\n    ll bs = 1, sum = 0;\n    REP (i, 4) {\n        sum = sum + bs * rot[i];\n        bs = bs * 503;\n    }\n    return sum % MAXC;\n}\n\nint gC (int id, int rt, int p) {\n    int d = p+rt >= 4 ? p+rt-4 : p+rt;\n    return til[id][d];\n}\n\nll ans;\n/********** Good Luck :) **********/\nint main()\n{\n    IOS();\n\n    cin >> n;\n    REP (i, n) {\n        REP (c, 4) {\n            cin >> til[i][c];\n        }\n        cnt[toInt(til[i])]++;\n    }\n    TIME(main);\n\n    pair<a4,int> rem[4];\n    \n    int ft, fb, len, hs;\n    ll tot, cur;\n    REP (t, n) {\n        // TIME(titr);\n        REP (b, n) {\n            if (t == b) {\n                continue;\n            }\n            ft = toInt(til[t]);\n            fb = toInt(til[b]);\n            cnt[ft]--;\n            cnt[fb]--;\n            REP (bd, 4) {\n                {\n                    // TIME(pre1);\n                    rem[0].X = {til[t][3], til[t][2], gC(b, bd, 1), gC(b, bd, 0)};\n                    rem[1].X = {til[t][2], til[t][1], gC(b, bd, 2), gC(b, bd, 1)};\n                    rem[2].X = {til[t][1], til[t][0], gC(b, bd, 3), gC(b, bd, 2)};\n                    rem[3].X = {til[t][0], til[t][3], gC(b, bd, 0), gC(b, bd, 3)};\n                }\n\n                {\n                    // TIME(pre2);\n                    REP (i, 4) {\n                        rem[i].Y = toInt(rem[i].X);\n                    }\n                }\n                \n                {\n                    // TIME(pre3);\n                    sort(rem, rem + 4, [&](pair<a4,int> p1, pair<a4,int> p2) {\n                        return p1.Y < p2.Y;\n                    });\n                }\n\n                {\n                    // TIME(cc);\n\n                    len = 0;\n                    tot = 1;\n                    REP (i, 4) {\n                        len++;\n                        if (i == 3 || rem[i].Y != rem[i+1].Y) {\n                            cur = 1;\n                            hs = rem[i].Y;\n                            bool alsm = rem[i].X[0] == rem[i].X[1] && rem[i].X[1] == rem[i].X[2] && rem[i].X[2] == rem[i].X[3];\n                            bool dgsm = rem[i].X[0] == rem[i].X[2] && rem[i].X[1] == rem[i].X[3];\n                            REP (j, len) {\n                                cur *= cnt[hs] - j;\n                                cur *= alsm ? 2 : 1;\n                                cur *= dgsm ? 2 : 1;\n                            }\n                            \n                            tot *= cur;\n                            len = 0;\n                        }\n                    }\n\n                    \n                    ans += tot;\n                }\n                            \n\n            }\n            cnt[ft]++;\n            cnt[fb]++;\n\n        }\n    }\n\n    cout << ans/6 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define f first\n#define s second\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%I64d\",&x)\n#define CLR(x)  memset(x,0,sizeof(x))\n#define RESET(x,a) memset(x,a,sizeof(x))\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<\">value (\"<<#x<<\") : \"<<x<<endl;\n\nconst int N=405;\nint a[N][4]; //tile\nll val[N];   //hash of tile\nint n;\n\nll h(int p[4],int k)\n{\n    ll res=0LL;\n    for(int i=k;i<4;i++)\n        res = res*1000LL + (ll)p[i];\n    for(int i=0;i<k;i++)\n        res = res*1000LL + (ll)p[i];\n    return res;\n}\n\nll normalise(int p[4])\n{\n    return min(h(p,0),min(h(p,1),min(h(p,2),h(p,3))));\n}\n\nll way(int x, int y, int r)\n{\n    int i,j,k,b[4];\n    for(i=0;i<4;i++)\n        b[i]=a[y][ (i+r)%4 ];\n    int p[4];\n    int sym[4]={1,1,1,1};\n    ll d[4];\n    p[0]=b[1];   p[1]=b[0];\n    p[2]=a[x][1];   p[3]=a[x][0];\n    if(h(p,0)==h(p,1))sym[0]=4;\n    else if(h(p,0)==h(p,2))sym[0]=2;\n    d[0]=normalise(p);\n\n    p[0]=b[0];   p[1]=b[3];\n    p[2]=a[x][2];   p[3]=a[x][1];\n    if(h(p,0)==h(p,1))sym[1]=4;\n    else if(h(p,0)==h(p,2))sym[1]=2;\n    d[1]=normalise(p);\n\n    p[0]=b[2];   p[1]=b[1];\n    p[2]=a[x][0];   p[3]=a[x][3];\n    if(h(p,0)==h(p,1))sym[2]=4;\n    else if(h(p,0)==h(p,2))sym[2]=2;\n    d[2]=normalise(p);\n\n    p[0]=b[3];   p[1]=b[2];\n    p[2]=a[x][3];   p[3]=a[x][2];\n    if(h(p,0)==h(p,1))sym[3]=4;\n    else if(h(p,0)==h(p,2))sym[3]=2;\n    d[3]=normalise(p);\n\n    ll ans[16]={0};\n    ans[0]=1;\n    for(i=x+1;i<n;i++)\n    {\n        if(i==y)continue;\n        for(j=14;j>=0;j--)\n        {\n            for(k=0;k<4;k++)\n            {\n                if(j&(1<<k))continue;\n                if(val[i]==d[k])\n                    ans[j+(1<<k)] += 1LL*sym[k]*ans[j];\n            }\n        }\n    }\n    //printf(\"%d %d %lld %d\\n\",x+1,y+1,ans[15],sym[0]);\n    return ans[15];\n}\n\nint main()\n{\n    int i,j,k;\n    si(n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<4;j++)\n            si(a[i][j]);\n        val[i] = normalise(a[i]);\n    }\n    ll ans=0LL;\n    for(i=0;i<n;i++)\n        for(j=i+1;j<n;j++)\n            for(k=0;k<4;k++)\n                ans+=way(i,j,k);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\npa4 rot(pa4 z){\n\treturn {z.w,z.x,z.y,z.z};\n}\nint hen(pa4 z){\n\treturn z.x+1000*z.y+1000000*z.z+1000000000*z.w;\n}\n\nbool ona(int z0,int z1){\n\tif(z0==z1) return 1;\n\tfor(int i=0;i<3;i++){\n\t\tint am=z0%1000;\n\t\tz0/=1000;\n\t\tz0+=am*1000000000ll;\n\t\tif(z0==z1) return 1;\n\t}\n\treturn 0;\n}\n\nint ki(int z0){\n\tint ans=z0;\n\tfor(int i=0;i<3;i++){\n\t\tint am=z0%1000;\n\t\tz0/=1000;\n\t\tz0+=am*1000000000ll;\n\t\tans=min(ans,z0);\n\t}\n\treturn ans;\n}\n\nint tai(int z){\n\tint y0=z%1000;\n\tz/=1000;\n\tint y1=z%1000;\n\tz/=1000;\n\tint y2=z%1000;\n\tz/=1000;\n\tint y3=z%1000;\n\tz/=1000;\n\t\n\tif(y1==y2 && y1==y0 && y1==y3) return 4;\n\tif(y1==y3 && y0==y2) return 2;\n\treturn 1;\n}\npa4 iro[400][4];\nint num[400][4];\nint kijun[400];\nmap<int,int> ma[400],zen,K; \nint b(int n,int r){\n\tif(r==0) return 1;\n\tif(r==1) return n;\n\tif(r%2)return b(n,r-1)*n;\n\tint z=b(n,r/2);\n\treturn z*z;\n}\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n  \tcin>>n;\n  \t\n  \tfor(int i=0;i<n;i++){\n  \t\tint y1,y2,y3,y4;\n  \t\tcin>>y1>>y2>>y3>>y4;\n  \t\tiro[i][0]={y1,y2,y3,y4};\n  \t\tfor(int j=1;j<4;j++)iro[i][j]=rot(iro[i][j-1]);\n  \t\tkijun[i]=ki(hen(iro[i][0]));\n  \t\tK[kijun[i]]++;\n  \t\tfor(int j=0;j<4;j++){\n  \t\t\tnum[i][j]=hen(iro[i][j]);\n  \t\t\tma[i][num[i][j]]++;\n  \t\t\tzen[num[i][j]]++;\n  \t//\t\tcout<<i<<\" \"<<j<<\"   \"<<num[i][j]<<endl;\n  \t\t}\n  \t}\n  \t\n  \tint ans=0;\n  \tfor(int s=0;s<n;s++)for(int t=0;t<n;t++)if(s!=t)for(int l=0;l<4;l++)for(int r=0;r<4;r++){\n  \t\t\n  \t\tint e[4];\n  \t\te[0]=hen({iro[s][l].x,iro[s][l].w,iro[t][r].x,iro[t][r].w});\n  \t\te[1]=hen({iro[s][l].w,iro[s][l].z,iro[t][r].y,iro[t][r].x});\n  \t\te[2]=hen({iro[s][l].z,iro[s][l].y,iro[t][r].z,iro[t][r].y});\n  \t\te[3]=hen({iro[s][l].y,iro[s][l].x,iro[t][r].w,iro[t][r].z});\n  \t\t\n  \t\tfor(int i=0;i<4;i++)e[i]=ki(e[i]);\n  \t\tK[kijun[s]]--;\n  \t\tK[kijun[t]]--;\n  \t\tbool bo=true;\n  \t\tfor(int i=0;i<4;i++)if(K.count(e[i])==0||K[e[i]]==0) bo=false;\n  \t\t\n  \t\tif(bo){\n  \t\t//int cnt=0;\n  \t\tvector<pa> Pair;\n  \t\tmap<int,int >w;\n  \t\tfor(int i=0;i<4;i++){\n  \t\t\tw[e[i]]++;\n  \t\t}\n  \t\tint ka=1;\n  \t\t\t/*\n  \t\t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\t\tcout<<it->first<<\" \"<<it->second<<endl;\n  \t\t\t}\n  \t\t\tcout<<endl;\n  \t\t\t*/\n  \t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\tif(it->second==4){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<4){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*(num-3)*b(tai(it->first),4);\n  \t\t\t}\n  \t\t\tif(it->second==3){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<3){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*b(tai(it->first),3);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==2){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<2){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*b(tai(it->first),2);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==1){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<1){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t//\t\tcout<<tai(it->first)<<endl;\n  \t\t\t\tka*=num*b(tai(it->first),1);\n  \t\t\t}\n  \t\t}\n  \t\t\tans+=ka;\n  \t\t}\n  \t\t\n  \t\tK[kijun[s]]++;\n  \t\tK[kijun[t]]++;\n  \t}\n  \t\n  \tcout<<ans/24<<endl;\n  \t\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint p[410][4];\nint v[2][4];\n\nmap<vector<int>, int> cnt;\nmap<vector<int>, int> qcnt;\n\nvector<int> norm(int a, int b, int c, int d){\n  vector<int> v0 = {a, b, c, d}, v1 = {b, c, d, a}, v2 = {c, d, a, b}, v3 = {d, a, b, c};\n  return min(v0, min(v1, min(v2, v3)));\n}\nvector<int> norm(int id){\n  return norm(p[id][0], p[id][1], p[id][2], p[id][3]);\n}\n\nint main(){\n  int N; scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < 4; j++) scanf(\"%d\", &p[i][j]);\n    cnt[norm(i)]++;\n  }\n\n  long long ans = 0;\n\n  for(int A = 0; A < N; A++){ // dir = 0\n    for(int i = 0; i < 4; i++) v[0][i] = p[A][i];\n    cnt[norm(A)]--;\n\n    for(int B = 0; B < N; B++){\n      if(A == B) continue;\n      cnt[norm(B)]--;\n\n      for(int BD = 0; BD < 4; BD++){\n        for(int i = 0; i < 4; i++) v[1][i] = p[B][(BD + i) % 4];\n\n        qcnt.clear();\n\n        qcnt[norm(v[0][3], v[0][2], v[1][2], v[1][1])]++;\n        qcnt[norm(v[0][2], v[0][1], v[1][3], v[1][2])]++;\n        qcnt[norm(v[0][1], v[0][0], v[1][0], v[1][3])]++;\n        qcnt[norm(v[0][0], v[0][3], v[1][1], v[1][0])]++;\n\n        long long r = 1;\n\n        for(auto &pp : qcnt){\n          int c = pp.second, cc = cnt[pp.first];\n          int m = 1;\n\n          if(pp.first[0] == pp.first[1] && pp.first[1] == pp.first[2] && pp.first[2] == pp.first[3]) m = 4;\n          else if(pp.first[0] == pp.first[2] && pp.first[1] == pp.first[3]) m = 2;\n\n          for(int j = 0; j < c; j++) r *= (cc - j) * m;\n        }\n\n        ans += r;\n      }\n\n      cnt[norm(B)]++;\n    }\n    cnt[norm(A)]++;\n  }\n\n  printf(\"%lld\\n\", ans / 6);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n;\nusing Panel = array<int, 4>;\n\nPanel rotate(Panel a) {\n  tie(a[0], a[1], a[2], a[3]) = make_tuple(a[1], a[2], a[3], a[0]);\n  return a;\n}\n\nPanel normalize(Panel a) {\n  Panel p[4];\n  for(int i = 0; i < 4; i++) {\n    p[i] = a;\n    a = rotate(a);\n  }\n  return *min_element(p, p + 4);\n}\n\nconst int N = 400;\n\nint rotcount(Panel a) {\n  auto b = a;\n  int res = 0;\n  for(int i = 0; i < 4; i++) {\n    b = rotate(b);\n    if(a == b) res++;\n  }\n  return res;\n}\n\nll fact[10];\nll comb[N + 1][N + 1];\n\nPanel a[N];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin >> a[i][0] >> a[i][1] >> a[i][2] >> a[i][3];\n    a[i] = normalize(a[i]);\n  }\n\n  comb[0][0] = 1;\n  for(int i = 1; i <= n; i++) for(int j = 0; j <= n; j++) {\n    // Pascal's identity\n    if(j == 0) {\n      comb[i][j] = 1;\n      continue;\n    }\n    comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n  }\n\n  fact[0] = 1;\n  for(int i = 1; i <= 9; i++) fact[i] = fact[i-1] * i;\n\n  ll ans = 0;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    dump(i, j);\n    for(int rot = 0; rot < 4; rot++) {\n      a[i] = rotate(a[i]);\n      map<Panel, int> target;\n      map<Panel, int> cnt;\n      for(int k = 0; k < 4; k++) {\n        Panel f{a[i][(k + 1) % 4], a[i][k + 0], a[j][(4 - k) % 4], a[j][(3 - k) % 4]};\n        f = normalize(f);\n        target[f]++;\n        cnt[f] = 0;\n      }\n      for(int l = 0; l < n; l++) {\n        if(l == i) continue;\n        if(l == j) continue;\n        if(target.count(a[l])) cnt[a[l]]++;\n      }\n\n      dump(target);\n      dump(cnt);\n\n      int ng = 0;\n      ll res = 1;\n      for(auto &p : target) {\n        Panel pan;\n        int tar;\n        tie(pan, tar) = p;\n        if(cnt[pan] < tar) {ng = 1; break;}\n        res *= comb[cnt[pan]][tar] * pow((ll) rotcount(pan), (ll) tar) * fact[tar];\n      }\n      if(ng) continue;\n      ans += res;\n    }\n  }\n  assert(ans % 3 == 0);\n  cout << ans/3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int Nmax = 400;\nint N, C[4][Nmax];\n\nlong encode(int c0,int c1,int c2,int c3){\n\tlong base=1000;\n\treturn c3+base*c2+base*base*c1+base*base*base*c0;\n}\n\n\nint main(){\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> C[j][i];\n\t\t}\n\t}\n\n\tmap<long, vector<int> > e2f;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tlong x = encode(C[j][i],C[(1+j)%4][i],C[(2+j)%4][i],C[(3+j)%4][i]);\n\t\t\te2f[x].push_back(i);\n\t\t}\n\t}\n\n\tlong ans = 0;\n\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tlong f[4];\n\t\t\t\tf[0] = encode(C[1][i],C[0][i],C[(k+0)%4][j],C[(k+3)%4][j]);\n\t\t\t\tf[1] = encode(C[2][i],C[1][i],C[(k+3)%4][j],C[(k+2)%4][j]);\n\t\t\t\tf[2] = encode(C[3][i],C[2][i],C[(k+2)%4][j],C[(k+1)%4][j]);\n\t\t\t\tf[3] = encode(C[0][i],C[3][i],C[(k+1)%4][j],C[(k+0)%4][j]);\n\t\t\t\tif(e2f.find(f[0]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[1]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[2]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[3]) == e2f.end()) continue;\n\t\t\t\t\t/*\n\t\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\t\tcout << f[0] << endl;\n\t\t\t\t\tcout << f[1] << endl;\n\t\t\t\t\tcout << f[2] << endl;\n\t\t\t\t\tcout << f[3] << endl;\n\t\t\t\t\t*/\n\t\t\t\tfor(auto l=e2f[f[0]].begin(); l!=e2f[f[0]].end(); l++){\n\t\t\t\t\t//cout << \" \" << *l << endl;\n\t\t\t\t\tif(*l==i || *l==j) continue;\n\t\t\t\t\tfor(auto m=e2f[f[1]].begin(); m!=e2f[f[1]].end(); m++){\n\t\t\t\t\t\t//cout << \"  \" << *m << endl;\n\t\t\t\t\t\tif(*m==i || *m==j || *m==*l) continue;\n\t\t\t\t\t\tfor(auto n=e2f[f[2]].begin(); n!=e2f[f[2]].end(); n++){\n\t\t\t\t\t\t\t//cout << \"   \" << *n << endl;\n\t\t\t\t\t\t\tif(*n==i || *n==j || *n==*l || *n==*m) continue;\n\t\t\t\t\t\t\tfor(auto o=e2f[f[3]].begin(); o!=e2f[f[3]].end(); o++){\n\t\t\t\t\t\t\t\t//cout << \"    \" << *o << endl;\n\t\t\t\t\t\t\t\tif(*o==i || *o==j || *o==*l || *o==*m || *o==*n) continue;\n\t\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans/3 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#pragma GCC optimize (\"O3\")\n#include<algorithm>\n#include<map>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nint n ;\nint s[ 405 ][ 5 ] ;\n\nll toint( int a , int b , int c , int d ) {\n  ll ret = 1000000000000000LLU ;\n  ret = min( ret , a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  ret = min( ret , b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  ret = min( ret , c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  ret = min( ret , d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  return ret ;\n}\n\nll ctint( int a , int b , int c , int d ) {\n  ll ret = 1000000000000000LLU ;\n  ret = min( ret , a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  ret = min( ret , b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  ret = min( ret , c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  ret = min( ret , d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  ll rt2 = 0 ;\n  rt2 += ( ret == a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  rt2 += ( ret == b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  rt2 += ( ret == c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  rt2 += ( ret == d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  return rt2 ;\n}\n\nll ctint( ll x ) {\n  ll a = x / 1000000000LLU ;\n  ll b = x / 1000000LLU % 1000LLU ;\n  ll c = x / 1000LLU % 1000LLU ;\n  ll d = x % 1000LLU ;\n  ll ret = 1000000000000000LLU ;\n  ret = min( ret , a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  ret = min( ret , b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  ret = min( ret , c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  ret = min( ret , d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  ll rt2 = 0 ;\n  rt2 += ( ret == a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  rt2 += ( ret == b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  rt2 += ( ret == c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  rt2 += ( ret == d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  return rt2 ;\n}\n\nmap< ll , ll > mp ;\n\nvoid init() {\n  scanf( \"%d\" , &n ) ;\n  for ( int i = 0 ; i < n ; i ++ ) {\n    for ( int j = 0 ; j < 4 ; j ++ ) {\n      scanf( \"%d\" , &s[ i ][ j ] ) ;\n    }\n    mp[ toint( s[ i ][ 0 ] , s[ i ][ 1 ] , s[ i ][ 2 ] , s[ i ][ 3 ] ) ] ++ ;\n  }\n}\n\nll ans = 0 ;\n\nll C( ll x , ll y ) {\n  ll ret = 1 ;\n  for ( ll i = 0 ; i < y ; i ++ ) {\n    ret *= x - i ;\n  }\n  return ret ;\n}\n\nll cnt( ll a , ll b , ll c , ll d ) {\n  vector< ll > v ;\n  v.push_back( 1000000000000000LLU ) ;\n  v.push_back( a ) ;\n  v.push_back( b ) ;\n  v.push_back( c ) ;\n  v.push_back( d ) ;\n  sort( v.begin() , v.end() ) ;\n  ll ret = 1 ;\n  ll ctt = 0 ;\n  for ( int i = 0 ; i < (int)v.size() - 1 ; i ++ ) {\n    ctt ++ ;\n    if ( v[ i ] != v[ i + 1 ] ) {\n      ll tret = C( mp[ v[ i ] ] , ctt ) ;\n      for ( int j = 0 ; j < (int)ctt ; j ++ )\n        tret *= ctint( v[ i ] ) ;\n      ret = ret * tret ;\n      ctt = 0 ;\n    }\n  }\n  return ret ;\n}\n\nll ans1 = 0 , ans2 = 0 ;\n\nvoid process() {\n  for ( int i = 0 ; i < n ; i ++ ) {\n    mp[ toint( s[ i ][ 0 ] , s[ i ][ 1 ] , s[ i ][ 2 ] , s[ i ][ 3 ] ) ] -- ;\n    for ( int j = 0 ; j < n ; j ++ ) if ( i != j ) {\n      mp[ toint( s[ j ][ 0 ] , s[ j ][ 1 ] , s[ j ][ 2 ] , s[ j ][ 3 ] ) ] -- ;\n\n      ans = 0 ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ) ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ) ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ) ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ) ;\n\n      ans1 += ans / 6LLU ;\n      ans2 += ans % 6 ;\n\n      mp[ toint( s[ j ][ 0 ] , s[ j ][ 1 ] , s[ j ][ 2 ] , s[ j ][ 3 ] ) ] ++ ;\n    }\n    mp[ toint( s[ i ][ 0 ] , s[ i ][ 1 ] , s[ i ][ 2 ] , s[ i ][ 3 ] ) ] ++ ;\n  }\n  ans1 += ans2 / 6 ;\n  printf( \"%lld\\n\" , ans1 ) ;\n}\n\nint main() {\n  init() ;\n  process() ;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 400\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nmap<LL,LL> mp;\nint col[MAXN+5][4];\nLL Translate(int seq[4])\n{\n\tLL x=0;\n\tfor(int i=3;i>=0;i--)\n\t\tx=1000LL*x+1LL*seq[i];\n\treturn x;\n}\nvoid Add(int seq[4],int val)//以块为单位进行计算 \n{\n\tLL num=Translate(seq);\n\tfor(int tmn=0;tmn<4;tmn++)\n\t{\n\t\tnum/=1000LL;\n\t\tnum+=seq[tmn]*1000000000LL;\n\t\tmp[num]+=val;\n\t}\n}\nLL Query(LL x)\n{\n\tif(mp.find(x)==mp.end())\n\t\treturn 0LL;\n\treturn mp[x];\n}\nvoid GetSeq(int a0,int a1,int a2,int a3,int seq[4])\n{\n\tseq[0]=a0;seq[1]=a1;seq[2]=a2;seq[3]=a3;\n}\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tAdd(col[i],1);\n\t}\n\tint val[4][4];\n\tLL ans=0,tot=0;\n\tLL ansn[4];\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int tmn=1;tmn<=4;tmn++)\n\t\t{\n\t\t\tAdd(col[i],-1LL);\n\t\t\tfor(int j=i+1;j<=N;j++)\n\t\t\t{\n\t\t\t\tAdd(col[j],-1LL);\n\t\t\t\ttot=1LL;\n\t\t\t\tGetSeq(col[j][1],col[j][0],col[i][1],col[i][0],val[0]);\n\t\t\t\tGetSeq(col[j][2],col[j][1],col[i][0],col[i][3],val[1]);\n\t\t\t\tGetSeq(col[j][0],col[j][3],col[i][2],col[i][1],val[2]);\n\t\t\t\tGetSeq(col[j][3],col[j][2],col[i][3],col[i][2],val[3]);\n\t\t\t\t//==================\n\t\t\t\tansn[0]=Query(Translate(val[0]));\n\t\t\t\tansn[1]=Query(Translate(val[1]));\n\t\t\t\tansn[2]=Query(Translate(val[2]));\n\t\t\t\tansn[3]=Query(Translate(val[3]));\n\t\t\t\tif(ansn[0]&&ansn[1]&&ansn[2]&&ansn[3])\n\t\t\t\t{\n\t\t\t\t\ttot*=Query(Translate(val[0]));\n\t\t\t\t\tAdd(val[0],-1LL);\n\t\t\t\t\ttot*=Query(Translate(val[1]));\n\t\t\t\t\tAdd(val[1],-1LL);\n\t\t\t\t\ttot*=Query(Translate(val[2]));\n\t\t\t\t\tAdd(val[2],-1LL);\n\t\t\t\t\ttot*=Query(Translate(val[3]));\n\t\t\t\t\tAdd(val[0],1LL);\n\t\t\t\t\tAdd(val[1],1LL);\n\t\t\t\t\tAdd(val[2],1LL);\n\t\t\t\t\tans+=tot;\n\t\t\t\t}\n\t\t\t\t//==================\n\t\t\t\tAdd(col[j],1LL);\n\t\t\t}\n\t\t\tAdd(col[i],1LL);\n\t\t\tint first=col[i][0];\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\tcol[i][k]=col[i][k+1];\n\t\t\tcol[i][3]=first;\n\t\t} \n\t}\n\tprintf(\"%lld\\n\",ans/3LL);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const N = 1234;\n\nint f[N][4], c[N][4];\nlong long dp[42];\nint can[42];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", c[i] + j);\n    }\n  }\n  long long ans = 0;\n  for (int first = 0; first < n; first++) {\n    for (int back = first + 1; back < n; back++) {\n      for (int rb = 0; rb < 4; rb++) {\n        for (int i = 0; i < 4; i++) {\n          f[i][0] = c[first][(i + 1) & 3];\n          f[i][1] = c[first][i];\n          f[i][2] = c[back][(-i + rb + 1) & 3];\n          f[i][3] = c[back][(-i + rb) & 3];\n        }\n        for (int i = 0; i < 1 << 4; i++) dp[i] = 0;\n        dp[0] = 1;      \n        for (int i = first + 1; i < n; i++) {\n          if (i == back) continue;          \n          for (int j = 0; j < 4; j++) {\n            can[j] = 0;\n            for (int rot = 0; rot < 4; rot++) {\n              bool ok = true;\n              for (int e = 0; e < 4; e++) {\n                if (c[i][e] != f[j][(e + rot) & 3]) {\n                  ok = false;\n                  break;\n                }\n              }\n              if (ok) ++can[j];\n            }\n          }\n          for (int mask = 15; mask >= 0; mask--) {\n            for (int j = 0; j < 4; j++) {\n              if (can[j] == 0 || ((mask >> j) & 1) == 0) continue;\n              dp[mask] += dp[mask & ~(1 << j)] * can[j];\n            }\n          }\n        }\n        ans += dp[15];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n#define MAXN 400\nLL F(LL a,LL b,LL c,LL d)\n{\n\treturn a<<30|b<<20|c<<10|d;\n}\nmap<LL,int> G;\nvoid A(LL a,int v)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tG[a]+=v;\n\t\ta=(a>>10)|((a&1023)<<30);\n\t}\n}\nint a[MAXN][8],n;\nLL r,ans,u[4];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\ta[i][j+4]=a[i][j];\n\t\t}\n\t\tA(F(a[i][0],a[i][1],a[i][2],a[i][3]),1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tA(F(a[i][0],a[i][1],a[i][2],a[i][3]),-1);\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tA(F(a[j][0],a[j][1],a[j][2],a[j][3]),-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tr=1;\n\t\t\t\tu[0]=F(a[j][k+1],a[j][k+0],a[i][1],a[i][0]);\n\t\t\t\tu[1]=F(a[j][k+0],a[j][k+3],a[i][2],a[i][1]);\n\t\t\t\tu[2]=F(a[j][k+3],a[j][k+2],a[i][3],a[i][2]);\n\t\t\t\tu[3]=F(a[j][k+2],a[j][k+1],a[i][4],a[i][3]);\n\t\t\t\tif(G[u[0]]&&G[u[1]]&&G[u[2]]&&G[u[3]])\n\t\t\t\t{\n\t\t\t\t\tr*=G[u[0]];\n\t\t\t\t\tA(u[0],-1);\n\t\t\t\t\tr*=G[u[1]];\n\t\t\t\t\tA(u[1],-1);\n\t\t\t\t\tr*=G[u[2]];\n\t\t\t\t\tA(u[2],-1);\n\t\t\t\t\tr*=G[u[3]];\n\t\t\t\t\tans+=r;\n\t\t\t\t\tA(u[0],1);\n\t\t\t\t\tA(u[1],1);\n\t\t\t\t\tA(u[2],1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tA(F(a[j][0],a[j][1],a[j][2],a[j][3]),1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) ((x)*1LL*1000000000+(y)*1000000+(z)*1000+(t))\nunordered_map<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[G(fr.x1,fr.x0,bk.x1,bk.x0)];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[G(fr.x2,fr.x1,bk.x0,bk.x3)];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[G(fr.x3,fr.x2,bk.x3,bk.x2)];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[G(fr.x0,fr.x3,bk.x2,bk.x1)];key[4].dec();\n\t\tret+=ans;\n\t\tfor(int j=1;j<=4;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\ntypedef tuple<int, int, int, int> TP;\nTP narabi(int a, int b, int c, int d) {\n\tTP kari[4];\n\tkari[0] = tie(a, b, c, d);\n\tkari[1] = tie(b, c, d, a);\n\tkari[2] = tie(c, d, a, b);\n\tkari[3] = tie(d, a, b, c);\n\treturn *min_element(kari, kari + 4);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tTP C[400];\n\tint cnum[1000] = {};\n\trep(i, N) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tC[i] = narabi(a, b, c, d);\n\t\tcnum[a]++;\n\t\tif(a != b) cnum[b]++;\n\t\tif(c != a && c != b) cnum[c]++;\n\t\tif(d != a && d != b && d != c) cnum[d]++;\n\t}\n\n\tsort(C, C + N);\n\tint kazu[400] = {};\n\trep(i, N) {\n\t\tint k = i;\n\t\twhile (k + 1 < N && C[k + 1] == C[i]) k++;\n\t\tkazu[i] = k - i + 1;\n\t\ti = k;\n\t}\n\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint inum = lower_bound(C, C + N, C[i]) - C;\n\t\tkazu[inum]--;\n\t\trep(j, N) if (i != j) {\n\t\t\tint bairitu = kazu[inum] + 1;\n\t\t\tint jnum = lower_bound(C, C + N, C[j]) - C;\n\t\t\tbairitu *= kazu[jnum]--;\n\n\t\t\tint a, b, c, d, e, f, g, h;\n\t\t\ta = get<0>(C[i]);\n\t\t\tb = get<1>(C[i]);\n\t\t\tc = get<2>(C[i]);\n\t\t\td = get<3>(C[i]);\n\t\t\te = get<0>(C[j]);\n\t\t\tf = get<1>(C[j]);\n\t\t\tg = get<2>(C[j]);\n\t\t\th = get<3>(C[j]);\n\t\t\tif (cnum[a] <= 2 || cnum[b] <= 2 || cnum[c] <= 2 || cnum[d] <= 2 || cnum[e] <= 2 || cnum[f] <= 2 || cnum[g] <= 2 || cnum[h] <= 2) {\n\t\t\t\tj += kazu[jnum]++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trep(x, 4) {\n\t\t\t\tTP D[4];\n\t\t\t\tD[0] = narabi(a, d, f, e);\n\t\t\t\tD[1] = narabi(a, e, h, b);\n\t\t\t\tD[2] = narabi(b, h, g, c);\n\t\t\t\tD[3] = narabi(c, g, f, d);\n\t\t\t\tTP* itr[4];\n\t\t\t\trep(k, 4) itr[k] = lower_bound(C, C + N, D[k]);\n\t\t\t\tll kari = bairitu;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (itr[k] != C + N && *(itr[k]) == D[k]) {\n\t\t\t\t\t\tkari *= kazu[itr[k] - C]--;\n\t\t\t\t\t\tif (get<0>(D[k]) == get<2>(D[k]) && get<1>(D[k]) == get<3>(D[k])) {\n\t\t\t\t\t\t\tkari *= 2;\n\t\t\t\t\t\t\tif (get<1>(D[k]) == get<2>(D[k])) kari *= 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tkari = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (itr[k] != C + N && *itr[k] == D[k]) {\n\t\t\t\t\t\tkazu[itr[k] - C]++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tkotae += kari;\n\n\t\t\t\tint tmp = e;\n\t\t\t\te = f;\n\t\t\t\tf = g;\n\t\t\t\tg = h;\n\t\t\t\th = tmp;\n\t\t\t}\n\t\t\tj += kazu[jnum]++;\n\t\t}\n\t\ti += kazu[inum]++;\n\t}\n\tco(kotae / 6);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(ll)(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) reps(i,0,((n)+1))\n#define repst(i,s,n) reps(i,s,((n)+1))\n#define reprt(i,n,t) for(ll (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ');}}\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 立方体の上面と底面のパネルと前者の向きを全探索\n// この2つが決まれば8頂点全ての色が確定するから残りは数え上げればいい\n// c[i]の順列のうち辞書順最小のものをハッシュ値として保存しておけば側面のパネルとして採用できる枚数がわかる\n\nint n, c[400][4], t[4], ans;\nmap<int,int> m;\n\nint id(int a, int b, int c, int d) {return (a<<30)+(b<<20)+(c<<10)+d;}\n\nvoid pl(int i, int x) {\n\tint a = i>>30, b = (i>>20)&1023, c = (i>>10)&1023, d = i&1023;\n\tm[id(a,b,c,d)] += x;\n\tm[id(d,a,b,c)] += x;\n\tm[id(c,d,a,b)] += x;\n\tm[id(b,c,d,a)] += x;\n}\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) {\n\t\trep(j,4) cin >> c[i][j];\n\t\tpl(id(c[i][0],c[i][1],c[i][2],c[i][3]), 1);\n\t}\n\trep(i,n-5) {\n\t\tpl(id(c[i][0],c[i][1],c[i][2],c[i][3]), -1);\n\t\treps(j,i+1,n) rep(d,4) {\n\t\t\t// 一つの立方体を作るときに同じパネルを採用しないように一旦使用済みにしてから元に戻す\n\t\t\tpl(id(c[j][0],c[j][1],c[j][2],c[j][3]), -1);\n\t\t\tt[0] = id(c[i][0],c[j][(0+d)%4],c[j][(3+d)%4],c[i][1]);\n\t\t\tt[1] = id(c[i][1],c[j][(3+d)%4],c[j][(2+d)%4],c[i][2]);\n\t\t\tt[2] = id(c[i][2],c[j][(2+d)%4],c[j][(1+d)%4],c[i][3]);\n\t\t\tt[3] = id(c[i][3],c[j][(1+d)%4],c[j][(0+d)%4],c[i][0]);\n\t\t\tif (m[t[0]]&&m[t[1]]&&m[t[2]]&&m[t[3]]) {\n\t\t\t\tint tmp = 1;\n\t\t\t\t// ここも同様\n\t\t\t\trep(l,4) tmp *= m[t[l]], pl(t[l],-1);\n\t\t\t\tans += tmp;\n\t\t\t\trep(l,4) pl(t[l],1);\n\t\t\t}\n\t\t\tpl(id(c[j][0],c[j][1],c[j][2],c[j][3]), 1);\n\t\t}\n\t}\n\tcout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int mod = 1e9 + 7;\n\nint N;\nint c[405][4];\nLL hsh[405];\n\nmap<LL, int> mp;\n\nint power(int x, int y)\n{\n    if(y <= 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvector<int> getBest(vector<int> cl)\n{\n    vector<int> bst = cl;\n    for(int j = 0; j < 4; j++)\n    {\n        cl.insert(cl.begin(), cl.back());\n        cl.pop_back();\n        if(bst > cl)    bst = cl;\n    }\n    return bst;\n}\n\nint rotateCount(vector<int> cl)\n{\n    LL h = cl[0] + LL(1e3) * cl[1] + LL(1e6) * cl[2] + LL(1e9) * cl[3];\n    int cnt = 0;\n    for(int j = 0; j < 4; j++)\n    {\n        cl.insert(cl.begin(), cl.back());\n        cl.pop_back();\n        LL h2 = cl[0] + LL(1e3) * cl[1] + LL(1e6) * cl[2] + LL(1e9) * cl[3];\n        cnt += (h == h2);\n    }\n    return cnt;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i <= N; i++)\n    {\n        vector<int> cl;\n        for(int j = 0; j < 4; j++)\n        {\n            int x; scanf(\"%d\", &x);\n            cl.push_back(x);\n        }\n\n        vector<int> bst = getBest(cl);\n        for(int j = 0; j < 4; j++)  c[i][j] = bst[j];\n\n        hsh[i] = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n        mp[ hsh[i] ]++;\n    }\n\n    int ans = 0;\n    for(int i = 1; i < N; i++)\n        for(int j = i + 1; j <= N; j++)\n            for(int d = 0; d < 4; d++)\n            {\n                mp[ hsh[i] ]--; mp[ hsh[j] ]--;\n                swap(c[j][1], c[j][3]);\n\n                int sol = 1, lst = -1;\n                for(int k = 0; k < 4; k++)\n                {\n                    vector<int> cl;\n                    cl.push_back(c[i][k]);\n                    cl.push_back(c[j][(k + d) % 4]);\n                    cl.push_back(c[j][(k + d + 1) % 4]);\n                    cl.push_back(c[i][(k + 1) % 4]);\n\n                    vector<int> bst = getBest(cl);\n                    LL h = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n\n                    if(!mp.count(h)) { sol = 0; break; }\n                    int cnt = mp[h];\n                    if(cnt <= 0) { sol = 0; break; }\n\n                    mp[h]--;\n                    sol = (1LL * sol * cnt) % mod;\n\n                    cnt = rotateCount(bst);\n                    sol = (1LL * sol * cnt) % mod;\n\n                    lst = k;\n                }\n\n                ans = ans + sol; if(ans >= mod) ans -= mod;\n\n                for(int k = 0; k <= lst; k++)\n                {\n                    vector<int> cl;\n                    cl.push_back(c[i][k]);\n                    cl.push_back(c[j][(k + d) % 4]);\n                    cl.push_back(c[j][(k + d + 1) % 4]);\n                    cl.push_back(c[i][(k + 1) % 4]);\n\n                    vector<int> bst = getBest(cl);\n                    LL h = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n\n                    mp[h]++;\n                }\n\n                swap(c[j][1], c[j][3]);\n                mp[ hsh[i] ]++; mp[ hsh[j] ]++;\n            }\n\n    ans = (1LL * ans * power(3, mod - 2)) % mod;\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\ntypedef tuple<int, int, int, int> P;\n\ntemplate<class T>\nstruct Dictionary {\n\tvector<T> dat;\n\tvector<int> cnt;\n\n\tvoid build() {\n\t\tsort(dat.begin(), dat.end());\n\t\tdat.erase(unique(dat.begin(), dat.end()), dat.end());\n\t\tcnt.resize(dat.size());\n\t}\n\n\tint index_of(T v) {\n\t\treturn lower_bound(dat.begin(), dat.end(), v) - dat.begin();\n\t}\n\n\tint operator[](T v) {\n\t\tint k = index_of(v);\n\t\tif (k < dat.size() && dat[k] == v) return cnt[k];\n\t\telse return 0;\n\t}\n\n\tvoid add(T v, int d) {\n\t\tcnt[index_of(v)] += d;\n\t}\n};\n\nP rot(P p) {\n\tint a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn make_tuple(b, c, d, a);\n}\n\nlong long modpow(long long a, long long b, long long mod) {\n\tif (b == 0) return 1;\n\treturn modpow(a * a % mod, b / 2, mod) * (b & 1 ? a : 1) % mod;\n}\n\nlong long modinv(long long a, long long mod) {\n\treturn modpow(a, mod - 2, mod);\n}\n\nint mul(int x, int y) {\n\treturn int64_t(x) * y % mod;\n}\n\nint add(int x, int y) {\n\treturn (x + y) % mod;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n * 4), b(n * 4), c(n * 4), d(n * 4);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 4] >> b[i * 4] >> c[i * 4] >> d[i * 4];\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\ta[i * 4 + j] = d[i * 4 + j - 1];\n\t\t\tb[i * 4 + j] = a[i * 4 + j - 1];\n\t\t\tc[i * 4 + j] = b[i * 4 + j - 1];\n\t\t\td[i * 4 + j] = c[i * 4 + j - 1];\n\t\t}\n\t}\n\tn *= 4;\n\n\tDictionary<P> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp.dat.emplace_back(a[i], b[i], c[i], d[i]);\n\t}\n\tmp.build();\n\tfor (int i = 0; i < n; i++) {\n\t\tmp.add(make_tuple(a[i], b[i], c[i], d[i]), 1);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i / 4 == j / 4) continue;\n\t\t\tP x(a[i], b[i], c[i], d[i]);\n\t\t\tP y(a[j], b[j], c[j], d[j]);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp.add(x, -1);\n\t\t\t\tmp.add(y, -1);\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tP p[4];\n\t\t\tp[0] = P(d[j], c[j], b[i], a[i]);\n\t\t\tp[1] = P(b[i], c[j], b[j], c[i]);\n\t\t\tp[2] = P(d[j], a[i], d[i], a[j]);\n\t\t\tp[3] = P(d[i], c[i], b[j], a[j]);\n\n\t\t\tint cnt = 1;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt = mul(cnt, mp[p[k]]);\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp.add(p[k], -1);\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp.add(p[k], 1);\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp.add(x, 1);\n\t\t\t\tmp.add(y, 1);\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tans = add(ans, cnt);\n\t\t}\n\t}\n\tcout << mul(ans, modinv(24, mod)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n \n#define REP(i,n) for(int(i)=0;(i)<(int)(n);(i)++)\n\n#include <vector>\n#include <utility>\n\n\n#include <algorithm>\n\n\nint n;\nint c[410][4];\nint tgt[4][4];\nlong long dp[16];\nint can[4];\n\nbool ok(int from, int dest) {\n\tfor (int i = 0; i < 4; i++) if (c[from][i] != tgt[dest][i]) return false;\n\treturn true;\n}\n\nvoid rotate(int idx) {\n\tint t = c[idx][3];\n\tfor (int i = 2; i >= 0; i--) c[idx][i+1] = c[idx][i];\n\tc[idx][0] = t;\n}\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tREP(i,n) REP(j,4) scanf(\"%d\", &c[i][j]);\n\t\n\tlong long ans = 0;\n\n\tREP(front, n) {\n\t\tfor (int back = 0; back < front; back++) {\n\t\t\tfor (int ro = 0; ro < 4; ro++) {\n\n\t\t\t\ttgt[0][0] = c[front][0];\n\t\t\t\ttgt[0][1] = c[back][1];\n\t\t\t\ttgt[0][2] = c[back][0];\n\t\t\t\ttgt[0][3] = c[front][1];\n\n\t\t\t\ttgt[1][0] = c[front][1];\n\t\t\t\ttgt[1][1] = c[back][0];\n\t\t\t\ttgt[1][2] = c[back][3];\n\t\t\t\ttgt[1][3] = c[front][2];\n\n\t\t\t\ttgt[2][0] = c[front][3];\n\t\t\t\ttgt[2][1] = c[front][2];\n\t\t\t\ttgt[2][2] = c[back][3];\n\t\t\t\ttgt[2][3] = c[back][2];\n\n\t\t\t\ttgt[3][0] = c[back][1];\n\t\t\t\ttgt[3][1] = c[front][0];\n\t\t\t\ttgt[3][2] = c[front][3];\n\t\t\t\ttgt[3][3] = c[back][2];\n\n\t\t\t\t/*if (front == 4 && back == 0) {\n\t\t\t\t\tREP(i,4) {\n\t\t\t\t\t\tREP(j,4) printf(\"%d \", tgt[i][j]);\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}*/\n\n\t\t\t\tREP(bm,16) dp[bm] = 0;\n\t\t\t\tdp[0]=1;\n\n\t\t\t\tfor (int ot = 0; ot < front; ot++) if (ot != back) {\n\t\t\t\t\tREP(i,4) can[i] = 0;\n\t\t\t\t\tfor (int rr = 0; rr < 4; rr++) {\n\t\t\t\t\t\tfor (int i = 0; i < 4; i++) can[i] += ok(ot, i);\n\t\t\t\t\t\trotate(ot);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int bm = 15; bm >= 0; bm--) {\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) if ((1<<bit)&bm) {\n\t\t\t\t\t\t\tdp[bm] += dp[bm ^ (1<<bit)] * can[bit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans += dp[15];\n\t\t\t\trotate(back);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n\n\nint main() {\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nclass Tile {\nprivate:\n    vector<ll> h, c;\npublic:\n    Tile(const vector<ll>& c) : c(c), h(0) {\n        REP(i, 4) {\n            h.pb( hash(i) );\n        }\n    }\n    ll hash(int d = 4) const {\n        if (d < h.size()) return h[d];\n        if (d == 4) {\n            ll res = linf;\n            REP(i, 4) {\n                res = min(res, hash(i));\n            }\n            return res;\n        }\n        else {\n            ll res = 0;\n            REP(i, 4) {\n                res = res * 1000 + c[(i+d)%4];\n            }\n            return res;\n        }\n    }\n    ll pattern() const {\n        if ( hash(0) == hash(1) ) return 4;\n        if ( hash(0) == hash(2) ) return 2;\n        return 1;\n    }\n    ll color(int idx) const {\n        return c[(idx%c.size()+c.size())%c.size()];\n    }\n};\nbool operator==(const Tile& t1, const Tile& t2) {\n    return t1.hash() == t2.hash();\n}\nbool operator<(const Tile& t1, const Tile& t2) {\n    return t1.hash() < t2.hash();\n}\n\nll comb(ll n, ll r) {\n    if (r > n) return 0;\n    ll res = 1;\n    REP(i, r) {\n        res *= (n-i);\n    }\n    FOR(i, 1, r+1) {\n        res /= i;\n    }\n    return res;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    REP(i, n) res *= x;\n    return res;\n}\nll fact(ll n) {\n    ll res = 1;\n    FOR(i, 1, n+1) res *= i;\n    return res;\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    vector<Tile> T;\n    REP(i, n) {\n        vector<ll> v(4); cin >> v;\n        T.pb( Tile(v) );\n    }\n    map<Tile, ll> m;\n    REP(i, n) m[T[i]]++;\n    ll ans = 0;\n    REP(i, n) REP(j, n) REP(ofs, 4) {\n        if (i == j) continue;\n        const Tile& t1 = T[i];\n        const Tile& t2 = T[j];\n        map<Tile, int> need;\n        REP(k, 4) {\n            need[ Tile({t1.color(ofs+k+1), t1.color(ofs+k), t2.color(-k+1), t2.color(-k)}) ]++;\n        }\n        --m[t1];\n        --m[t2];\n        ll da = 1;\n        EACH(p, need) {\n            if (m.count(p.first) > 0) {\n                // cout << m[p.first] << \" \" << p.second << \" \" << comb(m[p.first], p.second) << endl;\n                da *= comb(m[p.first], p.second) * power(p.first.pattern(), p.second) * fact(p.second);\n            }\n            else {\n                da = 0;\n            }\n        }\n        // if (da > 0) cout << i << \" \" << j << endl;\n        ++m[t1];\n        ++m[t2];\n        ans += da;\n    }\n    assert(ans % 6 == 0);\n    ans /= 6;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pw(x) (1ll << (x))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\n#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n\n//-----\nconst int N = 4e2 + 7;\nll nxt(ll d) { return d / 1000 + (d % 1000) * 1000000000; }\nmap<ll, int > cnt;\nvoid chg(ll d, int v) { rep(i, 0, 4) { cnt[d] += v; d = nxt(d); } }\n\nll v2d(vi v) { ll d = 0; rep(i, 0, 4) d = d * 1000 + v[i]; return d; }\nvi d2v(ll d) { vi v(4); per(i, 0, 4) v[i] = d % 1000, d /= 1000; return v; }\n\nint n;\nll c[N];\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tcin >> n;\n\trep(i, 0, n) {\n\t\tvi v(4); rep(j, 0, 4) cin >> v[j];\n\t\tc[i] = v2d(v);\n\t\tchg(c[i], 1);\n\t}\n\tll ans = 0;\n\trep(i, 0, n) {\n\t\tchg(c[i], -1);\n\t\tll ci = c[i];\n\t\trep(di, 0, 4) {\n\t\t\tvi a = d2v(ci); ci = nxt(ci);\n\t\t\trep(j, 0, n) if (j != i) {\n\t\t\t\tchg(c[j], -1);\n\t\t\t\tll cj = c[j];\n\t\t\t\trep(dj, 0, 4) {\n\t\t\t\t\tvi b = d2v(cj); cj = nxt(cj);\n\t\t\t\t\tbool show = (i == 2 && j == 4 && di == 0 && dj == 0);\n\t\t\t\t\tll up = v2d({b[1], b[0], a[1], a[0]});\n\t\t\t\t\tll dn = v2d({a[3], a[2], b[3], b[2]});\n\t\t\t\t\tll lf = v2d({b[1], a[0], a[3], b[2]});\n\t\t\t\t\tll rt = v2d({a[1], b[0], b[3], a[2]});\n\t\t\t\t\tll tmp = 1;\n\t\t\t\t\ttmp *= cnt[up]; chg(up, -1);\n\t\t\t\t\ttmp *= cnt[dn]; chg(dn, -1);\n\t\t\t\t\ttmp *= cnt[lf]; chg(lf, -1);\n\t\t\t\t\ttmp *= cnt[rt]; \n\t\t\t\t\tans += tmp;\n\t\t\t\t\tchg(lf, 1);\n\t\t\t\t\tchg(dn, 1);\n\t\t\t\t\tchg(up, 1);\n\t\t\t\t}\n\t\t\t\tchg(c[j], 1);\n\t\t\t}\n\t\t}\n\t\tchg(c[i], 1);\n\t}\n\tassert(ans % 24 == 0);\n\tcout << ans / 24;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint a[maxn], b[maxn], c[maxn], d[maxn];\nstd::unordered_map<ll, int> map;\nint n;\ninline ll pr(int a,int b,int c,int d) { return (ll) (a << 16 | b) << 32 | (c << 16 | d); }\ninline ll minpr(int a,int b,int c,int d) {\n\treturn std::min(std::min(pr(a, b, c, d), pr(b, c, d, a)), std::min(pr(c, d, a, b), pr(d, a, b, c)));\n}\ninline void swap(int & a,int & b,int & c,int & d) { int t = a; a = b, b = c, c = d, d = t; }\ninline void add(int a,int b,int c,int d,int v) { map[minpr(a, b, c, d)] += v; }\ninline ll C(int x,int v) {\n\tif(v == 1) return x;\n\tif(v == 2) return x * (x - 1);\n\tif(v == 3) return x * (x - 1) * (x - 2);\n\treturn (ll) x * (x - 1) * (x - 2) * (x - 3);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tmap.rehash(1e6 + 7);\n\tcin >> n;\n\trep(i, 1, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tadd(a[i], b[i], c[i], d[i], 1);\n\t}\n\tll ans = 0;\n\trep(i, 1, n) rep(j, 1, i - 1) {\n\t\tadd(a[i], b[i], c[i], d[i], -1);\n\t\tadd(a[j], b[j], c[j], d[j], -1);\n\t\tfor(int t = 0;t < 4;++t) {\n\t\t\tstd::map<ll, int> mp;\n\t\t\t++ mp[minpr(b[j], a[j], b[i], a[i])];\n\t\t\t++ mp[minpr(a[j], d[j], c[i], b[i])];\n\t\t\t++ mp[minpr(d[j], c[j], d[i], c[i])];\n\t\t\t++ mp[minpr(c[j], b[j], a[i], d[i])];\n\t\t\tll mul = 1;\n\t\t\tfor(auto i : mp) {\n\t\t\t\tif(i.first >> 16 == i.first << 16 >> 16) mul <<= i.second;\n\t\t\t\tif(i.first >> 32 == i.first << 32 >> 32) mul <<= i.second;\n\t\t\t\tmul *= C(map[i.first], i.second);\n\t\t\t}\n\t\t\tans += mul;\n\t\t\tswap(a[i], b[i], c[i], d[i]);\n\t\t}\n\t\tadd(a[i], b[i], c[i], d[i], 1);\n\t\tadd(a[j], b[j], c[j], d[j], 1);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nmap<LL,LL> colorCount;\n\nLL tolong(LL c0,LL c1,LL c2,LL c3){\n    return (c0*1000000000LL+ c1*1000000LL +c2*1000LL +c3);\n}\n\nvoid toc(LL num,LL &c0, LL &c1,LL &c2,LL &c3){\n    c0 = num/1000000000LL;\n    num %= 1000000000LL;\n    c1 = num/1000000LL;\n    num%= 1000000LL;\n    c2 = num/1000LL;\n    num%=1000LL;\n    c3 = num;\n}\n\nvoid add(LL c0,LL c1,LL c2,LL c3){\n    colorCount[tolong(c0,c1,c2,c3)]+=1;\n    colorCount[tolong(c3,c0,c1,c2)]+=1;\n    colorCount[tolong(c2,c3,c0,c1)]+=1;\n    colorCount[tolong(c1,c2,c3,c0)]+=1;\n}\n\nvoid sub(LL c0,LL c1,LL c2,LL c3){\n    colorCount[tolong(c0,c1,c2,c3)]-=1;\n    colorCount[tolong(c3,c0,c1,c2)]-=1;\n    colorCount[tolong(c2,c3,c0,c1)]-=1;\n    colorCount[tolong(c1,c2,c3,c0)]-=1;\n}\n\nint main(){\n\n    int N;cin>>N;\n    LL color[N];\n    REP(i,N){\n        LL c0,c1,c2,c3;\n        cin>>c0>>c1>>c2>>c3;\n        add(c0,c1,c2,c3);\n        color[i]=tolong(c0,c1,c2,c3);\n    }\n\n\n    LL col[4];\n    LL a,b,c,d,e,f,g,h;\n    LL ans = 0;\n    REP(i,N){\n        toc(color[i],col[0],col[1],col[2],col[3]);\n        sub(col[0],col[1],col[2],col[3]);\n        a = col[0],b=col[1],c=col[2],d=col[3];\n        REP(j,N){\n            if(i==j)continue;\n            toc(color[j],col[0],col[1],col[2],col[3]);\n            sub(col[0],col[1],col[2],col[3]);\n            REP(k,4){\n                LL T = 1;\n                e = col[(k)%4],h = col[(k+1)%4],g =col[(k+2)%4],f = col[(k+3)%4];\n                T *= colorCount[tolong(e,f,b,a)];\n                sub(e,f,b,a);\n                T *= colorCount[tolong(f,g,c,b)];\n                sub(f,g,c,b);\n                T*= colorCount[tolong(g,h,d,c)];\n                sub(g,h,d,c);\n                T *= colorCount[tolong(h,e,a,d)];\n                sub(h,e,a,d);\n\n                ans += T;\n                add(e,f,b,a);\n                add(f,g,c,b);\n                add(g,h,d,c);\n                add(h,e,a,d);\n            }\n            add(col[0],col[1],col[2],col[3]);\n        }\n        toc(color[i],col[0],col[1],col[2],col[3]);\n        add(col[0],col[1],col[2],col[3]);\n    }\n\n    cout<<ans/6<<endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan in Ubuntu 18.10 on 2018/10/21 using VIM\n//版权所有，翻印必究\n\ntypedef pair<pii,pii> pp;\nint n;\nint C[405][5];\nmap<pp,int> m;\n\npp mp(int a,int b,int c,int d){\n\treturn mp(mp(a,b),mp(c,d));\n}\n\nvoid ins(int a,int b,int c,int d){\n\tm[mp(a,b,c,d)]++;\n\tm[mp(b,c,d,a)]++;\n\tm[mp(c,d,a,b)]++;\n\tm[mp(d,a,b,c)]++;\n}\n\nint same(pp p,pp q){\n\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\tint ans=0;\n\tif(q==mp(a,b,c,d)){\n\t\tans++;\n\t}\n\tif(q==mp(b,c,d,a)){\n\t\tans++;\n\t}\n\tif(q==mp(c,d,a,b)){\n\t\tans++;\n\t}\n\tif(q==mp(d,a,b,c)){\n\t\tans++;\n\t}\n\treturn ans;\n}\n\nvector<pp> v;\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>C[i][0]>>C[i][1]>>C[i][2]>>C[i][3];\n\t}\n\tINT ans=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=0;j<SZ(v);j++){\n\t\t\tpp p=v[j];\n\t\t\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\t\t\tpp m1=mp(b,a,C[i][0],C[i][1]);\n\t\t\tpp m2=mp(c,b,C[i][1],C[i][2]);\n\t\t\tpp m3=mp(d,c,C[i][2],C[i][3]);\n\t\t\tpp m4=mp(a,d,C[i][3],C[i][0]);\n\t\t\tINT res=1;\n\t\t\tres*=m[m1]-same(p,m1);\n\t\t\tint fAck=same(m1,m2);\n\t\t\tres*=m[m2]-same(p,m2)-fAck;\n\t\t\tint fBck=same(m1,m3)+same(m2,m3);\n\t\t\tres*=m[m3]-same(p,m3)-fBck;\n\t\t\tint fCck=same(m1,m4)+same(m2,m4)+same(m3,m4);\n\t\t\tres*=m[m4]-same(p,m4)-fCck;\n\t\t\tans+=res;\n\t\t}\n\t\tint a=C[i][3],b=C[i][2],c=C[i][1],d=C[i][0];\n\t\tins(a,b,c,d);\n\t\tv.pb(mp(a,b,c,d));\n\t\tv.pb(mp(b,c,d,a));\n\t\tv.pb(mp(c,d,a,b));\n\t\tv.pb(mp(d,a,b,c));\n\t}\n\tfio<<ans<<endl;\n\treturn 0;\n}\n/*F*U*C*K*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define hash(a,b,c,d) ((((LL(a)*1000+b)*1000)+c)*1000+d)\nusing namespace std;\n\ntypedef long long LL;\nint n,a[410][4];\nLL ans,w[410];\nmap<LL,int> cnt,s;\n\nvoid rotate(int *a)\n{\n    int t=a[0];\n    a[0]=a[1],a[1]=a[2],a[2]=a[3],a[3]=t;\n}\n\nLL c(int n,int m)\n{\n    if (n<0)\n        return 0;\n    LL ret=1;\n    repu(i,1,m)\n        ret=LL(n-i+1)*ret;\n    return ret;\n}\n\nLL get(int a,int b,int c,int d)\n{\n    return min(min(hash(a,b,c,d),hash(b,c,d,a)),min(hash(c,d,a,b),hash(d,a,b,c)));\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n)\n    {\n        repu(j,0,3)\n            scanf(\"%d\",&a[i][j]);\n        LL t[4];\n        repu(j,1,i-1)\n            repu(k,0,3)\n            {\n                t[0]=get(a[i][0],a[j][1],a[j][0],a[i][1]);\n                t[1]=get(a[i][1],a[j][0],a[j][3],a[i][2]);\n                t[2]=get(a[i][3],a[i][2],a[j][3],a[j][2]);\n                t[3]=get(a[j][1],a[i][0],a[i][3],a[j][2]);\n                sort(t,t+4);\n                LL sum=1;\n                repu(l,0,3)\n                    sum*=s[t[l]];\n                for (int ii=0,jj; ii<4; ii=jj)\n                {\n                    for (jj=ii; jj<4 && t[ii]==t[jj]; ++jj);\n                    sum*=c(cnt[t[ii]]-(t[ii]==w[j]),jj-ii);\n                }\n                ans+=sum,rotate(a[j]);\n            }\n        repu(j,0,3)\n            t[j]=hash(a[i][0],a[i][1],a[i][2],a[i][3]),rotate(a[i]);\n        ++cnt[w[i]=min(min(t[0],t[1]),min(t[2],t[3]))];\n        repu(j,0,3)\n            s[t[j]]=(t[0]==t[j])+(t[1]==t[j])+(t[2]==t[j])+(t[3]==t[j]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n//emplace_back next_permutation tie get\n\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define OUT(a) cout<<(a)<<endl;\n\nvoid myrot(vector<int> &a){\n    auto it=a.end()-1;\n    REPN(i,2,a.size()-1){\n        if(*(a.end()-i)<*it or (it==a.end()-i+1 and *it==*(a.end()-i))) it=a.end()-i;\n    }\n    rotate(a.begin(),it,a.end());\n    if(a[0]==a[2] && a[1]>a[3]) swap(a[1],a[3]);\n    return;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    map<vector<int>,int> a;\n    LL ans=0;\n    int n; cin >> n;\n    vector<vector<int>> c(n,vector<int>(4));\n    REP(i,n){\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        myrot(c[i]);\n        a[c[i]]++;\n    }\n    REP(i,n){\n        FOR(j,i+1,n){\n            a[c[i]]--;\n            a[c[j]]--;\n            //a.erase(c[i]);\n            //a.erase(c[j]);\n            vector<vector<int>> sid(4,vector<int>(4));\n            REP(k,4){\n                bool e[4]={};\n                LL tmp=1;\n                REP(l,4){\n                    sid[l][0]=c[i][l];\n                    sid[l][1]=c[j][(1-l+4)%4];\n                    sid[l][2]=c[j][(-l+4)%4];\n                    sid[l][3]=c[i][(l+1)%4];\n                }\n                REP(l,4) myrot(sid[l]);\n                REP(l,4){\n                    //int cnt=a.count(sid[l]);\n                    int cnt=a[sid[l]];\n                    tmp*=cnt;\n                    if(cnt>0){\n                        //a.erase(sid[l]);\n                        a[sid[l]]--;\n                        e[l]=true;\n                    }\n                    if(sid[l][0]==sid[l][3]) tmp*=4;\n                    else if (sid[l][0]==sid[l][2] && sid[l][1]==sid[l][3]) tmp*=2;\n                }\n                //REP(l,4) if(e[l]) a.insert(sid[l]);\n                REP(l,4) if(e[l]) a[sid[l]]++;\n                ans+=tmp;\n                /*if(tmp>0){\n                    cout << i <<' '<< j << endl;\n                    REP(l,4)cout << c[i][l]<< ' ';\n                    REP(l,4)cout << c[j][l]<< ' ';\n                    cout << tmp<<endl;\n                }*/\n                rotate(c[j].begin(),c[j].begin()+1,c[j].end());\n            }\n            a[c[i]]++;\n            a[c[j]]++;\n\n            //a.insert(c[i]);\n            //a.insert(c[j]);\n        }\n        //a.erase(c[i]);\n        a[c[i]]--;\n\n    }\n    cout <<ans <<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 400;\nusing namespace std;\n\nmap <long long, int> mymap;\nint n;\nlong long a[N], ans;\n\nlong long po(int x){\n    if (x == 0) return 1;\n    if (x == 1) return 1000;\n    if (x == 2) return 1000000;\n    if (x == 3) return 1000000000;\n}\n\nlong long rotate(long long x){\n    long long t = x % po(1); x /= po(1);\n    x += t * po(3);\n    return x;\n}\n\nlong long get(long long a, int num){\n    return (a / po(num)) % 1000;\n}\n\nlong long reverse(long long x){\n    long long y = get(x, 0) * po(3) + get(x, 1) * po(2) + get(x, 2) * po(1) + get(x, 3) * po(0);\n    return y;\n}\n\nint main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        int x, y, z, t;\n        cin >> x >> y >> z >> t;\n        a[i] = 1LL * x * 1000000000 + 1LL * y * 1000000 + 1LL * z * 1000 + t;\n        mymap[a[i]]++;\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j < i; j++){\n            mymap[a[i]]--; mymap[a[j]]--;\n            long long x = reverse(a[j]);\n            for (int k = 0; k < 4; k++){\n                long long cnt = 0, mul = 1;\n                for (int h = 0; h < 4; h++){\n                    long long color = 0, cnt = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    for (int l = 0; l < 4; l++) cnt += mymap[color], color = rotate(color);\n                    mul *= cnt;\n                    mymap[color]--;\n                }\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    mymap[color]++;\n                }\n                ans += mul;\n                x = rotate(x);\n            }\n            mymap[a[i]]++; mymap[a[j]]++;\n        }\n    }\n    ans /= 3;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\ntypedef long long s64;\n\nstruct object\n{\n\tint a, b, c, d;\n\tobject() {}\n\tobject(const int &_a, const int &_b, const int &_c, const int &_d)\n\t\t: a(_a), b(_b), c(_c), d(_d) {}\n\n\tinline s64 value() const\n\t{\n\t\treturn ((s64)a << 30) | (b << 20) | (c << 10) | d;\n\t}\n\n\tinline object rotate() const\n\t{\n\t\treturn {b, c, d, a};\n\t}\n};\nmap<s64, int> all;\n\ninline void add(object cur, int delta)\n{\n\tfor (int k = 0; k < 4; ++k)\n\t\tall[(cur = cur.rotate()).value()] += delta;\n}\n\ninline int query(const object &a)\n{\n\treturn all[a.value()];\n}\n\nconst int MaxN = 400;\n\nint n;\nobject f[MaxN + 1];\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> f[i].a >> f[i].b;\n\t\tcin >> f[i].c >> f[i].d;\n\t\tadd(f[i], 1);\n\t}\n\n\ts64 res = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tadd(f[i], -1);\n\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tadd(f[j], -1);\n\n\t\t\tobject cur = f[j];\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t{\n\t\t\t\tobject f1(cur.b, cur.a, f[i].b, f[i].a);\n\t\t\t\tobject f2(cur.a, cur.d, f[i].c, f[i].b);\n\t\t\t\tobject f3(cur.d, cur.c, f[i].d, f[i].c);\n\t\t\t\tobject f4(cur.c, cur.b, f[i].a, f[i].d);\n\n\t\t\t\ts64 ways = 1;\n\t\t\t\tways *= query(f1), add(f1, -1);\n\t\t\t\tways *= query(f2), add(f2, -1);\n\t\t\t\tways *= query(f3), add(f3, -1);\n\t\t\t\tways *= query(f4);\n\n\t\t\t\tadd(f1, 1), add(f2, 1), add(f3, 1);\n\n\t\t\t\tres += ways;\n\n\t\t\t\tcur = cur.rotate();\n\t\t\t}\n\n\t\t\tadd(f[j], 1);\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 405;\nusing namespace std;\n\nmap <long long, int> mymap;\nint n;\nlong long a[N], ans;\n\nlong long po(int x){\n    if (x == 0) return 1;\n    if (x == 1) return 1000;\n    if (x == 2) return 1000000;\n    if (x == 3) return 1000000000;\n}\n\nlong long rotate(long long x){\n    long long t = x % po(1); x /= po(1);\n    x += t * po(3);\n    return x;\n}\n\nlong long get(long long a, int num){\n    return (a / po(num)) % 1000;\n}\n\nlong long reverse(long long x){\n    long long y = get(x, 0) * po(3) + get(x, 1) * po(2) + get(x, 2) * po(1) + get(x, 3) * po(0);\n    return y;\n}\n\nint main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        int x, y, z, t;\n        cin >> x >> y >> z >> t;\n        a[i] = 1LL * x * 1000000000 + 1LL * y * 1000000 + 1LL * z * 1000 + t;\n        mymap[a[i]]++;\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j < i; j++){\n            mymap[a[i]]--; mymap[a[j]]--;\n            long long x = reverse(a[j]);\n            for (int k = 0; k < 4; k++){\n                long long cnt = 0, mul = 1;\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    int cnt = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    bool ck = 1;\n                    for (int l = 0; l < 4; l++) {\n                        if (mymap.count(color)) {\n                            cnt += mymap[color];\n                            if (ck) mymap[color]--, ck = 0;\n                        }\n                        color = rotate(color);\n                    }\n                    mul *= cnt;\n                }\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    for (int l = 0; l < 4; l++) {\n                        if (mymap.count(color)) {\n                            mymap[color]++; break;\n                        }\n                        color = rotate(color);\n                    }\n                }\n                ans += mul;\n                x = rotate(x);\n            }\n            mymap[a[i]]++; mymap[a[j]]++;\n        }\n    }\n    ans /= 3;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define uint unsigned long long\n#define ll long long\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define eps 1e-9\n\nusing namespace std;\nconst db pi = acos(-1.0);\ninline int read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\n#define Node(a, b, c, d) mp(a,mp(b,mp(c,d)))\nmap <pair<int, pair<int, pii> >, ll> cnt;\nconst int N = 500;\n\nint A[N][4];\nint n, num[4];\n\nvoid fz(pair<int, pair<int,pii> > t)\n{\n    num[0] = t.X;\n    num[1] = t.Y.X;\n    num[2] = t.Y.Y.X;\n    num[3] = t.Y.Y.Y;\n}\n\npair<int, pair<int,pii> > stand(pair<int, pair<int,pii> > t)\n{\n\n    pair<int, pair<int,pii> > tmp[4];\n    rep(s, 0, 3)\n        tmp[s] = Node(num[(s + 0) % 4], num[(s + 1) % 4], num[(s + 2) % 4], num[(s + 3) % 4]);\n    sort(tmp, tmp + 4);\n    return tmp[0];\n\n}\n\nvoid update(int id,int val)\n{\n    pair<int, pair<int,pii> > now = stand(Node(A[id][0], A[id][1], A[id][2], A[id][3]));\n    cnt[now] += val;\n}\n\nint cal(pair<int, pair<int,pii> > t)\n{\n    int num[4];\n    num[0] = t.X;\n    num[1] = t.Y.X;\n    num[2] = t.Y.Y.X;\n    num[3] = t.Y.Y.X;\n    pair<int, pair<int,pii> > tmp[4];\n    rep(s, 0, 3) tmp[s] = Node(num[(s + 0) % 4], num[(s + 1) % 4], num[(s + 2) % 4], num[(s + 3) % 4]);\n    int c = 0;\n    rep(s, 0, 3) if(tmp[s] == tmp[0]) c ++;\n    return c;\n\n}\n\nint main()\n{\n    n = read();\n    rep(i, 1, n)\n    {\n        rep(j, 0, 3) A[i][j] = read();\n        update(i, 1);\n    }\n\n    ll res = 0;\n    rep(i, 1, n)\n    {\n        update(i, -1);\n        rep(j, i + 1, n)\n        {\n            update(j, -1);\n            int Down[4];\n            rep(x, 0, 3) Down[x] = A[i][x];\n            int Up[4];\n            rep(us, 0, 3)\n            {\n            \trep(y, 0, 3) Up[y] = A[j][(us - y + 4) % 4];\n                ll now = 1;\n                pair<int, pair<int,pii> > X[4];\n                rep(k, 0, 3)\n                {\n                    X[k] = stand(Node(Down[k], Up[k], Up[(k + 1) % 4], Down[(k + 1) % 4]));\n                    ll num = cal(X[k]);\n                    now *= num * cnt[X[k]];\n                    cnt[X[k]] --;\n                }\n\n                res += now;\n\t \trep(k, 0, 3) cnt[X[k]] ++;\n            }\n            update(j, 1);\n        }\n        update(i, 1);\n    }\n    printf(\"%lld\\n\",res / 3);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<short,short> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,ll> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,ll &delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)-4*((i+delta)>=4)]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid add(vi &nuevo,ll delta,map<iiii,ll> &mapa)\n{\n    //permutar(nuevo);\n    forr(i,0,4)\n    {\n        mapa[move(nuevo,i)]+=delta;\n    }\n}\nvector<iiii> vcaras(4);\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras[0]=auxcara;\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras[1]=auxcara;\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras[2]=auxcara;\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras[3]=auxcara;\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   ll n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   //permutar(V[2]);\n   map<iiii,ll> extra;\n   ll totp,answer=0,auxtotp;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,i+1,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    fiiv(cara2,move(V[j],kj));\n                    /*<<\"comenzamos\\n\";\n                    prll(cara1);\n                    prll(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prll(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxtotp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxtotp);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //cout<<answer<<endl;\n   cout<<answer/12<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define fo(f) freopen(f\".in\",\"r\",stdin);freopen(f\".out\",\"w\",stdout);\n#define gc getchar()\ninline int read()\n{\n\tint x=0;char c=gc;\n\tfor(;c<48||c>57;c=gc);\n\tfor(;c>47&&c<58;c=gc)\n\t\tx=(x<<1)+(x<<3)+c-48;\n\treturn x;\n}\n\ntypedef long long ll;\n#define maxn 405\nint n;\nstruct data\n{\n\tint c[4];\n\tdata(int c0=0,int c1=0,int c2=0,int c3=0)\n\t{\n\t\tc[0]=c0;c[1]=c1;c[2]=c2;c[3]=c3;\n\t}\n\tinline friend bool operator<(data a,data b)\n\t{\n\t\tfor(int i=0;i<4;++i)\n\t\t\tif(a.c[i]^b.c[i])return a.c[i]<b.c[i];\n\t\treturn 0;\n\t}\n\tinline void rotate()\n\t{\n\t\tint t=c[0];\n\t\tc[0]=c[1];c[1]=c[2];c[2]=c[3];c[3]=t;\n\t}\n\tinline friend bool operator==(data a,data b)\n\t{\n\t\tfor(int j=0;j<4;++j)\n\t\t{\n\t\t\tint fl=1;\n\t\t\tfor(int i=0;i<4;++i)\n\t\t\t\tif(a.c[i]!=b.c[(i+j)&3])\n\t\t\t\t{\n\t\t\t\t\tfl=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(fl)return true;\n\t\t}\n\t\treturn false;\n\t}\n}sq[maxn];\nmap<data,int> mp;\n\ninline void inc(data d)\n{\n\tfor(int i=0;i<4;++i)\n\t{\n\t\t++mp[d];\n\t\td.rotate();\n\t}\n}\ninline void dec(data d)\n{\n\tfor(int i=0;i<4;++i)\n\t{\n\t\t--mp[d];\n\t\td.rotate();\n\t}\n}\n\ninline void init()\n{\n\tfo(\"square\");\n\tn=read();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<4;++j)\n\t\t\tsq[i].c[j]=read();\n\t\tinc(sq[i]);\n\t}\n}\n\nll ans;\n\ninline void calc(data l,data r,data u,data d)\n{\n\tif(!mp[l]||!mp[r]||!mp[u]||!mp[d])return;\n\tll a=mp[l],b,x,y;\n\tdec(l);\n\tb=mp[r];\n\tdec(r);\n\tx=mp[u];\n\tdec(u);\n\ty=mp[d];\n\tinc(u);\n\tinc(r);\n\tinc(l);\n\tans+=a*b*x*y;\n}\n\ninline void solve()\n{\n\n\tdata l,r,u,d;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tdec(sq[i]);\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tdec(sq[j]);\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tl=data(sq[j].c[1],sq[i].c[0],sq[i].c[3],sq[j].c[2]);\n\t\t\t\tr=data(sq[i].c[1],sq[j].c[0],sq[j].c[3],sq[i].c[2]);\n\t\t\t\tu=data(sq[j].c[1],sq[j].c[0],sq[i].c[1],sq[i].c[0]);\n\t\t\t\td=data(sq[i].c[3],sq[i].c[2],sq[j].c[3],sq[j].c[2]);\n\t\t\t\tcalc(l,r,u,d);\n\t\t\t\tsq[i].rotate();\n\t\t\t}\n\t\t\tinc(sq[j]);\n\t\t}\n\t\tinc(sq[i]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n}\n\nint main()\n{\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <tuple>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nusing namespace std;\n\nlong long encode(long long p, long long q, long long r, long long s) {\n    return (((p << 10) + q) << 20) + (((r << 10) + s));\n}\n\ntuple<int, int, int, int> decode(long long x) {\n    int p = x >> 30, q = (x >> 20) & 1023, r = (x >> 10) & 1023, s = x & 1023;\n    return {p, q, r, s};\n}\n\nlong long rotate(long long x) {\n    return (x >> 30) | ((x & ((1 << 30) - 1)) << 10);\n}\n\nint multiplicity(long long x) {\n    auto [p, q, r, s] = decode(x);\n    if (p == r && q == s)\n        return p == q ? 4 : 2;\n    else\n        return 1;\n}\n\nint main() {\n    int n; cin >> n;\n    unordered_map<long long, int> cnt;\n    vector<long long> tiles;\n    for (int i = 0; i < n; i++) {\n        int p, q, r, s; cin >> p >> q >> r >> s;\n        long long x = encode(p, q, r, s);\n        for (int j = 0; j < 4; j++, x = rotate(x)) {\n            cnt[x]++;\n            tiles.push_back(x);\n        }\n    }\n    long long ans = 0;\n    unordered_map<long long, int> want;\n    for (int i = 0; i < tiles.size(); i += 4) {\n        const long long x = tiles[i];\n        for (long long x1 = x, a = 0; a < 4; a++, x1 = rotate(x1)) cnt[x1]--;\n        for (int j = i / 4 * 4 + 4; j < tiles.size(); j++) {\n            const long long y = tiles[j];\n            assert (cnt[y] > 0);\n            for (long long y1 = y, a = 0; a < 4; a++, y1 = rotate(y1)) cnt[y1]--;\n            auto [p, q, r, s] = decode(x);\n            auto [t, u, v, w] = decode(y);\n            want.clear();\n            want[encode(u, t, q, p)]++;\n            want[encode(q, t, w, r)]++;\n            want[encode(u, p, s, v)]++;\n            want[encode(w, v, s, r)]++;\n            long long prod = 1;\n            bool ok = true;\n            for (auto [z, k] : want) if (cnt[z] == 0)  { ok = false; break; }\n            if (ok) {\n                for (auto [z, k] : want) {\n                    const int m = multiplicity(z);\n                    assert (cnt[z] % m == 0);\n                    for (int i = 0; i < k; i++) prod *= cnt[z] - m * i;\n                    for (long long z1 = z, a = 0; a < 4; a++, z1 = rotate(z1)) cnt[z1] -= k;\n                }\n                for (auto [z, k] : want) {\n                    for (long long z1 = z, a = 0; a < 4; a++, z1 = rotate(z1)) cnt[z1] += k;\n                }\n                ans += prod;\n            }\n            for (long long y1 = y, a = 0; a < 4; a++, y1 = rotate(y1)) cnt[y1]++;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\n\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\n__int128_t check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  __int128_t res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[(k+z)%4][i];\n          x[k+4]=cs[k][j];\n        }\n\n        int way=0;\n        A w(x);\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          chmin(w,y);\n        }\n\n        if(used.count(make_hash(w))) continue;\n        used.emplace(make_hash(w));\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                reverse(all(d));\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    // if(i == 0 && j == 4) cerr << res << endl;\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    // if(i == 0 && j == 4) {\n                    //     cerr << c[i][l] << \" \" << c[i][(l + 1) % 4] << \" \" << d[(l + 1) % 4] << \" \" << d[l] << endl;\n                    // }\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        res = 0;\n                        break;\n                    }\n                }\n                //if(i == 0 && j == 4) cerr << res << endl;\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                //if(res) cerr << i << \" \" << j << \" \" << res << endl;\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    cout << ans / 6 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nlong get(long a,int k){return k==1?a%1000:k==2?a/1000%1000:k==3?a/1000000%1000:a/1000000000;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nlong C[400];\nmap<long,array<array<array<long,5>,5>,4> >M;\nmap<long,map<int,int> >Q;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tC[i]=conv(a,b,c,d);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C[i]]++;\n\t\t\tC[i]=rotate(C[i]);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<array<long,5>,5>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<5;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tif(j<k)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<4;i++)A[i][j][k]=A[i][k][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA[0][j][k]=sum-j-k;\n\t\t\t\tA[1][j][k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\t\tA[2][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\t\tA[3][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\t}\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong a=C[i];\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tlong b=C[j];\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tb=rotate(b);\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(get(a,3),get(a,4),get(b,3),get(b,4)),\n\t\t\t\t\tconv(get(a,4),get(a,1),get(b,2),get(b,3)),\n\t\t\t\t\tconv(get(a,1),get(a,2),get(b,1),get(b,2)),\n\t\t\t\t\tconv(get(a,2),get(a,3),get(b,4),get(b,1)),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][Q[t[k]][i]][Q[t[k]][j]];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 404;\nusing bs = bitset<maxn>;\nint c[maxn][4];\nvoid rotate(int id){\n\tint p0 = c[id][0];\n\tfor(int j = 0; j < 3; j++) c[id][j] = c[id][j + 1];\n\tc[id][3] = p0;\n}\nlong long calc(int id){\n\tlong long val = 0;\n\tfor(int k = 0; k < 4; k++) val = val * 1000 + c[id][k];\n\treturn val;\n}\nunordered_set<long long> has[maxn];\nunordered_map<long long, bs> cn;\nvoid ins(int id){\n\tfor(int rot = 0; rot < 4; rot++){\n\t\thas[id].insert(calc(id));\n\t\trotate(id);\n\t}\n}\nlong long need[4];\nbs mv[4], can[1<<4];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < 4; j++) cin >> c[i][j];\n\tfor(int i = 0; i < n; i++){\n\t\tins(i);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++){\n\t\tfor(int rotj = 0; rotj < 4; rotj++){\n\t\t\tmap<long long, int> occ;\n\t\t\tint prot[4] = {};\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint nik = (k + 1) % 4;\n\t\t\t\tint njk0 = (5 - k) % 4;\n\t\t\t\tint njk1 = (4 - k) % 4; \n\t\t\t\tneed[k] = 0;\n\t\t\t\tfor(int v : {c[i][nik], c[i][k], c[j][njk0], c[j][njk1]}){\n\t\t\t\t\tneed[k] = need[k] * 1000 + v;\n\t\t\t\t}\n\t\t\t\tc[n][0] = c[i][nik];\n\t\t\t\tc[n][1] = c[i][k];\n\t\t\t\tc[n][2] = c[j][njk0];\n\t\t\t\tc[n][3] = c[j][njk1];\n\t\t\t\tfor(int tk = 0; tk < 4; tk++){\n\t\t\t\t\tif(calc(n) == need[k]) prot[k]++;\n\t\t\t\t\trotate(n);\n\t\t\t\t}\n\t\t\t\tocc[need[k]]++;\n\t\t\t}\n\t\t\tvector<int> cnt(1<<4);\n\t\t\tfor(int k = 0; k < n; k++) if(k != i && k != j){\n\t\t\t\tint msk = 0;\n\t\t\t\tfor(int l = 0; l < 4; l++) msk |= (has[k].count(need[l]) > 0)<<l;\n\t\t\t\tcnt[msk]++;\n\t\t\t}\n\t\t\tvector<long long> f(1<<4, 0), nf(1<<4, 0);\n\t\t\tf[0] = 1;\n\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\tif(cnt[k]){\n\t\t\t\t\tnf = f;\n\t\t\t\t\tfor(int sk = k; sk; sk = k & (sk - 1)){\n\t\t\t\t\t\tassert((k&sk) == sk);\n\t\t\t\t\t\tlong long ways = 1;\n\t\t\t\t\t\tint bc = __builtin_popcount(sk);\n\t\t\t\t\t\tfor(int z = 0; z < bc; z++) ways *= (cnt[k] - z);\n\t\t\t\t\t\tif(ways > 0){\n\t\t\t\t\t\t\tfor(int msk = 0; msk < 1<<4; msk++){\n\t\t\t\t\t\t\t\tif((msk&sk) == 0){\n\t\t\t\t\t\t\t\t\tnf[msk|sk] += f[msk] * ways;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf = nf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++) f[15] *= prot[k];\n\t\t\tans += f[15];\n\t\t\trotate(j);\n\t\t}\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nlint key(const V<>& v) {\n  lint res = 0;\n  for (int i = 0; i < 4; ++i) {\n    lint curr = 0;\n    for (int j = 0; j < 4; ++j) curr += static_cast<lint>(v[i + j & 3]) << 10 * j;\n    res = max(res, curr);\n  }\n  return res;\n}\n\nint coeff(lint key) {\n  V<> v(4);\n  for (int i = 0; i < 4; ++i) {\n    v[i] = key & 1023;\n    key >>= 10;\n  }\n  if (v[0] == v[2] and v[1] == v[3]) {\n    if (v[0] == v[1]) return 4;\n    return 2;\n  }\n  return 1;\n}\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> c; assign(c, n, 4, 0);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < 4; ++j) cin >> c[i][j];\n  map<lint, lint> mp;\n  for (int i = 0; i < n; ++i) ++mp[key(c[i])];\n  lint res = 0;\n  for (int d = 0; d < n; ++d) for (int u = d + 1; u < n; ++u) {\n    --mp[key(c[d])], --mp[key(c[u])];\n    for (int dir = 0; dir < 4; ++dir) {\n      V<lint> keys(4);\n      for (int i = 0; i < 4; ++i) keys[i] = key({c[u][dir - i & 3], c[u][dir - i - 1 & 3], c[d][i + 1 & 3], c[d][i]});\n      sort(begin(keys), end(keys));\n      int bit = 0;\n      for (int i = 0; i < 3; ++i) if (keys[i] == keys[i + 1]) bit |= 1 << i;\n      auto f = [&](const V<>& v) -> lint {\n        lint res = 1;\n        for (int i = 0; i < 4; ++i) res *= coeff(keys[i]) * (mp[keys[i]] - v[i]);\n        return res;\n      };\n      switch (bit) {\n        case 0b000: res += f({0, 0, 0, 0}); break;\n        case 0b001: res += f({1, 0, 0, 0}); break;\n        case 0b010: res += f({0, 0, 1, 0}); break;\n        case 0b011: res += f({0, 1, 2, 0}); break;\n        case 0b100: res += f({0, 0, 0, 1}); break;\n        case 0b101: res += f({0, 1, 0, 1}); break;\n        case 0b110: res += f({0, 0, 1, 2}); break;\n        case 0b111: res += f({0, 1, 2, 3}); break;\n      }\n    }\n    ++mp[key(c[d])], ++mp[key(c[u])];\n  }\n  cout << res / 3 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<pair<int,int>, pair<int,int> > pt;\n\nconst int MOD = 1e9 + 7;\nconst int C = 1001;\n\nmap<ll,int> ma;\n\nll hsh(int a, int b, int c, int d)\n{\n\tll x = ll(a)*ll(C)*ll(C)*ll(C);\n\tx += ll(b)*ll(C)*ll(C);\n\tx += ll(c)*ll(C);\n\tx += d;\n\treturn x;\n}\n\nvoid cyc(int &a, int &b, int &c, int &d)\n{\n\tswap(a, b);\n\tswap(a, c);\n\tswap(a, d);\n}\n\nvector<pt> vec;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tvec.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> vec[i].fi.fi >> vec[i].fi.se >> vec[i].se.fi >> vec[i].se.se;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a = vec[i].fi.fi; int b = vec[i].fi.se;\n\t\tint c = vec[i].se.fi; int d = vec[i].se.se;\n\t\tma[hsh(a,b,c,d)]++;\n\t\tma[hsh(b,c,d,a)]++;\n\t\tma[hsh(c,d,a,b)]++;\n\t\tma[hsh(d,a,b,c)]++;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i == j) continue;\n\t\t\tint xa, xb, xc, xd, ya, yb, yc, yd;\n\t\t\txa = vec[i].fi.fi; xb = vec[i].fi.se; xc = vec[i].se.fi; xd = vec[i].se.se;\n\t\t\tya = vec[j].fi.fi; yb = vec[j].fi.se; yc = vec[j].se.fi; yd = vec[j].se.se;\n\t\t\tswap(xb,xd);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint a,b,c,d; map<ll,int> ma2;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\tll h1 = hsh(ya,yd,xd,xa);\n\t\t\t\tll h2 = hsh(yd,yc,xc,xd);\n\t\t\t\tll h3 = hsh(yc,yb,xb,xc);\n\t\t\t\tll h4 = hsh(yb,ya,xa,xb);\n\t\t\t\t//set<ll> ss;\n\t\t\t\t//ss.insert(h1); ss.insert(h2); ss.insert(h3); ss.insert(h4);\n\t\t\t\tmap<ll,int> ss;\n\t\t\t\t////cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\tll tmp = 0;\n\t\t\t\tfor(int l = 0; l < 1; l++)\n\t\t\t\t{\n\t\t\t\t\tint w = l;\n\t\t\t\t\tint x = (l>>2);\n\t\t\t\t\tint y = (x>>2);\n\t\t\t\t\tint z = (y>>2);\n\t\t\t\t\tw &= 3;\n\t\t\t\t\tx &= 3;\n\t\t\t\t\ty &= 3;\n\t\t\t\t\tz &= 3;\n\t\t\t\t\t////cerr<<w<<' '<<x<<' '<<y<<' '<<z<<'\\n';\n\t\t\t\t\tll x1 = ma[h1];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tll x2 = ma[h2];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tll x3 = ma[h3];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[y][h3]--; ma[y][h2]--; ma[y][h1]--; ma[y][h4]--;\n\t\t\t\t\tll x4 = ma[h4];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[w][h1]++; ma[x][h2]++; ma[y][h3]++;\n\t\t\t\t\t//ma[w][h1]++; ma[w][h2]++; ma[w][h3]++; ma[w][h4]++;\n\t\t\t\t\t//ma[x][h2]++; ma[x][h1]++; ma[x][h3]++; ma[x][h4]++;\n\t\t\t\t\t//ma[y][h3]++; ma[y][h2]++; ma[y][h1]++; ma[y][h4]++;\n\t\t\t\t\tx1=max(x1,0LL); x2=max(x2,0LL); x3=max(x3,0LL); x4 = max(x4,0LL);\n\t\t\t\t\tif((x1*x2*x3*x4*(w+1)*(x+1)*(y+1)*(z+1)) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\t\t\t//cerr<<x1<<' '<<x2<<' '<<x3<<' '<<x4<<'\\n';\n\t\t\t\t\t\t//cerr<<(w+1)<<' '<<(x+1)<<' '<<(y+1)<<' '<<(z+1)<<'\\n';\n\t\t\t\t\t\t//cerr<<(x1*x2*x3*x4*(w+1)*(x+1)*(y+1)*(z+1))<<'\\n';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttmp += (x1*x2*x3*x4*(w+1)*(x+1)*(y+1)*(z+1));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\ttmp*=ma[h1];\n\t\t\t\tma[h1]--;\n\t\t\t\ttmp*=ma[h2];\n\t\t\t\tma[h2]--;\n\t\t\t\ttmp*=ma[h3];\n\t\t\t\tma[h3]--;\n\t\t\t\ttmp*=ma[h4];\n\t\t\t\tma[h1]++; ma[h2]++; ma[h3]++;\n\t\t\t\t*/\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<xa<<' '<<xb<<' '<<xc<<' '<<xd<<' '<<ya<<' '<<yb<<' '<<yc<<' '<<yd<<' '<<tmp<<'\\n';\n\t\t\t\tans += tmp;\n\t\t\t\tma2.clear();\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\tcyc(ya,yb,yc,yd);\n\t\t\t}\n\t\t}\n\t}\n\t//assert(ans%6==0);\n\tans/=6;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\n// 回転の4通りのうち辞書順で最小のものを返す だぶって数えるのを防ぐ\nvector<int> getmin(vector<int> v) {\n    vector<int> ret(v);\n    REP(i, 3) {\n        rotate(v.begin(), v.begin()+1, v.end());\n        chmin(ret, v);\n    }\n    return ret;\n}\n\n// n0枚、n1枚、n2枚でpanel枚を埋める方法が何通り？\nll dfs(ll panel, ll n0, ll n1, ll n2) {\n    if(panel == 0) return 1;\n    ll ret = 0;\n    if(n0) ret += n0*dfs(panel-1, n0-1, n1, n2);\n    if(n1) ret += 2*n1*dfs(panel-1, n0, n1-1, n2);\n    if(n2) ret += 4*n2*dfs(panel-1, n0, n1, n2-1);\n    return ret;\n}\n\nsigned main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    // 0→回転して同じになるものはない\n    // 1→180度回転で同じになる(対角が同じ)\n    // 2→90度回転でも同じ(全部同じ)\n    vector<ll> r(n);\n    map<vector<int>, int> cnt[3];\n    vector<vector<int>> a(n, vector<int>(4));\n    REP(i, n) {\n        REP(j, 4) cin >> a[i][j];\n        a[i] = getmin(a[i]);\n        if(a[i][0] == a[i][2] && a[i][1] == a[i][3]) {\n            r[i] = 1;\n            if(a[i][0] == a[i][1]) r[i] = 2;\n        }\n        cnt[r[i]][a[i]]++;\n    }\n\n    ll ret = 0;\n    // 上をi番目のパネルに\n    REP(i, n) {\n        cnt[r[i]][a[i]]--;\n        // 底をj番目のパネルに\n        FOR(j, i+1, n) {\n            cnt[r[j]][a[j]]--;\n            // 底面を4通りに回転させる\n            REP(k, 4) {\n                // 側面に必要なパネル4枚を列挙\n                map<vector<int>, int> mp;\n                mp[getmin({a[i][1], a[i][0], a[j][1], a[j][0]})]++;\n                mp[getmin({a[i][2], a[i][1], a[j][0], a[j][3]})]++;\n                mp[getmin({a[i][3], a[i][2], a[j][3], a[j][2]})]++;\n                mp[getmin({a[i][0], a[i][3], a[j][2], a[j][1]})]++;\n                // 側面に置く方法が何通りあるか\n                ll t = 1;\n                for(auto p: mp) {\n                    t *= dfs(p.second, cnt[0][p.first], cnt[1][p.first], cnt[2][p.first]);\n                    if(t == 0) break;\n                }\n                ret += t;\n                // 底のパネルを回転\n                rotate(a[j].begin(), a[j].begin()+1, a[j].end());\n            }\n            cnt[r[j]][a[j]]++;\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef unsigned int U;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl; using std::cerr;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n) { cerr << #a << \" = {\"; \\\n      for(int qwq = (st); qwq <= (n); ++qwq) cerr << a[qwq] << (qwq == (n) ? '}' : ',') << (qwq == (n) ? '\\n' : ' '); }\n#define displayv(a) display(a, 0, (int)(a.size()-1))\n#include <ctime>\nclass MyTimer {\n  clock_t st;\npublic:\n  MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n  ~MyTimer() { report(); }\n  void reset() { st = clock_t(); }\n  void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) {}\n#define displayv(a) {}\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifdef QUICK_READ\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n  int a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\ninline LL readLL() {\n  LL a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\n\nconst int maxN = 400 + 5;\nconst int maxC = 1000 + 23;\nint n;\nstruct Tile {\n  int c[4];\n  Tile() {}\n  int& operator [](const int id) {\n    return c[id];\n  }\n  Tile(int x, int y, int z, int w) {\n    c[0] = x; c[1] = y; c[2] = z; c[3] = w;\n  }\n  friend bool operator < (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return A[i] < B[i];\n    return false;\n  }\n  friend bool operator == (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return false;\n    return true;\n  }\n  void rotate() {\n    int t = c[3];\n    for(int i = 3; i > 0; --i) c[i] = c[i - 1];\n    c[0] = t;\n  }\n}a[maxN];\n\nLL f[16];\nint c[4];\n\nLL solve() {\n  LL ans = 0;\n  for(int i = 0; i < n - 5; ++i)\n    for(int j = i + 1; j < n; ++j) {\n      for(int t = 0; t < 4; ++t) {\n        a[j].rotate();\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for(int k = i + 1; k < n; ++k) if(k != j) {\n        \tmemset(c, 0, sizeof(c));\n          for(int tt = 0; tt < 4; ++tt) {\n            a[k].rotate();\n            if(a[k] == Tile(a[j][2], a[j][1], a[i][0], a[i][3])) c[0]++;\n            if(a[k] == Tile(a[j][3], a[j][2], a[i][3], a[i][2])) c[1]++;\n            if(a[k] == Tile(a[j][0], a[j][3], a[i][2], a[i][1])) c[2]++;\n            if(a[k] == Tile(a[j][1], a[j][0], a[i][1], a[i][0])) c[3]++;\n          }\n          for(int S = 15; S >= 0; --S) {\n          \tfor(int i = 0; i < 4; ++i) if(S >> i & 1)\n          \t\tf[S] += f[S ^ (1 << i)] * c[i];\n\t\t\t\t\t}\n        }\n        ans += f[15];\n      }\n    }\n  return ans;\n}\n\nint main() {\n  n = readint();\n  for(int i = 0; i < n; ++i) for(int j = 0; j < 4; ++j) a[i][j] = readint();\n  printf(\"%lld\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\nusing namespace std;\n\nint nextInt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 400;\nint col[N][8];\nlong long hashes[N][4];\nset<long long> any;\nlong long dp[16];\nint ways[4];\n\nlong long calcHash(int a, int b, int c, int d) {\n\tlong long h = 0;\n\th = 1000 * h + a;\n\th = 1000 * h + b;\n\th = 1000 * h + c;\n\th = 1000 * h + d;\n\treturn h;\n}\n\nint main() {\n\tint n = nextInt();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcol[i][j] = nextInt();\n\t\t\tcol[i][j + 4] = col[i][j];\n\t\t}\n\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\thashes[i][rot] = 1000 * hashes[i][rot] + col[i][(rot + j) % 4];\n\t\t\t}\n\t\t\tany.insert(hashes[i][rot]);\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int front = 0; front < n; front++) {\n\t\tint a = col[front][0];\n\t\tint b = col[front][1];\n\t\tint c = col[front][2];\n\t\tint d = col[front][3];\n\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\trotLoop:\n\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\tlong long h1 = calcHash(a, e, f, b);\n\t\t\t\tlong long h2 = calcHash(b, f, g, c);\n\t\t\t\tlong long h3 = calcHash(d, c, g, h);\n\t\t\t\tlong long h4 = calcHash(e, a, d, h);\n\t\t\t\tvector<long long> hs = {h1, h2, h3, h4};\n\t\t\t\tbool can = true;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (any.count(hs[i]) == 0) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!can) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tdp[i] = 0;\n\t\t\t\t}\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tways[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\tif (hashes[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst LL MAX = 1e9;\nconst int SIZE = 410;\nLL an;\nint d[SIZE][4];\nLL val[SIZE];\nmap<LL,int>H,C;\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n}\nLL fix(LL x){\n    vector<LL>ker;\n    ker.PB(x);\n    int cnt=1;\n    LL mi=x;\n    REP(k,3){\n        LL tmp=x/MAX;\n        x=(x-tmp*MAX)*1000+tmp;\n        mi=min(mi,x);\n        ker.PB(x);\n    }\n    sort(ALL(ker));\n    if(ker[0]==ker[3])\n        C[mi]=4;\n    else if(ker[0]==ker[1]&&ker[2]==ker[3])C[mi]=2;\n    else C[mi]=1;\n    return mi;\n}\nint main(){\n    DRI(N);\n    REP(i,N){\n        //printf(\"%d:%lld\\n\",i,an);\n        REP(j,4)\n            RI(d[i][j]);\n        REP(j,i){\n            H[val[j]]--;\n            REP(r,4){\n                map<LL,int>shik;\n                REP(k,4){\n                    LL v=0;\n                    v=v*1000+d[j][(r-k+4)&3];\n                    v=v*1000+d[j][(r-k+3)&3];\n                    v=v*1000+d[i][(k+1)&3];\n                    v=v*1000+d[i][k&3];\n                    shik[fix(v)]++;\n                }\n                LL my_v=1;\n                for(map<LL,int>::iterator it=shik.begin();it!=shik.end();it++){\n                    if(H.count(it->F)){\n                        LL nn=H[it->F];\n                        REP(ker,it->S){\n                            my_v=my_v*nn%MOD;\n                            nn--;\n                            my_v=my_v*C[it->F]%MOD;\n                        }\n                    }\n                    else my_v=0;\n                }\n                ADD(an,my_v);\n            }\n            H[val[j]]++;\n        }\n        {\n            LL v=0;\n            REP(k,4)\n                v=v*1000+d[i][k];\n            val[i]=fix(v);\n            H[val[i]]++;\n        }\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 1010\n#define ll long long \n\nint n ;\nll c[ N ][ 4 ] ;\nll h[ N ] , ans = 0 ;\nmap< ll , ll > mp ;\n\nll hash( ll *a ) {\n\tll res = 0 ;\n\tfor( int i = 0 ; i < 4 ; i ++ ) {\n\t\tres |= ( a[ i ] << ( i * 10ll ) ) ;\n\t}\n\treturn res ;\n}\n\nvoid upd( ll  x , ll d ) {\n\tfor( int i = 0 ; i < 4 ; i ++ , x = ( ( x&1023ll ) << 30ll ) | ( x >> 10ll ) ) {\n\t\tmp[ x ] += d ;\n\t}\n}\n\nint main() {\n\tscanf( \"%d\" , &n ) ;\n\tfor( int i = 1 ; i <= n ; i ++ ) {\n\t\tfor( int j = 0 ; j < 4 ; j ++ ) {\n\t\t\tscanf( \"%lld\" , &c[ i ][ j ] ) ;\n\t\t}\n\t\th[ i ] = hash( c[ i ] ) ;\n\t\tupd( h[ i ] , 1ll ) ;\n\t}\n\tfor( int i = 1 ; i <= n - 5 ; i ++ ) {\n\t\tupd( h[ i ] , -1ll ) ;\n\t\tfor( int j = i + 1 ; j <= n ; j ++ ) {\n\t\t\tupd( h[ j ] , -1ll ) ;\n\t\t\tfor( int a = 0 ; a < 4 ; a ++ ) {\n\t\t\t\tll res = 1ll , val[ 4 ] ;\n\t\t\t\tbool check = 0 ;\n\t\t\t\tfor( int b = 0 ; b < 4 ; b ++ ) {\n\t\t\t\t\tll x[] = { c[ i ][ ( b + 1 ) & 3 ] , c[ i ][ b ] , c[ j ][ ( 3 - b + a ) & 3 ] , c[ j ][ ( 6 - b + a ) & 3 ] } ;\n\t\t\t\t\tval[ b ] = hash( x ) ;\n\t\t\t\t\tif( !mp.count( val[ b ] ) ) {\n\t\t\t\t\t\tcheck = 1 ; \n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !check ) {\n\t\t\t\t\tfor( int k = 0 ; k < 4 ; k ++ ) {\n\t\t\t\t\t\tres = res * mp[ val[ k ] ] ;\n\t\t\t\t\t\tupd( val[ k ] , -1ll ) ; \n\t\t\t\t\t}\n\t\t\t\t\tans += res ;\n\t\t\t\t\tfor( int k = 0 ; k < 4 ; k ++ ) {\n\t\t\t\t\t\tupd( val[ k ] , 1ll ) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupd( h[ j ] , 1ll ) ; \n\t\t}\n\t}\n\tprintf( \"%lld\" , ans ) ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (short i = a; i <= b; ++ i) \nconst short N = 1005 ; \n\nconst short turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <short>, short> Count ;\nshort col[N][5], n ;\n\ninline void getmin(vector <short> &p) {\n\tvector <short> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nmap <vector <short>, short>  mul, used ;\n\nint main() {\n\tcin >> n ;\n\trep(i, 1, n) rep(j, 0, 3) cin >> col[i][j] ;\n\trep(i, 1, n) {\n\t\tvector <short> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\t++ Count[ret] ;\n\t\tshort tot = 0 ; \n\t\tvector <short> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0, sum ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\tvector <short> ret ;\n\t\trep(k, 0, 3) ret.push_back(col[i][k]) ; getmin(ret) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ; getmin(ret) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <short> ret ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\tvector <short> U[5] ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\trep(q, 0, 3) U[p].push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(U[p]) ;\n\t\t\t\tsum *= (ll) mul[U[p]] * (Count[U[p]] - used[U[p]]) ;\n\t\t\t\t++ used[U[p]] ;\n\t\t\t}\n\t\t\trep(p, 0, 3) -- used[U[p]] ;\n\t\t\tans += sum ;\n\t\t}\n\t\trep(k, 0, 3) ret[k] = col[i][k] ; getmin(ret) ;\n\t\t++ Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ; getmin(ret) ;\n\t\t++ Count[ret] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tvector<array<int, 4>>c(N);\n\trep(i, N)rep(j, 4)cin >> c[i][j];\n\tmap<array<int, 4>, vector<array<int, 2>>>m4;\n\trep(i, N)rep(j, 4) {\n\t\tm4[{ c[i][j], c[i][(j + 1) % 4], c[i][(j + 2) % 4], c[i][(j + 3) % 4] }].push_back({ i,j });\n\t}\n\tint ans = 0;\n\trep(i, N)REP(j, i + 1, N)rep(k, 4) {\n\t\tarray<int, 4>a1 = { c[i][0],c[j][(k + 1) % 4],c[j][(k + 0) % 4],c[i][1] };\n\t\tarray<int, 4>a2 = { c[i][1],c[j][(k + 0) % 4],c[j][(k + 3) % 4],c[i][2] };\n\t\tarray<int, 4>a3 = { c[i][2],c[j][(k + 3) % 4],c[j][(k + 2) % 4],c[i][3] };\n\t\tarray<int, 4>a4 = { c[i][3],c[j][(k + 2) % 4],c[j][(k + 1) % 4],c[i][0] };\n\t\tfor (auto x1 : m4[a1])if (i < x1[0] && j != x1[0]) {\n\t\t\tfor (auto x2 : m4[a2])if (i < x2[0] && j != x2[0] && x1[0] != x2[0]) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1[0] != x3[0] && x2[0] != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2[0] != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nll h[maxn];\ninline ll cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tll ret = 1234567891234567ll;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tll num = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tnum = num*1000+col[(rot+i)%4];\n\t\t\tret = min(ret,num);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nint fac[5];\ninline ll Pow(int a,int n) {\n\tll ret = 1;\n\tll base = a;\n\twhile(n) {\n\t\tif(n&1)\tret *= base;\n\t\tbase *= base;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ninline ll C(int n,int m) {\n\tif(n < m)\treturn 0;\n\tll ret = 1;\n\tfor(int i=n-m+1;i<=n;i++)\n\t\tret *= i;\n\tfor(int i=1;i<=m;i++)\n\t\tret /= i;\n\treturn ret;\n}\nmap<ll,pii> cnt;\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tint now_cnt = 0;\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tll num = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tnum = num*1000+col[i][(rot+j)%4];\n\t\t\t\tif(num == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tnow_cnt = max(now_cnt,tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t\tcnt[h[i]].first++;\n\t\tcnt[h[i]].second = now_cnt;\n\t}\n\t\n\tfac[0] = 1;\n\tfor(int i=1;i<5;i++)\n\t\tfac[i] = fac[i-1] * i;\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tcnt[h[i]].first--;\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tcnt[h[j]].first--;\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tmap<ll,int> need;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k])]++;\n\t\t\t\tll now = 1;\n\t\t\t\tfor(auto x : need)\n\t\t\t\t\tnow *= C(cnt[x.first].first,x.second) * Pow(cnt[x.first].second,x.second) * fac[x.second];\n\t\t\t\tans += now;\n\t\t\t}\n\t\t\tcnt[h[j]].first++;\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n//\t\tcnt[h[i]].first++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n;\npair<pii,pii> cubes[525];\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    cubes[i] = make_pair(pii(a,b),pii(c,d));\n  }\n  typedef pii E;\n  typedef pair<pii,pii> S;\n  // one edge, another edge, [count, multiple]\n  map<E, map<E,pii> > edges;\n  // surface, [count, multiple]\n  map<S, pii> surfaces;\n\n  // surface to edges\n  map<S,set<pair<E,E> > > s2e;\n  // surface to surfaces\n  map<S,set<S> > s2s;\n\n  {\n    int a[4];\n    REP(i,n){\n      map<pii,map<pii,int> > ae;\n      map<pair<pii,pii>,int> as;\n      a[0] = cubes[i].first.first;\n      a[1] = cubes[i].first.second;\n      a[2] = cubes[i].second.first;\n      a[3] = cubes[i].second.second;\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        ae[e][oe]+=1;\n        as[s]+=1;\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        if(ae[e][oe]>0){\n          edges[e][oe].first += 1;\n          edges[e][oe].second = ae[e][oe];\n          ae[e][oe] = 0;\n        }\n        if(as[s]>0){\n          surfaces[s].first += 1;\n          surfaces[s].second = as[s];\n          as[s] = 0;\n        }\n        for(auto _s:as){\n          S s = _s.first;\n          s2e[s].insert(make_pair(e,oe));\n        }\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      for(auto _s:as){\n        S s = _s.first;\n        for(auto _t:as){\n          S t = _t.first;\n          s2s[s].insert(t);\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  // 1. determine first surface(a,b,c,d)\n  for(auto _s1:surfaces){\n    S s1 = _s1.first;\n    ll u1 = _s1.second.first * _s1.second.second;\n    int a = s1.first.first;\n    int b = s1.first.second;\n    int c = s1.second.first;\n    int d = s1.second.second;\n    // decrement\n    for(S s:s2s[s1])surfaces[s].first--;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first--;\n    // 2. determine second surface(e,f)\n    E e1 = pii(b,a);\n    for(auto _e2:edges[e1]){\n      E e2 = _e2.first;\n      ll u2 = u1 * _e2.second.first * _e2.second.second;\n      if(u2==0)continue;\n      int e = e2.first;\n      int f = e2.second;\n      // decrement\n      S s2 = make_pair(e1,e2);\n      for(S s:s2s[s2])surfaces[s].first--;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first--;\n      // 3. determine third surface(g,h)\n      E e3 = pii(d,c);\n      for(auto _e4:edges[e3]){\n        E e4 = _e4.first;\n        ll u3 = u2 * _e4.second.first * _e4.second.second;\n        if(u3==0)continue;\n        int g = e4.first;\n        int h = e4.second;\n        // decrement\n        S s3 = make_pair(e3,e4);\n        for(S s:s2s[s3])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first--;\n        // 4,5,6 the other 3 surfaces\n        S s4 = make_pair(pii(a,d),pii(h,e));\n        S s5 = make_pair(pii(e,h),pii(g,f));\n        S s6 = make_pair(pii(c,b),pii(f,g));\n        // s4\n        ll u4 = u3 * surfaces[s4].first * surfaces[s4].second;\n        for(S s:s2s[s4])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first--;\n        // s5\n        ll u5 = u4 * surfaces[s5].first * surfaces[s5].second;\n        for(S s:s2s[s5])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first--;\n        // s4\n        ll u6 = u5 * surfaces[s6].first * surfaces[s6].second;\n        for(S s:s2s[s6])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first--;\n        // add\n        ans += u6;\n        // s4\n        for(S s:s2s[s4])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first++;\n        // s5\n        for(S s:s2s[s5])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first++;\n        // s4\n        for(S s:s2s[s6])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first++;\n        // s3\n        for(S s:s2s[s3])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first++;\n      }\n      for(S s:s2s[s2])surfaces[s].first++;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first++;\n    }\n    for(S s:s2s[s1])surfaces[s].first++;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first++;\n  }\n  printf(\"%llu\\n\",ans/24);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1505;\nstruct lpl{\n\tint x[5];\n//\tfriend bool operator < (lpl a, lpl b) {\n//\t\treturn a.x[1] == b.x[1] ? (a.x[2] == b.x[2] ? (a.x[3] == b.x[3] ? a.x[4] < b.x[4] : a.x[3] < b.x[3]) : a.x[2] < b.x[2]) : a.x[1] < b.x[1];\n//\t}\n}ini[maxn];\nint n, c[5];\nmap<lpl, long long> mp;\nlong long ans;\n\ninline bool operator < (lpl A, lpl B){\n\tif(A.x[1] == B.x[1]){\n\t\tif(A.x[2] == B.x[2]){\n\t\t\tif(A.x[3] == B.x[3]) return A.x[4] < B.x[4];\n\t\t\telse return A.x[3] < B.x[3];\t\n\t\t}\n\t\telse return A.x[2] < B.x[2];\t\n\t}\n\telse return A.x[1] < B.x[1];\n}\n\ninline lpl move(lpl A){\n\tlpl ret;\n\tret.x[1] = A.x[2];\n\tret.x[2] = A.x[3];\n\tret.x[3] = A.x[4];\n\tret.x[4] = A.x[1];\n\treturn ret;\n}\n\ninline void ins(lpl A, long long val){\n\tfor(int i = 1; i <= 4; ++i){\n\t\tA = move(A); mp[A] += val; \n\t}\n}\n\ninline void putit(){\n\tscanf(\"%d\", &n);  lpl lin;\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int j = 1; j <= 4; ++j) scanf(\"%d\", &ini[i].x[j]); \n\t\tins(ini[i], 1);\n\t}\n}\n\ninline void calc(int a, int b){\n\tlpl A = ini[a], B = ini[b];\n\tfor(int p = 1; p <= 4; ++p){\n\t\tB = move(B);\n\t\tlpl up, down, qian, hou;\n\t\tup.x[1] = A.x[2]; up.x[2] = A.x[1]; up.x[3] = B.x[1]; up.x[4] = B.x[4];\n\t\tdown.x[1] = A.x[3]; down.x[2] = A.x[2]; down.x[3] = B.x[4]; down.x[4] = B.x[3];\n\t\tqian.x[1] = A.x[4]; qian.x[2] = A.x[3]; qian.x[3] = B.x[3]; qian.x[4] = B.x[2];\n\t\thou.x[1] = A.x[1]; hou.x[2] = A.x[4]; hou.x[3] = B.x[2]; hou.x[4] = B.x[1];\n\n//\t\tup.x[1] = A.x[1]; up.x[2] = B.x[2]; up.x[3] = B.x[1]; up.x[4] = A.x[2];\n//\t\tdown.x[1] = A.x[3]; down.x[2] = B.x[4]; down.x[3] = B.x[3]; down.x[4] = A.x[2];\n//\t\tqian.x[1] = A.x[2]; qian.x[2] = B.x[1]; qian.x[3] = B.x[4]; qian.x[4] = A.x[3];\n//\t\thou.x[1] = B.x[2]; hou.x[2] = A.x[1]; hou.x[3] = A.x[4]; hou.x[4] = B.x[3];\t\n\t\t\n\t\tif(!mp[up] || !mp[down] || !mp[qian] || !mp[hou]) continue;\n\t\tlong long ret = 1;\n\t\tret *= mp[up]; ins(up, -1);\n\t\tret *= mp[down]; ins(down, -1);\n\t\tret *= mp[qian]; ins(qian, -1);\n\t\tret *= mp[hou]; ans += ret;\n\t\tins(up, 1); ins(down, 1); ins(qian, 1);\n\t}\n}\n\ninline void workk(){\n\tfor(int i = 1; i <= n; ++i){\n\t\tins(ini[i], -1);\n\t\tfor(int j = i + 1; j <= n; ++j){\n\t\t\tins(ini[j], -1); calc(i, j); ins(ini[j], 1);\n\t\t}\n\t\tins(ini[i], 1);\n\t}\n\tcout << ans / 3;\n}\n\nint main()\n{\n\t//freopen(\"lpl.in\", \"r\", stdin);\n\tputit();\n\tworkk();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nvi normarize(const vi &v)\n{\n    vector<vi> r(4);\n    rep(i,4)\n    {\n        vi t(4);\n        rep(j,4) t[j]=v[(i+j)%4];\n        r[i]=t;\n    }\n    sort(all(r));\n    return r[0];\n}\n\ninline ll P(int n, int r)\n{\n    if(n<r) return 0;\n\n    ll ret=1;\n    rep(i,r) ret*=n-i;\n    return ret;\n}\n\ninline ll POW(int x, int n)\n{\n    ll ret=1;\n    rep(i,n) ret*=x;\n    return ret;\n}\n\ninline ll DIM(const vi &v)\n{\n    if(v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) return 4;\n    else if(v[0]==v[2] && v[1]==v[3]) return 2;\n    return 1;\n}\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<vi> c(n,vi(4));\n    rep(i,n)rep(j,4) scanf(\" %d\", &c[i][j]);\n\n    map<vi,int> ct;\n    rep(i,n)\n    {\n        c[i]=normarize(c[i]);\n        if(ct.find(c[i])==ct.end()) ct[c[i]]=1;\n        else ++ct[c[i]];\n    }\n\n    ll ans=0;\n    // 上面i, 下面j\n    rep(i,n)rep(j,i)\n    {\n        // 下面の向きを設定\n        rep(k,4)\n        {\n            vi u(4);\n            rep(x,4) u[x]=c[j][(k+x)%4];\n            swap(u[1],u[3]);\n\n            map<vi,int> sides_ct;\n            rep(x,4)\n            {\n                vi t(4);\n                t[0]=c[i][(x+1)%4];\n                t[1]=c[i][x];\n                t[2]=u[x];\n                t[3]=u[(x+1)%4];\n                t=normarize(t);\n\n                if(sides_ct.find(t)==sides_ct.end()) sides_ct[t]=1;\n                else ++sides_ct[t];\n            }\n\n            ll add=1;\n            for(const auto &x:sides_ct)\n            {\n                vi key=x.fi;\n                int value=x.se;\n\n                // 使ってないタイルのうち当てはめられる個数\n                int num=ct[key];\n                if(c[i]==key) --num;\n                if(c[j]==key) --num;\n\n                // 選び方、向き、位置\n                add*=P(num,value)*POW(DIM(key),value);\n            }\n            ans+=add;\n        }\n    }\n\n    // 向かい合う面の個数ぶん重複する\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n\tusing LD = long double;\n\t#define double LD\n\t#define long long long\n\t#define LL long\n\t#define int long\n\ttemplate<class T> using vec = vector<T>;\n\tusing VB = vec<bool>;\tusing WB = vec<VB>;\n\tusing VC = vec<char>;\tusing WC = vec<VC>;\n\tusing VI = vec<int>;\tusing WI = vec<VI>;\n\tusing VD = vec<double>;\tusing WD = vec<VD>;\n\tusing VS = vec<string>;\tusing WS = vec<VS>;\n\tusing PI = pair<int, int>;\tusing VPI = vec<PI>; using WPI = vec<VPI>;\n\tusing MI = map<int, int>;\tusing VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n\t#ifdef EBUG\n\t\tdebug = true;\n\t#elif defined(ONLINE_JUDGE)\n\t\tdebug = false;\n\t#else\n\t\tdebug = argc >= 2;\n\t#endif\n\tif(!debug) {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n\tcout << fixed << setprecision(20);\n\tcerr << fixed << setprecision(20);\n\n\tsettings();\n\tsolve();\n\n\treturn 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n\ttemplate<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n\t\tGraph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n\t};\n\tusing GraphI = Graph<int>;\n/** IO **/\n\ttemplate<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n\tint INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n\ttemplate<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n\t\tconst int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n\t\tif(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n\t\ttimes(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n\t}\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n\ttemplate<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n\ttemplate<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n\t#define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n\ttemplate<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n\tinline void RD() {}\n\ttemplate<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n\ttemplate<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n\t#define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n\ttemplate<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n\ttemplate<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n\ttemplate<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n\t#define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n\t#define all(v) begin(v), end(v)\n\ttemplate<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n\ttemplate<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n\ttemplate<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n\ttemplate<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n\ttemplate<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n\ttemplate<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n\ttemplate<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n\ttemplate<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n\t\treturn 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n\t#define first_itr_st_val_ge_ lower_bound\n\t#define first_itr_st_val_gt_ upper_bound\n/** other **/\n\ttemplate<class T> inline signed SIZE(const T& t) { return t.size(); }\n\t#define size SIZE\n\t#define MP make_pair\n\t#define MT make_tuple\n\t#define PB push_back\n\t#define b_max(x, y) x = max(x, y)\n\t#define b_min(x, y) x = min(x, y)\n\tinline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.m.pow> */\n\t// NOT_VERIFIED\n\t// ref: ari-114\n\t// O(log b)\n\tinline int mpow(int a, int b, int mod=MOD) {\n\t\tint ans = 1;\n\t\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ans *= a) %= mod;\n\t\treturn ans;\n\t}\n/* </sr.m.pow> */\n\n/************************************ main ************************************/\n\nvoid settings() {\n\t// INPUT_GRAPH_index_sub = 0;\t\t// uncomment if input index is 0-based\n\t// INPUT_GRAPH_allow_empty = true;\t// uncomment to allow empty graph\n\t// INPUT_GRAPH_cost = 1;\t\t\t// uncomment if all input costs are 1\n}\n\nusing I4 = array<int, 4>;\n\nvoid o(const I4& i4) { cout << '(' << vec<int>(all(i4)) << ')'; }\n\nI4 rot(const I4& i4, int r) {\n\treturn I4{{ i4[r&3], i4[r+1&3], i4[r+2&3], i4[r+3&3] }};\n}\n\nI4 minrot(const I4& i4) {\n\tI4 ans = i4;\n\ttimes(3, r) {\n\t\tI4 x = rot(i4, r+1);\n\t\tif(ans > x) ans = x;\n\t}\n\treturn ans;\n}\n\nint z(const I4& i4) {\n\tif(i4[0] == i4[2] && i4[1] == i4[3]) {\n\t\tif(i4[0] == i4[1]) return 4;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nvoid solve() {\n// N N(4(C))\n/* <foxy.memo-area> */\nint N;cin>>N;vec<I4> C(N);times(N,Ri_0){times(4,Ri_1){cin>>C[Ri_0][Ri_1];}}\n/* </foxy.memo-area> */\n\tmap<I4, int> pyon;\n\ttimes(N, i) {\n\t\tC[i] = minrot(C[i]);\n\t\t++pyon[C[i]];\n\t}\n\t//if(debug) {for(auto& p : pyon) { o(p.first); cout sp << p.second << '/';} cout ln;}\n\tint ans = 0;\n\n\ttimes(N, i) times(N, j) if(i!=j) times(4, jj) {\n\t\tint a = 1;\n\t\tmap<I4, int> sides;\n\t\ttimes(4, h) {\n\t\t\t++sides[minrot(I4{{C[i][h+1&3], C[i][h&3], C[j][jj+4-h&3], C[j][jj+3-h&3]}})];\n\t\t}\n\t\tfor(auto& p : sides) {\n\t\t\tI4 i4 = p.first; int n = p.second;\n\t\t\t(a *= mpow(z(i4), n)) %= MOD;\n\n\t\t\tint py = pyon[i4];\n\t\t\tif(i4 == minrot(C[i])) --py;\n\t\t\tif(i4 == minrot(C[j])) --py;\n\t\t\ttimes(n, k) (a *= py - k);\n\t\t}\n\n\t\t(ans += a) %= MOD;\n\t}\n\tcout << ans * mpow(6, MOD-2) % MOD ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 405\nusing namespace std;\ninline int read(){\n\tint ans=0;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans;\n}\nint n,col[N][4];\nll ans=0,mp[N][4];\nmap<ll,int>cnt;\ninline ll idx(int a,int b,int c,int d){return 1ll*a+1ll*b*1000+1ll*c*1000000+1ll*d*1000000000;}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i)for(int j=0;j<=3;++j)col[i][j]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tmp[i][0]=idx(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tmp[i][1]=idx(col[i][1],col[i][2],col[i][3],col[i][0]);\n\t\tmp[i][2]=idx(col[i][2],col[i][3],col[i][0],col[i][1]);\n\t\tmp[i][3]=idx(col[i][3],col[i][0],col[i][1],col[i][2]);\n\t\tfor(int j=0;j<4;++j)++cnt[mp[i][j]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<4;++j)--cnt[mp[i][j]];\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tif(i==j)continue;\n\t\t\tfor(int k=0;k<4;++k)--cnt[mp[j][k]];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tll tmp[16],ttmp=1;\n\t\t\t\ttmp[0]=idx(col[i][0],col[i][3],col[j][k],col[j][(k+3)%4]);\n\t\t\t\ttmp[4]=idx(col[j][(k+3)%4],col[i][0],col[i][3],col[j][k]);\n\t\t\t\ttmp[8]=idx(col[j][k],col[j][(k+3)%4],col[i][0],col[i][3]);\n\t\t\t\ttmp[12]=idx(col[i][3],col[j][k],col[j][(k+3)%4],col[i][0]);\n\t\t\t\ttmp[1]=idx(col[i][1],col[i][0],col[j][(k+3)%4],col[j][(k+2)%4]);\n\t\t\t\ttmp[5]=idx(col[j][(k+2)%4],col[i][1],col[i][0],col[j][(k+3)%4]);\n\t\t\t\ttmp[9]=idx(col[j][(k+3)%4],col[j][(k+2)%4],col[i][1],col[i][0]);\n\t\t\t\ttmp[13]=idx(col[i][0],col[j][(k+3)%4],col[j][(k+2)%4],col[i][1]);\n\t\t\t\ttmp[2]=idx(col[i][2],col[i][1],col[j][(k+2)%4],col[j][(k+1)%4]);\n\t\t\t\ttmp[6]=idx(col[j][(k+1)%4],col[i][2],col[i][1],col[j][(k+2)%4]);\n\t\t\t\ttmp[10]=idx(col[j][(k+2)%4],col[j][(k+1)%4],col[i][2],col[i][1]);\n\t\t\t\ttmp[14]=idx(col[i][1],col[j][(k+2)%4],col[j][(k+1)%4],col[i][2]);\n\t\t\t\ttmp[3]=idx(col[i][3],col[i][2],col[j][(k+1)%4],col[j][k]);\n\t\t\t\ttmp[7]=idx(col[j][k],col[i][3],col[i][2],col[j][(k+1)%4]);\n\t\t\t\ttmp[11]=idx(col[j][(k+1)%4],col[j][k],col[i][3],col[i][2]);\n\t\t\t\ttmp[15]=idx(col[i][2],col[j][(k+1)%4],col[j][k],col[i][3]);\n\t\t\t\tif(cnt[tmp[0]]==0||cnt[tmp[1]]==0||cnt[tmp[2]]==0||cnt[tmp[3]]==0)continue;\n\t\t\t\tfor(int l=0;l<4;++l){\n\t\t\t\t\tttmp*=cnt[tmp[l]];\n\t\t\t\t\tfor(int m=l;m<16;m+=4)--cnt[tmp[m]];\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<16;++l)++cnt[tmp[l]];\n\t\t\t\tans+=ttmp;\n\t\t\t}\n\t\t\tfor(int k=0;k<4;++k)++cnt[mp[j][k]];\n\t\t}\n\t\tfor(int j=0;j<4;++j)++cnt[mp[i][j]];\n\t}\n\tcout<<ans/3;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nvector<int> a[1010][4];\nmap<vector<int>, int> m, m2, m4;\nint mul2[5] = {1, 2, 4, 8, 16};\nint mul4[5] = {1, 4, 16, 64, 256};\nlong long pp[1010][5];\nlong long go(vector<int> v, int t) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= t; i++) {\n\t\tif (m[v] < i) break;\n\t\tfor (int j = 0; j <= t - i; j++) {\n\t\t\tif (m2[v] < j) break;\n\t\t\tint k = t - i - j;\n\t\t\tif (m4[v] >= k) {\n\t\t\t\tres += pp[m[v]][i] * pp[m2[v]][j] * pp[m4[v]][k] * mul2[j] * mul4[k];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint ti[1010];\nvoid reg(int i, int j, int x) {\n\tif (ti[i] == 4) {\n\t\tm4[a[i][0]] += x;\n\t}\n\tif (ti[i] == 2) {\n\t\tm2[*min_element(a[i], a[i] + 2)] += x;\n\t}\n\tif (ti[i] == 1) {\n\t\tm[*min_element(a[i], a[i] + 4)] += x;\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tpp[0][0] = 1;\n\tfor (int i = 1; i < 1010; i++) {\n\t\tpp[i][0] = 1;\n\t\tfor (int j = 1; j < 5; j++) {\n\t\t\tpp[i][j] = pp[i][j-1] * (i - j + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> &v = a[i][0];\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\ta[i][j].push_back(v[(j+k)%4]);\n\t\t\t}\n\t\t}\n\t\tif (v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) {\n\t\t\tti[i] = 4;\n\t\t\tm4[v]++;\n\t\t} else if (v[0] == v[2] && v[1] == v[3]) {\n\t\t\tti[i] = 2;\n\t\t\tm2[*min_element(a[i], a[i] + 2)]++;\n\t\t} else {\n\t\t\tti[i] = 1;\n\t\t\tm[*min_element(a[i], a[i] + 4)]++;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> &v = a[i][0];\n\t\treg(i, 0, -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<int> w = a[j][k];\n\t\t\t\treg(j, k, -1);\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\tmap<vector<int>, int> f;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tvector<int> u[4];\n\t\t\t\t\tu[0].push_back(w[l]);\n\t\t\t\t\tu[0].push_back(w[(l+1)%4]);\n\t\t\t\t\tu[0].push_back(v[(l+1)%4]);\n\t\t\t\t\tu[0].push_back(v[l]);\n\t\t\t\t\tfor (int r = 1; r < 4; r++) {\n\t\t\t\t\t\tfor (int q = 0; q < 4; q++) {\n\t\t\t\t\t\t\tu[r].push_back(u[0][(r+q)%4]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf[*min_element(u, u + 4)]++;\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (map<vector<int>, int>::iterator it = f.begin(); it != f.end(); it++) {\n\t\t\t\t\ttmp *= go(it->first, it->second);\n\t\t\t\t}\n\n\t\t\t\tans += tmp;\n\t\t\t\treg(j, k, 1);\n\t\t\t}\n\t\t}\n\t\treg(i, 0, 1);\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define inf 0x7fffffff\n#define mkp make_pair\n#define maxn 100205\ntypedef unsigned int U;\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 998244353;\nconst  double eps = 1e-8;\nconst double pi = acos(-1);\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\nint n,m,inde[100005],tot;\nstruct p{\n\tint c[4];\n\tbool operator < (const p & a)const{\n\t\tif(c[0]!=a.c[0]) return c[0]<a.c[0];\n\t\tif(c[1]!=a.c[1]) return c[1]<a.c[1];\n\t\tif(c[2]!=a.c[2]) return c[2]<a.c[2];\n\t\treturn c[3]<a.c[3];\n\t}\n}col[405];\nmap<p,int> mp;\nvoid add(p x,int val){\n\tp now=x,nxt;\n\tmp[now]+=val;\n\tfor(int j=1;j<=3;j++){\n\t\tfor(int i=0;i<=3;i++) nxt.c[i]=now.c[(i+1)%4];\n\t\tnow=nxt;\n\t\tmp[now]+=val;\n\t}\n}\nint main(){\n\tint i,j,u,v,e,w;\n\t//freopen(\"a.out\",\"r\",stdin);\n\t//freopen(\"a.ans\",\"w\",stdout);\n\tn=read();\n\tfor(i=1;i<=n;i++)\n\t\tcol[i].c[0]=read(),col[i].c[1]=read(),col[i].c[2]=read(),col[i].c[3]=read();\n\tfor(i=1;i<=n;i++) \n\t\tadd(col[i],1);\n\tll ans=0,S;\n\tfor(i=1;i<=n-5;i++){\n\t\tadd(col[i],-1);\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tadd(col[j],-1);\n\t\t\tp now,nxt=col[j],pj;\n\t\t\tfor(e=1;e<=4;e++){\n\t\t\t\tnow=nxt;\n\t\t\t\tS=1;\n\t\t\t\tfor(w=0;w<=3;w++) nxt.c[w]=now.c[(w+1)%4];\n\t\t\t\tfor(w=0;w<=3;w++){\n\t\t\t\t\tpj=(p){col[i].c[(w+1)%4],col[i].c[w],now.c[3-w],now.c[3-(w+1)%4]};\n\t\t\t\t\tS*=mp[pj];\n\t\t\t\t\tif(!mp[pj]) break;\n\t\t\t\t\telse add(pj,-1);\n\t\t\t\t}\n\t\t\t\tw--;\n\t\t\t\tfor(;w>=0;w--){\n\t\t\t\t\tpj=(p){col[i].c[(w+1)%4],col[i].c[w],now.c[3-w],now.c[3-(w+1)%4]};\n\t\t\t\t\tadd(pj,1);\n\t\t\t\t}\n\t\t\t\tans+=S;\n\t\t\t}\n\t\t\tadd(col[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n/*\n8\n0 0 0 0\n0 0 1 1\n0 1 0 1\n0 1 1 0\n1 0 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing T = tuple<int,int,int,int>;\nmap<T,int> mp;\nint n, c[405][4];\nlong long ans;\nT make(int *c){\n\tint id = 0, id2 = 0, r[12] = {};\n\trep(i,12) r[i] = c[i%4];\n\trep(i,4) if(r[id] < r[i]) id = i;\n\tid2 = id;\n\trep(i,4) if(r[id2] > r[id+i]) id2 = id+i;\n\treturn T(r[id2], r[id2+1], r[id2+2], r[id2+3]);\n}\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n){\n\t\tscanf(\"%d%d%d%d\", c[i], c[i]+1, c[i]+2, c[i]+3);\n\t\tmp[make(c[i])]++;\n\t}\n\trep(i,n){\n\t\tmp[make(c[i])]--;\n\t\tfor(int j = i+1; j < n; j++) rep(k,4){\n\t\t\tint cc = c[j][0];\n\t\t\tlong long part = 1;\n\t\t\trep(i,3) c[j][i] = c[j][i+1];\n\t\t\tc[j][3] = cc;\n\t\t\tmap<T,int> tmp_mp;\n\t\t\tint tmp_ar[4][4] = {{c[i][0],c[i][3],c[j][2],c[j][1]},{c[i][1],c[i][0],c[j][1],c[j][0]},{c[i][2],c[i][1],c[j][0],c[j][3]},{c[i][3],c[i][2],c[j][3],c[j][2]}};\n\t\t\tT tmp_t;\n\t\t\ttmp_mp[make(c[j])]++;\n\t\t\trep(l,4){\n\t\t\t\ttmp_t = make(tmp_ar[l]);\n\t\t\t\tpart *= mp[tmp_t] - tmp_mp[tmp_t];\n\t\t\t\tif(tmp_ar[l][0] == tmp_ar[l][2] && tmp_ar[l][1] == tmp_ar[l][3]){\n\t\t\t\t\tpart *= tmp_ar[l][0] == tmp_ar[l][1] ? 4 : 2;\n\t\t\t\t}\n\t\t\t\ttmp_mp[tmp_t]++;\n\t\t\t}\n\t\t\tans += part;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "解けてるはず"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile &a, tile &b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) return a.color[i] < b.color[i];\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) tmp.color[i] = t.color[i];\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    tmp = comp;\n  }\n}\n\nbool same(const tile &a, const tile &b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= a.color[i] == b.color[i];\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) cin >> t[i].color[j];\n  }\n\n  for (int i = 0; i < N; ++i) regulation(t[i]);\n  sort(t, t+N, comp_tile);\n\n\n  ll ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) top.color[k] = t[i].color[k];\n        for (int k = 0; k < 4; ++k) bottom.color[k] = t[j].color[k];\n        for (int k = 0; k < 4; ++k) {\n          tile tmp;\n          for (int l = 0; l < 4; ++l) tmp.color[l] = bottom.color[l];\n          bottom.color[0] = tmp.color[3];\n          bottom.color[1] = tmp.color[0];\n          bottom.color[2] = tmp.color[1];\n          bottom.color[3] = tmp.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) regulation(sides[l]);\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int t = 0;\n            if (lb <= i && i < ub) ++t;\n            if (lb <= j && j < ub) ++t;\n            match_count[m] = ub-lb-t;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) tmp.color[n] = sides[m].color[n];\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) symmetry_count[m]++;\n              tmp = cmp;\n            }\n          }\n\n          ll tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int t = 0;\n            for (int n = 0; n < m; ++n) if (same(sides[n],sides[m])) ++t;\n            if (match_count[m] - t <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= match_count[m] - t;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint const N = 1234;\n \nlong long f[N];\nint c[N][4];\nlong long dp[42];\nint can[42];\nlong long cr[N][4];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", c[i] + j);\n    }\n    \n    \n    for (int rot = 0; rot < 4; rot++) {\n      long long z = 0;\n      for (int e = 0; e < 4; e++) {\n        z = z * 1000 + c[i][(e + rot) & 3];\n      }\n      cr[i][rot] = z;\n    }\n  }\n  \n  long long ans = 0;\n  for (int first = 0; first < n; first++) \n  {\n    for (int back = first + 1; back < n; back++) \n    {\n      for (int rb = 0; rb < 4; rb++) \n      {\n        for (int i = 0; i < 4; i++) \n        {\n          f[i] = c[first][(i + 1) & 3];\n          f[i] = f[i] * 1000 + c[first][i];\n          f[i] = f[i] * 1000 + c[back][(-i + rb + 1) & 3];\n          f[i] = f[i] * 1000 + c[back][(-i + rb) & 3];\n        }\n        memset(dp, 0, sizeof(dp));\n        dp[0] = 1;\n        for (int i = first + 1; i < n; i++) \n        {\n          if (i == back) continue;\n          for (int j = 0; j < 4; j++) \n          {\n            can[j] = 0;\n            for (int rot = 0; rot < 4; rot++) \n            {\n              if (f[j] == cr[i][rot]) \n              {\n                ++can[j];\n              }\n            }\n          }\n          \n          dp[15] += dp[14] * can[0];\n          dp[15] += dp[13] * can[1];\n          dp[15] += dp[11] * can[2];\n          dp[15] += dp[7] * can[3];\n          dp[14] += dp[12] * can[1];\n          dp[14] += dp[10] * can[2];\n          dp[14] += dp[6] * can[3];\n          dp[13] += dp[12] * can[0];\n          dp[13] += dp[9] * can[2];\n          dp[13] += dp[5] * can[3];\n          dp[12] += dp[8] * can[2];\n          dp[12] += dp[4] * can[3];\n          dp[11] += dp[10] * can[0];\n          dp[11] += dp[9] * can[1];\n          dp[11] += dp[3] * can[3];\n          dp[10] += dp[8] * can[1];\n          dp[10] += dp[2] * can[3];\n          dp[9] += dp[8] * can[0];\n          dp[9] += dp[1] * can[3];\n          dp[8] += dp[0] * can[3];\n          dp[7] += dp[6] * can[0];\n          dp[7] += dp[5] * can[1];\n          dp[7] += dp[3] * can[2];\n          dp[6] += dp[4] * can[1];\n          dp[6] += dp[2] * can[2];\n          dp[5] += dp[4] * can[0];\n          dp[5] += dp[1] * can[2];\n          dp[4] += dp[0] * can[2];\n          dp[3] += dp[2] * can[0];\n          dp[3] += dp[1] * can[1];\n          dp[2] += dp[0] * can[1];\n          dp[1] += dp[0] * can[0];\n        }\n        ans += dp[15];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nlong get(long a,int k){return k==1?a%1000:k==2?a/1000%1000:k==3?a/1000000%1000:a/1000000000;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nlong C[400];\nmap<long,array<array<array<long,5>,5>,5> >M;\nmap<long,vector<int> >P;\nmap<long,multiset<int> >Q;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tC[i]=conv(a,b,c,d);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C[i]]++;\n\t\t\tQ[C[i]].insert(i);\n\t\t\tC[i]=rotate(C[i]);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tP[it->first].push_back(it->second);\n\t\t}\n\t}\n\tfor(map<long,vector<int> >::iterator it=P.begin();it!=P.end();it++)\n\t{\n\t\tarray<array<array<long,5>,5>,5>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(int c:it->second)\n\t\t{\n\t\t\tsum+=c;\n\t\t\tct[c]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<5;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tif(j<k)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<5;i++)A[i][j][k]=A[i][k][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA[0][j][k]=1;\n\t\t\t\tA[1][j][k]=sum-j-k;\n\t\t\t\tA[2][j][k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\t\tA[3][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t\t-(sum-j-k-ct[2])*ct[2]*6\n\t\t\t\t\t-(sum-j-k-ct[3])*ct[3]*3*6-ct[3]*6\n\t\t\t\t\t-(sum-j-k-ct[4])*ct[4]*6*6-ct[4]*24;\n\t\t\t\tA[4][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t\t-(sum-j-k-ct[2])*(sum-j-k-ct[2]-1)/2*ct[2]*24\n\t\t\t\t\t-(sum-j-k-ct[3])*(sum-j-k-ct[3]-1)/2*ct[3]*3*24-(sum-j-k-ct[3])*ct[3]*24\n\t\t\t\t\t-(sum-j-k-ct[4])*(sum-j-k-ct[4]-1)/2*ct[4]*6*24-(sum-j-k-ct[4])*ct[4]*4*24-ct[4]*24\n\t\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\t}\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong a=C[i];\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tlong b=C[j];\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tb=rotate(b);\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(get(a,3),get(a,4),get(b,3),get(b,4)),\n\t\t\t\t\tconv(get(a,4),get(a,1),get(b,2),get(b,3)),\n\t\t\t\t\tconv(get(a,1),get(a,2),get(b,1),get(b,2)),\n\t\t\t\t\tconv(get(a,2),get(a,3),get(b,4),get(b,1)),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint a=Q[t[k]].count(i);\n\t\t\t\t\tint b=Q[t[k]].count(j);\n\t\t\t\t\tnow*=M[t[k]][cc[k]][a][b];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int Maxn = 410;\n#define For( i, j, k ) for( int i = j; i <= k; ++i )\nusing std::cin;\nusing std::cout;\nstruct Node\n{\n\tint col[ 4 ];\n\tfriend bool operator < ( const Node &a, const Node &b )\n\t{\n\t\tFor( i, 0, 3 )\n\t\t\tif( a.col[ i ] != b.col[ i ] )\n\t\t\t\treturn a.col[ i ] < b.col[ i ];\n\t\treturn 0;\n }\n}elvahs[ 410 ];\nNode nxt( Node x )\n{\n\treturn ( Node ) { x.col[ 1 ], x.col[ 2 ], x.col[ 3 ], x.col[ 0 ] }; \n}\nstd::map < Node, int > mp;\ninline void insert( Node a, int x )\n{\n\tfor( int i = 0; i < 4; ++i, a = nxt( a ) )\n\t\tmp[ a ] += x;\n}\nint main( )\n{\n\tstd::ios::sync_with_stdio( false );\n\tint n;\n\tlong long ans = 0;\n\tcin >> n;\n\tFor( i, 1, n )\n\t\tcin >> elvahs[ i ].col[ 0 ] >> elvahs[ i ].col[ 1 ] >> elvahs[ i ].col[ 2 ] >> elvahs[ i ].col[ 3 ],\n\t\tinsert( elvahs[ i ], 1 );\n\tFor( i, 1, n )\n\t{\n\t\tinsert( elvahs[ i ], -1 );\n\t\tFor( j, i + 1, n )\n\t\t{\n\t\t\tinsert( elvahs[ j ], -1 );\n\t\t\tFor( t, 0, 3 )\n\t\t\t{\n\t\t\t\tNode a1 = Node{ elvahs[ j ].col[ 3 ], elvahs[ i ].col[ 0 ], elvahs[ i ].col[ 3 ], elvahs[ j ].col[ 0 ] },\n\t\t\t\ta2 = Node{ elvahs[ j ].col[ 0 ], elvahs[ i ].col[ 3 ], elvahs[ i ].col[ 2 ], elvahs[ j ].col[ 1 ] },\n\t\t\t a3 = Node{ elvahs[ j ].col[ 1 ], elvahs[ i ].col[ 2 ], elvahs[ i ].col[ 1 ], elvahs[ j ].col[ 2 ] },\n\t\t\t\ta4 = Node{ elvahs[ j ].col[ 2 ], elvahs[ i ].col[ 1 ], elvahs[ i ].col[ 0 ], elvahs[ j ].col[ 3 ] };\n\t\t\t\telvahs[ j ] = nxt( elvahs[ j ] );\n\t\t\t\tif( !mp[ a1 ] || !mp[ a2 ] || !mp[ a3 ] || !mp[ a4 ] )\n\t\t\t\t\tcontinue;\n    long long res = 1;\n\t\t\t\tres *= mp[ a1 ];insert( a1, -1 );\n\t\t\t\tres *= mp[ a2 ];insert( a2, -1 );\n\t\t\t\tres *= mp[ a3 ];insert( a3, -1 );\n\t\t\t\tres *= mp[ a4 ];\n\t\t\t\tinsert( a1, 1 ); insert( a2, 1 ); insert( a3, 1 );\n\t\t\t\tans += res;\n\t\t\t}\n\t\t\tinsert( elvahs[ j ], 1 );\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define N 410\n#define k1 1000\n#define k2 1000000\n#define k3 1000000000\n#define ll long long\nusing namespace std;\nint n, a[N][4];\nll ans, ans1, b[5];\nmap<ll, int>mp;\ninline ll id(int a, int b, int c, int d){return (ll)a*k3+b*k2+c*k1+d;}\ninline void ins(ll x, int y){\n\tint a=x/k3, b=x/k2%k1, c=x/k1%k1, d=x%k1;\n\tmp[id(a, b, c, d)]+=y;\n\tmp[id(b, c, d, a)]+=y;\n\tmp[id(c, d, a, b)]+=y;\n\tmp[id(d, a, b, c)]+=y;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tmp.clear();\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=0; j<=3; j++)scanf(\"%d\", &a[i][j]);\n\t\tins(id(a[i][0], a[i][1], a[i][2], a[i][3]), 1);\n\t}\n\tans=0;\n\tfor(int i=1; i<=n-5; i++){\n\t\tins(id(a[i][0], a[i][1], a[i][2], a[i][3]), -1);\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t\tfor(int k=0; k<=3; k++){\n\t\t\t\tins(id(a[j][0], a[j][1], a[j][2], a[j][3]), -1);\n\t\t\t\tb[1]=id(a[i][0], a[j][(0+k)%4], a[j][(3+k)%4], a[i][1]);\n\t\t\t\tb[2]=id(a[i][1], a[j][(3+k)%4], a[j][(2+k)%4], a[i][2]);\n\t\t\t\tb[3]=id(a[i][2], a[j][(2+k)%4], a[j][(1+k)%4], a[i][3]);\n\t\t\t\tb[4]=id(a[i][3], a[j][(1+k)%4], a[j][(0+k)%4], a[i][0]);\n\t\t\t\tans1=1; for(int ii=1; ii<=4; ii++){ans1*=mp[b[ii]]; ins(b[ii], -1);}\n\t\t\t\tans+=ans1; for(int ii=1; ii<=4; ii++)ins(b[ii], 1);\n\t\t\t\tins(id(a[j][0], a[j][1], a[j][2], a[j][3]), 1);\n\t\t\t}\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint64_t encode(vector<int>& c){\n    int64_t ret = 1e18;\n    for(int i=0; i<4; i++){\n        int64_t result = 0;\n        for(int j=0; j<4; j++){\n            result *= 1000;\n            result += c[(i+j)%4];\n        }\n        ret = min(ret, result);\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> C[400];\n    map<int64_t, int> mp;\n    for(int i=0; i<N; i++){\n        C[i].resize(4);\n        for(int j=0; j<4; j++) cin >> C[i][j];\n        mp[encode(C[i])]++;\n    }\n\n    int64_t ans = 0;\n    for(int i=0; i<N; i++){\n        int64_t ci = encode(C[i]);\n        mp[ci]--;\n        for(int j=i+1; j<N; j++){\n            int64_t cj = encode(C[j]);\n            mp[cj]--;\n\n            for(int k=0; k<4; k++){\n                int64_t result = 1;\n                vector<int64_t> use;\n                for(int l=0; l<4; l++){\n                    vector<int> c = {C[i][(l+1)%4], C[i][l], C[j][(3-l+k)%4], C[j][(3-l-1+k+4)%4]};\n                    int64_t code = encode(c);\n                    if(mp[code] > 0){\n                        result *= mp[code];\n                        if(c[0]==c[2] && c[1]==c[3]){\n                            result *= (c[0]==c[1] ? 4 : 2);\n                        }\n                        mp[code]--;\n                        use.push_back(code);\n                    }else{\n                        result = 0;\n                        break;\n                    }\n                }\n                ans += result;\n                for(auto code : use) mp[code]++;\n            }\n\n            mp[cj]++;\n        }\n        mp[ci]++;\n    }\n    cout << ans/3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link renamelink\n#define next renamenext\n#define prev renameprev\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string& fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 500, P = 1000;\n\ntypedef vector<LL> tile;\n\nint n;\ntile t[N];\nLL hsv[N];\nmap<LL, LL> c, rc;\n\ntile rotate(const tile& t) {\n  tile res(4);\n  for (int i = 0; i < 4; i++) res[i] = t[(i + 1) & 3];\n  return res;\n}\nLL gethash(const tile& t) {\n  return (t[0] * P * P * P + t[1] * P * P + t[2] * P + t[3]);\n}\nLL calchash(tile t) {\n  LL res = gethash(t);\n  for (int i = 0; i < 4; i++, t = rotate(t)) res = min(res, gethash(t));\n  return res;\n}\nLL getrot(const tile& t) {\n  tile p = t;\n  LL res = 0;\n  for (int i = 0; i < 4; i++, p = rotate(p)) res += (p == t);\n  return res;\n}\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    t[i].resize(4);\n    for (int j = 0; j < 4; j++) cin >> t[i][j];\n    c[hsv[i] = calchash(t[i])]++;\n    rc[hsv[i]] = getrot(t[i]);\n  }\n\n  LL ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      c[hsv[i]]--, c[hsv[j]]--;\n      for (int k = 0; k < 4; k++) {\n        map<LL, LL> m;\n        m[calchash({t[i][1], t[i][0], t[j][1], t[j][0]})]++;\n        m[calchash({t[i][0], t[i][3], t[j][2], t[j][1]})]++;\n        m[calchash({t[i][3], t[i][2], t[j][3], t[j][2]})]++;\n        m[calchash({t[i][2], t[i][1], t[j][0], t[j][3]})]++;\n        LL tmp = 1;\n        for (pair<LL, LL> it : m) {\n          for (int i = 0; i < it.second; i++)\n            tmp *= (c[it.first] - i) * rc[it.first];\n        }\n        ans += tmp;\n        t[j] = rotate(t[j]);\n      }\n      c[hsv[i]]++, c[hsv[j]]++;\n    }\n  }\n  cout << ans / 3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\nint mod = 1e9+7;\n\nvi normalize(vi v){\n\tvi ret(4,1e9);\n\trep(i,4){\n\t\tchmin(ret,v);\n\t\trotate(v.begin(),v.begin()+1,v.end());\n\t}\n\treturn ret;\n}\n\nint calc(vi v){\n\tint ret = 0;\n\tvi vc = v;\n\trep(i,4){\n\t\tif(v == vc)ret++;\n\t\trotate(v.begin(), v.begin()+1, v.end());\n\t}\n\treturn ret;\n}\n\nvi fs[500];\nmap<vi, P> cnt1;\nmap<vi, int> cnt2;\n\nsigned main(){\n\tint n;\n\tscanf(\"%lld\", &n);\n\trep(i,n){\n\t\tvi v(4);\n\t\trep(j,4)cin >> v[j];\n\t\tfs[i] = normalize(v);\n\t\tint t = calc(fs[i]);\n\t\tcnt1[fs[i]].fi++;\n\t\tcnt1[fs[i]].se = t;\n\t}\n\t\n\tint ans = 0;\n\trep(i,n)rep(j,n){\n\t\tif(i == j)continue;\n\t\trep(k,4){\n\t\t\tvi bot = fs[i], top = fs[j];\n\t\t\tcnt2[bot]++;cnt2[top]++;\n\t\t\trotate(top.begin(), top.begin()+k, top.end());\n\t\t\tint tmp = 1;\n\t\t\trep(l,4){\n\t\t\t\tvi side = {bot[0], top[1], top[0], bot[1]};\n\t\t\t\tside = normalize(side);\n\t\t\t\t//if(cnt2[side]+1 > cnt1[side].fi)tmp = 0;\n\t\t\t\ttmp *= cnt1[side].se*(cnt1[side].fi-cnt2[side]);\n\t\t\t\tcnt2[side]++;\n\t\t\t\trotate(top.begin(), top.begin()+1, top.end());\n\t\t\t\trotate(bot.begin(), bot.begin()+3, bot.end());\n\t\t\t}\n\t\t\tans += tmp;\n\t\t\tcnt2.clear();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans/6);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=404;\n\ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n\ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nint n,a[N][4];\nLL b[N];\n\nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n\n    // 1045, 2156, 3267, 0374\n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    // dump(VI(cc,cc+8));\n    // REP(i,4) dump(vector<LL>(c[i],c[i]+4));\n    LL dp[16]={1};\n    REP1(i,ti+1,n) if ( i!=bi ) {\n        for ( int j=14; j>=0; j-- ) REP(k,4) if ( !bit(j,k) ) {\n            REP(d,4) if ( b[i]==c[k][d] ) dp[j|(1<<k)]+=dp[j];\n        }\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[15];\n}\n\nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    REP1(i,1,n) b[i]=f(a[i][0],a[i][1],a[i][2],a[i][3]);\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nint b[1010][4];\nlong long a[1010][4];\nmap<long long, int> m, m2, m4;\nint mul2[5] = {1, 2, 4, 8, 16};\nint mul4[5] = {1, 4, 16, 64, 256};\nlong long pp[1010][5];\nlong long go(long long v, int t) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= t; i++) {\n\t\tif (m[v] < i) break;\n\t\tfor (int j = 0; j <= t - i; j++) {\n\t\t\tif (m2[v] < j) break;\n\t\t\tint k = t - i - j;\n\t\t\tif (m4[v] >= k) {\n\t\t\t\tres += pp[m[v]][i] * pp[m2[v]][j] * pp[m4[v]][k] * mul2[j] * mul4[k];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint ti[1010];\nvoid reg(int i, int j, int x) {\n\tif (ti[i] == 4) {\n\t\tm4[a[i][0]] += x;\n\t}\n\tif (ti[i] == 2) {\n\t\tm2[*min_element(a[i], a[i] + 2)] += x;\n\t}\n\tif (ti[i] == 1) {\n\t\tm[*min_element(a[i], a[i] + 4)] += x;\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tpp[0][0] = 1;\n\tfor (int i = 1; i < 1010; i++) {\n\t\tpp[i][0] = 1;\n\t\tfor (int j = 1; j < 5; j++) {\n\t\t\tpp[i][j] = pp[i][j-1] * (i - j + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\ta[i][j] = (a[i][j] << 10) | b[i][(j+k)%4];\n\t\t\t}\n\t\t}\n\t\tint *v = b[i];\n\t\tif (v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) {\n\t\t\tti[i] = 4;\n\t\t\tm4[a[i][0]]++;\n\t\t} else if (v[0] == v[2] && v[1] == v[3]) {\n\t\t\tti[i] = 2;\n\t\t\tm2[*min_element(a[i], a[i] + 2)]++;\n\t\t} else {\n\t\t\tti[i] = 1;\n\t\t\tm[*min_element(a[i], a[i] + 4)]++;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v[4];\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tv[j] = (a[i][0] >> (j * 10)) & 1023;\n\t\t}\n\t\treg(i, 0, -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint w[4];\n\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\tw[l] = (a[j][0] >> (l * 10)) & 1023;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\treg(j, k, -1);\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\tmap<long long, int> f;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tint u[4];\n\t\t\t\t\tu[0] = w[l];\n\t\t\t\t\tu[1] = w[(l+1)%4];\n\t\t\t\t\tu[2] = v[(l+1)%4];\n\t\t\t\t\tu[3] = v[l];\n\t\t\t\t\tlong long z = 1ll << 61;\n\t\t\t\t\tfor (int r = 0; r < 4; r++) {\n\t\t\t\t\t\tlong long tmp = 0;\n\t\t\t\t\t\tfor (int q = 0; q < 4; q++) {\n\t\t\t\t\t\t\ttmp = (tmp << 10) | u[(r+q)%4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = min(z, tmp);\n\t\t\t\t\t}\n\t\t\t\t\tf[z]++;\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (map<long long, int>::iterator it = f.begin(); it != f.end(); it++) {\n\t\t\t\t\ttmp *= go(it->first, it->second);\n\t\t\t\t}\n\n\t\t\t\tans += tmp;\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\trotate(w, w + 1, w + 4);\n\t\t\t\treg(j, k, 1);\n\t\t\t}\n\t\t}\n\t\treg(i, 0, 1);\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define uint unsigned long long\n#define ll long long\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define eps 1e-9\n\nusing namespace std;\nconst db pi = acos(-1.0);\ninline int read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\n#define Node(a, b, c, d) mp(a,mp(b,mp(c,d)))\nmap <pair<int, pair<int, pii> >, ll> cnt;\nconst int N = 500;\n\nint A[N][4];\nint n;\n\npair<int, pair<int,pii> > stand(pair<int, pair<int,pii> > t)\n{\n    int num[4];\n    num[0] = t.X;\n    num[1] = t.Y.X;\n    num[2] = t.Y.Y.X;\n    num[3] = t.Y.Y.Y;\n    pair<int, pair<int,pii> > tmp[4];\n    rep(s, 0, 3)\n        tmp[s] = Node(num[(s + 0) % 4], num[(s + 1) % 4], num[(s + 2) % 4], num[(s + 3) % 4]);\n    sort(tmp, tmp + 4);\n    return tmp[0];\n\n}\n\nvoid update(int id,int val)\n{\n    pair<int, pair<int,pii> > now = stand(Node(A[id][0], A[id][1], A[id][2], A[id][3]));\n    cnt[now] += val;\n}\n\nint main()\n{\n    n = read();\n    rep(i, 1, n)\n    {\n        rep(j, 0, 3) A[i][j] = read();\n        update(i,1);\n    }\n\n    ll res = 0;\n    rep(i, 1, n)\n    {\n        update(i, -1);\n        rep(j, 1, n)\n            if(i != j)\n            {\n                update(j, -1);\n                int Down[4];\n                rep(x, 0, 3) Down[x] = A[i][x];\n                int Up[4];\n                rep(us, 0, 3)\n                {\n                \trep(y, 0, 3) Up[y] = A[j][(us - y + 4) % 4];\n                    ll now = 1;\n                    pair<int, pair<int,pii> > X[4];\n                    rep(k, 0, 3)\n                    {\n                        X[k] = stand(Node(Down[k], Up[k], Up[(k + 1) % 4], Down[(k + 1) % 4]));\n                        int c = 0;\n                        now *= (cnt[X[k]] - c);\n\n                    }\n                    res += now;\n                }\n                update(j, 1);\n            }\n\n        update(i, 1);\n    }\n\n    printf(\"%lld\\n\",res);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef deque<int> D;\n\nD f(D d) {\n\tD ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d[0]);\n\t\td.pop_front();\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint overlap(D d) {\n\tint ret = 1;\n\tD t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d[0]);\n\t\td.pop_front();\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\n\nll P(int n, int k) {\n\tll ret = 1;\n\tfor(int i = n - k + 1; i <= n; i++) {\n\t\tret *= i;\n\t}\n\treturn ret;\n}\n\nD C[400];\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<D, int> m;\n\tmap<D, int> cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tC[i].push_back(c);\n\t\t}\n\t\tC[i] = f(C[i]);\n\t\tm[C[i]]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tD d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\tD d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<D, int> t;\n\t\t\t\tt[f(D({ d1[1], d1[0], d2[1], d2[0] }))]++;\n\t\t\t\tt[f(D({ d1[0], d1[3], d2[2], d2[1] }))]++;\n\t\t\t\tt[f(D({ d1[3], d1[2], d2[3], d2[2] }))]++;\n\t\t\t\tt[f(D({ d1[2], d1[1], d2[0], d2[3] }))]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P(m[p.first], p.second);\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\td1.push_back(d1[0]);\n\t\t\t\td1.pop_front();\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\nusing ll = long long;\nusing color_t = uint16_t;\nusing namespace std;\ntemplate <class T> void setmin(T & a, T const & b) { if (b < a) a = b; }\n\n\narray<color_t,4> rotate(array<color_t, 4 > c, int r) {\n    // r分ずつ左にずれる\n    rotate(c.begin(), c.begin() + r, c.end());\n    return c;\n}\n\n\nvoid normalize(array<color_t,4> & c) {\n    // 各面の表記を統一させる\n    // この場合は角の色を数列として考えて、その辞書順で最も小さいのを探している\n    array<color_t,4> d = c;\n    for(int r = 0; r < 4; r++){\n        setmin(c, rotate(d, r));\n    }\n}\n\n\nint multiplicity(array<color_t,4> const & c) {\n    // 回転させても同じ色の配置になる回数\n    int n = 1;\n    for (int r = 1; r < 4; r++){\n        if (c == rotate(c, r)){\n            n += 1;\n        }\n    }\n    return n;\n}\n\n\nint main() {\n    int n; cin >> n;\n    vector<array<color_t,4> > c(n);\n    for (int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++){\n            cin >> c[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++){\n        // 各パネルの表現を決める\n        normalize(c[i]);\n    }\n    \n    map<array<color_t,4>,int> cnt;\n    for(int i = 0; i < n; i++){\n        // 同じパネルが何枚あるか\n        cnt[c[i]] += 1;\n    }\n    map<array<color_t,4>,int> mul;\n    for (auto it : cnt){\n        mul[it.first] = multiplicity(it.first);\n    }\n\n    ll ans = 0;\n    for(int bi = 0; bi < n; bi++){\n        for(int ai = 0; ai < bi; ai++){\n        // 一枚ずつ使用している\n        // 後で元に戻す\n        cnt[c[ai]] -= 1;\n        cnt[c[bi]] -= 1;\n        for(int br = 0; br < 4; br++){\n            // bの面をbr回、回転させる\n            //    b0 -- b3\n            //   /     / |\n            // a0 -- a1  |\n            //  | _b1_|_ | b2\n            //  |     | /\n            // a3 -- a2\n            array<color_t,4> const & a = c[ai];\n            array<color_t,4> b = rotate(c[bi], br);\n            array<array<color_t,4>,4> ds;\n            // 各側面の角の色の組み合わせ\n            ds[0] = { b[0], b[3], a[1], a[0] };\n            ds[1] = { b[3], b[2], a[2], a[1] };\n            ds[2] = { b[2], b[1], a[3], a[2] };\n            ds[3] = { b[1], b[0], a[0], a[3] };\n\n            ll acc = 1;\n            map<array<color_t,4>,int> used;\n            for (auto & d : ds) {\n                normalize(d);\n                if (!cnt.count(d)){\n                    // この角の色の組み合わせの側面は存在していない\n                    acc = 0;\n                    break;\n                }\n                used[d] += 1; // 使用した回数\n                acc *= mul[d] * (cnt[d] - used[d] + 1); // 重複した回転*(使用できる枚数　- 使用した枚数 + 1)\n            }\n            ans += acc;\n        }\n        cnt[c[ai]] += 1;\n        cnt[c[bi]] += 1;\n        }\n    }\n    ans /= 3;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nmap<ll, vector<int>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                m[msk].PB(i);\n        }\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk= 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (int i : m[msk]) {\n                                cub[i][p]++;\n                        }\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, top+1, N) if (i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                        fo(x, 0, 4) if (cub[i][x]) {\n                                fo(j, 0, 15) if ((j&(1<<x)) == 0 && old[j]) {\n                                        ways[j|(1<<x)] += old[j] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nint n;\nll t1000[4];\nvoid init() {\n\tt1000[0] = 1;\n\trep(i, 3) {\n\t\tt1000[i + 1] = t1000[i] * 1000;\n\t}\n}\nll calc(ll a, ll b, ll c, ll d) {\n\tll res = INF;\n\tvector<ll> v = { a,b,c,d };\n\trep(j, 4) {\n\t\tll sum = 0;\n\t\trep(k, 4) {\n\t\t\tsum += v[k] * t1000[k];\n\t\t}\n\t\tres = min(res, sum);\n\t\tv.push_back(v[0]);\n\t\tv.erase(v.begin());\n\t}\n\treturn res;\n}\nll c[400];\nll turn(ll x) {\n\tvector<ll> v;\n\tper(j, 4) {\n\t\tv.push_back(x / t1000[j]);\n\t\tx %= t1000[j];\n\t}\n\treverse(v.begin(), v.end());\n\tv.push_back(v[0]); v.erase(v.begin());\n\tll res = 0;\n\trep(j, 4) {\n\t\tres += v[j] * t1000[j];\n\t}\n\treturn res;\n}\nvector<ll> query(ll k) {\n\tvector<ll> res;\n\tper(j, 4) {\n\t\tres.push_back(k / t1000[j]);\n\t\tk %= t1000[j];\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nmap<ll, int> mp,num;\nint main() {\n\tinit();\n\tcin >> n;\n\trep(i, n) {\n\t\tll x, y, z, w; cin >> x >> y >> z >> w;\n\t\tc[i] = calc(x, y, z, w);\n\t\tmp[c[i]]++;\n\t\tll t = c[i];\n\t\tint cnt = 0;\n\t\trep(j, 4) {\n\t\t\tt = turn(t);\n\t\t\tif (t == c[i])cnt++;\n\t\t}\n\t\tnum[c[i]] = cnt;\n\t\t//cout << c[i] << endl;\n\t}\n\tll ans = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == j)continue;\n\t\t\tll t = c[j];\n\t\t\t//cout << i << \" \" << j << endl;\n\t\t\trep(k, 4) {\n\t\t\t\tt = turn(t);\n\t\t\t\tvector<ll> a1 = query(c[i]), a2 = query(t);\n\t\t\t\tll z1 = calc(a1[3], a1[2], a2[1], a2[0]);\n\t\t\t\tll z2 = calc(a1[2], a1[1], a2[2], a2[1]);\n\t\t\t\tll z3 = calc(a1[1], a1[0], a2[3], a2[2]);\n\t\t\t\tll z4 = calc(a1[0], a1[3], a2[0], a2[3]);\n\t\t\t\t//cout << z1 << endl;\n\t\t\t\tll c1 = mp[z1];\n\t\t\t\tif (z1 == c[i])c1--;\n\t\t\t\tif (z1 == c[j])c1--;\n\t\t\t\tll c2 = mp[z2];\n\t\t\t\tif (z2 == c[i])c2--;\n\t\t\t\tif (z2 == c[j])c2--;\n\t\t\t\tif (z2 == z1)c2--;\n\t\t\t\tll c3 = mp[z3];\n\t\t\t\tif (z3 == c[i])c3--;\n\t\t\t\tif (z3 == c[j])c3--;\n\t\t\t\tif (z3 == z1)c3--;\n\t\t\t\tif (z3 == z2)c3--;\n\t\t\t\tll c4 = mp[z4];\n\t\t\t\tif (z4 == c[i])c4--;\n\t\t\t\tif (z4 == c[j])c4--;\n\t\t\t\tif (z4 == z1)c4--;\n\t\t\t\tif (z4 == z2)c4--;\n\t\t\t\tif (z4 == z3)c4--;\n\t\t\t\tc1 *= num[z1];\n\t\t\t\tc2 *= num[z2];\n\t\t\t\tc3 *= num[z3];\n\t\t\t\tc4 *= num[z4];\n\t\t\t\t//cout << c1 << \" \" << c2 << \" \" << c3 << \" \" << c4 << endl;\n\t\t\t\tans += c1 * c2*c3*c4;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << ans << endl;\n\tcout << ans / 6 << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nvector<int> C[405];\n\nvoid rotate(vector<int> &a) {\n    a.push_back(a[0]);\n    a.erase(a.begin());\n}\n\nvoid minimize(vector<int> &a) {\n    vector<int> ret;\n    for(int i = 0; i < a.size(); i++) ret.push_back(a[i]);\n    for(int i = 0; i < a.size(); i++) {\n        rotate(a);\n        chmin(ret, a);\n    }\n    for(int i = 0; i < a.size(); i++) a[i] = ret[i];\n}\n\nll ans = 0;\nmap<vector<int>, int> mp;\n\nvoid g(vector<int> a, vector<int> b, ll index, ll factor) {\n    if(index == a.size()) {\n        ans += factor;\n        /*\n        cerr << \"---------\" << endl;\n        for(int i = 0; i < a.size(); i++) cerr << a[i] << \" \";\n        cerr << endl;\n        for(int i = 0; i < a.size(); i++) cerr << b[i] << \" \";\n        cerr << endl;\n        cerr << factor << endl;\n        */\n        return;\n    }\n    vector<int> tmp;\n    int M = a.size();\n    tmp.push_back(a[(index + 1) % M]);\n    tmp.push_back(a[index % M]);\n    tmp.push_back(b[(2 * N - index) % M]);\n    tmp.push_back(b[(2 * N - index - 1) % M]);\n    minimize(tmp);\n    vector<int> v = tmp;\n    ll counter = 0;\n    for(int i = 0; i < v.size(); i++) {\n        rotate(v);\n        if(v == tmp) counter++;\n        /*\n        for(int i = 0; i < v.size(); i++) cerr << v[i] << \" \";\n        cerr << counter << endl;\n        */\n    }\n    /*\n    cerr << \"tmp: \";\n    for(int i = 0; i < tmp.size(); i++) {\n        cerr << tmp[i] << \" \";\n    }\n    cerr << endl;\n    */\n    ll now = mp[tmp];\n    mp[tmp]--;\n    //cerr << \"factor: \" << index << \" \" << factor << \" \" << now << \" \" << counter << endl;\n    g(a, b, index + 1, factor * now * counter);\n    mp[tmp]++;\n}\n\nvoid f(int up, int down) {\n    mp[C[down]]--;\n    for(int i = 0; i < C[down].size(); i++) {\n        g(C[up], C[down], 0, 1);\n        rotate(C[down]);\n    }\n    mp[C[down]]++;\n    /*\n    cerr << up << \" \" << down << \" \" << mp[C[down]] << endl;\n    for(int i = 0; i < C[down].size(); i++) cerr << C[down][i] << \" \";\n    cerr << endl;\n    */\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 1; i <= N; i++) {\n        C[i].resize(4);\n        for(int k = 0; k < 4; k++) cin >> C[i][k];\n        minimize(C[i]);\n        /*\n        for(int j = 0; j < C[i].size(); j++) {\n            cerr << C[i][j] << \" \";\n        }\n        cerr << endl;\n        */\n    }\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j < i; j++) {\n            f(i, j);\n        }\n        mp[C[i]]++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N*4];\nint pa[4]={1,0,3,2};\nmap<TILE,int> mp;\n\nint main(){\n\tscanf(\"%d\",&N);\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tT[i*4]=TILE(a,b,c,d,i);\n\t\tFOR(j,1,4){\n\t\t\tT[i*4+j]=rotate(T[i*4],j);\n\t\t}\n\t}\n//\tsort(T,T+N*4);\n\tREP(i,N*4){\n\t\tmp[T[i]]++;\n\t}\n\tll ans=0;\n\tTILE TI[6];\n\tint cnt[4];\n\tint cnt2[4][4];\n\tREP(i,N*4){\n\t\tTI[0]=T[i];\n\t\tFOR(j,i+1,N*4){\n\t\t\tif (TI[0].index==T[j].index) continue;\n\t\t\tTI[1]=T[j];\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tREP(k,4){\n\t\t\t\tTI[k+2]=TILE(TI[0].c[(k+1)%4],TI[0].c[k],TI[1].c[pa[k]],TI[1].c[pa[(k+1)%4]],0);\n\t\t\t}\n\t\t\tREP(k,4){\n//\t\t\t\tcnt[k]=upper_bound(T,T+N*4,TI[k+2])-lower_bound(T,T+N*4,TI[k+2]);\n\t\t\t\tcnt[k]=mp[TI[k+2]];\n\t\t\t\tREP(a,2){\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a],b)){\n\t\t\t\t\t\t\tcnt[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tFOR(a,k+1,4){\n\t\t\t\t\tcnt2[k][a]=0;\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a+2],b)){\n\t\t\t\t\t\t\tcnt2[k][a]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tll temp=1;\n\t\t\tREP(k,4){\n\t\t\t\tREP(a,k){\n\t\t\t\t\tcnt[k]-=cnt2[a][k];\n\t\t\t\t}\n\t\t\t\tif (cnt[k]<0){\n\t\t\t\t\tf=true;\n\t\t\t\t}else{\n\t\t\t\t\ttemp*=cnt[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f){\n\t\t\t\tans+=temp;\n\t\t\t}\n\t\t}\n\t}\n\tans/=12;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 400 + 5\n#define K 5\n#define base 1000\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, ans, C[N][K];\nmap <int, int> M;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Hash(int a, int b, int c, int d){\n    int ans = 0;\n    ans = ans * base + a, ans = ans * base + b, ans = ans * base + c, ans = ans * base + d;\n    return ans;\n}\nvoid update(int val, int x){\n    int a, b, c, d;\n    d = val % base, val /= base;\n    c = val % base, val /= base;\n    b = val % base, val /= base;\n    a = val % base, val /= base;\n    M[Hash(a, b, c, d)] += x;\n    M[Hash(b, c, d, a)] += x;\n    M[Hash(c, d, a, b)] += x;\n    M[Hash(d, a, b, c)] += x;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n){\n        C[i][0] = read(), C[i][1] = read(), C[i][2] = read(), C[i][3] = read();\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    rep(i, 1, n){\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), -1);\n        rep(j, i + 1, n){\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), -1);\n            rep(k, 0, 3){\n                int AA = Hash(C[i][0], C[i][3], C[j][k], C[j][(3 + k) % 4]);\n                int BB = Hash(C[i][3], C[i][2], C[j][(1 + k) % 4], C[j][k]);\n                int CC = Hash(C[i][2], C[i][1], C[j][(2 + k) % 4], C[j][(1 + k) % 4]);\n                int DD = Hash(C[i][1], C[i][0], C[j][(3 + k) % 4], C[j][(2 + k) % 4]);\n                int a, b, c, d;\n                a = M[AA], update(AA, -1);\n                b = M[BB], update(BB, -1);\n                c = M[CC], update(CC, -1);\n                d = M[DD], update(DD, -1);\n                if(a > 0 && b > 0 && c > 0 && d > 0) ans += a * b * c * d;\n                update(AA, 1), update(BB, 1), update(CC, 1), update(DD, 1);\n            }\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), 1);\n        }\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    } \n    printf(\"%lld\", ans / 3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) 0;\n#endif\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int four = 4;\n  lint kind = 1000;\n  auto coeffs = std::vector<lint>{1,kind, kind*kind,kind*kind*kind};\n  std::reverse(all(coeffs));\n  auto hash = [coeffs] (std::vector< lint > const& v)\n    { return std::inner_product(all(v), std::begin(coeffs), 0ll); };\n  auto unhash = [four, kind] (lint h) {\n    std::vector< lint > ret(four);\n    for (lint & x : ret) {\n      x = h % kind;\n      h /= kind;\n    }\n    std::reverse(all(ret));\n    return ret;\n  };\n  auto hashes_mul = [&] (std::vector< lint > v) {\n    std::vector< lint > h(four);\n    rep(i,0,four) {\n      h.at(i) = hash(v);\n      std::rotate(v.begin(), v.begin()+1, v.end());\n    }\n    std::sort(all(h));\n    h.resize(std::unique(all(h)) - h.begin());\n    return std::make_pair(h, four / h.size());\n  };\n\n  std::map< lint, lint > map;\n  int n; std::cin >> n;\n  auto store = make_vector< 2, lint >(n, four);\n  for (auto& v : store) {\n    std::cin >> v;\n    std::vector<lint> hs; lint m; std::tie(hs, m) = hashes_mul(v);\n    for (lint h : hs) {\n      map[h]++;\n    }\n  }\n\n  auto ind_mat = std::vector< std::vector< int > >{\n    std::vector< int >{ 0, 4, 5, 1 },\n    std::vector< int >{ 1, 5, 6, 2 },\n    std::vector< int >{ 2, 6, 7, 3 },\n    std::vector< int >{ 3, 7, 4, 0 }\n  };\n  auto cal = [&] (lint top, lint bottom) {\n    std::vector< lint > a = unhash(top);\n    std::vector< lint > b = unhash(bottom);\n    lint bottom_ = hashes_mul(b).first.front();\n    std::reverse(all(b));\n    for (lint x : b) a.emplace_back(x);\n    std::map< std::pair<lint, lint>, lint > want;\n    for (auto const& ind_vec: ind_mat) {\n      std::vector< lint > color(four);\n      std::transform(all(ind_vec), color.begin(), [&a](int i){ return a.at(i); });\n      std::vector< lint > hs; lint m; std::tie(hs, m) = hashes_mul(color);\n      lint h = hs.front();\n      // debug(ind_vec, color, unhash(h), m);\n      want[std::make_pair(h, m)]++;\n    }\n    // debug(want);\n    lint ans = 1;\n    for (auto&& pair : want) {\n      std::pair< lint, lint > key; lint want_; std::tie(key, want_) = pair;\n      lint id, mul_ ; std::tie(id, mul_) = key;\n      lint stock = [&]{ auto it = map.find(id); return it != map.end() ? it->second : 0ll; }();\n      stock -= (id == top);\n      stock -= (id == bottom_);\n      lint now = 1;\n      rep(i,0,want_) {\n        now *= stock - i;\n        now *= mul_;\n      }\n      // debug(id, mul_, want_, stock, now);\n      ans *= now;\n    }\n    return ans;\n  };\n  lint ans = 0;\n  rep(i,0,n) rep(j,i+1,n) {\n    std::vector< lint > top_vec, bottom_vec; lint m;\n    std::tie(top_vec, std::ignore) = hashes_mul(store.at(i));\n    std::tie(bottom_vec, m) = hashes_mul(store.at(j));\n    for (lint bottom : bottom_vec) {\n      lint now = cal(top_vec.front(), bottom);\n      // debug(now,m);\n      now *= m;\n      ans += now;\n    }\n  }\n  // debug(ans);\n  assert(ans % 3 == 0);\n  ans /= 3;\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<vector<ll> , vector<ll> > vp;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nvector<ll> reg(const vector<ll> a){\n  vector<ll> res(4,INF);\n  rep(d,4){\n    vector<ll> b;\n    rep(i,4)b.push_back(a[(i+d)%4]);\n    minch(res,b);\n  }\n  return res;\n}\n\nll n;\nvector<ll> c[404][2];\nmap<vector<ll> ,ll> cnt;\nmap<vp,ll> rotc;\n\nint main(){\n\tcin>>n;\n  ll res=0;\n  rep(i,n){\n    rep(j,4){\n      ll cc;\n      cin>>cc;\n      c[i][0].push_back(cc);\n    }\n    c[i][0]=reg(c[i][0]);\n    c[i][1]=c[i][0];\n    reverse(all(c[i][1]));\n    c[i][1]=reg(c[i][1]);\n    cnt[c[i][0]]++;\n  }\n  for(auto it : cnt){\n    rep(d,4){\n      vector<ll> b;\n      rep(k,4)b.push_back(it.fi[(k+d)%4]);\n      rotc[vp(it.fi,b)]++;\n    }\n  }\n  rep(i,n){\n    cnt[c[i][0]]--;\n    repl(j,i+1,n){\n      cnt[c[j][0]]--;\n      rep(d,4){\n        vector<ll> vi,vj;\n        rep(k,4)vj.push_back(c[j][1][(k+d)%4]);\n        vi=c[i][0];\n        map<vp,ll> sccnt;\n        rep(k,4){\n          vector<ll> sc;\n          sc.push_back(vi[k]);\n          sc.push_back(vj[k]);\n          sc.push_back(vj[(k+1)%4]);\n          sc.push_back(vi[(k+1)%4]);\n          vector<ll> rsc=reg(sc);\n          sccnt[vp(rsc,sc)]++;\n        }\n        ll sum=1;\n        for(auto it : sccnt){\n          rep(k,it.se)sum*=(cnt[it.fi.fi]-k)*rotc[it.fi];\n        }\n        res+=max(0LL,sum);\n      }\n      cnt[c[j][0]]++;\n    }\n    cnt[c[i][0]]++;\n  }\n  cout<<res/3<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\nvector<int> color[505];\nmap<vector<int>, int> has;\nint jiao[8];\nint use[4][4]={\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid add(vector<int> color)\n{\n  for (int i=0; i<4; i++)\n  {\n      has[color]++;\n      rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid reduce(vector<int> color)\n{\n\n    for (int i=0; i<4; i++)\n    {\n        has[color]--;\n        rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid dfs(int dep,long long& ans,long long res=1)\n{\n    if (dep==4) ans+=res;\n    else\n    {\n        vector<int> tmp(4);\n        for (int i=0; i<4; i++)\n            tmp[i]=jiao[use[dep][i]];\n        if (has.count(tmp))\n        {\n            int cnt=has[tmp];\n            reduce(tmp);\n            dfs(dep+1,ans,res*cnt);\n            add(tmp);\n        }\n    }\n}\n\nlong long solve(int a,int b)\n{\n    for (int i=0; i<4; i++)\n    {\n        jiao[i]=color[a][i];\n        jiao[i+4]=color[b][i];\n    }\n    long long ans=0;\n    for (int i=0; i<4; i++)\n    {\n        dfs(0,ans);\n        rotate(jiao+4,jiao+5,jiao+8);\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++)\n    {\n        color[i].resize(4);\n        for (int j=0; j<4; j++)\n        {\n            scanf(\"%d\",&color[i][j]);\n        }\n        add(color[i]);\n    }\n    long long ans1=0;\n    for (int i=0; i<n; i++)\n    {\n      for (int j=i+1; j<n; j++)\n      {\n          reduce(color[i]);\n          reduce(color[j]);\n          ans1+=solve(i,j);\n          add(color[i]);\n          add(color[j]);\n      }\n      reduce(color[i]);\n    }\n    printf(\"%lld\\n\",ans1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nint h[maxn];\ninline ll cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tll ret = 1234567891234567ll;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tll num = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tnum = num*1000+col[(rot+i)%4];\n\t\t\tret = min(ret,num);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nint fac[5];\ninline ll C(int n,int m) {\n\tif(n < m)\treturn 0;\n\tll ret = 1;\n\tfor(int i=n-m+1;i<=n;i++)\n\t\tret *= i;\n\tfor(int i=1;i<=m;i++)\n\t\tret /= i;\n\treturn ret;\n}\nmap<ll,pii> cnt;\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tint now_cnt = 0;\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tll num = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tnum = num*1000+col[i][(rot+j)%4];\n\t\t\t\tif(num == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tnow_cnt = max(now_cnt,tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t\tcnt[h[i]].first++;\n\t\tcnt[h[i]].second = now_cnt;\n\t}\n\t\n\tfac[0] = 1;\n\tfor(int i=1;i<5;i++)\n\t\tfac[i] = fac[i-1] * i;\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tcnt[h[i]].first--;\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tcnt[h[j]].first--;\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tmap<ll,int> need;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k])]++;\n\t\t\t\tll now = 1;\n\t\t\t\tfor(pii x : need)\n\t\t\t\t\tnow *= C(cnt[x.first].first,x.second) * pow(cnt[x.first].second,x.second) * fac[x.second];\n\t\t\t\tans += now;\n\t\t\t}\n\t\t\tcnt[h[j]].first++;\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n//\t\tcnt[h[i]].first++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 400\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nmap<LL,LL> mp;\nint col[MAXN+5][4];\nLL Translate(int seq[4])\n{\n\tLL x=0;\n\tfor(int i=3;i>=0;i--)\n\t\tx=1000LL*x+1LL*seq[i];\n\treturn x;\n}\nvoid Add(int seq[4],int val)//以块为单位进行计算 \n{\n\tLL num=Translate(seq);\n\tfor(int tmn=0;tmn<4;tmn++)\n\t{\n\t\tnum/=1000LL;\n\t\tnum+=seq[tmn]*1000000000LL;\n\t\tmp[num]+=val;\n\t}\n}\nLL Query(LL x)\n{\n\tif(mp.find(x)==mp.end())\n\t\treturn 0LL;\n\treturn mp[x];\n}\nvoid GetSeq(int a0,int a1,int a2,int a3,int seq[4])\n{\n\tseq[0]=a0;seq[1]=a1;seq[2]=a2;seq[3]=a3;\n}\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tAdd(col[i],1);\n\t}\n\tint val[4][4];\n\tLL ans=0,tot=0;\n\tLL ansn[4];\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int tmn=1;tmn<=4;tmn++)\n\t\t{\n\t\t\tAdd(col[i],-1LL);\n\t\t\tfor(int j=i+1;j<=N;j++)\n\t\t\t{\n\t\t\t\tAdd(col[j],-1LL);\n\t\t\t\ttot=1LL;\n\t\t\t\tGetSeq(col[j][1],col[j][0],col[i][1],col[i][0],val[0]);\n\t\t\t\tGetSeq(col[j][2],col[j][1],col[i][0],col[i][3],val[1]);\n\t\t\t\tGetSeq(col[j][0],col[j][3],col[i][2],col[i][1],val[2]);\n\t\t\t\tGetSeq(col[j][3],col[j][2],col[i][3],col[i][2],val[3]);\n\t\t\t\t//==================\n\t\t\t\tansn[0]=Query(Translate(val[0]));\n\t\t\t\tansn[1]=Query(Translate(val[1]));\n\t\t\t\tansn[2]=Query(Translate(val[2]));\n\t\t\t\tansn[3]=Query(Translate(val[3]));\n\t\t\t\tif(ansn[0]&&ansn[1]&&ansn[2]&&ansn[3])\n\t\t\t\t{\n\t\t\t\t\ttot*=Query(Translate(val[0]));\n\t\t\t\t\tAdd(val[0],-1LL);\n\t\t\t\t\ttot*=Query(Translate(val[1]));\n\t\t\t\t\tAdd(val[1],-1LL);\n\t\t\t\t\ttot*=Query(Translate(val[2]));\n\t\t\t\t\tAdd(val[2],-1LL);\n\t\t\t\t\ttot*=Query(Translate(val[3]));\n\t\t\t\t\tAdd(val[0],1LL);\n\t\t\t\t\tAdd(val[1],1LL);\n\t\t\t\t\tAdd(val[2],1LL);\n\t\t\t\t\tans+=tot;\n\t\t\t\t}\n\t\t\t\t//==================\n\t\t\t\tAdd(col[j],1LL);\n\t\t\t}\n\t\t\tAdd(col[i],1LL);\n\t\t\tint first=col[i][0];\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\tcol[i][k]=col[i][k+1];\n\t\t\tcol[i][3]=first;\n\t\t} \n\t}\n\tprintf(\"%lld\\n\",ans/3LL);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan in Ubuntu 18.10 on 2018/10/21 using VIM\n//版权所有，翻印必究\n\ntypedef pair<pii,pii> pp;\nint n;\nint C[405][5];\nmap<pp,int> m;\n\npp mp(int a,int b,int c,int d){\n\treturn mp(mp(a,b),mp(c,d));\n}\n\nvoid ins(int a,int b,int c,int d){\n\tm[mp(a,b,c,d)]++;\n\tm[mp(b,c,d,a)]++;\n\tm[mp(c,d,a,b)]++;\n\tm[mp(d,a,b,c)]++;\n}\n\nint same(pp p,pp q){\n\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\tint ans=0;\n\tif(q==mp(a,b,c,d)){\n\t\tans++;\n\t}\n\tif(q==mp(b,c,d,a)){\n\t\tans++;\n\t}\n\tif(q==mp(c,d,a,b)){\n\t\tans++;\n\t}\n\tif(q==mp(d,a,b,c)){\n\t\tans++;\n\t}\n\treturn ans;\n}\n\nvector<pp> v;\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>C[i][0]>>C[i][1]>>C[i][2]>>C[i][3];\n\t}\n\tINT ans=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=0;j<SZ(v);j++){\n\t\t\tpp p=v[j];\n\t\t\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\t\t\tpp m1=mp(b,a,C[i][0],C[i][1]);\n\t\t\tpp m2=mp(c,b,C[i][1],C[i][2]);\n\t\t\tpp m3=mp(d,c,C[i][2],C[i][3]);\n\t\t\tpp m4=mp(a,d,C[i][3],C[i][0]);\n\t\t\tINT res=1;\n\t\t\tres*=m[m1]-same(p,m1);\n\t\t\tint fAck=same(m1,m2);\n\t\t\tres*=m[m2]-same(p,m2)-fAck;\n\t\t\tint fBck=same(m1,m3)+same(m2,m3);\n\t\t\tres*=m[m3]-same(p,m3)-fBck;\n\t\t\tint fCck=same(m1,m4)+same(m2,m4)+same(m3,m4);\n\t\t\tres*=m[m4]-same(p,m4)-fCck;\n\t\t\tans+=res;\n\t\t}\n\t\tint a=C[i][3],b=C[i][2],c=C[i][1],d=C[i][0];\n\t\tins(a,b,c,d);\n\t\tv.pb(mp(a,b,c,d));\n\t\tv.pb(mp(b,c,d,a));\n\t\tv.pb(mp(c,d,a,b));\n\t\tv.pb(mp(d,a,b,c));\n\t}\n\tfio<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 11116\n\nint n,c[N][4],e[4][4];\nlong long ans;\nmap<long long,int> h;\n\nint query(int c[]){\n\treturn h[((c[0]*1000ll+c[1])*1000+c[2])*1000+c[3]];\n}\n\nvoid modify(int c[],int t){\n\th[((c[0]*1000ll+c[1])*1000+c[2])*1000+c[3]]+=t;\n\th[((c[1]*1000ll+c[2])*1000+c[3])*1000+c[0]]+=t;\n\th[((c[2]*1000ll+c[3])*1000+c[0])*1000+c[1]]+=t;\n\th[((c[3]*1000ll+c[0])*1000+c[1])*1000+c[2]]+=t;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\tc[i][0]=c[n+i][1]=c[2*n+i][2]=c[3*n+i][3]=read();\n\t\tc[i][1]=c[n+i][2]=c[2*n+i][3]=c[3*n+i][0]=read();\n\t\tc[i][2]=c[n+i][3]=c[2*n+i][0]=c[3*n+i][1]=read();\n\t\tc[i][3]=c[n+i][0]=c[2*n+i][1]=c[3*n+i][2]=read();\n\t\tmodify(c[i],1);\n\t}\n\tfor (int i=1;i<=4*n;i++)\n\t\tfor (int j=i+1;j<=4*n;j++)\n\t\t\tif (i%n!=j%n){\n\t\t\t\tmodify(c[i],-1);modify(c[j],-1);\n\t\t\t\te[0][0]=c[i][1];e[0][1]=c[i][0];e[0][2]=c[j][1];e[0][3]=c[j][0];\n\t\t\t\te[1][0]=c[i][2];e[1][1]=c[i][1];e[1][2]=c[j][0];e[1][3]=c[j][3];\n\t\t\t\te[2][0]=c[i][3];e[2][1]=c[i][2];e[2][2]=c[j][3];e[2][3]=c[j][2];\n\t\t\t\te[3][0]=c[i][0];e[3][1]=c[i][3];e[3][2]=c[j][2];e[3][3]=c[j][1];\n\t\t\t\tlong long tmp=query(e[0]);modify(e[0],-1);\n\t\t\t\ttmp*=query(e[1]);modify(e[1],-1);\n\t\t\t\ttmp*=query(e[2]);modify(e[2],-1);\n\t\t\t\tans+=tmp*query(e[3]);\n\t\t\t\tmodify(e[0],1);modify(e[1],1);modify(e[2],1);\n\t\t\t\tmodify(c[i],1);modify(c[j],1);\n\t\t\t}\n\tprintf(\"%lld\\n\",ans/12);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin>>n)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)cin>>x[i][j];\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[ii][(j+1)%4],x[ii][(j+0)%4],x[i][1],x[i][0]);\n                    y[1] = pack(x[ii][(j+0)%4],x[ii][(j+3)%4],x[i][2],x[i][1]);\n                    y[2] = pack(x[ii][(j+3)%4],x[ii][(j+2)%4],x[i][3],x[i][2]);\n                    y[3] = pack(x[ii][(j+2)%4],x[ii][(j+1)%4],x[i][0],x[i][3]);\n\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m.count(y[p])?m[y[p]]:0;\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            if(m.count(a[i]))m[a[i]]++;\n            else m[a[i]] = 1;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 400\nusing namespace std;\ntypedef long long LL;\nstruct tile\n{\n\tvector<int> values;\n\ttile(){}\n\ttile(int b[])\n\t{\n\t\tvector<int> rots[4];\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tfor(int offset = 0; offset < 4; offset++)\n\t\t\t\trots[i].push_back(b[(i+offset)%4]);\n\t\tvalues = *min_element(rots,rots+4);\n\t}\n\tbool operator <(const tile& other)const{ return this->values < other.values; }\n\tbool operator <=(const tile& other)const{ return this->values <=other.values; }\n\tbool operator ==(const tile& other)const{ return this->values ==other.values; }\n\tvoid print()const\n\t{\n\t\tfor(const int i : values)\n\t\t\tcout<<i<<\" \";\n\t\tcout<<endl;\n\t}\n\tint orbit()const\n\t{\n\t\tif(values[0]==values[1]&&values[1]==values[2]&&values[2]==values[3]) return 4;\n\t\tif(values[0]==values[2]&&values[1]==values[3]) return 2;\n\t\telse return 1;\n\t}\n};\n\nmap<tile,LL> freq;\nvector<tile> tiles;\n\nLL P(LL n, LL k)\n{\n\tif(k <= 0 || k > n) return 0;\n\tLL ans = 1;\n\tfor(LL j = 0; j < k; j++)\n\t\tans *= (n-j);\n\treturn ans;\n}\ntile make(int a, int b, int c, int d)\n{\n\tint arr[4] = {a,b,c,d};\n\treturn tile(arr);\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint n; cin >> n;\n\tLL total = 0;\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tint arr[4]; \n\t\tfor(int i = 0; i < 4; i++) cin >> arr[i];\n\t\t\n\t\ttile a(arr);\n\t\tfor(const auto& b : tiles)\n\t\t{\n\t\t\t//a.print();\n\t\t\t//b.print();\n\t\t\tfreq[b]--;\n\t\t\tfor(int offset = 0; offset < 4; offset++)\n\t\t\t{\n\t\t\t\tmap<tile,LL> needed;\n\t\t\t\tneeded[make( a.values[1], a.values[0], b.values[(1+offset)%4], b.values[(0+offset)%4] )]++;\n\t\t\t\tneeded[make( a.values[2], a.values[1], b.values[(0+offset)%4], b.values[(3+offset)%4] )]++;\n\t\t\t\tneeded[make( a.values[3], a.values[2], b.values[(3+offset)%4], b.values[(2+offset)%4] )]++;\n\t\t\t\tneeded[make( a.values[0], a.values[3], b.values[(2+offset)%4], b.values[(1+offset)%4] )]++;\n\n\t\t\t\tLL sub_ans = 1;\n\t\t\t\tfor(const auto& pattern : needed)\n\t\t\t\t{\n\t\t\t\t\tsub_ans *= P(freq[pattern.first],pattern.second);\n\t\t\t\t\tfor(int i = 0; i < pattern.second; i++)\n\t\t\t\t\t\tsub_ans *= pattern.first.orbit();\n\t\t\t\t}\n\t\t\t\ttotal += sub_ans;\n\t\t\t}\n\t\t\tfreq[b]++;\n\t\t}\n\t\tfreq[a]++;\t\t\n\t\ttiles.push_back(a);\n\t}\n\tcout<<total<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<vector<lli> > c;\nunordered_map<lli,lli> m;\nlli ans = 0;\nlli to_lli(vector<lli>& v){\n    lli ret = 0;\n    for(lli i = 0;i < v.size();i++){\n        ret *= 1000;\n        ret += v[i];\n    }\n    return ret;\n}\nvoid rotate(vector<lli>& v){\n    for(lli i = 0;i < 3;i++) swap(v[i],v[i+1]);\n    //for(lli k = 0;k < v.size();k++) cout << v[k] << \" \";cout << endl;\n}\nvoid rotate(lli& x){\n    x = x / 1000 + (x % 1000) * 1000000000;\n}\nvoid recover(vector<lli>& v){\n    lli x = to_lli(v);\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]++;\n    }\n}\nvoid dec(vector<lli>& v){\n    lli x = to_lli(v);\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]--;\n    }\n}\nvoid dec(lli& x){\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]--;\n    }\n}\nvoid inc(vector<lli>& v){\n    lli x = to_lli(v);\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]++;\n    }\n}\nlli select(vector<lli>& v){\n    lli x = to_lli(v);\n    lli ret = m[x];\n    dec(x);\n    return ret > 0 ? ret : 0;\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin >> n;\n    c = vector<vector<lli> > (n,vector<lli> (4));\n    for(lli i = 0;i < n;i++){\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        lli x = to_lli(c[i]);\n        for(lli j = 0;j < 4;j++){\n            rotate(x);\n            m[x]++;\n        }\n    }\n    for(lli i = 0;i < n;i++){\n        dec(c[i]);\n        for(lli j = i + 1;j < n;j++){\n            dec(c[j]);\n            for(lli k = 0;k < 4;k++){\n                rotate(c[j]);\n                lli adder = 1;\n                vector<lli> v1{c[i][1],c[i][0],c[j][1],c[j][0]};\n                vector<lli> v2{c[i][0],c[i][3],c[j][2],c[j][1]};\n                vector<lli> v3{c[i][3],c[i][2],c[j][3],c[j][2]};\n                vector<lli> v4{c[i][2],c[i][1],c[j][0],c[j][3]};\n                adder *= select(v1);\n                adder *= select(v2);\n                adder *= select(v3);\n                adder *= select(v4);\n                ans += adder;\n                recover(v1);\n                recover(v2);\n                recover(v3);\n                recover(v4);\n            }\n            inc(c[j]);\n        }\n        inc(c[i]);\n    }\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define LL long long\nusing namespace std;\nconst int N = 2000;\nint n;\nmap <vector <int>, int> res;\nint C[N][5];\nLL ans;\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        for (int j = 0; j < 4; ++ j)\n            cin >> C[i][j];\n    for (int i = 3; i <= n; ++ i)\n    {\n        for (int j = i + 1; j <= n; ++ j)\n            for (int k = i + 1; k <= n; ++ k) if (j != k)\n            {\n                for (int di = 0; di < 4; ++ di)\n                    for (int dj = 0; dj < 4; ++ dj)\n                        for (int dk = 0; dk < 4; ++ dk)\n                        {\n                            if (C[i][(di + 2) & 3] != C[j][(dj + 3) & 3]) continue;\n                            if (C[i][(di + 1) & 3] != C[j][(dj + 0) & 3]) continue;\n                            if (C[i][(di + 2) & 3] != C[k][(dk + 1) & 3]) continue;\n                            if (C[i][(di + 3) & 3] != C[k][(dk + 0) & 3]) continue;\n                            if (C[j][(dj + 2) & 3] != C[k][(dk + 2) & 3]) continue;\n\n                            vector <int> tmp;\n                            tmp.pb(C[k][(dk + 0) & 3]);\n                            tmp.pb(C[k][(dk + 3) & 3]);\n                            tmp.pb(C[j][(dj + 2) & 3]);\n                            tmp.pb(C[j][(dj + 1) & 3]);\n                            tmp.pb(C[i][(di + 1) & 3]);\n                            tmp.pb(C[i][(di + 0) & 3]);\n                            ans += res[tmp];\n\n                            tmp.clear();\n                            tmp.pb(C[j][(dj + 2) & 3]);\n                            tmp.pb(C[j][(dj + 1) & 3]);\n                            tmp.pb(C[i][(di + 1) & 3]);\n                            tmp.pb(C[i][(di + 0) & 3]);\n                            tmp.pb(C[k][(dk + 0) & 3]);\n                            tmp.pb(C[k][(dk + 3) & 3]);\n                            ans += res[tmp];\n\n                            tmp.clear();\n                            tmp.pb(C[i][(di + 1) & 3]);\n                            tmp.pb(C[i][(di + 0) & 3]);\n                            tmp.pb(C[k][(dk + 0) & 3]);\n                            tmp.pb(C[k][(dk + 3) & 3]);\n                            tmp.pb(C[j][(dj + 2) & 3]);\n                            tmp.pb(C[j][(dj + 1) & 3]);\n                            ans += res[tmp];\n                        }\n            }\n\n        for (int j = 1; j < i; ++ j)\n            for (int k = 1; k < i; ++ k) if (j != k)\n            {\n                for (int di = 0; di < 4; ++ di)\n                    for (int dj = 0; dj < 4; ++ dj)\n                        for (int dk = 0; dk < 4; ++ dk)\n                        {\n                            if (C[i][(di + 2) & 3] != C[j][(dj + 3) & 3]) continue;\n                            if (C[i][(di + 1) & 3] != C[j][(dj + 0) & 3]) continue;\n                            if (C[i][(di + 2) & 3] != C[k][(dk + 1) & 3]) continue;\n                            if (C[i][(di + 3) & 3] != C[k][(dk + 0) & 3]) continue;\n                            if (C[j][(dj + 2) & 3] != C[k][(dk + 2) & 3]) continue;\n\n                            vector <int> tmp;\n                            tmp.pb(C[i][(di + 0) & 3]);\n                            tmp.pb(C[i][(di + 1) & 3]);\n                            tmp.pb(C[j][(dj + 1) & 3]);\n                            tmp.pb(C[j][(dj + 2) & 3]);\n                            tmp.pb(C[k][(dk + 3) & 3]);\n                            tmp.pb(C[k][(dk + 0) & 3]);\n                            res[tmp] ++;\n                        }\n            }\n    }\n\n    res.clear();\n    \n    for (int ii = 3; ii <= n; ++ ii)\n    {\n        for (int jj = ii + 1; jj <= n; ++ jj)\n            for (int kk = jj + 1; kk <= n; ++ kk)\n            {\n                for (int d = 0; d < 6; ++ d)\n                {\n                    int i, j, k;\n                    if (d == 0) i = ii, j = jj, k = kk;\n                    if (d == 1) i = ii, j = kk, k = jj;\n                    if (d == 2) i = jj, j = ii, k = kk;\n                    if (d == 3) i = jj, j = kk, k = ii;\n                    if (d == 4) i = kk, j = ii, k = jj;\n                    if (d == 5) i = kk, j = jj, k = ii;\n                    for (int di = 0; di < 4; ++ di)\n                        for (int dj = 0; dj < 2; ++ dj)\n                            for (int dk = 0; dk < 4; ++ dk)\n                            {\n                                if (C[j][(dj + 0) & 3] != C[i][(di + 3) & 3]) continue;\n                                if (C[j][(dj + 1) & 3] != C[i][(di + 2) & 3]) continue;\n                                if (C[k][(dk + 0) & 3] != C[j][(dj + 3) & 3]) continue;\n                                if (C[k][(dk + 1) & 3] != C[j][(dj + 2) & 3]) continue;\n\n                                vector <int> tmp;\n                                tmp.pb(C[j][(dj + 0) & 3]);\n                                tmp.pb(C[j][(dj + 3) & 3]);\n                                tmp.pb(C[k][(dk + 3) & 3]);\n                                tmp.pb(C[k][(dk + 2) & 3]);\n                                tmp.pb(C[j][(dj + 2) & 3]);\n                                tmp.pb(C[j][(dj + 1) & 3]);\n                                tmp.pb(C[i][(di + 1) & 3]);\n                                tmp.pb(C[i][(di + 0) & 3]);\n                                ans += res[tmp];\n\n                                tmp.clear();\n                                tmp.pb(C[j][(dj + 2) & 3]);\n                                tmp.pb(C[j][(dj + 1) & 3]);\n                                tmp.pb(C[i][(di + 1) & 3]);\n                                tmp.pb(C[i][(di + 0) & 3]);\n                                tmp.pb(C[j][(dj + 0) & 3]);\n                                tmp.pb(C[j][(dj + 3) & 3]);\n                                tmp.pb(C[k][(dk + 3) & 3]);\n                                tmp.pb(C[k][(dk + 2) & 3]);\n                                ans += res[tmp];\n                            }\n                }\n            }\n        for (int jj = 2; jj < ii; ++ jj)\n            for (int kk = 1; kk < jj; ++ kk)\n            {\n                for (int d = 0; d < 6; ++ d)\n                {\n                    int i, j, k;\n                    if (d == 0) i = ii, j = jj, k = kk;\n                    if (d == 1) i = ii, j = kk, k = jj;\n                    if (d == 2) i = jj, j = ii, k = kk;\n                    if (d == 3) i = jj, j = kk, k = ii;\n                    if (d == 4) i = kk, j = ii, k = jj;\n                    if (d == 5) i = kk, j = jj, k = ii;\n                    for (int di = 0; di < 4; ++ di)\n                        for (int dj = 0; dj < 2; ++ dj)\n                            for (int dk = 0; dk < 4; ++ dk)\n                            {\n                                if (C[j][(dj + 0) & 3] != C[i][(di + 3) & 3]) continue;\n                                if (C[j][(dj + 1) & 3] != C[i][(di + 2) & 3]) continue;\n                                if (C[k][(dk + 0) & 3] != C[j][(dj + 3) & 3]) continue;\n                                if (C[k][(dk + 1) & 3] != C[j][(dj + 2) & 3]) continue;\n\n                                vector <int> tmp;\n                                tmp.pb(C[i][(di + 0) & 3]);\n                                tmp.pb(C[i][(di + 1) & 3]);\n                                tmp.pb(C[j][(dj + 1) & 3]);\n                                tmp.pb(C[j][(dj + 2) & 3]);\n                                tmp.pb(C[k][(dk + 2) & 3]);\n                                tmp.pb(C[k][(dk + 3) & 3]);\n                                tmp.pb(C[j][(dj + 3) & 3]);\n                                tmp.pb(C[j][(dj + 0) & 3]);\n                                res[tmp] ++;\n                            }\n                }\n            }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n\nint N;\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n\n    auto normalize=[&](vector<vector<int>> &a){\n        rep(i,0,4){\n            auto amin=a[i];\n            rep(j,0,4){\n                amin=min(amin,a[i]);\n                a[i]=shift(a[i]);\n            }\n        }\n        sort(a.begin(),a.begin());\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            vector<i64> sum(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_) or Csum[indexes[k]]!=sum[i_]) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto next_sides=make_sides(i,j);\n                normalize(next_sides);\n                if(next_sides!=sides){\n                    for(auto& u:update) memo[u.first][u.second]=-1;\n                    update.clear();\n                    indexes.clear();\n                    sides=next_sides;\n                    rep(i_,0,4){\n                        sum[i_]=0;\n                        rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                    }\n                }\n\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n\n                C[j]=shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nlong get(long a,int k){return k==1?a%1000:k==2?a/1000%1000:k==3?a/1000000%1000:a/1000000000;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nlong C[400];\nmap<long,array<array<array<long,5>,5>,4> >M;\nmap<long,map<int,int> >Q;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tC[i]=conv(a,b,c,d);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C[i]]++;\n\t\t\tC[i]=rotate(C[i]);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<array<long,5>,5>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<5;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tif(j<k)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<5;i++)A[i][j][k]=A[i][k][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA[0][j][k]=sum-j-k;\n\t\t\t\tA[1][j][k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\t\tA[2][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\t\tA[3][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\t}\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong a=C[i];\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tlong b=C[j];\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tb=rotate(b);\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(get(a,3),get(a,4),get(b,3),get(b,4)),\n\t\t\t\t\tconv(get(a,4),get(a,1),get(b,2),get(b,3)),\n\t\t\t\t\tconv(get(a,1),get(a,2),get(b,1),get(b,2)),\n\t\t\t\t\tconv(get(a,2),get(a,3),get(b,4),get(b,1)),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][Q[t[k]][i]][Q[t[k]][j]];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<pair<int,int>, pair<int,int> > pt;\n\nconst int MOD = 1e9 + 7;\nconst int C = 1001;\n\nmap<ll,int> ma;\n\nll hsh(int a, int b, int c, int d)\n{\n\tll x = ll(a)*ll(C)*ll(C)*ll(C);\n\tx += ll(b)*ll(C)*ll(C);\n\tx += ll(c)*ll(C);\n\tx += d;\n\treturn x;\n}\n\nvoid cyc(int &a, int &b, int &c, int &d)\n{\n\tswap(a, b);\n\tswap(a, c);\n\tswap(a, d);\n}\n\nvector<pt> vec;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tvec.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> vec[i].fi.fi >> vec[i].fi.se >> vec[i].se.fi >> vec[i].se.se;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a = vec[i].fi.fi; int b = vec[i].fi.se;\n\t\tint c = vec[i].se.fi; int d = vec[i].se.se;\n\t\tma[hsh(a,b,c,d)]++;\n\t\tma[hsh(b,c,d,a)]++;\n\t\tma[hsh(c,d,a,b)]++;\n\t\tma[hsh(d,a,b,c)]++;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i == j) continue;\n\t\t\tint xa, xb, xc, xd, ya, yb, yc, yd;\n\t\t\txa = vec[i].fi.fi; xb = vec[i].fi.se; xc = vec[i].se.fi; xd = vec[i].se.se;\n\t\t\tya = vec[j].fi.fi; yb = vec[j].fi.se; yc = vec[j].se.fi; yd = vec[j].se.se;\n\t\t\tswap(xb,xd);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint a,b,c,d; map<ll,int> ma2;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\tll h1 = hsh(ya,yd,xd,xa);\n\t\t\t\tll h2 = hsh(yd,yc,xc,xd);\n\t\t\t\tll h3 = hsh(yc,yb,xb,xc);\n\t\t\t\tll h4 = hsh(yb,ya,xa,xb);\n\t\t\t\t//set<ll> ss;\n\t\t\t\t//ss.insert(h1); ss.insert(h2); ss.insert(h3); ss.insert(h4);\n\t\t\t\tmap<ll,int> ss;\n\t\t\t\t////cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\tll tmp = 0;\n\t\t\t\t\n\t\t\t\t\t////cerr<<w<<' '<<x<<' '<<y<<' '<<z<<'\\n';\n\t\t\t\t\tll x1 = ma[h1];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tll x2 = ma[h2];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tll x3 = ma[h3];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[y][h3]--; ma[y][h2]--; ma[y][h1]--; ma[y][h4]--;\n\t\t\t\t\tll x4 = ma[h4];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[w][h1]++; ma[x][h2]++; ma[y][h3]++;\n\t\t\t\t\t//ma[w][h1]++; ma[w][h2]++; ma[w][h3]++; ma[w][h4]++;\n\t\t\t\t\t//ma[x][h2]++; ma[x][h1]++; ma[x][h3]++; ma[x][h4]++;\n\t\t\t\t\t//ma[y][h3]++; ma[y][h2]++; ma[y][h1]++; ma[y][h4]++;\n\t\t\t\t\tx1=max(x1,0LL); x2=max(x2,0LL); x3=max(x3,0LL); x4 = max(x4,0LL);\n\t\t\t\t\ttmp += (x1*x2*x3*x4);\n\n\t\t\t\t/*\n\t\t\t\ttmp*=ma[h1];\n\t\t\t\tma[h1]--;\n\t\t\t\ttmp*=ma[h2];\n\t\t\t\tma[h2]--;\n\t\t\t\ttmp*=ma[h3];\n\t\t\t\tma[h3]--;\n\t\t\t\ttmp*=ma[h4];\n\t\t\t\tma[h1]++; ma[h2]++; ma[h3]++;\n\t\t\t\t*/\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<xa<<' '<<xb<<' '<<xc<<' '<<xd<<' '<<ya<<' '<<yb<<' '<<yc<<' '<<yd<<' '<<tmp<<'\\n';\n\t\t\t\tans += tmp;\n\t\t\t\tma2.clear();\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\tcyc(ya,yb,yc,yd);\n\t\t\t}\n\t\t}\n\t}\n\t//assert(ans%6==0);\n\tans/=6;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) ((((LL)(x))<<30)+((y)<<20)+((z)<<10)+(t))\nunordered_map<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[key[1].key[1]];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[key[2].key[1]];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[key[3].key[1]];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[key[4].key[1]];key[4].dec();\n\t\tret+=ans;\n\t\tfor(int j=1;j<=4;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...)\\\n  std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::istream& operator>> (std::istream& is, Container& v) {\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T, typename U>\nstd::ostream& operator<< (std::ostream& os, const std::pair<T, U>& pair)\n  { return os << \"(\" << pair.first << \",\" << pair.second << \")\"; }\n\ntemplate <typename T, typename U>\nstd::istream& operator>> (std::iostream& is, std::pair<T, U>& pair)\n  { return is >> pair.first >> pair.second; }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto data = make_vector< 2, int >(n, 4);\n  std::cin >> data;\n  auto multiplicity = [&] (auto a) {\n    if (a.at(0) != a.at(2) || a.at(1) != a.at(3))\n      { return 1; }\n    if (a.at(0) != a.at(1))\n      { return 2;}\n    return 4;\n  };\n  auto power = [&] (auto x, auto y) {\n    auto ret = 1LL;\n    loop(y) ret *= x;\n    return ret;\n  };\n  auto normalized = [&] (auto a) {\n    auto z = a;\n    loop(3) {\n      std::rotate(a.begin(), a.begin() + 1, a.end());\n      cmn(z, a);\n    }\n    return z;\n  };\n  for (auto & v : data) v = normalized(v);\n  std::multiset< std::vector< int > > set(data.begin(), data.end());\n  auto cal = [&] (auto n, auto k) {\n    if (n < k) return 0LL;\n    auto ret = 1LL;\n    rep(i, 0, k) ret *= (n - i);\n    return ret;\n  };\n  lint ret = 0;\n  rep(i, 0, n) rep(j, i + 1, n) {\n    auto x = data.at(i);\n    auto y = data.at(j);\n    auto seq = std::vector< int >{1, 0, 1, 0};\n    loop(4) {\n      std::map< std::vector< int >, int > map;\n      loop(4) {\n        auto z = std::vector< int >{\n          x.at(seq.at(0)), x.at(seq.at(1)),\n          y.at(seq.at(2)), y.at(seq.at(3))\n        };\n        map[normalized(z)]++;\n        for (auto & x : std::vector< std::reference_wrapper<int> >{ seq.at(0), seq.at(1) })\n          { (x += 1) %= 4; }\n        for (auto & x : std::vector< std::reference_wrapper<int> >{ seq.at(2), seq.at(3) })\n          { (x += 3) %= 4; }\n      }\n      auto now = 1;\n      for (auto p : map) {\n        std::vector< int > v; int l; std::tie(v, l) = p;\n        auto m = set.count(v) - (x == v) - (y == v);\n        now *= cal(m, l) * power(multiplicity(v), l);\n      }\n      ret += now;\n      for (auto & x : std::vector< std::reference_wrapper<int> >{ seq.at(2), seq.at(3) })\n        { (x += 3) %= 4; }\n    }\n  }\n  assert(ret % 3 == 0);\n  ret /= 3;\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\n    #include <bitset> \n    #include <unordered_set>\nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef unsigned long long int128;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii > piii;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define eps 1e-10\n#define pi acos(-1)\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\n#define lson(x) ((x)<<1)\n#define rson(x) ((x)<<1^1)\nconst int maxn=405;\nint C[maxn][4];\nstruct tile\n{\n\tint a,b,c,d;\n\ttile(){}\n\ttile(int _a,int _b,int _c,int _d):a(_a),b(_b),c(_c),d(_d){} \n\tbool operator < (const tile &t)const\n\t{\n\t\treturn (a!=t.a?a<t.a:b!=t.b?b<t.b:c!=t.c?c<t.c:d<t.d);\n\t}\n\tbool operator == (const tile &t)\n\t{\n\t\treturn a==t.a&&b==t.b&&c==t.c&&d==t.d;\n\t}\n};\nmap<tile,int> m;\nvoid ins(int a,int b,int c,int d)\n{\n\tm[tile(a,b,c,d)]++;\n\tm[tile(b,c,d,a)]++;\n\tm[tile(c,d,a,b)]++;\n\tm[tile(d,a,b,c)]++;\n}\nvector<tile> vx;\nint same(tile a,tile b)\n{\n\tint ans=0;\n\tint aa=b.a,bb=b.b,cc=b.c,dd=b.d;\n\tif(a==tile(aa,bb,cc,dd))ans++;\n\tif(a==tile(bb,cc,dd,aa))ans++;\n\tif(a==tile(cc,dd,aa,bb))ans++;\n\tif(a==tile(dd,aa,bb,cc))ans++;\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,n)rep(j,4)cin>>C[i][j];\n\tll ans=0;\n\tford(i,n,0)\n\t{\n\t\trep(j,vx.size())\n\t\t{\n\t\t\ttile cur=vx[j];\n\t\t\tint a=cur.a,b=cur.b,c=cur.c,d=cur.d;\n\t\t//\tcout<<C[i][0]<<\" \"<<C[i][1]<<\" \"<<C[i][2]<<\" \"<<C[i][3]<<endl;\n\t\t//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\t//\tsystem(\"pause\"); \n\t\t\ttile x=tile(C[i][0],C[i][1],b,a);\n\t\t\ttile y=tile(C[i][1],C[i][2],c,b);\n\t\t\ttile z=tile(C[i][2],C[i][3],d,c);\n\t\t\ttile w=tile(C[i][3],C[i][0],a,d);\n\t\t//\tcout<<\"x: \"<<x.a<<\" \"<<x.b<<\" \"<<x.c<<\" \"<<x.d<<\" \"<<m[x]<<endl;\n\t\t//\tcout<<\"y: \"<<y.a<<\" \"<<y.b<<\" \"<<y.c<<\" \"<<y.d<<\" \"<<m[y]<<endl;\n\t\t//\tcout<<\"z: \"<<z.a<<\" \"<<z.b<<\" \"<<z.c<<\" \"<<z.d<<\" \"<<m[z]<<endl;\n\t\t//\tcout<<\"w: \"<<w.a<<\" \"<<w.b<<\" \"<<w.c<<\" \"<<w.d<<\" \"<<m[w]<<endl; \n\t\t\tll res=1;\n\t\t\tres*=1ll*m[x]-same(cur,x);\n\t\t//\tcout<<m[x]<<\" \"<<same(cur,x)<<endl;\n\t\t\tres*=1ll*m[y]-same(x,y)-same(cur,y);\n\t\t//\tcout<<m[y]<<\" \"<<same(x,y)<<\" \"<<same(cur,y)<<endl;\n\t\t\tres*=1ll*m[z]-same(x,z)-same(y,z)-same(cur,z);\n\t\t//\tcout<<m[z]<<\" \"<<same(x,z)<<\" \"<<same(y,z)<<\" \"<<same(cur,z)<<endl;\n\t\t\tres*=1ll*m[w]-same(x,w)-same(y,w)-same(z,w)-same(cur,w);\n\t\t//\tcout<<m[w]<<\" \"<<same(x,w)<<\" \"<<same(y,w)<<\" \"<<same(z,w)<<\" \"<<same(cur,w)<<endl;\n\t\t\tans+=res;\n\t\t//\tcout<<res<<\" \"<<ans<<endl;\n\t\t//\tsystem(\"pause\");\n\t\t}\n\t\tint a=C[i][0],b=C[i][3],c=C[i][2],d=C[i][1];\n\t\tins(a,b,c,d);\n\t\tvx.pb(tile(a,b,c,d));\n\t\tvx.pb(tile(b,c,d,a));\n\t\tvx.pb(tile(c,d,a,b));\n\t\tvx.pb(tile(d,a,b,c));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint nextInt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 400;\nint col[N][8];\nlong long hashes[N][4];\nlong long dp[16];\nint ways[4];\n\nlong long calcHash(int a, int b, int c, int d) {\n\tlong long h = 0;\n\th = 1000 * h + a;\n\th = 1000 * h + b;\n\th = 1000 * h + c;\n\th = 1000 * h + d;\n\treturn h;\n}\n\nint main() {\n\tint n = nextInt();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcol[i][j] = nextInt();\n\t\t\tcol[i][j + 4] = col[i][j];\n\t\t}\n\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\thashes[i][rot] = 1000 * hashes[i][rot] + col[i][(rot + j) % 4];\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int front = 0; front < n; front++) {\n\t\tint a = col[front][0];\n\t\tint b = col[front][1];\n\t\tint c = col[front][2];\n\t\tint d = col[front][3];\n\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\trotLoop:\n\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\tlong long h1 = calcHash(a, e, f, b);\n\t\t\t\tlong long h2 = calcHash(b, f, g, c);\n\t\t\t\tlong long h3 = calcHash(d, c, g, h);\n\t\t\t\tlong long h4 = calcHash(e, a, d, h);\n\t\t\t\tvector<long long> hs = {h1, h2, h3, h4};\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tdp[i] = 0;\n\t\t\t\t}\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tways[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\tif (hashes[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tint nmask = mask | (1 << bit);\n\t\t\t\t\t\t\t\tif (nmask != mask) {\n\t\t\t\t\t\t\t\t\tdp[nmask] += dp[mask] * ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tdp[15] += dp[14] * ways[0];\n\t\t\t\t\tdp[15] += dp[13] * ways[1];\n\t\t\t\t\tdp[15] += dp[11] * ways[2];\n\t\t\t\t\tdp[15] += dp[7] * ways[3];\n\t\t\t\t\tdp[14] += dp[12] * ways[1];\n\t\t\t\t\tdp[14] += dp[10] * ways[2];\n\t\t\t\t\tdp[14] += dp[6] * ways[3];\n\t\t\t\t\tdp[13] += dp[12] * ways[0];\n\t\t\t\t\tdp[13] += dp[9] * ways[2];\n\t\t\t\t\tdp[13] += dp[5] * ways[3];\n\t\t\t\t\tdp[12] += dp[8] * ways[2];\n\t\t\t\t\tdp[12] += dp[4] * ways[3];\n\t\t\t\t\tdp[11] += dp[10] * ways[0];\n\t\t\t\t\tdp[11] += dp[9] * ways[1];\n\t\t\t\t\tdp[11] += dp[3] * ways[3];\n\t\t\t\t\tdp[10] += dp[8] * ways[1];\n\t\t\t\t\tdp[10] += dp[2] * ways[3];\n\t\t\t\t\tdp[9] += dp[8] * ways[0];\n\t\t\t\t\tdp[9] += dp[1] * ways[3];\n\t\t\t\t\tdp[8] += dp[0] * ways[3];\n\t\t\t\t\tdp[7] += dp[6] * ways[0];\n\t\t\t\t\tdp[7] += dp[5] * ways[1];\n\t\t\t\t\tdp[7] += dp[3] * ways[2];\n\t\t\t\t\tdp[6] += dp[4] * ways[1];\n\t\t\t\t\tdp[6] += dp[2] * ways[2];\n\t\t\t\t\tdp[5] += dp[4] * ways[0];\n\t\t\t\t\tdp[5] += dp[1] * ways[2];\n\t\t\t\t\tdp[4] += dp[0] * ways[2];\n\t\t\t\t\tdp[3] += dp[2] * ways[0];\n\t\t\t\t\tdp[3] += dp[1] * ways[1];\n\t\t\t\t\tdp[2] += dp[0] * ways[1];\n\t\t\t\t\tdp[1] += dp[0] * ways[0];\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\n#define int long long\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n/*//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n        //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    *//*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*//*\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,int> cnt;\nunordered_map<LL,int> way;*/\n\nvector<int> rig(vector<int> v){\n    vector<vector<int>> r(4);\n    for (int i = 0; i < 4; ++i) {\n        r[i]=v;\n        rotate(r[i].begin(),r[i].begin()+i,r[i].end());\n    }\n    sort(all(r));\n    return r[0];\n}\n\nLL en(vector<int> v){\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\nint n;\nvector<int>C[400];\nsigned main(){\n    cin>>n;\n    map<LL,int>cnt;\n    map<LL,int>way;\n    for (int i = 0; i < n; ++i) {\n        C[i].resize(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>C[i][j];\n        }\n        C[i]=rig(C[i]);\n        cnt[en(C[i])]++;\n\n        vector<int> v=C[i];\n        set<vector<int>>s;\n        for (int k = 0; k <4 ; ++k) {\n            s.insert(v);\n            rotate(v.begin(),v.begin()+1,v.end());\n        }\n        way[en(C[i])]=4/s.size();\n    }\n\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        cnt[en(C[i])]--;\n        vector<int> X=C[i];\n        for (int j = i+1; j < n; ++j) {\n            vector<int> Y=C[j];\n            cnt[en(C[j])]--;\n            reverse(all(Y));\n\n            for (int ii = 0; ii < 4; ++ii) {\n                vector<LL> wanna(4);\n                for(int k=0;k<4;k++){\n                    vector<int> v(4);\n                    v[0]=X[(k+1)%4];\n                    v[1]=X[k];\n                    v[2]=Y[k];\n                    v[3]=Y[(k+1)%4];\n                    v=rig(v);\n                    wanna[k]=en(v);\n                }\n                sort(all(wanna));\n                vector<pair<int,int>> want;\n                for(int k=0;k<4;k++){\n                    if(want.size()==0||want.back().first!=wanna[k]){\n                        want.push_back(mp(wanna[k],1));\n                    }\n                    else{\n                        want[want.size()-1].second++;\n                    }\n                }\n\n                LL tmp=1;\n                for(int k=0;k<want.size();k++){\n                    int e=want[k].first;\n                    int f=want[k].second;\n                    if(cnt.find(e)==cnt.end()){\n                        tmp=0;\n                        continue;\n                    }\n                    LL hoge=cnt[e];\n                    LL piyo=way[e];\n                    for(int l=0;l<f;l++)\n                        tmp*=(hoge-l)*piyo;\n                }\n                ans+=tmp;\n                rotate(Y.begin(),Y.begin()+1,Y.end());\n            }\n            cnt[en(C[j])]++;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      //cout<<bitset<40>(v)<<\":\"<<x<<endl;\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  set<sq> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(b);\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(a)) continue;\n\n      auto calc=[](Int a,Int b,Int c,Int d){\n\treturn ((((((d<<10)|c)<<10)|b)<<10)|a);\n      };\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n\n  vector<sq> ord(24,sq(8));\n  {\n    sq a(8);\n    iota(a.begin(),a.end(),0);\n    Int x=0;\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tfor(Int k=0;k<8;k++) ord[x][a[k]]=k;\n\ta=clock(a);\n\tx++;\n      }\n      if(i==0||i==4) a=right(a);\n      else a=front(a);\n    }\n  }\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(8);\n    for(Int i=0;i<24;i++){\n      for(Int k=0;k<8;k++) b[ord[i][k]]=a[k];\n      res+=(a==b);\n      used.emplace(conv(b));\n    }\n    //cout<<res<<endl;\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nunordered_map<ll, int> dp;\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    double ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p1 = c[i];\n            for(int k=0;k<4;k++){\n                del(p1);\n                piipii p2 = c[j];\n                for(int l=0;l<4;l++){\n                    del(p2);\n\n                    double res = 1;\n                    piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                    piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                    piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                    piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                    // if(dp.count(tmp1)){\n                        res *= dp[get_idx(tmp1)];\n                        del(tmp1);\n                    // }\n                    // else res = 0;\n                    // if(dp.count(tmp2)){\n                        res *= dp[get_idx(tmp2)];\n                        del(tmp2);\n                    // }\n                    // else res = 0;\n                    // if(dp.count(tmp3)){\n                        res *= dp[get_idx(tmp3)];\n                        del(tmp3);\n                    // }\n                    // else res = 0;\n                    // if(dp.count(tmp4)){\n                        res *= dp[get_idx(tmp4)];\n                        del(tmp4);\n                    // }\n                    // else res = 0;\n\n                    ans += res;\n\n                    // if(dp.count(tmp1)){\n                        add(tmp1);\n                    // }\n                    // if(dp.count(tmp2)){\n                        add(tmp2);\n                    // }\n                    // if(dp.count(tmp3)){\n                        add(tmp3);\n                    // }\n                    // if(dp.count(tmp4)){\n                        add(tmp4);\n                    // }\n                    \n                    add(p2);\n                    p2 = rotate(p2);\n                }\n\n                add(p1);\n                p1 = rotate(p1);\n            }\n        }\n    }\n    printf(\"%.0lf\\n\", ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> rotate(const vector<int>& vec, int i) {\n  vector<int> ret = {vec[(0+i)%4], vec[(1+i)%4], vec[(2+i)%4], vec[(3+i)%4]};\n  return ret;\n}\n\nvector<int> getfirst(const vector<int>& v) {\n  vector<vector<int>> ret(4, vector<int>(4));\n  rep(p, 4) {\n    ret[p] = rotate(v, p);\n  }\n  sort(ret.begin(), ret.end());\n  return ret[0];\n}\n\nint getdup(const vector<int>& vec) {\n  if (vec[0] == vec[1] && vec[1] == vec[2] && vec[2] == vec[3]) {\n    return 4;\n  } else if (vec[0] == vec[2] && vec[1] == vec[3]) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<vector<int>> tiles(n, vector<int>(4));\n  vector<vector<int>> dice(4, vector<int>(4));\n  map<vector<int>, int> mp, mp2;\n  rep(i, n) {\n    int a, b, c, d; cin >> a >> b >> c >> d;\n    tiles[i] = {a, b, c, d};\n    tiles[i] = getfirst(tiles[i]);\n    mp[tiles[i]]++;\n  }\n\n  ll ans = 0;\n  rep(i, n-5) {\n    vector<int> ti = tiles[i];\n    mp[ti]--;\n    for(int j=i+1; j<n; j++) {\n      mp[tiles[j]]--;\n      rep(k, 4) {\n        vector<int> tj = rotate(tiles[j], k);\n        dice[0] = {ti[0], tj[1], tj[0], ti[1]};\n        dice[1] = {ti[1], tj[0], tj[3], ti[2]};\n        dice[2] = {ti[2], tj[3], tj[2], ti[3]};\n        dice[3] = {ti[3], tj[2], tj[1], ti[0]};\n        rep(l, 4) {\n          mp2[getfirst(dice[l])]++;\n        }\n        ll now = 1;\n        for(auto& e: mp2) {\n          auto cnt = mp[e.first];\n          auto num = e.second;\n          auto dup = getdup(e.first);\n          for(int p=1; p<=num; p++) {\n            now *= cnt*dup;\n            cnt--;\n          }\n        }\n        mp2.clear();\n        ans += now;\n      }\n      mp[tiles[j]]++;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n// 各色の長方形が何個ずつあるか\nmap<vector<int>, long long> ma;\nvoid use(vector<int> v) {\n    for (int it = 0; it < 4; ++it) {\n        vector<int> col(4);\n        for (int j = 0; j < 4; ++j) {\n            col[j] = v[(it+j)%4];\n        }\n        ma[col]--;\n    }\n}\nvoid add(vector<int> v) {\n    for (int it = 0; it < 4; ++it) {\n        vector<int> col(4);\n        for (int j = 0; j < 4; ++j) {\n            col[j] = v[(it+j)%4];\n        }\n        ma[col]++;\n    }\n}\n\nint main() {\n    int N; cin >> N;\n    vector<vector<int> > C(N, vector<int>(4));\n    for (int i = 0; i < N; ++i) for (int j = 0; j < 4; ++j) cin >> C[i][j];\n\n    // 追加\n    ma.clear();\n    for (int i = 0; i < N; ++i) add(C[i]);\n\n    // 集計\n    long long res = 0;\n    for (int i = 0; i < N; ++i) {\n        use(C[i]);\n        for (int j = 0; j < N; ++j) {\n            if (j == i) continue;\n            use(C[j]);\n            \n            for (int dir = 0; dir < 4; ++dir) {\n                auto ue = C[i];\n                vector<int> shita(4);\n                for (int k = 0; k < 4; ++k) shita[k] = C[j][(dir + k) % 4];\n                reverse(shita.begin(), shita.end());\n\n                long long tmp = 1;\n                vector<bool> isadd(4, 0);\n                for (int it = 0; it < 4; ++it) {\n                    vector<int> col = {ue[(it+1)%4], ue[it%4], shita[it%4], shita[(it+1)%4]};\n                    if (!ma.count(col)) tmp = 0;\n                    else tmp *= ma[col], use(col), isadd[it] = true;\n                }\n                for (int it = 0; it < 4; ++it) {\n                    vector<int> col = {ue[(it+1)%4], ue[it%4], shita[it%4], shita[(it+1)%4]};\n                    if (isadd[it]) add(col);\n                }\n                \n                res += tmp;\n            }\n            add(C[j]);\n        }\n        add(C[i]);\n    }\n    cout << res/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<climits>\n#include<cstring>\n#include<iostream>\n#include<algorithm>    \nusing namespace std;\n#define LL long long\nint read(){\n    int f=1,x=0;char s=getchar();   \n    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}  \n    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}\n    return x*f;\n}\n#define MAXN 400\n#define MAXC 999\n#define INF 0x3f3f3f3f\nstruct node{\n\tint c[4];\n}tile[MAXN+5];\nint vis[MAXN+5],n,pos[10],ans,dir[7][4]={{},{1,4,8,5},{2,6,7,3},{1,2,3,4},{3,7,8,4},{1,5,6,2},{5,8,7,6}};//前:后?\nint To[7][4]={{},{3,4,6,5},{3,4,6,5},{5,2,4,1},{3,1,6,2},{3,2,6,1},{5,2,4,1}};\nbool mian[10];\nvector<int> Col[MAXC+5][MAXC+5];\nvoid Rotate(int x){\n\tint tmp=tile[x].c[0];\n\tfor(int i=0;i<=2;i++)\n\t\ttile[x].c[i]=tile[x].c[i+1];\n\ttile[x].c[3]=tmp;\n\treturn ;\n}\nvoid DFS(int x,int p,int cnt){\n\tif(cnt==5){\n\t\tans++;\n\t\treturn ;\n\t}\n\tint xc[4];\n\tfor(int i=0;i<=3;i++)//角块赋值\n\t\txc[i]=pos[dir[p][i]],pos[dir[p][i]]=tile[x].c[i];\n\tfor(int i=0;i<=3;i++){//枚举下一个面\n\t\tint l=pos[dir[p][i]],r=pos[dir[p][(i+1)%4]];\n\t\tint T=To[p][i];\n\t\tif(mian[T]) continue;\n\t\tmian[T]=1;\n\t\tint siz=Col[l][r].size();\n\t\tfor(int t=0;t<siz;t++){//枚举放砖\n\t\t\tint tmp=Col[l][r][t];\n\t\t\tif(vis[tmp]!=-1) continue;\n\t\t\tfor(int c=0;c<=3;c++){//枚举切入位置\n\t\t\t\tint f=1;\n\t\t\t\tRotate(tmp);\n\t\t\t\tfor(int j=0;j<=3;j++)//判断是否能切入\n\t\t\t\t\tif(tile[tmp].c[j]!=pos[dir[T][j]]&&pos[dir[T][j]]!=-1){\n\t\t\t\t\t\tf=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif(f){//进入下一面\n\t\t\t\t\tvis[tmp]=1;\n\t\t\t\t\tDFS(tmp,T,cnt+1);\n\t\t\t\t\tvis[tmp]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmian[T]=0;\n\t}\n\tfor(int i=0;i<=3;i++)//角块赋值\n\t\tpos[dir[p][i]]=xc[i];\n\treturn ;\n}\nint main(){\n\tn=read();\n\tmemset(vis,-1,sizeof(vis));\n\tmemset(pos,-1,sizeof(pos));\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=3;j++)\n\t\t\ttile[i].c[j]=read();\n\t\tfor(int j=0;j<=3;j++)\n\t\t\tCol[tile[i].c[j]][tile[i].c[(j+1)%4]].push_back(i),\n\t\t\tCol[tile[i].c[(j+1)%4]][tile[i].c[j]].push_back(i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tmian[1]=1,vis[i]=1,DFS(i,1,0),vis[i]=-1,mian[1]=0;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nvint rig(vint v){\n    vector<vint>r(4);\n    rep(i,4){\n        r[i]=v;\n        rotate(r[i].begin(),r[i].begin()+i,r[i].end());\n    }\n    sort(all(r));\n    return r[0];\n}\n\nint en(vint v){\n    int r=0;\n    rep(i,v.size())r=r*1000+v[i];\n    return r;\n}\n\nint N;\nvector<int>C[400];\nsigned main(){\n    cin>>N;\n    map<int,int>cnt;\n    map<int,int>way;\n    rep(i,N){\n        C[i].resize(4);\n        rep(j,4)cin>>C[i][j];\n        C[i]=rig(C[i]);\n        cnt[en(C[i])]++;\n\n        vint v=C[i];\n        set<vint>s;\n        rep(k,4){\n            s.insert(v);\n            rotate(v.begin(),v.begin()+1,v.end());\n        }\n        way[en(C[i])]=4/s.size();\n    }\n\n    int ans=0;\n    rep(i,N){\n        rep(j,N)if(i!=j){\n            vint X=C[i];\n            vint Y=C[j];\n            cnt[en(C[i])]--;\n            cnt[en(C[j])]--;\n            reverse(all(Y));\n\n            rep(ii,4){\n\n                vint wanna(4);\n                rep(k,4){\n                    vint v(4);\n                    v[0]=X[(k+1)%4];\n                    v[1]=X[k];\n                    v[2]=Y[k];\n                    v[3]=Y[(k+1)%4];\n                    wanna[k]=en(rig(v));\n                }\n                vpint want;\n                rep(k,4){\n                    if(want.size()==0||want.back().fi!=wanna[k]){\n                        want.push_back(pint(wanna[k],1));\n                    }\n                    else{\n                        want[want.size()-1].se++;\n                    }\n                }\n\n                int tmp=1;\n                rep(k,want.size()){\n                    int e=want[k].fi;\n                    int f=want[k].se;\n                    if(cnt.find(e)==cnt.end()){\n                        tmp=0;\n                        continue;\n                    }\n                    int hoge=cnt[e];\n                    int piyo=way[e];\n                    rep(l,f)tmp*=(hoge-l)*piyo;\n                }\n                ans+=tmp;\n\n                rotate(Y.begin(),Y.begin()+1,Y.end());\n            }\n\n            cnt[en(C[i])]++;\n            cnt[en(C[j])]++;\n        }\n    }\n    cout<<ans/6<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nvoid debug(vector<int> tile) {\n  for (int c : tile) cout << c << ' ';\n  cout << endl;\n}\n\nvoid rm_tile(vector<int> &tile, map<vector<int>, ll> &colors) {\n  REP(i, 4) {\n    vector<int> color(4);\n    REP(j, 4) color[j] = tile[(i+j)%4];\n    colors[color]--;\n  }\n}\n\nvoid add_tile(vector<int> &tile, map<vector<int>, ll> &colors) {\n  REP(i, 4) {\n    vector<int> color(4);\n    REP(j, 4) color[j] = tile[(i+j)%4];\n    colors[color]++;\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, ll> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  for (vector<int> tile : side_tiles) {\n    ret *= max(colors[tile], 0LL);\n    rm_tile(tile, colors);\n  }\n\n  for (vector<int> tile : side_tiles) {\n    add_tile(tile, colors);\n  }\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, ll> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      vector<int> color(4);\n      REP(k, 4) color[k] = tiles[i][(j+k)%4];\n      colors[color]++;\n    }\n  }\n\n  ll ans = 0;\n  REP(i, N) {\n    vector<int> upper = tiles[i];\n    rm_tile(upper, colors);\n    FOR(j, i+1, N) {\n      vector<int> lower_base = tiles[j];\n      rm_tile(lower_base, colors);\n      REP(k, 4) {\n        vector<int> lower(4);\n        REP(l, 4) lower[l] = lower_base[(l+k)%4];\n        ans += calc_tiles(upper, lower, colors);\n      }\n      add_tile(lower_base, colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll ans;\nint n;\nstruct node{\n\tint a1,a2,a3,a4;\n\tnode() {}\n\tnode(int aa1,int aa2,int aa3,int aa4):a1(aa1),a2(aa2),a3(aa3),a4(aa4) {}\n\tbool operator <(const node &a) const {\n\t\tif(a1!=a.a1)\n\t\t\treturn a1<a.a1;\n\t\tif(a2!=a.a2)\n\t\t\treturn a2<a.a2;\n\t\tif(a3!=a.a3)\n\t\t\treturn a3<a.a3;\n\t\treturn a4<a.a4;\n\t}\n\tbool operator ==(const node &a) const{\n\t\tif(a1==a.a1&&a2==a.a2&&a3==a.a3&&a4==a.a4)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}t[MAXN];\nmap<node,ll> used;\nvoid solve(int b1,int b2,int b3,int b4){\n\tused[node(b1,b2,b3,b4)]++;\n}\nll check(node x,node y){\n\tll res=0;\n\tif(x==y)\n\t\tres++;\n\tint tx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\treturn res;\n}\t\nvoid count(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8){\n\t//PF(\"{%d %d %d %d %d %d %d %d}\\n\",b1,b2,b3,b4,b5,b6,b7,b8);\n\tnode x1=node(b1,b2,b6,b5);\n\tnode x2=node(b2,b3,b7,b6);\n\tnode x3=node(b3,b4,b8,b7);\n\tnode x4=node(b4,b1,b5,b8);\n\tnode sp1=node(b4,b3,b2,b1);\n\tnode sp2=node(b8,b7,b6,b5);\n\tll res1=used[x1];\n\tll res2=used[x2];\n\tll res3=used[x3];\n\tll res4=used[x4];\n\tres1=res1-check(sp1,x1)-check(sp2,x1);\n\tres2=res2-check(sp1,x2)-check(sp2,x2)-check(x1,x2);\n\tres3=res3-check(sp1,x3)-check(sp2,x3)-check(x1,x3)-check(x2,x3);\n\tres4=res4-check(sp1,x4)-check(sp2,x4)-check(x1,x4)-check(x2,x4)-check(x3,x4);\n\tans+=res1*res2*res3*res4;\n\t//PF(\"{%lld %lld %lld %lld %lld}\\n\",used[x1],res1,check(sp1,x1),check(sp2,x1),res4);\n}\nint main(){\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&t[i].a1,&t[i].a2,&t[i].a3,&t[i].a4);\n\t\tsolve(t[i].a4,t[i].a3,t[i].a2,t[i].a1);\n\t\tsolve(t[i].a3,t[i].a2,t[i].a1,t[i].a4);\n\t\tsolve(t[i].a2,t[i].a1,t[i].a4,t[i].a3);\n\t\tsolve(t[i].a1,t[i].a4,t[i].a3,t[i].a2);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a4,t[j].a3,t[j].a2,t[j].a1);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a3,t[j].a2,t[j].a1,t[j].a4);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a2,t[j].a1,t[j].a4,t[j].a3);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a1,t[j].a4,t[j].a3,t[j].a2);\t\n\t\t}\n\tPF(\"%lld\",ans/6ll);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=405;\nint n,c[N][4],a[N],v[4],ans;\nmap<int,int> Map;\nint get(int a,int b,int c,int d){\n\treturn (a<<30)+(b<<20)+(c<<10)+d;\n}\nvoid add(int x,int y){\n\tfor (int i=4;i--;x=x>>10|(x&1023)<<30)Map[x]+=y;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++){\n\t\t\tscanf(\"%lld\",&c[i][j]);\n\t\t\ta[i]=(a[i]<<10)+c[i][j];\n\t\t}\n\t\tadd(a[i],1);\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tadd(a[i],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tadd(a[j],-1);\n\t\t\tfor (int k=4;k--;){\n\t\t\t\tv[0]=get(c[i][0],c[j][k],c[j][(k+3)&3],c[i][1]);\n\t\t\t\tv[1]=get(c[i][1],c[j][(k+3)&3],c[j][(k+2)&3],c[i][2]);\n\t\t\t\tv[2]=get(c[i][2],c[j][(k+2)&3],c[j][(k+1)&3],c[i][3]);\n\t\t\t\tv[3]=get(c[i][3],c[j][(k+1)&3],c[j][k],c[i][0]);\n\t\t\t\tif (!Map[v[0]]||!Map[v[1]]||!Map[v[2]]||!Map[v[3]])continue;\n\t\t\t\tint now=1;\n\t\t\t\tfor (int k=4;k--;)now*=Map[v[k]],add(v[k],-1);\n\t\t\t\tans+=now;\n\t\t\t\tfor (int k=4;k--;)add(v[k],1);\n\t\t\t}\n\t\t\tadd(a[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> void chmax(T& a,const T& b){if(a < b) a = b;}\ntemplate<typename T> void chmin(T& a,const T& b){if(b < a) a = b;}\ntypedef long long ll;\n\nint N;\nconst int INF = 1e9;\nstruct tile{\n\tvector<int> c;\n\ttile(vector<int> a){\n\t\tc = a;\n\t}\n\tvoid rearrange(){\n\t\ttile mn = *this;\n\t\tFOR(i,0,4){\n\t\t\tthis->rotation();\n\t\t\tchmin(mn,*this);\n\t\t}\n\t\t*this = mn;\n\t}\n\tvoid rotation(){\n\t\tint tmp = c [0];\n\t\tFOR(i,0,3){\n\t\t\tc [i] = c [i + 1];\n\t\t}\n\t\tc [3] = tmp;\n\t}\n\tbool operator<(const tile& a) const{\n\t\treturn c < a.c;\n\t}\n\tbool operator==(const tile& a) const{\n\t\treturn c == a.c;\n\t}\n};\nmap<tile,int> mp;\n\nint cnt(tile& a)\n{\n\tint res = 0;\n\ttile tmp = a;\n\tFOR(i,0,4){\n\t\tres += tmp == a;\n\t\ttmp.rotation();\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tFOR(i,0,N){\n\t\tvector<int> a(4);\n\t\tFOR(i,0,4){\n\t\t\tcin >> a [i];\n\t\t}\n\t\ttile x(a);\n\t\tx.rearrange();\n\t\tmp [x]++;\n\t}\n\n\tll ans = 0;\n\tfor(auto&& top : mp){\n\t\tfor(auto&& bot : mp){\n\t\t\ttile tmp = bot.first;\n\t\t\tFOR(i,0,4){\n\t\t\t\tint color [8];\n\t\t\t\tFOR(j,0,4){\n\t\t\t\t\tcolor [j] = top.first.c [j];\n\t\t\t\t}\n\t\t\t\tFOR(j,0,4){\n\t\t\t\t\tcolor [j + 4] = tmp.c [j];\n\t\t\t\t}\n\t\t\t\ttile a(vector<int>{color [1],color [0],color [5],color [4]});\n\t\t\t\ttile b(vector<int>{color [2],color [1],color [4],color [7]});\n\t\t\t\ttile c(vector<int>{color [3],color [2],color [7],color [6]});\n\t\t\t\ttile d(vector<int>{color [0],color [3],color [6],color [5]});\n\t\t\t\ta.rearrange(),b.rearrange();\n\t\t\t\tc.rearrange(),d.rearrange();\n\t\t\t\tif(mp.count(a) && mp.count(b) && mp.count(c) && mp.count(d)){\n\t\t\t\t\tll mul = top.second-- * bot.second--;\n\t\t\t\t\tmul *= mp [a]-- * cnt(a);\n\t\t\t\t\tmul *= mp [b]-- * cnt(b);\n\t\t\t\t\tmul *= mp [c]-- * cnt(c);\n\t\t\t\t\tmul *= mp [d]-- * cnt(d);\n\t\t\t\t\tmp [a]++,mp [b]++,mp [c]++,mp [d]++;\n\t\t\t\t\tbot.second++,top.second++;\n\t\t\t\t\tif(mul > 0) ans += mul;\n\t\t\t\t}\n\t\t\t\ttmp.rotation();\n\t\t\t}\n\t\t}\n\t}\n\n\tans /= 6;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 405;\n\nint n;\nvector<int> a[N];\nmap<vector<int>,int> mp, m;\n\nvoid add(vector<int>& a) {\n    for (int r = 0; r < 4; ++r) {\n        vector<int> b;\n        for (int j = 0; j < 4; ++j) {\n             b.push_back(a[(j + r) % 4]);\n        }\n        ++mp[b];\n    }\n}\n\nvoid remove(vector<int>& a) {\n    for (int r = 0; r < 4; ++r) {\n        vector<int> b;\n        for (int j = 0; j < 4; ++j) {\n             b.push_back(a[(j + r) % 4]);\n        }\n        --mp[b];\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        a[i].resize(4);\n        for (int j = 0; j < 4; ++j) {\n            scanf(\"%d\", &a[i][j]);\n        }\n        add(a[i]);\n    }\n    long long result = 0;\n    vector<int> b, q;\n    for (int i = 0; i < n; ++i) {\n        remove(a[i]);\n        for (int j = i + 1; j < n; ++j) {\n            remove(a[j]);\n            q = a[j];\n            reverse(q.begin(), q.end());\n            for (int r = 0; r < 4; ++r) {\n                long long cur = 1;\n                for (int x = 0; x < 4; ++x) {\n                    b.clear();\n                    b.resize(4);\n                    b[0] = a[i][x]; \n                    b[3] = a[i][(x + 1) % 4];\n                    b[1] = q[(x + r) % 4];\n                    b[2] = q[(x + r + 1) % 4];\n                    cur *= mp[b];\n                    remove(b);\n                }\n                result += cur;\n                for (int x = 0; x < 4; ++x) {\n                    b.clear();\n                    b.resize(4);\n                    b[0] = a[i][x]; \n                    b[3] = a[i][(x + 1) % 4];\n                    b[1] = q[(x + r) % 4];\n                    b[2] = q[(x + r + 1) % 4];\n                    add(b);\n                }\n            }\n            add(a[j]);\n        }\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: Dynamic JQ\n\nProblem:\n\nTime & Date(start):\n\nVerdict:\n\nTags:\nImplementation\nBrute force\nGraphs\n\tDfs and similar\n\t\tDFS order\n\t\tTopological sort\n\t\tStrongly/Biconnected connected components\n\t\t\t2 - SAT\n\tBFS\n\tShortest Path\n\tTrees\n\t\tLCA\n\t\tCentroid Deposition\n\t\tDifferentation on trees\n\tFlows\n\t\tMax_flow\n\t\tMin_cost_flow\nData structures\n\tDSU\n\t\tUnion by rank\n\tDoubling algorithms \n\tSegment tree/Fenwick tree\n\t\tLazy tags\n\t\t2 - dimensional segment tree/Fenwick tree\n\tBalanced BST\n\tPersistent data structures\n\tDivide and conquer\n\tOffline algorithms\n\t\tMo's algorithm\n\tHeavy - light deposition\nTricks based on monotonicity\n\tBinary search\n\tTernary search\n\tTwo pointers\n*/\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nLL gen_ha(int ori[])\n{\n\tLL ret = 0;\n\trep(i, 4) ret = ret * 1000 + ori[i];\n\treturn ret;\n}\n\nLL min_rep(int ori[], int& cnt)\n{\n\tLL ret = INF;\n\trep(i, 4) {\n\t\tret = min(ret, gen_ha(ori));\n\t\trotate(ori, ori + 1, ori + 4);\n\t}\n\tcnt = 0;\n\trep(i, 4) {\n\t\tif(gen_ha(ori) == ret) cnt ++;\n\t\trotate(ori, ori + 1, ori + 4);\n\t}\n\treturn ret;\n}\n\nint n, c[405][4];\nLL ha[405];\nint hcnt[405];\n\nLL tha[4];\nint thcnt[405];\nint tmp[4];\nint fa[4], cnt[4];\nLL solve(int id0, int id1)\n{\n\trep(i, 4) {\n\t\ttmp[0] = c[id0][i];\n\t\ttmp[1] = c[id0][i + 1 & 3];\n\t\ttmp[2] = c[id1][i + 1 & 3];\n\t\ttmp[3] = c[id1][i];\n\t\ttha[i] = min_rep(tmp, thcnt[i]);\n\t}\n\t\n\trep(i, 4) fa[i] = i;\n\trep(i, 4) rep(j, i)\n\tif(tha[i] == tha[j]) {\n\t\tfa[i] = j;\n\t\tbreak;\n\t}\n\trep(i, 4) cnt[i] = 0;\n\trep(i, 4) cnt[fa[i]] ++;\n\t\n\tLL ans = 1;\n\trep(i, 4) {\n\t\tint tot = 0;\n\t\trep(j, id0) if(j != id1 && tha[i] == ha[j]) tot ++;\n\t\trep(j, cnt[i]) ans *= tot - j;\n\t\trep(j, cnt[i]) ans *= thcnt[i];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 4) scanf(\"%d\", &c[i][j]);\n\t\tha[i] = min_rep(c[i], hcnt[i]);\n\t}\n\tLL ans = 0;\n\trep(i, n) rep(j, i) {\n\t\treverse(c[i], c[i] + 4);\n\t\trep(k, 4) {\n\t\t\tans += solve(i, j);\n\t\t\trotate(c[j], c[j] + 1, c[j] + 4);\n\t\t}\n\t\treverse(c[i], c[i] + 4);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, C[400][4];\n\npair<ll, int> f(int a, int b, int c, int d) {\n    ll mi = LLONG_MAX;\n    vll v{a,b,c,d};\n    ll y[4] = {};\n    rep(i, 4) {\n        ll p = 1;\n        rep(j, 4) {\n            y[i] += p*v[(i + j) % 4];\n            p *= 1000;\n        }\n        smin(mi, y[i]);\n    }\n    int n = (int)count(y,y+4, mi);\n    return mp(mi, n);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    while(cin >> N) {\n        map<ll, int> m;\n        vector<pair<ll, int>> P(N);\n        rep(i, N) {\n            rep(j, 4)cin >> C[i][j];\n            auto p = f(C[i][0], C[i][1], C[i][2], C[i][3]);\n            m[p.first] += p.second;\n            P[i] = p;\n        }\n\n        ll w = 0;\n        vector<pair<ll,int>> r(4);\n        rep(i, N) {\n            m[P[i].first] -= P[i].second;\n            FOR(j, i + 1, N) {\n                m[P[j].first] -= P[j].second;\n                rep(k, 4) {\n                    ll x = 1;\n                    rep(l, 4) {\n                        r[l] = f(C[i][(l + 1) % 4], C[i][l], C[j][(4-l+k) % 4], C[j][(4-l+k-1)%4]);\n                        x *= m[r[l].first];\n                        m[r[l].first] -= r[l].second;\n                    }\n                    rep(l, 4)m[r[l].first] += r[l].second;\n                    w += x;\n                }\n                m[P[j].first] += P[j].second;\n            }\n        }\n\n        cout << w << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nunordered_map < ll, int > mp;\nint n;\nconst int maxN = 405;\nvector < int > c[maxN];\nvoid transform(vector < int >& a) {\n    int ans[4];\n    for (int j = 0; j < 4; j++) {\n        ans[j] = a[j];\n    }\n    for (int i = 1; i < 4; i++) {\n        int b[4];\n        for (int j = 0; j < 4; j++) {\n            b[j] = a[(i + j) % 4];\n        }\n        for (int j = 0; j < 4; j++) {\n            if (ans[j] != b[j]) {\n                if (ans[j] > b[j]) {\n                    for (int k = 0; k < 4; k++) {\n                        ans[k] = b[k];\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (int j = 0; j < 4; j++) {\n        a[j] = ans[j];\n    }\n}\nll val[maxN];\nint cnt[maxN];\nint get(vector < int >& a) {\n    int f = 0;\n    for (int j = 0; j < 4; j++) {\n        bool ok = true;\n        for (int p = 0; p < 4; p++) {\n            if (a[p] != a[(j + p) % 4]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) f++;\n    }\n    assert(f >= 1);\n    return f;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        c[i].resize(4);\n        for (int j = 0; j < 4; j++) {\n            cin >> c[i][j];\n        }\n        transform(c[i]);\n        val[i] = 0;\n        for (int j = 0; j < 4; j++) {\n            val[i] = 1000 * val[i] + c[i][j];\n        }\n        mp[val[i]]++;\n    }\n    ll ans = 0;\n    for (int first = 0; first < n; first++) {\n        for (int rot1 = 0; rot1 < 4; rot1++) {\n            for (int second = 0; second < n; second++) {\n                if (first == second) continue;\n                for (int rot2 = 0; rot2 < 4; rot2++) {\n                    vector < int > f1, f2;\n                    for (int p = 0; p < 4; p++) {\n                        f1.emplace_back(c[first][(p + rot1) % 4]);\n                        f2.emplace_back(c[second][(p + rot2) % 4]);\n                    }\n                    vector < vector < int > > r;\n                    r.push_back({f1[0], f2[1], f2[0], f1[1]});\n                    r.push_back({f1[1], f2[0], f2[3], f1[2]});\n                    r.push_back({f2[3], f2[2], f1[3], f1[2]});\n                    r.push_back({f2[1], f1[0], f1[3], f2[2]});\n                    for (int p = 0; p < 4; p++) {\n                        transform(r[p]);\n                    }\n                    ll ways = 1;\n                    for (int gg = 0; gg < 4; gg++) {\n                        bool ok = true;\n                        for (int vv = 0; vv < gg; vv++) {\n                            if (r[vv] == r[gg]) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if (!ok) continue;\n                        int z = 1;\n                        for (int vv = gg + 1; vv < 4; vv++) {\n                            if (r[vv] == r[gg]) z++;\n                        }\n                        int per = get(r[gg]);\n                        ll his_val = 0;\n                        for (int al = 0; al < 4; al++) {\n                            his_val = 1000 * his_val + r[gg][al];\n                        }\n                        if (!mp.count(his_val)) {\n                            ways = 0;\n                            break;\n                        }\n                        int total = mp[his_val];\n                        total *= per;\n                        if (his_val == val[first]) total -= per;\n                        if (his_val == val[second]) total -= per;\n                        for (int m = 1; m <= z; m++) {\n                            int cnt_now = (total - (m - 1) * per);\n                            cnt_now = max(cnt_now, 0);\n                            ways *= cnt_now;\n                        }\n                    }\n                    ans += ways;\n                }\n            }\n        }\n    }\n    assert(ans % 24 == 0);\n    cout << ans / 24;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\nconst int MAXN=405;\n\nlong long encode(long long a,long long b,long long c,long long d)\n{\n\treturn (a<<30LL)|(b<<20LL)|(c<<10LL)|d;\n}\n\nmap<long long,long long> cnt;\nvoid Add(long long c,int delta)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tcnt[c]+=delta;\n\t\tc=(c>>10LL)|((c&1023LL)<<30LL);\n\t}\n}\n\nint n;\nint c[MAXN][4];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",c[i],c[i]+1,c[i]+2,c[i]+3);\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tlong long u[4]=\n\t\t\t\t{encode(c[i][1],c[i][0],c[j][(k+1)%4],c[j][(k+0)%4]),\n\t\t\t\t encode(c[i][0],c[i][3],c[j][(k+2)%4],c[j][(k+1)%4]),\n\t\t\t\t encode(c[i][3],c[i][2],c[j][(k+3)%4],c[j][(k+2)%4]),\n\t\t\t\t encode(c[i][2],c[i][1],c[j][(k+0)%4],c[j][(k+3)%4])\n\t\t\t\t};\n\t\t\t\tlong long tmp=1;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\ttmp*=cnt[u[l]],Add(u[l],-1);\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tAdd(u[l],1);\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<ll,int>mp;\n  const ll tmp=(1<<10)-1;\n  ll access(ll now){\n    ll ret=0;\n    rep(i,0,4){\n      ret+=mp[now];\n      now=shift(now);\n    }\n    return max(0LL,ret);\n  }\n  void change(ll v,ll w){\n    mp[v]+=w;\n  }\n  ll trans(const vector<short>&v){\n    return v[0]+((ll)v[1]<<10)+((ll)v[2]<<20)+((ll)v[3]<<30);\n  }\n  ll trans(short a,short b,short c,short d){\n    return a+((ll)b<<10)+((ll)c<<20)+((ll)d<<30);\n  }\n  ll shift(ll x){\n    return (x>>10)+((x&tmp)<<30);\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,short(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  vector<ll>t(n);\n  Dict dict;\n  rep(i,0,n){\n    t[i]=dict.trans(c[i]);\n    dict.mp[t[i]]++;\n  }\n  rep(i,0,n){\n    dict.change(t[i],-1);\n    rep(j,i+1,n){\n      dict.change(t[j],-1);\n      rep(jj,0,4){\n        vector<short>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<ll>ret(4);\n        ret[0]=dict.trans(c[i][1],c[i][0],now[1],now[0]);\n        ret[1]=dict.trans(c[i][2],c[i][1],now[0],now[3]);\n        ret[2]=dict.trans(c[i][3],c[i][2],now[3],now[2]);\n        ret[3]=dict.trans(c[i][0],c[i][3],now[2],now[1]);\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(t[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n\nvoid shift(vector<int> &a){\n    rotate(a.begin(),a.begin()+1,a.end());\n};\n\nvoid normalize(vector<int>& a){\n    auto amin=a;\n    rep(i,0,4){\n        amin=min(amin,a);\n        shift(a);\n    }\n    a=amin;\n}\n\ni64 encode(vector<int>& a){\n    i64 res=0;\n    rep(i,0,4){\n        res*=1000;\n        res+=a[i];\n    }\n    return res;\n}\n\nvector<int> reverse(vector<int> &a){\n    auto b=a;\n    swap(b[0],b[1]);\n    swap(b[3],b[2]);\n    return b;\n}\n\nint f(vector<int>& a){\n    if(a[0]==a[1] and a[1]==a[2] and a[2]==a[3]) return 4;\n    if(a[0]==a[2] and a[1]==a[3]) return 2;\n    return 1;\n}\n\nvoid input(int& N,vector<vector<int>> &C){\n    cin >> N;\n    C.resize(N);\n    rep(i,0,N){\n        C[i].resize(4);\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        normalize(C[i]);\n    }\n}\n\nvoid solve(){\n    int N;\n    vector<vector<int>> C;\n    input(N,C);\n\n    map<i64,i64> count[5]; //1,2,4\n    rep(i,0,N) ++count[f(C[i])][encode(C[i])];\n \n    auto make_sides=[&](int i,int j){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i][(k+1)%4];\n            sides[k][1]=C[i][k];\n            sides[k][2]=C[j][k];\n            sides[k][3]=C[j][(k+1)%4];\n        }\n        return sides;\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        --count[f(C[i])][encode(C[i])];\n        rep(j,i+1,N){\n            --count[f(C[j])][encode(C[j])];\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto sides=make_sides(i,j);\n                for(auto &side:sides) normalize(side);\n                i64 tmp=count[f(sides[0])][encode(sides[0])]*f(sides[0]);\n                tmp*=(count[f(sides[1])][encode(sides[1])]-(encode(sides[0])==encode(sides[1])))*f(sides[1]);\n                tmp*=(count[f(sides[2])][encode(sides[2])]-((encode(sides[0])==encode(sides[2]))+(encode(sides[1])==encode(sides[2]))))*f(sides[2]);\n                tmp*=(count[f(sides[3])][encode(sides[3])]-((encode(sides[0])==encode(sides[3]))+(encode(sides[1])==encode(sides[3]))+(encode(sides[2])==encode(sides[3]))))*f(sides[3]);\n                ans+=tmp;\n                shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n            ++count[f(C[j])][encode(C[j])];\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define LL long long\nusing namespace std;\nconst int N = 2000;\nint n;\nmap <vector <int>, int> res;\nint C[N][5], S[N];\nLL ans, cnt;\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        for (int j = 0; j < 4; ++ j)\n            cin >> C[i][j];\n    // for (int i = 1; i <= n; ++ i) C[i][1] = C[i][3] = 1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        S[i] = 1;\n        for (int j = 1; j < 4; ++ j) if (C[i][0] != C[i][j]) S[i] = 0;\n    }\n    for (int i = 3; i <= n; ++ i)\n    {\n        for (int j = i + 1; j <= n; ++ j)\n            for (int k = i + 1; k <= n; ++ k) if (j != k)\n            {\n                for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                    for (int dj = 0; dj < (S[j]? 1: 4); ++ dj)\n                        for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                        {\n                            cnt ++;\n                            if (C[i][(di + 2) & 3] != C[j][(dj + 3) & 3]) continue;\n                            if (C[i][(di + 1) & 3] != C[j][(dj + 0) & 3]) continue;\n                            if (C[i][(di + 2) & 3] != C[k][(dk + 1) & 3]) continue;\n                            if (C[i][(di + 3) & 3] != C[k][(dk + 0) & 3]) continue;\n                            if (C[j][(dj + 2) & 3] != C[k][(dk + 2) & 3]) continue;\n\n                            vector <int> tmp;\n                            tmp = {C[k][(dk + 0) & 3], C[k][(dk + 3) & 3], C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3]};\n                            ans += res[tmp] << (2 * (S[i] + S[j] + S[k]));\n\n                            tmp.clear();\n                            tmp = {C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3], C[k][(dk + 0) & 3], C[k][(dk + 3) & 3]};\n                            ans += res[tmp] << (2 * (S[i] + S[j] + S[k]));\n\n                            tmp.clear();\n                            tmp = {C[i][(di + 1) & 3], C[i][(di + 0) & 3], C[k][(dk + 0) & 3], C[k][(dk + 3) & 3], C[j][(dj + 2) & 3], C[j][(dj + 1) & 3]};\n                            ans += res[tmp] << (2 * (S[i] + S[j] + S[k]));\n                        }\n            }\n\n        for (int j = 1; j < i; ++ j)\n            for (int k = 1; k < i; ++ k) if (j != k)\n            {\n                for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                    for (int dj = 0; dj < (S[j]? 1: 4); ++ dj)\n                        for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                        {\n                            if (C[i][(di + 2) & 3] != C[j][(dj + 3) & 3]) continue;\n                            if (C[i][(di + 1) & 3] != C[j][(dj + 0) & 3]) continue;\n                            if (C[i][(di + 2) & 3] != C[k][(dk + 1) & 3]) continue;\n                            if (C[i][(di + 3) & 3] != C[k][(dk + 0) & 3]) continue;\n                            if (C[j][(dj + 2) & 3] != C[k][(dk + 2) & 3]) continue;\n\n                            vector <int> tmp;\n                            tmp = {C[i][(di + 0) & 3], C[i][(di + 1) & 3], C[j][(dj + 1) & 3], C[j][(dj + 2) & 3], C[k][(dk + 3) & 3], C[k][(dk + 0) & 3]};\n                            res[tmp] += 1 << (2 * (S[i] + S[j] + S[k]));\n                        }\n            }\n    }\n    // cerr << ans << endl;\n    // res.clear();\n\n    for (int ii = 3; ii <= n; ++ ii)\n    {\n        for (int jj = ii + 1; jj <= n; ++ jj)\n            for (int kk = jj + 1; kk <= n; ++ kk)\n            {\n                for (int d = 0; d < 6; ++ d)\n                {\n                    int i, j, k;\n                    if (d == 0) i = ii, j = jj, k = kk;\n                    if (d == 1) i = ii, j = kk, k = jj;\n                    if (d == 2) i = jj, j = ii, k = kk;\n                    if (d == 3) i = jj, j = kk, k = ii;\n                    if (d == 4) i = kk, j = ii, k = jj;\n                    if (d == 5) i = kk, j = jj, k = ii;\n                    for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                        for (int dj = 0; dj < 2; ++ dj)\n                            for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                            {\n                                cnt ++;\n                                if (C[j][(dj + 0) & 3] != C[i][(di + 3) & 3]) continue;\n                                if (C[j][(dj + 1) & 3] != C[i][(di + 2) & 3]) continue;\n                                if (C[k][(dk + 0) & 3] != C[j][(dj + 3) & 3]) continue;\n                                if (C[k][(dk + 1) & 3] != C[j][(dj + 2) & 3]) continue;\n\n                                vector <int> tmp;\n                                tmp = {C[j][(dj + 0) & 3], C[j][(dj + 3) & 3], C[k][(dk + 3) & 3], C[k][(dk + 2) & 3],\n                                    C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3]};\n                                ans += res[tmp] << (2 * (S[i] + S[k]));\n\n                                tmp.clear();\n                                tmp = {C[j][(dj + 2) & 3], C[j][(dj + 1) & 3], C[i][(di + 1) & 3], C[i][(di + 0) & 3],\n                                    C[j][(dj + 0) & 3], C[j][(dj + 3) & 3], C[k][(dk + 3) & 3], C[k][(dk + 2) & 3]};\n                                ans += res[tmp] << (2 * (S[i] + S[k]));\n                            }\n                }\n            }\n        for (int jj = 2; jj < ii; ++ jj)\n            for (int kk = 1; kk < jj; ++ kk)\n            {\n                for (int d = 0; d < 6; ++ d)\n                {\n                    int i, j, k;\n                    if (d == 0) i = ii, j = jj, k = kk;\n                    if (d == 1) i = ii, j = kk, k = jj;\n                    if (d == 2) i = jj, j = ii, k = kk;\n                    if (d == 3) i = jj, j = kk, k = ii;\n                    if (d == 4) i = kk, j = ii, k = jj;\n                    if (d == 5) i = kk, j = jj, k = ii;\n                    for (int di = 0; di < (S[i]? 1: 4); ++ di)\n                        for (int dj = 0; dj < 2; ++ dj)\n                            for (int dk = 0; dk < (S[k]? 1: 4); ++ dk)\n                            {\n                                if (C[j][(dj + 0) & 3] != C[i][(di + 3) & 3]) continue;\n                                if (C[j][(dj + 1) & 3] != C[i][(di + 2) & 3]) continue;\n                                if (C[k][(dk + 0) & 3] != C[j][(dj + 3) & 3]) continue;\n                                if (C[k][(dk + 1) & 3] != C[j][(dj + 2) & 3]) continue;\n\n                                vector <int> tmp;\n                                tmp = {C[i][(di + 0) & 3], C[i][(di + 1) & 3], C[j][(dj + 1) & 3], C[j][(dj + 2) & 3],\n                                    C[k][(dk + 2) & 3], C[k][(dk + 3) & 3], C[j][(dj + 3) & 3], C[j][(dj + 0) & 3]};\n                                res[tmp] += 1 << (2 * (S[i] + S[k]));\n                            }\n                }\n            }\n    }\n    cout << ans << endl;\n    // cerr << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nll h[maxn];\ninline ll cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tll ret = 1234567891234567ll;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tll num = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tnum = num*1000+col[(rot+i)%4];\n\t\t\tret = min(ret,num);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nint fac[5];\ninline ll C(int n,int m) {\n\tif(n < m)\treturn 0;\n\tll ret = 1;\n\tfor(int i=n-m+1;i<=n;i++)\n\t\tret *= i;\n\tfor(int i=1;i<=m;i++)\n\t\tret /= i;\n\treturn ret;\n}\nmap<ll,pii> cnt;\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tint now_cnt = 0;\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tll num = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tnum = num*1000+col[i][(rot+j)%4];\n\t\t\t\tif(num == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tnow_cnt = max(now_cnt,tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t\tcnt[h[i]].first++;\n\t\tcnt[h[i]].second = now_cnt;\n\t}\n\t\n\tfac[0] = 1;\n\tfor(int i=1;i<5;i++)\n\t\tfac[i] = fac[i-1] * i;\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tcnt[h[i]].first--;\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tcnt[h[j]].first--;\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tmap<ll,int> need;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k])]++;\n\t\t\t\tll now = 1;\n\t\t\t\tfor(auto x : need)\n\t\t\t\t\tnow *= C(cnt[x.first].first,x.second) * pow(cnt[x.first].second,x.second) * fac[x.second];\n\t\t\t\tans += now;\n\t\t\t}\n\t\t\tcnt[h[j]].first++;\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n//\t\tcnt[h[i]].first++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n\nusing namespace std;\n\nstruct Tile{\n\tint c[4];\n\tTile(){}\n\tTile(int a, int b, int C, int d){\n\t\tc[0] = a, c[1] = b, c[2] = C, c[3] = d;\n\t}\n\tTile(int a[]){\n\t\tfor(int i = 0; i < 4; i++) c[i] = a[i];\n\t}\n\tTile rot(){\n\t\tTile tmp;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ttmp.c[i] = c[(i+1)%4];\n\t\t}\n\t\treturn tmp;\n\t}\n\tbool equal(Tile &obj){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(c[i] != obj.c[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool similar(Tile &obj)\n\t{\n\t\tTile tmp = obj;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) return true;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn false;\n\t}\n\tint sym()\n\t{\n\t\tint ret = 0;\n\t\tTile tmp = *this;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) ret++;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i = 0; i < 4; i++) cout << c[i] << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N;\nTile tile[405];\n\nint parent[4];\nvoid init(){\n\tfor(int i = 0; i < 4; i++) parent[i] = i;\n}\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nllint perm(llint n, llint k)\n{\n\tllint ret = 1;\n\tfor(int i = 0; i < k; i++){\n\t\tret *= n-i;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint c[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < 4; j++) cin >> c[j];\n\t\ttile[i] = Tile(c);\n\t}\n\t\n\tllint ans = 0;\n\tllint cnt[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\t\n\t\t\tTile t = tile[j];\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\n\t\t\t\tTile need[4];\n\t\t\t\tneed[0] = Tile(tile[i].c[1], tile[i].c[0], t.c[1], t.c[0]);\n\t\t\t\tneed[1] = Tile(tile[i].c[2], tile[i].c[1], t.c[0], t.c[3]);\n\t\t\t\tneed[2] = Tile(tile[i].c[3], tile[i].c[2], t.c[3], t.c[2]);\n\t\t\t\tneed[3] = Tile(tile[i].c[0], tile[i].c[3], t.c[2], t.c[1]);\n\t\t\t\t\n\t\t\t\tfor(int l = 0; l < 4; l++) cnt[l] = 0;\n\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\tif(l <= i || l == j) continue;\n\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\tif(tile[l].similar(need[m])) cnt[m]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt[0] == 0) continue;\n\t\t\t\tif(cnt[1] == 0) continue;\n\t\t\t\tif(cnt[2] == 0) continue;\n\t\t\t\tif(cnt[3] == 0) continue;\n\t\t\t\t\n\t\t\t\tinit();\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\tif(l >= m) continue;\n\t\t\t\t\t\tif(same(l, m)) continue;\n\t\t\t\t\t\tif(need[l].similar(need[m])) unite(l, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tllint cnum[4];\n\t\t\t\tfor(int i = 0; i < 4; i++) cnum[i] = 0;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tcnum[root(i)]++;\n\t\t\t\t}\n\t\t\t\tllint tmp = 1;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tif(cnum[i]) tmp *= perm(cnt[i], cnum[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++) tmp *= need[i].sym();\n\t\t\t\tans += tmp;\n\t\t\t\t\n\t\t\t\tt = t.rot();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        // if(used.count(make_hash(x))) continue;\n\n        int way=0;\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          // used.emplace(make_hash(y));\n        }\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 400\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nmap<LL,LL> mp;\nLL col[MAXN+5][4];\nLL Translate(LL seq[4])\n{\n\tLL x=0;\n\tfor(int i=0;i<4;i++)\n\t\tx=1000LL*x+1LL*seq[i];\n\treturn x;\n}\nvoid Add(LL seq[4],LL val)//以块为单位进行计算 \n{\n\tfor(int tmn=0;tmn<4;tmn++)\n\t{\n\t\tLL first=seq[0];\n\t\tfor(int j=0;j<3;j++)\n\t\t\tseq[j]=seq[j+1];\n\t\tseq[3]=first;\n\t\tLL x=Translate(seq);\n\t\tmp[x]+=val;\n\t}\n}\nLL Query(LL x)\n{\n\tif(mp.find(x)==mp.end())\n\t\treturn 0;\n\treturn mp[x];\n}\nvoid GetSeq(LL a0,LL a1,LL a2,LL a3,LL seq[4])\n{\n\tseq[0]=a0;seq[1]=a1;seq[2]=a2;seq[3]=a3;\n}\nint main()\n{\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%lld %lld %lld %lld\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tAdd(col[i],1);\n\t}\n\tLL val[4][4];\n\tLL ans=0,tot=0;\n\tLL seq[4];\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i+1;j<=N;j++)\n\t\t{\n\t\t\tAdd(col[i],-1);\n\t\t\tAdd(col[j],-1);\n\t\t\tfor(int tmn=1;tmn<=4;tmn++)\n\t\t\t{\n\t\t\t\ttot=1LL;\n\t\t\t\tGetSeq(col[j][1],col[j][0],col[i][1],col[i][0],val[0]);\n\t\t\t\tGetSeq(col[j][2],col[j][1],col[i][0],col[i][3],val[1]);\n\t\t\t\tGetSeq(col[j][0],col[j][3],col[i][2],col[i][1],val[2]);\n\t\t\t\tGetSeq(col[j][3],col[j][2],col[i][3],col[i][2],val[3]);\n\t\t\t\t//==================\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\ttot*=Query(Translate(val[k]));\n\t\t\t\t\tAdd(val[k],-1);\n\t\t\t\t}\n\t\t\t\t//==================\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tAdd(val[k],1);\n\t\t\t\tans+=tot/3LL;\n\t\t\t\tLL first=col[i][0];\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\tcol[i][k]=col[i][k+1];\n\t\t\t\tcol[i][3]=first;\n\t\t\t}\n\t\t\tAdd(col[i],1);\n\t\t\tAdd(col[j],1);\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include<cassert>\n#include<set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nconst int MAXN = 444;\nmap<vi, int> me;\nvi C[MAXN];\nll co[MAXN][MAXN];\n\nvi minV(vi v) {\n    vi ret = v;\n    for (int i = 0; i < 4; i++) {\n        rotate(v.begin(), v.begin()+1, v.end());\n        ret = min(ret, v);\n    }\n    return ret;\n}\n\nll calc(vi a) {\n    if (a[0] == a[1] && a[1] == a[2] && a[2] == a[3]) return 4;\n    if (a[0] == a[2] && a[1] == a[3]) return 2;\n    return 1;\n}\n\nll powI(ll a, int p) {\n    if (a == 0) return 0;\n    if (p == 0) return 1;\n    if (p == 1) return a;\n    if (p%2) return a*powI(a, p-1);\n    ll tmp = powI(a, p/2);\n    return tmp*tmp;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // co[i][j] = i*(i-1)*...*(i-j+1)\n    for (int i = 0; i < MAXN; i++) {\n        co[i][0] = 1;\n        for (int j = 0; j < 8; j++) co[i][j+1] = co[i][j]*(i-j);\n    }\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        vi v(4, 0);\n        for (int j = 0; j < 4; j++) cin >> v[j];\n        C[i] = minV(v);\n        me[C[i]]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) {\n        me[C[i]]--; me[C[j]]--;\n        vi a = C[i], b = C[j];\n        swap(b[0], b[2]);\n        for (int k = 0; k < 4; k++) {\n            map<vi, int> m;\n            for (int l = 0; l < 4; l++) {\n                vi v;\n                v.push_back(a[l]);\n                v.push_back(a[(l+3)%4]);\n                v.push_back(b[(l+3)%4]);\n                v.push_back(b[l]);\n                m[minV(v)]++;\n            }\n            ll t = 1;\n            auto it = m.begin();\n            while (it != m.end()) {\n                t *= co[me[it->first]][it->second];\n                t *= powI(calc(it->first), it->second);\n                ++it;\n            }\n            ans += t;\n            rotate(b.begin(), b.begin()+1, b.end());\n        }\n        me[C[i]]++;\n        me[C[j]]++;\n    }\n    ans /= 3;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef pair<LD,LD> Pt;\ntypedef tuple<int,int,int> tiii;\ntypedef tuple<LL,LL,LL> tlll;\n#define mod9 1000000009ll\n#define mod7 1000000007ll\n#define INF  1023456789ll\n#define INF16 10000000000000000ll\n#define FI first\n#define SE second\n#define X FI\n#define Y SE\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nLL n , c[ N ][ 4 ];\nvoid build(){\n \n}\nmap< LL , int > cnt;\nmap< pair<LL,LL> , int > cnt2;\nmap< tuple<LL,LL,LL> , int > cnt3;\nmap< tuple<LL,LL,LL,LL> , int > cnt4;\ninline bool bye( const pair<LL,LL>& x ){\n  LL t[ 4 ] , rr = x.first;;\n  for( int i = 3 ; i >= 0 ; i -- ){\n    t[ i ] = rr % 1000;\n    rr /= 1000;\n  }\n  for( int i = 0 ; i < 4 ; i ++ ){\n    LL ret = 0;\n    for( int j = 0 ; j < 4 ; j ++ )\n      ret = ret * 1000 + t[ ( i + j ) & 3 ];\n    if( ret == x.second ) return false;\n  }\n  return true;\n}\ninline LL CNT( LL x ){\n  auto it = cnt.find( x );\n  return it == cnt.end() ? 0 : it->second;\n}\ninline LL CNT2( const pair<LL,LL>& x ){\n  auto it = cnt2.find( x );\n  return it == cnt2.end() ? 0 : it->second;\n}\ninline LL CNT3( const tuple<LL,LL,LL>& x ){\n  auto it = cnt3.find( x );\n  return it == cnt3.end() ? 0 : it->second;\n}\ninline LL CNT4( const tuple<LL,LL,LL,LL>& x ){\n  auto it = cnt4.find( x );\n  return it == cnt4.end() ? 0 : it->second;\n}\nvector< LL > vv[ N ];\nset< LL > cand;\ninline void modify( int id , int dlt ){\n  if( vv[ id ].size() > 3u && vv[ id ][ 0 ] == vv[ id ][ 3 ] ){\n    cnt[ vv[ id ][ 0 ] ] += dlt * (1 << 2);\n    cnt2[ { vv[ id ][ 0 ] , vv[ id ][ 0 ] } ] += dlt * (1 << 4);\n    cnt3[ make_tuple( vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] ) ] += dlt * (1 << 6);\n    cnt4[ make_tuple( vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] , vv[ id ][ 0 ] ) ] += dlt * (1 << 8);\n  }else{\n    for( LL i1 : vv[ id ] ){\n      cnt[ i1 ] += dlt;\n      if( vv[ id ].size() > 1u )\n      for( LL i2 : vv[ id ] ){\n        cnt2[ { i1 , i2 } ] += dlt;\n        if( vv[ id ].size() > 2u )\n        for( LL i3 : vv[ id ] ){\n          cnt3[ make_tuple( i1 , i2 , i3 ) ] += dlt;\n          if( vv[ id ].size() > 3u )\n          for( LL i4 : vv[ id ] )\n            cnt4[ make_tuple( i1 , i2 , i3 , i4 ) ] += dlt;\n        }\n      }\n    }     \n  }\n}\ninline LL zip( LL za , LL zb , LL zc , LL zd ){\n  LL ret = 0;\n  for( LL i : { za , zb , zc , zd } )\n    ret = ret * 1000 + i;\n  return ret;\n}\nvoid init(){\n  scanf( \"%lld\" , &n );\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      scanf( \"%lld\" , &c[ i ][ j ] );\n    // for( int j = 0 ; j < 4 ; j ++ ){\n      // LL ret = 0;\n      // for( int k = 0 ; k < 4 ; k ++ )\n        // ret = ret * 1000 + c[ i ][ ( j + k ) % 4 ];\n      // vv[ i ].push_back( ret );\n    // }\n    sort( vv[ i ].begin() , vv[ i ].end() );\n  }\n}\nvoid solve(){\n  LL ans = 0;\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = i - 1 ; j >= 0 ; j -- ){\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL iv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          iv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , iv[ 1 ] , iv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , iv[ 2 ] , iv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , iv[ 3 ] , iv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , iv[ 0 ] , iv[ 3 ] );\n        cand.insert( f1 );\n        cand.insert( f2 );\n        cand.insert( f3 );\n        cand.insert( f4 );\n      }\n    }\n  }\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ ){\n      LL ret = 0;\n      for( int k = 0 ; k < 4 ; k ++ )\n        ret = ret * 1000 + c[ i ][ ( j + k ) % 4 ];\n      if( cand.count( ret ) )\n        vv[ i ].push_back( ret );\n    }\n    sort( vv[ i ].begin() , vv[ i ].end() );\n  }\n  for( int i = 0 ; i < n ; i ++ ){\n    for( int j = i - 1 ; j >= 0 ; j -- ){\n      if( j != i - 1 ) modify( j , -1 );\n      for( int rj = 0 ; rj < 4 ; rj ++ ){\n        LL iv[ 4 ];\n        for( int k = 0 ; k < 4 ; k ++ )\n          iv[ k ] = c[ j ][ ( rj + k ) % 4 ];\n        LL f1 = zip( c[ i ][ 3 ] , c[ i ][ 2 ] , iv[ 1 ] , iv[ 0 ] );\n        LL f2 = zip( c[ i ][ 2 ] , c[ i ][ 1 ] , iv[ 2 ] , iv[ 1 ] );\n        LL f3 = zip( c[ i ][ 1 ] , c[ i ][ 0 ] , iv[ 3 ] , iv[ 2 ] );\n        LL f4 = zip( c[ i ][ 0 ] , c[ i ][ 3 ] , iv[ 0 ] , iv[ 3 ] );\n        // A , B , C , D\n        LL tans = CNT( f1 ) * CNT( f2 ) * CNT( f3 ) * CNT( f4 );\n        if( tans > 0 ){\n          // { A , A } , { B , B }\n          tans += CNT2( { f1 , f2 } ) * CNT2( { f3 , f4 } );\n          tans += CNT2( { f1 , f3 } ) * CNT2( { f2 , f4 } );\n          tans += CNT2( { f1 , f4 } ) * CNT2( { f2 , f3 } );\n          // { A , A , A } , B\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f3 ) ) * CNT( f4 );\n          tans += 2ll * CNT3( make_tuple( f1 , f2 , f4 ) ) * CNT( f3 );\n          tans += 2ll * CNT3( make_tuple( f1 , f3 , f4 ) ) * CNT( f2 );\n          tans += 2ll * CNT3( make_tuple( f2 , f3 , f4 ) ) * CNT( f1 );\n          if( tans > 0 ){\n            // { A , A } , B , C\n            tans -= CNT2( { f1 , f2 } ) * CNT( f3 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f3 } ) * CNT( f2 ) * CNT( f4 );\n            tans -= CNT2( { f1 , f4 } ) * CNT( f2 ) * CNT( f3 );\n            tans -= CNT2( { f2 , f3 } ) * CNT( f1 ) * CNT( f4 );\n            tans -= CNT2( { f2 , f4 } ) * CNT( f1 ) * CNT( f3 );\n            tans -= CNT2( { f3 , f4 } ) * CNT( f1 ) * CNT( f2 );\n            // { A , A , A , A }\n            tans -= 6ll * CNT4( make_tuple( f1 , f2 , f3 , f4 ) );\n          }\n        }\n        ans += tans;\n      }\n      modify( j , +1 );\n    }\n  }\n  printf( \"%lld\\n\" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector <int> vec[210],ths[4];\nmap<vector <int>,int>mp;\nvoid leg(vector <int> &vec)\n{if (vec.size()!=4) assert(0);\n\tvector <int> ls=vec;\n\tfor (int i=1;i<=4;i++)\n\t{\n\t\tint t=vec[0];vec[0]=vec[1];vec[1]=vec[2];vec[2]=vec[3];vec[3]=t;\n\t\tif (ls>vec) ls=vec;\n\t}\n\tvec=ls;\n}\nint gnum(vector <int> &vec)\n{\n\tint ans=0;\n\tfor (int i=1;i<=4;i++)\n\t{\n\t\tif ((vec[0]==vec[(0+i)%4])&&(vec[1]==vec[(1+i)%4])&&(vec[2]==vec[(2+i)%4])&&(vec[3]==vec[(3+i)%4]))\n\t\t\tans++;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tvec[i].resize(4);\n\t\tscanf(\"%d%d%d%d\",&vec[i][0],&vec[i][1],&vec[i][2],&vec[i][3]);\n\t\tleg(vec[i]);mp[vec[i]]++;\n\t}\n\tfor (int i=0;i<4;i++) ths[i].resize(4);\n\tlong long ans=0;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<i;j++)\n\t{\n\t\tmp[vec[i]]--;mp[vec[j]]--;\n\t\tvector <int> x=vec[i],y=vec[j];reverse(x.begin(),x.end());\n\t\tfor (int d=0;d<4;d++)\n\t\t{\n\t\t\tths[0][0]=x[0];ths[0][1]=x[1];ths[0][2]=y[1];ths[0][3]=y[0];\n\t\t\tths[1][0]=x[1];ths[1][1]=x[2];ths[1][2]=y[2];ths[1][3]=y[1];\n\t\t\tths[2][0]=x[2];ths[2][1]=x[3];ths[2][2]=y[3];ths[2][3]=y[2];\n\t\t\tths[3][0]=x[3];ths[3][1]=x[0];ths[3][2]=y[0];ths[3][3]=y[3];\n\t\t\tlong long p=1;\n\t\t\tfor (int t=0;t<4;t++)\n\t\t\t{\n\t\t\t\tleg(ths[t]);\n\t\t\t\tp*=gnum(ths[t])*mp[ths[t]];\n\t\t\t\tmp[ths[t]]--;\n\t\t\t}\n\t\t\tans+=p;\n\t\t\tfor (int t=0;t<4;t++) mp[ths[t]]++;\n\t\t\tint ls=y[0];y[0]=y[1];y[1]=y[2];y[2]=y[3];y[3]=ls;\n\t\t}\n\t\tmp[vec[i]]++;mp[vec[j]]++;\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define f first\n#define s second\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%I64d\",&x)\n#define CLR(x)  memset(x,0,sizeof(x))\n#define RESET(x,a) memset(x,a,sizeof(x))\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<\">value (\"<<#x<<\") : \"<<x<<endl;\n\nconst int N=405;\nint a[N][4]; //tile\nll val[N];   //hash of tile\nint p[4];\nint sym[4];\nll d[4];\nll ans[16];\nint n;\n\ninline ll h(int p[4],int k)\n{\n    ll res=0LL;\n    for(int i=k;i<4;i++)\n        res = res<<10LL | (ll)p[i];\n    for(int i=0;i<k;i++)\n        res = res<<10LL | (ll)p[i];\n    return res;\n}\n\nll normalise(int p[4])\n{\n    return min(h(p,0),min(h(p,1),min(h(p,2),h(p,3))));\n}\n\nll way(int x, int y, int r)\n{\n    int i,j,k,b[4];\n    for(i=0;i<4;i++)\n        b[i]=a[y][ (i+r)%4 ];\n\n    p[0]=b[1];   p[1]=b[0];\n    p[2]=a[x][1];   p[3]=a[x][0];\n    if(h(p,0)==h(p,1))sym[0]=4;\n    else if(h(p,0)==h(p,2))sym[0]=2;\n    else sym[0]=1;\n    d[0]=normalise(p);\n\n    p[0]=b[0];   p[1]=b[3];\n    p[2]=a[x][2];   p[3]=a[x][1];\n    if(h(p,0)==h(p,1))sym[1]=4;\n    else if(h(p,0)==h(p,2))sym[1]=2;\n    else sym[1]=1;\n    d[1]=normalise(p);\n\n    p[0]=b[2];   p[1]=b[1];\n    p[2]=a[x][0];   p[3]=a[x][3];\n    if(h(p,0)==h(p,1))sym[2]=4;\n    else if(h(p,0)==h(p,2))sym[2]=2;\n    else sym[2]=1;\n    d[2]=normalise(p);\n\n    p[0]=b[3];   p[1]=b[2];\n    p[2]=a[x][3];   p[3]=a[x][2];\n    if(h(p,0)==h(p,1))sym[3]=4;\n    else if(h(p,0)==h(p,2))sym[3]=2;\n    else sym[3]=1;\n    d[3]=normalise(p);\n    CLR(ans);\n    ans[0]=1;\n    for(i=x+1;i<n;i++)\n    {\n        if(i==y)continue;\n        for(j=14;j>=0;j--)\n        {\n            for(k=0;k<4;k++)\n            {\n                if(j&(1<<k))continue;\n                if(val[i]==d[k])\n                    ans[j|(1<<k)] += sym[k]*ans[j];\n            }\n        }\n    }\n    return ans[15];\n}\n\nint main()\n{\n    int i,j,k;\n    si(n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<4;j++)\n            si(a[i][j]);\n        val[i] = normalise(a[i]);\n    }\n    ll ans=0LL;\n    for(i=0;i<n;i++)\n        for(j=i+1;j<n;j++)\n            for(k=0;k<4;k++)\n                ans+=way(i,j,k);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include <utility>\n#include <cstdio>\n#include<algorithm>\n#include<queue>\n#define ll  long long\n\nusing namespace std;\n\tint n;\nvoid rotate(vector<int> & vec){\n    vector<int> tmp(4);\n    int minind = min_element(vec.begin(), vec.end() ) - vec.begin();\n    for(int i=3; i>0; i--){\n\tif(vec[i]==vec[minind]){\n\t    minind=i;\n\t}else{\n\t    break;\n\t}\n    }\n    for(int i=0; i<4; i++){\n\ttmp[i] = vec[(i+minind)%4];\n    }\n    vec=tmp;\n}\nvoid rot1(vector<int> & vec){\n    int tmp = vec[0];\n    for(int i=0; i<4; i++){\n\tvec[i] = vec[i+1];\n    }\n    vec[3]=tmp;\n}\nint cntsq(vector<vector<int> > & c, vector<int>  & sq, int st, int sk){\n    int res=0;\n    for(int i=st; i<n; i++)\n\tif(i!=sk && c[i]==sq)res++;\n    return res;\n}\nint sym(vector<int> v){\n    if(v[0]!=v[2] || v[1]!=v[3])return 1;\n    if(v[0]!=v[1] || v[2]!=v[3])return 2;\n    return 4;\n}\nint main(){\n    cin>>n;\n    vector<vector<int> > c(n, vector<int>(4));\n    for(int i=0; i<n; i++){\n\tfor(int j=0; j<4; j++ )cin>>c[i][j];\n\trotate(c[i]);\n    }\n    ll res = 0;\n    for(int f = 0; f<n; f++){\n\tfor(int s=f+1; s<n; s++){\n\t    for(int r=0; r<4; r++){\n\t\tll mu=1;\n\t\tmap<vector<int>, int> occ; occ.clear();\n\t\tfor(int i=0; i<4; i++){\n\t\t    vector<int> tmp(4);\n\t\t    tmp[1] = c[f][i]; tmp[0] = c[f][(i+1)%4];\n\t\t    tmp[3] = c[s][3-(i+1)%4]; tmp[2] = c[s][3-i];\n\t\t    rotate(tmp);\n\t\t    mu*=(cntsq(c, tmp, f+1, s)-occ[tmp])*sym(tmp);\n//cout<<f<<\" \"<<s<<\" \"<<r<<\" \"<<i<<\" \"<<cntsq(c, tmp, f+1, s)<<\" \"<<mu<<\"\\n\";\n//cout<<tmp[0]<<tmp[1]<<tmp[2]<<tmp[3]<<\"\\n\";\n\t\t    occ[tmp]++;\n\t\t}\n\t\tres+=mu;\n\t\trot1(c[s]);\n//\t\tcout<<c[s][0]<<c[s][1]<<c[s][2]<<c[s][3]<<\"\\n\";\n\t    }\n\t}\n    }\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\n#define N 410\n#define lint long long\n#define gc getchar()\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nint Gc;unordered_map<lint,int> cnt;lint val[1000];\nint c[N][5];\ninline lint hv(int a,int b,int c,int d)\n{\n\treturn a*1000000000ll+b*1000000ll+c*1000ll+d;\n}\ninline lint hv(int *a)\n{\n\treturn hv(a[0],a[1],a[2],a[3]);\n}\ninline int Rot(int *a,int c)\n{\n\trep(i,1,c)\n\t{\n\t\tint tmp=a[0];\n\t\trep(j,1,3) a[j-1]=a[j];\n\t\ta[3]=tmp;\n\t}\n\treturn 0;\n}\ninline int Upd(int *a,int c,int v)\n{\n\tstatic int b[5];\n\trep(i,0,3) b[i]=a[i];\n\tRot(b,c);\n\tcnt[hv(b)]+=v;\n\treturn 0;\n}\ninline int Add(int *a)\n{\n\tcnt[hv(a[0],a[1],a[2],a[3])]++;\n\tcnt[hv(a[1],a[2],a[3],a[0])]++;\n\tcnt[hv(a[2],a[3],a[0],a[1])]++;\n\tcnt[hv(a[3],a[0],a[1],a[2])]++;\n\treturn 0;\n}\ninline int Del(int *a)\n{\n\tcnt[hv(a[0],a[1],a[2],a[3])]--;\n\tcnt[hv(a[1],a[2],a[3],a[0])]--;\n\tcnt[hv(a[2],a[3],a[0],a[1])]--;\n\tcnt[hv(a[3],a[0],a[1],a[2])]--;\n\treturn 0;\n}\ninline int Get(int a,int b,int c,int d)\n{\n\tint t=cnt[hv(a,b,c,d)];\n\tcnt[val[++Gc]=hv(a,b,c,d)]--;\n\tcnt[val[++Gc]=hv(b,c,d,a)]--;\n\tcnt[val[++Gc]=hv(c,d,a,b)]--;\n\tcnt[val[++Gc]=hv(d,a,b,c)]--;\n\treturn t;\n}\ninline int Back()\n{\n\trep(i,1,Gc) cnt[val[i]]++;\n\tGc=0;return 0;\n}\nint main()\n{\n\tint n=inn();lint ans=0ll;\n\trep(i,1,n) rep(j,0,3) c[i][j]=inn();\n\trep(i,1,n) rep(j,0,3) Upd(c[i],j,1);\n\trep(i,1,n)\n\t{\n\t\tDel(c[i]);\n\t\trep(p,0,3)\n\t\t{\n//\t\t\tRot(c[i],p);\n\t\t\trep(j,1,n) if(i!=j)\n\t\t\t{\n\t\t\t\tDel(c[j]);\n\t\t\t\trep(q,0,3)\n\t\t\t\t{\n//\t\t\t\t\tRot(c[j],q);\n\t\t\t\t\tint s,x,z,y;\n\t\t\t\t\ts=Get(c[j][1],c[j][0],c[i][1],c[i][0]);//S\n\t\t\t\t\tif(!s) goto loop;\n\t\t\t\t\tx=Get(c[j][2],c[i][3],c[i][2],c[j][3]);//X\n\t\t\t\t\tif(!x) goto loop;\n\t\t\t\t\tz=Get(c[j][1],c[i][0],c[i][3],c[j][2]);//Z\n\t\t\t\t\tif(!z) goto loop;\n\t\t\t\t\ty=Get(c[i][1],c[j][0],c[j][3],c[i][2]);//Y\n\t\t\t\t\tif(!y) goto loop;\n\t\t\t\t\tans+=1ll*s*x*z*y;\n\t\t\t\t\tloop:;\n\t\t\t\t\tBack();\n\t\t\t\t\tRot(c[j],1);\n\t\t\t\t}\n\t\t\t\tAdd(c[j]);\n\t\t\t}\n\t\t\tRot(c[i],1);\n\t\t}\n\t\tAdd(c[i]);\n\t}\n\treturn !printf(\"%lld\\n\",ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nmap<ll, vector<int>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                m[msk].PB(i);\n        }\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk= 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (int i : m[msk]) {\n                                cub[i][p]++;\n                        }\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, top+1, N) if (i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                                fo(j, 0, 15) if (old[j]) {\n                        fo(x, 0, 4) if (cub[i][x] && ((1<<x)&j == 0)) {\n                                        ways[j|(1<<x)] += old[j] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1505;\nstruct lpl{int x[5];}ini[maxn];\nint n, c[5];\nmap<lpl, long long> mp;\nlong long ans;\n\ninline bool operator < (lpl A, lpl B){\n\tif(A.x[1] == B.x[1]){\n\t\tif(A.x[2] == B.x[2]){\n\t\t\tif(A.x[3] == B.x[3]) return A.x[4] < B.x[4];\n\t\t\telse return A.x[3] < B.x[3];\t\n\t\t}\n\t\telse return A.x[2] < B.x[2];\t\n\t}\n\telse return A.x[1] < B.x[1];\n}\n\ninline lpl move(lpl A){\n\tlpl ret;\n\tret.x[1] = A.x[2];\n\tret.x[2] = A.x[3];\n\tret.x[3] = A.x[4];\n\tret.x[4] = A.x[1];\n\treturn ret;\n}\n\ninline void ins(lpl A, long long val){\n\tfor(int i = 1; i <= 4; ++i){\n\t\tA = move(A); mp[A] += val; \n\t}\n}\n\ninline void putit(){\n\tscanf(\"%d\", &n);  lpl lin;\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int j = 1; j <= 4; ++j) scanf(\"%d\", &ini[i].x[j]); \n\t\tins(ini[i], 1);\n\t}\n}\n\ninline void calc(int a, int b){\n\tlpl A = ini[a], B = ini[b];\n\tfor(int p = 1; p <= 4; ++p){\n\t\tB = move(B);\n\t\tlpl up, down, qian, hou;\n\t\tup.x[1] = A.x[2]; up.x[2] = A.x[1]; up.x[3] = B.x[1]; up.x[4] = B.x[4];\n\t\tdown.x[1] = A.x[3]; down.x[2] = A.x[2]; down.x[3] = B.x[4]; down.x[4] = B.x[3];\n\t\tqian.x[1] = A.x[4]; qian.x[2] = A.x[3]; qian.x[3] = B.x[3]; qian.x[4] = B.x[2];\n\t\thou.x[1] = A.x[1]; hou.x[2] = A.x[4]; hou.x[3] = B.x[2]; hou.x[4] = B.x[1];\t\t\n\t\tif(!mp[up] || !mp[down] || !mp[qian] || !mp[hou]) continue;\n\t\tlong long ret = 1;\n\t\tret *= mp[up]; ins(up, -1);\n\t\tret *= mp[down]; ins(down, -1);\n\t\tret *= mp[qian]; ins(qian, -1);\n\t\tret *= mp[hou]; ans += ret;\n\t\tins(up, 1); ins(down, 1); ins(qian, 1);\n\t}\n}\n\ninline void workk(){\n\tfor(int i = 1; i <= n; ++i){\n\t\tins(ini[i], -1);\n\t\tfor(int j = i + 1; j <= n; ++j){\n\t\t\tins(ini[j], -1); calc(i, j); ins(ini[j], 1);\n\t\t}\n\t\tins(ini[i], 1);\n\t}\n\tcout << ans / 3;\n}\n\nint main()\n{\n\tputit();\n\tworkk();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define f first\n#define s second\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%I64d\",&x)\n#define CLR(x)  memset(x,0,sizeof(x))\n#define RESET(x,a) memset(x,a,sizeof(x))\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<\">value (\"<<#x<<\") : \"<<x<<endl;\n\nconst int N=405;\nint a[N][4]; //tile\nll val[N];   //hash of tile\nint p[4];\nint sym[4];\nll g[4];\nll ans[16];\nint n;\n\ninline ll h(int p[4],int k)\n{\n    ll res=0LL;\n    for(int i=k;i<4;i++)\n        res = res<<10LL | (ll)p[i];\n    for(int i=0;i<k;i++)\n        res = res<<10LL | (ll)p[i];\n    return res;\n}\n\nll normalise(int p[4])\n{\n    return min(h(p,0),min(h(p,1),min(h(p,2),h(p,3))));\n}\n\nll way(int x, int y, int r)\n{\n    int i,j,k,b[4];\n    for(i=0;i<4;i++)\n        b[i]=a[y][ (i+r)%4 ];\n    ll e,f,c,d;\n    sym[0]=sym[1]=sym[2]=sym[3]=1;\n    p[0]=b[1];   p[1]=b[0];\n    p[2]=a[x][1];   p[3]=a[x][0];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[0]=4;\n    else if(e==c)sym[0]=2;\n    g[0]=min(e,min(f,min(c,d)));\n\n    p[0]=b[0];   p[1]=b[3];\n    p[2]=a[x][2];   p[3]=a[x][1];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[1]=4;\n    else if(e==c)sym[1]=2;\n    g[1]=min(e,min(f,min(c,d)));\n\n    p[0]=b[2];   p[1]=b[1];\n    p[2]=a[x][0];   p[3]=a[x][3];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[2]=4;\n    else if(e==c)sym[2]=2;\n    g[2]=min(e,min(f,min(c,d)));\n\n    p[0]=b[3];   p[1]=b[2];\n    p[2]=a[x][3];   p[3]=a[x][2];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[3]=4;\n    else if(e==c)sym[3]=2;\n    g[3]=min(e,min(f,min(c,d)));\n\n    CLR(ans);\n    ans[0]=1;\n    for(i=x+1;i<n;i++)\n    {\n        if(i==y)continue;\n        for(j=14;j>=0;j--)\n        {\n            for(k=0;k<4;k++)\n            {\n                if(j&(1<<k))continue;\n                if(val[i]==g[k])\n                    ans[j|(1<<k)] += sym[k]*ans[j];\n            }\n        }\n    }\n    return ans[15];\n}\n\nint main()\n{\n    int i,j,k;\n    si(n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<4;j++)\n            si(a[i][j]);\n        val[i] = normalise(a[i]);\n    }\n    ll ans=0LL;\n    for(i=0;i<n;i++)\n        for(j=i+1;j<n;j++)\n            for(k=0;k<4;k++)\n                ans+=way(i,j,k);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<vector<lli> > c;\nmap<vector<lli>,lli> m;\nlli ans = 0;\n\nvector<lli> rotate(vector<lli> v){\n    for(lli i = 0;i < 3;i++) swap(v[i],v[i+1]);\n    //for(lli k = 0;k < v.size();k++) cout << v[k] << \" \";cout << endl;\n    return v;\n}\nvoid recover(lli x1,lli x2,lli x3,lli x4){\n    vector<lli> v{x1,x2,x3,x4};\n    for(lli i = 0;i < 4;i++){\n        v = rotate(v);\n        m[v]++;\n    }\n}\nvoid dec(vector<lli> v){\n    for(lli i = 0;i < 4;i++){\n        v = rotate(v);\n        m[v]--;\n    }\n}\nvoid inc(vector<lli> v){\n    for(lli i = 0;i < 4;i++){\n        v = rotate(v);\n        m[v]++;\n    }\n}\nlli select(lli x1,lli x2,lli x3,lli x4){\n    vector<lli> v{x1,x2,x3,x4};\n    lli ret = m[v];\n    dec(v);\n    return ret > 0 ? ret : 0;\n}\n\nint main(int argc, char const *argv[]) {\n    cin >> n;\n    c = vector<vector<lli> > (n,vector<lli> (4));\n    for(lli i = 0;i < n;i++){\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        for(lli j = 0;j < 4;j++){\n            c[i] = rotate(c[i]);\n            m[c[i]]++;\n        }\n    }\n    for(lli i = 0;i < n;i++){\n        dec(c[i]);\n        for(lli j = i + 1;j < n;j++){\n            dec(c[j]);\n            for(lli k = 0;k < 4;k++){\n                c[j] = rotate(c[j]);\n                lli adder = 1;\n                adder *= select(c[i][1],c[i][0],c[j][1],c[j][0]);\n                adder *= select(c[i][0],c[i][3],c[j][2],c[j][1]);\n                adder *= select(c[i][3],c[i][2],c[j][3],c[j][2]);\n                adder *= select(c[i][2],c[i][1],c[j][0],c[j][3]);\n                ans += adder;\n                recover(c[i][1],c[i][0],c[j][1],c[j][0]);\n                recover(c[i][0],c[i][3],c[j][2],c[j][1]);\n                recover(c[i][3],c[i][2],c[j][3],c[j][2]);\n                recover(c[i][2],c[i][1],c[j][0],c[j][3]);\n            }\n            inc(c[j]);\n        }\n        inc(c[i]);\n    }\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n \nvoid solve(){\n    int N;\n    cin >> N;\n \n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            vector<i64> sum(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_) or Csum[indexes[k]]!=sum[i_]) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                rep(i_,0,4){\n                    sum[i_]=0;\n                    rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                }\n\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n                \n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n                indexes.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<ll,ll>mp;\n  const ll tmp=(1<<10)-1;\n  ll access(const vector<short>&v){\n    ll ret=0;\n    ll now=trans(v);\n    rep(i,0,4){\n      ret+=mp[now];\n      now=shift(now);\n    }\n    return max(0LL,ret);\n  }\n  void change(const vector<short>&v,ll w){\n    ll t=trans(v);\n    if(!mp.count(t))return;\n    mp[trans(v)]+=w;\n  }\n  ll trans(const vector<short>&v){\n    return v[0]+((ll)v[1]<<10)+((ll)v[2]<<20)+((ll)v[3]<<30);\n  }\n  ll shift(ll x){\n    return (x>>10)+((x&tmp)<<30);\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,short(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.mp[dict.trans(c[i])]++;\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<short>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<short>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<int> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,int> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,int delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)%4]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid permutar(vi &nuevo)\n{\n    vper.clear();\n    forr(i,0,4)\n    vper.pb(move(nuevo,i));\n\n}\nvoid add(vi &nuevo,int delta,map<iiii,int> &mapa)\n{\n    permutar(nuevo);\n    forr(i,0,vper.size())\n    {\n        mapa[vper[i]]+=delta;\n    }\n}\nvector<iiii> vcaras;\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n        vcaras.clear();\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   int n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   permutar(V[2]);\n   map<iiii,int> extra;\n   ll totp,answer=0;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,0,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    fiiv(cara2,move(V[j],kj));\n                    /*<<\"comenzamos\\n\";\n                    print(cara1);\n                    print(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        print(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        totp*=(todo[vcaras[l]]-extra[vcaras[l]]);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //<<answer<<endl;\n   cout<<answer/24<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst int INF=5e8;\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\nvi col[405];\nint n;\n\nvi getmini(vi c){\n  vector<int> mini(4,INF);\n  REP(k,4){\n    vector<int> tmp=c;\n    rotate(tmp.begin(),tmp.begin()+k,tmp.end());\n    chmin(mini,tmp);\n  }\n  return mini;\n}\nInt dp[405][16];\nint coef[405];\nint rotn(vi mini){\n  if(mini[0]==mini[1] && mini[1]==mini[2] && mini[2]==mini[3]) return 4;\n  else if(mini[0]==mini[2] && mini[1]==mini[3]) return 2;\n  return 1;\n}\nint main(){\n  cin>>n;\n  REP(i,n){\n    vector<int> c(4),mini;\n    REP(j,4) cin>>c[j];\n    mini=getmini(c);\n\n    col[i]=mini;\n  }\n\n\n\n  Int res=0;\n  REP(i,n) REP(j,i) REP(d,4){\n    int back[4];\n    REP(k,4) back[k]=col[j][3-k];\n    rotate(back,back+d,back+4);\n\n    map<vi,pi> cnt;\n    lint tmpn=1;\n    REP(k,4){\n      vi tmp(4),mini;\n      tmp[0]=back[k];\n      tmp[1]=back[(k+1)%4];\n      tmp[2]=col[i][(1+k)%4];\n      tmp[3]=col[i][k];\n      mini=getmini(tmp);\n      cnt[mini].fr++;\n      tmpn*=rotn(mini);\n    }\n    int match[4]={0};\n    int coef2[4]={0};\n\n    REP(k,i) if(k!=j && cnt.count(col[k])){\n      ++cnt[col[k]].sc;\n    }\n    for(auto e:cnt){\n      lint tmp2=1;\n      REP(j,e.sc.fr) tmp2=tmp2*(e.sc.sc-j);\n      tmpn*=tmp2;\n    }\n    res+=tmpn;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=440,D=4;\nint i,j,k,n,m,ch,ff;\nll ans;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nstruct cc {\n\tll a;\n\tvoid rev() {\n\t\tll t=a&1023;\n\t\t(a>>=10)|=t<<30;\n\t}\n\tvoid change() {\n\t\tll t1=(a>>10)&1023,t3=(a>>30)&1023;\n\t\ta^=(t1<<10)|(t3<<30);\n\t\ta^=(t3<<10)|(t1<<30);\n\t}\n\tll hash() {\n\t\treturn a;\n\t}\n\tvoid read() {\n\t\tfor (int i=0;i<D;i++) {\n\t\t\tint x;\n\t\t\tR(x);\n\t\t\t(a<<=10)|=x;\n\t\t}\n\t\t//change();\n\t}\n} A[N];\nmap<ll,int> Map;\nll work(cc a,cc b) {\n\tint i,j,k;\n\tcc t;\n\tll ans=1;\n\tfor (i=0;i<D;i++) {\n\t\tt.a=0;\n\t\t(t.a<<=10)|=(b.a>>((i+1)%D*10))&1023;\n\t\t(t.a<<=10)|=(b.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>((i+1)%D*10))&1023;\n\t\tans*=Map[t.hash()];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]--;\n\t\t}\n\t}\n\tfor (i=0;i<D;i++) {\n\t\tt.a=0;\n\t\t(t.a<<=10)|=(b.a>>((i+1)%D*10))&1023;\n\t\t(t.a<<=10)|=(b.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>(i*10))&1023;\n\t\t(t.a<<=10)|=(a.a>>((i+1)%D*10))&1023;\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]++;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tR(n);ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tA[i].read();\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]--;\n\t\t}\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]--;\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[i].rev();\n\t\t\t\tans+=work(A[i],A[j]);\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]++;\n\t\t\t}\n\t\t}\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tW(ans/3);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 402;\nconst ll MAXC = 1000003;\n\ntypedef array<int, 4> a4;\nostream& operator << (ostream &_s,const a4 &_p){return _s<<\"(\"<<_p[0]<<\",\"<<_p[1]<<\",\"<<_p[2]<<\",\"<<_p[3]<<\")\";}\n\nint n, cnt[MAXC];\na4 til[MAXN];\n\na4 reg (const a4 &state) {\n    a4 rot[4];\n    REP (i, 4) {\n        REP (j, 4) {\n            rot[i][j] = state[(i+j)%4];\n        }\n    }\n\n    sort(rot, rot+4);\n    return rot[0];\n}\n\nint toInt (const a4 &state) {\n    a4 rot = reg(state);\n\n    ll bs = 1, sum = 0;\n    REP (i, 4) {\n        sum = (sum + bs * rot[i]) % MAXC;\n        bs = bs * 880301 % MAXC;\n    }\n    return sum;\n}\n\nint gC (int id, int rt, int p) {\n    int d = p+rt >= 4 ? p+rt-4 : p+rt;\n    return til[id][d];\n}\n\nll ans;\n/********** Good Luck :) **********/\nint main()\n{\n    IOS();\n\n    cin >> n;\n    REP (i, n) {\n        REP (c, 4) {\n            cin >> til[i][c];\n        }\n        cnt[toInt(til[i])]++;\n    }\n    TIME(main);\n\n    a4 rem[3];\n    \n    REP (t, n) {\n        REP (l, n) {\n            REP (r, n) {\n                if (t != l && l != r && t != r) {\n                    cnt[toInt(til[t])]--;\n                    cnt[toInt(til[l])]--;\n                    cnt[toInt(til[r])]--;\n                    REP (ld, 4) {\n                        if (gC(l, ld, 0) == til[t][0] && gC(l, ld, 1) == til[t][3]) {\n                            REP (rd, 4) {\n                                if (gC(r, rd, 0) == til[t][2] && gC(r, rd, 1) == til[t][1]) {\n                                    rem[0] = {til[t][3], til[t][2], gC(r, rd, 3), gC(l, ld, 2)};\n                                    rem[1] = {gC(l, ld, 2), gC(r, rd, 3), gC(r, rd, 2), gC(l, ld, 3)};\n                                    rem[2] = {til[t][1], til[t][0], gC(l, ld, 3), gC(r, rd, 2)};\n\n                                    rem[0] = reg(rem[0]);\n                                    rem[1] = reg(rem[1]);\n                                    rem[2] = reg(rem[2]);\n\n                                    sort(rem, rem + 3);\n\n                                    int len = 0;\n                                    ll tot = 1;\n                                    REP (i, 3) {\n                                        len++;\n                                        if (i == 2 || rem[i] != rem[i+1]) {\n                                            ll cur = 1;\n                                            int hs = toInt(rem[i]);\n                                            bool alsm = rem[i][0] == rem[i][1] && rem[i][1] == rem[i][2] && rem[i][2] == rem[i][3];\n                                            bool dgsm = rem[i][0] == rem[i][2] && rem[i][1] == rem[i][3];\n                                            REP (j, len) {\n                                                cur *= cnt[hs] - j;\n                                                cur *= alsm ? 2 : 1;\n                                                cur *= dgsm ? 2 : 1;\n                                            }\n                                            \n                                            tot *= cur;\n                                            len = 0;\n                                        }\n                                    }\n\n                                    ans += tot;\n                                    \n\n                                }\n                            }\n                        }\n                    }\n                    cnt[toInt(til[t])]++;\n                    cnt[toInt(til[l])]++;\n                    cnt[toInt(til[r])]++;\n                }\n            }\n        }\n    }\n\n    cout << ans/6 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include<bits/stdc++.h>\nusing namespace std;\n# define lowbit(x) ((x)&(-x))\n# define pi acos(-1.0)\n# define eps 1e-8\n# define MOD 1000000007\n# define INF 1000000000\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(register int i=a; i<=n; ++i)\n# define FDR(i,a,n) for(register int i=a; i>=n; --i)\n# define AU(i,x)    for(auto i=x.begin(); i!=x.end(); ++i)\n# define ALL(A) A.begin(),A.end()\n# define bug puts(\"H\");\n# define lch p<<1,l,mid\n# define rch p<<1|1,mid+1,r\n# define mp make_pair\n# define pb push_back\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n# pragma comment(linker, \"/STACK:1024000000,1024000000\")\ntypedef long long LL;\ninline char nc(){\n    static char buf[1000000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int Scan(){\n    char ch=nc();int sum=0, f=1;\n    if (ch=='-') f=-1, ch=nc();\n    while(!(ch>='0'&&ch<='9'))ch=nc();\n    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();\n    return sum*f;\n}\nint ps4[4][2]={0,1,0,-1,1,0,-1,0};\nint ps8[8][2]={0,1,0,-1,1,0,-1,0,1,1,1,-1,-1,-1,-1,1};\ninline int min(int a,int b,int c) {return min(a,min(b,c));}\ninline int max(int a,int b,int c) {return max(a,max(b,c));}\ninline int min(int a,int b,int c,int d){return min(min(a,b,c),d);}\ninline int max(int a,int b,int c,int d){return max(max(a,b,c),d);}\n//struct Edge{int p, next, w;}edge[maxn];\n//inline add_edge(int u, int v, int w){edge[cnt]=Edge{v,head[u],w}; head[u]=cnt++;}\nconst int N=405;\n///Code begin..................................................................\n\nstruct Node{int a[5];}node[N];\nunordered_map<LL,int>vis;\nNode tmp, b[5];\nint F[5];\nLL ans=0;\n\nLL _hash(Node a){\n    LL tmp=0;\n    FOR(i,0,3) tmp*=1000, tmp+=a.a[i];\n    return tmp;\n}\nNode Swap(Node a){\n    Node b;\n    FOR(i,0,3) b.a[i]=a.a[3-i];\n    return b;\n}\nint find(int x){return F[x]<0?x:F[x]=find(F[x]);}\nint Check(Node c1, Node c2){\n    int cnt=0;\n    FOR(i,0,3) {\n        if (c1.a[0]==c2.a[i]&&c1.a[1]==c2.a[(i+1)%4]&&c1.a[2]==c2.a[(i+2)%4]&&c1.a[3]==c2.a[(i+3)%4])\n            ++cnt;\n    }\n    return cnt;\n}\nLL Cal(int x){\n    mem(F,-1);\n    FOR(i,0,3) FOR(j,i+1,3) {\n        if (Check(b[i],b[j])) {\n            int u=find(i), v=find(j);\n            if (u!=v) F[u]+=F[v], F[v]=u;\n        }\n    }\n    LL tmp=1;\n    FOR(i,0,3) {\n        if (F[i]>0) continue;\n        int m=vis[_hash(b[i])]-Check(node[x],b[i]), n=Check(b[i],b[i]);\n        LL now=1;\n        FOR(j,1,-F[i]) {\n            if (m<0) {now=0; break;}\n            now*=m;\n            m-=n;\n        }\n        tmp*=now;\n    }\n    return tmp;\n}\nint main ()\n{\n    int n;\n    scanf(\"%d\",&n);\n    FOR(i,1,n) {\n        scanf(\"%d%d%d%d\",&node[i].a[0],&node[i].a[1],&node[i].a[2],&node[i].a[3]);\n        node[i]=Swap(node[i]);\n        FOR(j,1,i-1) FOR(k,0,3) {\n            FOR(l,0,3) tmp.a[l]=node[j].a[(l+k)%4];\n            FOR(l,0,3) {\n                b[l].a[0]=node[i].a[l]; b[l].a[1]=node[i].a[(l+1)%4];\n                b[l].a[3]=tmp.a[l]; b[l].a[2]=tmp.a[(l+1)%4];\n            }\n            ans+=Cal(j);\n        }\n        node[i]=Swap(node[i]);\n        FOR(j,0,3) {\n            FOR(k,0,3) tmp.a[k]=node[i].a[(k+j)%4];\n            ++vis[_hash(tmp)];\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,int> cnt;\nunordered_map<LL,int> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay(v);\n    }\n    int ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];        //0-1:mae   2-3:usiro\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];    //3-2:mae  \t0-1:usiro\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                int resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 1005, base = 9971 ; \nconst int trans[6][8] = {\n\t{0, 1, 2, 3, 4, 5, 6, 7}, \n\t{7, 6, 5, 4, 3, 2, 1, 0},\n\t{4, 5, 1, 0, 7, 6, 2, 3}, \n\t{3, 2, 6, 7, 0, 1, 5, 4}, \n\t{7, 4, 0, 3, 6, 5, 1, 2}, \n\t{2, 1, 5, 6, 3, 0, 4, 7}\n} ;\nconst int turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <int>, int> Count ;\nint col[N][5], n ;\nll sum ;\n\ninline void getmin(vector <int> &p) {\n\tvector <int> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nvector <int> vec[N] ;\nmap <vector <int>, int> used, mul ;\n\ninline void solve(int x0, int x1, int x2, int x3) {\n\tvector <int> ret ;\n\tret.push_back(x0), ret.push_back(x1), ret.push_back(x2), ret.push_back(x3) ;\n\tgetmin(ret) ;\n\tsum *= mul[ret] * (Count[ret] - used[ret]) ;\n\t++ used[ret] ;\n}\n\ninline void era(int x0, int x1, int x2, int x3) {\n\tvector <int> ret ;\n\tret.push_back(x0), ret.push_back(x1), ret.push_back(x2), ret.push_back(x3) ;\n\tgetmin(ret) ;\n\t-- used[ret] ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) rep(j, 0, 3) scanf(\"%d\", &col[i][j]) ;\n\trep(i, 1, n) {\n\t\tvector <int> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\tvec[i] = ret ;\n\t\t++ Count[ret] ;\n\t\tint tot = 0 ; \n\t\tvector <int> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0 ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\t-- Count[vec[i]], -- Count[vec[j]] ;\n//\t\tprintf(\"%d %d\\n\", i, j) ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <int> ret ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) solve(ret[turn[p][0]], ret[turn[p][1]], ret[turn[p][2]], ret[turn[p][3]]) ;\n\t\t\trep(p, 0, 3) era(ret[turn[p][0]], ret[turn[p][1]], ret[turn[p][2]], ret[turn[p][3]]) ;\n\t\t\tans += sum ;\n\t\t}\n\t\t++ Count[vec[i]], ++ Count[vec[j]] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nlong long int converter(const int a, const int b, const int c, const int d) {\n\treturn ((a * 1000 + b) * 1000 + c) * 1000 + d;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<short>>box(N, vector<short>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tlong long int ans = 0;\n\tunordered_map<long long int, int>mp;\n\tunordered_map<long long int, int>sz;\n\tunordered_map<long long int, int>oold;\n\tfor (int i = N - 5; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 6; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<char>old(4, -1);\n\t\t\t\tvector<short>num(4, 0);\n\t\t\t\tvector<short>sum(4, 0);\n\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\tauto it = oold.find(converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4]));\n\t\t\t\t\tif (it != oold.end()) {\n\t\t\t\t\t\told[n] = it->second;\n\t\t\t\t\t\tsum[n] = mp[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t\tnum[n] = sz[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[j][m] && box[i][n] == box[j][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[j][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[j][(m + 3) % 4]) {\n\t\t\t\t\t\t\tsum[n]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\tfor (int l = i + 1; l < N; l++) {\n\t\t\t\t\tif (j == l)continue;\n\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[l][m] && box[i][n] == box[l][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[l][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[l][(m + 3) % 4]) {\n\t\t\t\t\t\t\t\tsum[n]++;\n\t\t\t\t\t\t\t\tif (old[n] != l) {\n\t\t\t\t\t\t\t\t\tnum[n]++;\n\t\t\t\t\t\t\t\t\told[n] = l;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m] && num[l]) {\n\t\t\t\t\t\t\tsum[l] -= num[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define iREP(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\ntypedef long long ll;\n\nmap< vector<int>,int > cnt;\n\nvoid nomalize(vector<int> a){\n    REP(i,4){\n        a.push_back(a[0]);\n        a.erase(a.begin());\n        if(cnt.find(a)!=cnt.end())cnt[a]++;\n        else cnt[a]=1;\n    }\n}\n\nint main(){\n\n    int n; cin>>n;\n    vector< vector<int> > panel;\n    REP(i,n){\n        vector<int> t(4); REP(j,4)cin>>t[j];\n        panel.push_back(t);\n        nomalize(t);\n    }\n    \n    ll ans=0;\n    for(auto itr=cnt.begin();itr!=cnt.end();itr++){\n        for(auto j=itr;j!=cnt.end();j++){\n            ll t=1;\n            if(itr==j)t*=itr->second*(j->second-1);\n            else t*=itr->second*j->second;\n            \n            vector< vector<int> > mul;\n            mul.push_back({itr->first[0],itr->first[1],j->first[1],j->first[0]});\n            mul.push_back({itr->first[1],itr->first[2],j->first[2],j->first[1]});\n            mul.push_back({itr->first[2],itr->first[3],j->first[3],j->first[2]});\n            mul.push_back({itr->first[3],itr->first[0],j->first[0],j->first[3]});\n            bool flag=true;\n            REP(i,4){\n                if(cnt.find(mul[i])==cnt.end())flag=false;\n            }\n            if(flag)REP(i,4)t*=cnt[mul[i]];\n            ans+=t;\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<A> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        if(used.count(x)) continue;\n\n        int way=0;\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          used.emplace(y);\n        }\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 402;\nconst ll MAXC = 1000003;\n\ntypedef array<int, 4> a4;\nostream& operator << (ostream &_s,const a4 &_p){return _s<<\"(\"<<_p[0]<<\",\"<<_p[1]<<\",\"<<_p[2]<<\",\"<<_p[3]<<\")\";}\n\nint n, cnt[MAXC];\na4 til[MAXN];\n\na4 reg (const a4 &state) {\n    a4 rot[4];\n    REP (i, 4) {\n        REP (j, 4) {\n            rot[i][j] = state[i+j >= 4 ? i+j-4 : i+j];\n        }\n    }\n\n    sort(rot, rot+4);\n    return rot[0];\n}\n\nint toInt (const a4 &state) {\n    a4 rot = reg(state);\n\n    ll bs = 1, sum = 0;\n    REP (i, 4) {\n        sum = sum + bs * rot[i];\n        bs = bs * 503;\n    }\n    return sum % MAXC;\n}\n\nint gC (int id, int rt, int p) {\n    int d = p+rt >= 4 ? p+rt-4 : p+rt;\n    return til[id][d];\n}\n\nll ans;\n/********** Good Luck :) **********/\nint main()\n{\n    IOS();\n\n    cin >> n;\n    REP (i, n) {\n        REP (c, 4) {\n            cin >> til[i][c];\n        }\n        cnt[toInt(til[i])]++;\n    }\n    TIME(main);\n\n    pair<a4,int> rem[4];\n    \n    int ft, fb, len, hs;\n    ll tot, cur;\n    REP (t, n) {\n        // TIME(titr);\n        REP (b, n) {\n            if (t == b) {\n                continue;\n            }\n            ft = toInt(til[t]);\n            fb = toInt(til[b]);\n            cnt[ft]--;\n            cnt[fb]--;\n            REP (bd, 4) {\n                {\n                    // TIME(pre1);\n                    rem[0].X = {til[t][3], til[t][2], gC(b, bd, 1), gC(b, bd, 0)};\n                    rem[1].X = {til[t][2], til[t][1], gC(b, bd, 2), gC(b, bd, 1)};\n                    rem[2].X = {til[t][1], til[t][0], gC(b, bd, 3), gC(b, bd, 2)};\n                    rem[3].X = {til[t][0], til[t][3], gC(b, bd, 0), gC(b, bd, 3)};\n                }\n\n                {\n                    // TIME(pre2);\n                    REP (i, 4) {\n                        rem[i].Y = toInt(rem[i].X);\n                    }\n                }\n                \n                {\n                    // TIME(pre3);\n                    sort(rem, rem + 4, [&](pair<a4,int> p1, pair<a4,int> p2) {\n                        return p1.Y < p2.Y;\n                    });\n                }\n\n                {\n                    // TIME(cc);\n\n                    len = 0;\n                    tot = 1;\n                    REP (i, 4) {\n                        len++;\n                        if (i == 3 || rem[i].Y != rem[i+1].Y) {\n                            cur = 1;\n                            hs = rem[i].Y;\n                            bool alsm = rem[i].X[0] == rem[i].X[1] && rem[i].X[1] == rem[i].X[2] && rem[i].X[2] == rem[i].X[3];\n                            bool dgsm = rem[i].X[0] == rem[i].X[2] && rem[i].X[1] == rem[i].X[3];\n                            REP (j, len) {\n                                cur *= cnt[hs] - j;\n                                cur *= alsm ? 2 : 1;\n                                cur *= dgsm ? 2 : 1;\n                            }\n                            \n                            tot *= cur;\n                            len = 0;\n                        }\n                    }\n\n                    \n                    ans += tot;\n                }\n                            \n\n            }\n            cnt[ft]++;\n            cnt[fb]++;\n\n        }\n    }\n\n    cout << ans/6 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint N;\nint C[1600][5];\n\nint used[6];\n\nll f6() {\n\tint a = used[0], b = used[2], c = used[3], d = used[1], e = used[4], f = used[5];\n\tint t[6] = { a, b, c, d, e, f };\n\tREP(i, 6) FOR(j, i + 1, 6) if (t[i] / 4 == t[j] / 4) return 0;\n\tif (C[a][0] == C[b][1] && C[a][1] == C[e][0] && C[a][2] == C[e][3] && C[a][3] == C[b][2]\n\t\t&& C[f][0] == C[d][1] && C[f][1] == C[b][0] && C[f][2] == C[b][3] && C[f][3] == C[c][2]) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nll f5() {\n\tll res = 0;\n\tint e = used[4];\n\tREP(f, N * 4) {\n\t\tif (C[e][1] == C[f][0] && C[e][2] == C[f][3]) {\n\t\t\tused[5] = f;\n\t\t\tres += f6();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f4() {\n\tll res = 0;\n\tint c = used[3];\n\tREP(e, N * 4) {\n\t\tif (C[c][1] == C[e][3] && C[c][2] == C[e][2]) {\n\t\t\tused[4] = e;\n\t\t\tres += f5();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f3() {\n\tll res = 0;\n\tint b = used[2];\n\tREP(c, N * 4) {\n\t\tif (C[b][2] == C[c][0] && C[b][3] == C[c][3]) {\n\t\t\tused[3] = c;\n\t\t\tres += f4();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f2() {\n\tll res = 0;\n\tint d = used[1];\n\tREP(b, N * 4) {\n\t\tif (C[d][0] == C[b][0] && C[d][3] == C[b][1]) {\n\t\t\tused[2] = b;\n\t\t\tres += f3();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f1() {\n\tll res = 0;\n\tint a = used[0];\n\tREP(d, N * 4) {\n\t\tif (C[a][0] == C[d][3] && C[a][1] == C[d][2]) {\n\t\t\tused[1] = d;\n\t\t\tres += f2();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f0() {\n\tll res = 0;\n\tREP(a, N * 4) {\n\t\tused[0] = a;\n\t\tres += f1();\n\t}\n\treturn res;\n}\n\nbool eq(int a, int b) {\n\tREP(i, 4) if (C[a][i] != C[b][i]) return false;\n\treturn true;\n}\n\nint main(int argc, char **argv) {\n\tcin >> N;\n\tREP(i, N) {\n\t\tREP(j, 4) cin >> C[i * 4][j];\n\t\tREP(j, 3) REP(k, 4) C[i * 4 + 1 + j][(1 + j + k) % 4] = C[i * 4][k];\n\t}\n\tREP(i, N * 4) C[i][4] = C[i][0];\n\tcout << (f0() / 24) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n明知这是一场意外，你要不要来\n明知这是一场重伤害，你会不会来\n当疯狂慢慢从爱情离开，还有什么你值得感慨\n如果风景早已都不存在，我想我谁都不爱\n——薛之谦《意外》\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n// #define MPS\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 405;\n\nmap<ll,int> Cnt;\nint n;\nVI C[maxn];\nll Ans;\n\nll f(int a,int b,int c,int d) // hash function\n{\n\treturn (((a*1000ll + b)*1000) + c)*1000 + d;\n}\nVI fmr(VI A) // find the minimal representation for a squre\n{\n\tVI ret = A;\n\tfo(d,1,3)\n\t{\n\t\tfo(i,0,3) \n\t\t\tif(ret[i] < A[(i+d)%4]) break;\n\t\t\telse if(ret[i] > A[(i+d)%4]) \n\t\t\t{\n\t\t\t\tfo(j,0,3) ret[j] = A[(j+d)%4];\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"arc062e.in\",\"r\",stdin);\n\t\tfp(\"arc062e.out\",\"w\",stdout);\n\t#endif\n\tVI tmp;\n\tsf(\"%d\",&n);\n\tfo(i,1,n) \n\t{\n\t\tfo(j,0,3) {int x; sf(\"%d\",&x); C[i].pb(x);}\n\t\ttmp = fmr(C[i]);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tfo(i,1,n)\n\t{\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\tfo(j,i+1,n)\n\t\t{\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\t\tfo(d1,0,3)\n\t\t\t{\n\t\t\t\tVI tmp;\n\t\t\t\tvector<ll> cube;\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[i][(4-d1)%4]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[j][2]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[j][0]); tmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[i][(4-d1)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[j][0]); tmp.pb(C[j][3]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][3]); tmp.pb(C[j][2]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\tsort(cube.begin(),cube.end());\n\t\t\t\tint s = 1; ll cur = 1;\n\t\t\t\tfor(int i = 1; i <= 4; ++ i)\n\t\t\t\t\tif(i != 4 && cube[i] == cube[i-1]) {++ s; continue;}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!Cnt.count(cube[i-1])) {cur = 0; break;} \n\t\t\t\t\t\tint num = Cnt[cube[i-1]]; //we are calculating A(num, s) = num! / (num-s)!\n\t\t\t\t\t\tfo(i,num-s+1,num) cur *= i;\n\t\t\t\t\t\tint bonus = 1, a, b, c, d;\n\t\t\t\t\t\tll x = cube[i-1];\n\t\t\t\t\t\ta = x/1000000000; x -= a*1000000000ll;\n\t\t\t\t\t\tb = x/1000000; x -= b*1000000ll;\n\t\t\t\t\t\tc = x/1000; x -= c*1000ll;\n\t\t\t\t\t\td = x;\n\t\t\t\t\t\tif(a == d && b == a && c == b && d == c) ++ bonus;\n\t\t\t\t\t\tif(a == c && b == d && c == a && d == b) ++ bonus;\n\t\t\t\t\t\tif(a == b && b == c && c == a && d == d) ++ bonus;\n\t\t\t\t\t\tfo(i,1,s) cur *= bonus;\n\t\t\t\t\t\ts = 1;\n\t\t\t\t\t}\n\t\t\t\tAns += cur;\n\t\t\t}\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t\t}\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tpf(\"%lld\\n\",Ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\n\n// 回転した時の最小\nvector<int> normalize(vector<int> v) {\n    vector<int> ret = v;\n    for(int i=0; i<4; i++) {\n        vector<int> tmp = v;\n        rotate(tmp.begin(), tmp.begin() + i, tmp.end());\n        ret = min(ret, tmp);\n    }\n    return ret;\n}\n\nvoid print_vec(vector<int> v) {\n    for(auto x : v) printf(\"%d \", x);\n    printf(\"\\n\");\n}\n\nmap< vector<int>, int > cnt, mul;\n\nint main() {\n    int N; scanf(\"%d\", &N);\n\n    vector< vector<int> > squares(N);\n    for(int i=0; i<N; i++) {\n        vector<int> v(4);\n        for(int k=0; k<4; k++) {\n            scanf(\"%d\", &v[k]);\n        }\n        squares[i] = normalize(v);\n        cnt[ squares[i] ]++;\n\n\n        if(squares[i][0] == squares[i][1] && squares[i][1] == squares[i][2] && squares[i][2] == squares[i][3]) {\n            mul[squares[i]] = 4;\n        }\n        else if(squares[i][0] == squares[i][2] && squares[i][1] == squares[i][3]) {\n            mul[squares[i]] = 2;\n        }\n        else {\n            mul[squares[i]] = 1;\n        }\n    }\n\n    ll ans = 0;\n    // i: front, j: back\n    for(int fr=0; fr<N; fr++) {\n        vector<int> front = squares[fr];\n        for(int bc=fr+1; bc<N; bc++) {\n            vector<int> back_orig = squares[bc];\n            cnt[front]--; cnt[back_orig]--;\n            for(int k=0; k<4; k++) {\n                // rotate (back)\n                vector<int> back(4);\n                for(int x=0; x<4; x++) {\n                    int value = squares[bc][(x+k)%4];\n                    back[x] = value;\n                }\n\n                vector< vector<int> > sides(4);\n                sides[0] = {front[0], back[1], back[0], front[1]};\n                sides[1] = {front[1], back[0], back[3], front[2]};\n                sides[2] = {front[2], back[3], back[2], front[3]};\n                sides[3] = {front[3], back[2], back[1], front[0]};\n\n                ll add = 1;\n                map< vector<int>, int > used;\n                for(auto vec : sides) {\n                    vec = normalize(vec);\n                    int exist = cnt[vec] - used[vec];\n                    if(exist == 0) {\n                        add = 0;\n                        break;\n                    }\n                    add *= exist * mul[vec];\n                    used[vec]++;\n                }\n                ans += add;\n            }\n            cnt[front]++; cnt[back_orig]++;\n        }\n    }\n    printf(\"%lld\\n\", ans / 3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n明知这是一场意外，你要不要来\n明知这是一场重伤害，你会不会来\n当疯狂慢慢从爱情离开，还有什么你值得感慨\n如果风景早已都不存在，我想我谁都不爱\n——薛之谦《意外》\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n// #define MPS\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 405;\n\nmap<ll,int> Cnt;\nint n;\nVI C[maxn];\nll Ans;\n\nll f(int a,int b,int c,int d) // hash function\n{\n\treturn (((a*1000ll + b)*1000) + c)*1000 + d;\n}\nVI fmr(VI A) // find the minimal representation for a squre\n{\n\tVI ret = A;\n\tfo(d,1,3)\n\t{\n\t\tfo(i,0,3) \n\t\t\tif(ret[i] < A[(i+d)%4]) break;\n\t\t\telse if(ret[i] > A[(i+d)%4]) \n\t\t\t{\n\t\t\t\tfo(j,0,3) ret[j] = A[(j+d)%4];\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"arc062e.in\",\"r\",stdin);\n\t\tfp(\"arc062e.out\",\"w\",stdout);\n\t#endif\n\tVI tmp;\n\tsf(\"%d\",&n);\n\tfo(i,1,n) \n\t{\n\t\tfo(j,0,3) {int x; sf(\"%d\",&x); C[i].pb(x);}\n\t\ttmp = fmr(C[i]);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tfo(i,1,n)\n\t{\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\tfo(j,i+1,n)\n\t\t{\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\t\tfo(d1,0,3)\n\t\t\t{\n\t\t\t\tVI tmp;\n\t\t\t\tvector<ll> cube;\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[i][(4-d1)%4]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[j][2]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[j][0]); tmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[i][(4-d1)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[j][0]); tmp.pb(C[j][3]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][3]); tmp.pb(C[j][2]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\tsort(cube.begin(),cube.end());\n\t\t\t\tint s = 1; ll cur = 1;\n\t\t\t\tfor(int i = 1; i <= 4; ++ i)\n\t\t\t\t\tif(i != 4 && cube[i] == cube[i-1]) {++ s; continue;}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!Cnt.count(cube[i-1])) {cur = 0; break;} \n\t\t\t\t\t\tint num = Cnt[cube[i-1]]; //we are calculating A(num, s) = num! / (num-s)!\n\t\t\t\t\t\tfo(i,num-s+1,num) cur *= i;\n\t\t\t\t\t\tint bonus = 1, a, b, c, d;\n\t\t\t\t\t\tll x = cube[i-1];\n\t\t\t\t\t\ta = x/1000000000; x -= a*1000000000;\n\t\t\t\t\t\tb = x/1000000; x -= b*1000000;\n\t\t\t\t\t\tc = x/1000; x -= c*1000;\n\t\t\t\t\t\td = x;\n\t\t\t\t\t\tif(a == d && b == a && c == b && d == c) ++ bonus;\n\t\t\t\t\t\tif(a == c && b == d && c == a && d == b) ++ bonus;\n\t\t\t\t\t\tif(a == b && b == c && c == a && d == d) ++ bonus;\n\t\t\t\t\t\tfo(i,1,s) cur *= bonus;\n\t\t\t\t\t\ts = 1;\n\t\t\t\t\t}\n\t\t\t\tAns += cur;\n\t\t\t}\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t\t}\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tpf(\"%lld\\n\",Ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef deque<int> D;\n\nvoid rot(D& d) {\n\td.push_back(d[0]);\n\td.pop_front();\n}\n\nD f(D d) {\n\tD ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\trot(d);\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint overlap(D d) {\n\tint ret = 1;\n\tD t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\trot(d);\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\n\nll P(int n, int k) {\n\tll ret = 1;\n\tfor(int i = n - k + 1; i <= n; i++) ret *= i;\n\treturn ret;\n}\n\nD C[400];\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<D, int> m;\n\tmap<D, int> cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tC[i].push_back(c);\n\t\t}\n\t\tC[i] = f(C[i]);\n\t\tm[C[i]]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tD d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\tD d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<D, int> t;\n\t\t\t\tt[f(D({ d1[1], d1[0], d2[1], d2[0] }))]++;\n\t\t\t\tt[f(D({ d1[0], d1[3], d2[2], d2[1] }))]++;\n\t\t\t\tt[f(D({ d1[3], d1[2], d2[3], d2[2] }))]++;\n\t\t\t\tt[f(D({ d1[2], d1[1], d2[0], d2[3] }))]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P(m[p.first], p.second);\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\trot(d1);\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef unsigned int U;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl; using std::cerr;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n) { cerr << #a << \" = {\"; \\\n      for(int qwq = (st); qwq <= (n); ++qwq) cerr << a[qwq] << (qwq == (n) ? '}' : ',') << (qwq == (n) ? '\\n' : ' '); }\n#define displayv(a) display(a, 0, (int)(a.size()-1))\n#include <ctime>\nclass MyTimer {\n  clock_t st;\npublic:\n  MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n  ~MyTimer() { report(); }\n  void reset() { st = clock_t(); }\n  void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) {}\n#define displayv(a) {}\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifdef QUICK_READ\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n  int a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\ninline LL readLL() {\n  LL a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\n\nconst int maxN = 400 + 5;\nconst int maxC = 1000 + 23;\nint n;\nstruct Tile {\n  int c[4];\n  Tile() {}\n  int& operator [](const int id) {\n    return c[id];\n  }\n  Tile(int x, int y, int z, int w) {\n    c[0] = x; c[1] = y; c[2] = z; c[3] = w;\n  }\n  friend bool operator < (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return A[i] < B[i];\n    return false;\n  }\n  friend bool operator == (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return false;\n    return true;\n  }\n  void rotate() {\n    int t = c[3];\n    for(int i = 3; i > 0; --i) c[i] = c[i - 1];\n    c[0] = t;\n  }\n}a[maxN];\n\nLL f[16], g[16];\nint c[4];\n\nLL solve() {\n  LL ans = 0;\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j) {\n      for(int t = 0; t < 4; ++t) {\n        a[j].rotate();\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for(int k = i + 1; k < n; ++k) if(k != j) {\n        \tmemset(c, 0, sizeof(c));\n          for(int tt = 0; tt < 4; ++tt) {\n            a[k].rotate();\n            if(a[k] == Tile(a[j][2], a[j][1], a[i][0], a[i][3])) c[0]++;\n            if(a[k] == Tile(a[j][3], a[j][2], a[i][3], a[i][2])) c[1]++;\n            if(a[k] == Tile(a[j][0], a[j][3], a[i][2], a[i][1])) c[2]++;\n            if(a[k] == Tile(a[j][1], a[j][0], a[i][1], a[i][0])) c[3]++;\n          }\n          memcpy(g, f, sizeof(g));\n//          printf(\"at k = %d, c = {%d, %d, %d, %d}\\n\", k, c[0], c[1], c[2], c[3]);\n          for(int i = 0; i < 4; ++i) if(c[i]) {\n            int num = 1 << i;\n            int full = 15 ^ num;\n            LL tc = c[i];\n            for(int S = full; S; S = full & (S - 1)) f[S | num] += g[S] * tc;\n            f[num] += g[0] * tc;\n          }\n//          for(int S = 15; S >= 0; --S) {\n//          \tfor(int i = 0; i < 4; ++i) if(S >> i & 1)\n//          \t\tf[S] += f[S ^ (1 << i)] * c[i];\n//\t\t\t\t\t}\n        }\n        ans += f[15];\n      }\n    }\n  return ans;\n}\n\nint main() {\n  n = readint();\n  for(int i = 0; i < n; ++i) for(int j = 0; j < 4; ++j) a[i][j] = readint();\n\tprintf(\"%lld\\n\", solve());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\n\nmap<pii,int> cnt[1111][1111];\nstruct tile\n{\n\tint c[4];\n\ttile(int a1,int a2,int a3,int a4){c[0]=a1;c[1]=a2;c[2]=a3;c[3]=a4;}\n\ttile(){}\n\tvoid add(int x){for(int i=0;i<4;i++)cnt[c[i]][c[i+1&3]][mp(c[i+2&3],c[i+3&3])]+=x;}\n\tint getnum()\n\t{\n\t\tif(cnt[c[0]][c[1]].find(mp(c[2],c[3]))==cnt[c[0]][c[1]].end())\n\t\t\treturn 0;\n\t\treturn cnt[c[0]][c[1]][mp(c[2],c[3])];\n\t}\n\ttile rev()\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i]=c[i^3];\n\t\treturn ret;\n\t}\n\ttile rotate(int x)\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i+x&3]=c[i];\n\t\treturn ret;\n\t}\n\ttile print(){printf(\"tile %d %d %d %d\\n\",c[0],c[1],c[2],c[3]);}\n}a[411],tmp[4];\n\nLL getnum(const tile up,const tile down)\n{\n\tbool hehe[4]={};\n\tLL ret=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n//\t\tcur.print();printf(\"num= %d\\n\",cur.getnum());\n\t\tint t=cur.getnum();\n\t\tret *=t;\n\t\tif(t)cur.add(-1);\n\t\telse hehe[i]=1;\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n\t\tif(!hehe[i])cur.add(1);\n\t}\n\treturn ret;\n}\nint n;\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t\tget1(a[i].c[j]);\n\t\ta[i].add(1);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i].add(-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\ta[j].add(-1);\n\t\t\tfor(int k=0;k<4;k++)ans+=getnum(a[i],a[j].rev().rotate(k));\n\t\t\ta[j].add(1);\n\t\t}\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile a, tile b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) {return a.color[i] < b.color[i];}\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) {tmp.color[i] = t.color[i];}\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    for (int j = 0; j < 4; ++j) {tmp.color[j] = comp.color[j];}\n  }\n}\n\nbool same(tile a, tile b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= (a.color[i] == b.color[i]);\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) {\n      cin >> t[i].color[j];\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {regulation(t[i]);}\n  sort(t, t+N, comp_tile);\n\n\n  ll ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) {top.color[k] = t[i].color[k];}\n        for (int k = 0; k < 4; ++k) {bottom.color[k] = t[j].color[k];}\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) {tmp1.color[l] = bottom.color[l];}\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) {regulation(sides[l]);}\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) {tmp.color[n] = sides[m].color[n];}\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) ++symmetry_count[m];\n              for (int l = 0; l < 4; ++l) {tmp.color[l] = cmp.color[l];}\n            }\n          }\n\n          ll tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) {\n              if (same(sides[n],sides[m])) ++x;\n            }\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= match_count[m] - x;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\n\nint N, t, C[MAX][5];\nmap<ll,pair<int,int> >::iterator it;\nmap<ll,pair<int,int> > MP;\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    it=MP.find(H);\n    if(it!=MP.end())\n    {\n        it->s.s+=t;\n        return;\n    }\n    int re=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n    MP[H]=mp(re, t);\n}\n\ninline int Find(ll H)\n{\n    it=MP.find(H);\n    return it->s.f*it->s.s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n\nint N;\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    random_shuffle(C.begin(),C.end());\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N),Cpro(N);\n    rep(i,0,N){\n        Cpro[i]=1;\n        rep(j,0,4){\n            Csum[i]+=C[i][j];\n            Cpro[i]*=C[i][j];\n        }\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n\n    auto normalize=[&](vector<vector<int>> &a){\n        rep(i,0,4){\n            auto amin=a[i];\n            rep(j,0,4){\n                amin=min(amin,a[i]);\n                a[i]=shift(a[i]);\n            }\n        }\n        sort(a.begin(),a.begin());\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            vector<i64> sum(4),pro(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_) or Csum[indexes[k]]!=sum[i_] or Cpro[indexes[k]]!=pro[i_]) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto next_sides=make_sides(i,j);\n                normalize(next_sides);\n                if(next_sides!=sides){\n                    for(auto& u:update) memo[u.first][u.second]=-1;\n                    update.clear();\n                    indexes.clear();\n                    sides=next_sides;\n                    rep(i_,0,4){\n                        sum[i_]=0;\n                        pro[i_]=1;\n                        rep(j_,0,4){\n                            sum[i_]+=sides[i_][j_];\n                            pro[i_]*=sides[i_][j_];\n                        }\n                    }\n                }\n\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_] and Cpro[i_]==pro[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n\n                C[j]=shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> cyc(V<int> &a) {\n\tVV<int> cand;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(a[(j+k)%4]);\n\t\t}\n\t\tcand.pb(vec);\n\t}\n\treturn *min_element(ALL(cand));\n}\n\nint com(V<int>& v) {\n\tint cnt = 0;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(v[(j+k)%4]);\n\t\t}\n\t\tif (vec == v) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> vf;\n\n\tmap<V<int>, int> T, coef;\n\n\trep(i, N) {\n\t\tV<int> a(4);\n\t\trep(j, 4) cin >> a[j];\n\n\t\tauto vec = cyc(a);\n\t\tvf.pb(vec);\n\t\t++T[vec];\n\t\tdump(vec);\n\t\tcoef[vec] = com(vec);\n\t}\n\n\tll ans = 0;\n\n\trep(i, N) {\n\t\trep(j, i) {\n\t\t\t--T[vf[i]];\n\t\t\t--T[vf[j]];\n\n\t\t\trep(k, 4) {\n\t\t\t\tint up[4], dw[4];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tup[l] = vf[i][l];\n\t\t\t\t\tdw[l] = vf[j][(k-l+4)%4];\n\t\t\t\t}\n\n\t\t\t\tll t = 1;\n\n\t\t\t\tVV<int> use;\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tV<int> vec{up[l],up[(l+3)%4],dw[(l+3)%4],dw[l]};\n\t\t\t\t\tvec = cyc(vec);\n\t\t\t\t\tuse.pb(vec);\n\t\t\t\t\tt *= T[vec] * coef[vec];\n\t\t\t\t\t--T[vec];\n\t\t\t\t\tif (T[vec] < 0) break;\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\trep(l, 4) ++T[use[l]];\n\t\t\t}\n\n\t\t\t++T[vf[i]];\n\t\t\t++T[vf[j]];\t\t\t\n\t\t}\n\t}\n\tdump(ans);\n\n\tcout << ans / 3 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define AREP(i,a,n) for(int i=a;i<n;i++)\nvoid SO(vector<int> &v){\n  vector<int> w(8);\n  REP(i,4)w[i]=w[i+4]=v[i];\n  REP(j,4)\n    if(w[j]*1e9+w[j+1]*1e6+w[j+2]*1e3+w[j+3]<v[0]*1e9+v[1]*1e6+v[2]*1e3+v[3])\n      REP(a,4)v[a]=w[j+a];\n}\nint cou(vector<vector<int>> &c,vector<int> &need,int idx,int n,int ex){\n  if((idx<n-1&&c[idx+1]>need)||c[n-1]<need)return 0;\n  int l=idx,r=n;\n  while(r-l>1){\n    int mid=(r+l)>>1;\n    (c[mid]<need?l:r)=mid;\n  }\n  int miman=l;\n  r=n;\n  while(r-l>1){\n    int mid=(r+l)>>1;\n    (c[mid]<=need?l:r)=mid;\n  }\n  return l-miman-(c[ex]==need);\n}\nint F(vector<int> &v){\n  if(v[0]==v[1]&&v[1]==v[2]&&v[2]==v[3])return 4;\n  if(v[0]==v[2]&&v[1]==v[3])return 2;\n  return 1;\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<vector<int>> c(n);\n  REP(i,n){\n    REP(j,4){\n      int a;cin>>a;\n      c[i].push_back(a);\n    }\n    SO(c[i]);\n  }\n  sort(c.begin(),c.end());\n  int ans=0;\n  REP(i,n)\n    AREP(j,i+1,n)\n      REP(k,4){\n        vector<vector<int>> need(4);\n        REP(l,4){\n          need[l].push_back(c[j][(4-l+1+k)%4]);\n          need[l].push_back(c[j][(4-l+k)%4]);\n          need[l].push_back(c[i][(l+1)%4]);\n          need[l].push_back(c[i][l]);\n          SO(need[l]);\n        }\n        sort(need.begin(),need.end());\n        int A=cou(c,need[0],i,n,j);\n        int B=(need[0]==need[1]?A-1:cou(c,need[1],i,n,j));\n        int C=(need[1]==need[2]?B-1:cou(c,need[2],i,n,j));\n        int D=(need[2]==need[3]?C-1:cou(c,need[3],i,n,j));\n        if(min({A,B,C,D})<=0)continue;\n        ans+=A*B*C*D*F(need[0])*F(need[1])*F(need[2])*F(need[3]);\n      }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<std::vector<int>>> fss(n);\n    for (auto& fs : fss) {\n        std::vector<int> f(4);\n        for (auto& x : f) std::cin >> x;\n\n        for (int r = 0; r < 4; ++r) {\n            fs.push_back(f);\n            std::rotate(f.begin(), f.begin() + 1, f.end());\n        }\n    }\n\n    lint ans = 0;\n    std::vector<std::vector<int>> cs;\n    std::vector<lint> dp(1 << 4), ndp(1 << 4);\n\n    for (int i = 0; i < n; ++i) {\n        // top face (fixed)\n        const auto& tf = fss[i][0];\n\n        for (int j = 0; j < i; ++j) {\n            // bottom face\n            for (const auto& bf : fss[j]) {\n                cs = std::vector<std::vector<int>>{\n                    {tf[3], tf[2], bf[1], bf[0]},\n                    {tf[2], tf[1], bf[2], bf[1]},\n                    {tf[1], tf[0], bf[3], bf[2]},\n                    {tf[0], tf[3], bf[0], bf[3]},\n                };\n\n                std::fill(dp.begin(), dp.end(), 0);\n                dp[0] = 1;\n                for (int k = 0; k < i; ++k) {\n                    if (k == j) continue;\n                    ndp = dp;\n\n                    for (const auto& f : fss[k]) {\n                        for (int b = 0; b < (1 << 4); ++b) {\n                            for (int l = 0; l < 4; ++l) {\n                                if (((b >> l) & 1) ||\n                                    cs[l] != f) continue;\n                                ndp[b | (1 << l)] += dp[b];\n                            }\n                        }\n                    }\n                    std::swap(dp, ndp);\n                }\n\n                ans += dp.back();\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconst ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nll vitoll(const vi &v){\n  ll ret = 0;\n  rep(i, 4){\n    ret *= 1000;\n    ret += v[i];\n  }\n  return ret;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n;\n  cin >> n;\n  vvi col(n, vi(7));\n  rep(i, n){\n    rep(j, 4){\n      cin >> col[i][j];\n    }\n    repr(j, 4, 7){\n      col[i][j] = col[i][j-4];\n    }\n  }\n  map<ll, vi> mp;\n  rep(i, n){\n    rep(j, 4){\n      vi tmp;\n      repr(k, j, j+4){\n        tmp.emplace_back(col[i][k]);\n      }\n      ll tmp2 = vitoll(tmp);\n      if(mp.count(tmp2)){\n        mp[tmp2].emplace_back(i);\n      }else{\n        mp[tmp2] = vi(1, i);\n      }\n    }\n  }\n  ll ans = 0;\n  rep(x, n){\n    repr(y, x+1, n){\n      rep(rol, 4){\n        vi tmp;\n        rep(k, 4){\n          tmp.emplace_back(col[x][k]);\n        }\n        repr(k, rol, rol+4){\n          tmp.emplace_back(col[y][k]);\n        }\n        vvi rem;\n        rem.emplace_back(vi{tmp[4], tmp[7], tmp[1], tmp[0]});\n        rem.emplace_back(vi{tmp[7], tmp[6], tmp[2], tmp[1]});\n        rem.emplace_back(vi{tmp[6], tmp[5], tmp[3], tmp[2]});\n        rem.emplace_back(vi{tmp[5], tmp[4], tmp[0], tmp[3]});\n        // 包除\n        bool f = 1;\n        rep(i, 4){\n          ll hash = vitoll(rem[i]);\n          if(!mp.count(hash)){\n            f = 0;\n            break;\n          }\n        }\n        if(!f) continue;\n        vvll cnt(4, vll(n, 0));\n        vll sum(16, 0);\n        rep(i, 4){\n          ll hash = vitoll(rem[i]);\n          if(mp.count(hash)){\n            for(auto&& e: mp[hash]){\n              if(e != x && e != y){\n                cnt[i][e]++;\n              }\n            }\n          }\n        }\n        dump(cnt);\n        // 7000 ms\n        repr(i, 1, 16){\n          rep(k, n){\n            ll tmp = 1;\n            rep(j, 4){\n              if((i>>j)&1){\n                tmp *= cnt[j][k];\n              }\n            }\n            sum[i] += tmp;\n          }\n        }\n        // 100 ms\n        ll anst = sum[1]*sum[2]*sum[4]*sum[8];\n        rep(i, 16){\n          ll c = __builtin_popcountll(i);\n          if(c == 2){\n            ll anstt = sum[i];\n            rep(j, 4) if(!((i>>j)&1)) anstt *= sum[1<<j];\n            anst -= anstt;\n          }\n          if(c == 2 && (i & 1)){\n            anst += sum[i]*sum[i^15];\n          }\n          if(c == 3){\n            anst += sum[i]*sum[i^15]*2;\n          }\n          if(c == 4){\n            anst -= sum[i]*6;\n          }\n        }\n        ans += anst;\n      }\n    }\n  }\n  print(ans/3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n/*//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n        //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    *//*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*//*\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,int> cnt;\nunordered_map<LL,int> way;*/\n\nvector<int> rig(vector<int> v){\n    vector<vector<int>> r(4);\n    for (int i = 0; i < 4; ++i) {\n        r[i]=v;\n        rotate(r[i].begin(),r[i].begin()+i,r[i].end());\n    }\n    sort(all(r));\n    return r[0];\n}\n\nLL en(vector<int> v){\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\nint n;\nvector<int>C[400];\nsigned main(){\n    cin>>n;\n    map<LL,int>cnt;\n    map<LL,int>way;\n    for (int i = 0; i < n; ++i) {\n        C[i].resize(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>C[i][j];\n        }\n        C[i]=rig(C[i]);\n        cnt[en(C[i])]++;\n\n        vector<int> v=C[i];\n        set<vector<int>>s;\n        for (int k = 0; k <4 ; ++k) {\n            s.insert(v);\n            rotate(v.begin(),v.begin()+1,v.end());\n        }\n        way[en(C[i])]=4/s.size();\n    }\n\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        cnt[en(C[i])]--;\n        vector<int> X=C[i];\n        for (int j = i+1; j < n; ++j) {\n            vector<int> Y=C[j];\n            cnt[en(C[j])]--;\n            reverse(all(Y));\n\n            for (int ii = 0; ii < 4; ++ii) {\n                vector<LL> wanna(4);\n                for(int k=0;k<4;k++){\n                    vector<int> v(4);\n                    v[0]=X[(k+1)%4];\n                    v[1]=X[k];\n                    v[2]=Y[k];\n                    v[3]=Y[(k+1)%4];\n                    v=rig(v);\n                    wanna[k]=en(v);\n                }\n                sort(all(wanna));\n                vector<pair<int,int>> want;\n                for(int k=0;k<4;k++){\n                    if(want.size()==0||want.back().first!=wanna[k]){\n                        want.push_back(mp(wanna[k],1));\n                    }\n                    else{\n                        want[want.size()-1].second++;\n                    }\n                }\n\n                LL tmp=1;\n                for(int k=0;k<want.size();k++){\n                    int e=want[k].first;\n                    int f=want[k].second;\n                    if(cnt.find(e)==cnt.end()){\n                        tmp=0;\n                        continue;\n                    }\n                    LL hoge=cnt[e];\n                    LL piyo=way[e];\n                    for(int l=0;l<f;l++)\n                        tmp*=(hoge-l)*piyo;\n                }\n                ans+=tmp;\n                rotate(Y.begin(),Y.begin()+1,Y.end());\n            }\n            cnt[en(C[j])]++;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// author: hjy\n// Problem:\n#include<bits/stdc++.h>\n//#pragma GCC optimize(2)\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define rep(i,n) for(register int i=0; i<(int)(n); ++i)\n#define per(i,n) for(register int i=(int)(n)-1; i>=0; --i)\n#define rep1(i,n) for(register int i=1; i<=(int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\ninline int read() {\n\tint x=0,ng=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') { if(ch=='-') ng=1; ch=getchar(); }\n\twhile(ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn ng?-x:x;\n}\n\nconst int mod=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int seed=20040305;\n\nint n;\nint c[410][5];\nvector<pair<pii,pii> > v;\nll res;\nmap<pair<pii,pii>,int> have;\n\n\nint same(pair<pii,pii> cur,pair<pii,pii> per)\n{\n\tint cnt=0;\n\tif(cur==per) cnt++;\n\tif(cur==mp(mp(per.fi.se,per.se.fi),mp(per.se.se,per.fi.fi))) cnt++;\n\tif(cur==mp(mp(per.se.fi,per.se.se),mp(per.fi.fi,per.fi.se))) cnt++;\n\tif(cur==mp(mp(per.se.se,per.fi.fi),mp(per.fi.se,per.se.fi))) cnt++;\n\treturn cnt;\n}\n/*\n1---2\n|   |\n3---4\n*/\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n)\n\t{\n\t\trep(j,4) scanf(\"%d\",&c[i][j]);\n\t\trep(j,v.size())\n\t\t{\n\t\t\t\n\t\t\tpair<pii,pii> x=v[j];\n\t\t\tpair<pii,pii> y=mp(mp(c[i][0],c[i][1]),mp(c[i][2],c[i][3]));\n\t\t\tpair<pii,pii> c1=mp(mp(x.se.se,x.se.fi),mp(y.fi.se,y.fi.fi));\n\t\t\tpair<pii,pii> c2=mp(mp(x.se.fi,x.fi.se),mp(y.se.fi,y.fi.se));\n\t\t\tpair<pii,pii> c3=mp(mp(x.fi.se,x.fi.fi),mp(y.se.se,y.se.fi));\n\t\t\tpair<pii,pii> c4=mp(mp(x.fi.fi,x.se.se),mp(y.fi.fi,y.se.se));\n//\t\t\tprintf(\"x=%d%d%d%d\\n\",x.fi.fi,x.fi.se,x.se.fi,x.se.se);\n//\t\t\tprintf(\"c1=%d%d%d%d\\n\",c1.fi.fi,c1.fi.se,c1.se.fi,c1.se.se);\n\t\t\tll all=1;\n\t\t\tall*=have[c1]-same(c1,x);\n\t\t\tall*=have[c2]-same(c2,x)-same(c2,c1);\n\t\t\tall*=have[c3]-same(c3,x)-same(c3,c1)-same(c3,c2);\n\t\t\tall*=have[c4]-same(c4,x)-same(c4,c1)-same(c4,c2)-same(c4,c3);\n\t\t\tres+=all;\n\t\t}\n\t\tv.pb(mp(mp(c[i][0],c[i][1]),mp(c[i][2],c[i][3])));\n\t\tv.pb(mp(mp(c[i][1],c[i][2]),mp(c[i][3],c[i][0])));\n\t\tv.pb(mp(mp(c[i][2],c[i][3]),mp(c[i][0],c[i][1])));\n\t\tv.pb(mp(mp(c[i][3],c[i][0]),mp(c[i][1],c[i][2])));\n\t\thave[mp(mp(c[i][0],c[i][1]),mp(c[i][2],c[i][3]))]++;\n\t\thave[mp(mp(c[i][1],c[i][2]),mp(c[i][3],c[i][0]))]++;\n\t\thave[mp(mp(c[i][2],c[i][3]),mp(c[i][0],c[i][1]))]++;\n\t\thave[mp(mp(c[i][3],c[i][0]),mp(c[i][1],c[i][2]))]++;\n\t}\n\tprintf(\"%lld\",res);\n}\n/*\n       1-------2          x\n      /|      /|\n\t 4-------3 |\n\t | 4-----|-3\n\t |/      |/  \n\t 1-------2            y   \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n\ntypedef long long ll;\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > ita(n,vector<int>(4,0));\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ita[i][0] >> ita[i][1] >> ita[i][2] >> ita[i][3];\n\t\t\n\t}\n\tsort(ita.begin(), ita.end());\n\tvector<int> igno(4, -1);\n\tvector<int> tage(4);\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> I;\n\t\tI = ita[i];\n\t\t//ita[i] = igno;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tvector<int> J;\n\t\t\tJ = ita[j];\n\t\t\t//ita[j] = igno;\n\t\t\tfor (int k = 0; k < 4; k++) {//下の面の回転\n\t\t\t\tint flag = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {//四側面\n\t\t\t\t\tint kosuu = 0;\n\t\t\t\t\tfor (int m = 0; m < 4; m++) {//側面の回転\n\t\t\t\t\t\ttage[(0 + m) % 4] = I[(0+l)%4];\n\t\t\t\t\t\ttage[(1 + m) % 4] = I[(3+l)%4];\n\t\t\t\t\t\ttage[(2 + m) % 4] = J[(1+k+3*l)%4];\n\t\t\t\t\t\ttage[(3 + m) % 4] = J[(0+k+3*l)%4];\n\t\t\t\t\t\tauto sita = lower_bound(ita.begin()+i, ita.end(), tage);\n\t\t\t\t\t\tauto ue = upper_bound(ita.begin()+i, ita.end(), tage);\n\t\t\t\t\t\tif(sita != ita.end())kosuu += distance(sita, ue);\n\t\t\t\t\t\tif (tage == I)kosuu--;\n\t\t\t\t\t\tif (tage == J)kosuu--;\n\t\t\t\t\t\t//cout << distance(sita, ue);\n\t\t\t\t\t}\t\n\t\t\t\t\tflag *= kosuu;\n\t\t\t\t}\n\t\t\t\t//cout << flag<<\" \";\n\t\t\t\tans += flag;\n\t\t\t}\n\t\t\tita[j] = J;\n\t\t}\n\t\tita[i] = I;\n\t}\n\tcout << endl;\n\tcout << ans << endl;\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\n\nint nextInt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 400;\nint col[N][8];\nlong long hash[N][4];\nset<long long> any;\nlong long dp[16];\nint ways[4];\n\nlong long calcHash(int a, int b, int c, int d) {\n\tlong long h = 0;\n\th = 1000 * h + a;\n\th = 1000 * h + b;\n\th = 1000 * h + c;\n\th = 1000 * h + d;\n\treturn h;\n}\n\nint main() {\n\tint n = nextInt();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcol[i][j] = nextInt();\n\t\t\tcol[i][j + 4] = col[i][j];\n\t\t}\n\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t}\n\t\t\tany.insert(hash[i][rot]);\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int front = 0; front < n; front++) {\n\t\tint a = col[front][0];\n\t\tint b = col[front][1];\n\t\tint c = col[front][2];\n\t\tint d = col[front][3];\n\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\trotLoop:\n\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\tlong long h1 = calcHash(a, e, f, b);\n\t\t\t\tlong long h2 = calcHash(b, f, g, c);\n\t\t\t\tlong long h3 = calcHash(d, c, g, h);\n\t\t\t\tlong long h4 = calcHash(e, a, d, h);\n\t\t\t\tvector<long long> hs = {h1, h2, h3, h4};\n\t\t\t\tbool can = true;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (any.count(s) == 0) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!can) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tdp[i] = 0;\n\t\t\t\t}\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tways[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint vtoi(int a, int b, int c, int d){\n    return a + 1000 * b + 1000000 * c + 1000000000 * d;\n}\nint vtoi(vec v){\n    return vtoi(v[0], v[1], v[2], v[3]);\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    mat C(N, vec(4));\n    vector<mat> C2(N, mat(4, vec(4)));\n    map<int, int> m;\n    REP(i, N){\n        readv(C[i]);\n        REP(r, 4){\n            REP(j, 4) C2[i][r][j] = C[i][(j + r) % 4];\n            m[vtoi(C2[i][r])] += 1;\n        }\n    }\n\n    int ans = 0;\n    mat side(4, vec(4));\n    REP(i, N){\n        REP(r, 4) m[vtoi(C2[i][r])] -= 1;\n        FOR(j, i + 1, N){\n            REP(r, 4) m[vtoi(C2[j][r])] -= 1;\n\n            REP(r, 4){\n                int tmp = 1;\n                REP(s, 4){\n                    side[s][0] = C2[i][0][(4 - s) % 4];\n                    side[s][1] = C2[i][0][3 - s];\n                    side[s][2] = C2[j][r][(1 + s) % 4];\n                    side[s][3] = C2[j][r][s];\n                }\n                REP(s, 4){\n                    tmp *= m[vtoi(side[s])];\n                    REP(r2, 4) m[vtoi(side[s][(0 + r2) % 4], side[s][(1 + r2) % 4], side[s][(2 + r2) % 4], side[s][(3 + r2) % 4])] -= 1;\n                }\n                REP(s, 4) REP(r2, 4) m[vtoi(side[s][(0 + r2) % 4], side[s][(1 + r2) % 4], side[s][(2 + r2) % 4], side[s][(3 + r2) % 4])] += 1;\n                ans += tmp;\n            }\n\n            //cout << i << \",\" << j << \",\" << ans << endl;\n\n            REP(r, 4) m[vtoi(C2[j][r])] += 1;\n        }\n        REP(r, 4) m[vtoi(C2[i][r])] += 1;\n    }\n    cout << ans / 3;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\n//____________________________________________\n//____________________________________________\n//__________________OOOOOOOOOOOOOOOO__________\n//_________________OO_____________OO__________\n//________________O_O____________O_O__________\n//_______________O__O___________O__O__________\n//______________O___O__________O___O__________\n//_____________O____O_________O____O__________\n//____________OOOOOOOOOOOOOOOO_____O__________\n//____________O_____O________O_____O__________\n//____________O_____OOOOOOOOOOOOOOOO__________\n//____________O____O_________O____O___________\n//____________O___O__________O___O____________\n//____________O__O___________O__O_____________\n//____________O_O____________O_O______________\n//____________OO_____________OO_______________\n//____________OOOOOOOOOOOOOOOO________________\n//____________________________________________\n//____________________________________________\n\nconst long long MOD = 1e9 + 7;\nll n;\nll c[500][4];\nll ans;\nmap<vector<int>, int> g;\nmap<vector<int>, int> cubes;\n\nvector<int> reform(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 4; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 4; j++)\n        {\n            x.push_back(c[(i + j) % 4]);\n        }\n        cc.push_back(x);\n    }\n    sort(cc.begin(), cc.end());\n    return *min_element(cc.begin(), cc.end());\n}\n\nvector<int> cube(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 8; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 8; j++)\n        {\n            x.push_back(c[(i + j) % 8]);\n        }\n        cc.push_back(x);\n    }\n    return *min_element(cc.begin(), cc.end());\n}\n\nll cnk(ll k, ll n)\n{\n    if (k > n)\n        return 0;\n    if (k == 0)\n        return 1;\n    if (k == 1)\n        return n;\n    if (k == 2)\n        return n * (n - 1) / 2;\n    if (k == 3)\n        return n * (n - 1) * (n - 2) / 6;\n    if (k == 4)\n        return n * (n - 1) * (n - 2) * (n - 3) / 24;\n}\n\nsigned main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            for (int o1 = 0; o1 < 4; o1++)\n            {\n                //     c[j][1] ---- c[j][0]\n                //       /|            /|\n                //      / |           / |\n                //     /  c[j][2]    /  c[j][3]\n                // c[i][o1] ---- c[i][o1 + 1]\n                //    | /            |\n                //    |/             |\n                // c[i][o1 + 3] ---- c[i][o1 + 2]\n                vector<int> f = reform({c[i][0], c[i][1], c[i][2], c[i][3]});\n                vector<int> b = reform({c[j][0], c[j][1], c[j][2], c[j][3]});\n                g[f]--;\n                g[b]--;\n                int ful = c[i][o1];\n                int fur = c[i][(o1 + 1) % 4];\n                int fdl = c[i][(o1 + 3) % 4];\n                int fdr = c[i][(o1 + 2) % 4];\n\n                int bul = c[j][1];\n                int bur = c[j][0];\n                int bdl = c[j][2];\n                int bdr = c[j][3];\n\n                //vector<int> cuber = cube({ful, fur, fdr, fdl, bdl, bdr, bur, bul});\n                //if (cubes[cuber] == 1)\n                //    continue;\n                //cubes[cuber] = 1;\n\n                vector<int> l = {ful, fdl, bdl, bul};\n                vector<int> u = {fur, ful, bul, bur};\n                vector<int> r = {fur, bur, bdr, fdr};\n                vector<int> d = {fdl, fdr, bdr, bdl};\n\n                ll swappers = 1;\n\n                ll y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (l[y] != l[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (d[y] != d[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (u[y] != u[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (r[y] != r[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                r = reform(r);\n                l = reform(l);\n                u = reform(u);\n                d = reform(d);\n\n                map<vector<int>, int> gg2;\n                gg2[r]++;\n                gg2[l]++;\n                gg2[u]++;\n                gg2[d]++;\n\n                for (auto it : gg2)\n                {\n                    swappers *= cnk(it.second, g[it.first]);\n                }\n\n                //cout << i << \" \" << j << \" \" << swappers << endl;\n\n                ans += swappers;\n                g[f]++;\n                g[b]++;\n            }\n        }\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]--;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=4e5;\nint n;\nint c[maxn][4];\nll val[maxn],ans;\nvoid rot(int *c){\n\tper(i,3,1)swap(c[i],c[(i+1)%4]);\n}\nll getv(int *c){\n\tll res=0;\n\trep(i,0,3)res=1000*res+c[i];\n\treturn res;\n}\nll get(int *c){\n\tll res=getv(c);\n\trot(c);res=min(res,getv(c));\n\trot(c);res=min(res,getv(c));\n\trot(c);res=min(res,getv(c));\n\treturn res;\n}\nint main(){\n\tread(n);\n\trep(i,1,n)rep(j,0,3)read(c[i][j]);\n\trep(i,1,n)val[i]=get(c[i]);\n\trep(i,1,n)rep(j,i+1,n){\n\t\trep(k,0,3){\n\t\t\tll res=1;\n\t\t\trot(c[j]);\n\t\t\tll v[4];\n\t\t\trep(l,0,3){\n\t\t\t\tint now[4];\n\t\t\t\tnow[0]=c[j][(5-l)%4];\n\t\t\t\tnow[1]=c[j][(4-l)%4];\n\t\t\t\tnow[2]=c[i][(l+1)%4];\n\t\t\t\tnow[3]=c[i][l];\n\t\t\t\tv[l]=get(now);\n\t\t\t\tint t=0,cnt=0;\n\t\t\t\tt+=(getv(now)==v[l]);\n\t\t\t\trot(now);t+=(getv(now)==v[l]);\n\t\t\t\trot(now);t+=(getv(now)==v[l]);\n\t\t\t\trot(now);t+=(getv(now)==v[l]);\n\t\t\t\trep(p,i+1,n)if(p!=j&&val[p]==v[l])cnt++;\n\t\t\t\trep(ll,0,l-1)if(v[ll]==v[l])cnt--;\n\t\t\t\tif(cnt<=0){\n\t\t\t\t\tres=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres*=t*cnt;\n\t\t\t}\n\t\t\tans+=res;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N*4];\nint pa[4]={1,0,3,2};\n\nint main(){\n\tscanf(\"%d\",&N);\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tT[i*4]=TILE(a,b,c,d,i);\n\t\tFOR(j,1,4){\n\t\t\tT[i*4+j]=rotate(T[i*4],j);\n\t\t}\n\t}\n\tsort(T,T+N*4);\n\tll ans=0;\n\tTILE TI[6];\n\tint cnt[4];\n\tint cnt2[4][4];\n\tREP(i,N*4){\n\t\tTI[0]=T[i];\n\t\tREP(j,N*4){\n\t\t\tif (TI[0].index>=T[j].index) continue;\n\t\t\tTI[1]=T[j];\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tREP(k,4){\n\t\t\t\tTI[k+2]=TILE(TI[0].c[(k+1)%4],TI[0].c[k],TI[1].c[pa[k]],TI[1].c[pa[(k+1)%4]],0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcnt[k]=upper_bound(T,T+N*4,TI[k+2])-lower_bound(T,T+N*4,TI[k+2]);\n\t\t\t\tREP(a,2){\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a],b)){\n\t\t\t\t\t\t\tcnt[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tFOR(a,k+1,4){\n\t\t\t\t\tcnt2[k][a]=0;\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a+2],b)){\n\t\t\t\t\t\t\tcnt2[k][a]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tll temp=1;\n\t\t\tREP(k,4){\n\t\t\t\tREP(a,k){\n\t\t\t\t\tcnt[k]-=cnt2[a][k];\n\t\t\t\t}\n\t\t\t\tif (cnt[k]<0){\n\t\t\t\t\tf=true;\n\t\t\t\t}else{\n\t\t\t\t\ttemp*=cnt[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f){\n\t\t\t\tans+=temp;\n\t\t\t}\n\t\t}\n\t}\n\tans/=12;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nll rot(ll c, int r){\n    ll p[4];\n    FORR(i,3,0){\n        p[i] = c % 1000;\n        c /= 1000;\n    }\n    ll ret = 0;\n    REP(i,4){\n        ret = 1000 * ret + p[(i+r)%4];\n    }\n    return ret;\n}\n\nll col(ll c, int x){\n    REP(i,3-x) c /= 1000;\n    return c % 1000;\n}\n\nll make(ll a, ll b, ll c, ll d){\n    return 1000000000LL * a + 1000000 * b + 1000 * c + d;\n}\n\nll calc(VVL c){\n    return 0;\n    int n = c.size();\n    VVL dp(n+1, VL(16));\n    dp[0][0] = 1;\n    REP(i,n) REP(mask,16){\n        dp[i+1][mask] += dp[i][mask];\n        REP(j,4){\n            if ((mask >> j) & 1) continue;\n            dp[i+1][mask | (1 << j)] += dp[i][mask] * c[i][j];\n        }\n    }\n\n    // REP(i,n){\n    //     REP(j,4) cout << c[i][j] << \" \";\n    //     cout<< endl;\n    // }\n\n    // REP(i,n+1){\n    //     REP(j,16) cout << dp[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n\n    return dp[n][15];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    VL c(n);\n    REP(i,n){\n        REP(j,4){\n            ll x;\n            cin >> x;\n            c[i] = 1000 * c[i] + x;\n        }\n    }\n\n    ll ans = 0;\n    REP(i,n) REP(j,i) REP(r,4){\n        ll c1 = c[i], c2 = rot(c[j], r);\n        ll cs[4];\n        cs[0] = make(col(c1,1), col(c1,0), col(c2,1), col(c2,0));\n        cs[1] = make(col(c1,2), col(c1,1), col(c2,0), col(c2,3));\n        cs[2] = make(col(c1,3), col(c1,2), col(c2,3), col(c2,2));\n        cs[3] = make(col(c1,0), col(c1,3), col(c2,2), col(c2,1));\n\n        VVL cnt;\n        REP(k,n){\n            if (k == i || k == j) continue;\n            VL tmp(4);\n            bool zero = true;\n            REP(x,4) REP(y,4){\n                if (rot(c[k], y) == cs[x]){\n                    tmp[x]++;\n                    zero = false;\n                }\n            }\n            if (!zero) cnt.push_back(tmp);\n        }\n\n        ans += calc(cnt);\n    }\n    cout << ans / 3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define f first\n#define s second\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%I64d\",&x)\n#define CLR(x)  memset(x,0,sizeof(x))\n#define RESET(x,a) memset(x,a,sizeof(x))\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<\">value (\"<<#x<<\") : \"<<x<<endl;\n#define F(j,k) if ( !((j>>k)&1) && b[i]==c[k][0] ) dp[j|(1<<k)]+=rc[k]*dp[j]\n\nconst int N=405;\nint a[N][4]; //tile\nll val[N];   //hash of tile\nint p[4];\nint sym[4];\nll g[4];\nll ans[16];\nint n;\n\ninline ll h(int p[4],int k)\n{\n    ll res=0LL;\n    for(int i=k;i<4;i++)\n        res = res<<10LL | (ll)p[i];\n    for(int i=0;i<k;i++)\n        res = res<<10LL | (ll)p[i];\n    return res;\n}\n\nll normalise(int p[4])\n{\n    return min(h(p,0),min(h(p,1),min(h(p,2),h(p,3))));\n}\n\nll way(int x, int y, int r)\n{\n    int i,j,k,b[4];\n    for(i=0;i<4;i++)\n        b[i]=a[y][ (i+r)%4 ];\n    ll e,f,c,d;\n    sym[0]=sym[1]=sym[2]=sym[3]=1;\n    p[0]=b[1];   p[1]=b[0];\n    p[2]=a[x][1];   p[3]=a[x][0];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[0]=4;\n    else if(e==c)sym[0]=2;\n    g[0]=min(e,min(f,min(c,d)));\n\n    p[0]=b[0];   p[1]=b[3];\n    p[2]=a[x][2];   p[3]=a[x][1];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[1]=4;\n    else if(e==c)sym[1]=2;\n    g[1]=min(e,min(f,min(c,d)));\n\n    p[0]=b[2];   p[1]=b[1];\n    p[2]=a[x][0];   p[3]=a[x][3];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[2]=4;\n    else if(e==c)sym[2]=2;\n    g[2]=min(e,min(f,min(c,d)));\n\n    p[0]=b[3];   p[1]=b[2];\n    p[2]=a[x][3];   p[3]=a[x][2];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[3]=4;\n    else if(e==c)sym[3]=2;\n    g[3]=min(e,min(f,min(c,d)));\n\n    CLR(ans);\n    ans[0]=1;\n    for(i=x+1;i<n;i++)\n    {\n        if(i==y)continue;\n        F(14,0); F(14,1); F(14,2); F(14,3);\n        F(13,0); F(13,1); F(13,2); F(13,3);\n        F(12,0); F(12,1); F(12,2); F(12,3);\n        F(11,0); F(11,1); F(11,2); F(11,3);\n        F(10,0); F(10,1); F(10,2); F(10,3);\n        F(9,0); F(9,1); F(9,2); F(9,3);\n        F(8,0); F(8,1); F(8,2); F(8,3);\n        F(7,0); F(7,1); F(7,2); F(7,3);\n        F(6,0); F(6,1); F(6,2); F(6,3);\n        F(5,0); F(5,1); F(5,2); F(5,3);\n        F(4,0); F(4,1); F(4,2); F(4,3);\n        F(3,0); F(3,1); F(3,2); F(3,3);\n        F(2,0); F(2,1); F(2,2); F(2,3);\n        F(1,0); F(1,1); F(1,2); F(1,3);\n        F(0,0); F(0,1); F(0,2); F(0,3);\n//        for(j=14;j>=0;j--)\n//        {\n//            for(k=0;k<4;k++)\n//            {\n//                if(j&(1<<k))continue;\n//                if(val[i]==g[k])\n//                    ans[j|(1<<k)] += sym[k]*ans[j];\n//            }\n//        }\n    }\n    return ans[15];\n}\n\nint main()\n{\n    int i,j,k;\n    si(n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<4;j++)\n            si(a[i][j]);\n        val[i] = normalise(a[i]);\n    }\n    ll ans=0LL;\n    for(i=0;i<n;i++)\n        for(j=i+1;j<n;j++)\n            for(k=0;k<4;k++)\n                ans+=way(i,j,k);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t#if 1\n\tint n; cin >> n;\n\tvector<vi> c(n, vi(4));\n\trep(i, n) rep(j, 4) cin >> c[i][j];\n\t#else\n\tint n = 400;\n\tvector<vi> c(n, vi(4));\n\t//673205187207168000\n\t#endif\n\tll ans = 0;\n\tmap<vi, int> cnt;\n\tauto norm = [](const vi &v){\n\t\tvector<vi> u;\n\t\trep(j, 4){\n\t\t\tu.pb({v[j], v[(j + 1) % 4], v[(j + 2) % 4], v[(j + 3) % 4]});\n\t\t}\n\t\treturn *min_element(all(u));\n\t};\n\tauto count = [](const vi &v){\n\t\tvector<vi> u;\n\t\trep(j, 4){\n\t\t\tu.pb({v[j], v[(j + 1) % 4], v[(j + 2) % 4], v[(j + 3) % 4]});\n\t\t}\n\t\tif(u[0] == u[1]) return 4;\n\t\tif(u[0] == u[2]) return 2;\n\t\treturn 1;\n\t};\n\trep(i, n) ++cnt[c[i] = norm(c[i])];\n\t\n\t\n\trep(i, n){\n\t\t--cnt[c[i]];\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t--cnt[c[j]];\n\t\t\trep(k, 4){\n\t\t\t\tconst vi col = {c[i][0], c[i][1], c[i][2], c[i][3],\n\t\t\t\t\tc[j][(k + 3) % 4], c[j][(k + 2) % 4], c[j][(k + 1) % 4], c[j][k]};\n\t\t\t\tvector<vi> cs = {{0, 4, 5, 1}, {1, 5, 6, 2}, {3, 2, 6, 7}, {0, 3, 7, 4}};\n\t\t\t\tfor(auto &v : cs){\n\t\t\t\t\tfor(int &p : v) p = col[p];\n\t\t\t\t\tv = norm(v);\n\t\t\t\t}\n\t\t\t\tsort(all(cs));\n\t\t\t\t\n\t\t\t\tll x = cnt.count(cs[0]) ? cnt[cs[0]] : 0;\n\t\t\t\tll y = cnt.count(cs[1]) ? cnt[cs[1]] : 0;\n\t\t\t\tll z = cnt.count(cs[2]) ? cnt[cs[2]] : 0;\n\t\t\t\tll w = cnt.count(cs[3]) ? cnt[cs[3]] : 0;\n\t\t\t\tint rot = count(cs[0]) * count(cs[1]) * count(cs[2]) * count(cs[3]);\n\t\t\t\t/*\n\t\t\t\tif(x * y * z * w){\n\t\t\t\t\tdbg(i, j, k);\n\t\t\t\t\tdbg(x, y, z, w, rot);\n\t\t\t\t\trep(ii, 4) dbg(ii, cs[ii]);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(cs[0] == cs[3]){\n\t\t\t\t\tans += x * (x - 1) * (x - 2) * (x - 3) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[2]){\n\t\t\t\t\tans += x * (x - 1) * (x - 2) * w * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[1] == cs[3]){\n\t\t\t\t\tans += x * y * (y - 1) * (y - 2) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[1] && cs[2] == cs[3]){\n\t\t\t\t\tans += x * (x - 1) * z * (z - 1) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[1]){\n\t\t\t\t\tans += x * (x - 1) * z * w * rot;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += x * y * z * w * rot;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++cnt[c[j]];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nmap<LL,int> f;\nint c[405][4];\nLL a[405];\nLL Ch(LL x0,int x1,int x2,int x3){\n\treturn x0<<30|x1<<20|x2<<10|x3;\n}\nvoid add(LL x,int v){\n\tfor (int i=0;i<4;i++){\n\t\tx=(x>>10)+((x&1023)<<30);\n\t\tf[x]+=v;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&c[i][j]),a[i]=a[i]<<10|c[i][j];\n\t\tadd(a[i],1);\n\t}\n\tLL ans=0;\n\tfor (int i=1;i<=n-5;i++){\n\t\tadd(a[i],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tadd(a[j],-1);\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tLL A[4];\n\t\t\t\tA[0]=Ch(c[i][0],c[j][k],c[j][(k+3)&3],c[i][1]);\n\t\t\t\tA[1]=Ch(c[i][1],c[j][(k+3)&3],c[j][(k+2)&3],c[i][2]);\n\t\t\t\tA[2]=Ch(c[i][2],c[j][(k+2)&3],c[j][(k+1)&3],c[i][3]);\n\t\t\t\tA[3]=Ch(c[i][3],c[j][(k+1)&3],c[j][k],c[i][0]);\n\t\t\t\tif (!f[A[0]]||!f[A[1]]||!f[A[2]]||!f[A[3]]) continue;\n\t\t\t\tLL cnt=1;\n\t\t\t\tfor (int l=0;l<4;l++) cnt*=f[A[l]],add(A[l],-1);\n\t\t\t\tfor (int l=0;l<4;l++) add(A[l],1);\n\t\t\t\tans+=cnt;\n\t\t\t}\n\t\t\tadd(a[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint b[510][4];\nstruct wolf{\n\tint a[4];\n\twolf(){}\n};\ninline bool operator==(const wolf &a,const wolf &b){\n\tfor(int i=0;i<4;i++)if(a.a[i]!=b.a[i])return false;\n\treturn true;\n}\ninline bool operator<(const wolf &a,const wolf &b){\n\tfor(int i=0;i<4;i++){\n\t\tif(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t}\n\treturn false;\n}\nwolf p[510];\nint q[8];\nint g[4][4]={\n{0,4,6,1},\n{1,6,7,2},\n{2,7,5,3},\n{4,0,3,5},\n};\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<4;j++)scanf(\"%d\",&b[i][j]);\n\t\t\n\t\tfor(int j=0;j<4;j++)p[i].a[j]=b[i][j];\n\t\tfor(int j=1;j<4;j++){\n\t\t\twolf tmp;\n\t\t\tfor(int k=0;k<4;k++)tmp.a[k]=b[i][(j+k)%4];\n\t\t\tp[i]=min(p[i],tmp);\n\t\t}\n\t}\n\tstd::sort(p,p+a);\n//\tfor(int i=0;i<a;i++)printf(\"%d %d %d %d\\n\",p[i].a[0],p[i].a[1],p[i].a[2],p[i].a[3]);\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tq[l]=p[i].a[(l+k/4)%4];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tq[4]=p[j].a[(k+1)%4];\n\t\t\t\tq[5]=p[j].a[(k+2)%4];\n\t\t\t\tq[6]=p[j].a[(k)%4];\n\t\t\t\tq[7]=p[j].a[(k+3)%4];\n\t\t\t\t\n\t\t\t\tmap<wolf,int> M;\n\t\t\t\tM[p[i]]=1;\n\t\t\t\tif(M.count(p[j]))M[p[j]]++;\n\t\t\t\telse M[p[j]]=1;\n\t\t\t\tlong long ks=1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\twolf tmp;\n\t\t\t\t\twolf res;\n\t\t\t\t\tres.a[0]=q[g[l][0]];\n\t\t\t\t\tres.a[1]=q[g[l][1]];\n\t\t\t\t\tres.a[2]=q[g[l][2]];\n\t\t\t\t\tres.a[3]=q[g[l][3]];\n\t\t\t\t\tfor(int m=1;m<4;m++){\n\t\t\t\t\t\tfor(int n=0;n<4;n++)tmp.a[n]=q[g[l][(m+n)%4]];\n\t\t\t\t\t\tres=min(res,tmp);\n\t\t\t\t\t}\n\t\t\t\t\tint sz=0;\n\t\t\t\t\tfor(int m=0;m<a;m++)if(res==p[m])sz++;\n\t\t\t\t\tif(sz==0){ks=0;break;}\n\t\t\t//\t\tprintf(\"%d %d %d %d\\n\",res.a[0],res.a[1],res.a[2],res.a[3]);\n\t\t\t\t\tif(M.count(res)){\n\t\t\t\t\t\tsz-=M[res];\n\t\t\t\t\t\tif(sz==0){ks=0;break;}\n\t\t\t\t\t\tM[res]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tM[res]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(res.a[0]==res.a[1]&&res.a[0]==res.a[2]&&res.a[0]==res.a[3])sz*=4;\n\t\t\t\t\telse if(res.a[0]==res.a[2]&&res.a[1]==res.a[3])sz*=2;\n\t\t\t\t\tks*=sz;\n\t\t\t\t}\n\t\t\t\tret+=ks;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tret/=3;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nll color[408][4];\nll has(ll a[])\n{\n\tll res=0;\n\tfor(ll i=N-1;i>=0;i--) res=res*1008ll+(ll)a[i];\n\treturn res;\n}\nvector<ll> _rotate(ll c[])\n{\n\tvector<ll> res;\n\tfor(ll i=0;i<N;i++) \n\t{\n\t\tll a[4];for(ll j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nll same(ll x,ll y)\n{\n\tll a[N],c[N];ll sum=0;\n\tfor(ll i=0;i<N;i++) a[i]=x%1008,x/=1008;\n\tfor(ll i=0;i<N;i++) \n\t{\n\t\tfor(ll j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(ll x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(ll i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(ll c1[],ll c2[])\n{\n\tll p=has(c2);\n\tll a[4];ll ck[4];\n\tfor(ll i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(ll i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(ll j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t\tcnt*=(ll)m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint main()\n{\n\tll n;cin>>n;\n\tfor(ll i=1;i<=n;i++) for(ll j=0;j<N;j++) cin>>color[i][j];\n\tfor(ll i=n;i>=1;i--)\n\t{\n\t\tfor(ll j=i+1;j<=n;j++)\n\t\t{\n\t\t\tll a[N],b[N];for(ll k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(ll k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tll c[4];\n\t\t\t//\tc[0]=color[j][0],c[1]=color[j][3],c[2]=color[j][2],c[3]=color[j][1];\n\t\t\t\tfor(ll l=0;l<N;l++)\n\t\t\t\t\ta[l]=color[j][(l+k)%N];\n\t\t\t\tans+=operate(b,a);\n\t\t\t}\n\t\t}\n\t\tswap(color[i][1],color[i][3]);\n\t\tins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<ll,ii> iii;\ntypedef vector<short> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<vi,short> todo;\nvector<vi> vper;\nvi move(vi &nuevo,short delta)\n{\n    vi ans;\n    forr(i,0,4)\n    {\n        ans.pb(nuevo[(i+delta)%4]);\n    }\n    return ans;\n}\nvoid permutar(vi &nuevo)\n{\n    vper.clear();\n    forr(i,0,4)\n    vper.pb(move(nuevo,i));\n\n}\nvoid add(vi &nuevo,short delta,map<vi,short> &mapa)\n{\n    permutar(nuevo);\n    forr(i,0,vper.size())\n    {\n        mapa[vper[i]]+=delta;\n    }\n}\nvector<vi> vcaras;\nvoid gocaras(vi &v1,vi& v2)\n{\n        vcaras.clear();\n    vi auxcara(4,0);\n    auxcara[0]=v1[0],auxcara[3]=v1[1],auxcara[1]=v2[0],auxcara[2]=v2[3];vcaras.pb(auxcara);\n    auxcara[0]=v1[1],auxcara[3]=v1[2],auxcara[1]=v2[3],auxcara[2]=v2[2];vcaras.pb(auxcara);\n    auxcara[0]=v1[2],auxcara[3]=v1[3],auxcara[1]=v2[2],auxcara[2]=v2[1];vcaras.pb(auxcara);\n    auxcara[0]=v1[0],auxcara[3]=v2[0],auxcara[1]=v1[3],auxcara[2]=v2[1];vcaras.pb(auxcara);\n\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   short n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   permutar(V[2]);\n   map<vi,short> extra;\n   ll totp,answer=0,auxp;\n   //return 0;\n   forr(i,0,n)\n   {\n        forr(j,0,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    cara1=move(V[i],ki);\n                    cara2=move(V[j],kj);\n                    /*<<\"comenzamos\\n\";\n                    prshort(cara1);\n                    prshort(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prshort(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxp);\n                        add(vcaras[l],1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //<<answer<<endl;\n   cout<<answer/24<<\"\\n\";\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  unordered_set<Int> used_f;\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n    if(used_f.count(b[i])) continue;\n    \n    for(Int j=i;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;      \n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n\n      if(cnt[b[j]]==0){\n\tadd(b[i],1);\n\tcontinue;\n      }\n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n    \n    Int v=b[i];\n    for(Int j=0;j<4;j++){\n      v=((v&1023)<<30)|(v>>10);\n      used_f.emplace(v);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MAXN 405\nusing namespace std;\n\nint n;\nint color[MAXN][4];\nlong long dp[MAXN][16], sol;\nint can2[MAXN][4];\nbool can[MAXN][4][MAXN][4];\n\nint nxt(int c) {\n    if(++c == 4) c = 0;\n    return c;\n}\n\nint prv(int c) {\n    if(c == 0) c = 4;\n    return c - 1;\n}\n\nint fmod(int x, int mod) {\n    x %= mod;\n    if(x < 0) x += mod;\n    return x;\n}\n\nint main() {\n\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        for(int c = 0; c < 4; ++c) {\n            scanf(\"%d\", &color[i][c]);\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int ci = 0; ci < 4; ++ci) {\n            for(int j = i + 1; j <= n; ++j) {\n                for(int cj = 0; cj < 4; ++cj) {\n                    can[i][ci][j][cj] = can[j][cj][i][ci] = (color[i][ci] == color[j][nxt(cj)] && color[i][nxt(ci)] == color[j][cj]);\n                }\n            }\n        }\n    }\n\n    for(int i = 1; i <= n - 5; ++i) {\n        for(int j = i + 1; j <= n; ++j) {\n            for(int cj = 0; cj < 4; ++cj) {\n                for(int k = i + 1; k <= n; ++k) {\n                    if(k == j) continue;\n                    for(int face = 0; face < 4; ++face) {\n                        can2[k][face] = 0;\n                        for(int d = 0; d < 4; ++d) {\n                            can2[k][face] += (can[i][face][k][d] && can[k][(d + 2) % 4][j][fmod(cj - face, 4)]);\n                        }\n                    }\n                }\n\n                for(int ii = 1; ii < 16; ++ii)\n                    dp[i][ii] = 0;\n                dp[i][0] = 1;\n\n                for(int k = i + 1; k <= n; ++k) {\n                    for(int mask = 0; mask < 16; ++mask) {\n                        dp[k][mask] = dp[k - 1][mask];\n                        \n                        if(k == j) continue;\n\n                        for(int bit = 0; bit < 4; ++bit) {\n                            if(mask & (1 << bit)) {\n                                dp[k][mask] += can2[k][bit] * dp[k - 1][mask & ~(1 << bit)];\n                            }\n                        }\n                    }\n                }\n\n                // printf(\"(%d, 0) -> (%d, %d) => %lld\\n\", i, j, cj, dp[n][15]);\n\n                sol += dp[n][15];\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", sol);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> rotate(vector<int>& vec, int i) {\n  vector<int> ret = {vec[(0+i)%4], vec[(1+i)%4], vec[(2+i)%4], vec[(3+i)%4]};\n  return ret;\n}\n\nvector<int> getfirst(vector<int>& v) {\n  vector<vector<int>> ret(4, vector<int>(4));\n  rep(p, 4) {\n    ret[p] = rotate(v, p);\n  }\n  sort(ret.begin(), ret.end());\n  return ret[0];\n}\n\nint getdup(const vector<int>& vec) {\n  if (vec[0] == vec[1] && vec[1] == vec[2] && vec[2] == vec[3]) {\n    return 4;\n  } else if (vec[0] == vec[2] && vec[1] == vec[3]) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<vector<int>> tiles(n, vector<int>(4));\n  map<vector<int>, int> mp, mp2;\n  rep(i, n) {\n    int a, b, c, d; cin >> a >> b >> c >> d;\n    tiles[i] = {a, b, c, d};\n    tiles[i] = getfirst(tiles[i]);\n    mp[tiles[i]]++;\n  }\n\n  ll ans = 0;\n  rep(i, n-5) {\n    vector<int> ti = tiles[i];\n    mp[ti]--;\n    for(int j=i+1; j<n; j++) {\n      mp[tiles[j]]--;\n      rep(k, 4) {\n        vector<int> tj = rotate(tiles[j], k);\n        vector<vector<int>> dice(4, vector<int>(4));\n        dice[0] = {ti[0], tj[1], tj[0], ti[1]};\n        dice[1] = {ti[1], tj[0], tj[3], ti[2]};\n        dice[2] = {ti[2], tj[3], tj[2], ti[3]};\n        dice[3] = {ti[3], tj[2], tj[1], ti[0]};\n        rep(l, 4) {\n          mp2[getfirst(dice[l])]++;\n        }\n        ll now = 1;\n        for(auto& e: mp2) {\n          int cnt = mp[e.first];\n          int num = e.second;\n          int dup = getdup(e.first);\n          for(int p=1; p<=num; p++) {\n            now *= cnt*dup;\n            cnt--;\n          }\n        }\n        mp2.clear();\n        ans += now;\n      }\n      mp[tiles[j]]++;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define MN 1600\nstruct P{int a,b,c,d;}p[MN+5];\nll z[MN+5];int s[MN+5],zn;\ninline ll cal(const P&p){return 1LL*p.a*int(1e9)+p.b*int(1e6)+p.c*int(1e3)+p.d;}\ninline int&find(const P&p)\n{\n\tll x=cal(p),t;\n\tt=lower_bound(z+1,z+zn+1,x)-z;\n\treturn z[t]==x?s[t]:s[0];\n}\ninline void inc(P p,int x)\n{\n\tfind((P){p.a,p.b,p.c,p.d})+=x;\n\tfind((P){p.d,p.a,p.b,p.c})+=x;\n\tfind((P){p.c,p.d,p.a,p.b})+=x;\n\tfind((P){p.b,p.c,p.d,p.a})+=x;\n}\nint main()\n{\n\tint n,i,j;long long ss,ans=0;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&p[i].a,&p[i].b,&p[i].c,&p[i].d);\n\t\tp[i+n]=(P){p[i].d,p[i].a,p[i].b,p[i].c};\n\t\tp[i+2*n]=(P){p[i].c,p[i].d,p[i].a,p[i].b};\n\t\tp[i+3*n]=(P){p[i].b,p[i].c,p[i].d,p[i].a};\n\t}\n\tfor(i=1;i<=4*n;++i)z[i]=cal(p[i]);\n\tsort(z+1,z+4*n+1);zn=unique(z+1,z+4*n+1)-z-1;\n\tfor(i=1;i<=n;++i)inc(p[i],1);\n\tfor(i=1;i<=4*n;++i)for(j=i;j<=4*n;++j)if(i%n!=j%n)\n\t{\n\t\tinc(p[i],-1);inc(p[j],-1);\n\t\tP A=(P){p[j].b,p[i].a,p[i].d,p[j].c},\n\t\t  B=(P){p[j].b,p[j].a,p[i].b,p[i].a},\n\t\t  C=(P){p[i].b,p[j].a,p[j].d,p[i].c},\n\t\t  D=(P){p[j].d,p[j].c,p[i].d,p[i].c};\n\t\tss=find(A);inc(A,-1);ss*=find(B);inc(B,-1);ss*=find(C);inc(C,-1);ans+=ss*find(D);\n\t\tinc(A,1);inc(B,1);inc(C,1);inc(p[i],1);inc(p[j],1);\n\t}\n\tprintf(\"%lld\",ans/12);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nlong get(long a,int k){return k==1?a%1000:k==2?a/1000%1000:k==3?a/1000000%1000:a/1000000000;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nlong C[400];\nmap<long,array<array<array<long,5>,5>,4> >M;\nmap<long,map<int,int> >Q;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\tC[i]=conv(a,b,c,d);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C[i]]++;\n\t\t\tC[i]=rotate(C[i]);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<array<long,5>,5>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<5;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tif(j<k)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<5;i++)A[i][j][k]=A[i][k][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA[0][j][k]=sum-j-k;\n\t\t\t\tA[1][j][k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\t\tA[2][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t\t-(sum-j-k-ct[2])*ct[2]*6\n\t\t\t\t\t-(sum-j-k-ct[3])*ct[3]*3*6-ct[3]*6\n\t\t\t\t\t-(sum-j-k-ct[4])*ct[4]*6*6-ct[4]*24;\n\t\t\t\tA[3][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t\t-(sum-j-k-ct[2])*(sum-j-k-ct[2]-1)/2*ct[2]*24\n\t\t\t\t\t-(sum-j-k-ct[3])*(sum-j-k-ct[3]-1)/2*ct[3]*3*24-(sum-j-k-ct[3])*ct[3]*24\n\t\t\t\t\t-(sum-j-k-ct[4])*(sum-j-k-ct[4]-1)/2*ct[4]*6*24-(sum-j-k-ct[4])*ct[4]*4*24-ct[4]*24\n\t\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\t}\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong a=C[i];\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tlong b=C[j];\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tb=rotate(b);\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(get(a,3),get(a,4),get(b,3),get(b,4)),\n\t\t\t\t\tconv(get(a,4),get(a,1),get(b,2),get(b,3)),\n\t\t\t\t\tconv(get(a,1),get(a,2),get(b,1),get(b,2)),\n\t\t\t\t\tconv(get(a,2),get(a,3),get(b,4),get(b,1)),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][Q[t[k]][i]][Q[t[k]][j]];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n \ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nint n;\nvector<int> c[400];\nll chash[400];\nint dup[400]; // 重複回数\n\ninline ll get_hash(vector<int> v) {\n\tll res = INF;\n\tREP(i, 4) {\n\t\tchmin(res, v[0] * 1000000000ll + v[1] * 1000000ll + v[2] * 1000ll + v[3]);\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tc[i].resize(4);\n\t\tREP(j, 4) scanf(\"%d\", &c[i][j]);\n\t\t\n\t\tif (c[i][0] == c[i][2] && c[i][1] == c[i][3]) {\n\t\t\tif (c[i][0] == c[i][1]) dup[i] = 4;\n\t\t\telse dup[i] = 2;\n\t\t}\n\t\telse dup[i] = 1;\n\t\t\n\t\tchash[i] = get_hash(c[i]);\n\t}\n\t\n\tmap<ll,  int> pat[5]; // 各タイルを正規化したもののそれぞれの個数\n\tREP(i, n) pat[ dup[i] ][ chash[i] ]++;\n\t\n\tll ans = 0;\n\t\n\tREP(i, n) FOR(j, i + 1, n) {\n\t\tif (i == j) continue;\n\t\t\n\t\tvector<int> v(8); // 各頂点の色\n\t\tREP(k, 4) v[k] = c[i][k];\n\t\t\n\t\tREP(p, 4) {\n\t\t\t\n\t\t\tREP(k, 4) v[k + 4] = c[j][(k + p) % 4];\n\t\t\t\n\t\t\tint dd[4][4] = { {1,0,7,6}, {0,3,4,7}, {2,1,6,5}, {3,2,5,4} };\n\t\t\t\n\t\t\tmap<ll, int> now; // 各方向から見た色の配置\n\t\t\tREP(k, 4) {\n\t\t\t\tvector<int> u(4);\n\t\t\t\tREP(l, 4) u[l] = v[dd[k][l]];\n\t\t\t\tnow[get_hash(u)]++;\n\t\t\t}\n\t\t\t\n\t\t\tll add = 1;\n\t\t\t\n\t\t\tfor (map<ll, int>::iterator it = now.begin(); it != now.end(); ++it) {\n\t\t\t\tbool ng = true;\n\t\t\t\t\n\t\t\t\tREP(k, 5) {\n\t\t\t\t\tll cnt = pat[k][it->first];\n\t\t\t\t\t\n\t\t\t\t\tif (dup[i] == k && chash[i] == it->first) cnt--;\n\t\t\t\t\tif (dup[j] == k && chash[j] == it->first) cnt--;\n\t\t\t\t\t\n\t\t\t\t\tif (cnt < it->second) continue;\n\t\t\t\t\t\n\t\t\t\t\tng = false;\n\t\t\t\t\t\n\t\t\t\t\tREP(l, it->second) {\n\t\t\t\t\t\tadd *= (cnt - l) * k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ng) { add = 0; break; }\n\t\t\t}\n\t\t\t\n\t\t\tans += add;\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\tcout << ans / 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    /*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*/\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay2(v);\n    }\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    /*tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];*/\n                    tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n;\n    cin >> n;\n    ll c[405][4];\n    ll b[405][4];\n    map<ll, ll> mp;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++) cin >> c[i][j];\n        for(int j = 0; j < 4; j++){\n            for(int k = 0; k < 4; k++){\n                b[i][j] |= (c[i][(j + k) % 4] << 10 * k);\n            }\n            mp[b[i][j]]++;\n        }\n    }\n    ll ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++){\n            mp[b[i][j]]--;\n        }\n        for(int j = i + 1; j < n; j++){\n            for(int k = 0; k < 4; k++){\n                mp[b[j][k]]--;\n            }\n            for(int k = 0; k < 4; k++){\n                vector<ll> ver(8);\n                for(int l = 0; l < 4; l++) ver[l] = c[i][l];\n                for(int l = 4; l < 8; l++) ver[l] = c[j][(7 - l + k) % 4];\n                ll s = 1;\n                for(int l = 0; l < 4; l++){\n                    vector<ll> r(4);\n                    r[0] = ver[l];\n                    r[1] = ver[(l + 3) % 4];\n                    r[2] = ver[(l + 3) % 4 + 4];\n                    r[3] = ver[l + 4];\n                    ll c = r[0] | (r[1] << 10) | (r[2] << 20) | (r[3] << 30);\n                    s *= mp[c];\n                    for(int m = 0; m < 4; m++){\n                        vector<ll> t(4);\n                        for(int p = 0; p < 4; p++) t[p] = r[(p + m) % 4];\n                        ll d = t[0] | (t[1] << 10) | (t[2] << 20) | (t[3] << 30);\n                        mp[d]--;\n                    }\n                }\n                ans += s;\n                for(int l = 0; l < 4; l++){\n                    vector<ll> r(4);\n                    r[0] = ver[l];\n                    r[1] = ver[(l + 3) % 4];\n                    r[2] = ver[(l + 3) % 4 + 4];\n                    r[3] = ver[l + 4];\n                    for(int m = 0; m < 4; m++){\n                        vector<ll> t(4);\n                        for(int p = 0; p < 4; p++) t[p] = r[(p + m) % 4];\n                        ll d = t[0] | (t[1] << 10) | (t[2] << 20) | (t[3] << 30);\n                        mp[d]++;\n                    }\n                }\n            }\n            for(int k = 0; k < 4; k++){\n                mp[b[j][k]]++;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans,c[410][4],h[410],v[4],tmp[4];\nunordered_map<ll,int>mp;\nvoid upd(ll x,int d){\n    for(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll))\n        mp[x]+=d;\n    return;\n}\nll Hash(ll *a){\n    ll ret=0;\n    for(int i=0;i<4;i++)\n        ret|=(a[i]<<(i*10ll));\n    return ret;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n        h[i]=Hash(c[i]);\n        upd(h[i],1);\n    }\n    for(int i=1;i<=n-5;i++){\n        upd(h[i],-1);\n        for(int j=i+1;j<=n;j++){\n            upd(h[j],-1);\n            for(int k=0;k<4;k++){\n                ll res=1;\n                for(int l=0;l<4;l++){\n                    ll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n                    v[l]=Hash(tmp);\n                    if(!mp.count(v[l]))\n                        goto to;\n                }\n                for(int l=0;l<4;l++){\n                    res*=mp[v[l]];\n                    upd(v[l],-1);\n                }\n                ans+=res;\n                for(int l=0;l<4;l++)\n                    upd(v[l],1);\n                to: ;\n            }\n            upd(h[j],1);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\ntypedef long long LL;\nconst int N=405,bas=1000;\nint n;LL ans,has[N],need[4];\nstruct node{int c[4];}b[N];\nmap<LL,int> mp;\n\nLL gethas(node tmp) {\n\tLL re=0;\n\tfor(RI i=0;i<=3;++i) re=1LL*bas*re+tmp.c[i];\n\treturn re;\n}\nvoid add(LL d,int num) {\n\tint kl[4];\n\tfor(RI i=3;i>=0;--i) kl[i]=d%bas,d/=bas;\n\tfor(RI i=0;i<=3;++i) {\n\t\tLL orz=0;\n\t\tfor(RI j=0;j<=3;++j) orz=1LL*bas*orz+kl[(i+j)&3];\n\t\tmp[orz]+=num;\n\t}\n}\nvoid work() {\n\tfor(RI i=1;i<=n-5;++i) {\n\t\tadd(has[i],-1);\n\t\tfor(RI j=i+1;j<=n;++j) {\n\t\t\tadd(has[j],-1);\n\t\t\tfor(RI k=0;k<4;++k) {\n\t\t\t\tLL js=1;int flag=0;\n\t\t\t\tfor(RI t=0;t<4;++t) {\n\t\t\t\t\tnode kl;\n\t\t\t\t\tkl.c[0]=b[i].c[(t+1)&3],kl.c[1]=b[i].c[t];\n\t\t\t\t\tkl.c[2]=b[j].c[(k-t+4)&3],kl.c[3]=b[j].c[(k-t+3)&3];\n\t\t\t\t\tneed[t]=gethas(kl);\n\t\t\t\t\tif(!mp[need[t]]) {flag=1;break;}\n\t\t\t\t}\n\t\t\t\tif(flag) continue;\n\t\t\t\tfor(RI t=0;t<4;++t) js*=mp[need[t]],add(need[t],-1);\n\t\t\t\tans+=js;for(RI t=0;t<4;++t) add(need[t],1);\n\t\t\t}\n\t\t\tadd(has[j],1);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tfor(RI i=1;i<=n;++i) {\n\t\tfor(RI j=0;j<=3;++j) b[i].c[j]=read();\n\t\thas[i]=gethas(b[i]),add(has[i],1);\n\t}\n\twork();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define ll long long\n#define p 9931\n#define q 937527359ll\n#define Val(x) ((((ll)x) % q + q ) % q)\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nint h[maxn];\ninline int cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tint ret = q;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tint hash = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\thash = Val(hash*p+col[(rot+i)%4]);\n\t\t\tret = min(ret,hash);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nint fac[5];\ninline ll C(int n,int m) {\n\tif(n < m)\treturn 0;\n\tll ret = 1;\n\tfor(int i=n-m+1;i<=n;i++)\n\t\tret *= i;\n\tfor(int i=1;i<=m;i++)\n\t\tret /= i;\n\treturn ret;\n}\nmap<int,pii> cnt;\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tint now_cnt = 0;\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tint hash = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\thash = Val(hash*p+col[i][(rot+j)%4]);\n\t\t\t\tif(hash == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tnow_cnt = max(now_cnt,tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t\tcnt[h[i]].first++;\n\t\tcnt[h[i]].second = now_cnt;\n\t}\n\t\n\tfac[0] = 1;\n\tfor(int i=1;i<5;i++)\n\t\tfac[i] = fac[i-1] * i;\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tcnt[h[i]].first--;\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tcnt[h[j]].first--;\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tmap<int,int> need;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k])]++;\n\t\t\t\tll now = 1;\n\t\t\t\tfor(pii x : need)\n\t\t\t\t\tnow *= C(cnt[x.first].first,x.second) * pow(cnt[x.first].second,x.second) * fac[x.second];\n\t\t\t\tans += now;\n\t\t\t}\n\t\t\tcnt[h[j]].first++;\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n//\t\tcnt[h[i]].first++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 405;\nusing namespace std;\n\nmap <long long, int> mymap;\nint n;\nlong long a[N], ans;\n\nlong long po(int x){\n    if (x == 0) return 1;\n    if (x == 1) return 1000;\n    if (x == 2) return 1000000;\n    if (x == 3) return 1000000000;\n}\n\nlong long rotate(long long x){\n    long long t = x % po(1); x /= po(1);\n    x += t * po(3);\n    return x;\n}\n\nlong long get(long long a, int num){\n    return (a / po(num)) % 1000;\n}\n\nlong long reverse(long long x){\n    long long y = get(x, 0) * po(3) + get(x, 1) * po(2) + get(x, 2) * po(1) + get(x, 3) * po(0);\n    return y;\n}\n\nint main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        int x, y, z, t;\n        cin >> x >> y >> z >> t;\n        a[i] = 1LL * x * 1000000000 + 1LL * y * 1000000 + 1LL * z * 1000 + t;\n        mymap[a[i]]++;\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j < i; j++){\n            mymap[a[i]]--; mymap[a[j]]--;\n            long long x = reverse(a[j]);\n            for (int k = 0; k < 4; k++){\n                long long cnt = 0, mul = 1;\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    int cnt = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    bool ck = 1;\n                    for (int l = 0; l < 4; l++) {\n                        if (mymap.count(color)) cnt += mymap[color];\n                        color = rotate(color);\n                    }\n                    for (int l = 0; l < 4; l++) {\n                        if (mymap.count(color)) {\n                            mymap[color]--; break;\n                        }\n                        color = rotate(color);\n                    }\n                    mul *= cnt;\n                }\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    for (int l = 0; l < 4; l++) {\n                        if (mymap.count(color)) {\n                            mymap[color]++; break;\n                        }\n                        color = rotate(color);\n                    }\n                }\n                ans += mul;\n                x = rotate(x);\n            }\n            mymap[a[i]]++; mymap[a[j]]++;\n        }\n    }\n    ans /= 3;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile a, tile b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) return a.color[i] < b.color[i];\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) tmp.color[i] = t.color[i];\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    for (int j = 0; j < 4; ++j) tmp.color[j] = comp.color[j];\n  }\n}\n\nbool same(tile a, tile b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= a.color[i] == b.color[i];\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) cin >> t[i].color[j];\n  }\n\n  for (int i = 0; i < N; ++i) regulation(t[i]);\n  sort(t, t+N, comp_tile);\n\n\n  ll ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) top.color[k] = t[i].color[k];\n        for (int k = 0; k < 4; ++k) bottom.color[k] = t[j].color[k];\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) tmp1.color[l] = bottom.color[l];\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) regulation(sides[l]);\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) tmp.color[n] = sides[m].color[n];\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) symmetry_count[m]++;\n              tmp = cmp;\n            }\n          }\n\n          ll tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) if (same(sides[n],sides[m])) ++x;\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= match_count[m] - x;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max<R>(x, 0.0));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\nauto normlize(vector<int> ary){\n\tvector<int> cmin = ary;\n\n\trep(j,4){\n\t\trotate(begin(ary),begin(ary)+1,end(ary));\n\t\tchmin(cmin,ary);\n\t}\n\t\n\treturn cmin;\t\n}\n\nint duplicate(vector<int> ary){\n\tint ret = 0;\n\tvector<int> cur=ary;\n\t\n\trep(j,4){\n\t\trotate(begin(cur),begin(cur)+1,end(cur));\n\t\tif(cur == ary) ret++;\n\t}\n\n\treturn ret;\t\n}\n\n\nmap<vector<int>,ll> memo;\n\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> c(n, vector<int>(4, 0));\n\n\trep(i, n){\t\n\t\trep(j, 4) cin >> c[i][j];\n\t\tc[i] = normlize(c[i]);\n\t\tmemo[c[i]]++;\n\t}\n\n\n\tll ans = 0LL;\n\n\trep(j, n)rep(i, j) {\n\t\tmemo[c[i]]--;\n\t\tmemo[c[j]]--;\n\t\t\n\t\trep(di, 4) rep(dj,4){\n\t\t\tvector<int> top = c[i];\n\t\t\tvector<int> bottom = c[j];\n\t\t\treverse(begin(bottom), end(bottom));\n\t\t\t\n\t\t\trotate(begin(top), begin(top) + di, end(top));\n\t\t\trotate(begin(bottom), begin(bottom) + dj, end(bottom));\n\n\t\t\t\n\t\t\tll cur = 1LL;\n\t\t\t\n\t\t\tmap<vector<int>,ll> tmp;\n\n\n\t\t\trep(dd,4){\n\t\t\t\tvector<int> rot = {bottom[(dd + 0) % 4], bottom[(dd + 1) % 4], top[(dd + 1) % 4], top[(dd + 0) % 4]};\n\t\t\t\trot = normlize(rot);\n\t\t\t\ttmp[rot]++;\n\t\t\t}\n\n\t\t\tfor(auto &it:tmp){\n\t\t\t\tconst ll coef = duplicate(it.first);\n\n\t\t\t\trep(k,it.second){\n\t\t\t\t\tcur *= coef;\n\t\t\t\t\tcur *= (memo[it.first]-k);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += 1LL * cur;\n\t\t}\n\n\t\tmemo[c[i]]++;\n\t\tmemo[c[j]]++;\n\t}\n\n\tcout << ans / 12LL << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define PL pair<ll,int>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 1010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n;\n\nint C[maxn][4];\n\nmap<ll,int> has;\n\nll ans=0;\n\nint tmp[maxn];\n\nll ned[4];\n\nPL calc(int *a){\n\tll f=1e18;int g=0;\n\tREP(i,0,3){\n\t\tll t=0;\n\t\tREP(j,0,3)t=t*1000+a[(i+j)&3];\n\t\tif(t<f)f=t,g=1;\n\t\telse if(t==f)g++;\n\t}\n\treturn MP(f,g);\n}\n\nvoid Work(){\n\tREP(i,1,n)\n\t\tREP(j,i+1,n){\n\t\t\thas[calc(C[i]).fi]--;has[calc(C[j]).fi]--;\n\t\t\tREP(k,0,3){\n\t\t\t\tll t=1;\n\t\t\t\tREP(l,0,3){\n\t\t\t\t\ttmp[0]=C[i][(l+1)&3];\n\t\t\t\t\ttmp[1]=C[i][l];\n\t\t\t\t\ttmp[2]=C[j][(k-l)&3];\n\t\t\t\t\ttmp[3]=C[j][(k-l-1)&3];\n\t\t\t\t\tPL res=calc(tmp);\n\t\t\t\t\tt*=res.se%mod;\n\t\t\t\t\tned[l]=res.fi;\n\t\t\t\t}\n\t\t\t\tREP(l,0,3)t*=has[ned[l]]--;\n\t\t\t\tREP(l,0,3)has[ned[l]]++;\n\t\t\t\tans+=t;\n\t\t\t}\n\t\t\thas[calc(C[i]).fi]++;has[calc(C[j]).fi]++;\n\t\t}\n\tcout<<ans/3<<endl;\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n)REP(j,0,3)read(C[i][j]);\n\tREP(i,1,n)has[calc(C[i]).fi]++;\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nconstexpr ll T[4]={1,1000,1000000,1000000000};\nll f(const ar &x,int k){\n    ll res=0;\n    rep(i,4)res+=x[i]*T[(i+k)&3];\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin>>v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i],j);\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                s[0] = f(ar{v[i][1],v[i][0],v[j][1],v[j][0]},0);\n                s[1] = f(ar{v[i][0],v[i][3],v[j][2],v[j][1]},0);\n                s[2] = f(ar{v[i][3],v[i][2],v[j][3],v[j][2]},0);\n                s[3] = f(ar{v[i][2],v[i][1],v[j][0],v[j][3]},0);\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    rep3(t,15,0){\n                        rep(tt,4){\n                            if(t&(1<<tt)){\n                                dp[t]+=dp[t^(1<<tt)]*cnt[tt];\n                            }\n                        }\n                    }\n                }\n                ans += dp[15];\n                rotate(v[j].begin(),v[j].begin()+1,v[j].end());\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#ifdef ONLINE_JUDGE\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N; cin >> N;\n    vector<array<int, 4>> C(N);\n    rep(i,N) rep(j,4) cin >> C[i][j];\n\n    array<int, 4> A,B,E;\n    vector<array<int, 4>> D;\n    vector<int> uni,cnt,kai;\n    ll ans = 0;\n    rep(i,N) {\n        rep(k,4) A[k] = C[i][k];\n        rep(j,i) {\n            rep(_,4) {//下の面の回転\n                D.clear();\n                uni.clear();\n                cnt.clear();\n                kai.clear();\n                rep(l,4) B[l] = C[j][(l+_)%4];\n\n                rep(l,4) {\n                    E[0] = A[3-l];\n                    E[1] = A[(6-l)%4];\n                    E[2] = B[(1+l)%4];\n                    E[3] = B[l];\n                    bool same = false;\n                    rep(w,SZ(D)) {\n                        rep(y,4) {\n                            bool same2 = true;\n                            rep(x,4) {\n                                if (D[w][x] != E[(x+y)%4]) same2 = false;\n                            }\n                            if (same2) {\n                                same = true;\n                                uni[w]++;\n                                break;\n                            }\n                        }\n                        if (same) break;\n                    }\n                    if (!same) {\n                        D.emplace_back(E);\n                        uni.emplace_back(1);\n                        cnt.emplace_back(0);\n                        kai.emplace_back(1);\n                    }\n                }\n\n                rep(w,SZ(D)) {\n                    if (D[w][0]==D[w][1] and D[w][1]==D[w][2] and D[w][2]==D[w][3]) kai[w] = 4;\n                    else if (D[w][0]==D[w][2] and D[w][1]==D[w][3]) kai[w] = 2;\n                }\n\n                rep(k,N) {\n                    if (k==i or k==j) continue;\n                    rep(w,SZ(D)) {\n                        rep(x,4) {\n                            bool same = true;\n                            rep(y,4) {\n                                if (D[w][y]!=C[k][(x+y)%4]) same = false;\n                            }\n                            if (same) {\n                                cnt[w]++;\n                                break;\n                            } \n                        }\n                    } \n                }\n\n                ll val = 1;\n                rep(w,SZ(D)) {\n                    ll c = cnt[w];\n                    rep(x,uni[w]) {\n                        val *= c;\n                        c--;\n                        val *= kai[w];\n                    }\n                }\n\n                ans += val;\n            }\n        }\n    }\n\n    cout << ans/3 << ln;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\npa4 rot(pa4 z){\n\treturn {z.w,z.x,z.y,z.z};\n}\nint hen(pa4 z){\n\treturn z.x+1000*z.y+1000000*z.z+1000000000*z.w;\n}\npa4 iro[400][4];\nint num[400][4];\nmap<int,int> ma[400]; \n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n  \tcin>>n;\n  \t\n  \tfor(int i=0;i<n;i++){\n  \t\tint y1,y2,y3,y4;\n  \t\tcin>>y1>>y2>>y3>>y4;\n  \t\tiro[i][0]={y1,y2,y3,y4};\n  \t\tfor(int j=1;j<4;j++)iro[i][j]=rot(iro[i][j-1]);\n  \t\tfor(int j=0;j<4;j++){\n  \t\t\tnum[i][j]=hen(iro[i][j]);\n  \t\t\tma[i][num[i][j]]++;\n  \t//\t\tcout<<i<<\" \"<<j<<\"   \"<<num[i][j]<<endl;\n  \t\t}\n  \t}\n  \t\n  \tint ans=0;\n  \tfor(int s=0;s<n;s++)for(int t=s+1;t<n;t++)for(int l=0;l<1;l++)for(int r=0;r<4;r++){\n  \t\t\n  \t\tint e[4];\n  \t\te[0]=hen({iro[s][l].x,iro[s][l].w,iro[t][r].x,iro[t][r].w});\n  \t\te[1]=hen({iro[s][l].w,iro[s][l].z,iro[t][r].y,iro[t][r].x});\n  \t\te[2]=hen({iro[s][l].z,iro[s][l].y,iro[t][r].z,iro[t][r].y});\n  \t\te[3]=hen({iro[s][l].y,iro[s][l].x,iro[t][r].w,iro[t][r].z});\n  \t\tint kosuu=0;\n  \t\t//vector<int> ve[4];\n  \t\tint rui[16]={0};\n  \t\tfor(int i=s+1;i<n;i++)if(i!=s&& i!=t){\n  \t\t\tint g[4]={0};\n  \t\t\tfor(int w=0;w<4;w++){\n  \t\t\t\tif(ma[i].count(e[w]))g[w]=ma[i][e[w]];\n  \t\t\t}\n  \t\t//\tfor(int w=0;w<4;w++)cout<<g[w];\n  \t\t//\tcout<<endl;\n  \t\t\tif(g[0]+g[1]+g[2]+g[3]==0) continue;\n  \t\t\tkosuu++;\n  \t\t\trui[15]+=g[0]*g[1]*g[2]*g[3];\n  \t\t\trui[1]+=g[0];\n  \t\t\trui[2]+=g[1];\n  \t\t\trui[4]+=g[2];\n  \t\t\trui[8]+=g[3];\n  \t\t\t\n  \t\t\trui[3]+=g[0]*g[1];\n  \t\t\trui[5]+=g[0]*g[2];\n  \t\t\trui[9]+=g[0]*g[3];\n  \t\t\trui[6]+=g[1]*g[2];\n  \t\t\trui[10]+=g[1]*g[3];\n  \t\t\trui[12]+=g[2]*g[3];\n  \t\t\t\n  \t\t\trui[14]+=g[1]*g[2]*g[3];\n  \t\t\trui[13]+=g[0]*g[2]*g[3];\n  \t\t\trui[11]+=g[0]*g[1]*g[3];\n  \t\t\trui[7]+=g[0]*g[1]*g[2];\n  \t\t\t\n  \t\t\t\n  \t\t\t\n  \t\t}\n  \t//\tif(kosuu)cout<<kosuu<<endl;\n  \t\tif(kosuu<4) continue;\n  \t\t\n  \t\t\n  \t\tint p_0123=rui[15];\n  \t\t\n  \t\tint p_01_23=rui[3]*rui[12]-p_0123;\n  \t\tint p_02_13=rui[5]*rui[10]-p_0123;\n  \t\tint p_03_12=rui[9]*rui[6]-p_0123;\n  \t\t\n  \t\tint p_0_123=rui[1]*rui[14]-p_0123;\n  \t\tint p_1_023=rui[2]*rui[13]-p_0123;\n  \t\tint p_2_013=rui[4]*rui[11]-p_0123;\n  \t\tint p_3_012=rui[8]*rui[7]-p_0123;\n  \t\t\n  \t\tint p_01_2_3=rui[3]*rui[4]*rui[8]-p_3_012-p_2_013-p_01_23-p_0123;\n  \t\tint p_02_1_3=rui[5]*rui[2]*rui[8]-p_3_012-p_1_023-p_02_13-p_0123;\n  \t\tint p_03_1_2=rui[9]*rui[2]*rui[4]-p_1_023-p_2_013-p_03_12-p_0123;\n  \t\tint p_12_0_3=rui[6]*rui[1]*rui[8]-p_3_012-p_0_123-p_03_12-p_0123;\n  \t\tint p_13_0_2=rui[10]*rui[1]*rui[4]-p_0_123-p_2_013-p_02_13-p_0123;\n  \t\tint p_23_0_1=rui[12]*rui[1]*rui[2]-p_0_123-p_1_023-p_01_23-p_0123;\n  \t\t\n  \t\tint wa=p_0123+p_01_23+p_02_13+p_03_12+p_0_123+p_1_023+p_2_013+p_3_012;\n  \t\twa+=p_01_2_3+p_02_1_3+p_03_1_2+p_12_0_3+p_13_0_2+p_23_0_1;\n  \t\t\n  \t\tint p_0_1_2_3=rui[1]*rui[2]*rui[4]*rui[8];\n  \t//\tcout<<p_0_1_2_3<<endl;\n  \t\tp_0_1_2_3-=wa;\n  \t//\tcout<<p_0_1_2_3<<endl;\n  \t\tans+=p_0_1_2_3;\n  \t\t\n  \t}\n  \t\n  \tcout<<ans<<endl;\n  \t\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nlong long k(long long a, long long b, long long c, long long d){\n  return 1000000000*a+1000000*b+1000*c+d;\n}\n\nint comp(long long x0, long long x1, long long x2, long long x3, long long y0, long long y1, long long y2, long long y3){\n  int r = 0;\n  if (x0==y0 && x1==y1 && x2==y2 && x3==y3) r++;\n  if (x0==y1 && x1==y2 && x2==y3 && x3==y0) r++;\n  if (x0==y2 && x1==y3 && x2==y0 && x3==y1) r++;\n  if (x0==y3 && x1==y0 && x2==y1 && x3==y2) r++;\n  return r;\n}\n\nint main(){\n  unordered_map<long long, long long> counter;\n  int N; cin >> N;\n  long long value;\n  long long C[N][4];\n  long long c1, res = 1, tot = 0;\n  for (int i = 0; i < N; i++){\n    for (int j = 0; j < 4; j++) cin >> C[i][j];\n    for (int l = 0; l < 4; l++){\n      value = k(C[i][l%4], C[i][(l+1)%4], C[i][(l+2)%4], C[i][(l+3)%4]);\n      if (counter.count(value) == 0) counter[value] = 1;\n      else counter[value]++;\n    }\n  }\n\n  for (int i = 0; i < N; i++){\n    for (int j = 0; j < N; j++){\n      if (i != j){\n        for (int k0 = 16; k0 < 20; k0++){\n          res = 1;\n          value = k(C[j][k0%4], C[j][(k0-1)%4], C[i][1], C[i][0]);\n          if (counter.count(value) == 0) c1 = 0;\n          else c1 = counter[value];\n          c1 -= comp(C[i][0], C[i][1], C[i][2], C[i][3], C[j][k0%4], C[j][(k0-1)%4], C[i][1], C[i][0]);\n          c1 -= comp(C[j][0], C[j][1], C[j][2], C[j][3], C[j][k0%4], C[j][(k0-1)%4], C[i][1], C[i][0]);\n          res *= c1;\n\n          value = k(C[j][(k0-1)%4], C[j][(k0-2)%4], C[i][2], C[i][1]);\n          if (counter.count(value) == 0) c1 = 0;\n          else c1 = counter[value];\n          c1 -= comp(C[i][0], C[i][1], C[i][2], C[i][3], C[j][(k0-1)%4], C[j][(k0-2)%4], C[i][2], C[i][1]);\n          c1 -= comp(C[j][0], C[j][1], C[j][2], C[j][3], C[j][(k0-1)%4], C[j][(k0-2)%4], C[i][2], C[i][1]);\n          c1 -= comp(C[j][k0%4], C[j][(k0-1)%4], C[i][1], C[i][0], C[j][(k0-1)%4], C[j][(k0-2)%4], C[i][2], C[i][1]);\n          res *= c1;\n\n          value = k(C[j][(k0-2)%4], C[j][(k0-3)%4], C[i][3], C[i][2]);\n          if (counter.count(value) == 0) c1 = 0;\n          else c1 = counter[value];\n          c1 -= comp(C[i][0], C[i][1], C[i][2], C[i][3], C[j][(k0-2)%4], C[j][(k0-3)%4], C[i][3], C[i][2]);\n          c1 -= comp(C[j][0], C[j][1], C[j][2], C[j][3], C[j][(k0-2)%4], C[j][(k0-3)%4], C[i][3], C[i][2]);\n          c1 -= comp(C[j][k0%4], C[j][(k0-1)%4], C[i][1], C[i][0], C[j][(k0-2)%4], C[j][(k0-3)%4], C[i][3], C[i][2]);\n          c1 -= comp(C[j][(k0-1)%4], C[j][(k0-2)%4], C[i][2], C[i][1], C[j][(k0-2)%4], C[j][(k0-3)%4], C[i][3], C[i][2]);\n          res *= c1;\n\n          value = k(C[j][(k0-3)%4], C[j][k0%4], C[i][0], C[i][3]);\n          if (counter.count(value) == 0) c1 = 0;\n          else c1 = counter[value];\n          c1 -= comp(C[i][0], C[i][1], C[i][2], C[i][3], C[j][(k0-3)%4], C[j][k0%4], C[i][0], C[i][3]);\n          c1 -= comp(C[j][0], C[j][1], C[j][2], C[j][3], C[j][(k0-3)%4], C[j][k0%4], C[i][0], C[i][3]);\n          c1 -= comp(C[j][k0%4], C[j][(k0-1)%4], C[i][1], C[i][0], C[j][(k0-3)%4], C[j][k0%4], C[i][0], C[i][3]);\n          c1 -= comp(C[j][(k0-1)%4], C[j][(k0-2)%4], C[i][2], C[i][1], C[j][(k0-3)%4], C[j][k0%4], C[i][0], C[i][3]);\n          c1 -= comp(C[j][(k0-2)%4], C[j][(k0-3)%4], C[i][3], C[i][2], C[j][(k0-3)%4], C[j][k0%4], C[i][0], C[i][3]);\n          res *= c1;\n          tot += res;\n        }\n      }\n    }\n  }\n  cout << tot/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint C[400][4];\nmap<long long, int> E;\nlong long enc(int a, int b, int c, int d) {\n  return 1000LL*1000LL*1000LL*a + 1000LL*1000LL* b + 1000LL*c + d;\n}\nvoid add(int i, int x) {\n  E[enc(C[i][0], C[i][1], C[i][2], C[i][3])] += x;\n  E[enc(C[i][1], C[i][2], C[i][3], C[i][0])] += x;\n  E[enc(C[i][2], C[i][3], C[i][0], C[i][1])] += x;\n  E[enc(C[i][3], C[i][0], C[i][1], C[i][2])] += x;\n}\n\nvoid add(int a, int b, int c, int d, int x) {\n  E[enc(a, b, c, d)] += x;\n  E[enc(b, c, d, a)] += x;\n  E[enc(c, d, a, b)] += x;\n  E[enc(d, a, b, c)] += x;\n}\n\nint t[4][4];\nlong long solve(int x1, int x2, int k) {\n  rep(i, 4) {\n    t[i][0] = C[x2][(i+1+k)%4];\n    t[i][1] = C[x2][(i+k)%4];\n    t[i][2] = C[x1][(4-i)%4];\n    t[i][3] = C[x1][(8-(i+1))%4];\n    if (E.find(enc(t[i][0], t[i][1], t[i][2], t[i][3])) == E.end()) return 0;\n  }\n  long long r = 1;\n  rep(i, 4) {\n    r *= E[enc(t[i][0], t[i][1], t[i][2], t[i][3])];\n    add(t[i][0], t[i][1], t[i][2], t[i][3], -1);\n  }\n  rep(i, 4) {\n    add(t[i][0], t[i][1], t[i][2], t[i][3], 1);\n  }\n  return r;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) {\n    rep(j, 4) {\n      cin >> C[i][j];\n    }\n  }\n  rep(i, N) add(i, 1);\n  long long ctr = 0;\n  for (int x1=0; x1<N; x1++) {\n    add(x1, -1);\n    for (int x2=0; x2<N; x2++) {\n      if (x1 == x2) continue;\n      add(x2, -1);\n      rep(k, 4) {\n        ctr += solve(x1, x2, k);\n      }\n      add(x2, 1);\n    }\n    add(x1, 1);\n  }\n  cout << ctr/6 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nusing namespace std;\nmap<ll,int> mp;\nll c[405][4];\nll h[405],v[4];\nvoid upd(ll x,int d){\n\tfor(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll)){\n\t\tmp[x]+=d;\n\t}\n}\nll hash(ll *a){\n\tll ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tans|=(a[i]<<(i*10ll));\n\t}\n\treturn ans;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&c[i][0],&c[i][1],&c[i][2],&c[i][3]);\n\t\th[i]=hash(c[i]);\n\t\tupd(h[i],1);\n\t}\n\tll ans=0,res;\n\tfor(int i=1;i<=n-5;i++){\n\t\tupd(h[i],-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tupd(h[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tres=1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n\t\t\t\t\tv[l]=hash(tmp);\n\t\t\t\t\tif(!mp.count(v[l])){\n\t\t\t\t\t\tgoto to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tres*=mp[v[l]];\n\t\t\t\t\tupd(v[l],-1);\n\t\t\t\t}\n\t\t\t\tans+=res;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tupd(v[l],1);\n\t\t\t\t}\n\t\t\t\tto:;\n\t\t\t}\n\t\t\tupd(h[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=440,D=4;\nint i,j,k,n,m,ch,ff;\nll ans;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nstruct cc {\n\tint a[D];\n\tbool operator < (const cc &n) const {\n\t\tfor (int i=0;i<D;i++) if (a[i]!=n.a[i]) return a[i]<n.a[i];\n\t\treturn 0;\n\t}\n\tvoid rev() {\n\t\tint t=a[0];\n\t\tfor (int i=1;i<D;i++) a[i-1]=a[i];\n\t\ta[D-1]=t;\n\t}\n\tvoid change() {\n\t\tint t=a[1];a[1]=a[3];a[3]=t;\n\t}\n\tll hash() {\n\t\tll ans=0;\n\t\tfor (int i=0;i<D;i++) ans=ans*1000+a[i];\n\t\treturn ans;\n\t}\n\tvoid read() {\n\t\tfor (int i=0;i<D;i++) R(a[i]);\n\t\t//change();\n\t}\n} A[N];\nmap<ll,int> Map;\nll work(cc a,cc b) {\n\tint i,j,k;\n\tcc t;\n\tll ans=1;\n\tfor (i=0;i<D;i++) {\n\t\tt.a[0]=a.a[(i+1)%D];t.a[1]=a.a[i];\n\t\tt.a[2]=b.a[i];t.a[3]=b.a[(i+1)%D];\n\t\tans*=Map[t.hash()];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]--;\n\t\t}\n\t}\n\tfor (i=0;i<D;i++) {\n\t\tt.a[0]=a.a[(i+1)%D];t.a[1]=a.a[i];\n\t\tt.a[2]=b.a[i];t.a[3]=b.a[(i+1)%D];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]++;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tR(n);ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tA[i].read();\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]--;\n\t\t}\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]--;\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[i].rev();\n\t\t\t\tans+=work(A[i],A[j]);\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]++;\n\t\t\t}\n\t\t}\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tW(ans/3);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <array>\nusing namespace std;\n\nint same(array<int, 4> a, array<int, 4> b){\n    int ret = 0;\n    if(a == b) ret++;\n    if(a == array<int, 4>{b[1], b[2], b[3], b[0]}) ret++;\n    if(a == array<int, 4>{b[2], b[3], b[0], b[1]}) ret++;\n    if(a == array<int, 4>{b[3], b[0], b[1], b[2]}) ret++;\n    return ret;\n}\n\nmap<array<int, 4>, int> mp;\nvector<array<int, 4> > up;\n\nint n;\n\nconst int maxn = 405;\n\nint main(){\n    cin >> n;\n    long long ans = 0;\n    for(int i = 1;i <= n;i++){\n        array<int, 4> c;\n        for(int j = 0;j < 4;j++){\n            cin >> c[j];\n        }\n        for(auto d : up){\n            long long ret = 1;\n            array<int, 4> w = {d[1], d[0], c[1], c[0]};\n            array<int, 4> x = {d[2], d[1], c[0], c[3]};\n            array<int, 4> y = {d[0], d[3], c[2], c[1]};\n            array<int, 4> z = {d[3], d[2], c[3], c[2]};\n            ret *= mp[w] - same(w, d);\n            ret *= mp[x] - same(x, w) - same(x, d);\n            ret *= mp[y] - same(y, x) - same(y, w) - same(y, d);\n            ret *= mp[z] - same(z, y) - same(z, x) - same(z, w) - same(z, d);\n            ans += ret;\n        }\n        up.push_back(array<int, 4>{c[0], c[1], c[2], c[3]});mp[up.back()]++; \n        up.push_back(array<int, 4>{c[1], c[2], c[3], c[0]});mp[up.back()]++;\n        up.push_back(array<int, 4>{c[2], c[3], c[0], c[1]});mp[up.back()]++;\n        up.push_back(array<int, 4>{c[3], c[0], c[1], c[2]});mp[up.back()]++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nusing namespace std;\nconst int N=405;\nnamespace HASH{/*{{{*/\n\tconst int N=10000000;\n\tconst int MOD=9875321;\n\tint sz,h[MOD],nex[N],val[N];\n\tll key[N];\n\tinline int getHash(ll x){\n\t\treturn x%MOD;\n\t}\n\tvoid add(ll x,int y){\n\t\tint pos=getHash(x),u;\n\t\tfor(u=h[pos];u&&nex[u]&&key[u]!=x;u=nex[u]);\n\t\tif(key[u]==x)\n\t\t\tval[u]+=y;\n\t\telse{\n\t\t\tif(!h[pos])\n\t\t\t\th[pos]=++sz;\n\t\t\telse nex[u]=++sz;\n\t\t\tkey[sz]=x;\n\t\t\tval[sz]=y;\n\t\t}\n\t}\n\tint query(ll x){\n\t\tint pos=getHash(x),u;\n\t\tfor(u=h[pos];u&&nex[u]&&key[u]!=x;u=nex[u]);\n\t\treturn key[u]==x?val[u]:0;\n\t}\n}/*}}}*/\nint n;\nint c[N][4];\ninline ll getKey(int *c){\n\treturn c[0]+c[1]*1000+1ll*c[2]*1000000+1ll*c[3]*1000000000;\n}\ninline void rotate(int *c){\n\tint c0=c[0];\n\tfor(int i=0;i<3;i++)\n\t\tc[i]=c[i+1];\n\tc[3]=c0;\n}\ninline void pattern_add(int *c,int x){\n\tfor(int i=0;i<4;i++){\n\t\tHASH::add(getKey(c),x);\t\n\t\trotate(c);\n\t}\n}\nvoid readData(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&c[i][1],&c[i][0],&c[i][3],&c[i][2]);\n\t\tpattern_add(c[i],1);\n\t}\n}\nvoid solve(){\n\tll ans=0;\n\tfor(int i=1;i<n;i++){\n\t\tpattern_add(c[i],-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tpattern_add(c[j],-1);\n\t\t\tfor(int l=0;l<4;l++){// up rotate \n\t\t\t\tstatic int tp[4];\n\t\t\t\tll now=1;\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;k<4&&now;k++){// count 4 sides\n\t\t\t\t\ttp[0]=c[j][3-k]; tp[1]=c[j][3-((k+1)%4)]; tp[2]=c[i][(k+1)%4]; tp[3]=c[i][k];\n\t\t\t\t\tnow*=HASH::query(getKey(tp));\n\t\t\t\t\tpattern_add(tp,-1);\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t\tfor(k--;k>=0;k--){// count 4 sides\n\t\t\t\t\ttp[0]=c[j][3-k]; tp[1]=c[j][3-((k+1)%4)]; tp[2]=c[i][(k+1)%4]; tp[3]=c[i][k];\n\t\t\t\t\tpattern_add(tp,1);\n\t\t\t\t}\n\t\t\t\trotate(c[j]);\n\t\t\t}\n\t\t\tpattern_add(c[j],1);\t\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nP f(ll x,ll y,ll z,ll w){\n\tll c[4] = { x , y , z , w };\n\tll a[4] = {};\n\trep(i,4){\n\t\trep(j,4){\n\t\t\ta[i] *= 1000;\n\t\t\ta[i] += c[(i+j)%4];\n\t\t}\n\t}\n\tll ret = max(max(a[0],a[1]),max(a[2],a[3]));\n\tll cnt = 0;\n\trep(i,4)if(a[i] == ret)cnt ++;\n\treturn P(ret,cnt);\n}\n\nint main(){\n\tint n;\n\tll c[402][4];\n\tP A[402];\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\trep(j,4){\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tA[i] = f(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t\t//cout << A[i] << endl;\n\t}\n\t\n\tmap<ll,int> M;\n\trep(i,n)M[A[i].fr] += A[i].sc;\n\t\n\tll ret = 0;\n\trep(i,n){\n\t\tM[A[i].fr] -= A[i].sc;\n\t\tfor(int j = i+1 ; j < n ; j ++){\n\t\t\tM[A[j].fr] -= A[j].sc;\n\t\t\trep(k,4){\n\t\t\t\tP x[4];\n\t\t\t\tll _ret = 1;\n\t\t\t\trep(l,4){\n\t\t\t\t\tx[l] = f(c[i][l],c[j][(k+4-l)%4],c[j][(k+4-l-1)%4],c[i][(l+1)%4]);\n\t\t\t\t\t_ret *= M[x[l].fr];\n\t\t\t\t\tM[x[l].fr] -= x[l].sc;\n\t\t\t\t}\n\t\t\t\trep(l,4){\n\t\t\t\t\tM[x[l].fr] += x[l].sc;\n\t\t\t\t}\n\t\t\t\tret += _ret;\n\t\t\t}\n\t\t\tM[A[j].fr] += A[j].sc;\n\t\t}\n\t}\n\t\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i) & 3];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)&3] < colors[(j+k)&3]) return true;\n            if (colors[(i+k)&3] > colors[(j+k)&3]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nstruct myhash {\n    std::size_t operator() (const Colors &c) const {\n        LL x = 0;\n        x |= c.colors[0];\n        x |= c.colors[1] << 10;\n        x |= c.colors[2] << 20;\n        x |= c.colors[3] << 30;\n        return std::hash<LL>()(x);\n    }\n};\n\n// unordered_map<Colors, int, myhash> colcnt;\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors &a, Colors &b, Colors &brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        if (colcnt.find(c) == colcnt.end()) return 0;\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    for(auto &pb: colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL multi = pb.second;\n        pb.second--;\n        FORN(rot, 4) {\n            ans += multi * countfit(a, b, brot);\n            brot.rotate_left(1);\n        }\n        pb.second++;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        Colors a = tiles[i];\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nbool all_same(vector<int>& vec){\n    return vec[0]==vec[1] && vec[1]==vec[2] && vec[2]==vec[3];\n}\nbool rot_same(vector<int> &vec){\n    return vec[0]==vec[2] && vec[1]==vec[3];\n}\nenum{ALL,ROT,REG};\nstruct reg_pat{\n    int type;\n    ll all_c;\n    ll rot_c;\n    ll x;\n};\nconst ll NUM=1000;\nll rot(vector<int> &vec){\n    ll c1=min(vec[0],vec[1]);\n    ll c2=max(vec[0],vec[1]);\n    return c1*NUM+c2;\n}\nll regular(vector<int> &vec){\n    ll res=1e17;\n    for(int i=0;i<4;i++){\n        ll num=0;\n        for(int j=0;j<4;j++){\n            num*=NUM;\n            num+=vec[(i+j)%4];\n        }\n        res=min(num,res);\n    }\n    return res;\n}\nll regul(vector<int> &c){\n    if(all_same(c)){\n        return c[0];\n    }\n    else if(rot_same(c)){\n        return rot(c);\n    }\n    else{\n        return regular(c);\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> c(n,vector<int>(4));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<4;j++){\n            cin>>c[i][j];\n            c[i][j]++;\n        }\n    }\n    map<ll,ll> pat_cnt;\n    for(int i=0;i<n;i++){\n        pat_cnt[regul(c[i])]++;\n    }\n    ll res=0;\n    auto par=[](ll x,ll y){\n        ll res=1;\n        for(int i=0;i<y;i++){\n            res*=(x-i);\n        }\n        return res;\n    };\n    for(int i=0;i<n;i++){\n        pat_cnt[regul(c[i])]--;\n        for(int j=i+1;j<n;j++){\n            pat_cnt[regul(c[j])]--;\n            vector<int> top=c[i];\n            vector<int> bot(4);\n            for(int r=0;r<4;r++){\n                for(int k=0;k<4;k++){\n                    bot[k]=c[j][(k+r)%4];\n                }\n                map<ll,int> cnt;\n                vector<int> fr={top[3],top[2],bot[3],bot[2]};\n                vector<int> ri={top[2],top[1],bot[0],bot[3]};\n                vector<int> ba={top[1],top[0],bot[1],bot[0]};\n                vector<int> le={top[0],top[3],bot[2],bot[1]};\n                cnt[regul(fr)]++;\n                cnt[regul(ri)]++;\n                cnt[regul(ba)]++;\n                cnt[regul(le)]++;\n                ll pat=1;\n                for(auto &e:cnt){\n                    if(e.first<NUM){\n                        pat*=par(pat_cnt[e.first],e.second);\n                        for(int z=0;z<e.second;z++) pat*=4;\n                    }else if(e.first<NUM*NUM){\n                        \n                        pat*=par(pat_cnt[e.first],e.second);\n                        for(int z=0;z<e.second;z++) pat*=2;\n                    }\n                    else{\n                        pat*=par(pat_cnt[e.first],e.second);\n                    }\n                }\n                \n                res+=pat;\n            }\n            pat_cnt[regul(c[j])]++;\n        }\n\n        \n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nvector<int> e[MAXN],V[MAXN];\nint fac[MAXN],inv[MAXN],dfn[MAXN],low[MAXN],stk[MAXN],flag[MAXN],top=0,num=0,DFN=0,n,m,k;\ninline int quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\ninline void Init(int n)\n{\n\tfac[0]=1; \n\tfor (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mods;\n\tinv[n]=quick_pow(fac[n],mods-2);\n\tfor (int i=n-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mods;\n}\ninline int upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\ninline int gcd(int x,int y) { return y==0?x:gcd(y,x%y); }\ninline int C(int x,int y) { return 1ll*fac[x]*inv[y]%mods*inv[x-y]%mods; }\ninline int Burnside(int n) { int ans=0; for (int i=0;i<n;i++) ans=upd(ans,quick_pow(k,gcd(i,n))%mods); return 1ll*ans*quick_pow(n,mods-2)%mods; }\ninline void tarjan(int x,int father)\n{\n\tdfn[x]=low[x]=++DFN;\n\tstk[++top]=x;\n\tfor (auto v:e[x])\n\t{\n\t\tif (v==father) continue;\n\t\tif (!dfn[v])\n\t\t{\n\t\t\ttarjan(v,x);\n\t\t\tupmin(low[x],low[v]);\n\t\t\tif (low[v]>=dfn[x])\n\t\t\t{\n\t\t\t\tint y;\n\t\t\t\tV[++num].PB(x);\n\t\t\t\twhile (y=stk[top--])\n\t\t\t\t{\n\t\t\t\t\tV[num].PB(y);\n\t\t\t\t\tif (y==v) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse upmin(low[x],dfn[v]);\n\t}\n}\nint main()\n{\n\tn=read(),m=read(),k=read();\n\tInit(m+k);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint u=read(),v=read();\n\t\te[u].PB(v),e[v].PB(u);\n\t}\n\tfor (int i=1;i<=n;i++) if (!dfn[i]) tarjan(i,0);\n\tint ans=1;\n\tfor (int i=1;i<=num;i++)\n\t{\n\t\tif (V[i].size()==2) ans=1ll*ans*k%mods;\n\t\telse\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor (int i=1;i<=n;i++) flag[i]=0;\n\t\t\tfor (auto x:V[i]) flag[x]=1;\n\t\t\tfor (auto x:V[i])\n\t\t\t\tfor (auto v:e[x]) if (flag[v]) cnt++;\n\t\t\tcnt>>=1;\n\t\t\tif (cnt==V[i].size()) ans=1ll*ans*Burnside(cnt)%mods;\n\t\t\telse ans=1ll*ans*C(cnt+k-1,k-1)%mods;\n//\t\t\tcout<<V[i].size()<<\" \"<<cnt<<\" \"<<ans<<endl;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass tile{\n\tint edge[4];\n\tint rev_edge[4];\t\n};\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tint t[400][4];\n\tint r_t[400][4];\n\tint i1,i2,i3,i4,i5,i6,i7,i8;\n\t\n\tint r = 0;\n\t\t\n\tfor(int i=0;i<n;i++){\n\t\tcin >> t[i][0] >> t[i][1] >> t[i][2] >> t[i][3];\n\t}\n\t\t\n\tfor(int i=0;i<n;i++){\n\t\ti1 = t[i][0];\n\t\ti2 = t[i][1];\n\t\ti3 = t[i][2];\n\t\ti4 = t[i][3];\n\t\tfor(int j=i;j<n;j++){\n\t\t\ti5 = t[j][0];\n\t\t\ti6 = t[j][1];\n\t\t\ti7 = t[j][2];\n\t\t\ti8 = t[j][3];\n\t\t\t\n\t\t\tfor(int j1 = i+1; j1 < n; j1++){\n\t\t\t\tif(j1 == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i+1; j2 < n; j2++){\n\t\t\t\t\t\tif(j2 == j || j2 == j1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i+1; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif(j3 == j || j3 == j1 || j3 == j2)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i+1; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif(j4 == j || j4 == j1 || j4 == j2 || j4 == j3)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti5 = t[j][1];\n\t\t\ti6 = t[j][2];\n\t\t\ti7 = t[j][3];\n\t\t\ti8 = t[j][0];\n\n\t\t\tfor(int j1 = i+1; j1 < n; j1++){\n\t\t\t\tif(j1 == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i+1; j2 < n; j2++){\n\t\t\t\t\t\tif(j2 == j || j2 == j1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i+1; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif(j3 == j || j3 == j1 || j3 == j2)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i+1; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif(j4 == j || j4 == j1 || j4 == j2 || j4 == j3)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\ti5 = t[j][2];\n\t\t\ti6 = t[j][3];\n\t\t\ti7 = t[j][0];\n\t\t\ti8 = t[j][1];\n\n\t\t\tfor(int j1 = i+1; j1 < n; j1++){\n\t\t\t\tif(j1 == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i+1; j2 < n; j2++){\n\t\t\t\t\t\tif(j2 == j || j2 == j1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i+1; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif(j3 == j || j3 == j1 || j3 == j2)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i+1; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif(j4 == j || j4 == j1 || j4 == j2 || j4 == j3)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti5 = t[j][3];\n\t\t\ti6 = t[j][0];\n\t\t\ti7 = t[j][1];\n\t\t\ti8 = t[j][2];\n\t\t\t\n\t\t\tfor(int j1 = i+1; j1 < n; j1++){\n\t\t\t\tif(j1 == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i+1; j2 < n; j2++){\n\t\t\t\t\t\tif(j2 == j || j2 == j1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i+1; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif(j3 == j || j3 == j1 || j3 == j2)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i+1; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif(j4 == j || j4 == j1 || j4 == j2 || j4 == j3)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t\t\n\tprintf(\"%d\\n\",r);\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef deque<int> D;\n\nvoid rot(D& d) {\n\td.push_back(d[0]);\n\td.pop_front();\n}\n\nD f(D d) {\n\tD ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\trot(d);\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint overlap(D d) {\n\tint ret = 1;\n\tD t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\trot(d);\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\nll P(int n, int k) {\n\tll ret = 1;\n\tfor(int i = n - k + 1; i <= n; i++) ret *= i;\n\treturn ret;\n}\n\nD C[400];\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<D, int> m;\n\tmap<D, int> cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tC[i] = D(4);\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tcin >> C[i][j];\n\t\t}\n\t\tC[i] = f(C[i]);\n\t\tm[C[i]]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tD d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\tD d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<D, int> t;\n\t\t\t\tt[f(D({ d1[1], d1[0], d2[1], d2[0] }))]++;\n\t\t\t\tt[f(D({ d1[0], d1[3], d2[2], d2[1] }))]++;\n\t\t\t\tt[f(D({ d1[3], d1[2], d2[3], d2[2] }))]++;\n\t\t\t\tt[f(D({ d1[2], d1[1], d2[0], d2[3] }))]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P(m[p.first], p.second);\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\trot(d1);\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > rotate(vector< int > v, int p) {\n  rotate(begin(v), begin(v) + p, end(v));\n  return v;\n}\n\nvector< int > normalize(vector< int > &v) {\n  vector< int > ret(v);\n  for(int i = 1; i < 4; i++) {\n    ret = min(ret, rotate(v, i));\n  }\n  return ret;\n}\n\nusing int64 = long long;\n\nint main() {\n  int N;\n  cin >> N;\n  vector< vector< int > > C(N, vector< int >(4));\n\n  map< vector< int >, int > cnt, mul;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 4; j++) cin >> C[i][j];\n    C[i] = normalize(C[i]);\n    cnt[C[i]]++;\n  }\n  for(auto &p : cnt) {\n    for(int j = 0; j < 4; j++) {\n      mul[p.first] += rotate(p.first, j) == p.first;\n    }\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    cnt[C[i]]--;\n    for(int j = 0; j < i; j++) {\n      cnt[C[j]]--;\n      for(int k = 0; k < 4; k++) {\n        vector< int > key1{C[i][1], C[i][0], C[j][1], C[j][0]};\n        vector< int > key2{C[i][2], C[i][1], C[j][0], C[j][3]};\n        vector< int > key3{C[i][3], C[i][2], C[j][3], C[j][2]};\n        vector< int > key4{C[i][0], C[i][3], C[j][2], C[j][1]};\n        key1 = normalize(key1);\n        key2 = normalize(key2);\n        key3 = normalize(key3);\n        key4 = normalize(key4);\n        int64 latte = 1;\n        latte *= mul[key1] * cnt[key1];\n        --cnt[key1];\n        latte *= mul[key2] * cnt[key2];\n        --cnt[key2];\n        latte *= mul[key3] * cnt[key3];\n        --cnt[key3];\n        latte *= mul[key4] * cnt[key4];\n        --cnt[key4];\n        ret += latte;\n        ++cnt[key1];\n        ++cnt[key2];\n        ++cnt[key3];\n        ++cnt[key4];\n        rotate(begin(C[j]), begin(C[j]) + 1, end(C[j]));\n      }\n      cnt[C[j]]++;\n    }\n    cnt[C[i]]++;\n  }\n  cout << ret / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nint c[400][4];\nLL h[400];\nint e[5], f[5];\nint sides[4][4];\nLL sh[4];\nbool used[4];\nmap<LL, int> cnt;\n\nLL getHash(int *a) {\n    LL h = 0;\n    forn(i, 4) {\n        h <<= 10;\n        h |= a[i];\n    }\n    return h;\n}\n\nvoid lexMin(int *a) {\n    int cur[4];\n    forn(i, 4) cur[i] = a[i];\n    forn(i, 3) {\n        int tmp = a[0];\n        forn(j, 3) a[j] = a[j + 1];\n        a[3] = tmp;\n        bool ok = false;\n        forn(j, 4) if (a[j] != cur[j]) {\n            ok = a[j] < cur[j];\n            break;\n        }\n        if (ok) {\n            forn(j, 4) {\n                cur[j] = a[j];\n            }\n        }\n    }\n    forn(i, 4) a[i] = cur[i];\n}\n\nint calcSameRots(int *a) {\n    int same = 1;\n    int b[4];\n    forn(i, 4) {\n        b[i] = a[i];\n    }\n    forn(i, 3) {\n        int tmp = b[0];\n        forn(j, 3) b[j] = b[j + 1];\n        b[3] = tmp;\n        bool ok = true;\n        forn(j, 4) if (b[j] != a[j]) {\n            ok = false;\n            break;\n        }\n        if (ok) {\n            ++same;\n        }\n    }\n    return same;\n}\n\nLL C[1111][6];\nLL fac[10] = {};\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    fac[0] = 1;\n    for (int i = 1; i < 10; ++i) {\n        fac[i] = fac[i - 1] * i;\n    }\n    forn(i, 6) C[0][i] = 0;\n    C[0][0] = 1;\n    for (int i = 1; i < 1111; ++i) {\n        C[i][0] = 1;\n        for (int j = 1; j < 6; ++j) {\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n        }\n    }\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    forn(i, n) forn(j, 4) {\n        cin >> c[i][j];\n    }\n    /*cout << LL(9e18) << endl;\n    forn(i, n) forn(j, 4) {\n        c[i][j] = 0;\n    }*/\n    forn(i, n) {\n        lexMin(c[i]);\n        h[i] = getHash(c[i]);\n    }\n    LL ans = 0;\n    forn(i, n) {\n        forn(z, 4) {\n            e[z] = c[i][z];\n        }\n        e[4] = e[0];\n        forn(j, i) {\n            --cnt[h[j]];\n            forn(k, 4) {\n                forn(z, 4) {\n                    f[z] = c[j][(z + k) % 4];\n                }\n                reverse(f, f + 4);\n                f[4] = f[0];\n                forn(z, 4) {\n                    sides[z][0] = e[z + 1];\n                    sides[z][1] = e[z];\n                    sides[z][2] = f[z];\n                    sides[z][3] = f[z + 1];\n                    lexMin(sides[z]);\n                    sh[z] = getHash(sides[z]);\n                }\n                forn(z, 4) {\n                    used[z] = false;\n                }\n                LL cur = 1;\n                forn(z, 4) {\n                    if (used[z]) {\n                        continue;\n                    }\n                    used[z] = true;\n                    int same = 1;\n                    for (int y = z + 1; y < 4; ++y) {\n                        if (sh[z] == sh[y]) {\n                            ++same;\n                            used[y] = true;\n                        }\n                    }\n                    cur *= C[cnt[sh[z]]][same] * fac[same];\n                }\n                forn(z, 4) {\n                    cur *= calcSameRots(sides[z]);\n                }\n                ans += cur;\n            }\n            ++cnt[h[j]];\n        }\n        ++cnt[h[i]];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <unordered_map>\n#include <map>\n#define REP(i,n) for(long (i)=0;(i)<(n);(i)++)\n#define REPI(i,a,b) for(long (i)=(a);(i)<(b);(i)++)\n#define INF numeric_limits<double>::infinity()\nconstexpr long MOD = 1e9 + 7;\nusing namespace std;\nusing P = pair<long, long>;\nusing VI = vector<long>;\n\nvector<vector<int>> rot(vector<int> a) {\n    vector<vector<int>> ret;\n    ret.push_back(a);\n    REP(i,3) {\n        a.push_back(a[0]);\n        a.erase(a.begin());\n        ret.push_back(a);\n    }\n    return ret;\n}\n\nint main() {\n    int n, p, q, r, s;\n    cin >> n;\n    \n    vector<vector<int>> v;\n    REP(i,n) {\n        cin >> p >> q >> r >> s;\n        v.push_back({p,q,r,s});\n    }\n    \n    long ans = 0;\n    \n    map<vector<int>, vector<int>> m;\n    REP(k,n) {\n        for (auto l: rot(v[k])) {\n            m[l].push_back(k);\n        }\n    }\n    \n    REP(i,n) {\n        auto a = v[i];\n        for (int j = i + 1; j < n; j++) {\n            for (auto b: rot(v[j])) {\n                vector<int> fr, ri, ba, le;\n                fr = m[{a[3],a[2],b[1],b[0]}];\n                ri = m[{a[2],a[1],b[2],b[1]}];\n                ba = m[{a[1],a[0],b[3],b[2]}];\n                le = m[{a[0],a[3],b[0],b[3]}];\n                \n                sort(fr.begin(), fr.end());\n                sort(ri.begin(), ri.end());\n                sort(ba.begin(), ba.end());\n                sort(le.begin(), le.end());\n                \n                for (int x: fr) for (int y: ri) for (int z: ba) for (int w: le) {\n                    if (i != x && i != y && i != z && i != w) {\n                        if (j != x && j != y && j != z && j != w) {\n                            if (x != y && x != z && x != w && y != z && y != w && z != w) ans++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << ans / 3 << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\n#define ll long long\nmap<ll,int> mp;\nstruct Wall{\n\tint a[4];\n\tll Hash;\n\tvoid hash(){\n\t\tHash=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tHash|=a[i]<<(i*10ll);\n\t\t}\n\t}\n\tvoid update(int x){\n\t\tll now=Hash;\n\t\tfor(int i=0;i<4;i++,now=((now&1023ll)<<30ll)|(now>>10ll)){\n\t\t\tmp[now]+=x;\n\t\t}\n\t}\n\tvoid read(){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t}\n\t\thash();\n\t\tupdate(1);\n\t}\n}a[405],tmp;\nll v[4];\nvoid update(ll x,int d){\n\tfor(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll)){\n\t\tmp[x]+=d;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\ta[i].read();\n\t}\n\tll ans=0,res;\n\tbool get_ans;\n\tfor(int i=1;i<=n-5;i++){\n\t\ta[i].update(-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\ta[j].update(-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tres=1;\n\t\t\t\tget_ans=1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\ttmp.a[0]=a[i].a[(l+1)&3];\n\t\t\t\t\ttmp.a[1]=a[i].a[l];\n\t\t\t\t\ttmp.a[2]=a[j].a[(3-l+k)&3];\n\t\t\t\t\ttmp.a[3]=a[j].a[(6-l+k)&3];\n\t\t\t\t\ttmp.hash();\n\t\t\t\t\tv[l]=tmp.Hash;\n\t\t\t\t\tif(!mp.count(v[l])){\n\t\t\t\t\t\tget_ans=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!get_ans){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tres*=mp[v[l]];\n\t\t\t\t\tupdate(v[l],-1);\n\t\t\t\t}\n\t\t\t\tans+=res;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tupdate(v[l],1);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[j].update(1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans==0?1:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<ll> C[404];\nll VV[404];\nint R[404];\nmap<ll,int> B[5];\n\nll getkey(vector<ll> v) {\n\tll r=1LL<<60;\n\tint i;\n\tFOR(i,4) {\n\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\tr=min(r,v[0]*1000000000+v[1]*1000000+v[2]*1000+v[3]);\n\t}\n\treturn r;\n}\n\nll dfs(int cur,int n1,int n2,int n4) {\n\tif(cur==0) return 1;\n\tll ret=0;\n\tif(n1) ret += n1*dfs(cur-1,n1-1,n2,n4);\n\tif(n2) ret += 2*n2*dfs(cur-1,n1,n2-1,n4);\n\tif(n4) ret += 4*n4*dfs(cur-1,n1,n2,n4-1);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y,z; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tvector<ll> V(4,0);\n\t\tFOR(j,4) cin>>V[j];\n\t\tC[i]=V;\n\t\tFOR(j,4) {\n\t\t\tC[i]=min(C[i],V);\n\t\t\trotate(V.begin(),V.begin()+1,V.end());\n\t\t}\n\t\tFOR(j,4) {\n\t\t\tR[i]+=(C[i]==V);\n\t\t\trotate(V.begin(),V.begin()+1,V.end());\n\t\t}\n\t\tVV[i]=C[i][0]*1000000000+C[i][1]*1000000+C[i][2]*1000+C[i][3];\n\t\tB[R[i]][VV[i]]++;\n\t}\n\tll ret=0;\n\tFOR(x,N) {\n\t\tB[R[x]][VV[x]]--;\n\t\tfor(y=x+1;y<N;y++) {\n\t\t\tB[R[y]][VV[y]]--;\n\t\t\tFOR(z,4) {\n\t\t\t\trotate(C[y].begin(),C[y].begin()+1,C[y].end());\n\t\t\t\t\n\t\t\t\tmap<ll,int> mp;\n\t\t\t\tmp[getkey({C[x][0],C[x][1],C[y][1],C[y][0]})]++;\n\t\t\t\tmp[getkey({C[x][1],C[x][2],C[y][2],C[y][1]})]++;\n\t\t\t\tmp[getkey({C[x][2],C[x][3],C[y][3],C[y][2]})]++;\n\t\t\t\tmp[getkey({C[x][3],C[x][0],C[y][0],C[y][3]})]++;\n\t\t\t\t\n\t\t\t\tll tmp=1;\n\t\t\t\tFORR(r,mp) {\n\t\t\t\t\ttmp *= dfs(r.second,B[1][r.first],B[2][r.first],B[4][r.first]);\n\t\t\t\t\tif(tmp==0) break;\n\t\t\t\t}\n\t\t\t\tret += tmp;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tB[R[y]][VV[y]]++;\n\t\t}\n\t\tB[R[y]][VV[x]]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define pb push_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define debug printf(\"--%d--\\n\",__LINE__)\n#define ll long long int\n\nint n;\nint c[512][4];\nll ans = 0;\n\nbool same(vi x, vi y){\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif (x[j] != y[(i+j)%4]) break;\n\t\t\tif (j==3) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvi rot(vi a, int n){\n\tvi ret(4);\n\tfor(int i=0;i<4;i++){\n\t\tret[i] = a[(i+n)%4];\n\t}\n\treturn ret;\n}\n\nvi normalize(vi a){\n\tint x = 0, y = 0;\n\tx = a[1] + a[2] - a[3] - a[0];\n\ty = a[0] + a[1] - a[2] - a[3];\n\tif (x==0 && y==0){\n\t\tif (a[0] > a[1]) return rot(a,1);\n\t\treturn a;\n\t}\n\tif (x>0 && y>=0) return rot(a,1);\n\tif (x>=0 && y<0) return rot(a,2);\n\tif (x<0 && y<=0) return rot(a,3);\n\treturn a;\n}\n\nint calcsym(vi a){\n\tif (a[0]==a[1] && a[0]==a[2] && a[0]==a[3]) return 4;\n\tif (a[0]==a[2] && a[1]==a[3]) return 2;\n\treturn 1;\n}\n\nint main(void){\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tvi men(4);\n\t\tfor(int j=0;j<4;j++){\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tll ans = 0;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tmultiset<vi> allmens;\n\t\t\tfor(int k=i+1;k<n;k++){\n\t\t\t\tif (k==j) continue;\n\t\t\t\tvi men(4);\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tmen[l] = c[k][l];\n\t\t\t\t}\n\t\t\t\tallmens.insert(normalize(men));\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvvi mens;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tvi men;\n\t\t\t\t\tmen.pb(c[i][l]);\n\t\t\t\t\tmen.pb(c[j][(4-l+k)%4]);\n\t\t\t\t\tmen.pb(c[j][(7-l+k)%4]);\n\t\t\t\t\tmen.pb(c[i][(l+1)%4]);\n\t\t\t\t\tmens.pb(normalize(men));\n\t\t\t\t}\n\t\t\t\t//cout << i << \" \" << j << \" \" << k << endl;\t\t\t\t\n\t\t\t\t/*for(int l=0;l<4;l++){\n\t\t\t\t\tfor(int m=0;m<4;m++){\n\t\t\t\t\t\tcout << mens[l][m] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}*/\n\t\t\t\tvi chk(4);\n\t\t\t\tll num = 1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif (chk[l]) continue;\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tfor(int m=l+1;m<4;m++){\n\t\t\t\t\t\tif (mens[l]==mens[m]){\n\t\t\t\t\t\t\tchk[m] = 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint mc = allmens.count(mens[l]);\n\t\t\t\t\t/*if (mc>0){\n\t\t\t\t\t\tcout << \"mc = \" << mc << \": \";\n\t\t\t\t\t\tfor(int m=0;m<4;m++){\n\t\t\t\t\t\t\tcout << mens[l][m] << \" \";\n\t\t\t\t\t\t}cout << endl;\n\t\t\t\t\t}*/\n\t\t\t\t\tint sym = calcsym(mens[l]);\n\t\t\t\t\tfor(int m=0;m<cnt;m++){\n\t\t\t\t\t\tnum *= (mc-m)*sym;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += num;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 405\nusing namespace std;\ninline int read(){\n\tint ans=0;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\treturn ans;\n}\nint n,col[N][4];\nll ans=0,mp[N][4];\nmap<ll,int>cnt;\ninline ll idx(int a,int b,int c,int d){return 1ll*a+1ll*b*1000+1ll*c*1000000+1ll*d*1000000000;}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i)for(int j=0;j<=3;++j)col[i][j]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tmp[i][0]=idx(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tmp[i][1]=idx(col[i][1],col[i][2],col[i][3],col[i][0]);\n\t\tmp[i][2]=idx(col[i][2],col[i][3],col[i][0],col[i][1]);\n\t\tmp[i][3]=idx(col[i][3],col[i][0],col[i][1],col[i][2]);\n\t\tfor(int j=0;j<4;++j)++cnt[mp[i][j]];\n\t}\n\tfor(int i=1;i<n-4;++i){\n\t\tfor(int j=0;j<4;++j)--cnt[mp[i][j]];\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tfor(int k=0;k<4;++k)--cnt[mp[j][k]];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tll tmp[16],ttmp=1;\n\t\t\t\ttmp[0]=idx(col[i][0],col[i][3],col[j][k],col[j][(k+3)%4]);\n\t\t\t\ttmp[4]=idx(col[j][(k+3)%4],col[i][0],col[i][3],col[j][k]);\n\t\t\t\ttmp[8]=idx(col[j][k],col[j][(k+3)%4],col[i][0],col[i][3]);\n\t\t\t\ttmp[12]=idx(col[i][3],col[j][k],col[j][(k+3)%4],col[i][0]);\n\t\t\t\ttmp[1]=idx(col[i][1],col[i][0],col[j][(k+3)%4],col[j][(k+2)%4]);\n\t\t\t\ttmp[5]=idx(col[j][(k+2)%4],col[i][1],col[i][0],col[j][(k+3)%4]);\n\t\t\t\ttmp[9]=idx(col[j][(k+3)%4],col[j][(k+2)%4],col[i][1],col[i][0]);\n\t\t\t\ttmp[13]=idx(col[i][0],col[j][(k+3)%4],col[j][(k+2)%4],col[i][1]);\n\t\t\t\ttmp[2]=idx(col[i][2],col[i][1],col[j][(k+2)%4],col[j][(k+1)%4]);\n\t\t\t\ttmp[6]=idx(col[j][(k+1)%4],col[i][2],col[i][1],col[j][(k+2)%4]);\n\t\t\t\ttmp[10]=idx(col[j][(k+2)%4],col[j][(k+1)%4],col[i][2],col[i][1]);\n\t\t\t\ttmp[14]=idx(col[i][1],col[j][(k+2)%4],col[j][(k+1)%4],col[i][2]);\n\t\t\t\ttmp[3]=idx(col[i][3],col[i][2],col[j][(k+1)%4],col[j][k]);\n\t\t\t\ttmp[7]=idx(col[j][k],col[i][3],col[i][2],col[j][(k+1)%4]);\n\t\t\t\ttmp[11]=idx(col[j][(k+1)%4],col[j][k],col[i][3],col[i][2]);\n\t\t\t\ttmp[15]=idx(col[i][2],col[j][(k+1)%4],col[j][k],col[i][3]);\n\t\t\t\tif(cnt[tmp[0]]==0||cnt[tmp[1]]==0||cnt[tmp[2]]==0||cnt[tmp[3]]==0)continue;\n\t\t\t\tfor(int l=0;l<4;++l){\n\t\t\t\t\tttmp*=cnt[tmp[l]];\n\t\t\t\t\tfor(int m=l;m<16;m+=4)--cnt[tmp[m]];\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<16;++l)++cnt[tmp[l]];\n\t\t\t\tans+=ttmp;\n\t\t\t}\n\t\t\tfor(int k=0;k<4;++k)++cnt[mp[j][k]];\n\t\t}\n\t\tfor(int j=0;j<4;++j)++cnt[mp[i][j]];\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n;\nlong long bin[5],ans;\nlong long a[405][4],A[4],B[4];\nunordered_map<long long,long long>mp;\nlong long gao(long long aa,long long bb)\n{\n\tlong long qwq=0;\n\tfor(long long j=0;j<4;++j) qwq+=bin[j]*a[aa][(bb+j)%4];\n\treturn qwq;\n}\nlong long md(long long aa,long long bb,long long cc)\n{\n\ta[n+1][0]=A[aa];a[n+1][1]=B[aa];\n\ta[n+1][2]=B[bb];a[n+1][3]=A[bb];\n\tlong long tmp=mp[gao(n+1,0)];\n\tfor(long long i=0;i<4;++i) mp[gao(n+1,i)]-=cc;\n\treturn tmp;\n}\nvoid getans()\n{\n\tans+=1ll*md(0,1,1)*md(1,2,1)*md(2,3,1)*md(3,0,1);\n\tmd(0,1,-1);md(1,2,-1);md(2,3,-1);md(3,0,-1);\n\treturn;\n}\nint main()\n{\n\tn=read();bin[0]=1;\n\tfor(long long i=1;i<4;++i) bin[i]=bin[i-1]*1000;\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tfor(long long j=0;j<4;++j) a[i][j]=read();\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]--,A[j]=a[i][j];\n\t\tfor(long long j=i+1;j<=n;++j)\n\t\t{\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]--;\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l)\n\t\t\t{\n\t\t\t\tfor(long long k=0;k<4;++k) B[k]=a[j][(k+l)%4];\n\t\t\t\tgetans();\n\t\t\t}\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]++;\n\t\t}\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\twrite(ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 400 + 100;\n\nstruct Tile\n{\n\tint a[4];\n\tTile()\n\t{}\n\tTile(int x0, int x1, int x2, int x3)\n\t{\n\t\tint x[4] = {x0, x1, x2, x3};\n\t\tmemcpy(a, x, sizeof(x));\n\t}\n\tbool operator < (const Tile &s) const\n\t{\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tif(a[i] != s.a[i])\n\t\t\t\treturn a[i] < s.a[i];\n\t\treturn false;\n\t}\n};\n\nint n;\nTile s[MAXN];\nmap<Tile, int> cnt;\n\nvoid add(const Tile &s, int v)\n{\n\tfor(int i = 0; i < 4; i++)\n\t\tcnt[Tile(s.a[i], s.a[(i + 1) % 4], s.a[(i + 2) % 4], s.a[(i + 3) % 4])] += v;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tcin >> s[i].a[j];\n\t\tadd(s[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tadd(s[i], -1);\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tadd(s[i], -1);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tTile t[4] = {\n\t\t\t\t\tTile(s[j].a[k], s[j].a[(k + 3) % 4], s[i].a[1], s[i].a[0]),\n\t\t\t\t\tTile(s[j].a[(k + 3) % 4], s[j].a[(k + 2) % 4], s[i].a[2], s[i].a[1]),\n\t\t\t\t\tTile(s[j].a[(k + 2) % 4], s[j].a[(k + 1) % 4], s[i].a[3], s[i].a[2]),\n\t\t\t\t\tTile(s[j].a[(k + 1) % 4], s[j].a[k], s[i].a[0], s[i].a[3])\n\t\t\t\t};\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\ttmp *= cnt[t[l]], add(t[l], -1);\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tadd(t[l], 1);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tadd(s[i], 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(3)\n#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db double\n#define inf 100009\n#define infm 100009\n#define INF (ll)1e15\n#define mod 1000000007LL\n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\nint n,m,X,Y;\n\nll inv[inf];\nll getinv(ll x){\n\tint tmpx=(ll)x;\n/*\tif (inv[tmpx]){\n\t\treturn inv[tmpx];\n\t}*/\n\tll ans=1LL,k=mod-2LL;\n\twhile (k){\n\t\tif (k&1LL){\n\t\t\tans=(ans*x)%mod;\n\t\t}\n\t\tx=(x*x)%mod;\n\t\tk/=2LL;\n\t}\n//\tinv[tmpx]=ans;\n\treturn ans;\n}\n\nstruct edge{\n\tint y,nxt;\n\tedge(){}\n\tedge(int yy,int nn){\n\t\ty=yy,nxt=nn;\n\t}\n}e[inf*2];\nint head[inf],ecnt;\n\nvoid addedge(int x,int y){\n\tecnt++;\n\te[ecnt]=edge(y,head[x]);\n\thead[x]=ecnt;\n\treturn;\n}\n\nll deg[inf],dp[inf];\nbool vis[inf];\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tif (u==X){\n\t\tdp[u]=1LL;\n\t\treturn;\n\t}\n\telse if (u==Y){\n\t\treturn;\n\t}\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].y;\n\t\tif (!vis[v]){\n\t\t\tdfs(v);\n\t\t}\n\t\tdp[u]=(dp[u]+getinv(deg[v])*dp[v]%mod)%mod;\n\t}\n\treturn;\n}\n\nint main(){\n\trd(n) rd(m) rd(X) rd(Y)\n\tint x,y;\n\tfor (int i=1;i<=m;i++){\n\t\trd(x) rd(y)\n\t\taddedge(x,y);\n\t\tdeg[y]++;\n\t}\n\tll ans=1LL;\n\tfor (int i=2;i<=n;i++){\n\t\tans=(ans*deg[i])%mod;\n\t}\n\tif (X==Y || Y==1){\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tdfs(1);\n\tans=(ans+ans*dp[1]%mod*getinv(deg[Y])%mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n  >         File: C.cc\n  >       Author: lyyllyyl\n  >         Mail: riho.yoshioka@yandex.com\n  > Created Time: Sat 15 Oct 2016 08:29:45 PM CST\n*************************************************************************/\n#include <bits/stdc++.h>\nusing LL = long long;\n\nconstexpr int N = 444;\nstd::vector<int> color[N];\nstd::map<std::vector<int>, int> has;\n\nint corner[8];\nint use[4][4] = {\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid Dfs(int dep, LL& ans, LL res = 1) {\n  if (dep == 4) ans += res;\n  else {\n    std::vector<int> tmp(4);\n    for (int i = 0; i < 4; ++i) tmp[i] = corner[use[dep][i]];\n    for (int k = 0; k < 4; ++k) {\n      if (has.count(tmp)) {\n        int cnt = has[tmp];\n        has[tmp]--;\n        Dfs(dep + 1, ans, res * cnt);\n        has[tmp]++;\n      }\n      std::rotate(tmp.begin(), tmp.begin() + 1, tmp.end());\n    }\n  }\n}\n\nLL solve(int a, int b) {\n  for (int i = 0; i < 4; ++i) {\n    corner[i] = color[a][i];\n    corner[i + 4] = color[b][i];\n  }\n  LL ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    Dfs(0, ans);\n    std::rotate(corner + 4, corner + 5, corner + 8);\n  }\n  return ans;\n}\n\nint main() {\n  std::ios::sync_with_stdio(0);\n  int n;\n  std::cin >> n;\n  for (int i = 0; i < n; ++i) {\n    color[i].resize(4);\n    for (int j = 0; j < 4; ++j) {\n      std::cin >> color[i][j];\n    }\n    has[color[i]]++;\n  }\n  LL answer = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      has[color[i]]--, has[color[j]]--;\n      answer += solve(i, j);\n      has[color[i]]++, has[color[j]]++;\n      //std::cerr << \"# i << ' ' << j << ' ' << answer # is \" << i << ' ' << j << ' ' << answer << std::endl;\n    }\n    has[color[i]]--;\n    if (has[color[i]] == 0) has.erase(color[i]);\n  }\n  std::cout << answer << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 500\n\nvector<vector<int>> a;\nmap<vector<int>, ll> cnt, mul;\n\nvoid norm(vector<int> &a){\n\tvector<int> b(a);\n\trep(i, 4){\n\t\tif(b<a) a = b;\n\t\trotate(b.begin(), b.begin()+1, b.end());\n\t}\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\ta = vector<vector<int>>(n, vector<int>(4));\n\trep(i, n){\n\t\trep(j, 4) cin>>a[i][j];\n\t}\n\trep(i, n) norm(a[i]);\n\t//sort(all(a));\n\trep(i, n) ++cnt[a[i]];\n\trep(i, n){\n\t\tvector<int> b(a[i]);\n\t\tif(mul[b]) continue;\n\t\trep(j, 4){\n\t\t\tif(b==a[i]) ++mul[b];\n\t\t\trotate(b.begin(), b.begin()+1, b.end());\n\t\t}\n\t}\n\tll res = 0;\n\trep(i, n){\n\t\t--cnt[a[i]];\n\t\tvector<int> ai(a[i]);\n\t\trep(j, i){\n\t\t\t--cnt[a[j]];\n\t\t\tvector<int> aj(a[j]); swap(aj[1], aj[3]);\n\t\t\trep(k, 4){\n\t\t\t\tvector<vector<int>> b(4, vector<int>(4));\n\t\t\t\trep(l, 4){\n\t\t\t\t\tb[l][1] = ai[(l+0)%4];\n\t\t\t\t\tb[l][0] = ai[(l+1)%4];\n\t\t\t\t\tb[l][3] = aj[(l+1)%4];\n\t\t\t\t\tb[l][2] = aj[(l+0)%4];\n\t\t\t\t\tnorm(b[l]);\n\t\t\t\t}\n\t\t\t\t/*cerr<<\"dubug: \"<<i<<\" \"<<j<<endl;\n\t\t\t\tcerr<<ai<<endl;\n\t\t\t\tcerr<<aj<<endl;\n\t\t\t\trep(l, 4) cerr<<b[l]<<endl;\n\t\t\t\tcerr<<endl;*/\n\t\t\t\tll r = 1;\n\t\t\t\trep(l, 4){\n\t\t\t\t\tr *= cnt[b[l]]--*mul[b[l]];\n\t\t\t\t}\n\t\t\t\tres += r;\n\t\t\t\trep(l, 4) ++cnt[b[l]];\n\t\t\t\trotate(aj.begin(), aj.begin()+1, aj.end());\n\t\t\t}\n\t\t\t++cnt[a[j]];\n\t\t}\n\t\t++cnt[a[i]];\n\t}\n\tcout<<res/3<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nlong long calc(int a, int b, int c, int d){\n\tlong long r = 1024 * a + b;\n\tr = 1024 * r + c;\n\treturn 1024 * r + d;\n}\n\nlong long pack(int a, int b, int c, int d){\n\treturn min(min(calc(a, b, c, d), calc(b, c, d, a)), min(calc(c, d, a, b), calc(d, a, b, c)));\n}\n\nint getR(long long key){\n\tint c[4];\n\tfor(int i=0;i<4;i++){\n\t\tc[i] = key%1024;\n\t\tkey /= 1024;\n\t}\n\tif(c[0] == c[1] && c[1] == c[2] && c[2] == c[3]) return 4;\n\tif(c[0] == c[2] && c[1] == c[3]) return 2;\n\treturn 1;\n}\n\nlong long pow(int a, int p){\n\tlong long r = 1;\n\tfor(int i=0;i<p;i++) r *= a;\n\treturn r;\n}\n\nlong long fact(int f){\n\tlong long r = 1;\n\tfor(int i=2;i<=f;i++) r *= i;\n\treturn r;\n}\n\nint main(){\n\tint N;\n\tstatic int c[400][4];\n\tstatic long long comb[400][400];\n\tcomb[1][0] = comb[1][1] = 1;\n\tfor(int i=2;i<=400;i++){\n\t\tcomb[i][0] = 1;\n\t\tfor(int j=1;j<i;j++) comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\t\tcomb[i][i] = 1;\n\t}\n\twhile(cin >> N && N){\n\t\tmap<long long, int> num;\n\t\tlong long res = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<4;j++) cin >> c[i][j];\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tconst int* back = c[j];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tlong long key[4];\n\t\t\t\t\tkey[0] = pack(back[(k+1)%4], back[(k+0)%4], c[i][1], c[i][0]);\n\t\t\t\t\tkey[1] = pack(back[(k+0)%4], back[(k+3)%4], c[i][2], c[i][1]);\n\t\t\t\t\tkey[2] = pack(back[(k+3)%4], back[(k+2)%4], c[i][3], c[i][2]);\n\t\t\t\t\tkey[3] = pack(back[(k+2)%4], back[(k+1)%4], c[i][0], c[i][3]);\n\t\t\t\t\tsort(key, key+4);\n\t\t\t\t\tlong long backKey = pack(back[0], back[1], back[2], back[3]);\n\t\t\t\t\tlong long add = 1;\n\t\t\t\t\tfor(int l=0;l<4;){\n\t\t\t\t\t\tint cnt = 1;\n\t\t\t\t\t\tfor(int m=l+1;m<4 && key[l]==key[m];m++) ++cnt;\n\t\t\t\t\t\tint sel = 0;\n\t\t\t\t\t\tif(num.count(key[l])) sel = num[key[l]];\n\t\t\t\t\t\tif(key[l] == backKey) --sel;\n\t\t\t\t\t\tif(sel < cnt){\n\t\t\t\t\t\t\tadd = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tadd *= comb[sel][cnt] * pow(getR(key[l]), cnt) * fact(cnt);\n\t\t\t\t\t\tl += cnt;\n\t\t\t\t\t}\n\t\t\t\t\tres += add;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long k = pack(c[i][0], c[i][1], c[i][2], c[i][3]);\n\t\t\tif(num.count(k)) ++num[k];\n\t\t\telse num[k] = 1;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int weight[4] = {1, 1000, 1000000, 1000000000};\nconst int N = 505;\n\nstd::unordered_map<LL, int> num;\nLL q[N], ans;\n\ninline int get(LL s, int b) { return s / weight[b] % 1000; }\ninline void insert(LL s, int v = 1) {\n\tfor (int i = 0; i < 4; ++i)\n\t\tnum[s] += v, s = s % 1000 * weight[3] + s / 1000;\n}\ninline void remove(LL s) { insert(s, -1); }\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tint n; std::cin >> n;\n\tfor (int i = 0; i < n; insert(q[i++]))\n\t\tfor (int j = 0, x; j < 4; ++j) std::cin >> x, q[i] += (LL) x * weight[j];\n\tfor (int i = 0; i < n; ++i) {\n\t\tremove(q[i]);\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tremove(q[j]);\n\t\t\tint up[5], down[5]; LL s[4];\n\t\t\tfor (int k = 0; k < 4; ++k) up[3 - k] = get(q[i], k); up[4] = up[0];\n\t\t\tfor (int k = 0; k < 4; ++k) down[k] = get(q[j], k); down[4] = down[0];\n\t\t\tfor (int shift = 0; shift < 4; ++shift) {\n\t\t\t\tLL prod = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\ts[k] = up[k] + up[k + 1] * 1000 + down[k + 1] * 1000000 + down[k] * 1000000000LL;\n\t\t\t\t\tprod *= num[s[k]], remove(s[k]);\n\t\t\t\t}\n\t\t\t\tans += prod;\n\t\t\t\tfor (int k = 0; k < 4; ++k) insert(s[k]);\n\t\t\t\tint t = up[3]; up[3] = up[2], up[2] = up[1], up[1] = up[0], up[4] = up[0] = t;\n\t\t\t}\n\t\t\tinsert(q[j]);\n\t\t}\n\t\tinsert(q[i]);\n\t}\n\tstd::cout << ans / 3 << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 400 + 5\n#define K 5\n#define base 1000\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, ans, C[N][K];\nunordered_map <int, int> M;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Hash(int a, int b, int c, int d){\n    int ans = 0;\n    ans = ans * base + a, ans = ans * base + b, ans = ans * base + c, ans = ans * base + d;\n    return ans;\n}\nvoid update(int val, int x){\n    int a, b, c, d;\n    d = val % base, val /= base;\n    c = val % base, val /= base;\n    b = val % base, val /= base;\n    a = val % base, val /= base;\n    M[Hash(a, b, c, d)] += x;\n    M[Hash(b, c, d, a)] += x;\n    M[Hash(c, d, a, b)] += x;\n    M[Hash(d, a, b, c)] += x;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n){\n        C[i][0] = read(), C[i][1] = read(), C[i][2] = read(), C[i][3] = read();\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    rep(i, 1, n){\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), -1);\n        rep(j, i + 1, n){\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), -1);\n            rep(k, 0, 3){\n                int AA = Hash(C[i][0], C[i][3], C[j][k], C[j][(3 + k) % 4]); if(!AA) continue;\n                int BB = Hash(C[i][3], C[i][2], C[j][(1 + k) % 4], C[j][k]); if(!BB) continue;\n                int CC = Hash(C[i][2], C[i][1], C[j][(2 + k) % 4], C[j][(1 + k) % 4]); if(!CC) continue;\n                int DD = Hash(C[i][1], C[i][0], C[j][(3 + k) % 4], C[j][(2 + k) % 4]); if(!DD) continue;\n                int a, b, c, d;\n                a = M[AA], update(AA, -1);\n                b = M[BB], update(BB, -1);\n                c = M[CC], update(CC, -1);\n                d = M[DD], update(DD, -1);\n                if(a > 0 && b > 0 && c > 0 && d > 0) ans += a * b * c * d;\n                update(AA, 1), update(BB, 1), update(CC, 1), update(DD, 1);\n            }\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), 1);\n        }\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    printf(\"%lld\", ans / 3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    /*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*/\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay2(v);\n    }\n    int ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    /*tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];*/\n                    tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\nstruct tile\n{\n\tint c[4];\n\ttile () {}\n\ttile (int c0,int c1,int c2,int c3)\n\t{\n\t\tc[0]=c0;\n\t\tc[1]=c1;\n\t\tc[2]=c2;\n\t\tc[3]=c3;\n\t\twork();\n\t}\n\tint way()\n\t{\n\t\tint ret=1;\n\t\tif(c[0]==c[2]&&c[1]==c[3])\n\t\t{\n\t\t\tret*=2;\n\t\t\tif(c[0]==c[1])\n\t\t\t\tret*=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const tile &t)const\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t\tif(c[i]!=t.c[i])\n\t\t\t\treturn c[i]<t.c[i];\n\t\treturn false;\n\t}\n\tvoid work()\n\t{\n\t\tint cc[4],h;\n\t\tbool ok[4];\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tcc[i]=c[i];\n\t\t\tok[i]=true;\n\t\t}\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\th=1000;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(ok[j]&&cc[(j+i)&3]<h)\n\t\t\t\t\th=cc[(j+i)&3];\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(cc[(j+i)&3]!=h)\n\t\t\t\t\tok[j]=false;\n\t\t}\n\t\tfor(int i=0;i<4;i++)\n\t\t\tif(ok[i])\n\t\t\t{\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tc[j]=cc[(j+i)&3];\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}t[404];\nmap <tile,int> cnt;\ntile tt[10];\nint tn;\nint main()\n{\n\tint n;\n\tlong long ans=0,now=0;\n\ttile nd;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&t[i].c[j]);\n\t\tt[i].work();\n\t\tcnt[t[i]]++;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt[t[i]]--;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tcnt[t[j]]--;\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\ttn=0;\n\t\t\t\tnow=1;\n\t\t\t\tfor(int kk=7;kk>=4&&now;kk--)\n\t\t\t\t{\n\t\t\t\t\tnd=tile(t[i].c[(7-kk)&3],t[j].c[(kk+k)&3],t[j].c[(kk-1+k)&3],t[i].c[(8-kk)&3]);\n\t\t\t\t\tif(cnt[nd])\n\t\t\t\t\t{\n\t\t\t\t\t\tnow*=cnt[nd];\n\t\t\t\t\t\tnow*=nd.way();\n\t\t\t\t\t\ttt[++tn]=nd;\n\t\t\t\t\t\tcnt[nd]--;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnow=0;\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t\tfor(int kk=1;kk<=tn;kk++)\n\t\t\t\t\tcnt[tt[kk]]++;\n\t\t\t}\n\t\t\tcnt[t[j]]++;\n\t\t}\n\t\tcnt[t[i]]++;\n\t}\n\tprintf(\"%lld\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP2D(a, n, m) REP(i, n) REP(j, m) printf(\"%lld%c\", a[i][j], j + 1 == m ? '\\n' : ' '); puts(\"\")\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n#define COLOR(c, i) (c >> (10 * (3 - (i))) & 1023)\n\ntypedef long long ll;\n\nconst int N_MAX = 400;\n\nint N;\nll C[N_MAX][4];\n\nint M;\nll h[N_MAX];\nmap<ll, ll> par;\nmap<ll, ll> tb;\nmap<ll, ll> crd;\n\nchar buf[64];\nchar buf2[64];\n\nchar *dumpC(ll c, char * buf) {\n  snprintf(\n    buf,\n    64,\n    \"%lld-%lld-%lld-%lld\",\n    COLOR(c, 0),\n    COLOR(c, 1),\n    COLOR(c, 2),\n    COLOR(c, 3)\n  );\n  return buf;\n}\n\nll perm(ll n, ll k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  ll ret = 1;\n  REP(i, k) ret = ret * (n - i);\n  return ret;\n}\n\nvoid solve() {\n  REP(i, N) {\n    ll c = 0;\n    REP(d, 4) c = c << 10 | C[i][d];\n    ll cs[4];\n    REP(d, 4) {\n      cs[d] = c;\n      c = (c << 10 | c >> 30) & ((1LL << 40) - 1);\n    }\n    c = *min_element(cs, cs + 4);\n    tb[c]++;\n    crd[c] = count(cs, cs + 4, c);\n    REP(d, 4) par[cs[d]] = c;\n  }\n\n  M = 0;\n  ITR(tb, it) h[M++] = it->first;\n\n  // ITR(par, it) {\n  //   ll c = it->first, p = it->second;\n  //   printf(\"par[%s]: %s\\n\", dumpC(c, buf), dumpC(p, buf2));\n  // }\n  // ITR(tb, it) {\n  //   ll c = it->first;\n  //   printf(\"tb[%s]: %lld\\n\", dumpC(c, buf), it->second);\n  // }\n  // ITR(crd, it) {\n  //   ll c = it->first;\n  //   printf(\"crd[%s]: %lld\\n\", dumpC(c, buf), it->second);\n  // }\n\n  ll ans = 0;\n  REP(i, M) REP(j, M) {\n    ll hi = h[i], hj = h[j];\n    if (i == j && tb[hi] <= 1) continue;\n    // printf(\"i: %d(%s), j: %d(%s)\\n\", i, dumpC(hi, buf), j, dumpC(hj, buf2));\n    map<ll, ll> tbh;\n    tbh[hi]++; tbh[hj]++;\n    ll pth = tb[hi] * (tb[hj] - (i == j ? 1 : 0));\n    // printf(\"pth: %lld * %lld = %lld\\n\", tb[hi], tb[hj] - (i == j ? 1 : 0), pth);\n    REP(k, 4) {\n      // printf(\" k: %d\\n\", k);\n      bool ok = true;\n      map<ll, ll> tbs;\n      REP(d, 4) {\n        ll s = 0;\n        s |= COLOR(hi, (1 + d) % 4) << 30;\n        s |= COLOR(hi, d % 4) << 20;\n        s |= COLOR(hj, (4 - d + k) % 4) << 10;\n        s |= COLOR(hj, (3 - d + k) % 4);\n        if (par.count(s) == 0) {\n          ok = false;\n          break;\n        }\n        tbs[par[s]]++;\n      }\n      if (!ok) continue;\n      ll pts = 1;\n      ITR(tbs, it) {\n        ll s = it->first;\n        ll use = it->second;\n        ll cmp = perm(tb[s] - tbh[s], use);\n        REP(i, use) cmp *= crd[s];\n        // if (cmp != 0) {\n        //   printf(\"  s: %s, avail: %lld, use: %lld, crd: %lld, cp: %lld\\n\",\n        //     dumpC(s, buf), tb[s] - tbh[s], use, crd[s], cmp);\n        // }\n        pts *= cmp;\n      }\n      // if (pts != 0) printf(\" pts: %lld\\n\", pts);\n      ans += pts * pth;\n    }\n  }\n\n  printf(\"%lld\\n\", ans / 6);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) REP(j, 4) scanf(\"%lld\", &C[i][j]);\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nvi normarize(const vi &v)\n{\n    vector<vi> r;\n    rep(i,4)\n    {\n        vi t;\n        rep(j,4) t.pb(v[(i+j)%4]);\n        r.pb(t);\n    }\n    sort(all(r));\n    return r[0];\n}\n\nvoid print(const vi &v)\n{\n    rep(i,4)\n    {\n        if(i) printf(\" \");\n        printf(\"%d\", v[i]);\n    }\n    printf(\"\\n\");\n}\n\ninline ll P(int n, int r)\n{\n    if(n<r) return 0;\n\n    ll ret=1;\n    rep(i,r) ret*=n-i;\n    return ret;\n}\n\ninline ll POW(int x, int n)\n{\n    ll ret=1;\n    rep(i,n) ret*=x;\n    return ret;\n}\n\ninline ll DIM(const vi &v)\n{\n    if(v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) return 4;\n    else if(v[0]==v[2] && v[1]==v[3]) return 2;\n    return 1;\n}\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<vi> c(n,vi(4));\n    rep(i,n)rep(j,4) scanf(\" %d\", &c[i][j]);\n\n    map<vi,int> ct;\n    rep(i,n)\n    {\n        c[i]=normarize(c[i]);\n        if(ct.find(c[i])==ct.end()) ct[c[i]]=1;\n        else ++ct[c[i]];\n    }\n\n    ll ans=0;\n    // 上面i, 下面j\n    rep(i,n)rep(j,i)\n    {\n        if(i==j) continue;\n        // 下面の向きを設定\n        rep(k,4)\n        {\n            vi u;\n            rep(x,4) u.pb(c[j][(k+x)%4]);\n            swap(u[1],u[3]);\n\n            // printf(\"c[i]: \");\n            // print(c[i]);\n            // printf(\"u: \");\n            // print(u);\n\n            vector<vi> sides(4);\n            map<vi,int> sides_ct;\n            rep(x,4)\n            {\n                vi t(4);\n                t[0]=c[i][(x+1)%4];\n                t[1]=c[i][x];\n                t[2]=u[x];\n                t[3]=u[(x+1)%4];\n                // print(t);\n                t=normarize(t);\n\n                sides[x]=t;\n                if(sides_ct.find(t)==sides_ct.end()) sides_ct[t]=1;\n                else ++sides_ct[t];\n            }\n\n            // printf(\"   go (%d,%d,%d)\\n\",i,j,k);\n            ll add=1;\n            for(const auto &x:sides_ct)\n            {\n                vi key=x.fi;\n                int value=x.se;\n\n                // printf(\"key = \");\n                // print(key);\n                // printf(\"value= %d\\n\", value);\n\n                // 使ってないタイルのうち当てはめられる個数\n                int num=ct[key];\n                if(c[i]==key) --num;\n                if(c[j]==key) --num;\n\n                // 選び方、向き、位置\n                add*=P(num,value)*POW(DIM(key),value);\n            }\n            ans+=add;\n        }\n    }\n\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef ONLINE_JUDGE\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N; cin >> N;\n    vector<array<int, 4>> C(N);\n    rep(i,N) rep(j,4) cin >> C[i][j];\n\n    array<int, 4> A,B,E;\n    vector<array<int, 4>> D;\n    vector<int> uni,cnt,kai;\n    ll ans = 0;\n    rep(i,N) {\n        rep(k,4) A[k] = C[i][k];\n        rep(j,i) {\n            rep(_,4) {//下の面の回転\n                D.clear();\n                uni.clear();\n                cnt.clear();\n                kai.clear();\n                rep(l,4) B[l] = C[j][(l+_)%4];\n\n                rep(l,4) {\n                    E[0] = A[3-l];\n                    E[1] = A[(6-l)%4];\n                    E[2] = B[(1+l)%4];\n                    E[3] = B[l];\n                    bool same = false;\n                    rep(w,SZ(D)) {\n                        rep(y,4) {\n                            bool same2 = true;\n                            rep(x,4) {\n                                if (D[w][x] != E[(x+y)%4]) same2 = false;\n                            }\n                            if (same2) {\n                                same = true;\n                                uni[w]++;\n                                break;\n                            }\n                        }\n                        if (same) break;\n                    }\n                    if (!same) {\n                        D.emplace_back(E);\n                        uni.emplace_back(1);\n                        cnt.emplace_back(0);\n                        kai.emplace_back(1);\n                    }\n                }\n\n                rep(w,SZ(D)) {\n                    if (D[w][0]==D[w][1] and D[w][1]==D[w][2] and D[w][2]==D[w][3]) kai[w] = 4;\n                    else if (D[w][0]==D[w][2] and D[w][1]==D[w][3]) kai[w] = 2;\n                }\n\n                rep(k,N) {\n                    if (k==i or k==j) continue;\n                    rep(w,SZ(D)) {\n                        bool same2 = false;\n                        rep(x,4) {\n                            bool same = true;\n                            rep(y,4) {\n                                if (D[w][y]!=C[k][(x+y)%4]) same = false;\n                            }\n                            if (same) {\n                                cnt[w]++;\n                                if (same) same2 = true; \n                                break;\n                            } \n                        }\n                        if (same2) break;\n                    } \n                }\n\n                ll val = 1;\n                rep(w,SZ(D)) {\n                    ll c = cnt[w];\n                    rep(x,uni[w]) {\n                        val *= c;\n                        c--;\n                        val *= kai[w];\n                    }\n                }\n\n                ans += val;\n            }\n        }\n    }\n\n    cout << ans/3 << ln;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 405;\n\nint col[MAX][4];\n\nvoid rotate(int tmp[4])\n{\n  int poc = tmp[0];\n  for (int i=0; i<3; i++)\n    tmp[i] = tmp[i+1];\n  tmp[3] = poc;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i=0; i<n; i++)\n    for (int j=0; j<4; j++)\n      scanf(\"%d\", &col[i][j]);\n\n  ll rje = 0;\n  for (int i=0; i<n; i++) {\n    for (int j=i+1; j<n; j++) {\n      for (int rot=0; rot<4; rot++) {\n        int ima[4] = {0, 0, 0, 0};\n        int isti[4][4];\n        int sus[4] = {col[j][1], col[j][0], col[j][3], col[j][2]};\n        int kocka[4][4];\n        for (int l=0; l<4; l++) {\n          kocka[l][0] = col[i][l];\n          kocka[l][1] = col[i][(l+1)%4];\n          kocka[l][2] = sus[(l+1)%4];\n          kocka[l][3] = sus[l];\n        }\n\n        memset(isti, 0, sizeof isti);\n\n        for (int k=i+1; k<n; k++) {\n          if (k == j)\n            continue;\n          \n          int da[4] = {0, 0, 0, 0};\n          for (int r=0; r<4; r++) {\n            for (int l=0; l<4; l++) {\n              if (!da[l] &&\n                  col[k][(l+0)&3] == kocka[l][0] &&\n                  col[k][(l+3)&3] == kocka[l][1] &&\n                  col[k][(l+2)&3] == kocka[l][2] &&\n                  col[k][(l+1)&3] == kocka[l][3]) {\n                da[l] = 1;\n              }\n            }\n\n            rotate(col[k]);\n          }\n\n          for (int l=0; l<4; l++) {\n            if (!ima[l] && da[l]) {\n              for (int dr=0; dr<4; dr++)\n                if (da[dr])\n                  isti[dr][l] = 1;\n            }\n            ima[l] += da[l];\n          }\n        }\n\n        int koef = 1;\n        for (int l=0; l<4; l++) {\n          int poc[4] = { col[i][l%4], col[i][(l+1)%4], sus[(l+1)%4], sus[l] };\n          int tmp[4];\n          memcpy(tmp, poc, sizeof tmp);\n\n          int br=0;\n          for (int r=0; r<4; r++) {\n            if (memcmp(tmp, poc, sizeof tmp) == 0)\n              br++;\n\n            rotate(tmp);\n          }\n\n          koef *= br;\n        }\n\n        ll tmp = 1;\n        for (int l=0; l<4; l++) {\n          tmp *= ima[l];\n          for (int k=0; k<4; k++)\n            if (isti[l][k])\n              ima[k]--;\n        }\n\n        rje += tmp * koef;\n        rotate(col[j]);\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", rje);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back()\n#define ppf pop_front()\n#define all(vec) vec.begin(), vec.end()\n#define fol(i,a,b) for(int i=a;i<b;i++)\n#define loop(i,a,b) for(int i=a;i>=b;i--)\n#define forr(x,arr) for(auto& x:arr)\n#define mod 1000000007\n#define INF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-7\n#define sz(x) ((lli)(x).size())\n\nusing   lli     =   long long;\nusing   lld     =   long double;\nusing   ulli    =   unsigned long long int;\nusing   pll     =   pair<lli, lli>;\nusing   ttt     =   pair<lli, pll>;\nusing   vttt    =   vector<ttt>;\nusing   vll     =   vector<pll>;\nusing   vl      =   vector<lli>;\nusing   vi      =   vector<int>;\nusing   vvi     =   vector<vector<int>>;\nusing   cd      =   complex<lld>;\nconst double PI = acos(-1);\n\n#ifdef tejasp\n#include \"library/debugger.cpp\"\n#else\n#define trace(...) {}\n#define cotra(...) {}\n#define end_routine() {}\n#define localsys 0\n#define endl '\\n'\n#endif\n\n#define ca first.first\n#define cb first.second\n#define cc second.first\n#define cd second.second\n#define node pair<pll,pll>\n\nnode arr[410];\nlli ans=0;\nmap<node,lli> mp;\n\nvoid rotate(node &cur)\n{\n    lli temp=cur.ca;\n    cur.ca=cur.cb;\n    cur.cb=cur.cc;\n    cur.cc=cur.cd;\n    cur.cd=temp;\n}\n\nint calc(node &a, node &b)\n{\n    int ans=0;\n    fol(i,0,4)\n    {\n        if(a==b) ans++;\n        rotate(b);\n    }\n    return ans;\n}\n\nnode reverse(node n)\n{\n    swap(n.cb,n.cd);\n    return n;\n}\n\nvoid upd(node &l1, node &r1)\n{\n    node lef=reverse(l1), rig=r1;\n    node uu({{lef.ca,lef.cb},{rig.cb,rig.ca}});\n    node dd({{lef.cb,lef.cc},{rig.cc,rig.cb}});\n    node ll({{lef.cc,lef.cd},{rig.cd,rig.cc}});\n    node rr({{lef.cd,lef.ca},{rig.ca,rig.cd}});\n    lli res1=mp[uu];\n    lli res2=mp[dd];\n    lli res3=mp[ll];\n    lli res4=mp[rr];\n    res1-=calc(uu,l1)+calc(uu,r1);\n    res2-=calc(dd,l1)+calc(dd,r1)+calc(dd,uu);\n    res3-=calc(ll,l1)+calc(ll,r1)+calc(ll,uu)+calc(ll,dd);\n    res4-=calc(rr,l1)+calc(rr,r1)+calc(rr,uu)+calc(rr,dd)+calc(rr,ll);\n    ans+=(res1*res2*res3*res4);\n}\n\nint tejas_919(int kkkk)\n{\n    lli n, m, k, q, u, v, temp=0;\n    cin>>n;\n    fol(i,0,n)\n    {\n        cin>>m>>k>>u>>v;\n        arr[i]=node({{m,k},{u,v}});\n        fol(j,0,4)\n        {\n            mp[arr[i]]++;\n            rotate(arr[i]);\n        }\n    }\n    fol(i,0,n)\n    {\n        fol(j,i+1,n)\n        {\n            fol(k,0,4)\n            {\n                upd(arr[i],arr[j]);\n                rotate(arr[j]);\n            }\n        }\n    }\n    ans/=3;\n    cout<<ans<<endl;\n    return 0;\n}\n\nsigned main()\n{\n    #ifdef tejasp\n            freopen(\"input.txt\", \"rt\", stdin);\n            freopen(\"output.txt\", \"wt\", stdout);\n    #endif\n    if(!localsys) { ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); }\n    cout << fixed << setprecision(10);\n    int t=1;\n    //cin>>t;\n    fol(i,0,t) { tejas_919(i+1); }\n    end_routine();\n    if(localsys) system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<algorithm>\nusing namespace std;\nlong get(int a,int b,int c,int d)\n{\n\tlong ret=a*1000000000L+b*1000000L+c*1000L+d;\n\tret=min(ret,b*1000000000L+c*1000000L+d*1000L+a);\n\tret=min(ret,c*1000000000L+d*1000000L+a*1000L+b);\n\tret=min(ret,d*1000000000L+a*1000000L+b*1000L+c);\n\treturn ret;\n}\nmap<long,set<int> >M;\nint a[400],b[400],c[400],d[400];\nint N;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tM[get(a[i],b[i],c[i],d[i])].insert(i);\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tswap(a[j],b[j]);\n\t\t\t\tswap(b[j],c[j]);\n\t\t\t\tswap(c[j],d[j]);\n\t\t\t\tlong t[4]={\n\t\t\t\t\tget(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tget(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tget(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tget(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(t[I]==t[J])cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tif(M.find(t[k])==M.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint C=M[t[k]].size();\n\t\t\t\t\tif(M[t[k]].find(i)!=M[t[k]].end())C--;\n\t\t\t\t\tif(M[t[k]].find(j)!=M[t[k]].end())C--;\n\t\t\t\t\tint L=1;\n\t\t\t\t\tif(t[k]==t[k]%1000*1001001001L)L=4;\n\t\t\t\t\telse if(t[k]==t[k]%1000000*1000001L)L=2;\n\t\t\t\t\tfor(int l=0;l<cc[k];l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=now*(C-l)*L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\ngp_hash_table<ll, int> dp;\n\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        piipii p1 = c[i];\n        del(p1);\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p2 = c[j];\n            del(p2);\n            for(int k=0;k<4;k++){\n                ll res = 1;\n                piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                if(dp.find(get_idx(tmp1)) != dp.end()){\n                    res *= dp[get_idx(tmp1)];\n                    del(tmp1);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp2)) != dp.end()){\n                    res *= dp[get_idx(tmp2)];\n                    del(tmp2);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp3)) != dp.end()){\n                    res *= dp[get_idx(tmp3)];\n                    del(tmp3);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp4)) != dp.end()){\n                    res *= dp[get_idx(tmp4)];\n                    del(tmp4);\n                }\n                else res = 0;\n\n                ans += res;\n\n                if(dp.find(get_idx(tmp1)) != dp.end()){\n                    add(tmp1);\n                }\n                if(dp.find(get_idx(tmp2)) != dp.end()){\n                    add(tmp2);\n                }\n                if(dp.find(get_idx(tmp3)) != dp.end()){\n                    add(tmp3);\n                }\n                if(dp.find(get_idx(tmp4)) != dp.end()){\n                    add(tmp4);\n                }\n\n                p2 = rotate(p2);\n            }\n            add(p2);\n        }\n        add(p1);\n    }\n    printf(\"%lld\\n\", ans/6);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define llint long long\n\nusing namespace std;\n\nstruct Tile{\n\tint c[4];\n\tTile(){}\n\tTile(int a, int b, int C, int d){\n\t\tc[0] = a, c[1] = b, c[2] = C, c[3] = d;\n\t}\n\tTile(int a[]){\n\t\tfor(int i = 0; i < 4; i++) c[i] = a[i];\n\t}\n\tTile rot(){\n\t\tTile tmp;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ttmp.c[i] = c[(i+1)%4];\n\t\t}\n\t\treturn tmp;\n\t}\n\tbool equal(Tile &obj){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(c[i] != obj.c[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool similar(Tile &obj)\n\t{\n\t\tTile tmp = obj;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) return true;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn false;\n\t}\n\tint sym()\n\t{\n\t\tint ret = 0;\n\t\tTile tmp = *this;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) ret++;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn ret;\n\t}\n\tbool operator<(const Tile& obj)const{\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(c[i] < obj.c[i]) return true;\n\t\t\tif(c[i] > obj.c[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n\t\t\n\tvoid reg(){\n\t\tint a[4];\n\t\tfor(int i = 0; i < 4; i++) a[i] = c[i];\n\t\tTile tmp = *this;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tif(a[j] < tmp.c[j]) break;\n\t\t\t\tif(a[j] > tmp.c[j]){\n\t\t\t\t\tfor(int k = 0; k < 4; k++) a[k] = tmp.c[k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) c[i] = a[i];\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i = 0; i < 4; i++) cout << c[i] << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N;\nTile tile[405];\nmap<Tile, int> mp;\n\nint parent[4];\nvoid init(){\n\tfor(int i = 0; i < 4; i++) parent[i] = i;\n}\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nllint perm(llint n, llint k)\n{\n\tllint ret = 1;\n\tfor(int i = 0; i < k; i++){\n\t\tret *= n-i;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint c[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < 4; j++) cin >> c[j];\n\t\ttile[i] = Tile(c);\n\t\ttile[i].reg();\n\t}\n\t\n\tfor(int i = 0; i < N; i++) mp[tile[i]]++;\n\t\n\tllint ans = 0;\n\tllint cnt[4];\n\tfor(int i = 0; i < N; i++){\n\t\tmp[tile[i]]--;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\t\n\t\t\tTile t = tile[j];\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\n\t\t\t\tTile need[4];\n\t\t\t\tneed[0] = Tile(tile[i].c[1], tile[i].c[0], t.c[1], t.c[0]);\n\t\t\t\tneed[1] = Tile(tile[i].c[2], tile[i].c[1], t.c[0], t.c[3]);\n\t\t\t\tneed[2] = Tile(tile[i].c[3], tile[i].c[2], t.c[3], t.c[2]);\n\t\t\t\tneed[3] = Tile(tile[i].c[0], tile[i].c[3], t.c[2], t.c[1]);\n\t\t\t\tfor(int l = 0; l < 4; l++) need[l].reg();\n\t\t\t\t\n\t\t\t\tllint cnt[4];\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tcnt[l] = mp[need[l]];\n\t\t\t\t\tif(tile[j].similar(need[l])) cnt[l]--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinit();\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\tif(l >= m) continue;\n\t\t\t\t\t\tif(same(l, m)) continue;\n\t\t\t\t\t\tif(need[l].similar(need[m])) unite(l, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tllint cnum[4];\n\t\t\t\tfor(int i = 0; i < 4; i++) cnum[i] = 0;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tcnum[root(i)]++;\n\t\t\t\t}\n\t\t\t\tllint tmp = 1;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tif(cnum[i]) tmp *= perm(cnt[i], cnum[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++) tmp *= need[i].sym();\n\t\t\t\tans += tmp;\n\t\t\t\t\n\t\t\t\tt = t.rot();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define A 1000000000LL\n#define B 1000000LL\n#define C 1000LL\n\nll dp[404][5];\n\nll r(ll d) {\n\tll a1 = d / A;\n\tll b1 = d % A / B;\n\tll c1 = d % B / C;\n\tll d1 = d % C;\n\tll tmp = a1;\n\ta1 = b1;\n\tb1 = c1;\n\tc1 = d1;\n\td1 = tmp;\n\tll dd = a1 * A + b1 * B + c1 * C + d1;\n\treturn dd;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tvector<ll> v;\n\trep(i, 0, n) {\n\t\tll a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tll d1 = a * A + b * B + c * C + d;\n\t\tll d2 = r(d1);\n\t\tll d3 = r(d2);\n\t\tll d4 = r(d3);\n\t\tll dd = min(d1, min(d2, min(d3, d4)));\n\t\tv.pb(dd);\n\t}\n\tsort(all(v));\n\tll ans = 0;\n\trep(i, 0, n) {\n\t\trep(j, i + 1, n) {\n\t\t\t//print(v[i]);\n\t\t\tll a1 = v[i] / A;\n\t\t\tll b1 = v[i] % A / B;\n\t\t\tll c1 = v[i] % B / C;\n\t\t\tll d1 = v[i] % C;\n\t\t\tll a2 = v[j] / A;\n\t\t\tll b2 = v[j] % A / B;\n\t\t\tll c2 = v[j] % B / C;\n\t\t\tll d2 = v[j] % C;\n\t\t\trep(k, 0, 4) {\n\t\t\t\tll dd1 = d1 * A + c1 * B + c2 * C + d2;\n\t\t\t\tll dd2 = c1 * A + b1 * B + b2 * C + c2;\n\t\t\t\tll dd3 = b1 * A + a1 * B + a2 * C + b2;\n\t\t\t\tll dd4 = a1 * A + d1 * B + d2 * C + a2;\n\t\t\t\tll ddd1 = min(dd1, min(r(dd1), min(r(r(dd1)), r(r(r(dd1))))));\n\t\t\t\tll ddd2 = min(dd2, min(r(dd2), min(r(r(dd2)), r(r(r(dd2))))));\n\t\t\t\tll ddd3 = min(dd3, min(r(dd3), min(r(r(dd3)), r(r(r(dd3))))));\n\t\t\t\tll ddd4 = min(dd4, min(r(dd4), min(r(r(dd4)), r(r(r(dd4))))));\n\t\t\t\tvector<ll> v1;\n\t\t\t\tv1.pb(ddd1);\n\t\t\t\tv1.pb(ddd2);\n\t\t\t\tv1.pb(ddd3);\n\t\t\t\tv1.pb(ddd4);\n\t\t\t\tsort(all(v1));\n\t\t\t\tclr(dp,0);\n\t\t\t\tdp[0][0] = 1;\n\t\t\t\tll index = 1;\n\t\t\t\trep(l,j+1,n){\n\t\t\t\t\trep(m,0,4){\n\t\t\t\t\t\t//print(v1[m]);\n\t\t\t\t\t\tif(v[l]==v1[m]){\n\t\t\t\t\t\t\tll count = 1;\n\t\t\t\t\t\t\tif(v[l]==r(v1[m]))count++;\n\t\t\t\t\t\t\tif(v[l]==r(r(v1[m])))count++;\n\t\t\t\t\t\t\tif(v[l]==r(r(r(v1[m]))))count++;\n\t\t\t\t\t\t\tdp[index][m+1] += dp[index-1][m]*count;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[index][m] += dp[index][m];\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tans += dp[index-1][4];\n\t\t\t\tll tmp = a2;\n\t\t\t\ta2 = b2;\n\t\t\t\tb2 = c2;\n\t\t\t\tc2 = d2;\n\t\t\t\td2 = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int NMAX = 4e2 + 5;\nconst int CMAX = 1e3 + 0;\n\nint col[NMAX][4];\n\nmap<long long, int> cnt;\n\ninline long long encrypt( int arr[4] ) {\n    long long ans = numeric_limits<long long> :: max();\n    \n    for( int k = 0; k <= 3; k ++ ) {\n        ans = min( ans, 1LL * arr[(0 + k) % 4] * CMAX * CMAX * CMAX +\n                        1LL * arr[(1 + k) % 4] * CMAX * CMAX +\n                        1LL * arr[(2 + k) % 4] * CMAX +\n                        1LL * arr[(3 + k) % 4] );\n    }\n    \n    return ans;\n}\n\ninline long long encrypt( int a, int b, int c, int d ) {\n    int arr[4] = { a, b, c, d };\n    return encrypt( arr );\n}\n\ninline int countrot( int a, int b, int c, int d ) {\n    if( a == b && b == c&& c == d )\n        return 4;\n    if( a == c && b == d )\n        return 2;\n    return 1;\n}\n\nint main( void ) {\n    \n    int n;\n    cin >> n;\n    \n    for( int i = 1; i <= n; i ++ ) {\n        cin >> col[i][0] >> col[i][1] >> col[i][2] >> col[i][3];\n        cnt[encrypt( col[i] )] ++;\n    }\n    \n    long long ans = 0;\n    for( int i = 1; i <= n; i ++ ) {\n        for( int j = i + 1; j <= n; j ++ ) {\n            long long edg1 = encrypt( col[i] ), edg5 = encrypt( col[j] );\n            \n            cnt[edg1] --; cnt[edg5] --;\n            for( int k = 0; k <= 3; k ++ ) {\n                long long edg2 = encrypt( col[i][0], col[j][(1 + k) % 4], col[j][(0 + k) % 4], col[i][1] );\n                long long edg3 = encrypt( col[i][1], col[j][(0 + k) % 4], col[j][(3 + k) % 4], col[i][2] );\n                long long edg4 = encrypt( col[i][2], col[j][(3 + k) % 4], col[j][(2 + k) % 4], col[i][3] );\n                long long edg6 = encrypt( col[j][(1 + k) % 4], col[i][0], col[i][3], col[j][(2 + k) % 4] );\n                \n                long long aux = 1;\n                aux *= cnt[edg2] * countrot( col[i][0], col[j][(1 + k) % 4], col[j][(0 + k) % 4], col[i][1] ); cnt[edg2] --;\n                aux *= cnt[edg3] * countrot( col[i][1], col[j][(0 + k) % 4], col[j][(3 + k) % 4], col[i][2] ); cnt[edg3] --;\n                aux *= cnt[edg4] * countrot( col[i][2], col[j][(3 + k) % 4], col[j][(2 + k) % 4], col[i][3] ); cnt[edg4] --;\n                aux *= cnt[edg6] * countrot( col[j][(1 + k) % 4], col[i][0], col[i][3], col[j][(2 + k) % 4] ); cnt[edg6] --;\n                ans += aux; cnt[edg2] ++; cnt[edg3] ++; cnt[edg4] ++; cnt[edg6] ++;\n            }\n            \n            cnt[edg1] ++; cnt[edg5] ++;\n        }\n    }\n    \n    cout << ans / 3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            vector<pair<int,int>> updates;\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                updates.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(k!=i and k!=j){\n                    rep(i_,0,4){\n                        if(b&(1<<i_)) continue;\n                        rep(j_,0,4) if(match(rotatedC[k][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                ans+=rec(i+1,0);\n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n                for(auto& u:updates) memo[u.first][u.second]=-1;\n                updates.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define MAXN\t5005\n#define MAXV\t1000\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ngp_hash_table <long long, int> cnt;\nint n, a[MAXN], b[MAXN], c[MAXN], d[MAXN];\nlong long Hash(int a, int b, int c, int d) {\n\tlong long ans = a;\n\tans = ans * MAXV + b;\n\tans = ans * MAXV + c;\n\tans = ans * MAXV + d;\n\treturn ans;\n}\nint Count(int a, int b, int c, int d) {\n\treturn cnt[Hash(a, b, c, d)];\n}\nvoid Modify(int a, int b, int c, int d, int x) {\n\tcnt[Hash(a, b, c, d)] += x;\n\tcnt[Hash(b, c, d, a)] += x;\n\tcnt[Hash(c, d, a, b)] += x;\n\tcnt[Hash(d, a, b, c)] += x;\n}\nlong long Query(int a, int b, int c, int d, int A, int B, int C, int D) {\n\tlong long ans = 1;\n\tans *= Count(a, A, B, b);\n\tModify(a, A, B, b, -1);\n\tans *= Count(b, B, C, c);\n\tModify(b, B, C, c, -1);\n\tans *= Count(c, C, D, d);\n\tModify(c, C, D, d, -1);\n\tans *= Count(d, D, A, a);\n\tModify(d, D, A, a, -1);\n\tModify(a, A, B, b, 1);\n\tModify(b, B, C, c, 1);\n\tModify(c, C, D, d, 1);\n\tModify(d, D, A, a, 1);\n\treturn ans;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]), read(b[i]), read(c[i]), read(d[i]);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tModify(a[j], b[j], c[j], d[j], -1);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], d[j], c[j], b[j], a[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], a[j], d[j], c[j], b[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], b[j], a[j], d[j], c[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], c[j], b[j], a[j], d[j]);\n\t\t\tModify(a[j], b[j], c[j], d[j], 1);\n\t\t}\n\t\tModify(a[i], b[i], c[i], d[i], 1);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 401;\nconst int K = 5000;\nconst int b = 1000;\nint c[N][4], a[N][4], dp[N][20], d[N], v[N], q[N][20];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        for (int j = 0; j < 4; j++){\n            cin >> c[i][j];\n           // c[i][j] = 0;\n        }\n        for (int j = 0; j < 4; j++){\n            a[i][j] = b * b * b * c[i][(j) % 4] + b * b * c[i][(j + 1) % 4] + b * c[i][(j + 2) % 4] + c[i][(j + 3) % 4];\n         //   cout << a[i][j] << \" \";\n        }\n     //   cout << endl;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = i + 1; j <= n; j++){\n            for (int r = 0; r < 4; r++){\n              //  cout << endl;\n                for (int k = 0; k < 4; k++) d[k] = c[j][(k + r) % 4];\n                v[0] = c[i][0] * b * b * b + d[1] * b * b + d[0] * b + c[i][1];\n                v[1] = d[1] * b * b * b + c[i][0] * b * b + c[i][3] * b + d[2];\n                v[2] = c[i][2] * b * b * b + d[3] * b * b + d[2] * b + c[i][3];\n                v[3] = c[i][1] * b * b * b + d[0] * b * b + d[3] * b + c[i][2];\n               // cout << v[0] << \" \" << v[1] << \" \" << v[2] << \" \" << v[3] << endl;\n                memset(dp, 0, sizeof dp);\n                memset(q, 0, sizeof q);\n                for (int l = i + 1; l <= n; l++){\n                    for (int t = 0; t < 4; t++){\n                        for (int k = 0; k < 4; k++){\n                            if (a[l][k] == v[t]) q[l][t]++;\n                        }\n                    }\n                }\n                dp[i][0] = 1;\n                for (int l = i + 1; l <= n; l++){\n                    if (l != j){\n                        dp[l][0] = dp[l - 1][0];\n                        dp[l][1] = dp[l - 1][1] + q[l][0] * dp[l - 1][0];\n                        dp[l][2] = dp[l - 1][2] + q[l][1] * dp[l - 1][0];\n                        dp[l][3] = dp[l - 1][3] + q[l][1] * dp[l - 1][1] + q[l][0] * dp[l - 1][2];\n                        dp[l][4] = dp[l - 1][4] + q[l][2] * dp[l - 1][0];\n                        dp[l][5] = dp[l - 1][5] + q[l][2] * dp[l - 1][1] + q[l][0] * dp[l - 1][4];\n                        dp[l][6] = dp[l - 1][6] + q[l][2] * dp[l - 1][2] + q[l][1] * dp[l - 1][4];\n                        dp[l][7] = dp[l - 1][7] + q[l][2] * dp[l - 1][3] + q[l][1] * dp[l - 1][5] + q[l][0] * dp[l - 1][6];\n                        dp[l][8] = dp[l - 1][8] + q[l][3] * dp[l - 1][0];\n                        dp[l][9] = dp[l - 1][9] + q[l][3] * dp[l - 1][1] + q[l][0] * dp[l - 1][8];\n                        dp[l][10] = dp[l - 1][10] + q[l][3] * dp[l - 1][2] + q[l][1] * dp[l - 1][8];\n                        dp[l][11] = dp[l - 1][11] + q[l][3] * dp[l - 1][3] + q[l][1] * dp[l - 1][9] + q[l][0] * dp[l - 1][10];\n                        dp[l][12] = dp[l - 1][12] + q[l][3] * dp[l - 1][4] + q[l][2] * dp[l - 1][8];\n                        dp[l][13] = dp[l - 1][13] + q[l][3] * dp[l - 1][5] + q[l][2] * dp[l - 1][9] + q[l][0] * dp[l - 1][12];\n                        dp[l][14] = dp[l - 1][14] + q[l][3] * dp[l - 1][6] + q[l][2] * dp[l - 1][10] + q[l][1] * dp[l - 1][12];\n                        dp[l][15] = dp[l - 1][15] + q[l][3] * dp[l - 1][7] + q[l][2] * dp[l - 1][11] + q[l][1] * dp[l - 1][13] + q[l][0] * dp[l - 1][14];\n                    } else{\n                        dp[l][0] = dp[l - 1][0];\n                        dp[l][1] = dp[l - 1][1];\n                        dp[l][2] = dp[l - 1][2];\n                        dp[l][3] = dp[l - 1][3];\n                        dp[l][4] = dp[l - 1][4];\n                        dp[l][5] = dp[l - 1][5];\n                        dp[l][6] = dp[l - 1][6];\n                        dp[l][7] = dp[l - 1][7];\n                        dp[l][8] = dp[l - 1][8];\n                        dp[l][9] = dp[l - 1][9];\n                        dp[l][10] = dp[l - 1][10];\n                        dp[l][11] = dp[l - 1][11];\n                        dp[l][12] = dp[l - 1][12];\n                        dp[l][13] = dp[l - 1][13];\n                        dp[l][14] = dp[l - 1][14];\n                        dp[l][15] = dp[l - 1][15];\n                    }\n                }\n                //cout << \"!! \" << dp[n][15] << endl;\n                ans += dp[n][15];\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nconstexpr ll T[4]={1,1000,1000000,1000000000};\ninline ll f(const ar &x,int k){\n    ll res=0;\n    rep(i,4)res+=T[(i+k)&3]*x[i];\n    return res;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin >> v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i],j);\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                rep(ii,4){\n                    s[ii] = f(ar{v[i][(4+1-ii)&3],v[i][(4-ii)&3],v[j][(1+k+ii)&3],v[j][(k+ii)&3]},0);\n                }\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    dp[15]+=dp[14]*cnt[0];\n                    dp[15]+=dp[13]*cnt[1];\n                    dp[15]+=dp[11]*cnt[2];\n                    dp[15]+=dp[7]*cnt[3];\n                    dp[14]+=dp[12]*cnt[1];\n                    dp[14]+=dp[10]*cnt[2];\n                    dp[14]+=dp[6]*cnt[3];\n                    dp[13]+=dp[12]*cnt[0];\n                    dp[13]+=dp[9]*cnt[2];\n                    dp[13]+=dp[5]*cnt[3];\n                    dp[12]+=dp[8]*cnt[2];\n                    dp[12]+=dp[4]*cnt[3];\n                    dp[11]+=dp[10]*cnt[0];\n                    dp[11]+=dp[9]*cnt[1];\n                    dp[11]+=dp[3]*cnt[3];\n                    dp[10]+=dp[8]*cnt[1];\n                    dp[10]+=dp[2]*cnt[3];\n                    dp[9]+=dp[8]*cnt[0];\n                    dp[9]+=dp[1]*cnt[3];\n                    dp[8]+=dp[0]*cnt[3];\n                    dp[7]+=dp[6]*cnt[0];\n                    dp[7]+=dp[5]*cnt[1];\n                    dp[7]+=dp[3]*cnt[2];\n                    dp[6]+=dp[4]*cnt[1];\n                    dp[6]+=dp[2]*cnt[2];\n                    dp[5]+=dp[4]*cnt[0];\n                    dp[5]+=dp[1]*cnt[2];\n                    dp[4]+=dp[0]*cnt[2];\n                    dp[3]+=dp[2]*cnt[0];\n                    dp[3]+=dp[1]*cnt[1];\n                    dp[2]+=dp[0]*cnt[1];\n                    dp[1]+=dp[0]*cnt[0];\n                }\n                ans += dp[15];\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n \n\n#define REP(i,n) for(int(i)=0;(i)<(int)(n);(i)++)\n\n#include <vector>\n#include <utility>\n\n\n#include <algorithm>\n\n\ntypedef pair< pair<int, int>, pair<int, int> > cbcol;\nmap< cbcol , int > cube_cnt;\n\nint n;\nint c[410][4];\nint tgt[4][4];\nint tmp[4];\nint rot_to[4][4];\n\n\nint can[4];\nint counts[4];\n\n\nvoid rotate(int *c) {\n\tint t = c[3];\n\tfor (int i = 2; i >= 0; i--) c[i+1] = c[i];\n\tc[0] = t;\n}\n\nvoid rotate(int idx) {\n\trotate(c[idx]);\n}\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tREP(i,n) REP(j,4) scanf(\"%d\", &c[i][j]);\n\n\tREP(i,n) {\n\t\tset<cbcol> seen;\n\t\tREP(j,4) {\n\t\t\tcbcol cur = {{c[i][0], c[i][1]}, {c[i][2], c[i][3]} };\n\t\t\tif (!seen.count(cur)) {\n\t\t\t\tseen.insert(cur);\n\t\t\t\tcube_cnt[cur]++;\n\t\t\t}\n\t\t\trotate(i);\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tREP(front, n) {\n\t\tfor (int back = 0; back < front; back++) {\n\t\t\tfor (int ro = 0; ro < 4; ro++) {\n\n\t\t\t\ttgt[0][0] = c[front][0];\n\t\t\t\ttgt[0][1] = c[back][1];\n\t\t\t\ttgt[0][2] = c[back][0];\n\t\t\t\ttgt[0][3] = c[front][1];\n\n\t\t\t\ttgt[1][0] = c[front][1];\n\t\t\t\ttgt[1][1] = c[back][0];\n\t\t\t\ttgt[1][2] = c[back][3];\n\t\t\t\ttgt[1][3] = c[front][2];\n\n\t\t\t\ttgt[2][0] = c[front][3];\n\t\t\t\ttgt[2][1] = c[front][2];\n\t\t\t\ttgt[2][2] = c[back][3];\n\t\t\t\ttgt[2][3] = c[back][2];\n\n\t\t\t\ttgt[3][0] = c[back][1];\n\t\t\t\ttgt[3][1] = c[front][0];\n\t\t\t\ttgt[3][2] = c[front][3];\n\t\t\t\ttgt[3][3] = c[back][2];\n\n\t\t\t\tREP(i,4) counts[i] = cube_cnt[ {{tgt[i][0], tgt[i][1]}, {tgt[i][2], tgt[i][3]}} ];\n\n\t\t\t\tREP(i,4) can[i] = 0;\n\t\t\t\tREP(ro, 4) {\n\t\t\t\t\tREP(i,4) {\n\t\t\t\t\t\tbool eq = true;\n\t\t\t\t\t\tREP(k,4) if (tgt[i][k] != c[front][k]) eq = false;\n\t\t\t\t\t\tcan[i] += eq;\n\t\t\t\t\t}\n\t\t\t\t\trotate(front);\n\t\t\t\t}\n\t\t\t\tREP(i,4) if (can[i]) counts[i]--;\n\n\t\t\t\tREP(i,4) can[i] = 0;\n\t\t\t\tREP(ro, 4) {\n\t\t\t\t\tREP(i,4) {\n\t\t\t\t\t\tbool eq = true;\n\t\t\t\t\t\tREP(k,4) if (tgt[i][k] != c[back][k]) eq = false;\n\t\t\t\t\t\tcan[i] += eq;\n\t\t\t\t\t}\n\t\t\t\t\trotate(back);\n\t\t\t\t}\n\t\t\t\tREP(i,4) if (can[i]) counts[i]--;\n\n\t\t\t\tREP(i,4) {\n\t\t\t\t\tREP(j,4) {\n\t\t\t\t\t\trot_to[i][j] = 0;\n\t\t\t\t\t\tREP(k,4) tmp[k] = tgt[i][k];\n\n\t\t\t\t\t\tfor (int ro = 0; ro < 4; ro++) {\n\t\t\t\t\t\t\tbool eq = true;\n\t\t\t\t\t\t\tREP(k,4) if (tmp[k] != tgt[j][k]) eq = false;\n\t\t\t\t\t\t\trot_to[i][j] += eq;\n\t\t\t\t\t\t\trotate(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tlong long th = 1;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint sub = 0;\n\t\t\t\t\tfor (int j = 0; j < i; j++) if (rot_to[j][i]) sub++;\n\t\t\t\t\tth = (th * (counts[i]-sub) * rot_to[i][i]);\n\t\t\t\t}\n\t\t\t\tans += th;\n\t\t\t\t\n\t\t\t\trotate(back);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans/3);\n}\n\n\nint main() {\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int mod = 1e9 + 7;\n\nint N;\nint c[405][4];\nLL hsh[405];\n\nLL coef[] = {1LL, LL(1e3), LL(1e6), LL(1e9)};\n\nmap<LL, int> mp;\n\nint power(int x, int y)\n{\n    if(y <= 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvector<int> getBest(vector<int> cl)\n{\n    vector<int> bst = cl;\n    for(int j = 0; j < 4; j++)\n    {\n        cl.insert(cl.begin(), cl.back());\n        cl.pop_back();\n        if(bst > cl)    bst = cl;\n    }\n    return bst;\n}\n\nint rotateCount(vector<int> cl)\n{\n    LL h = cl[0] + LL(1e3) * cl[1] + LL(1e6) * cl[2] + LL(1e9) * cl[3];\n    int cnt = 0;\n    for(int j = 0; j < 4; j++)\n    {\n        cl.insert(cl.begin(), cl.back());\n        cl.pop_back();\n        LL h2 = cl[0] + LL(1e3) * cl[1] + LL(1e6) * cl[2] + LL(1e9) * cl[3];\n        cnt += (h == h2);\n    }\n    return cnt;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i <= N; i++)\n    {\n        vector<int> cl;\n        for(int j = 0; j < 4; j++)\n        {\n            int x; scanf(\"%d\", &x);\n            cl.push_back(x);\n        }\n\n        vector<int> bst = getBest(cl);\n        for(int j = 0; j < 4; j++)  c[i][j] = bst[j];\n\n        hsh[i] = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n        mp[ hsh[i] ]++;\n    }\n\n    LL ans = 0;\n    for(int i = 1; i < N; i++)\n        for(int j = i + 1; j <= N; j++)\n            for(int d = 0; d < 4; d++)\n            {\n                mp[ hsh[i] ]--; mp[ hsh[j] ]--;\n                swap(c[j][1], c[j][3]);\n\n                LL sol = 1; int lst = -1;\n                for(int k = 0; k < 4; k++)\n                {\n                    int cl[4];\n                    cl[0] = (c[i][k]);\n                    cl[1] = (c[j][(k + d) & 3]);\n                    cl[2] = (c[j][(k + d + 1) & 3]);\n                    cl[3] = (c[i][(k + 1) & 3]);\n\n                    LL h = 1LL << 60;\n                    int cnt = 0;\n                    for(int i = 0; i < 4; i++)\n                    {\n                        LL hh = cl[i] + LL(1e3) * cl[(i + 1) & 3] + LL(1e6) * cl[(i + 2) & 3] + LL(1e9) * cl[(i + 3) & 3];\n                        if(h == hh) cnt++;\n                        else if(h > hh) { h = hh; cnt = 1; }\n                    }\n\n                    if(!mp.count(h)) { sol = 0; break; }\n                    int nr = mp[h];\n                    if(nr <= 0) { sol = 0; break; }\n\n                    mp[h]--;\n                    sol = (1LL * sol * nr * cnt);\n\n                    lst = k;\n                }\n\n                ans += sol;\n\n                for(int k = 0; k <= lst; k++)\n                {\n                    int cl[4];\n                    cl[0] = (c[i][k]);\n                    cl[1] = (c[j][(k + d) & 3]);\n                    cl[2] = (c[j][(k + d + 1) & 3]);\n                    cl[3] = (c[i][(k + 1) & 3]);\n\n                    LL h = 1LL << 60;\n                    int cnt = 0;\n                    for(int i = 0; i < 4; i++)\n                    {\n                        LL hh = cl[i] + LL(1e3) * cl[(i + 1) & 3] + LL(1e6) * cl[(i + 2) & 3] + LL(1e9) * cl[(i + 3) & 3];\n                        if(h == hh) cnt++;\n                        else if(h > hh) { h = hh; cnt = 1; }\n                    }\n\n                    mp[h]++;\n                }\n\n                swap(c[j][1], c[j][3]);\n                mp[ hsh[i] ]++; mp[ hsh[j] ]++;\n            }\n\n    ans /= 3;\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) ((((LL)(x))<<30)+((y)<<20)+((z)<<10)+(t))\nunordered_map<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[G(fr.x1,fr.x0,bk.x1,bk.x0)];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[G(fr.x2,fr.x1,bk.x0,bk.x3)];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[G(fr.x3,fr.x2,bk.x3,bk.x2)];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[G(fr.x0,fr.x3,bk.x2,bk.x1)];key[4].dec();\n\t\tret+=ans;\n\t\tfor(int j=1;j<=4;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\n//////////////////\nvector< vector< vector<int> > > block;\nvector< bool > used;\nvector< vector<int> > men;\n\n//num面決定している。\nLL dfs( vector<int> v,int num ){\n\tif( num >= 6 ){//全て配置されている。\n\t\treturn 1;\n\t}\n\tvector<int> orgV = v;//保存しておく\n\tvector<int> ter(5,-1);//探す面\n\tfor(int i=0;i<4;++i){\n\t\tter[i] = v[ men[num][i] ];\n\t}\n\tvector< vector<int> >::iterator itr,end;\n\tLL ans,res;\n\tans = 0;\n\t//set<vector<int> > bSet;//回転対象分も含める\n\tfor(int d=0;d<4;++d){//回転分探す\n\t\titr = lower_bound( block[d].begin(),block[d].end(), ter );\n\t\tend = block[d].end();\n\t\tbool flag = true;\n\t\tfor( ;flag && itr != end;++itr ){\n\t\t\t//色のチェック\n\t\t\tfor(int c=0;c<4;++c){\n\t\t\t\tif( ter[c] == -1 )continue;//なんでもいい\n\t\t\t\tif( ter[c] != (*itr)[c] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ){//色はマッチしてる\n\t\t\t\tint now = (*itr)[4];//ブロック番号\n\t\t\t\tif( used[now] )continue;//使用済み\n\t\t\t\t//色を配置する。\n\t\t\t\tvector<int> next = orgV;//もらった配置\n\t\t\t\tfor(int i=0;i<4;++i){//選択したブロックの色を配置\n\t\t\t\t\tnext[ men[num][i] ] = (*itr)[i];\n\t\t\t\t}\n\t\t\t\tused[now] = true;//使用済みへ\n\t\t\t\tres = dfs( next, num+1 );\n\t\t\t\tused[now] = false;\n\t\t\t\tans += res;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<int> color(1000,0);\n\tvector< vector<int> > org(N,vector<int>(4));\n\tfor(int i=0;i<N;++i){\n\t\tfor(int j=0;j<4;++j){\n\t\t\tcin >> org[i][j];\n\t\t\tcolor[org[i][j]]++;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor(int i=0;i<1000;++i){\n\t\tif( color[i] < 3 ){\n\t\t\tcolor[i] = 0;\n\t\t}\n\t}\n\tfor(int i=0;i<N;++i){\n\t\tbool flag = true;\n\t\tfor(int j=0;j<4;++j){\n\t\t\tif( color[ org[i][j] ] == 0 ){\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\tif( flag ){\n\t\t\t++sum;\n\t\t}\n\t}\n\tblock = vector< vector< vector<int> > >(4,\n\t\tvector< vector<int> >(sum,\n\t\t\tvector<int>(5)\n\t\t\t)\n\t\t);\n\tint index = 0;\n\tfor(int i=0;i<N;++i){\n\t\tbool flag = true;\n\t\tfor(int j=0;j<4;++j){\n\t\t\tif( color[ org[i][j] ] == 0 ){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( flag ){//使えるブロック\n\t\t\tfor(int d=0;d<4;++d){//回転\n\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\tblock[d][index][j] = org[i][(d+j)%4];\n\t\t\t\t}\n\t\t\t\tblock[d][index][4] = index;//ブロック番号\n\t\t\t}\n\t\t\t++index;\n\t\t}\n\t}\n\tfor(int d=0;d<4;++d){\n\t\tsort(block[d].begin(),block[d].end());\n\t}\n\tused = vector<bool>(sum,false);\n\tLL ans = 0;\n\tmen = vector< vector<int> >(6,vector<int>(4));\n\tmen[0][0]=0;men[0][1]=1;men[0][2]=2;men[0][3]=3;\n\tmen[1][0]=1;men[1][1]=0;men[1][2]=5;men[1][3]=4;\n\tmen[2][0]=2;men[2][1]=1;men[2][2]=4;men[2][3]=7;\n\tmen[3][0]=3;men[3][1]=2;men[3][2]=7;men[3][3]=6;\n\tmen[4][0]=0;men[4][1]=3;men[4][2]=6;men[4][3]=5;\n\tmen[5][0]=4;men[5][1]=5;men[5][2]=6;men[5][3]=7;\n\t/*\n\tmen[i]のi=0から順に埋めていく\n\t決定した数字が先頭から埋まるように時計回りに選択。\n\t*/\n\tfor(int i=0;i<=sum-6;++i){\n\t\tvector<int> v(8,-1);//未決定-1\n\t\t/*\n\t\t  5--4\n\t\t /  /|\n\t\t0--1 7 ←6が裏\n\t\t|  |/\n\t\t3--2\n\t\t*/\n\t\tfor(int j=0;j<4;++j){\n\t\t\tv[j] = block[0][i][j];\n\t\t}\n\t\tint now = block[0][i][4];//ブロック番号\n\t\tused[now] = true;//使用済みに\n\t\tLL res = dfs( v, 1 );\n\t\tans += res;\n\t\t//used[i] = true;\n\t}\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\t\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\ntypedef long long LL;\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\ntemplate<typename T>\nvoid chmin(T& a,T b){a=min(a,b);}\ntemplate<typename T>\nvoid chmax(T& a,T b){a=max(a,b);}\n\n\n#define PRO \"YES\"\n#define SHUMI \"NO\"\n#define fin \"\\n\"\n#define IL inline\nIL void rot(V& C){\n    swap(C[0],C[3]);\n    swap(C[1],C[3]);\n    swap(C[2],C[3]);\n}\nV min_rot(V C){\n    auto res=C;\n    for(int i=0;i<3;i++){\n        rot(C);\n        res=min(res,C);\n    }\n    return res;\n}\nint get_same(V C){\n    if(C[0]==C[2]&&C[1]==C[3]){\n        if(C[0]==C[1])return 4;\n        else return 2;\n    }\n        \n    return 1;\n}\nLL P(LL n,LL k){\n    if(n<k)return 0;\n    LL res=1;\n    for(int i=0;i<k;i++)\n        res*=n-i;\n    return res;\n}\n\nint pos[4][4]={\n    {1,0,1,0},\n    {2,1,0,3},\n    {3,2,3,2},\n    {0,3,2,1}\n};\nLL mypow(LL a,LL n){\n    LL res=1;\n    while(n--){\n        res*=a;\n    }\n    return res;\n}\ntypedef pair<int,int> pi;\nint main(){\n    int N;\n    cin>>N;\n    VV C(N,V(4));\n    for(auto &c:C){\n        for(auto &it:c)cin>>it;\n        c=min_rot(c);\n    }\n    map<V,int> cnt;\n    LL res=0;\n    for(int i=0;i<N;i++)cnt[C[i]]++;\n    for(int i=0;i<N;i++){\n        auto &now=C[i];\n        cnt[C[i]]--;\n        for(auto &it:cnt){\n            if(it.second==0)continue;\n            LL ans=0;\n            V rev=it.first;\n            it.second--;\n            for(int j=0;j<4;j++){\n                map<V,int> need;\n                for(int t=0;t<4;t++){\n                    need[min_rot({now[pos[t][0]],now[pos[t][1]],rev[pos[t][2]],rev[pos[t][3]]})]++;\n                }\n                LL K=1;\n                for(auto &it:need)K*=mypow(get_same(it.first),it.second);\n                for(auto &it:need){\n                    if(cnt.count(it.first)==0)K=0;\n                    else{                         \n                        K*=P(cnt[it.first],it.second);\n                    }\n                } \n                ans+=K;\n                rot(rev);  \n            }\n            it.second++;\n            ans*=it.second;\n            res+=ans;\n        }       \n    }\n    cout<<res<<fin;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n\tusing LD = long double;\n\t#define double LD\n\t#define long long long\n\t#define LL long\n\t#define int long\n\ttemplate<class T> using vec = vector<T>;\n\tusing VB = vec<bool>;\tusing WB = vec<VB>;\n\tusing VC = vec<char>;\tusing WC = vec<VC>;\n\tusing VI = vec<int>;\tusing WI = vec<VI>;\n\tusing VD = vec<double>;\tusing WD = vec<VD>;\n\tusing VS = vec<string>;\tusing WS = vec<VS>;\n\tusing PI = pair<int, int>;\tusing VPI = vec<PI>; using WPI = vec<VPI>;\n\tusing MI = map<int, int>;\tusing VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n\t#ifdef EBUG\n\t\tdebug = true;\n\t#elif defined(ONLINE_JUDGE)\n\t\tdebug = false;\n\t#else\n\t\tdebug = argc >= 2;\n\t#endif\n\tif(!debug) {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n\tcout << fixed << setprecision(20);\n\tcerr << fixed << setprecision(20);\n\n\tsettings();\n\tsolve();\n\n\treturn 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n\ttemplate<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n\t\tGraph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n\t};\n\tusing GraphI = Graph<int>;\n/** IO **/\n\ttemplate<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n\tint INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n\ttemplate<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n\t\tconst int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n\t\tif(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n\t\ttimes(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n\t}\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n\ttemplate<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n\ttemplate<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n\t#define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n\ttemplate<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n\tinline void RD() {}\n\ttemplate<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n\ttemplate<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n\t#define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n\ttemplate<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n\ttemplate<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n\ttemplate<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n\t#define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n\t#define all(v) begin(v), end(v)\n\ttemplate<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n\ttemplate<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n\ttemplate<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n\ttemplate<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n\ttemplate<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n\ttemplate<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n\ttemplate<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n\ttemplate<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n\t\treturn 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n\t#define first_itr_st_val_ge_ lower_bound\n\t#define first_itr_st_val_gt_ upper_bound\n/** other **/\n\ttemplate<class T> inline signed SIZE(const T& t) { return t.size(); }\n\t#define size SIZE\n\t#define MP make_pair\n\t#define MT make_tuple\n\t#define PB push_back\n\t#define b_max(x, y) x = max(x, y)\n\t#define b_min(x, y) x = min(x, y)\n\tinline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.m.pow> */\n\t// NOT_VERIFIED\n\t// ref: ari-114\n\t// O(log b)\n\tinline int mpow(int a, int b, int mod=MOD) {\n\t\tint ans = 1;\n\t\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ans *= a) %= mod;\n\t\treturn ans;\n\t}\n/* </sr.m.pow> */\n\n/************************************ main ************************************/\n\nvoid settings() {\n\t// INPUT_GRAPH_index_sub = 0;\t\t// uncomment if input index is 0-based\n\t// INPUT_GRAPH_allow_empty = true;\t// uncomment to allow empty graph\n\t// INPUT_GRAPH_cost = 1;\t\t\t// uncomment if all input costs are 1\n}\n\nusing I4 = array<int, 4>;\n\nvoid o(const I4& i4) { cout << '(' << vec<int>(all(i4)) << ')'; }\n\nI4 rot(const I4& i4, int r) {\n\treturn I4{{ i4[r&3], i4[r+1&3], i4[r+2&3], i4[r+3&3] }};\n}\n\nI4 minrot(const I4& i4) {\n\tI4 ans = i4;\n\ttimes(3, r) {\n\t\tI4 x = rot(i4, r+1);\n\t\tif(ans > x) ans = x;\n\t}\n\treturn ans;\n}\n\nint z(const I4& i4) {\n\tif(i4[0] == i4[2] && i4[1] == i4[3]) {\n\t\tif(i4[0] == i4[1]) return 4;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nvoid solve() {\n// N N(4(C))\n/* <foxy.memo-area> */\nint N;cin>>N;vec<I4> C(N);times(N,Ri_0){times(4,Ri_1){cin>>C[Ri_0][Ri_1];}}\n/* </foxy.memo-area> */\n\tmap<I4, int> pyon;\n\ttimes(N, i) {\n\t\tC[i] = minrot(C[i]);\n\t\t++pyon[C[i]];\n\t}\n\t//if(debug) {for(auto& p : pyon) { o(p.first); cout sp << p.second << '/';} cout ln;}\n\tint ans = 0;\n\n\ttimes(N, i) times(N, j) if(i!=j) times(4, jj) {\n\t\tint a = 1;\n\t\tmap<I4, int> sides;\n\t\ttimes(4, h) {\n\t\t\t++sides[minrot(I4{{C[i][h+1&3], C[i][h&3], C[j][jj+4-h&3], C[j][jj+3-h&3]}})];\n\t\t}\n\t\tfor(auto& p : sides) {\n\t\t\tI4 i4 = p.first; int n = p.second;\n\t\t\t(a *= mpow(z(i4), n)) %= MOD;\n\n\t\t\tint py = pyon[i4];\n\t\t\tif(i4 == minrot(C[i])) --py;\n\t\t\tif(i4 == minrot(C[j])) --py;\n\t\t\ttimes(n, k) (a *= py - k) %= MOD;\n\t\t}\n\n\t\t(ans += a) %= MOD;\n\t}\n\tcout << ans * mpow(6, MOD-2) % MOD ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nll h[maxn];\ninline ll cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tll ret = 1234567891234567ll;\n\tfor(int rot=0;rot<4;rot++) {\n\t\tll num = 0;\n\t\tfor(int i=0;i<4;i++)\n\t\t\tnum = num*1000+col[(rot+i)%4];\n\t\tret = min(ret,num);\n\t}\n\treturn ret;\n}\nint fac[5];\ninline ll Pow(int a,int n) {\n\tll ret = 1;\n\tll base = a;\n\twhile(n) {\n\t\tif(n&1)\tret *= base;\n\t\tbase *= base;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ninline ll C(int n,int m) {\n\tif(n < m)\treturn 0;\n\tll ret = 1;\n\tfor(int i=n-m+1;i<=n;i++)\n\t\tret *= i;\n\tfor(int i=1;i<=m;i++)\n\t\tret /= i;\n\treturn ret;\n}\nmap<ll,pii> cnt;\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tint now_cnt = 0;\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tll num = 0;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tnum = num*1000+col[i][(rot+j)%4];\n\t\t\tif(num == h[i])\n\t\t\t\tnow_cnt++;\n\t\t}\n\t\tcnt[h[i]].first++;\n\t\tcnt[h[i]].second = now_cnt;\n\t}\n\t\n\tfac[0] = 1;\n\tfor(int i=1;i<5;i++)\n\t\tfac[i] = fac[i-1] * i;\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tcnt[h[i]].first--;\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tcnt[h[j]].first--;\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tmap<ll,int> need;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[cal(t1[k],t2[k],t2[(k+1)%4],t1[(k+1)%4])]++;\n\t\t\t\tll now = 1;\n\t\t\t\tfor(auto x : need)\n\t\t\t\t\tnow *= C(cnt[x.first].first,x.second) * Pow(cnt[x.first].second,x.second) * fac[x.second];\n\t\t\t\tans += now;\n\t\t\t}\n\t\t\tcnt[h[j]].first++;\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n//\t\tcnt[h[i]].first++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (short i = a; i <= b; ++ i) \nconst short N = 1005 ; \n\nconst short turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <short>, short> Count ;\nshort col[N][5], n ;\n\ninline void getmin(vector <short> &p) {\n\tvector <short> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nvector <short> vec[N] ;\nmap <vector <short>, short>  mul ;\n\nint main() {\n\tcin >> n ;\n\trep(i, 1, n) rep(j, 0, 3) cin >> col[i][j] ;\n\trep(i, 1, n) {\n\t\tvector <short> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\tvec[i] = ret ;\n\t\t++ Count[ret] ;\n\t\tshort tot = 0 ; \n\t\tvector <short> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0, sum ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\t-- Count[vec[i]], -- Count[vec[j]] ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <short> ret ;\n\t\t\tmap <vector <short>, short> used ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\tvector <short> U ;\n\t\t\t\trep(q, 0, 3) U.push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(U) ;\n\t\t\t\tsum *= (ll) mul[U] * (Count[U] - used[U]) ;\n\t\t\t\t++ used[U] ;\n\t\t\t}\n\t\t\tans += sum ;\n\t\t}\n\t\t++ Count[vec[i]], ++ Count[vec[j]] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\ntypedef pair<P,int> Pi;\n\nconst int MAX_N = 400;\n\nmap<ll, int> mp;\nvi col[MAX_N];\nll num[MAX_N];\n\nll trans(vi& vec)\n{\n    ll r = (1LL << 60);\n    rep(i,4){\n        cmn(r, (vec[(i+3)%4]*1000000000LL+vec[(i+2)%4]*1000000LL+vec[(i+1)%4]*1000LL+vec[i]));\n    }\n    return r;\n}\n\nint cmp(ll arg)\n{\n    vector<int> vec(4);\n    rep(i,4){\n        vec[i] = arg%1000LL;\n        arg /= 1000LL;\n    }\n    if(vec[0] == vec[2] && vec[1] == vec[3]){\n        if(vec[0] == vec[1]){\n            return 4;\n        }else{\n            return 2;\n        }\n    }else{\n        return 1;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        col[i] = {a,b,c,d};\n        num[i] = trans(col[i]);\n        mp[num[i]]++;\n    }\n    ll ans = 0;\n    rep(i,n){\n        mp[num[i]]--;\n        srep(j,i+1,n){\n            mp[num[j]]--;\n            rep(k,4){\n                map<ll,int> mp2;\n                rep(l,4){\n                    vi hoge = {col[i][(l+1)%4],col[i][l],col[j][(k+5-l)%4],col[j][(k+4-l)%4]};\n                    mp2[trans(hoge)]++;\n                }\n                ll res = 1;\n                each(val,mp2){\n                    int cnt = cmp(val.fi);\n                    int kp = mp[val.fi];\n                    rep(l,val.se){\n                        res *= cnt*(kp-l);\n                    }\n                    if(!res) break;\n                }\n                ans += res;\n            }\n            mp[num[j]]++;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nll readLL(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\npair<ll,int> norm(int c[4]){\n\tll x[4]={};\n\tREP(i,4)\n\t\tREP(j,4){\n\t\t\tx[i]*=1000;\n\t\t\tx[i]+=c[(i+j)%4];\n\t\t}\n\tll a=*min_element(x,x+4);\n\tint b=0;\n\tREP(i,4)if(x[i]==a)\n\t\tb++;\n\treturn MP(a,b);\n}\n\nint main(){\n\tint n=read();\n\tvector<pair<ll,int>> fs(n);\n\tvector<int[4]> raw(n);\n\tmap<ll,int> k;\n\tREP(i,n){\n\t\tREP(j,4)\n\t\t\traw[i][j]=read();\n\t\tfs[i]=norm(raw[i]);\n\t\tk[fs[i].first]+=fs[i].second;\n\t}\n\tll ans=0;\n\tREP(top,n){\n\t\tk[fs[top].first]-=fs[top].second;\n\t\tFOR(bot,top+1,n){\n\t\t\tk[fs[bot].first]-=fs[bot].second;\n\t\t\tREP(d,4){\n\t\t\t\tll w=1;\n\t\t\t\tpair<ll,int> x[4];\n\t\t\t\tREP(i,4){\n\t\t\t\t\tint tmp[4]={raw[top][(d+1+i)%4],raw[top][(d+0+i)%4],raw[bot][(3-i+4)%4],raw[bot][(2-i+4)%4]};\n\t\t\t\t\tx[i]=norm(tmp);\n\t\t\t\t}\n\t\t\t\tREP(i,4){\n\t\t\t\t\tw*=k[x[i].first];\n\t\t\t\t\tk[x[i].first]-=x[i].second;\n\t\t\t\t}\n\t\t\t\tans+=w;\n\t\t\t\tREP(i,4)\n\t\t\t\t\tk[x[i].first]+=x[i].second;\n\t\t\t}\n\t\t\tk[fs[bot].first]+=fs[bot].second;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n;\nusing Panel = array<int, 4>;\n\nPanel rotate(Panel a) {\n  tie(a[0], a[1], a[2], a[3]) = make_tuple(a[1], a[2], a[3], a[0]);\n  return a;\n}\n\nPanel normalize(Panel a) {\n  Panel p[4];\n  for(int i = 0; i < 4; i++) {\n    p[i] = a;\n    a = rotate(a);\n  }\n  return *min_element(p, p + 4);\n}\n\nconst int N = 400;\n\nint rotcount(Panel a) {\n  auto b = a;\n  int res = 0;\n  for(int i = 0; i < 4; i++) {\n    b = rotate(b);\n    if(a == b) res++;\n  }\n  return res;\n}\n\nll fact[10];\nll comb[N + 1][N + 1];\n\nPanel a[N];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin >> a[i][0] >> a[i][1] >> a[i][2] >> a[i][3];\n    a[i] = normalize(a[i]);\n  }\n\n  comb[0][0] = 1;\n  for(int i = 1; i <= n; i++) for(int j = 0; j <= n; j++) {\n    // Pascal's identity\n    if(j == 0) {\n      comb[i][j] = 1;\n      continue;\n    }\n    comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n  }\n\n  fact[0] = 1;\n  for(int i = 1; i <= 9; i++) fact[i] = fact[i-1] * i;\n\n  ll ans = 0;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    for(int rot = 0; rot < 4; rot++) {\n      a[i] = rotate(a[i]);\n      map<Panel, int> target;\n      map<Panel, int> cnt;\n      for(int k = 0; k < 4; k++) {\n        Panel f{a[i][(k + 1) % 4], a[i][k + 0], a[j][(4 - k) % 4], a[j][(3 - k) % 4]};\n        f = normalize(f);\n        target[f]++;\n        cnt[f] = 0;\n      }\n      for(int l = 0; l < n; l++) {\n        if(l == i) continue;\n        if(l == j) continue;\n        if(target.count(a[l])) cnt[a[l]]++;\n      }\n\n      int ng = 0;\n      ll res = 1;\n      for(auto &p : target) {\n        Panel pan;\n        int tar;\n        tie(pan, tar) = p;\n        if(cnt[pan] < tar) {ng = 1; break;}\n        res *= comb[cnt[pan]][tar] * pow((ll) rotcount(pan), (ll) tar) * fact[tar];\n      }\n      if(ng) continue;\n      ans += res;\n    }\n  }\n  assert(ans % 3 == 0);\n  cout << ans/3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 410;\ntypedef long long LL;\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a *= a) if (b & 1) res *= a;\n\treturn res;\n}\nint C[MAXN][4], n;\nLL hash(int * a) { return a[0] | a[1] << 16 | (LL) a[2] << 32 | (LL) a[3] << 48; }\nvoid dehash(int * a, LL t) {\n\tstatic const int mask = (1 << 16) - 1;\n\ta[0] = t & mask, t >>= 16;\n\ta[1] = t & mask, t >>= 16;\n\ta[2] = t & mask, t >>= 16;\n\ta[3] = t & mask;\n}\nvoid mk(int * t, int a, int b, int c, int d) {\n\tt[0] = a, t[1] = b, t[2] = c, t[3] = d;\n}\nvoid rotate(int * a) {\n\tstatic int t;\n\tt = a[3], a[3] = a[2], a[2] = a[1], a[1] = a[0], a[0] = t;\n}\nint rtteq(int * a) {\n\tLL hs = hash(a); int res = 0;\n\tfor (int i = 0; i != 4; ++i) res += hash(a) == hs, rotate(a);\n\treturn res;\n}\nvoid mins(int * a) {\n\tLL h[4];\n\tfor (int i = 0; i != 4; ++i) h[i] = hash(a), rotate(a);\n\tint at = std::min_element(h, h + 4) - h;\n\tfor (int i = 0; i != at; ++i) rotate(a);\n}\nLL down(int a, int b) {\n\tLL res = 1;\n\tfor (int i = a; i > a - b; --i) res *= i;\n\treturn res;\n}\nstd::map<LL, int> hav, pt;\nvoid ins(int * a, int v) { hav[hash(a)] += v; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t\tstd::cin >> C[i][j];\n\t\tmins(C[i]); ins(C[i], 1);\n\t}\n\tLL ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tins(C[i], -1), ins(C[j], -1);\n\t\t\tfor (int T = 0; T != 4; ++T) {\n\t\t\t\tint t[4];\n\t\t\t\tmk(t, C[i][3], C[i][2], C[j][3], C[j][2]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tmk(t, C[i][2], C[i][1], C[j][0], C[j][3]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tmk(t, C[i][1], C[i][0], C[j][1], C[j][0]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tmk(t, C[i][0], C[i][3], C[j][2], C[j][1]);\n\t\t\t\tmins(t); ++pt[hash(t)];\n\t\t\t\tLL r = 1;\n\t\t\t\tfor (auto x : pt) {\n\t\t\t\t\tr *= down(hav[x.first], x.second);\n\t\t\t\t\tdehash(t, x.first);\n\t\t\t\t\tr *= pow(rtteq(t), x.second);\n\t\t\t\t}\n\t\t\t\tans += r;\n\t\t\t\tpt.clear();\n\t\t\t\trotate(C[j]);\n\t\t\t}\n\t\t\tins(C[i], 1), ins(C[j], 1);\n\t\t}\n\tstd::cout << ans / 3 << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> cyc(V<int> a) {\n\tVV<int> cand;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(a[(j+k)%4]);\n\t\t}\n\t\tcand.pb(vec);\n\t}\n\treturn *min_element(ALL(cand));\n}\n\nint com(V<int>& v) {\n\tint cnt = 0;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(v[(j+k)%4]);\n\t\t}\n\t\tif (vec == v) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> vf;\n\tmap<V<int>, int> T;\n\n\trep(i, N) {\n\t\tV<int> a(4);\n\t\trep(j, 4) cin >> a[j];\n\n\t\tauto vec = cyc(a);\n\t\tvf.pb(vec);\n\t\t++T[vec];\n\t\tdump(vec);\n\t}\n\n\tint ans = 0;\n\n\trep(i, N) {\n\t\trep(j, N) if (i != j) {\n\t\t\t--T[vf[i]];\n\t\t\t--T[vf[j]];\n\n\t\t\trep(k, 4) {\n\t\t\t\tint up[4], dw[4];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tup[l] = vf[i][l];\n\t\t\t\t\tdw[l] = vf[j][(k-l+4)%4];\n\t\t\t\t}\n\n\t\t\t\tint t = 1;\n\n\t\t\t\tVV<int> use;\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tV<int> vec{up[l],up[(l+3)%4],dw[(l+3)%4],dw[l]};\n\t\t\t\t\tvec = cyc(vec);\n\t\t\t\t\tuse.pb(vec);\n\t\t\t\t\tt *= T[vec] * com(vec);\n\t\t\t\t\t--T[vec];\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\trep(l, 4) ++T[use[l]];\n\t\t\t}\n\n\t\t\t++T[vf[i]];\n\t\t\t++T[vf[j]];\t\t\t\n\t\t}\n\t}\n\tdump(ans);\n\n\tcout << ans / 6 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 062\n// E - AtCoDeerくんと立方体づくり / Building Cubes with AtCoDeer\n\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define MAX_N 400\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> Tile;\n\n\nint N;\nvector<Tile> tiles;\nmultiset<Tile> used;\nll ans;\n\nTile rotate(Tile t) {\n  return { t[1], t[2], t[3], t[0] };\n}\n\nint main() {\n\n  Tile t1, t2;\n  int c;\n  ll cnt, tmp;\n  vector<Tile>::iterator itr1, itr2;\n\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    Tile t;\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", &c);\n      t.push_back(c);\n    }\n    tiles.push_back(t);\n  }\n\n  sort(tiles.begin(), tiles.end());\n\n  ans = 0;\n  for (itr1 = tiles.begin(); itr1 != tiles.end(); itr1++) {\n    for (itr2 = itr1, itr2++; itr2 != tiles.end(); itr2++) {\n      t1 = *itr1; t2 = *itr2;\n      for (int d = 0; d < 4; d++) {\n        used.clear();\n        used.insert(t1);\n        used.insert(t2);\n        cnt = 1;\n        for (int i = 0; i < 4; i++) {\n          tmp = 0;\n          Tile t = { t1[(1 + i) % 4], t1[(0 + i) % 4], t2[(4 - i) % 4], t2[(7 - i) % 4] };\n          for (int j = 0; j < 4; j++) {\n            tmp += upper_bound(tiles.begin(), tiles.end(), t) - lower_bound(tiles.begin(), tiles.end(), t);\n            tmp -= used.count(t);\n            t = rotate(t);\n          }\n          tmp = max(tmp, 0LL);\n          cnt *= tmp;\n          used.insert(t);\n        }\n        ans += cnt;\n        t2 = rotate(t2);\n      }\n    }\n  }\n\n  ans /= 3;\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n\n#define uint unsigned int\n#define ull unsigned long long\n#define INF 1000000001\n#define LINF 1000000000000000001\n#define ll long long\n#define ld long double\n#define M 1000000007\n#define E 0.0000001\n#define N (1<<17)\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pdd pair<double, double>\n#define pld pair<long double, long double>\n#define cll complex<long long>\n#define cld complex<long double>\n#define X real()\n#define Y imag()\n#define C 'a'\n#define F first\n#define S second\n#define PI 3.1415926535897932384626433\n\nusing namespace std;\n\nint c[400][4];\n\ninline ll h (int i, int r) {\n    ll ans = 0;\n    for (int x = 0; x < 4; x++) {\n        ans = ans * 1001 + c[i][(x + r) % 4];\n    }\n    return ans;\n}\n\nint foo (ll i) {\n    ll a = i % 1001;\n    i /= 1001;\n    ll b = i % 1001;\n    i /= 1001;\n    ll c = i % 1001;\n    i /= 1001;\n    ll d = i;\n    if (a == b && b == c && c == d) return 4;\n    if (a == c && b == d) return 2;\n    return 1;\n}\n\nunordered_map<ll, ll> m;\nunordered_map<ll, int> la;\n\nint main () {\n    int n;\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) cin>>c[i][j];\n        for (int j = 0; j < 4; j++) la[h(i, j)] = i, m[h(i, j)]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) m[h(i, j)]--;\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 0; k < 4; k++) m[h(j, k)]--;\n\n            for (int k = 0; k < 4; k++) {\n                unordered_map<ll, ll> r;\n\n                for (int l = 0; l < 4; l++) {\n                    r[1001LL * 1001LL * c[i][(-l + 4) % 4] + 1001LL * 1001LL * 1001LL * c[i][(-l + 5) % 4] + c[j][(l + k) % 4] + 1001LL * c[j][(l + k + 1) % 4]]++;\n                }\n                ll x = 1;\n                for (auto p : r) {\n                    ll h = p.first;\n                    ll a = p.second;\n                    ll b = foo(h);\n                    //if (i == 0 && j == 4) cout<<h<<\" \"<<a<<\" \"<<b<<\" \"<<m[h]<<\" \"<<la[h]<<endl;\n                    for (int i = 0; i < a; i++) {\n                        x *= m[h] - b * i;\n                    }\n                }\n                ans += x;\n            }\n\n            for (int k = 0; k < 4; k++) m[h(j, k)]++;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=410;\nstruct Tile{\n\tconst static int D=4;\n\tint a[D];\n\tinline bool cmp(int x,int y){\n\t\tfor(int i=0;i<D;(++x)%=D,(++y)%=D,i++){\n\t\t\tif(a[x]!=a[y])return a[x]<a[y];\n\t\t}\n\t\treturn false;\n\t}\n\tinline bool equal(int x,int y){\n\t\tfor(int i=0;i<D;(++x)%=D,(++y)%=D,i++){\n\t\t\tif(a[x]!=a[y])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tinline void sani(){\n\t\tint j=0;\n\t\tfor(int i=1;i<D;i++){\n\t\t\tif(cmp(i,j)){\n\t\t\t\tj=i;\n\t\t\t}\n\t\t}\n\t\tint b[D];\n\t\tmemcpy(b,a,D<<2);\n\t\tfor(int i=0;i<D;i++,(++j)%=D){\n\t\t\ta[i]=b[j];\n\t\t}\n\t}\n\tinline int getloop(){\n\t\tint cnt=0;\n\t\tfor(int i=0;i<D;i++){\n\t\t\tcnt+=equal(0,i);\n\t\t}\n\t\treturn cnt;\n\t}\n\tinline friend bool operator < (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<D;i++){\n\t\t\tif(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t\t}\n\t\treturn false;\n\t}\n\tinline friend bool operator == (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<D;i++){\n\t\t\tif(a.a[i]!=b.a[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n}tile[N];\nmap<Tile,int>m;\nint main(){\n\tint n=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ttile[i]=(Tile){ni,ni,ni,ni};\n\t\ttile[i].sani();\n\t\tm[tile[i]]++;\n\t}\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tm[tile[i]]--;\n\t\tint *a=tile[i].a;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint *b=tile[j].a;\n\t\t\tm[tile[j]]--;\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\tTile t[4];\n\t\t\t\tfor(int e=0;e<4;e++){\n\t\t\t\t\tt[e]=(Tile){a[e+1],a[e],b[(d+4-e)&3],b[(d+3-e)&3]};\n\t\t\t\t\tt[e].sani();\n\t\t\t\t}\n\t\t\t\tsort(t,t+4);\n\t\t\t\tlint tmp=1;\n\t\t\t\tint cnt[4];\n\t\t\t\tfor(int e=0;e<4;e++){\n\t\t\t\t\tif(e&&t[e]==t[e-1]){\n\t\t\t\t\t\tcnt[e]=cnt[e-1]-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcnt[e]=m[t[e]];\n\t\t\t\t\t}\n\t\t\t\t\ttmp*=cnt[e]*t[e].getloop();\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tm[tile[j]]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\n#define ll long long\nmap<ll,int> mp;\nstruct Wall{\n\tint a[4];\n\tll Hash;\n\tvoid hash(){\n\t\tHash=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tHash|=a[i]<<(i*10ll);\n\t\t}\n\t}\n\tvoid update(int x){\n\t\tll now=Hash;\n\t\tfor(int i=0;i<4;i++,now=((now&1023ll)<<30ll)|(now>>10ll)){\n\t\t\tmp[now]+=x;\n\t\t}\n\t}\n\tvoid read(){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d%d%d%d\",&a[0],&a[1],&a[2],&a[3]);\n\t\t}\n\t\thash();\n\t\tupdate(1);\n\t}\n}a[405],tmp;\nll v[4];\nvoid update(ll x,int d){\n\tfor(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll)){\n\t\tmp[x]+=d;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\ta[i].read();\n\t}\n\tll ans=0,res;\n\tbool get_ans;\n\tfor(int i=1;i<=n-5;i++){\n\t\ta[i].update(-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\ta[j].update(-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tres=1;\n\t\t\t\tget_ans=1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\ttmp.a[0]=a[i].a[(l+1)&3];\n\t\t\t\t\ttmp.a[1]=a[i].a[l];\n\t\t\t\t\ttmp.a[2]=a[j].a[(3-l+k)&3];\n\t\t\t\t\ttmp.a[3]=a[j].a[(6-l+k)&3];\n\t\t\t\t\ttmp.hash();\n\t\t\t\t\tv[l]=tmp.Hash;\n\t\t\t\t\tif(!mp.count(v[l])){\n\t\t\t\t\t\tget_ans=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!get_ans){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tres*=mp[v[l]];\n\t\t\t\t\tupdate(v[l],-1);\n\t\t\t\t}\n\t\t\t\tans+=res;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tupdate(v[l],1);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[j].update(1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \nlong long ans=0;\nint n;\nstruct Node{\n    int a[5];\n    Node(int i,int j,int k,int l){\n        a[0]=i,a[1]=j,a[2]=k,a[3]=l;\n    }\n    Node(){}\n    int &operator[](const int &x){return a[x];}\n    bool operator<(const Node &b)const{\n        if(a[0]!=b.a[0])return a[0]<b.a[0];\n        else if(a[1]!=b.a[1])return a[1]<b.a[1];\n        else if(a[2]!=b.a[2])return a[2]<b.a[2];\n        else return a[3]<b.a[3];\n    }\n}col[405];\nmap<Node,int> cnt;\n \nvoid add(Node x,int k){\n    cnt[Node(x[0],x[1],x[2],x[3])]+=k;\n    cnt[Node(x[1],x[2],x[3],x[0])]+=k;\n    cnt[Node(x[2],x[3],x[0],x[1])]+=k;\n    cnt[Node(x[3],x[0],x[1],x[2])]+=k;\n}\n  \nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n        add(col[i],1);\n    }\n    for(int i=1;i<=n-1;i++){\n        add(col[i],-1);\n        for(int j=i+1;j<=n;j++){\n            add(col[j],-1);\n            for(int k=0;k<4;k++){\n                Node num[5];\n                for(int l=0;l<4;l++)\n                    num[l]=Node(col[i][l],col[j][k+5-l&3],col[j][k+4-l&3],col[i][l+1&3]);\n                if(!cnt[num[0]]||!cnt[num[1]]||!cnt[num[2]]||!cnt[num[3]])continue;\n                long long tmp=1;\n                for(int l=0;l<4;l++)tmp*=cnt[num[l]],add(num[l],-1);\n                for(int l=0;l<4;l++)add(num[l],1);\n                ans+=tmp;\n            }\n            add(col[j],1);\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\npair< int, vector< int > > norm(vector< int > C) {\n  vector< int > D(C), ret(C);\n  int same = 1;\n  for(int i = 0; i < 3; i++) {\n    rotate(begin(C), begin(C) + 1, end(C));\n    same += C == D;\n    ret = min(ret, C);\n  }\n  return {same, ret};\n}\n\n\nint main() {\n\n  int N;\n  vector< int > C[400];\n  map< vector< int >, int > same;\n  map< vector< int >, int > mp;\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    C[i].resize(4);\n    for(int j = 0; j < 4; j++) cin >> C[i][j];\n    auto ret = norm(C[i]);\n    same[ret.second] = ret.first;\n    C[i] = ret.second;\n    ++mp[C[i]];\n  }\n\n  // とりあえず上下を決めるんですが\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    --mp[C[i]];\n    for(int j = 0; j < i; j++) {\n      --mp[C[j]];\n      for(int k = 0; k < 4; k++) {\n        rotate(begin(C[j]), begin(C[j]) + 1, end(C[j]));\n        vector< int > lu(norm({C[i][1], C[i][0], C[j][1], C[j][0]}).second);\n        vector< int > zh(norm({C[i][2], C[i][1], C[j][0], C[j][3]}).second);\n        vector< int > il(norm({C[i][3], C[i][2], C[j][3], C[j][2]}).second);\n        vector< int > ed(norm({C[i][0], C[i][3], C[j][2], C[j][1]}).second);\n        if(mp.count(lu) && mp.count(zh) && mp.count(il) && mp.count(ed)) {\n          int64 add = 1;\n          add *= same[lu] * mp[lu];\n          --mp[lu];\n          add *= same[zh] * mp[zh];\n          --mp[zh];\n          add *= same[il] * mp[il];\n          --mp[il];\n          add *= same[ed] * mp[ed];\n          ret += add;\n          ++mp[il];\n          ++mp[zh];\n          ++mp[lu];\n        }\n      }\n      ++mp[C[j]];\n    }\n    ++mp[C[i]];\n  }\n  cout << ret / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvi normalize(vi a)\n{\n\tvi res=a;\n\trep(i,3){\n\t\trotate(all(a)-1,end(a));\n\t\tres=min(res,a);\n\t}\n\treturn res;\n}\n\nll count(const vvi& faces)\n{\n\tll res=1;\n\tfor(vi face:faces)\n\t\tif(face[0]==face[2]&&face[1]==face[3]){\n\t\t\tres*=2;\n\t\t\tif(face[0]==face[1])\n\t\t\t\tres*=2;\n\t\t}\n\treturn res;\n}\n\nll npr(int n,int p)\n{\n\tll res=1;\n\trep(i,p) res*=n-i;\n\treturn res;\n}\n\nll calc(const vvi& cs,map<vi,ll>& f,int ti,int bi)\n{\n\tvvi faces={\n\t\tnormalize(vi{cs[ti][1],cs[ti][0],cs[bi][1],cs[bi][0]}),\n\t\tnormalize(vi{cs[ti][2],cs[ti][1],cs[bi][0],cs[bi][3]}),\n\t\tnormalize(vi{cs[ti][3],cs[ti][2],cs[bi][3],cs[bi][2]}),\n\t\tnormalize(vi{cs[ti][0],cs[ti][3],cs[bi][2],cs[bi][1]}),\n\t};\n\tmap<vi,int> g;\n\tfor(auto face:faces) g[face]++;\n\tll res=count(faces);\n\tfor(auto p:g){\n\t\tvi face=p.first;\n\t\tint n=f[face]-(face==cs[ti])-(face==normalize(cs[bi]));\n\t\tres*=npr(n,p.second);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvvi cs(n,vi(4));\n\t\trep(i,n){\n\t\t\trep(j,4) cin>>cs[i][j];\n\t\t\tcs[i]=normalize(cs[i]);\n\t\t}\n\n\t\tmap<vi,ll> f;\n\t\trep(i,n) f[cs[i]]++;\n\n\t\tll res=0;\n\t\trep(i,n) repi(j,i+1,n) rep(k,4){\n\t\t\tres+=calc(cs,f,i,j);\n\t\t\trotate(all(cs[j])-1,end(cs[j]));\n\t\t}\n\t\tcout<<res/3<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\t   c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nint c[MAXN][4];\nint64 h[MAXN];\nmap<int64,int> zz;\nvoid insert(int64 p,int d) {\n    for(int i = 0 ; i < 4 ; ++i) {\n        zz[p] += d;\n        p = p / 1000 + (p % 1000) * 1000000000LL;\n    }\n}\nint64 calc(int64 a,int64 b,int64 c,int64 d) {\n    int64 res = d + c * 1000 + b * 1000000 + a * 1000000000;\n    return res;\n}\nint64 getcol(int64 p,int t) {\n    for(int i = 0 ; i < 3 - t ; ++i) p /= 1000;\n    return p % 1000;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        for(int j = 0 ; j < 4 ; ++j) {\n            read(c[i][j]);\n        }\n        h[i] = calc(c[i][0],c[i][1],c[i][2],c[i][3]);\n        insert(h[i],1);\n    }\n    int64 ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n        insert(h[i],-1);\n        for(int j = i + 1 ; j <= N ; ++j) {\n            insert(h[j],-1);\n            for(int k = 0 ; k < 4 ; ++k) {\n                int64 res = 1;\n\n                int64 rec[4] = {0};\n                rec[0] = calc(getcol(h[i],0),getcol(h[j],1),getcol(h[j],0),getcol(h[i],1));\n                rec[1] = calc(getcol(h[i],1),getcol(h[j],0),getcol(h[j],3),getcol(h[i],2));\n                rec[2] = calc(getcol(h[i],2),getcol(h[j],3),getcol(h[j],2),getcol(h[i],3));\n                rec[3] = calc(getcol(h[i],3),getcol(h[j],2),getcol(h[j],1),getcol(h[i],0));\n                for(int x = 0 ; x < 4 ; ++x) {\n                    res = res * zz[rec[x]];\n                    insert(rec[x],-1);\n                }\n                for(int x = 0 ; x < 4 ; ++x) {\n                    insert(rec[x],1);\n                }\n                ans += res;\n                h[j] = h[j] / 1000 + (h[j] % 1000) * 1000000000;\n            }\n            insert(h[j],1);\n        }\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T,typename U, typename H=hash<T> >\nusing gmap = cc_hash_table<T, U, H>;\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\ngmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\n\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\n__int128_t check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  __int128_t res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[(k+z)%4][i];\n          x[k+4]=cs[k][j];\n        }\n\n        int way=0;\n        A w(x);\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          chmin(w,y);\n        }\n\n        if(used.count(make_hash(w))) continue;\n        used.emplace(make_hash(w));\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=400+19;\n\nstruct node{\n\tint s[4];\n\tbool operator < (const node &B) const{\n\t\tFor(i,0,4) if (s[i]!=B.s[i]) return s[i]<B.s[i];\n\t\treturn 0;\n\t}\n\tvoid gao(){\n\t\tint tmp=s[0];\n\t\tFor(i,0,3) s[i]=s[i+1];\n\t\ts[3]=tmp;\n\t}\n} A[N],B[4];\n\nmap<node,int> M;\nint n,res;\n\nvoid dfs(int x,int tmp){\n\tif (x==4){\n\t\tres+=tmp;\n\t\treturn;\n\t}\n\tFor(i,0,4){\n\t\tif (M[B[x]]){\n\t\t\tdfs(x+1,tmp*(M[B[x]]--));\n\t\t\tM[B[x]]++;\n\t\t}\n\t\tB[x].gao();\n\t}\n}\n\nint main(){\n\tn=IN();\n\tFor(i,1,n+1){\n\t\tFor(j,0,4) A[i].s[j]=IN();\n\t\tM[A[i]]++;\n\t}\n\tFor(i,1,n+1) For(j,1,n+1) if (i!=j){\n\t\tM[A[i]]--;\n\t\tM[A[j]]--;\n\t\tFor(w,0,4){\n\t\t\tB[0]=(node){A[i].s[0],A[i].s[3],A[j].s[2],A[j].s[1]};\n\t\t\tB[1]=(node){A[i].s[3],A[i].s[2],A[j].s[3],A[j].s[2]};\n\t\t\tB[2]=(node){A[i].s[2],A[i].s[1],A[j].s[0],A[j].s[3]};\n\t\t\tB[3]=(node){A[i].s[1],A[i].s[0],A[j].s[1],A[j].s[0]};\n\t\t\tdfs(0,1);\n\t\t\tA[j].gao();\n\t\t}\n\t\tM[A[j]]++;\n\t\tM[A[i]]++;\n\t}\n\tprintf(\"%d\\n\",res/6);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=n;i--;)\n#define rrep2(i,n) for(ll i=n;i--;)\n#define rrep3(i,a,b) for(ll i=b;i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&&i:a)\n#define each2(x,y,a) for(auto&&[x,y]:a)\n#define each3(x,y,z,a) for(auto&&[x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type>name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type>name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > T(b)){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < T(b)){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nusing A=array<ll,4>;\nA normalize(A a){\n    A ans=a;\n    rep(3){\n        rotate(a.begin(),a.begin()+1,a.end());\n        chmin(ans,a);\n    }\n    return ans;\n}\nll r(A a){\n    if(a[0]!=a[2]||a[1]!=a[3])return 1;\n    if(a[0]!=a[1])return 2;\n    return 4;\n}\nconst auto Hash=[](const A&a){ull ans=0;each(i,a){ans<<=16;ans|=i;}return ans;};\nint main(){\n    LL(n);\n    VEC(A,a,n);\n    each(i,a)i=normalize(i);\n    unordered_map<A,ll,decltype(Hash)>c(100000,Hash);\n    ll ans=0;\n    rrep(n){\n        auto&x=a[i];\n        rep(j,i+1,n){\n            auto&y=a[j];\n            c[y]--;\n            rep(_,4){\n                ll cnt=1;\n                vector<A>z;\n                z.reserve(4);\n                rep(4)z.push_back(normalize({x[(i+1)&3],x[i],y[(1-i)&3],y[-i&3]}));\n                each(i,z)cnt*=r(i)*c[i]--;\n                each(i,z)c[i]++;\n                ans+=cnt;\n                rotate(y.begin(),y.begin()+1,y.end());\n            }\n            c[y]++;\n        }\n        c[x]++;\n    }\n    out(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nint b[1010][4];\nlong long a[1010][4];\nmap<long long, int> m, m2, m4;\nint mul2[5] = {1, 2, 4, 8, 16};\nint mul4[5] = {1, 4, 16, 64, 256};\nlong long pp[1010][5];\nlong long go(long long v, int t) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= t; i++) {\n\t\tif (m[v] < i) break;\n\t\tfor (int j = 0; j <= t - i; j++) {\n\t\t\tif (m2[v] < j) break;\n\t\t\tint k = t - i - j;\n\t\t\tif (m4[v] >= k) {\n\t\t\t\tres += pp[m[v]][i] * pp[m2[v]][j] * pp[m4[v]][k] * mul2[j] * mul4[k];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint ti[1010];\nvoid reg(int i, int x) {\n\tif (ti[i] == 4) {\n\t\tm4[a[i][0]] += x;\n\t}\n\tif (ti[i] == 2) {\n\t\tm2[*min_element(a[i], a[i] + 2)] += x;\n\t}\n\tif (ti[i] == 1) {\n\t\tm[*min_element(a[i], a[i] + 4)] += x;\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tpp[0][0] = 1;\n\tfor (int i = 1; i < 1010; i++) {\n\t\tpp[i][0] = 1;\n\t\tfor (int j = 1; j < 5; j++) {\n\t\t\tpp[i][j] = pp[i][j-1] * (i - j + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\ta[i][j] = (a[i][j] << 10) | b[i][(j+k)%4];\n\t\t\t}\n\t\t}\n\t\tint *v = b[i];\n\t\tif (v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) {\n\t\t\tti[i] = 4;\n\t\t} else if (v[0] == v[2] && v[1] == v[3]) {\n\t\t\tti[i] = 2;\n\t\t} else {\n\t\t\tti[i] = 1;\n\t\t}\n\t\treg(i, 1);\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v[4];\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tv[j] = (a[i][0] >> ((3-j) * 10)) & 1023;\n\t\t}\n\t\treg(i, -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint w[4];\n\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\tw[l] = (a[j][0] >> ((3-l) * 10)) & 1023;\n\t\t\t}\n\t\t\treg(j, -1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\tmap<long long, int> f;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tint u[4];\n\t\t\t\t\tu[0] = w[l];\n\t\t\t\t\tu[1] = w[(l+1)%4];\n\t\t\t\t\tu[2] = v[(l+1)%4];\n\t\t\t\t\tu[3] = v[l];\n\t\t\t\t\tlong long z = 1ll << 61;\n\t\t\t\t\tfor (int r = 0; r < 4; r++) {\n\t\t\t\t\t\tlong long tmp = 0;\n\t\t\t\t\t\tfor (int q = 0; q < 4; q++) {\n\t\t\t\t\t\t\ttmp = (tmp << 10) | u[(r+q)%4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = min(z, tmp);\n\t\t\t\t\t}\n\t\t\t\t\tf[z]++;\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (map<long long, int>::iterator it = f.begin(); it != f.end(); it++) {\n\t\t\t\t\ttmp *= go(it->first, it->second);\n\t\t\t\t}\n\n\t\t\t\tans += tmp;\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\trotate(w, w + 1, w + 4);\n\t\t\t}\n\t\t\treg(j, 1);\n\t\t}\n\t\treg(i, 1);\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nvi rotate_square(vi a) {\n  a.push_back(a[0]);\n  a.erase(a.begin());\n  return a;\n}\n\nvi normalize_square(vi a) {\n  vi temp = a;\n  rep (i, 3) {\n    a = rotate_square(a);\n    temp = min(temp, a);\n  }\n  return temp;\n}\n\n\nclass Box {\npublic:\n  vi color;\n  \n  Box(){\n    color.resize(8);\n  }\n  void set_up(vi a) {\n    rep (i, 4) color[i] = a[i];\n  }\n  void set_down(vi a) {\n    rep (i, 4) color[i + 4] = a[3 - i];\n  }\n\n  vii get_side() {\n    vii res(4, vi(4));\n    rep (i, 4) {\n      res[i][0] = i;\n      res[i][1] = (i + 3) % 4;\n      res[i][2] = res[i][1] + 4;\n      res[i][3] = res[i][2] + 1;\n      if (res[i][3] == 8) res[i][3] = 4;\n      rep (j, 4) {\n        res[i][j] = color[res[i][j]];\n      }\n    }\n    return res;\n  }\n  \n};\n\nll nCr(ll n, ll r) {\n  assert(r <= 4);\n  ll ans = 1;\n  rep (i, r) {\n    ans *= n;\n    n--;\n  }\n  return ans;\n}\n\nint square_num(vi a) {\n  vi initial = a;\n  int ans = 0;\n  rep (i, 4) {\n    if (initial == a) ans++;\n    a = rotate_square(a);\n  }\n  return ans;\n}\n\nll solve(Box &box, vii& c) {\n  if (c.size() < 4) return 0;\n  vii sides = box.get_side();\n  map<vi, int> mp;\n  rep (i, 4) {\n    sides[i] = normalize_square(sides[i]);\n    mp[sides[i]] = 0;\n  }\n\n  rep (i, c.size()) {\n    if (mp.count(c[i])) {\n      mp[c[i]]++;\n    }\n  }\n\n  ll ans = 1;\n  rep (i, 4) {\n    ll n = mp[sides[i]];\n    ans = ans * n * square_num(sides[i]);\n    mp[sides[i]]--;\n  }\n  return ans;\n}\n\nsigned main() {\n  fio();\n  int n;\n  cin >> n;\n\n  vii c(n, vi(4));\n  rep (i, n) {\n    rep (j, 4) {\n      cin >> c[i][j];\n    }\n    c[i] = normalize_square(c[i]);\n  }\n\n  Box box;\n  ll ans = 0;\n  rep (i, n) {\n    box.set_up(c[i]);\n    for (int j = i + 1; j < n; j++) {\n      vi ccc = c[j];\n      vii temp;\n      for (int k = i + 1; k < n; k++) {\n        if (j == k) continue;\n        temp.push_back(c[k]);\n      }\n      rep (_, 4) {\n        box.set_down(ccc);\n        ll add = solve(box, temp);\n        ans += add;\n        ccc = rotate_square(ccc);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i, x) for (int i = 0; i < x; i++)\n#define rep1(i, x) for (int i = 1; i <= x; i++)\n#define rrep(i, x) for (int i = x - 1; i >= 0; i--)\n#define rrep1(i, x) for (int i = x; i > 0; i--)\n#define sor(v) sort(v.begin(), v.end())\n#define rev(s) reverse(s.begin(), s.end())\n#define lb(vec, a) lower_bound(vec.begin(), vec.end(), a)\n#define ub(vec, a) upper_bound(vec.begin(), vec.end(), a)\n#define uniq(vec) vec.erase(unique(vec.begin(), vec.end()), vec.end())\n#define mp1(a, b, c) P1(a, P(b, c))\n\nconst int INF = 1000000000;\nconst ll M = 1000000000;\nconst int dir_4[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconst int dir_8[8][2] = {{1, 0},  {1, 1},   {0, 1},  {-1, 1},\n                         {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\n/*----------------------------------------------/\n/- char         : %c  | char *       : %s  | short        : %hd\n/- int          : %d  | long         : %ld | long long    : %lld\n/- unsigned short:%hu | unsigned int : %u  | unsigned long: %lu\n/- u_long long  : %llu| (octal)      : %o  | (hexadecimal): %x\n/- float        : %f  | double       : %lf |\n/----------------------------------------------*/\n\n/*----------------------------------------------/\n/- INT_MAX, LONG_MAX   : 1<<15 = 2.1*pow(10, 9)       (= 2147483647)\n/- UINT_MAX, ULONG_MAX : 1<<16 = 4.2*pow(10, 9)       (= 4294967295)\n/- LLONG_MAX           : 1<<63 = 9.2*pow(10, 18)      (= 9223372036854775807)\n/- ULLONG_MAX          : 1<<64 = 1.8*pow(10, 19)      (= 18446744073709551615)\n/----------------------------------------------*/\n\nP f(ll x, ll y, ll z, ll w) {\n    ll c[4] = {x, y, z, w};\n    ll a[4] = {};\n    rep(i, 4) {\n        rep(j, 4) {\n            a[i] *= 1000;\n            a[i] += c[(i + j) % 4];\n        }\n    }\n    ll ret = max(max(a[0], a[1]), max(a[2], a[3]));\n    ll cnt = 0;\n    rep(i, 4) if (a[i] == ret) cnt++;\n    return P(ret, cnt);\n}\n\nint main() {\n    int n;\n    ll c[402][4];\n    P A[402];\n    scanf(\"%d\", &n);\n    rep(i, n) {\n        rep(j, 4) { cin >> c[i][j]; }\n        A[i] = f(c[i][0], c[i][1], c[i][2], c[i][3]);\n    }\n\n    map<ll, int> M;\n    rep(i, n) M[A[i].fr] += A[i].sc;\n\n    ll ret = 0;\n    rep(i, n) {\n        M[A[i].fr] -= A[i].sc;\n        for (int j = i + 1; j < n; j++) {\n            M[A[j].fr] -= A[j].sc;\n            rep(k, 4) {\n                P x[4];\n                ll _ret = 1;\n                rep(l, 4) {\n                    x[l] = f(c[i][l], c[j][(k + 4 - l) % 4],\n                             c[j][(k + 4 - l - 1) % 4], c[i][(l + 1) % 4]);\n                    _ret *= M[x[l].fr];\n                    M[x[l].fr] -= x[l].sc;\n                }\n                rep(l, 4) { M[x[l].fr] += x[l].sc; }\n                ret += _ret;\n            }\n            M[A[j].fr] += A[j].sc;\n        }\n    }\n\n    cout << ret;\n    /* ====================================== */\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 400 + 100;\n\nint n;\nlong long s[MAXN];\nmap<long long, int> cnt;\n\nlong long get_ind(int x0, int x1, int x2, int x3)\n{\n\treturn (x0) | (x1 << 10) | (x2 << 20) | ((long long)x3 << 30);\n}\n\nint get_dig(long long s, int k)\n{\n\treturn (s >> (10 * k)) & 1023;\n}\n\nvoid add(long long s, int v)\n{\n\tfor(int i = 0; i < 4; i++)\n\t\tcnt[s] += v, s = (s >> 10) | ((s & 1023) << 30);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x0, x1, x2, x3;\n\t\tcin >> x0 >> x1 >> x2 >> x3;\n\t\ts[i] = get_ind(x0, x1, x2, x3);\n\t\tadd(s[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tadd(s[i], -1);\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tadd(s[j], -1);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tlong long t[4] = {\n\t\t\t\t\tget_ind(get_dig(s[j], k), get_dig(s[j], (k + 3) % 4), get_dig(s[i], 1), get_dig(s[i], 0)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 3) % 4), get_dig(s[j], (k + 2) % 4), get_dig(s[i], 2), get_dig(s[i], 1)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 2) % 4), get_dig(s[j], (k + 1) % 4), get_dig(s[i], 3), get_dig(s[i], 2)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 1) % 4), get_dig(s[j], k), get_dig(s[i], 0), get_dig(s[i], 3))\n\t\t\t\t};\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tif(cnt.find(t[l]) == cnt.end())\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = 0; break;\n\t\t\t\t\t}\n\t\t\t\tif(!tmp) continue;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\ttmp *= cnt[t[l]], add(t[l], -1);\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tadd(t[l], 1);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tadd(s[j], 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 444;\n\nint n;\nint a[N][4];\nll form[N];\n\ntemplate<class T>\nll id(T a) {\n    ll res = 1e18;\n    forn(off,4) {\n        ll tmp = 0;\n        forn(i,4) tmp = 1000*tmp + a[(i+off)%4];\n        res = min(res, tmp);\n    }\n    return res;\n}\n\nint rotations(int a[]) {\n    int res = 0;\n    forn(off,4) {\n        bool ok = true;\n        forn(i,4) if (a[i] != a[(i+off)%4]) ok = false;\n        res += ok;\n    }\n    return res;\n}\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    map<ll,int> cnt, mult;\n    forn(i,n) {\n        forn(j,4) cin >> a[i][j];\n        form[i] = id(a[i]);\n        cnt[form[i]]++;\n        mult[form[i]] = rotations(a[i]);\n    }\n\n    ll res = 0;\n    forn(j,n) forn(i,j) {\n        cnt[form[i]]--; cnt[form[j]]--;\n        forn(oi,4) {\n            forn(oj,4) {\n                ll tmp = 1;\n                ll x = id(vi{a[i][3], a[i][2], a[j][1], a[j][0]});\n                ll y = id(vi{a[j][3], a[j][2], a[i][1], a[i][0]});\n                ll z = id(vi{a[i][2], a[i][1], a[j][2], a[j][1]});\n                ll w = id(vi{a[i][0], a[i][3], a[j][0], a[j][3]});\n\n                tmp *= mult[x] * cnt[x]--;\n                tmp *= mult[y] * cnt[y]--;\n                tmp *= mult[z] * cnt[z]--;\n                tmp *= mult[w] * cnt[w]--;\n                cnt[x]++; cnt[y]++; cnt[z]++; cnt[w]++;\n                res += tmp;\n                rotate(a[j], a[j]+1, a[j]+4);\n            }\n            rotate(a[i], a[i]+1, a[i]+4);\n        }\n        cnt[form[i]]++; cnt[form[j]]++;\n    }\n    res /= 12;\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst int INF=5e8;\n\ntypedef long long Int;\n\nint col[405][4];\nint n;\n\nint need[4][4];\n\nint match[405][4];\n\ntypedef vector<int> vi;\nvi getmini(vi c){\n  vector<int> mini(4,INF);\n  REP(k,4){\n    vector<int> tmp=c;\n    rotate(tmp.begin(),tmp.begin()+k,tmp.end());\n    chmin(mini,tmp);\n  }\n  return mini;\n}\nInt dp[405][16];\nint coef[405];\nint main(){\n  cin>>n;\n  REP(i,n){\n    vector<int> c(4),mini;\n    REP(j,4) cin>>c[j];\n    mini=getmini(c);\n\n    REP(j,4) col[i][j]=mini[j];\n    if(mini[0]==mini[1] && mini[1]==mini[2] && mini[2]==mini[3]) coef[i]=4;\n    else if(mini[0]==mini[2] && mini[1]==mini[3]) coef[i]=2;\n    else coef[i]=1;\n  }\n\n\n\n  Int res=0;\n  REP(i,n) REP(j,i) REP(d,4){\n    int back[4];\n    REP(k,4) back[k]=col[j][3-k];\n    rotate(back,back+d,back+4);\n\n    REP(k,4){\n      vi tmp(4),mini;\n      tmp[0]=back[k];\n      tmp[1]=back[(k+1)%4];\n      tmp[2]=col[i][(1+k)%4];\n      tmp[3]=col[i][k];\n      mini=getmini(tmp);\n      REP(l,4) need[k][l]=mini[l];\n    }\n    CLR(match);\n    REP(k,i) if(k!=j){\n      REP(d2,4){\n        bool fail=false;\n        REP(l,4) if(need[d2][l]!=col[k][l]) fail=true;\n        if(!fail){\n          match[k][d2]=coef[k];\n        }\n      }\n    }\n    CLR(dp);\n    dp[0][0]=1;\n    REP(k,i) REP(bit,16) if(dp[k][bit]){\n      Int val=dp[k][bit];\n      dp[k+1][bit]+=val;\n      REP(l,4) if(!(bit>>l&1) && match[k][l]) dp[k+1][bit|(1<<l)]+=val*match[k][l];\n    }\n    res+=dp[i][15];\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nvector<int> Normalize(vector<int> xs) {\n  vector<deque<int>> rs;\n  deque<int> q(xs.begin(), xs.end());\n  rs.push_back(q);\n  for (int i = 0; i < 3; i++) {\n    q.push_back(q.front());\n    q.pop_front();\n    rs.push_back(q);\n  }\n  sort(rs.begin(), rs.end());\n  return vector<int>(rs[0].begin(), rs[0].end());\n}\n\nint Symmetry(vector<int> xs) {\n  if (xs[0] == xs[1] && xs[1] == xs[2] && xs[2] == xs[3]) return 4;\n  if (xs[0] == xs[2] && xs[1] == xs[3]) return 2;\n  return 1;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  s << \"[\";\n  for (int i = 0; i < len; i++) {\n    if (i > 0) s << \", \";\n    s << v[i];\n  }\n  s << \"]\";\n  return s;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> faces;\n  for (int i = 0; i < n; i++) {\n    vector<int> cs(4);\n    for (int j = 0; j < 4; j++) {\n      cin >> cs[j];\n    }\n    faces.push_back(Normalize(cs));\n  }\n\n  int64 ans = 0;\n  for (int f1 = 0; f1 < n; f1++) {\n    for (int f2 = f1 + 1; f2 < n; f2++) {\n      for (int d2 = 0; d2 < 4; d2++) {\n        vector<int> vs(8);\n        for (int i = 0; i < 4; i++) vs[i] = faces[f1][i];\n        for (int i = 0; i < 4; i++) vs[7 - i] = faces[f2][(d2 + i) % 4];\n        // cout << vs << endl;\n\n        map<vector<int>, int> r_count;\n        r_count[(Normalize({vs[4], vs[5], vs[1], vs[0]}))]++;\n        r_count[(Normalize({vs[5], vs[6], vs[2], vs[1]}))]++;\n        r_count[(Normalize({vs[6], vs[7], vs[3], vs[2]}))]++;\n        r_count[(Normalize({vs[7], vs[4], vs[0], vs[3]}))]++;\n\n        map<vector<int>, int> s_count;\n        for (int f3 = f1 + 1; f3 < n; f3++) {\n          if (f3 == f2) continue;\n          // cout << faces[f3] << endl;\n          if (r_count.find(faces[f3]) != r_count.end()) {\n            s_count[faces[f3]]++;\n          }\n        }\n\n        // for (const auto& kv : r_count) {\n        //   cout << kv.first << \" \" << s_count[kv.first] << \" \";\n        // }\n        // cout << endl;\n\n        int64 inc = 1;\n        for (const auto& kv : r_count) {\n          int r = kv.second;\n          int s = s_count[kv.first];\n          if (r > s) inc *= 0;\n          for (int k = 0; k < r; k++) {\n            inc *= (s - k);\n            inc *= Symmetry(kv.first);\n          }\n        }\n        ans += inc;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    map<C, int> P;\n    map<C, int> R;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        R[x] = rot(x);\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        P[p]--;\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            P[q]--;\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}});\n                    int opts = P[u[l]];\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*R[u[l]];\n                    }\n                    P[u[l]]--;\n                }\n                for (int l = 0; l < 4; l++) {\n                    P[u[l]]++;\n                }\n                ans += cur;\n            }\n            P[q]++;\n        }\n        P[p]++;\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct squ\n{\n\tlong long a,b,c,d;\n\tbool operator == (const squ &u) const\n\t{\n\t\treturn (a==u.a && b==u.b && c==u.c && d==u.d);\n\t}\n\tbool operator < (const squ &u) const\n\t{\n\t\tif (a!=u.a) return a<u.a;\n\t\tif (b!=u.b) return b<u.b;\n\t\tif (c!=u.c) return c<u.c;\n\t\treturn d<u.d;\n\t}\n};\nlong long eqal(squ u,squ v)\n{\n\tlong long res=0;\n\tif (u==v) res++;\n\tif (u==(squ){v.b,v.c,v.d,v.a}) res++;\n\tif (u==(squ){v.c,v.d,v.a,v.b}) res++;\n\tif (u==(squ){v.d,v.a,v.b,v.c}) res++;\n\treturn res;\n}\nlong long n,x,y,z,w,lans,ans;\nvector<squ> v;\nmap<squ,long long> mp;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld%lld%lld\",&x,&y,&z,&w);\n\t\tfor (long long j=0;j<v.size();j++)\n\t\t{\n\t\t\tsqu cur=v[j],a1=(squ){x,w,cur.c,cur.b},a2=(squ){z,y,cur.a,cur.d},a3=(squ){y,x,cur.b,cur.a},a4=(squ){w,z,cur.d,cur.c};\n\t\t\tlans=mp[a1]-eqal(cur,a1);\n\t\t\tlans*=(mp[a2]-eqal(cur,a2)-eqal(a1,a2));\n\t\t\tlans*=(mp[a3]-eqal(cur,a3)-eqal(a1,a3)-eqal(a2,a3));\n\t\t\tlans*=(mp[a4]-eqal(cur,a4)-eqal(a1,a4)-eqal(a2,a4)-eqal(a3,a4));\n\t\t\tans+=lans;\n\t\t}\n\t\tv.push_back((squ){x,y,z,w});v.push_back((squ){y,z,w,x});v.push_back((squ){z,w,x,y});v.push_back((squ){w,x,y,z});\n\t\tmp[(squ){x,y,z,w}]++;mp[(squ){y,z,w,x}]++;mp[(squ){z,w,x,y}]++;mp[(squ){w,x,y,z}]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\n#define N 410\n#define lint long long\n#define ull unsigned long long\n#define gc getchar()\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nint Gc;unordered_map<lint,int> cnt;lint val[1000];\nint c[N][5];lint cv[N][4];\ninline lint hv(int a,int b,int c,int d)\n{\n\treturn a*1000000000ll+b*1000000ll+c*1000ll+d;\n}\ninline lint hv(int *a)\n{\n\treturn hv(a[0],a[1],a[2],a[3]);\n}\ninline int Rot(int *a,int c)\n{\n\trep(i,1,c)\n\t{\n\t\tint tmp=a[0];\n\t\trep(j,1,3) a[j-1]=a[j];\n\t\ta[3]=tmp;\n\t}\n\treturn 0;\n}\ninline int Add(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]++;\n\treturn 0;\n}\ninline int Del(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]--;\n\treturn 0;\n}\ninline int Get(int a,int b,int c,int d)\n{\n\tint t=cnt[hv(a,b,c,d)];\n\tcnt[val[++Gc]=hv(a,b,c,d)]--;\n\tcnt[val[++Gc]=hv(b,c,d,a)]--;\n\tcnt[val[++Gc]=hv(c,d,a,b)]--;\n\tcnt[val[++Gc]=hv(d,a,b,c)]--;\n\treturn t;\n}\ninline int Back()\n{\n\trep(i,1,Gc) cnt[val[i]]++;\n\tGc=0;return 0;\n}\nint main()\n{\n\tint n=inn();ull ans=0ll;\n\trep(i,1,n) rep(j,0,3) c[i][j]=inn();\n\trep(i,1,n)\n\t{\n\t\t#define a c[i]\n\t\tcnt[cv[i][0]=hv(a[0],a[1],a[2],a[3])]++;\n\t\tcnt[cv[i][1]=hv(a[1],a[2],a[3],a[0])]++;\n\t\tcnt[cv[i][2]=hv(a[2],a[3],a[0],a[1])]++;\n\t\tcnt[cv[i][3]=hv(a[3],a[0],a[1],a[2])]++;\n\t\t#undef a\n\t}\n\trep(i,1,n)\n\t{\n\t\tDel(i);\n\t\trep(p,0,3)\n\t\t{\n//\t\t\tRot(c[i],p);\n\t\t\trep(j,1,n) if(i!=j)\n\t\t\t{\n\t\t\t\tDel(j);\n\t\t\t\trep(q,0,3)\n\t\t\t\t{\n//\t\t\t\t\tRot(c[j],q);\n\t\t\t\t\tint s,x,z,y;\n\t\t\t\t\ts=Get(c[j][1],c[j][0],c[i][1],c[i][0]);//S\n\t\t\t\t\tif(!s) goto loop;\n\t\t\t\t\tx=Get(c[j][2],c[i][3],c[i][2],c[j][3]);//X\n\t\t\t\t\tif(!x) goto loop;\n\t\t\t\t\tz=Get(c[j][1],c[i][0],c[i][3],c[j][2]);//Z\n\t\t\t\t\tif(!z) goto loop;\n\t\t\t\t\ty=Get(c[i][1],c[j][0],c[j][3],c[i][2]);//Y\n\t\t\t\t\tif(!y) goto loop;\n\t\t\t\t\tans+=1ll*s*x*z*y;\n\t\t\t\t\tloop:;\n\t\t\t\t\tBack();\n\t\t\t\t\tRot(c[j],1);\n\t\t\t\t}\n\t\t\t\tAdd(j);\n\t\t\t}\n\t\t\tRot(c[i],1);\n\t\t}\n\t\tAdd(i);\n\t}\n\treturn !printf(\"%llu\\n\",ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\ntypedef unsigned long long ull;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 405;\n\nmap<ull,int>cnt;\nint a[N][4];\nint n;\nLL ans;\null id[N];\nint w[4][4]={{1,0,1,0},{2,1,0,3},{3,2,3,2},{0,3,2,1}};\n\nint trs(int *a){\n\tull mv;\n\tfo(st,0,3){\n\t\tull tmp=0;\n\t\tfor(int i=st;i<4;i++)tmp=tmp*1003+a[i];\n\t\tfor(int i=0;i<st;i++)tmp=tmp*1003+a[i];\n\t\tif (st==0||tmp<mv)mv=tmp;\n\t}\n\treturn mv;\n}\n\nint calc(int *a){\n\tint t=0;\n\tfo(d,0,3){\n\t\tbool pd=1;\n\t\tfo(i,0,3)\n\t\tif (a[i]!=a[(i+d)%4])pd=0;\n\t\tif (pd)t++;\n\t}\n\treturn t;\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n){\n\t\ta[i][0]=get();a[i][1]=get();a[i][2]=get();a[i][3]=get();\n\t\tcnt[id[i]=trs(a[i])]++;\n\t}\n\tans=0;\n\tfo(i,1,n)\n\t\tfo(j,i+1,n){\n\t\t\tcnt[id[i]]--;cnt[id[j]]--;\n\t\t\tfo(tim,0,3){\n\t\t\t\tull t[4];\n\t\t\t\tLL tv=1;\n\t\t\t\tfo(c,0,3){\n\t\t\t\t\tint col[4];\n\t\t\t\t\tcol[0]=a[i][w[c][0]];col[1]=a[i][w[c][1]];\n\t\t\t\t\tcol[2]=a[j][(w[c][2]+tim)%4];col[3]=a[j][(w[c][3]+tim)%4];\n\t\t\t\t\tull tmp=trs(col);\n\t\t\t\t\ttv=tv*calc(col)*cnt[tmp];\n\t\t\t\t\tcnt[tmp]--;\n\t\t\t\t\tt[c]=tmp;\n\t\t\t\t}\n\t\t\t\tans=ans+tv;\n\t\t\t\tfo(c,0,3)cnt[t[c]]++;\n\t\t\t}\n\t\t\tcnt[id[i]]++;cnt[id[j]]++;\n\t\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n\nusing namespace std;\ntypedef long long ll;\n//____________________________________________\n//____________________________________________\n//__________________OOOOOOOOOOOOOOOO__________\n//_________________OO_____________OO__________\n//________________O_O____________O_O__________\n//_______________O__O___________O__O__________\n//______________O___O__________O___O__________\n//_____________O____O_________O____O__________\n//____________OOOOOOOOOOOOOOOO_____O__________\n//____________O_____O________O_____O__________\n//____________O_____OOOOOOOOOOOOOOOO__________\n//____________O____O_________O____O___________\n//____________O___O__________O___O____________\n//____________O__O___________O__O_____________\n//____________O_O____________O_O______________\n//____________OO_____________OO_______________\n//____________OOOOOOOOOOOOOOOO________________\n//____________________________________________\n//____________________________________________\n\nconst long long MOD = 1e9 + 7;\nll n;\nll c[500][4];\nll ans;\nmap<vector<int>, int> g;\n\nvector<int> reform(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 4; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 4; j++)\n        {\n            x.push_back(c[(i + j) % 4]);\n        }\n        cc.push_back(x);\n    }\n    sort(cc.begin(), cc.end());\n    return cc[0];\n}\n\nll cnk(ll k, ll n)\n{\n    if (k > n)\n        return 0;\n    if (k == 0)\n        return 1;\n    if (k == 1)\n        return n;\n    if (k == 2)\n        return n * (n - 1) / 2;\n    if (k == 3)\n        return n * (n - 1) * (n - 2) / 6;\n    if (k == 4)\n        return n * (n - 1) * (n - 2) * (n - 3) / 24;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            for (int o1 = 0; o1 < 4; o1++)\n            {\n                //     c[j][1] ---- c[j][0]\n                //       /|            /|\n                //      / |           / |\n                //     /  c[j][2]    /  c[j][3]\n                // c[i][o1] ---- c[i][o1 + 1]\n                //    | /            |\n                //    |/             |\n                // c[i][o1 + 3] ---- c[i][o1 + 2]\n                int ful = c[i][o1];\n                int fur = c[i][(o1 + 1) % 4];\n                int fdl = c[i][(o1 + 3) % 4];\n                int fdr = c[i][(o1 + 2) % 4];\n\n                int bul = c[j][1];\n                int bur = c[j][0];\n                int bdl = c[j][2];\n                int bdr = c[j][3];\n\n                vector<int> l = {ful, fdl, bdl, bul};\n                vector<int> u = {fur, ful, bul, bur};\n                vector<int> r = {fur, bur, bdr, fdr};\n                vector<int> d = {fdl, fdr, bdr, bdl};\n\n                ll swappers = 1;\n\n                ll y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (l[y] != l[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (d[y] != d[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (u[y] != u[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (r[y] != r[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                r = reform(r);\n                l = reform(l);\n                u = reform(u);\n                d = reform(d);\n\n                map<vector<int>, int> gg2;\n                gg2[r]++;\n                gg2[l]++;\n                gg2[u]++;\n                gg2[d]++;\n\n                for (auto it : gg2)\n                {\n                    swappers *= cnk(it.second, g[it.first]);\n                }\n\n                ans += swappers;\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n;\nL p;\nstruct orz;\ninline orz minn(orz a,orz b);\nstruct orz\n{\n\tint a[4];\n\tinline void in()\n\t{\n\t\tint i;\n\t\tfor(i=0;i<4;i++)\n\t\t  scanf(\"%d\",&a[i]);\n\t}\n\tinline orz trans()\n\t{\n\t\torz x;\n\t\tx.a[0]=a[1];\n\t\tx.a[1]=a[2];\n\t\tx.a[2]=a[3];\n\t\tx.a[3]=a[0];\n\t\treturn x;\n\t}\n\tinline bool operator==(orz x)\n\t{\n\t\treturn a[0]==x.a[0] && a[1]==x.a[1] && a[2]==x.a[2] && a[3]==x.a[3];\n\t}\n\tinline bool operator<(orz x)const\n\t{\n\t\treturn minn(*this,x)==*this && !(x==*this);\n\t}\n\tinline void print()\n\t{\n\t\tint i;\n\t\tfor(i=0;i<4;i++)\n\t\t  printf(\"%d \",a[i]);\n\t    printf(\"!!\\n\");\n\t}\n}x[410],a,b,w[4];\nmap<orz,int> f;\ninline int count(orz x)\n{\n\tif(x.a[0]==x.a[2] && x.a[1]==x.a[3])\n\t  if(x.a[0]==x.a[1])\n\t    return 4;\n\t  else\n\t    return 2;\n\treturn 1;\n}\ninline orz minn(orz a,orz b)\n{\n\tint i;\n\tfor(i=0;i<4;i++)\n\t  {\n\t   if(a.a[i]<b.a[i])\n\t     return a;\n\t   if(b.a[i]<a.a[i])\n\t     return b;\n\t  }\n\treturn a;\n}\ninline orz minn(orz a)\n{\n\torz b=a,c=a;\n\tint i;\n\tfor(i=1,b=b.trans();i<4;i++,b=b.trans())\n\t  c=minn(b,c);\n\treturn c;\n}\ninline void add(orz a,int k)\n{\n\tint i;\n\torz b=minn(a);\n\tf[b]+=count(a)*k;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l,u,v;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  x[i].in();\n\tfor(i=1;i<=n;i++)\n\t  add(x[i],1);\n\tfor(i=1;i<n;i++)\n\t  {\n\t   add(x[i],-1);\n\t   for(j=0,a=x[i];j<4;j++,a=a.trans())\n\t     for(k=i+1;k<=n;k++)\n\t       {\n\t\t    b=x[k];\n\t\t\tadd(x[k],-1);\n\t\t\tw[0].a[0]=b.a[1];\n\t\t\tw[0].a[1]=a.a[0];\n\t\t\tw[0].a[2]=a.a[3];\n\t\t\tw[0].a[3]=b.a[2];\n\t\t\tw[1].a[0]=b.a[0];\n\t\t\tw[1].a[1]=a.a[1];\n\t\t\tw[1].a[2]=a.a[0];\n\t\t\tw[1].a[3]=b.a[1];\n\t\t\tw[2].a[0]=b.a[3];\n\t\t\tw[2].a[1]=a.a[2];\n\t\t\tw[2].a[2]=a.a[1];\n\t\t\tw[2].a[3]=b.a[0];\n\t\t\tw[3].a[0]=b.a[2];\n\t\t\tw[3].a[1]=a.a[3];\n\t\t\tw[3].a[2]=a.a[2];\n\t\t\tw[3].a[3]=b.a[3];\n\t\t\tL q=1;\n\t\t\tfor(l=0;l<4;l++)\n\t\t\t  {\n\t\t\t   w[l]=minn(w[l]);\n\t\t\t   v=f[w[l]];\n\t\t\t   for(u=0;u<l;u++)\n\t\t\t     if(w[l]==w[u])\n\t\t\t\t   v-=count(w[l]);\n\t\t\t   q*=v;\n\t\t\t  }\n\t\t\tadd(x[k],1);\n\t\t\tp+=q;\n\t\t   }\n\t   add(x[i],1);\n\t  }\n\tp/=3;\n\tprintf(\"%lld\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nmap<ll,int> m;\n\nvoid modify(ll x,int k){\n\tfor(int i=0;i<4;i++){\n\t\tm[x]+=k;\n\t\tx=(x>>10)|((x&1023)<<30);\n\t}\n}\n\nll Hash(ll a,ll b,ll c,ll d){\n\treturn (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nll f[400][4],h[400],tmp[4];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>f[i][0]>>f[i][1]>>f[i][2]>>f[i][3];\n\t\th[i]=Hash(f[i][0],f[i][1],f[i][2],f[i][3]);\n\t\tmodify(h[i],1);\n\t}\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmodify(h[i],-1);\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tmodify(h[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\ttmp[0]=Hash(f[i][3],f[i][2],f[j][(k+1)%4],f[j][k]);\n\t\t\t\ttmp[1]=Hash(f[i][2],f[i][1],f[j][(k+2)%4],f[j][(k+1)%4]);\n\t\t\t\ttmp[2]=Hash(f[i][1],f[i][0],f[j][(k+3)%4],f[j][(k+2)%4]);\n\t\t\t\ttmp[3]=Hash(f[i][0],f[i][3],f[j][k],f[j][(k+3)%4]);\n\t\t\t\tll z=1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tz*=m[tmp[l]];\n\t\t\t\t\tmodify(tmp[l],-1);\n\t\t\t\t}\n\t\t\t\tans+=z;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tmodify(tmp[l],1);\n\t\t\t}\n\t\t\tmodify(h[j],1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tvector<array<int, 4>>c(N);\n\trep(i, N)rep(j, 4)cin >> c[i][j];\n\tmap<int, vector<int>>m1;\n\tmap<array<int, 4>, vector<array<int, 2>>>m4;\n\trep(i, N) {\n\t\tif (c[i][0] == c[i][1] && c[i][1] == c[i][2] && c[i][2] == c[i][3]) {\n\t\t\tm1[c[i][0]].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trep(j, 4) {\n\t\t\t\tm4[{ c[i][j], c[i][(j + 1) % 4], c[i][(j + 2) % 4], c[i][(j + 3) % 4] }].push_back({ i,j });\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i, N)REP(j, i + 1, N)rep(k, 4) {\n\t\tarray<int, 4>a1 = { c[i][0],c[j][(k + 1) % 4],c[j][(k + 0) % 4],c[i][1] };\n\t\tarray<int, 4>a2 = { c[i][1],c[j][(k + 0) % 4],c[j][(k + 3) % 4],c[i][2] };\n\t\tarray<int, 4>a3 = { c[i][2],c[j][(k + 3) % 4],c[j][(k + 2) % 4],c[i][3] };\n\t\tarray<int, 4>a4 = { c[i][3],c[j][(k + 2) % 4],c[j][(k + 1) % 4],c[i][0] };\n\t\tfor (auto x1 : m4[a1])if (i < x1[0] && j != x1[0]) {\n\t\t\tfor (auto x2 : m4[a2])if (i < x2[0] && j != x2[0] && x1[0] != x2[0]) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1[0] != x3[0] && x2[0] != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2[0] != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(auto x4:m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2[0] != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(auto x3:m1[a3[0]])if (i < x3 && j != x3 && x1[0] != x3 && x2[0] != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2[0] != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2[0] != x4 && x3 != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto x2:m1[a2[0]])if (i < x2 && j != x2 && x1[0] != x2) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1[0] != x3[0] && x2 != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2 != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2 != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto x3 : m1[a3[0]])if (i < x3 && j != x3 && x1[0] != x3 && x2 != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2 != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1[0] != x4 && x2 != x4 && x3 != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto x1:m1[a1[0]])if (i < x1 && j != x1) {\n\t\t\tfor (auto x2 : m4[a2])if (i < x2[0] && j != x2[0] && x1 != x2[0]) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1 != x3[0] && x2[0] != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2[0] != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2[0] != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto x3 : m1[a3[0]])if (i < x3 && j != x3 && x1 != x3 && x2[0] != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2[0] != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2[0] != x4 && x3 != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto x2 : m1[a2[0]])if (i < x2 && j != x2 && x1 != x2) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1 != x3[0] && x2 != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2 != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2 != x4 && x3[0] != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto x3 : m1[a3[0]])if (i < x3 && j != x3 && x1 != x3 && x2 != x3) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1 != x4[0] && x2 != x4[0] && x3 != x4[0]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto x4 : m1[a4[0]])if (i < x4 && j != x4 && x1 != x4 && x2 != x4 && x3 != x4) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N;\nvi a[400];\nll ans = 0;\nunordered_map<ll,int> u;\n\nll hsh(vi v) {\n    return v[0]+1000LL*v[1]+1000000LL*v[2]+1000000000LL*v[3];\n}\n\nvi rot(vi a, int b) {\n    rotate(a.begin(),a.begin()+b,a.end());\n    return a;\n}\n\nll minRot(vi a) {\n    ll z = 1e12;\n    F0R(i,4) z = min(z,hsh(rot(a,i)));\n    return z;\n}\n\nvoid ad(int x, int ind) {\n    F0R(i,4) u[hsh(rot(a[x],i))] += ind;\n}\n\nvoid tri(int x, int y) {\n    F0R(i,4) {\n        vi t1 = a[x]; \n        vi t2 = rot(a[y],i); reverse(all(t2));\n        \n        ll num = 1;\n        vl p;\n        \n        F0R(j,4) {\n            vi z = {t2[j],t2[(j+1)%4],t1[(j+1)%4],t1[j]};\n            ll Z = hsh(z);\n            ll tnum = u[Z];\n            for (auto a: p) if (a == Z) tnum --;\n            num *= tnum;\n            F0R(i,4) p.pb(hsh(rot(z,i)));\n        }\n        ans += num;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N) {\n        a[i].resize(4);\n        F0R(j,4) cin >> a[i][j];\n        ad(i,1);\n    }\n    F0R(i,N) {\n        ad(i,-1);\n        FOR(j,i+1,N) {\n            ad(j,-1);\n            tri(i,j);\n            ad(j,1);\n        }\n    }\n    cout << ans;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\ngp_hash_table<ll, int> dp;\n\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    double ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p1 = c[i];\n            for(int k=0;k<4;k++){\n                del(p1);\n                piipii p2 = c[j];\n                for(int l=0;l<4;l++){\n                    del(p2);\n\n                    double res = 1;\n                    piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                    piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                    piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                    piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                    if(dp.find(get_idx(tmp1)) != dp.end()){\n                        res *= dp[get_idx(tmp1)];\n                        del(tmp1);\n                    }\n                    else res = 0;\n                    if(dp.find(get_idx(tmp2)) != dp.end()){\n                        res *= dp[get_idx(tmp2)];\n                        del(tmp2);\n                    }\n                    else res = 0;\n                    if(dp.find(get_idx(tmp3)) != dp.end()){\n                        res *= dp[get_idx(tmp3)];\n                        del(tmp3);\n                    }\n                    else res = 0;\n                    if(dp.find(get_idx(tmp4)) != dp.end()){\n                        res *= dp[get_idx(tmp4)];\n                        del(tmp4);\n                    }\n                    else res = 0;\n\n                    ans += res;\n\n                    if(dp.find(get_idx(tmp1)) != dp.end()){\n                        add(tmp1);\n                    }\n                    if(dp.find(get_idx(tmp2)) != dp.end()){\n                        add(tmp2);\n                    }\n                    if(dp.find(get_idx(tmp3)) != dp.end()){\n                        add(tmp3);\n                    }\n                    if(dp.find(get_idx(tmp4)) != dp.end()){\n                        add(tmp4);\n                    }\n                    \n                    add(p2);\n                    p2 = rotate(p2);\n                }\n\n                add(p1);\n                p1 = rotate(p1);\n            }\n        }\n    }\n    printf(\"%.0lf\\n\", ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[405];\nlong long x[405][4];\nlong long c[405][10];\nlong long dp[405][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<long long,int>m;\nlong long get(long long x,long long y,long long z,long long h)\n{\n    long long ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nlong long pack(long long x,long long y,long long z,long long h){return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));}\nlong long fac(long long x){long long ret=1;for(int i=1;i<=x;i++)ret*=i;return ret;}\nlong long rot(long long x)\n{\n    int k[4];\n\tfor(int i=0;i<=3;i++,x>>=10)k[i]=x&((1<<10)-1);\n    if(k[0]==k[1]&&k[1]==k[2]&&k[2]==k[3])return 4;\n    if(k[0]==k[2]&&k[1]==k[3])return 2;\n    return 1;\n}\nint main()\n{\n    int n;\n\tcin>>n;\n        for(int i=1;i<=n;i++)c[i][0]=c[i][i]=1;\n        for(int i=1;i<=n;i++)for(int j=1;j<=min(4,i-1);j++)c[i][j]=c[i-1][j]+c[i-1][j-1];\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=0;j<=3;i++)cin>>x[i][j];\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        long long ans = 0;\n        m.clear();\n        for(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int ii=1;i<i;i++)\n            {\n            \tfor(int j=0;j<=3;j++)\n                {\n                    long long y[4];\n                    y[0]=pack(x[ii][(j+1)%4],x[ii][(j+0)%4],x[i][1],x[i][0]);\n                    y[1]=pack(x[ii][(j+0)%4],x[ii][(j+3)%4],x[i][2],x[i][1]);\n                    y[2]=pack(x[ii][(j+3)%4],x[ii][(j+2)%4],x[i][3],x[i][2]);\n                    y[3]=pack(x[ii][(j+2)%4],x[ii][(j+1)%4],x[i][0],x[i][3]);\n                    sort(y,y+4);\n                    long long ret=1;\n                    for(int p=0;p<4;)\n                    {\n                        int cnt=1;\n                        for(int r=p+1;r<4&&y[r]==y[p];r++)cnt++;\n                        int num=m[y[p]];\n                        if(y[p]==a[ii])num--;\n                        if(num<cnt){ret=0;break;}\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            m[a[i]]++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\n#define all(x) x.begin(),x.end()\n\nconst ll mod = 1e9+7;\nconst ll INF = 1e9;\nconst ll MAXN = 1e9;\n\nmap<vector<int>, int> mt;\nint flag[4];\n\nvector<int> rotate(vector<int> x){\n\treturn vector<int>{x[3],x[0],x[1],x[2]};\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tvector<vector<int> > faces(n,vector<int>(4));\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcin>>faces[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfaces[i] = rotate(faces[i]);\n\t\t\tmt[faces[i]]++;\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tvector<int> upper = faces[i];\n\t\t\tvector<int> lower = faces[j];\n\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tupper = rotate(upper);\n\t\t\t\tmt[upper]--;\n\t\t\t\tlower = rotate(lower);\n\t\t\t\tmt[lower]--;\n\t\t\t}\n\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tupper = rotate(upper);\n\t\t\t\tvector<int> side[4];\n\t\t\t\tside[0] = vector<int>{upper[1],upper[0],lower[1],lower[0]};\n\t\t\t\tside[1] = vector<int>{upper[2],upper[1],lower[0],lower[3]};\n\t\t\t\tside[2] = vector<int>{upper[3],upper[2],lower[3],lower[2]};\n\t\t\t\tside[3] = vector<int>{upper[0],upper[3],lower[2],lower[1]};\n\n\t\t\t\tll cnt = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tflag[l] = 0;\n\t\t\t\t}\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tif(mt.count(side[l])>0 && mt[side[l]] > 0){\n\t\t\t\t\t\tcnt *= mt[side[l]];\n\t\t\t\t\t\tflag[l]++;\n\t\t\t\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\t\t\t\tside[l] = rotate(side[l]);\n\t\t\t\t\t\t\tmt[side[l]]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if(cnt != 0) cout << cnt << endl;\n\t\t\t\tans += cnt;\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tif(flag[l]>0){\n\t\t\t\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\t\t\t\tside[l] = rotate(side[l]);\n\t\t\t\t\t\t\tmt[side[l]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// cout << ans << endl;\n\t\t\t}\n\n\t\t\tfor(int p = 0; p < 4; p++){\n\t\t\t\tupper = rotate(upper);\n\t\t\t\tmt[upper]++;\n\t\t\t\tlower = rotate(lower);\n\t\t\t\tmt[lower]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans/3 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ninline void rot(vector<int> &tile) {\n  rotate(tile.begin(), tile.begin() + 1, tile.end());\n}\n\ninline void rm_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]--;\n    rot(tile);\n  }\n}\n\ninline void add_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]++;\n    rot(tile);\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[tile], 0);\n    rm_tile(tile, colors);\n  }\n\n  for (vector<int> &tile : side_tiles) {\n    add_tile(tile, colors);\n  }\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[tiles[i]]++;\n      rot(tiles[i]);\n    }\n  }\n\n  ll ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rot(tiles[low]);\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<algorithm>\n#include<map>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nint n ;\nint s[ 405 ][ 5 ] ;\n\nll toint( int a , int b , int c , int d ) {\n  ll ret = 1000000000000000LLU ;\n  ret = min( ret , a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  ret = min( ret , b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  ret = min( ret , c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  ret = min( ret , d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  return ret ;\n}\n\nll ctint( int a , int b , int c , int d ) {\n  ll ret = 1000000000000000LLU ;\n  ret = min( ret , a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  ret = min( ret , b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  ret = min( ret , c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  ret = min( ret , d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  ll rt2 = 0 ;\n  rt2 += ( ret == a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  rt2 += ( ret == b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  rt2 += ( ret == c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  rt2 += ( ret == d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  return rt2 ;\n}\n\nll ctint( ll x ) {\n  ll a = x / 1000000000LLU ;\n  ll b = x / 1000000LLU % 1000LLU ;\n  ll c = x / 1000LLU % 1000LLU ;\n  ll d = x % 1000LLU ;\n  ll ret = 1000000000000000LLU ;\n  ret = min( ret , a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  ret = min( ret , b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  ret = min( ret , c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  ret = min( ret , d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  ll rt2 = 0 ;\n  rt2 += ( ret == a * 1000000000LLU + b * 1000000LLU + c * 1000LLU + d ) ;\n  rt2 += ( ret == b * 1000000000LLU + c * 1000000LLU + d * 1000LLU + a ) ;\n  rt2 += ( ret == c * 1000000000LLU + d * 1000000LLU + a * 1000LLU + b ) ;\n  rt2 += ( ret == d * 1000000000LLU + a * 1000000LLU + b * 1000LLU + c ) ;\n  return rt2 ;\n}\n\nmap< ll , ll > mp ;\n\nvoid init() {\n  scanf( \"%d\" , &n ) ;\n  for ( int i = 0 ; i < n ; i ++ ) {\n    for ( int j = 0 ; j < 4 ; j ++ ) {\n      scanf( \"%d\" , &s[ i ][ j ] ) ;\n    }\n    mp[ toint( s[ i ][ 0 ] , s[ i ][ 1 ] , s[ i ][ 2 ] , s[ i ][ 3 ] ) ] ++ ;\n  }\n}\n\nll ans = 0 ;\n\nll C( ll x , ll y ) {\n  ll ret = 1 ;\n  for ( ll i = 0 ; i < y ; i ++ ) {\n    ret *= x - i ;\n  }\n  return ret ;\n}\n\nll cnt( ll a , ll b , ll c , ll d ) {\n  vector< ll > v ;\n  v.push_back( 1000000000000000LLU ) ;\n  v.push_back( a ) ;\n  v.push_back( b ) ;\n  v.push_back( c ) ;\n  v.push_back( d ) ;\n  sort( v.begin() , v.end() ) ;\n  ll ret = 1 ;\n  ll ctt = 0 ;\n  for ( int i = 0 ; i < (int)v.size() - 1 ; i ++ ) {\n    ctt ++ ;\n    if ( v[ i ] != v[ i + 1 ] ) {\n      ll tret = C( mp[ v[ i ] ] , ctt ) ;\n      for ( int j = 0 ; j < (int)ctt ; j ++ )\n        tret *= ctint( v[ i ] ) ;\n      ret = ret * tret ;\n      ctt = 0 ;\n    }\n  }\n  return ret ;\n}\n\nll ans1 = 0 , ans2 = 0 ;\n\nvoid process() {\n  for ( int i = 0 ; i < n ; i ++ ) {\n    mp[ toint( s[ i ][ 0 ] , s[ i ][ 1 ] , s[ i ][ 2 ] , s[ i ][ 3 ] ) ] -- ;\n    for ( int j = 0 ; j < n ; j ++ ) if ( i != j ) {\n      mp[ toint( s[ j ][ 0 ] , s[ j ][ 1 ] , s[ j ][ 2 ] , s[ j ][ 3 ] ) ] -- ;\n\n      ans = 0 ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ) ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ) ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ) ;\n\n      ans += cnt( toint( s[ i ][ 1 ] , s[ i ][ 0 ] , s[ j ][ 0 ] , s[ j ][ 3 ] ) ,\n                  toint( s[ i ][ 2 ] , s[ i ][ 1 ] , s[ j ][ 3 ] , s[ j ][ 2 ] ) ,\n                  toint( s[ i ][ 3 ] , s[ i ][ 2 ] , s[ j ][ 2 ] , s[ j ][ 1 ] ) ,\n                  toint( s[ i ][ 0 ] , s[ i ][ 3 ] , s[ j ][ 1 ] , s[ j ][ 0 ] ) ) ;\n\n      ans1 += ans / 6LLU ;\n      ans2 += ans % 6 ;\n\n      mp[ toint( s[ j ][ 0 ] , s[ j ][ 1 ] , s[ j ][ 2 ] , s[ j ][ 3 ] ) ] ++ ;\n    }\n    mp[ toint( s[ i ][ 0 ] , s[ i ][ 1 ] , s[ i ][ 2 ] , s[ i ][ 3 ] ) ] ++ ;\n  }\n  ans1 += ans2 / 6 ;\n  printf( \"%lld\\n\" , ans1 ) ;\n}\n\nint main() {\n  init() ;\n  process() ;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nvector<int> opt[4];\nmap<ll, vector<pair<int,int>>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                if (m[msk].size() && m[msk].back().first == i) m[msk].back().second++;\n                else m[msk].PB(make_pair(i, 1));\n        }\n\n        fo(i, 0, 4) fo(j, 0, 16) if (((1<<i)&j) == 0) opt[i].PB(j);\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk = 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (auto i : m[msk]) {\n                                cub[i.first][p] = i.second;\n                        }\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, top+1, N) if (i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                        fo(x, 0, 4) {\n                                for (int j : opt[x]) {\n                                        ways[j|(1<<x)] += old[j] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<char>>box(N, vector<char>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<char>old(4, -1);\n\t\t\t\tvector<short>num(4, 0);\n\t\t\t\tvector<short>sum(4, 0);\n\t\t\t\tfor (int l = i + 1; l < N; l++) {\n\t\t\t\t\tif (j == l)continue;\n\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[l][m] && box[i][n] == box[l][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[l][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[l][(m + 3) % 4]) {\n\t\t\t\t\t\t\t\tsum[n]++;\n\t\t\t\t\t\t\t\tif (old[n] != l) {\n\t\t\t\t\t\t\t\t\tnum[n]++;\n\t\t\t\t\t\t\t\t\told[n] = l;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m]&&num[l]) {\n\t\t\t\t\t\t\tsum[l] -= sum[l] / num[l];\n\t\t\t\t\t\t\tnum[l]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  unordered_set<Int> used_f;\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n    if(used_f.count(b[i])) continue;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;      \n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n\n      if(cnt[b[j]]==0){\n\tadd(b[i],1);\n\tcontinue;\n      }\n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n    \n    Int v=b[i];\n    for(Int j=0;j<4;j++){\n      v=((v&1023)<<30)|(v>>10);\n      used_f.emplace(v);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\n\nlint gethash(const std::vector<int>& f) {\n    lint ret = 0;\n    for (auto x : f) ret = ret * 1000 + x;\n    return ret;\n}\n\nint getidx(lint x, int i) {\n    i = 3 - i;\n    while (i--) x /= 1000;\n    return x % 1000;\n}\n\nstd::vector<std::vector<int>> idxs{\n    {3, 2, 1, 0},\n    {2, 1, 2, 1},\n    {1, 0, 3, 2},\n    {0, 3, 0, 3},\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<lint>> fss(n);\n    {\n        std::vector<int> f(4);\n        for (auto& fs : fss) {\n            for (auto& x : f) std::cin >> x;\n\n            for (int r = 0; r < 4; ++r) {\n                fs.push_back(gethash(f));\n                std::rotate(f.begin(), f.begin() + 1, f.end());\n            }\n        }\n    }\n\n    lint ans = 0;\n    std::vector<lint> cs(4);\n    std::vector<lint> dp(1 << 4), ndp(1 << 4);\n    std::vector<lint> pats(4);\n\n    for (int i = 0; i < n; ++i) {\n        // top face (fixed)\n        const auto& tf = fss[i][0];\n\n        for (int j = 0; j < i; ++j) {\n            // bottom face\n            for (const auto& bf : fss[j]) {\n                for (int xi = 0; xi < 4; ++xi) {\n                    auto& c = cs[xi];\n                    c = 0;\n                    for (int yi = 0; yi < 4; ++yi) {\n                        int x = getidx(yi < 2 ? tf : bf, idxs[xi][yi]);\n                        c = c * 1000 + x;\n                    }\n                }\n\n                std::fill(dp.begin(), dp.end(), 0);\n                dp[0] = 1;\n\n                for (int k = 0; k < i; ++k) {\n                    if (k == j) continue;\n                    ndp = dp;\n\n                    std::fill(pats.begin(), pats.end(), 0);\n                    for (const auto& f : fss[k]) {\n                        for (int l = 0; l < 4; ++l) {\n                            if (cs[l] == f) ++pats[l];\n                        }\n                    }\n\n                    for (int l = 0; l < 4; ++l) {\n                        for (int b = 0; b < (1 << 4); ++b) {\n                            if ((b >> l) & 1) continue;\n                            ndp[b | (1 << l)] += dp[b] * pats[l];\n                        }\n                    }\n\n                    std::swap(dp, ndp);\n                }\n\n                ans += dp.back();\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef unsigned long long LL;\nmap<LL,int>c;\nconst int N=404;\nstruct zk{\n\tint a[4];\n\tinline zk(int A,int B,int C,int D){a[0]=A,a[1]=B,a[2]=C,a[3]=D;}\n\tinline zk(){}\n\tinline LL Hash(){\n\t\tLL r=0x3fffffffffffffff;\n\t\tfor(int i=0;i<4;++i)\n\t\tr=min(r,((LL)a[i]<<48)|((LL)a[(i+1)&3]<<32)|((LL)a[(i+2)&3]<<16)|(a[(i+3)&3]));\n\t\treturn r;\n\t}\n\tinline int check(){\n\t\tif(a[0]==a[1]&&a[1]==a[2]&&a[2]==a[3])return 4;\n\t\tif(a[0]==a[2]&&a[1]==a[3])return 2;\n\t\treturn 1;\n\t}\n}A[N];\ninline istream&operator>>(istream&in,zk&a){in>>a.a[0]>>a.a[1]>>a.a[2]>>a.a[3];return in;}\nint n;LL ans;\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)cin>>A[i],++c[A[i].Hash()];\n\tfor(int X=1;X<=n;++X)\n\tfor(int X_=0;X_<4;++X_)\n\tfor(int Y=X+1;Y<=n;++Y)\n\tfor(int Y_=0;Y_<4;++Y_){\n\t\tzk H=zk(A[X].a[X_],A[X].a[(X_+1)&3],A[X].a[(X_+2)&3],A[X].a[(X_+3)&3]);\n\t\tzk T=zk(A[Y].a[Y_],A[Y].a[(Y_+1)&3],A[Y].a[(Y_+2)&3],A[Y].a[(Y_+3)&3]);\n\t\t--c[H.Hash()],--c[T.Hash()];\n\t\tzk L=zk(T.a[1],H.a[0],H.a[3],T.a[2]),R=zk(H.a[1],T.a[0],T.a[3],H.a[2]);\n\t\tzk U=zk(T.a[1],T.a[0],H.a[1],H.a[0]),D=zk(H.a[3],H.a[2],T.a[3],T.a[2]);\n\t\tLL r=1;\n\t\tr*=c[L.Hash()]--;\n\t\tr*=c[R.Hash()]--;\n\t\tr*=c[U.Hash()]--;\n\t\tr*=c[D.Hash()]--;\n\t\t++c[L.Hash()],++c[R.Hash()],++c[U.Hash()],++c[D.Hash()];\n\t\t++c[H.Hash()],++c[T.Hash()];\n\t\tr*=L.check()*R.check()*U.check()*D.check();\n\t\tans+=r;\n\t}\n\tcout<<ans/12<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\n//____________________________________________\n//____________________________________________\n//__________________OOOOOOOOOOOOOOOO__________\n//_________________OO_____________OO__________\n//________________O_O____________O_O__________\n//_______________O__O___________O__O__________\n//______________O___O__________O___O__________\n//_____________O____O_________O____O__________\n//____________OOOOOOOOOOOOOOOO_____O__________\n//____________O_____O________O_____O__________\n//____________O_____OOOOOOOOOOOOOOOO__________\n//____________O____O_________O____O___________\n//____________O___O__________O___O____________\n//____________O__O___________O__O_____________\n//____________O_O____________O_O______________\n//____________OO_____________OO_______________\n//____________OOOOOOOOOOOOOOOO________________\n//____________________________________________\n//____________________________________________\n\nconst long long MOD = 1e9 + 7;\nll n;\nll c[500][4];\nll ans;\nmap<vector<int>, int> g;\nmap<vector<int>, int> cubes;\n\nvector<int> reform(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 4; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 4; j++)\n        {\n            x.push_back(c[(i + j) % 4]);\n        }\n        cc.push_back(x);\n    }\n    sort(cc.begin(), cc.end());\n    return *min_element(cc.begin(), cc.end());\n}\n\nvector<int> cube(vector<int> c)\n{\n    vector<vector<int> > cc;\n    for (int i = 0; i < 8; i++)\n    {\n        vector<int> x;\n        for (int j = 0; j < 8; j++)\n        {\n            x.push_back(c[(i + j) % 8]);\n        }\n        cc.push_back(x);\n    }\n    return *min_element(cc.begin(), cc.end());\n}\n\nll cnk(ll k, ll n)\n{\n    if (k > n)\n        return 0;\n    if (k == 0)\n        return 1;\n    if (k == 1)\n        return n;\n    if (k == 2)\n        return n * (n - 1);\n    if (k == 3)\n        return n * (n - 1) * (n - 2);\n    if (k == 4)\n        return n * (n - 1) * (n - 2) * (n - 3);\n}\n\nsigned main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        vector<int> u = reform({c[i][0], c[i][1], c[i][2], c[i][3]});\n        //cout << u[0] << \" \" << u[1] << \" \" << u[2] << \" \" << u[3] << endl;\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            for (int o1 = 0; o1 < 4; o1++)\n            {\n                //     c[j][1] ---- c[j][0]\n                //       /|            /|\n                //      / |           / |\n                //     /  c[j][2]    /  c[j][3]\n                // c[i][o1] ---- c[i][o1 + 1]\n                //    | /            |\n                //    |/             |\n                // c[i][o1 + 3] ---- c[i][o1 + 2]\n                vector<int> f = reform({c[i][0], c[i][1], c[i][2], c[i][3]});\n                vector<int> b = reform({c[j][0], c[j][1], c[j][2], c[j][3]});\n                g[f]--;\n                g[b]--;\n                int ful = c[i][o1];\n                int fur = c[i][(o1 + 1) % 4];\n                int fdl = c[i][(o1 + 3) % 4];\n                int fdr = c[i][(o1 + 2) % 4];\n\n                int bul = c[j][1];\n                int bur = c[j][0];\n                int bdl = c[j][2];\n                int bdr = c[j][3];\n\n                //vector<int> cuber = cube({ful, fur, fdr, fdl, bdl, bdr, bur, bul});\n                //if (cubes[cuber] == 1)\n                //    continue;\n                //cubes[cuber] = 1;\n\n                vector<int> l = {ful, fdl, bdl, bul};\n                vector<int> u = {fur, ful, bul, bur};\n                vector<int> r = {fur, bur, bdr, fdr};\n                vector<int> d = {fdl, fdr, bdr, bdl};\n\n                ll swappers = 1;\n\n                ll y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (l[y] != l[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (d[y] != d[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (u[y] != u[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (r[y] != r[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                r = reform(r);\n                l = reform(l);\n                u = reform(u);\n                d = reform(d);\n                \n                //cout << i << \" \" << j << \" \" << swappers << endl;\n\n                map<vector<int>, int> gg2;\n                gg2[r]++;\n                gg2[l]++;\n                gg2[u]++;\n                gg2[d]++;\n\n                for (auto it : gg2)\n                {\n                    swappers *= cnk(it.second, g[it.first]);\n                }\n                //cout << swappers << endl;\n                //cout << i << \" \" << j << \" \" << swappers << endl;\n\n                ans += swappers;\n                g[f]++;\n                g[b]++;\n            }\n        }\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]--;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=10000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\tin*=f;return in;\n}\nstruct data{int c[4];}a[MN],t;\nint n;ll ans;\nll has[MN],fact[4],tmp[4];\nmap<ll,int>mp;\nvoid add(ll has,int d){\n\tfor(int i=3;i>=0;--i)tmp[i]=has%1000,has/=1000;\n\tfor(int i=0;i<4;++i){\n\t\thas=0;\n\t\tfor(int j=0;j<4;++j)\n\t\t\thas=has*1000+tmp[(i+j)&3];\n\t\tmp[has]+=d;\n\t}\n}\nll get(data a){ll res=0;for(int i=0;i<4;++i)res=res*1000+a.c[i];return res;}\nvoid input(){\n\tIN(n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<4;++j)IN(a[i].c[j]);\n\t\thas[i]=get(a[i]),add(has[i],1);\n\t}\n\tfor(int i=1;i<=n-5;++i){\n\t\tadd(has[i],-1);\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tadd(has[j],-1);\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tint F=0;ll s=1;\n\t\t\t\tfor(int l=0;l<4;++l){\n\t\t\t\t\tt.c[0]=a[i].c[(l+1)&3],t.c[1]=a[i].c[l];\n\t\t\t\t\tt.c[2]=a[j].c[(k-l+4)&3],t.c[3]=a[j].c[(k-l+3)&3];\n\t\t\t\t\tfact[l]=get(t);\n\t\t\t\t\tif(!mp[fact[l]]){F=1;break;}\n\t\t\t\t}\n\t\t\t\tif(F)continue;\n\t\t\t\tfor(int l=0;l<4;++l)s*=mp[fact[l]],add(fact[l],-1);\n\t\t\t\tfor(int l=0;l<4;++l)add(fact[l],1);\n\t\t\t\tans+=s;\n\t\t\t}\n\t\t\tadd(has[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\nvector<int>rotate(vector<int>v)\n{\n\tvector<int>r;\n\tr.resize(4);\n\tr[0] = v[1], r[1] = v[2], r[2] = v[3], r[3] = v[0];\n\treturn r;\n}\nvector<int>d[444];\ntypedef long long ll;\nmap<ll, ll>ma;\nll conv(vector<int>v)\n{\n\treturn (((ll)v[0]) << 30) + (((ll)v[1]) << 20) + (((ll)v[2]) << 10) + ((ll)v[3]);\n}\nvoid add(vector<int>v)\n{\n\tll t = conv(v);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tma[t]++;\n\t\tt = ((t&((1LL << 40) - (1LL << 30))) >> 30) + ((t&((1LL << 30) - 1)) << 10);\n\t}\n}\nvoid sub(vector<int>v)\n{\n\tll t = conv(v);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tma[t]--;\n\t\tt = ((t&((1LL << 40) - (1LL << 30))) >> 30) + ((t&((1LL << 30) - 1)) << 10);\n\t}\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tvector<int>v;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tv.push_back(z);\n\t\t}\n\t\td[i] = v;\n\t\tadd(v);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = i + 1; j < num; j++)\n\t\t{\n\t\t\tvector<int>s = d[i], t = d[j];\n\t\t\tsub(s), sub(t);\n\t\t\tswap(t[0], t[2]);\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tll x = 1;\n\t\t\t\tvector<vector<int> >ddd;\n\t\t\t\tfor (int l = 0; l < 4; l++)\n\t\t\t\t{\n\t\t\t\t\tvector<int>z;\n\t\t\t\t\tz.push_back(s[1]);\n\t\t\t\t\tz.push_back(s[0]);\n\t\t\t\t\tz.push_back(t[0]);\n\t\t\t\t\tz.push_back(t[1]);\n\t\t\t\t\tx *= ma[conv(z)];\n\t\t\t\t\tsub(z);\n\t\t\t\t\tddd.push_back(z);\n\t\t\t\t\ts = rotate(s), t = rotate(t);\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < 4; l++)add(ddd[l]);\n\t\t\t\t//if (x > 0)printf(\"%d %d %lld\\n\", i, j, x);\n\t\t\t\tans += x;\n\t\t\t\tt = rotate(t);\n\t\t\t}\n\t\t\tswap(t[0], t[2]);\n\t\t\tadd(s), add(t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i) & 3];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)&3] < colors[(j+k)&3]) return true;\n            if (colors[(i+k)&3] > colors[(j+k)&3]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nstruct myhash {\n    std::size_t operator() (const Colors &c) const {\n        LL x = 0;\n        x |= c.colors[0];\n        x |= c.colors[1] << 10;\n        x |= c.colors[2] << 20;\n        x |= c.colors[3] << 30;\n        return std::hash<LL>()(x);\n    }\n};\n\nunordered_map<Colors, int, myhash> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors &a, Colors &b, Colors &brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    for(auto &pb: colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL multi = pb.second;\n        pb.second--;\n        FORN(rot, 4) {\n            ans += multi * countfit(a, b, brot);\n            brot.rotate_left(1);\n        }\n        pb.second++;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        Colors a = tiles[i];\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n, c[666][8], u[4], z;\nll F(ll a, ll b, ll c, ll d) {\n\treturn a << 30 | b << 20 | c << 10 | d;\n}\nmap<ll, ll> g;\nvoid A(ll x, ll v) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tg[x] += v;\n\t\tx = (x >> 10) | (x & 1023) << 30;\n\t}\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> c[i][j];\n\t\t\tc[i][j + 4] = c[i][j];\n\t\t}\n\t\tA(F(c[i][0], c[i][1], c[i][2], c[i][3]), 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tA(F(c[i][0], c[i][1], c[i][2], c[i][3]), -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tA(F(c[j][0], c[j][1], c[j][2], c[j][3]), -1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tll r = 1;\n\t\t\t\tu[0] = F(c[j][k + 1], c[j][k + 0], c[i][1], c[i][0]);\n\t\t\t\tu[1] = F(c[j][k + 0], c[j][k + 3], c[i][2], c[i][1]);\n\t\t\t\tu[2] = F(c[j][k + 3], c[j][k + 2], c[i][3], c[i][2]);\n\t\t\t\tu[3] = F(c[j][k + 2], c[j][k + 1], c[i][4], c[i][3]);\n\t\t\t\tif (g[u[0]] && g[u[1]] && g[u[2]] && g[u[3]]) {\n\t\t\t\t\tr *= g[u[0]];\n\t\t\t\t\tA(u[0], -1);\n\t\t\t\t\tr *= g[u[1]];\n\t\t\t\t\tA(u[1], -1);\n\t\t\t\t\tr *= g[u[2]];\n\t\t\t\t\tA(u[2], -1);\n\t\t\t\t\tr *= g[u[3]];\n\t\t\t\t\tA(u[2], 1);\n\t\t\t\t\tA(u[1], 1);\n\t\t\t\t\tA(u[0], 1);\n\t\t\t\t\tz += r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA(F(c[j][0], c[j][1], c[j][2], c[j][3]), 1);\n\t\t}\n\t}\n\tcout << z << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef unsigned int U;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl; using std::cerr;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n) { cerr << #a << \" = {\"; \\\n      for(int qwq = (st); qwq <= (n); ++qwq) cerr << a[qwq] << (qwq == (n) ? '}' : ',') << (qwq == (n) ? '\\n' : ' '); }\n#define displayv(a) display(a, 0, (int)(a.size()-1))\n#include <ctime>\nclass MyTimer {\n  clock_t st;\npublic:\n  MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n  ~MyTimer() { report(); }\n  void reset() { st = clock_t(); }\n  void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) {}\n#define displayv(a) {}\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifdef QUICK_READ\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n  int a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\ninline LL readLL() {\n  LL a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\n\nconst int maxN = 400 + 5;\nconst int maxC = 1000 + 23;\nint n;\nstruct Tile {\n  int c[4];\n  Tile() {}\n  int& operator [](const int id) {\n    return c[id];\n  }\n  Tile(int x, int y, int z, int w) {\n    c[0] = x; c[1] = y; c[2] = z; c[3] = w;\n  }\n  friend bool operator < (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return A[i] < B[i];\n    return false;\n  }\n  friend bool operator == (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return false;\n    return true;\n  }\n  void rotate() {\n    int t = c[3];\n    for(int i = 3; i > 0; --i) c[i] = c[i - 1];\n    c[0] = t;\n  }\n}a[maxN];\n\nLL f[16], g[16];\nint c[4];\n\nLL solve() {\n  LL ans = 0;\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j) {\n      for(int t = 0; t < 4; ++t) {\n        a[j].rotate();\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for(int k = i + 1; k < n; ++k) if(k != j) {\n        \tmemset(c, 0, sizeof(c));\n          for(int tt = 0; tt < 4; ++tt) {\n            a[k].rotate();\n            if(a[k] == Tile(a[j][2], a[j][1], a[i][0], a[i][3])) c[0]++;\n            if(a[k] == Tile(a[j][3], a[j][2], a[i][3], a[i][2])) c[1]++;\n            if(a[k] == Tile(a[j][0], a[j][3], a[i][2], a[i][1])) c[2]++;\n            if(a[k] == Tile(a[j][1], a[j][0], a[i][1], a[i][0])) c[3]++;\n          }\n          memcpy(g, f, sizeof(g));\n//          printf(\"at k = %d, c = {%d, %d, %d, %d}\\n\", k, c[0], c[1], c[2], c[3]);\n          for(int i = 0; i < 4; ++i) if(c[i]) {\n            int num = 1 << i;\n            int full = 15 ^ num;\n            LL tc = c[i];\n            for(int S = full; S; S = full & (S - 1)) f[S | num] += g[S] * tc;\n            f[num] += g[0] * tc;\n          }\n//          for(int S = 15; S >= 0; --S) {\n//          \tfor(int i = 0; i < 4; ++i) if(S >> i & 1)\n//          \t\tf[S] += f[S ^ (1 << i)] * c[i];\n//\t\t\t\t\t}\n        }\n        ans += f[15];\n      }\n    }\n  return ans;\n}\n\nint main() {\n  n = readint();\n  for(int i = 0; i < n; ++i) for(int j = 0; j < 4; ++j) a[i][j] = readint();\n  printf(\"%lld\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i) & 3];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)&3] < colors[(j+k)&3]) return true;\n            if (colors[(i+k)&3] > colors[(j+k)&3]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors &a, Colors &b, Colors &brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    for(auto &pb: colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL multi = pb.second;\n        pb.second--;\n        FORN(rot, 4) {\n            ans += multi * countfit(a, b, brot);\n            brot.rotate_left(1);\n        }\n        pb.second++;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        Colors a = tiles[i];\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {};\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        map<pair<pii, pii>, ll> p;\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                if (p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}]) {\n                    z += p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}];\n                    continue;\n                }\n                int b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}}, c[404][4] = {}, d[16] = {};\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 0; m < 4; m++) {\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[l][m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[l][m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[l][m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[l][m]++;\n                    }\n                }\n                d[0] = 1;\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 15; m >= 0; m--) {\n                        if (l != j) {\n                            for (int o = 0; o < 4; o++) if (m & (1 << o)) d[m] += c[l][o] * d[m - (1 << o)];\n                        }\n                    }\n                }\n                p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}] = d[15];\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\ntypedef unsigned long long ull;\n\nint n;\n\n#define TUPLE(a,b,c,d) (a | (b<<16) | ((ull)c<<32) | ((ull)d<<48))\n#define UNPACK(t,a,b,c,d) int a=((t)&65535),b=(((t)>>16)&65535),c=(((t)>>32)&65535),d=(((t)>>48)&65535)\n\null normalize(int a,int b,int c,int d){\n  ull r = TUPLE(a,b,c,d);\n  REP(_,3){\n    swap(a,b);\n    swap(b,c);\n    swap(c,d);\n    CHMIN(r,TUPLE(a,b,c,d));\n  }\n  return r;\n}\null normalize(ull s){\n  UNPACK(s,a,b,c,d);\n  return normalize(a,b,c,d);\n}\nvoid debunpack(string po,ull s){\n  UNPACK(s,a,b,c,d);\n  printf(\"%s%5d%5d%5d%5d\\n\",po.c_str(),a,b,c,d);\n}\n\nint main(){\n  // cube, [count,multiply]\n  map<ull,pii> mp;\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    set<ull> S;\n    S.insert(TUPLE(a,b,c,d));\n    REP(_,3){\n      swap(a,b);\n      swap(b,c);\n      swap(c,d);\n      S.insert(TUPLE(a,b,c,d));\n    }\n    ull s = *S.begin();\n    mp[s].first += 1;\n    mp[s].second = 4/S.size();\n  }\n  ull ans = 0;\n  for(auto& _s1:mp){\n    ull s1 = _s1.first;\n    ull u = _s1.second.first;\n    _s1.second.first--;\n    UNPACK(s1,a,b,c,d);\n    for(auto& _s2:mp){\n      ull s2 = _s2.first;\n      ull v = u * _s2.second.first;\n      _s2.second.first--;\n      UNPACK(s2,h,g,f,e);\n      REP(_,4){\n        ull add = v;\n        ull s3 = normalize(b,a,e,f);\n        ull s4 = normalize(c,b,f,g);\n        ull s5 = normalize(d,c,g,h);\n        ull s6 = normalize(a,d,h,e);\n        bool ok = mp.count(s3) && mp.count(s4) && mp.count(s5) && mp.count(s6);\n        if(ok){\n          add *= mp[s3].first * mp[s3].second;  mp[s3].first--;\n          add *= mp[s4].first * mp[s4].second;  mp[s4].first--;\n          add *= mp[s5].first * mp[s5].second;  mp[s5].first--;\n          add *= mp[s6].first * mp[s6].second;  mp[s6].first--;\n        }else{\n          add = 0;\n        }\n        ans += add;\n        if(ok){\n          mp[s3].first++;\n          mp[s4].first++;\n          mp[s5].first++;\n          mp[s6].first++;\n        }\n        swap(e,f);\n        swap(f,g);\n        swap(g,h);\n      }\n      _s2.second.first++;\n    }\n    _s1.second.first++;\n  }\n  printf(\"%llu\\n\",ans/6);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef array<int,4> A;\n\nLL toLL(A a){\n\tA r=a;\n\tfor(int i=0;i<3;i++){\n\t\trotate(a.begin(),a.begin()+1,a.end());\n\t\tr=min(r,a);\n\t}\n\tLL v=0;\n\tfor(int i=0;i<4;i++){\n\t\tv<<=10;\n\t\tv+=r[i];\n\t}\n\treturn v;\n}\nLL ord(A a){\n\tif(a[0]==a[2]&&a[1]==a[3]){\n\t\tif(a[0]==a[1]){\n\t\t\treturn 4;\n\t\t}\n\t\treturn 2;\n\t}\n\treturn 1;\n}\nconst LL M=1e9+7;\nLL vs[400];\nA C[400];\nint main() {\n\tint N;\n\tscanf(\"%d\",&N);\n\tunordered_map<LL,int> cnt;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tC[i][j]=a;\n\t\t}\n\t\tvs[i]=toLL(C[i]);\n\t\tcnt[vs[i]]++;\n\t}\n\tLL ret=0;\n\tfor(int i=0;i<N;i++){\n\t\tcnt[vs[i]]--;\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tcnt[vs[j]]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tLL r=1;\n\t\t\t\tLL u[4];\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tA a={{C[i][(4-l+1)%4],C[i][(4-l)%4],C[j][(l+k+1)%4],C[j][(l+k)%4]}};\n\t\t\t\t\tLL v=toLL(a);\n\t\t\t\t\tr*=ord(a)*cnt[v];\n\t\t\t\t\tr%=M;\n#if 1\n\t\t\t\t\tif(i==0&&j==4){\n\t\t\t\t\t\tcerr << a[0] << \", \" << a[1] << \", \" << a[2] << \", \" << a[3] << endl;\n\t\t\t\t\t\tcerr << cnt[v] << endl;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tu[l]=v;\n\t\t\t\t\tcnt[v]--;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tcnt[u[l]]++;\n\t\t\t\t}\n\t\t\t\tret+=r;\n\t\t\t\tret%=M;\n\t\t\t}\n\t\t\tcnt[vs[j]]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long int64;\nstatic const int MAXN = 418;\nstatic const int MAXC = 1002;\n\nint n;\nstruct tile {\n    int val[4];\n    int64 _hash;\n\n    inline void normalize() {\n        static int nw[4];\n        static int64 h[4];\n        for (int i = 0; i < 4; ++i)\n            h[i] = (((int64)val[i] * MAXC + val[(i + 1) % 4]) * MAXC + val[(i + 2) % 4]) * MAXC + val[(i + 3) % 4];\n        int x = std::min_element(h, h + 4) - &h[0];\n        for (int i = 0; i < 4; ++i) nw[i] = val[(i + x) % 4];\n        for (int i = 0; i < 4; ++i) val[i] = nw[i];\n    }\n    inline void shift() {\n        int x = val[0]; val[0] = val[1]; val[1] = val[2]; val[2] = val[3]; val[3] = x;\n    }\n    inline int64 hash() {\n        if (_hash != -1) return _hash;\n        static int nw[4];\n        for (int i = 0; i < 4; ++i) nw[i] = val[i];\n        this->normalize();\n        int64 ans = (((int64)val[0] * MAXC + val[1]) * MAXC + val[2]) * MAXC + val[3];\n        for (int i = 0; i < 4; ++i) val[i] = nw[i];\n        return (_hash = ans);\n    }\n    inline int rotations() {\n        if (val[0] == val[2] && val[1] == val[3]) {\n            if (val[0] == val[1]) return 4; else return 2;\n        } else return 1;\n    }\n\n    tile() : _hash(-1) { }\n    tile(int a, int b, int c, int d) : _hash(-1) { val[0] = a, val[1] = b, val[2] = c, val[3] = d; this->hash(); }\n} c[MAXN];\n\ninline bool operator < (const tile &lhs, const tile &rhs) { return lhs._hash < rhs._hash; }\n\nstd::map< int64, std::vector<int> > counter;\n\ninline int count(int64 hash, int lower)\n{\n    std::map< int64, std::vector<int> >::iterator p = counter.find(hash);\n    if (p == counter.end()) return 0;\n    return std::distance(std::lower_bound(p->second.begin(), p->second.end(), lower), p->second.end());\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d%d%d%d\", &c[i].val[0], &c[i].val[1], &c[i].val[2], &c[i].val[3]);\n        c[i].normalize();\n        counter[c[i].hash()].push_back(i);\n    }\n\n    int64 ans = 0;\n    tile t[4];\n    for (int i = 0; i < n - 1; ++i)\n        for (int j = i + 1; j < n; ++j)\n            for (int k = 0; k < 4; ++k) {\n                t[0] = tile(c[i].val[1], c[i].val[0], c[j].val[1], c[j].val[0]);\n                t[1] = tile(c[i].val[2], c[i].val[1], c[j].val[0], c[j].val[3]);\n                t[2] = tile(c[i].val[3], c[i].val[2], c[j].val[3], c[j].val[2]);\n                t[3] = tile(c[i].val[0], c[i].val[3], c[j].val[2], c[j].val[1]);\n                std::sort(t, t + 4);\n\n                int64 cur = 1;\n                for (int p = 0, q; p < 4; p = q) {\n                    for (q = p + 1; q < 4 && t[p].hash() == t[q].hash(); ++q) ;\n                    int ct = count(t[p].hash(), i + 1), sel = q - p;\n                    if (t[p].hash() == c[j].hash()) --ct;\n                    for (int k = 1; k <= sel; ++k) cur = cur * (ct - k + 1) * t[p].rotations();\n                }\n                ans += cur;\n\n                c[j].shift();\n            }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass Tile\n{\npublic:\n    vector<int> color;\n    Tile(vector<int> c)\n    {\n        color = c;\n        for(int i=0; i<3; ++i){\n            rotate(c.begin(), c.begin() + 1, c.end());\n            color = min(color, c);\n        }\n    }\n    int getCount()\n    {\n        if(color == vector<int>(4, color[0]))\n            return 4;\n        else if(color[0] == color[2] && color[1] == color[3])\n            return 2;\n        else\n            return 1;\n    }\n    bool operator<(const Tile& t) const{\n        return color < t.color;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<Tile> tile;\n    map<Tile, int> m;\n    for(int i=0; i<n; ++i){\n        vector<int> v(4);\n        for(int j=0; j<4; ++j)\n            cin >> v[j];\n        Tile t(v);\n        tile.push_back(t);\n        ++ m[t];\n    }\n\n    long long ans = 0;\n    for(int a=0; a<n; ++a){\n        -- m[tile[a]];\n        for(int b=a+1; b<n; ++b){\n            -- m[tile[b]];\n\n            for(int r=0; r<4; ++r){\n                vector<Tile> t;\n                for(int i=0; i<4; ++i){\n                    vector<int> v(4);\n                    v[0] = tile[a].color[(i+r)%4];\n                    v[1] = tile[b].color[(4-i)%4];\n                    v[2] = tile[b].color[3-i];\n                    v[3] = tile[a].color[(i+1+r)%4];\n                    t.push_back(Tile(v));\n                }\n\n                long long cnt = 1;\n                for(int i=0; i<4; ++i){\n                    if(m.find(t[i]) == m.end()){\n                        cnt = 0;\n                    }\n                    else{\n                        cnt *= m[t[i]];\n                        cnt *= t[i].getCount();\n                        -- m[t[i]];\n                    }\n                }\n                ans += cnt;\n\n                for(int i=0; i<4; ++i){\n                    if(m.find(t[i]) != m.end())\n                        ++ m[t[i]];\n                }\n            }\n\n            ++ m[tile[b]];\n        }\n        ++ m[tile[a]];\n    }\n\n    ans /= 3;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int Nmax = 400;\nint N, C[4][Nmax];\n\nlong encode(int c0,int c1,int c2,int c3){\n\tlong base=1000;\n\tlong x = c3+base*c2+base*base*c1+base*base*base*c0;\n\tlong m = x;\n\tfor(int i=0; i<3; i++){\n\t\tx = x/base+(x%base)*base*base*base;\n\t\tm = min(m, x);\n\t}\n\treturn m;\n}\n\nint rot(long code){\n\tint c[4];\n\tint base = 1000;\n\tfor(int i=0; i<4; i++) {\n\t\tc[i] = code%base;\n\t\tcode /= base;\n\t}\n\tif(c[0]==c[1]&&c[1]==c[2]&&c[2]==c[3]) return 4;\n\tif(c[0]==c[2]&&c[1]==c[3]) return 2;\n\treturn 1;\n}\n\nlong pow(long a,long n){\n\tif(n==0) return 1;\n\tif(n%2) return pow(a,n-1)*a;\n\treturn pow(a,n/2);\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> C[j][i];\n\t\t}\n\t}\n\n\tmap<long, vector<int> > e2f;\n\tfor(int i=0; i<N; i++){\n\t\tlong x = encode(C[0][i],C[1][i],C[2][i],C[3][i]);\n\t\te2f[x].push_back(i);\n\t}\n\n\tlong ans = 0;\n\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tlong f[4];\n\t\t\t\tf[0] = encode(C[1][i],C[0][i],C[(k+0)%4][j],C[(k+3)%4][j]);\n\t\t\t\tf[1] = encode(C[2][i],C[1][i],C[(k+3)%4][j],C[(k+2)%4][j]);\n\t\t\t\tf[2] = encode(C[3][i],C[2][i],C[(k+2)%4][j],C[(k+1)%4][j]);\n\t\t\t\tf[3] = encode(C[0][i],C[3][i],C[(k+1)%4][j],C[(k+0)%4][j]);\n\t\t\t\tif(e2f.find(f[0]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[1]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[2]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[3]) == e2f.end()) continue;\n\t\t\t\t/*\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tcout << f[0] << endl;\n\t\t\t\tcout << f[1] << endl;\n\t\t\t\tcout << f[2] << endl;\n\t\t\t\tcout << f[3] << endl;\n\t\t\t\t*/\n\t\t\t\tlong c[4];\n\t\t\t\tlong a=0;\n\t\t\t\tfor(int m=0; m<4; m++){\n\t\t\t\t\tc[m]=0;\n\t\t\t\t\tfor(auto l=e2f[f[m]].begin(); l!=e2f[f[m]].end(); l++){\n\t\t\t\t\t\t//cout << \" \" << *l << endl;\n\t\t\t\t\t\tif(*l<=i || *l==j) continue;\n\t\t\t\t\t\tc[m]++;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << c[m] << \" \";\n\t\t\t\t}\n\t\t\t\tif(f[0]==f[1]&&f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=4){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*(c[0]-3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]&&f[1]==f[2]){\n\t\t\t\t\tif(c[0]>=3){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=3){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=3){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[1]>=3){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*(c[1]-2)*c[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=2&&c[1]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*(c[1]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[3]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[2]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[2]==f[3]){\n\t\t\t\t\tif(c[2]>=2){\n\t\t\t\t\t\ta = c[2]*(c[2]-1)*c[0]*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[3]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta = c[0]*c[1]*c[2]*c[3];\n\t\t\t\t}\n\t\t\t\tfor(int m=0; m<4; m++) a*=rot(f[m]);\n\t\t\t\t//cout << a << endl;\n\t\t\t\tans += a;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include <utility>\n#include <cstdio>\n#include<algorithm>\n#include<queue>\n#define ll  long long\n\nusing namespace std;\n\tint n;\nvoid rotate(vector<int> & vec){\n    vector<int> tmp(4);\n    int minind = min_element(vec.begin(), vec.end() ) - vec.begin();\n    for(int i=3; i>0; i--){\n\tif(vec[i]==vec[minind]){\n\t    minind=i;\n\t}else{\n\t    break;\n\t}\n    }\n    for(int i=0; i<4; i++){\n\ttmp[i] = vec[(i+minind)%4];\n    }\n    vec=tmp;\n}\nvoid rot1(vector<int> & vec){\n    int tmp = vec[0];\n    for(int i=0; i<4; i++){\n\tvec[i] = vec[i+1];\n    }\n    vec[3]=tmp;\n}\nint cntsq(vector<vector<int> > & c, vector<int>  & sq, int st, int sk){\n    int res=0;\n    for(int i=st; i<n; i++)\n\tif(i!=sk && c[i]==sq)res++;\n    return res;\n}\nint sym(vector<int> v){\n    if(v[0]!=v[2] || v[1]!=v[3])return 1;\n    if(v[0]!=v[1] || v[2]!=v[3])return 2;\n    return 4;\n}\nint main(){\n    cin>>n;\n    vector<vector<int> > c(n, vector<int>(4));\n    for(int i=0; i<n; i++){\n\tfor(int j=0; j<4; j++ )cin>>c[i][j];\n\trotate(c[i]);\n    }\n    ll res = 0;\n    for(int f = 0; f<n; f++){\n\tfor(int s=f+1; s<n; s++){\n\t    for(int r=0; r<4; r++){\n\t\tunsigned ll mu=1;\n\t\tmap<vector<int>, int> occ; occ.clear();\n\t\tfor(int i=0; i<4; i++){\n\t\t    vector<int> tmp(4);\n\t\t    tmp[1] = c[f][i]; tmp[0] = c[f][(i+1)%4];\n\t\t    tmp[3] = c[s][3-(i+1)%4]; tmp[2] = c[s][3-i];\n\t\t    rotate(tmp);\n\t\t    int x = cntsq(c, tmp, f+1, s);\n\t\t    if(x>occ[tmp])\n\t\t\tmu*=1LL*(x-occ[tmp])*sym(tmp);\n\t\t    else {mu=0; break; }\n//cout<<f<<\" \"<<s<<\" \"<<r<<\" \"<<i<<\" \"<<cntsq(c, tmp, f+1, s)<<\" \"<<mu<<\"\\n\";\n//cout<<tmp[0]<<tmp[1]<<tmp[2]<<tmp[3]<<\"\\n\";\n\t\t    occ[tmp]++;\n\t\t}\n\t\tres+=mu;\n\t\trot1(c[s]);\n//\t\tcout<<c[s][0]<<c[s][1]<<c[s][2]<<c[s][3]<<\"\\n\";\n\t    }\n\t}\n    }\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      //cout<<bitset<40>(v)<<\":\"<<x<<endl;\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      //res/=dup(a);\n      //ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#define INT_MAX 2147483647\n#define INT_MIN -2147483648\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\nint n;\n\nvi sortc(vi c) {\n\tvi ret = c;\n\tLoop1(i, 3) {\n\t\tc = { c[(0 + i) % 4], c[(1 + i) % 4],c[(2 + i) % 4],c[(3 + i) % 4] };\n\t\tret = min(ret, c);\n\t}\n\treturn ret;\n}\n\nint cnt_rout(vi c) {\n\tint ret = 1;\n\tLoop1(i, 3) {\n\t\tvi ccopy = { c[(0 + i) % 4], c[(1 + i) % 4], c[(2 + i) % 4], c[(3 + i) % 4] };\n\t\tif (c == ccopy) ret++;\n\t}\n\treturn ret;\n}\n\nvoid solve(vvi c) {\n\tll ans = 0;\n\tLoop(i, n - 5) {\n\t\tfor (int j = i + 1;j < n;j++) {\n\t\t\tLoop(k, 4) {\n\t\t\t\tvi cs = { c[i][0],c[i][1],c[i][2],c[i][3],\n\t\t\t\t\tc[j][(0 + k) % 4], c[j][(3 + k) % 4],c[j][(2 + k) % 4],c[j][(1 + k) % 4] };\n\t\t\t\tvvi findlist = {\n\t\t\t\t\tsortc({cs[4],cs[0],cs[3],cs[7]}),\n\t\t\t\t\tsortc({cs[1],cs[5],cs[6],cs[2]}),\n\t\t\t\t\tsortc({cs[4],cs[5],cs[1],cs[0]}),\n\t\t\t\t\tsortc({cs[6],cs[7],cs[3],cs[2]}) };\n\t\t\t\tsort(findlist.begin(), findlist.end());\n\t\t\t\tvi buf(4), buf2(4);\n\t\t\t\tll _ans = 1;\n\t\t\t\tLoop(m, 4) {\n\t\t\t\t\tif (m > 0 && findlist[m] == findlist[m - 1]) {\n\t\t\t\t\t\tbuf[m] = buf[m - 1] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tauto ub = upper_bound(c.begin() + i + 1, c.end(), findlist[m]);\n\t\t\t\t\t\tauto lb = lower_bound(c.begin() + i + 1, c.end(), findlist[m]);\n\t\t\t\t\t\tbuf[m] = ub - lb;\n\t\t\t\t\t\tif (lb - c.begin() <= j&&j < ub - c.begin()) buf[m]--;\n\t\t\t\t\t}\n\t\t\t\t\tbuf2[m] = cnt_rout(findlist[m]);\n\t\t\t\t\t_ans *= buf[m] * buf2[m];\n\t\t\t\t\tif (buf[m] == 0) break;\n\t\t\t\t}\n\t\t\t\tans += _ans;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> n;\n\tvvi c(n, vi(4));\n\tLoop(i, n) {\n\t\tLoop(j, 4) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tc[i] = sortc(c[i]);\n\t}\n\tsort(c.begin(), c.end());\n\tsolve(c);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 400 + 100;\n\nint n;\nlong long s[MAXN];\nmap<long long, int> cnt;\n\nlong long get_ind(int x0, int x1, int x2, int x3)\n{\n\treturn (x0) | (x1 << 10) | (x2 << 20) | (x3 << 30);\n}\n\nint get_dig(long long s, int k)\n{\n\treturn (s >> (10 * k)) & 1023;\n}\n\nvoid add(long long s, int v)\n{\n\tfor(int i = 0; i < 4; i++)\n\t\tcnt[s] += v, s = (s >> 10) | ((s & 1023)<< 30);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x0, x1, x2, x3;\n\t\tcin >> x0 >> x1 >> x2 >> x3;\n\t\ts[i] = get_ind(x0, x1, x2, x3);\n\t\tadd(s[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tadd(s[i], -1);\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tadd(s[j], -1);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tlong long t[4] = {\n\t\t\t\t\tget_ind(get_dig(s[j], k), get_dig(s[j], (k + 3) % 4), get_dig(s[i], 1), get_dig(s[i], 0)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 3) % 4), get_dig(s[j], (k + 2) % 4), get_dig(s[i], 2), get_dig(s[i], 1)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 2) % 4), get_dig(s[j], (k + 1) % 4), get_dig(s[i], 3), get_dig(s[i], 2)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 1) % 4), get_dig(s[j], k), get_dig(s[i], 0), get_dig(s[i], 3))\n\t\t\t\t};\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\ttmp *= cnt[t[l]], add(t[l], -1);\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tadd(t[l], 1);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tadd(s[j], 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\n// ModInt (ref. anta) {{{\ntemplate<int MOD>\nstruct ModInt{\n    static const int Mod = MOD;\n    unsigned val;\n    ModInt():val(0){}\n    ModInt(unsigned x):val(x%MOD){}\n    ModInt(signed x) {\n        int y = x % MOD;\n        if(y < 0) y += MOD;\n        val = y;\n    }\n    ModInt(signed long long x) {\n        int y = x % MOD;\n        if(y < 0) y += MOD;\n        val = y;\n    }\n\n    ModInt &operator+=(ModInt rhs) {\n        val += rhs.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(ModInt rhs) {\n        val += MOD - rhs.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator*=(ModInt rhs) {\n        val = (unsigned long long)val * rhs.val % MOD;\n        return *this;\n    }\n    ModInt &operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n\n    ModInt inv() const {\n        signed a = val, b = MOD, u = 1, v = 0;\n        while(b) {\n            signed t = a / b;\n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        if(u < 0) u += MOD;\n        ModInt res;\n        res.val = u;\n        return res;\n    }\n\n    ModInt operator+(ModInt rhs) const {\n        return ModInt(*this) += rhs;\n    }\n    ModInt operator-(ModInt rhs) const {\n        return ModInt(*this) -= rhs;\n    }\n    ModInt operator*(ModInt rhs) const {\n        return ModInt(*this) *= rhs;\n    }\n    ModInt operator/(ModInt rhs) const {\n        return ModInt(*this) /= rhs;\n    }\n\n    // compare\n    bool operator==(ModInt rhs) const {\n        return val == rhs.val;\n    }\n    bool operator!=(ModInt rhs) const {\n        return val != rhs.val;\n    }\n    bool operator< (ModInt rhs) const {\n        return val <  rhs.val;\n    }\n    bool operator<=(ModInt rhs) const {\n        return val <= rhs.val;\n    }\n    bool operator> (ModInt rhs) const {\n        return val >  rhs.val;\n    }\n    bool operator>=(ModInt rhs) const {\n        return val >= rhs.val;\n    }\n};\ntemplate<int MOD>\nostream& operator << (ostream& os, const ModInt<MOD> m) {\n    return os << m.val;\n}\ntemplate<int MOD, typename T>\nModInt<MOD> pow(ModInt<MOD> a, T b) {\n    if(b == 0) {\n        return 1;\n    } else {\n        auto w = pow(a*a, b/2);\n        if(b&1) w *= a;\n        return w;\n    }\n}\n// }}}\ntypedef ModInt<1000000007> mint;\n\nconst int d[6][4] = {\n    {0, 1, 2, 3},\n    {0, 5, 4, 1},\n    {1, 4, 7, 2},\n    {2, 7, 6, 3},\n    {4, 5, 6, 7},\n    {5, 0, 3, 6},\n};\nint main(){\n    iostream_init();\n    int N;\n    while(cin >> N) {\n        int C[500][4] = {};\n        REP(i, N) REP(j, 4) cin >> C[i][j];\n\n        map<array<int, 4>, int> count;\n        REP(i, N) {\n            array<int, 4> a;\n            REP(j, 4) a[j] = C[i][j];\n            count[a] += 1;\n        }\n\n        set<array<int, 8>> colors;\n        REP(i, N) REP(j, N) if(i != j) REP(rot1, 4) REP(rot2, 4) {\n            array<int, 8> c;\n            REP(k, 4) c[k] = C[i][(k + rot1) % 4];\n            REP(k, 4) c[4 + k] = C[j][(k + rot2) % 4];\n            colors.insert(c);\n        }\n\n        mint answer = 0;\n\n        array<int, 4> c[6];\n        int cnt = 0;\n\n        for(const auto& color : colors) {\n            array<int, 4> cs;\n            vector<int> rots1; REP(rot, 4){ REP(j, 4) cs[j] = color[ d[0][(j + rot) % 4] ]; if(count[cs]) rots1.push_back(rot); }\n            if(!rots1.size()) continue;\n            vector<int> rots2; REP(rot, 4){ REP(j, 4) cs[j] = color[ d[1][(j + rot) % 4] ]; if(count[cs]) rots2.push_back(rot); }\n            if(!rots2.size()) continue;\n            vector<int> rots3; REP(rot, 4){ REP(j, 4) cs[j] = color[ d[2][(j + rot) % 4] ]; if(count[cs]) rots3.push_back(rot); }\n            if(!rots3.size()) continue;\n            vector<int> rots4; REP(rot, 4){ REP(j, 4) cs[j] = color[ d[3][(j + rot) % 4] ]; if(count[cs]) rots4.push_back(rot); }\n            if(!rots4.size()) continue;\n            vector<int> rots5; REP(rot, 4){ REP(j, 4) cs[j] = color[ d[4][(j + rot) % 4] ]; if(count[cs]) rots5.push_back(rot); }\n            if(!rots5.size()) continue;\n            vector<int> rots6; REP(rot, 4){ REP(j, 4) cs[j] = color[ d[5][(j + rot) % 4] ]; if(count[cs]) rots6.push_back(rot); }\n            if(!rots6.size()) continue;\n\n            for(int rot1 : rots1) { REP(j, 4) c[0][j] = color[ d[0][(j + rot1) % 4] ]; \n            for(int rot2 : rots2) { REP(j, 4) c[1][j] = color[ d[1][(j + rot2) % 4] ]; \n            for(int rot3 : rots3) { REP(j, 4) c[2][j] = color[ d[2][(j + rot3) % 4] ]; \n            for(int rot4 : rots4) { REP(j, 4) c[3][j] = color[ d[3][(j + rot4) % 4] ]; \n            for(int rot5 : rots5) { REP(j, 4) c[4][j] = color[ d[4][(j + rot5) % 4] ]; \n            for(int rot6 : rots6) { REP(j, 4) c[5][j] = color[ d[5][(j + rot6) % 4] ]; \n                {\n                    mint sub = 1;\n                    int max_i = 0;\n                    REP(i, 6) {\n                        if(count[ c[i] ] > 0) {\n                            sub *= mint(count[c[i]]);\n                        } else {\n                            sub = 0;\n                            break;\n                        }\n                        max_i = i;\n                        count[ c[i] ]--;\n                    }\n                    REP(i, max_i+1) { count[ c[i] ]++; }\n\n                    answer += sub;\n                }\n            }}}}}}}\n\n        answer /= mint(24);\n\n        cout << answer.val << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n\nusing namespace std;\n\nstruct Tile{\n\tint c[4];\n\tTile(){}\n\tTile(int a, int b, int C, int d){\n\t\tc[0] = a, c[1] = b, c[2] = C, c[3] = d;\n\t}\n\tTile(int a[]){\n\t\tfor(int i = 0; i < 4; i++) c[i] = a[i];\n\t}\n\tTile rot(){\n\t\tTile tmp;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ttmp.c[i] = c[(i+1)%4];\n\t\t}\n\t\treturn tmp;\n\t}\n\tbool equal(Tile &obj){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(c[i] != obj.c[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool similar(Tile &obj)\n\t{\n\t\tTile tmp = obj;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) return true;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn false;\n\t}\n\tint sym()\n\t{\n\t\tint ret = 0;\n\t\tTile tmp = *this;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) ret++;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i = 0; i < 4; i++) cout << c[i] << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N;\nTile tile[405];\n\nint parent[4];\nvoid init(){\n\tfor(int i = 0; i < 4; i++) parent[i] = i;\n}\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nllint perm(llint n, llint k)\n{\n\tllint ret = 1;\n\tfor(int i = 0; i < k; i++){\n\t\tret *= n-i;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint c[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < 4; j++) cin >> c[j];\n\t\ttile[i] = Tile(c);\n\t}\n\t\n\tllint ans = 0;\n\tllint cnt[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\n\t\t\tTile t = tile[j];\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\n\t\t\t\tTile need[4];\n\t\t\t\tneed[0] = Tile(tile[i].c[1], tile[i].c[0], t.c[1], t.c[0]);\n\t\t\t\tneed[1] = Tile(tile[i].c[2], tile[i].c[1], t.c[0], t.c[3]);\n\t\t\t\tneed[2] = Tile(tile[i].c[3], tile[i].c[2], t.c[3], t.c[2]);\n\t\t\t\tneed[3] = Tile(tile[i].c[0], tile[i].c[3], t.c[2], t.c[1]);\n\t\t\t\t\n\t\t\t\tfor(int l = 0; l < 4; l++) cnt[l] = 0;\n\t\t\t\tfor(int l = i+1; l < N; l++){\n\t\t\t\t\tif(l == j) continue;\n\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\tif(tile[l].similar(need[m])) cnt[m]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinit();\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tfor(int m = l+1; m < 4; m++){\n\t\t\t\t\t\tif(same(l, m)) continue;\n\t\t\t\t\t\tif(need[l].similar(need[m])) unite(l, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tllint cnum[4];\n\t\t\t\tfor(int i = 0; i < 4; i++) cnum[i] = 0;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tcnum[root(i)]++;\n\t\t\t\t}\n\t\t\t\tllint tmp = 1;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tif(cnum[i]) tmp *= perm(cnt[i], cnum[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++) tmp *= need[i].sym();\n\t\t\t\tans += tmp;\n\n\t\t\t\tt = t.rot();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {};\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        //map<pair<pii, pii>, ll> p;\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                //if (p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}]) {\n                //    z += p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}];\n                //    continue;\n                //}\n                int b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}}, c[404][4] = {}, d[16] = {};\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 0; m < 4; m++) {\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[l][m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[l][m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[l][m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[l][m]++;\n                    }\n                }\n                d[0] = 1;\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 15; m >= 0; m--) {\n                        if (l != j) {\n                            for (int o = 0; o < 4; o++) if (m & (1 << o)) d[m] += c[l][o] * d[m - (1 << o)];\n                        }\n                    }\n                }\n                //p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}] = d[15];\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n\nnamespace IO {\n    template <typename _T>\n    inline bool read(_T& x) {\n        x = 0;\n        _T y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return false;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return true;\n    }\n\n    template <typename _T>\n    inline _T input() {\n        _T x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return x;\n    }\n};  // namespace IO\nusing namespace IO;\n\nnamespace modular {\n    const int MOD = 1000000007;\n\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n\n    inline void inc(int& x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\n\n#define MAX_N 407\n#define reg register\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\ntypedef long long ll;\n\nint N;\n\nstruct node {\n    int c[4];\n    inline node nxt() {\n        node a;\n        lep(i, 0, 4) a.c[i] = c[(i + 1) & 3];\n        return a;\n    }\n    bool operator<(const node& rhs) const {\n        lep(i, 0, 4) if (c[i] != rhs.c[i]) return c[i] < rhs.c[i];\n        return false;\n    }\n} a[MAX_N];\nstd::map<node, ll> mp;\n\ninline void insert(node x, ll val) {\n    for (int i = 0; i < 4; ++i, x = x.nxt())\n        mp[x] += val;\n}\n\ninline void solve() {\n    ll res = 0;\n    rep(i, 1, N) {\n        insert(a[i], -1);\n        rep(j, i + 1, N) {\n            insert(a[j], -1);\n            lep(k, 0, 4) {\n                node x1 = node{a[j].c[1], a[j].c[0], a[i].c[1], a[i].c[0]};\n                node x2 = node{a[j].c[2], a[j].c[1], a[i].c[0], a[i].c[3]};\n                node x3 = node{a[j].c[3], a[j].c[2], a[i].c[3], a[i].c[2]};\n                node x4 = node{a[j].c[0], a[j].c[3], a[i].c[2], a[i].c[1]};\n                // rep(i, 0, 0) x1 = x1.nxt(), x2 = x2.nxt(), x3 = x3.nxt(),\n                //              x4 = x4.nxt();\n                a[j] = a[j].nxt();\n                if (!mp[x1] || !mp[x2] || !mp[x3] || !mp[x4])\n                    continue;\n                ll ans = 1;\n                ans *= mp[x1], insert(x1, -1);\n                ans *= mp[x2], insert(x2, -1);\n                ans *= mp[x3], insert(x3, -1);\n                ans *= mp[x4];\n                res += ans;\n                insert(x1, 1), insert(x2, 1), insert(x3, 1);\n            }\n            insert(a[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n}\n\nint main() {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    read(N);\n    rep(i, 1, N) {\n        rep(j, 0, 3) read(a[i].c[j]);\n        insert(a[i], 1);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 410;\n\nint n, c[maxn][4];\nlong long hash_val[maxn], ans;\nstd::map<long long, int> m;\n\ninline void rot(int *a) {\n\tint t = a[0];\n\ta[0] = a[1];\n\ta[1] = a[2];\n\ta[2] = a[3];\n\ta[3] = t;\n\treturn;\n}\n\ninline long long calc_hash_val(long long a, long long b, long long c, long long d) {\n\treturn a * 1000000000ll + b * 1000000ll + c * 1000ll + d;\n}\n\ninline long long get_hash_val(long long a, long long b, long long c, long long d) {\n\treturn std::min(std::min(calc_hash_val(a, b, c, d), calc_hash_val(b, c, d, a)), std::min(calc_hash_val(c, d, a, b), calc_hash_val(d, a, b, c)));\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d%d%d\", c[i], c[i] + 1, c[i] + 2, c[i] + 3);\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tstd::reverse(c[j] + 1, c[j] + 4);\n\t\t\t--m[hash_val[j]];\n\t\t\tfor (int dj = 0; dj < 4; ++dj) {\n\t\t\t\tlong long face[4];\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tface[k] = get_hash_val(c[i][k], c[i][k + 3 & 3], c[j][k + 3 & 3], c[j][k]);\n\t\t\t\t}\n\t\t\t\tstd::sort(face, face + 4);\n\t\t\t\tlong long t = 1;\n\t\t\t\tfor (int l = 0; l < 4; ++l) {\n\t\t\t\t\tif(!t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint r = l;\n\t\t\t\t\twhile(r + 1 < 4 && face[r + 1] == face[l]) {\n\t\t\t\t\t\t++r;\n\t\t\t\t\t}\n\t\t\t\t\tint N = m.find(face[l]) == m.end() ? 0 : m[face[l]], M = r - l + 1;\n\t\t\t\t\tlong long a = face[l] / 1000000000ll, b = face[l] / 1000000ll % 1000ll, c = face[l] / 1000ll % 1000ll, d = face[l] % 1000ll;\n\t\t\t\t\tint cnt = (calc_hash_val(a, b, c, d) == face[l]) + (calc_hash_val(b, c, d, a) == face[l]) + (calc_hash_val(c, d, a, b) == face[l]) + (calc_hash_val(d, a, b, c) == face[l]);\n\t\t\t\t\t#ifdef DEBUG\n\t\t\t\t\tprintf(\"%d %d\\t%lld %d\\n\", N, M, face[l], cnt);\n\t\t\t\t\t#endif\n\t\t\t\t\twhile(M--) {\n\t\t\t\t\t\tt *= (long long) (N - M) * cnt;\n\t\t\t\t\t}\n\t\t\t\t\tl = r;\n\t\t\t\t}\n\t\t\t\t#ifdef DEBUG\n\t\t\t\tprintf(\"%lld\\n\", t);\n\t\t\t\t#endif\n\t\t\t\tans += t;\n\t\t\t\trot(c[j]);\n\t\t\t}\n\t\t\t++m[hash_val[j]];\n\t\t\tstd::reverse(c[j] + 1, c[j] + 4);\n\t\t}\n\t\thash_val[i] = get_hash_val(c[i][0], c[i][1], c[i][2], c[i][3]);\n\t\tif(m.find(hash_val[i]) == m.end()) {\n\t\t\tm[hash_val[i]] = 0;\n\t\t}\n\t\t++m[hash_val[i]];\n\t\t#ifdef DEBUG\n\t\tprintf(\"hash_val[%d] = %lld\\n\", i, hash_val[i]);\n\t\t#endif\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nconstexpr ll T[4]={1,1000,1000000,1000000000};\nll f(const ar &x,int k){\n    ll res=0;\n    rep(i,4)res+=T[(i+k)&3]*x[i];\n    return res;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin>>v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i],j);\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                s[0] = f(ar{v[i][1],v[i][0],v[j][1],v[j][0]},0);\n                s[1] = f(ar{v[i][0],v[i][3],v[j][2],v[j][1]},0);\n                s[2] = f(ar{v[i][3],v[i][2],v[j][3],v[j][2]},0);\n                s[3] = f(ar{v[i][2],v[i][1],v[j][0],v[j][3]},0);\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    rep3(t,15,0){\n                        rep(tt,4){\n                            if(t&(1<<tt)){\n                                dp[t]+=dp[t^(1<<tt)]*cnt[tt];\n                            }\n                        }\n                    }\n                }\n                ans += dp[15];\n                rotate(v[j].begin(),v[j].begin()+1,v[j].end());\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\ntypedef tuple<int, int, int, int> TP;\nTP narabi(int a, int b, int c, int d) {\n\tTP kari[4];\n\tkari[0] = tie(a, b, c, d);\n\tkari[1] = tie(b, c, d, a);\n\tkari[2] = tie(c, d, a, b);\n\tkari[3] = tie(d, a, b, c);\n\treturn *min_element(kari, kari + 4);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tTP C[400];\n\tint cnum[1000] = {};\n\trep(i, N) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tC[i] = narabi(a, b, c, d);\n\t\tcnum[a]++;\n\t\tif(a != b) cnum[b]++;\n\t\tif(c != a && c != b) cnum[c]++;\n\t\tif(d != a && d != b && d != c) cnum[d]++;\n\t}\n\n\tsort(C, C + N);\n\tint kazu[400] = {};\n\trep(i, N) {\n\t\tint k = i;\n\t\twhile (k + 1 < N && C[k + 1] == C[i]) k++;\n\t\tkazu[i] = k - i + 1;\n\t\ti = k;\n\t}\n\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint inum = lower_bound(C, C + N, C[i]) - C;\n\t\tkazu[inum]--;\n\t\trep(j, N) if (i != j) {\n\n\t\t\tint a, b, c, d, e, f, g, h;\n\t\t\ta = get<0>(C[i]);\n\t\t\tb = get<1>(C[i]);\n\t\t\tc = get<2>(C[i]);\n\t\t\td = get<3>(C[i]);\n\t\t\te = get<0>(C[j]);\n\t\t\tf = get<1>(C[j]);\n\t\t\tg = get<2>(C[j]);\n\t\t\th = get<3>(C[j]);\n\t\t\tif (cnum[a] <= 2) continue;\n\t\t\tif (cnum[b] <= 2) continue;\n\t\t\tif (cnum[c] <= 2) continue;\n\t\t\tif (cnum[d] <= 2) continue;\n\t\t\tif (cnum[e] <= 2) continue;\n\t\t\tif (cnum[f] <= 2) continue;\n\t\t\tif (cnum[g] <= 2) continue;\n\t\t\tif (cnum[h] <= 2) continue;\n\n\t\t\tint bairitu = kazu[inum] + 1;\n\t\t\tint jnum = lower_bound(C, C + N, C[j]) - C;\n\t\t\tbairitu *= kazu[jnum]--;\n\n\t\t\trep(x, 4) {\n\t\t\t\tTP D[4];\n\t\t\t\tD[0] = narabi(a, d, f, e);\n\t\t\t\tD[1] = narabi(a, e, h, b);\n\t\t\t\tD[2] = narabi(b, h, g, c);\n\t\t\t\tD[3] = narabi(c, g, f, d);\n\t\t\t\tTP* itr[4];\n\t\t\t\trep(k, 4) itr[k] = lower_bound(C, C + N, D[k]);\n\t\t\t\tll kari = bairitu;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (itr[k] != C + N && *(itr[k]) == D[k]) {\n\t\t\t\t\t\tkari *= kazu[itr[k] - C]--;\n\t\t\t\t\t\tif (get<0>(D[k]) == get<2>(D[k]) && get<1>(D[k]) == get<3>(D[k])) {\n\t\t\t\t\t\t\tkari *= 2;\n\t\t\t\t\t\t\tif (get<1>(D[k]) == get<2>(D[k])) kari *= 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tkari = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (itr[k] != C + N && *itr[k] == D[k]) {\n\t\t\t\t\t\tkazu[itr[k] - C]++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tkotae += kari;\n\n\t\t\t\tint tmp = e;\n\t\t\t\te = f;\n\t\t\t\tf = g;\n\t\t\t\tg = h;\n\t\t\t\th = tmp;\n\t\t\t}\n\t\t\tj += kazu[jnum]++;\n\t\t}\n\t\ti += kazu[inum]++;\n\t}\n\tco(kotae / 6);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<ll,int>mp;\n  const ll tmp=(1<<10)-1;\n  ll access(ll now){\n    ll ret=0;\n    rep(i,0,4){\n      ret+=mp[now];\n      now=shift(now);\n    }\n    return max(0LL,ret);\n  }\n  void change(ll v,ll w){\n    mp[v]+=w;\n    if(mp[v]==0)mp.erase(v);\n  }\n  ll trans(const vector<short>&v){\n    return v[0]+((ll)v[1]<<10)+((ll)v[2]<<20)+((ll)v[3]<<30);\n  }\n  ll trans(short a,short b,short c,short d){\n    return a+((ll)b<<10)+((ll)c<<20)+((ll)d<<30);\n  }\n  ll shift(ll x){\n    return (x>>10)+((x&tmp)<<30);\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,short(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  vector<ll>t(n);\n  Dict dict;\n  rep(i,0,n){\n    t[i]=dict.trans(c[i]);\n    dict.mp[t[i]]++;\n  }\n  rep(i,0,n){\n    dict.change(t[i],-1);\n    rep(j,i+1,n){\n      dict.change(t[j],-1);\n      rep(jj,0,4){\n        vector<short>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<ll>ret(4);\n        ret[0]=dict.trans(c[i][1],c[i][0],now[1],now[0]);\n        ret[1]=dict.trans(c[i][2],c[i][1],now[0],now[3]);\n        ret[2]=dict.trans(c[i][3],c[i][2],now[3],now[2]);\n        ret[3]=dict.trans(c[i][0],c[i][3],now[2],now[1]);\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(t[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i) & 3];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)&3] < colors[(j+k)&3]) return true;\n            if (colors[(i+k)&3] > colors[(j+k)&3]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors &a, Colors &b, Colors &brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        if (colcnt.find(c) == colcnt.end()) break;\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        if (colcnt.find(c) == colcnt.end()) return 0;\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    for(auto &pb: colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL multi = pb.second;\n        pb.second--;\n        FORN(rot, 4) {\n            ans += multi * countfit(a, b, brot);\n            brot.rotate_left(1);\n        }\n        pb.second++;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        Colors a = tiles[i];\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define X first\n#define Y second\nusing namespace std;\n\nconst int N=4e2+10;\n\nstruct info{\n    int a[4];\n    void roll(){\n        int tmp=a[3];\n        for(int i=3;i>=1;i--) a[i]=a[i-1];\n        a[0]=tmp;\n    }\n    info (int _a0=0,int _a1=0,int _a2=0,int _a3=0){\n        a[0]=_a0;\n        a[1]=_a1;\n        a[2]=_a2;\n        a[3]=_a3;\n    }\n};\nstruct infocomp{\n    bool operator ()(const info& a,const info& b){\n        for(int i=0;i<4;i++) if (a.a[i]!=b.a[i])\n            return a.a[i]<b.a[i];\n        return 0;\n    }\n};\nmap <info,int,infocomp> need,store;\nint n;\ninfo a[N];\n\nint tu1[5],tu2[5];\nvoid prepare(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<4;j++) scanf(\"%d\",&a[i].a[j]);\n        for(int j=0;j<4;j++){\n//            cout<<\"=>\";\n//                for(int k=0;k<4;k++) cout<<a[i].a[k]<<\" \\n\"[k==3];\n            store[a[i]]++;\n            a[i].roll();\n        }\n    }\n//    for(auto i:store) {\n//        for(int j=0;j<4;j++) cout<<i.X.a[j]<<\" \";\n//        cout<<i.Y<<'\\n';\n//    }\n}\nint getstorage(info a){\n    auto ite=store.find(a);\n    if (ite==store.end()) return 0;\n    return ite->Y;\n}\nvoid takestorage(info a,int val){\n    auto ite=store.find(a);\n    if (ite==store.end()) return;\n    store[a]-=val;\n}\nll A(int x,int y){\n    if (y>x||y<0) return 0;\n    ll ans=1;\n    for(int i=0;i<y;i++) ans*=(x-i);\n    return ans;\n}\nbool operator ==(info a,info b){\n    for(int i=0;i<n;i++) if (a.a[i]!=b.a[i]) return 0;\n    return 1;\n}\nint unidi(info a){\n    int ans=0;\n    info tmp=a;\n    for(int i=0;i<4;i++) {\n        if (a==tmp) ans++;\n        tmp.roll();\n    }\n    return ans;\n}\nll solve(){\n    ll ans=0;\n    for(int u1=1;u1<=n;u1++){\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]--;\n            a[u1].roll();\n        }\n        for(int u2=u1+1;u2<=n;u2++){\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]--;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                need.clear();\n                for(int i=0;i<5;i++) tu1[i]=a[u1].a[i%4];\n                for(int i=0;i<5;i++) tu2[i]=a[u2].a[(1-i+4)%4];\n                for(int i=0;i<4;i++) need[info(tu1[i+1],tu1[i],tu2[i],tu2[i+1])]++;\n                ll cans=1;\n                for(auto cur:need){\n                    int n2=unidi(cur.X);\n                    int n1=getstorage(cur.X)/n2;\n                    cans*=A(n1,cur.Y);\n                    for(int i=0;i<cur.Y;i++) cans*=n2;\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,cur.Y);\n                        tmp.roll();\n                    }\n                }\n                for(auto cur:need){\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,-cur.Y);\n                        tmp.roll();\n                    }\n                }\n                ans+=cans;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]++;\n                a[u2].roll();\n            }\n        }\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]++;\n            a[u1].roll();\n        }\n    }\n    return ans/3;\n}\nint main(){\n    prepare();\n    cout<<solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nvector<int> opt[4];\nmap<ll, vector<pair<int,int>>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                if (m[msk].size() && m[msk].back().first == i) m[msk].back().second++;\n                else m[msk].PB(make_pair(i, 1));\n        }\n\n        fo(i, 0, 4) fo(j, 0, 16) if (((1<<i)&j) == 0) opt[i].PB(j);\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk = 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (auto i : m[msk]) cub[i.first][p] = i.second;\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, top+1, N) if (i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                        fo(x, 0, 4) {\n                                for (int j : opt[x]) {\n                                        ways[j|(1<<x)] += old[j] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot/3);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nlong get(long a,int k){return k==1?a%1000:k==2?a/1000%1000:k==3?a/1000000%1000:a/1000000000;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<array<long,5>,5>,4> >M;\nmap<long,map<int,int> >Q;\nint a[400],b[400],c[400],d[400];\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tlong C=conv(a[i],b[i],c[i],d[i]);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C]++;\n\t\t\tC=rotate(C);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<array<long,5>,5>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<5;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tif(j<k)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<4;i++)A[i][j][k]=A[i][k][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA[0][j][k]=sum-j-k;\n\t\t\t\tA[1][j][k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\t\tA[2][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\t\tA[3][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\t}\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][Q[t[k]][i]][Q[t[k]][j]];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=405;\nint n;\nll ans;\nint a[4];\nclass tile{\npublic:\n\tint c[4],cnt;\n\ttile(){\n\t\tmemset(c,0,sizeof(c));\n\t}\n\ttile(int a[]){\n\t\trep(i,4)c[i]=a[i];\n\t}\n\tbool operator <(const tile &other)const{\n\t\trep(i,3)if(c[i]!=other.c[i])return c[i]<other.c[i];\n\t\treturn c[3]<other.c[3];\n\t}\n\tbool operator ==(const tile &other)const{\n\t\trep(i,4)if(c[i]!=other.c[i])return false;\n\t\treturn true;\n\t}\n\ttile Rotate(){\n\t\ttile res=tile();\n\t\trep(i,4)res.c[i]=c[(i+3)%4];\n\t\treturn res;\n\t}\n\ttile change(){\n\t\tcnt=0;\n\t\ttile t[4];\n\t\trep(i,4)t[0].c[i]=c[i];\n\t\tREP(i,3)t[i]=t[i-1].Rotate();\n\t\tsort(t,t+4);\n\t\trep(i,4)if(t[i]==t[0])cnt++;\n\t\treturn t[0];\n\t}\n\tvoid debug(){\n\t\trep(i,4)printf(\"%d \",c[i]);\n\t\tputs(\"\");\n\t}\n}t[maxn];\nmap<tile,int>mp;\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\trep(j,4)scanf(\"%d\",&a[j]);\n\t\tt[i]=tile(a);\n\t\tmp[t[i].change()]++;\n\t}\n\trep(i,n)\n\t\tfor(int j=i+1;j<n;j++){\n\t\ttile A=t[i],B=t[j],C=A.change(),D=B.change();\n\t\tmp[C]--;\n\t\tmp[D]--;\n\t\trep(C,4){\n\t\t\tmap<tile,int>cur=mp;\n\t\t\tint cur1=0,cur2=0;\n\t\t\tll res=1LL;\n\t\t\trep(k,4){\n\t\t\t\ta[0]=A.c[cur1],a[1]=A.c[(cur1+3)%4],a[2]=B.c[cur2],a[3]=B.c[(cur2+3)%4];\n\t\t\t\ttile now=tile(a);\n\t\t\t\ttile NOW=now.change();\n\t\t\t\tres*=1LL*cur[NOW]*now.cnt;\n\t\t\t\tif(cur[NOW])cur[NOW]--;\n\t\t\t\tcur1=(cur1+3)%4;\n\t\t\t\tcur2=(cur2+1)%4;\n\t\t\t}\n\t\t\tans+=res;\n\t\t\tB=B.Rotate();\n\t\t} \n\t\tmp[C]++;\n\t\tmp[D]++;\n\t}\n\tprintf(\"%lld\",ans/3);\n\treturn 0;\n}\n/*\n6\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n\n#define uint unsigned int\n#define ull unsigned long long\n#define INF 1000000001\n#define LINF 1000000000000000001\n#define ll long long\n#define ld long double\n#define M 1000000007\n#define E 0.0000001\n#define N (1<<17)\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pdd pair<double, double>\n#define pld pair<long double, long double>\n#define cll complex<long long>\n#define cld complex<long double>\n#define X real()\n#define Y imag()\n#define C 'a'\n#define F first\n#define S second\n#define PI 3.1415926535897932384626433\n\nusing namespace std;\n\nint c[400][4];\n\ninline ll h (int i, int r) {\n    ll ans = 0;\n    for (int x = 0; x < 4; x++) {\n        ans = ans * 1001 + c[i][(x + r) % 4];\n    }\n    return ans;\n}\n\nint foo (ll i) {\n    ll a = i % 1001;\n    i /= 1001;\n    ll b = i % 1001;\n    i /= 1001;\n    ll c = i % 1001;\n    i /= 1001;\n    ll d = i;\n    if (a == b && b == c && c == d) return 4;\n    if (a == c && b == d) return 2;\n    return 1;\n}\n\nunordered_map<ll, ll> m;\nunordered_map<ll, int> la;\n\nint main () {\n    int n;\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) cin>>c[i][j];\n        for (int j = 0; j < 4; j++) la[h(i, j)] = i, m[h(i, j)]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) m[h(i, j)]--;\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 0; k < 4; k++) m[h(j, k)]--;\n\n            for (int k = 0; k < 4; k++) {\n                unordered_map<ll, ll> r;\n\n                for (int l = 0; l < 4; l++) {\n                    if (l % 2) r[1001LL * 1001LL * c[i][l] + 1001LL * 1001LL * 1001LL * c[i][(l + 1) % 4] + c[j][(l + k) % 4] + 1001LL * c[j][(l + k + 1) % 4]]++;\n                    else r[1001LL * 1001LL * 1001LL * c[i][l] + 1001LL * 1001LL * c[i][(l + 1) % 4] + c[j][(l + k) % 4] * 1001LL + c[j][(l + k + 1) % 4]]++;\n                }\n                ll x = 1;\n                for (auto p : r) {\n                    ll h = p.first;\n                    ll a = p.second;\n                    ll b = foo(h);\n                    //if (i == 0 && j == 4) cout<<h<<\" \"<<a<<\" \"<<b<<\" \"<<m[h]<<\" \"<<la[h]<<endl;\n                    for (int i = 0; i < a; i++) {\n                        x *= m[h] - b * i;\n                    }\n                }\n                ans += x;\n            }\n\n            for (int k = 0; k < 4; k++) m[h(j, k)]++;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,int> cnt;\nunordered_map<LL,int> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay(v);\n    }\n    int ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    /*tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];*/\n                    tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                int resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint const N = 1234;\n \nlong long f[N];\nint c[N][4];\nlong long dp[1<<4];\nint can[42];\nlong long cr[N][4];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", c[i] + j);\n    }\n    \n    \n    for (int rot = 0; rot < 4; rot++) {\n      long long z = 0;\n      for (int e = 0; e < 4; e++) {\n        z = z * 1000 + c[i][(e + rot) & 3];\n      }\n      cr[i][rot] = z;\n    }\n  }\n  \n  long long ans = 0;\n  for (int first = 0; first < n; first++) \n  {\n    for (int back = first + 1; back < n; back++) \n    {\n      for (int rb = 0; rb < 4; rb++) \n      {\n        for (int i = 0; i < 4; i++) \n        {\n          f[i] = c[first][(i + 1) & 3];\n          f[i] = f[i] * 1000 + c[first][i];\n          f[i] = f[i] * 1000 + c[back][(-i + rb + 1) & 3];\n          f[i] = f[i] * 1000 + c[back][(-i + rb) & 3];\n        }\n        memset(dp, 0, sizeof(dp));\n        dp[0] = 1;\n        for (int i = first + 1; i < n; i++) \n        {\n          if (i == back) continue;\n          for (int j = 0; j < 4; j++) \n          {\n            can[j] = 0;\n            for (int rot = 0; rot < 4; rot++) \n            {\n              if (f[j] == cr[i][rot]) \n              {\n                ++can[j];\n              }\n            }\n          }\n          \n          dp[15] += dp[14] * can[0];\n          dp[15] += dp[13] * can[1];\n          dp[15] += dp[11] * can[2];\n          dp[15] += dp[7] * can[3];\n          dp[14] += dp[12] * can[1];\n          dp[14] += dp[10] * can[2];\n          dp[14] += dp[6] * can[3];\n          dp[13] += dp[12] * can[0];\n          dp[13] += dp[9] * can[2];\n          dp[13] += dp[5] * can[3];\n          dp[12] += dp[8] * can[2];\n          dp[12] += dp[4] * can[3];\n          dp[11] += dp[10] * can[0];\n          dp[11] += dp[9] * can[1];\n          dp[11] += dp[3] * can[3];\n          dp[10] += dp[8] * can[1];\n          dp[10] += dp[2] * can[3];\n          dp[9] += dp[8] * can[0];\n          dp[9] += dp[1] * can[3];\n          dp[8] += dp[0] * can[3];\n          dp[7] += dp[6] * can[0];\n          dp[7] += dp[5] * can[1];\n          dp[7] += dp[3] * can[2];\n          dp[6] += dp[4] * can[1];\n          dp[6] += dp[2] * can[2];\n          dp[5] += dp[4] * can[0];\n          dp[5] += dp[1] * can[2];\n          dp[4] += dp[0] * can[2];\n          dp[3] += dp[2] * can[0];\n          dp[3] += dp[1] * can[1];\n          dp[2] += dp[0] * can[1];\n          dp[1] += dp[0] * can[0];\n        }\n        ans += dp[15];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 400 + 100;\n\nstruct Tile\n{\n\tint a[4];\n\tTile()\n\t{}\n\tTile(int x0, int x1, int x2, int x3)\n\t{\n\t\tint x[4] = {x0, x1, x2, x3};\n\t\tmemcpy(a, x, sizeof(x));\n\t}\n\tbool operator < (const Tile &s) const\n\t{\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tif(a[i] != s.a[i])\n\t\t\t\treturn a[i] < s.a[i];\n\t\treturn false;\n\t}\n};\n\nint n;\nTile s[MAXN];\nmap<Tile, int> cnt;\n\nvoid add(const Tile &s, int v)\n{\n\tfor(int i = 0; i < 4; i++)\n\t\tcnt[Tile(s.a[i], s.a[(i + 1) % 4], s.a[(i + 2) % 4], s.a[(i + 3) % 4])] += v;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tcin >> s[i].a[j];\n\t\tadd(s[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tadd(s[i], -1);\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tadd(s[j], -1);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tTile t[4] = {\n\t\t\t\t\tTile(s[j].a[k], s[j].a[(k + 3) % 4], s[i].a[1], s[i].a[0]),\n\t\t\t\t\tTile(s[j].a[(k + 3) % 4], s[j].a[(k + 2) % 4], s[i].a[2], s[i].a[1]),\n\t\t\t\t\tTile(s[j].a[(k + 2) % 4], s[j].a[(k + 1) % 4], s[i].a[3], s[i].a[2]),\n\t\t\t\t\tTile(s[j].a[(k + 1) % 4], s[j].a[k], s[i].a[0], s[i].a[3])\n\t\t\t\t};\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\ttmp *= cnt[t[l]], add(t[l], -1);\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tadd(t[l], 1);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tadd(s[j], 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,a[405][4];\nmap<ll,int> cnt;\n\ninline ll make(int *a){\n\tll ans=1ll<<60;\n\tfor(int i=0;i<4;i++){\n\t\tll res=0;\n\t\tfor(int j=0;j<4;j++)\n\t\t\tres=res*1000+a[(i+j)%4];\n\t\tgmin(ans,res);\n\t}\n\treturn ans;\n}\ninline ll make(int a,int b,int c,int d){\n\tstatic int x[10];\n\tx[0]=a;x[1]=b;x[2]=c;x[3]=d;\n\treturn make(x);\n}\ninline int calc(int *a){\n\tll ans=make(a),cnt=0;\n\tfor(int i=0;i<4;i++){\n\t\tll res=0;\n\t\tfor(int j=0;j<4;j++)\n\t\t\tres=res*1000+a[(i+j)%4];\n\t\tif(res==ans) cnt++;\n\t}\n\treturn cnt;\n}\ninline int calc(int a,int b,int c,int d){\n\tstatic int x[10];\n\tx[0]=a;x[1]=b;x[2]=c;x[3]=d;\n\treturn calc(x);\n}\n\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tread(a[i][j]);\n\t\tcnt[make(a[i])]++;\n//\t\tdebug(make(a[i]));\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[make(a[i])]--;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tcnt[make(a[j])]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tstatic ll b[10],res;\n\t\t\t\tres=1;\n\t\t\t\tfor(int c=0;c<4;c++){\n\t\t\t\t\tb[c]=make(a[i][(c+1)&3],a[i][c],a[j][(k-c)&3],a[j][(k-c-1)&3]);\n\t\t\t\t\tres*=calc(a[i][(c+1)&3],a[i][c],a[j][(k-c)&3],a[j][(k-c-1)&3]);\n\t\t\t\t}\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tres=res*cnt[b[c]],cnt[b[c]]--;\n\t\t\t\tans+=res;\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tcnt[b[c]]++;\n\t\t\t}\n\t\t\tcnt[make(a[j])]++;\n\t\t}\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n \ntypedef vector<int> vi;\nmap<vi,int> cnt;\nvi normalize(vi vc){\n\tvi ret(4,1e9);\n\trep(i,4){\n\t\tchmin(ret,vc);\n\t\trotate(vc.begin(),vc.begin()+1,vc.end());\n\t}\n\treturn ret;\n}\nint coef(vi vc){\n\tint ret=0;\n\tvi vco=vc;\n\trep(i,4){\n\t\tif(vc==vco) ret++;\n\t\trotate(vc.begin(),vc.begin()+1,vc.end());\n\t}\n\treturn ret;\n}\n \nvi fs[500];\ntypedef long long ll;\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tvi vc(4);\n\t\trep(j,4) cin>>vc[j];\n\t\tfs[i]=normalize(vc);\n\t\tcnt[fs[i]]++;\n\t}\n\tll ans=0;\n\trep(i,N) for(int j=i+1;j<N;j++){\n\t\trep(dj,4){\n\t\t\tvi x=fs[i];\n\t\t\tvi y=fs[j];\n\t\t\trotate(y.begin(),y.begin()+dj,y.end());\n\t\t\tmap<vi,int> used;\n\t\t\tused[fs[i]]++;\n\t\t\tused[fs[j]]++;\n\t\t\tll tmp=1;\n\t\t\trep(d,4){\n\t\t\t\tvi vc={x[0],y[1],y[0],x[1]};\n\t\t\t\tvc=normalize(vc);\n\t\t\t\tif(!cnt.count(vc)) tmp=0;\n\t\t\t\telse{\n\t\t\t\t\tint c=coef(vc);\n\t\t\t\t\ttmp*=c*(cnt[vc]-used[vc]);\n\t\t\t\t\tused[vc]++;\n\t\t\t\t}\n\t\t\t\trotate(x.begin(),x.begin()+1,x.end());\n\t\t\t\trotate(y.begin(),y.begin()+3,y.end());\n\t\t\t}\n\t\t\tans+=tmp;\n\t\t}\n\t}\n\tans/=3;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\nmap<ll, int> dp;\n\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        piipii p1 = c[i];\n        del(p1);\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p2 = c[j];\n            del(p2);\n            for(int k=0;k<4;k++){\n                ll res = 1;\n                piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                if(dp.find(get_idx(tmp1)) != dp.end()){\n                    res *= dp[get_idx(tmp1)];\n                    del(tmp1);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp2)) != dp.end()){\n                    res *= dp[get_idx(tmp2)];\n                    del(tmp2);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp3)) != dp.end()){\n                    res *= dp[get_idx(tmp3)];\n                    del(tmp3);\n                }\n                else res = 0;\n                if(dp.find(get_idx(tmp4)) != dp.end()){\n                    res *= dp[get_idx(tmp4)];\n                    del(tmp4);\n                }\n                else res = 0;\n\n                ans += res;\n\n                if(dp.find(get_idx(tmp1)) != dp.end()){\n                    add(tmp1);\n                }\n                if(dp.find(get_idx(tmp2)) != dp.end()){\n                    add(tmp2);\n                }\n                if(dp.find(get_idx(tmp3)) != dp.end()){\n                    add(tmp3);\n                }\n                if(dp.find(get_idx(tmp4)) != dp.end()){\n                    add(tmp4);\n                }\n\n                p2 = rotate(p2);\n            }\n            add(p2);\n        }\n        add(p1);\n    }\n    printf(\"%lld\\n\", ans/6);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n;\npair<pii,pii> cubes[525];\n\nint main(){\n  scanf(\"%d\",&n);\n  assert(n!=400);\n  while(n==6);\n  REP(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    cubes[i] = make_pair(pii(a,b),pii(c,d));\n  }\n  typedef pii E;\n  typedef pair<pii,pii> S;\n  // one edge, another edge, [count, multiple]\n  map<E, map<E,pii> > edges;\n  // surface, [count, multiple]\n  map<S, pii> surfaces;\n\n  // surface to edges\n  map<S,set<pair<E,E> > > s2e;\n  // surface to surfaces\n  map<S,set<S> > s2s;\n\n  {\n    int a[4];\n    REP(i,n){\n      map<pii,map<pii,int> > ae;\n      map<pair<pii,pii>,int> as;\n      a[0] = cubes[i].first.first;\n      a[1] = cubes[i].first.second;\n      a[2] = cubes[i].second.first;\n      a[3] = cubes[i].second.second;\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        ae[e][oe]+=1;\n        as[s]+=1;\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        if(ae[e][oe]>0){\n          edges[e][oe].first += 1;\n          edges[e][oe].second = ae[e][oe];\n          ae[e][oe] = 0;\n        }\n        if(as[s]>0){\n          surfaces[s].first += 1;\n          surfaces[s].second = as[s];\n          as[s] = 0;\n        }\n        for(auto _s:as){\n          S s = _s.first;\n          s2e[s].insert(make_pair(e,oe));\n        }\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      for(auto _s:as){\n        S s = _s.first;\n        for(auto _t:as){\n          S t = _t.first;\n          s2s[s].insert(t);\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  // 1. determine first surface(a,b,c,d)\n  for(auto _s1:surfaces){\n    S s1 = _s1.first;\n    ll u1 = _s1.second.first * _s1.second.second;\n    int a = s1.first.first;\n    int b = s1.first.second;\n    int c = s1.second.first;\n    int d = s1.second.second;\n    // decrement\n    for(S s:s2s[s1])surfaces[s].first--;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first--;\n    // 2. determine second surface(e,f)\n    E e1 = pii(b,a);\n    for(auto _e2:edges[e1]){\n      E e2 = _e2.first;\n      ll u2 = u1 * _e2.second.first * _e2.second.second;\n      if(u2==0)continue;\n      int e = e2.first;\n      int f = e2.second;\n      // decrement\n      S s2 = make_pair(e1,e2);\n      for(S s:s2s[s2])surfaces[s].first--;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first--;\n      // 3. determine third surface(g,h)\n      E e3 = pii(d,c);\n      for(auto _e4:edges[e3]){\n        E e4 = _e4.first;\n        ll u3 = u2 * _e4.second.first * _e4.second.second;\n        if(u3==0)continue;\n        int g = e4.first;\n        int h = e4.second;\n        // decrement\n        S s3 = make_pair(e3,e4);\n        for(S s:s2s[s3])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first--;\n        // 4,5,6 the other 3 surfaces\n        S s4 = make_pair(pii(a,d),pii(h,e));\n        S s5 = make_pair(pii(e,h),pii(g,f));\n        S s6 = make_pair(pii(c,b),pii(f,g));\n        // s4\n        ll u4 = u3 * surfaces[s4].first * surfaces[s4].second;\n        for(S s:s2s[s4])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first--;\n        // s5\n        ll u5 = u4 * surfaces[s5].first * surfaces[s5].second;\n        for(S s:s2s[s5])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first--;\n        // s4\n        ll u6 = u5 * surfaces[s6].first * surfaces[s6].second;\n        for(S s:s2s[s6])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first--;\n        // add\n        ans += u6;\n        // s4\n        for(S s:s2s[s4])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first++;\n        // s5\n        for(S s:s2s[s5])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first++;\n        // s4\n        for(S s:s2s[s6])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first++;\n        // s3\n        for(S s:s2s[s3])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first++;\n      }\n      for(S s:s2s[s2])surfaces[s].first++;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first++;\n    }\n    for(S s:s2s[s1])surfaces[s].first++;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first++;\n  }\n  printf(\"%lld\\n\",ans/24);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define X first\n#define Y second\nusing namespace std;\n\nconst int N=4e2+10;\n\nstruct info{\n    int a[4];\n    void roll(){\n        int tmp=a[3];\n        for(int i=3;i>=1;i--) a[i]=a[i-1];\n        a[0]=tmp;\n    }\n    info (int _a0=0,int _a1=0,int _a2=0,int _a3=0){\n        a[0]=_a0;\n        a[1]=_a1;\n        a[2]=_a2;\n        a[3]=_a3;\n    }\n};\nstruct infocomp{\n    bool operator ()(const info& a,const info& b){\n        for(int i=0;i<4;i++) if (a.a[i]!=b.a[i])\n            return a.a[i]<b.a[i];\n        return 0;\n    }\n};\nmap <info,int,infocomp> need,store;\nint n;\ninfo a[N];\n\nint tu1[5],tu2[5];\nvoid prepare(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<4;j++) scanf(\"%d\",&a[i].a[j]);\n        for(int j=0;j<4;j++){\n//            cout<<\"=>\";\n//                for(int k=0;k<4;k++) cout<<a[i].a[k]<<\" \\n\"[k==3];\n            store[a[i]]++;\n            a[i].roll();\n        }\n    }\n//    for(auto i:store) {\n//        for(int j=0;j<4;j++) cout<<i.X.a[j]<<\" \";\n//        cout<<i.Y<<'\\n';\n//    }\n}\nint getstorage(info a){\n    auto ite=store.find(a);\n    if (ite==store.end()) return 0;\n    return ite->Y;\n}\nvoid takestorage(info a,int val){\n    auto ite=store.find(a);\n    if (ite==store.end()) return;\n    store[a]-=val;\n}\nll A(int x,int y){\n    if (y>x||y<0) return 0;\n    ll ans=1;\n    for(int i=0;i<y;i++) ans*=(x-i);\n    return ans;\n}\nbool operator ==(info a,info b){\n    for(int i=0;i<4;i++) if (a.a[i]!=b.a[i]) return 0;\n    return 1;\n}\nint unidi(info a){\n    int ans=0;\n    info tmp=a;\n    for(int i=0;i<4;i++) {\n        if (a==tmp) ans++;\n        tmp.roll();\n    }\n    return ans;\n}\nll solve(){\n    ll ans=0;\n    for(int u1=1;u1<=n;u1++){\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]--;\n            a[u1].roll();\n        }\n        for(int u2=u1+1;u2<=n;u2++){\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]--;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                need.clear();\n                for(int i=0;i<5;i++) tu1[i]=a[u1].a[i%4];\n                for(int i=0;i<5;i++) tu2[i]=a[u2].a[(1-i+4)%4];\n                for(int i=0;i<4;i++) need[info(tu1[i+1],tu1[i],tu2[i],tu2[i+1])]++;\n                ll cans=1;\n                for(auto cur:need){\n                    int n2=unidi(cur.X);\n                    int n1=getstorage(cur.X)/n2;\n                    cans*=A(n1,cur.Y);\n                    for(int i=0;i<cur.Y;i++) cans*=n2;\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,cur.Y);\n                        tmp.roll();\n                    }\n                }\n                for(auto cur:need){\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,-cur.Y);\n                        tmp.roll();\n                    }\n                }\n                ans+=cans;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]++;\n                a[u2].roll();\n            }\n        }\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]++;\n            a[u1].roll();\n        }\n    }\n    return ans/3;\n}\nint main(){\n    prepare();\n    cout<<solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\nusing namespace std;\n\nint nextInt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 400;\nint col[N][8];\nlong long hashes[N][4];\nset<long long> any;\nlong long dp[16];\nint ways[4];\n\nlong long calcHash(int a, int b, int c, int d) {\n\tlong long h = 0;\n\th = 1000 * h + a;\n\th = 1000 * h + b;\n\th = 1000 * h + c;\n\th = 1000 * h + d;\n\treturn h;\n}\n\nint main() {\n\tint n = nextInt();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcol[i][j] = nextInt();\n\t\t\tcol[i][j + 4] = col[i][j];\n\t\t}\n\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\thashes[i][rot] = 1000 * hashes[i][rot] + col[i][(rot + j) % 4];\n\t\t\t}\n\t\t\tany.insert(hashes[i][rot]);\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int front = 0; front < n; front++) {\n\t\tint a = col[front][0];\n\t\tint b = col[front][1];\n\t\tint c = col[front][2];\n\t\tint d = col[front][3];\n\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\trotLoop:\n\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\tlong long h1 = calcHash(a, e, f, b);\n\t\t\t\tlong long h2 = calcHash(b, f, g, c);\n\t\t\t\tlong long h3 = calcHash(d, c, g, h);\n\t\t\t\tlong long h4 = calcHash(e, a, d, h);\n\t\t\t\tvector<long long> hs = {h1, h2, h3, h4};\n\t\t\t\tbool can = true;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (any.count(s) == 0) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!can) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tdp[i] = 0;\n\t\t\t\t}\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tways[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\tif (hashes[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ll long long\nusing namespace std;\n\nusing Tile=array<int,4>;\n\nTile rotate(Tile c,int r){\n\trotate(c.begin(),c.begin()+r,c.end());\n\treturn c;\n}\n\nvoid normalize(Tile& c){\n\tTile res=c;\n\tfor(int i=0;i<4;++i){\n\t\tres=rotate(res,i);\n\t\tif(res<c) c=res;\n\t}\n} \n\nint multiplicity(const Tile& c){\n\tint res=0;\n\tfor(int i=0;i<4;++i) if(c==rotate(c,i)) ++res;\n\treturn res;\n}\n\nint n;\nTile c[444];\nmap<Tile,int> cnt,mul;\n\nint main() {\n\t#ifdef kvutxdy\n\tfreopen(\"C:/Users/khanh/OneDrive/RoadtoPurple/Code/Codeforces/input.in\", \"r\", stdin);\n\t#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcin>>n;\n\tfor(int i=0;i<n;++i) for(int j=0;j<4;++j) cin>>c[i][j];\n\tfor(int i=0;i<n;++i) normalize(c[i]);\n\tfor(int i=0;i<n;++i) ++cnt[c[i]];\n\tfor(auto it:cnt) mul[it.fi]=multiplicity(it.fi);\n\tll res=0LL;\n\tfor(int bi=0;bi<n;++bi) for(int ai=0;ai<bi;++ai){\n\t\t--cnt[c[ai]];\n\t\t--cnt[c[bi]];\n\t\tfor(int r=0;r<4;++r){\n\t\t\tconst Tile& a=c[ai];\n\t\t\tTile b=rotate(c[bi],r);\n\t\t\tvector<Tile> d(4);\n\t\t\td[0]={b[0],b[3],a[1],a[0]};\n            d[1]={b[3],b[2],a[2],a[1]};\n            d[2]={b[2],b[1],a[3],a[2]};\n            d[3]={b[1],b[0],a[0],a[3]};\n\t\t\tll tmp=1LL;\n\t\t\tmap<Tile,int> used;\n\t\t\tfor(auto& it:d){\n\t\t\t\tnormalize(it);\n\t\t\t\tif(!cnt.count(it)){\n\t\t\t\t\ttmp=0LL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++used[it];\n\t\t\t\ttmp*=mul[it]*(cnt[it]-used[it]+1);\n\t\t\t}\n\t\t\tres+=tmp;\n\t\t}\n\t\t++cnt[c[ai]];\n\t\t++cnt[c[bi]];\n\t}\n\tcout<<res/3LL;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005,INF=1<<30;\ntypedef pair<pair<int,int>,pair<int,int>> P;\n\nP f(int a,int b,int c,int d){\n    P aa={{a,b},{c,d}};\n    P bb={{b,c},{d,a}};\n    P cc={{c,d},{a,b}};\n    P dd={{d,a},{b,c}};\n    chmin(aa,bb);\n    chmin(aa,cc);\n    chmin(aa,dd);\n    return aa;\n}\n\nP f(P &aa){\n    int a=aa.fi.fi,b=aa.fi.se,c=aa.se.fi,d=aa.se.se;\n    P bb={{b,c},{d,a}};\n    P cc={{c,d},{a,b}};\n    P dd={{d,a},{b,c}};\n    chmin(aa,bb);\n    chmin(aa,cc);\n    chmin(aa,dd);\n    return aa;\n}\n\nint g(P aa){\n    int a=aa.fi.fi,b=aa.fi.se,c=aa.se.fi,d=aa.se.se;\n    if(a==b&&b==c&&c==d) return 4;\n    else if(a==c&&b==d) return 2;\n    else return 1;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    map<P,int> MA;\n    vector<vector<P>> S(N,vector<P>(4));\n    for(int i=0;i<N;i++){\n        int a,b,c,d;cin>>a>>b>>c>>d;\n        S[i][0]=f(a,b,c,d);\n        a=S[i][0].fi.fi;\n        b=S[i][0].fi.se;\n        c=S[i][0].se.fi;\n        d=S[i][0].se.se;\n        S[i][1]={{b,c},{d,a}};\n        S[i][2]={{c,d},{a,b}};\n        S[i][3]={{d,a},{b,c}};\n        \n        MA[S[i][0]]++;\n    }\n    ll ans=0;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            if(i==j) continue;\n            \n            for(int k=0;k<4;k++){\n                P a={{S[j][k].fi.se,S[j][k].fi.fi},{S[i][0].fi.se,S[i][0].fi.fi}};\n                P b={{S[j][k].fi.fi,S[j][k].se.se},{S[i][0].se.fi,S[i][0].fi.se}};\n                P c={{S[j][k].se.se,S[j][k].se.fi},{S[i][0].se.se,S[i][0].se.fi}};\n                P d={{S[j][k].se.fi,S[j][k].fi.se},{S[i][0].fi.fi,S[i][0].se.se}};\n                \n                f(a);\n                f(b);\n                f(c);\n                f(d);\n                \n                int aa=g(a),bb=g(b),cc=g(c),dd=g(d);\n                \n                map<P,int> M;\n                M[S[i][0]]++;\n                M[S[j][0]]++;\n                \n                ll pat=1;\n                pat*=(MA[a]-M[a])*aa;\n                M[a]++;\n                \n                pat*=(MA[b]-M[b])*bb;\n                M[b]++;\n                \n                pat*=(MA[c]-M[c])*cc;\n                M[c]++;\n                \n                pat*=(MA[d]-M[d])*dd;\n                M[d]++;\n                \n                ans+=pat;\n            }\n        }\n    }\n    \n    cout<<ans/6<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP2D(a, n, m) REP(i, n) REP(j, m) printf(\"%lld%c\", a[i][j], j + 1 == m ? '\\n' : ' '); puts(\"\")\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n\ntypedef long long ll;\n\nconst int N_MAX = 400;\n\nint N;\nll C[N_MAX][4];\n\nll h[N_MAX];\nmap<ll, ll> par;\nmap<ll, ll> car;\nmap<ll, ll> tb;\nmap<ll, ll> tbh;\nmap<ll, ll> tbs;\n\nvoid dumpC(ll c) {\n  printf(\"%lld, %lld, %lld, %lld\\n\",\n    c >> 30 & 1023,\n    c >> 20 & 1023,\n    c >> 10 & 1023,\n    c & 1023\n  );\n}\n\nll perm(ll n, ll k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  ll ret = 1;\n  REP(i, k) ret = ret * (n - i);\n  return ret;\n}\n\nvoid solve() {\n  REP(i, N) {\n    ll c = 0;\n    ll cs[4];\n    REP(d, 4) c = c << 10 | C[i][d];\n    REP(d, 4) {\n      // printf(\"i: %d, d: %d, c: %lld :\", i, d, c); dumpC(c);\n      cs[d] = c;\n      c = (c << 10  | c >> 30) & ((1LL << 40) - 1);\n    }\n    c = *min_element(cs, cs + 4);\n    h[i] = c;\n    tb[c]++;\n    car[c] = count(cs, cs + 4, c);\n    REP(d, 4) par[cs[d]] = c;\n  }\n\n  // ITR(par, it) printf(\"k: %lld, v: %lld\\n\", it->first, it->second);\n  // ITR(tb, it) printf(\"k: %lld, v: %lld\\n\", it->first, it->second);\n  // ITR(car, it) printf(\"k: %lld, v: %lld\\n\", it->first, it->second);\n\n  ll ans = 0;\n  REP(j, N) REP(i, j) {\n    // printf(\"h[%d]: \", i); dumpC(h[i]);\n    // printf(\"h[%d]: \", j); dumpC(h[j]);\n    tbh.clear();\n    tbh[par[h[i]]]++; tbh[par[h[j]]]++;\n    REP(k, 4) {\n      // printf(\"  k: %d\\n\", k);\n      tbs.clear();\n      REP(d, 4) {\n        ll s = 0;\n        s |= C[i][(1 + d) % 4] << 30;\n        s |= C[i][d % 4] << 20;\n        s |= C[j][(4 - d + k) % 4] << 10;\n        s |= C[j][(7 - d + k) % 4];\n        tbs[par[s]]++;\n      }\n      ll sp = 1;\n      ITR(tbs, it) {\n        ll s = it->first;\n        ll sc = it->second;\n        ll scb = perm(tb[s] - tbh[s], sc);\n        // if (scb != 0 && i == 0 && j == 1) {\n          // printf(\" s: \"); dumpC(s);\n          // printf(\" sc: %lld, tb-tbh: %lld, scb: %lld, car: %lld\\n\", sc, tb[s] - tbh[s], scb, car[s]);\n        // }\n        REP(i, sc) scb *= car[s];\n        sp *= scb;\n      }\n      ans += sp;\n    }\n  }\n\n  printf(\"%lld\\n\", ans / 3);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) REP(j, 4) scanf(\"%lld\", &C[i][j]);\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//時間内にできず，しかもTLE\n\n//方針は合っているが，オーダーがうっかり増えてしまっている\n//setの要素削除できるようになっとかないと．\n#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define pb push_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define debug printf(\"--%d--\\n\",__LINE__)\n#define ll long long int\n\nint n;\nint c[512][4];\nll ans = 0;\n\nbool same(vi x, vi y){\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tif (x[j] != y[(i+j)%4]) break;\n\t\t\tif (j==3) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvi rot(vi a, int n){\n\tvi ret(4);\n\tfor(int i=0;i<4;i++){\n\t\tret[i] = a[(i+n)%4];\n\t}\n\treturn ret;\n}\n\nvi normalize(vi a){\n\tint x = 0, y = 0;\n\tx = a[1] + a[2] - a[3] - a[0];\n\ty = a[0] + a[1] - a[2] - a[3];\n\tif (x==0 && y==0){\n\t\tif (a[0] > a[1]) return rot(a,1);\n\t\treturn a;\n\t}\n\tif (x>0 && y>=0) return rot(a,1);\n\tif (x>=0 && y<0) return rot(a,2);\n\tif (x<0 && y<=0) return rot(a,3);\n\treturn a;\n}\n\nint calcsym(vi a){\n\tif (a[0]==a[1] && a[0]==a[2] && a[0]==a[3]) return 4;\n\tif (a[0]==a[2] && a[1]==a[3]) return 2;\n\treturn 1;\n}\n\nint main(void){\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tvi men(4);\n\t\tfor(int j=0;j<4;j++){\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tll ans = 0;\n\tvvi menscatalog;\n\tfor(int i=0;i<n;i++){\n\t\tvi men(4);\n\t\tfor(int j=0;j<4;j++){\n\t\t\tmen[j] = c[i][j];\n\t\t}\n\t\tmenscatalog.pb(normalize(men));\n\t}\n\t\n\t\n\tmultiset<vi> allmens;\n\tfor(int k=0;k<n;k++){\n\t\tallmens.insert(menscatalog[k]);\n\t}\n\t\n\t\n\tfor(int i=0;i<n;i++){\n\t\t//erase i-th men\n\t\tmultiset<vi>::iterator itr = allmens.find(menscatalog[i]);\n\t\tallmens.erase(itr);\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\t//erase j-th men\n\t\t\tmultiset<vi>::iterator itr = allmens.find(menscatalog[j]);\n\t\t\tallmens.erase(itr);\n\t\t\t//insert (j-1)-th men (if j>i+1)\n\t\t\tif (j>i+1){\n\t\t\t\tallmens.insert(menscatalog[j-1]);\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvvi mens;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tvi men;\n\t\t\t\t\tmen.pb(c[i][l]);\n\t\t\t\t\tmen.pb(c[j][(4-l+k)%4]);\n\t\t\t\t\tmen.pb(c[j][(7-l+k)%4]);\n\t\t\t\t\tmen.pb(c[i][(l+1)%4]);\n\t\t\t\t\tmens.pb(normalize(men));\n\t\t\t\t}\n\t\t\t\t//cout << i << \" \" << j << \" \" << k << endl;\t\t\t\t\n\t\t\t\t/*for(int l=0;l<4;l++){\n\t\t\t\t\tfor(int m=0;m<4;m++){\n\t\t\t\t\t\tcout << mens[l][m] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}*/\n\t\t\t\tvi chk(4);\n\t\t\t\tll num = 1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif (chk[l]) continue;\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tfor(int m=l+1;m<4;m++){\n\t\t\t\t\t\tif (mens[l]==mens[m]){\n\t\t\t\t\t\t\tchk[m] = 1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint mc = allmens.count(mens[l]);\n\t\t\t\t\t/*if (mc>0){\n\t\t\t\t\t\tcout << \"mc = \" << mc << \": \";\n\t\t\t\t\t\tfor(int m=0;m<4;m++){\n\t\t\t\t\t\t\tcout << mens[l][m] << \" \";\n\t\t\t\t\t\t}cout << endl;\n\t\t\t\t\t}*/\n\t\t\t\t\tint sym = calcsym(mens[l]);\n\t\t\t\t\tfor(int m=0;m<cnt;m++){\n\t\t\t\t\t\tnum *= (mc-m)*sym;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += num;\n\t\t\t}\n\t\t\t\n\t\t\t//insert (n-1)-th men (if j=n-1)\n\t\t\tif (j==n-1){\n\t\t\t\tallmens.insert(menscatalog[n-1]);\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 2220;\n\nint n;\nint ar[N][6];\nlong long dp[N][16];\n\nlong long ans;\n\nint ar1[100], ar2[100];\nint matches[1000];\n\nvector<int> cube_list[1050], lists[10];\nint pattern[1050];\n\nvector<int> get_rotation(vector<int> v, int ps)\n{\n\tvector<int> res = v;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tres[i] = v[(i + ps) % v.size()];\n\t}\n\treturn res;\n}\n\nint good_rotations(vector<int> v)\n{\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvector<int> v2 = get_rotation(v, i);\n\t\tif (v2 == v)\n\t\t\t++res;\n\t}\n\treturn res;\n}\nbool better(vector<int> a, vector<int> b)\n{\n\tfor (int i = 0; i < a.size(); i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t\treturn a[i] < b[i];\n\t}\n\treturn false;\n}\n\nvector<int> normalize(vector<int> v)\n{\n\tvector<int> res = v;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvector<int> here = get_rotation(v, i);\n\t\tif (better(here, res))\n\t\t\tres = here;\n\t}\n\treturn res;\n}\n\nint maps[N], maps2[N];\nset<vector<int> > v_list;\nmap<vector<int>, int> mapp;\nint cnt[1 << 20];\n\nint get_id(vector<int> v,int flag)\n{\n\tif (v_list.find(v) == v_list.end())\n\t{\n\t\tif (flag == 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tv_list.insert(v);\n\t\tmapp[v] = v_list.size();\n\t}\n\treturn mapp[v];\n}\n\nlong long run_solver(int id_front, int id_back, int rot_back)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tar1[i] = ar[id_front][i];\n\t}\n\n\tar2[0] = ar[id_back][(0+rot_back)%4];\n\tar2[1] = ar[id_back][(3+rot_back)%4];\n\tar2[2] = ar[id_back][(2+rot_back)%4];\n\tar2[3] = ar[id_back][(1+rot_back)%4];\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tlists[i].clear();\n\t}\n\tfor (int q = 0; q < 4; q++)\n\t{\n\t\tint i = q;\n\t\tlists[i].push_back(ar2[q]);\n\t\tlists[i].push_back(ar2[(q + 1) % 4]);\n\t\tlists[i].push_back(ar1[(q + 1) % 4]);\n\t\tlists[i].push_back(ar1[q]);\n\t}\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tlists[i] = normalize(lists[i]);\n\t}\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tpattern[i] = i;\n\t}\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (pattern[i] != i)\n\t\t\tcontinue;\n\t\tfor (int j = i + 1; j < 4; j++)\n\t\t{\n\t\t\tif (lists[i]==lists[j])\n\t\t\t\tpattern[j] = i;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tmaps2[i] = get_id(lists[i],1);\n\t}\n\n\t/*for (int i = 0; i < 4; i++)\n\t{\n\t\tcnt[i] = 0;\n\t}\n\n\tfor (int i = id_front+1; i <= n; i++)\n\t{\n\t\tif (i == id_back)\n\t\t\tcontinue;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (pattern[j] != j)\n\t\t\t\tcontinue;\n\t\t\tif (maps[i] == maps2[j])\n\t\t\t\t++cnt[j];\n\t\t}\n\t}\n\t*/\n\tlong long res = 1;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint here = pattern[i];\n\t\tif (cnt[maps2[here]] == 0)\n\t\t\tres = 0;\n\t\tres *= cnt[maps2[here]];\n\t\t//cout << cnt[here] << \"%\" << good_rotations(lists[i]) << endl;\n\t\tcnt[maps2[here]]--;\n\t\tres *= good_rotations(lists[i]);\n\t}\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint here = pattern[i];\n\t\tcnt[maps2[here]]++;\n\t}\n\n//\tcout << res << endl;\n\treturn res;\n}\n\nint main(){\n\t//freopen(\"fabro.in\",\"r\",stdin);\n\t//freopen(\"fabro.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\", \"r\", stdin);\n\t//freopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcin >> ar[i][j];\n//\t\t\tar[i][j] = rand() % 1000;\n\t\t}\n\t\tvector<int> v;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tv.push_back(ar[i][j]);\n\t\t}\n\t\tv = normalize(v);\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tar[i][j] = v[j];\n\t\t}\n\t\tcube_list[i] = v;\n\t\tmaps[i] = get_id(v,0);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcnt[maps[i]]++;\n\t}\n\n\tfor (int F = 1; F <= n; F++)\n\t{\n\t\tcnt[maps[F]]--;\n\n\t\tfor (int B = F + 1; B <= n; B++)\n\t\t{\n\t\t\tif (F == B)\n\t\t\t\tcontinue;\n\t\t\tcnt[maps[B]]--;\n\t\t\tfor (int brot = 0; brot < 4; brot++)\n\t\t\t{\n\t\t\t\tans+=run_solver(F, B, brot);\n\t\t\t}\n\t\t\tcnt[maps[B]]++;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {}, e[16][4] = {};\n  \tfor (int i = 0; i < 16; i++) for (int j = 0; j < 4; j++) if (i & (1 << j)) e[i][j] = 1;\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                int c[4] = {}, b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}};\n              \tll d[16] = {1};\n                for (int l = i + 1; l <= n; l++) {\n                  \tfor (int m = 0; m < 4; m++) {\n                      \tc[m] = 0;\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[m]++;\n                    }\n                  \tif (l == j) continue;\n                    d[15] += c[0] * d[14];\n                    d[15] += c[1] * d[13];\n                    d[15] += c[2] * d[11];\n                    d[15] += c[3] * d[7];\n                    d[14] += c[1] * d[12];\n                    d[14] += c[2] * d[10];\n                    d[14] += c[3] * d[6];\n                    d[13] += c[0] * d[12];\n                    d[13] += c[2] * d[9];\n                    d[13] += c[3] * d[5];\n                    d[12] += c[2] * d[8];\n                    d[12] += c[3] * d[4];\n                    d[11] += c[0] * d[10];\n                    d[11] += c[1] * d[9];\n                    d[11] += c[3] * d[3];\n                    d[10] += c[1] * d[8];\n                    d[10] += c[3] * d[2];\n                    d[9] += c[0] * d[8];\n                    d[9] += c[3] * d[1];\n                    d[8] += c[3] * d[0];\n                    d[7] += c[0] * d[6];\n                    d[7] += c[1] * d[5];\n                    d[7] += c[2] * d[3];\n                    d[6] += c[1] * d[4];\n                    d[6] += c[2] * d[2];\n                    d[5] += c[0] * d[4];\n                    d[5] += c[2] * d[1];\n                    d[4] += c[2] * d[0];\n                    d[3] += c[0] * d[2];\n                    d[3] += c[1] * d[1];\n                    d[2] += c[1] * d[0];\n                    d[1] += c[0] * d[0];\n                }\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint N,C[410][4],cnt;\nlong long id(int*a){\n\tlong long v=-1;\n\tfor(int d=0;d<4;d++){\n\t\tlong long t=0;\n\t\tfor(int i=0;i<4;i++)t|=1ll*a[d+i&3]<<i*10;\n\t\tt>v?v=t,cnt=1:t==v?++cnt:0;\n\t}\n\treturn v;\n}\nconst int mod=10007;\nstruct item{long long x;int cnt;item*next;}items[1610],*nit=items,*fir[mod];\nvoid ins(long long x){\n\tint h=x%mod;\n\tfor(item*it=fir[h];it;it=it->next)\n\t\tif(it->x==x){++it->cnt;return;}\n\t*nit=(item){x,1,fir[h]};\n\tfir[h]=nit++;\n}\nint fd(long long x,bool*suc){\n\tfor(item*it=fir[x%mod];it;it=it->next)\n\t\tif(it->x==x)return*suc=1,it->cnt--;\n\treturn*suc=0;\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<4;j++)scanf(\"%d\",C[i]+j);\n\t\tins(id(C[i]));\n\t}\n\tlong long sum=0;\n\tbool tmp;\n\tfor(int x=0;x<N;x++){\n\t\tfd(id(C[x]),&tmp);\n\t\tfor(int y=x+1;y<N;y++){\n\t\t\tfd(id(C[y]),&tmp);\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\tlong long t=1,z[4];\n\t\t\t\tbool suc[4]={0};\n\t\t\t\tfor(int i=0;i<4&&t;i++){\n\t\t\t\t\tint a[4]={C[y][d-i&3],C[y][d-i-1&3],C[x][i+1&3],C[x][i&3]};\n\t\t\t\t\tz[i]=id(a);\n\t\t\t\t\tt*=fd(z[i],suc+i)*cnt;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++)if(suc[i])ins(z[i]);\n\t\t\t\tsum+=t;\n\t\t\t}\n\t\t\tins(id(C[y]));\n\t\t}\n\t\tins(id(C[x]));\n\t}\n\tprintf(\"%lld\\n\",sum/3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> color[505];\nmap<vector<int>, int> has;\nint jiao[8];\nint use[4][4]={\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid add(vector<int> color)\n{\n  for (int i=0; i<4; i++)\n  {\n      has[color]++;\n      rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid reduce(vector<int> color)\n{\n\n    for (int i=0; i<4; i++)\n    {\n        has[color]--;\n        rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid dfs(int dep,long long& ans,int res=1)\n{\n    if (dep==4) ans+=res;\n    else\n    {\n        vector<int> tmp(4);\n        for (int i=0; i<4; i++)\n            tmp[i]=jiao[use[dep][i]];\n        if (has.count(tmp))\n        {\n            int cnt=has[tmp];\n            reduce(tmp);\n            dfs(dep+1,ans,res*cnt);\n            add(tmp);\n        }\n    }\n}\n\nlong long solve(int a,int b)\n{\n    for (int i=0; i<4; i++)\n    {\n        jiao[i]=color[a][i];\n        jiao[i+4]=color[b][i];\n    }\n    long long ans=0;\n    for (int i=0; i<4; i++)\n    {\n        dfs(0,ans);\n        rotate(jiao+4,jiao+5,jiao+6);\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++)\n    {\n        color[i].resize(4);\n        for (int j=0; j<4; j++)\n        {\n            scanf(\"%d\",&color[i][j]);\n        }\n        add(color[i]);\n    }\n    long long ans1=0;\n    for (int i=0; i<n; i++)\n    {\n      for (int j=i+1; j<n; j++)\n      {\n          reduce(color[i]);\n          reduce(color[j]);\n          ans1+=solve(i,j);\n          add(color[i]);\n          add(color[j]);\n      }\n      reduce(color[i]);\n    }\n    printf(\"%lld\\n\",ans1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T,typename U, typename H=hash<T> >\nusing gmap = cc_hash_table<T, U, H>;\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\ngmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\n\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\n__int128_t check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(cnt.find(a)!=cnt.end()) return 0;\n  if(cnt.find(b)!=cnt.end()) return 0;\n  if(cnt.find(c)!=cnt.end()) return 0;\n  if(cnt.find(d)!=cnt.end()) return 0;\n  if(cnt.find(e)!=cnt.end()) return 0;\n  if(cnt.find(f)!=cnt.end()) return 0;\n\n  __int128_t res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[(k+z)%4][i];\n          x[k+4]=cs[k][j];\n        }\n\n        int way=0;\n        A w(x);\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          chmin(w,y);\n        }\n\n        if(used.count(make_hash(w))) continue;\n        used.emplace(make_hash(w));\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t5005\n#define MAXV\t1000\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nmap <long long, int> cnt;\nint n, a[MAXN], b[MAXN], c[MAXN], d[MAXN];\nlong long Hash(int a, int b, int c, int d) {\n\tlong long ans = a;\n\tans = ans * MAXV + b;\n\tans = ans * MAXV + c;\n\tans = ans * MAXV + d;\n\treturn ans;\n}\nint Count(int a, int b, int c, int d) {\n\treturn cnt[Hash(a, b, c, d)];\n}\nvoid Modify(int a, int b, int c, int d, int x) {\n\tcnt[Hash(a, b, c, d)] += x;\n\tcnt[Hash(b, c, d, a)] += x;\n\tcnt[Hash(c, d, a, b)] += x;\n\tcnt[Hash(d, a, b, c)] += x;\n}\nlong long Query(int a, int b, int c, int d, int A, int B, int C, int D) {\n\tlong long ans = 1;\n\tans *= Count(a, A, B, b);\n\tModify(a, A, B, b, -1);\n\tans *= Count(b, B, C, c);\n\tModify(b, B, C, c, -1);\n\tans *= Count(c, C, D, d);\n\tModify(c, C, D, d, -1);\n\tans *= Count(d, D, A, a);\n\tModify(d, D, A, a, -1);\n\tModify(a, A, B, b, 1);\n\tModify(b, B, C, c, 1);\n\tModify(c, C, D, d, 1);\n\tModify(d, D, A, a, 1);\n\treturn ans;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]), read(b[i]), read(c[i]), read(d[i]);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tModify(a[j], b[j], c[j], d[j], -1);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], d[j], c[j], b[j], a[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], a[j], d[j], c[j], b[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], b[j], a[j], d[j], c[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], c[j], b[j], a[j], d[j]);\n\t\t\tModify(a[j], b[j], c[j], d[j], 1);\n\t\t}\n\t\tModify(a[i], b[i], c[i], d[i], 1);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 404;\nint c[maxn][4];\nvoid rotate(int id){\n\tint p0 = c[id][0];\n\tfor(int j = 0; j < 3; j++) c[id][j] = c[id][j + 1];\n\tc[id][3] = p0;\n}\nlong long calc(int id){\n\tlong long val = 0;\n\tfor(int k = 0; k < 4; k++) val = val * 1000 + c[id][k];\n\treturn val;\n}\nlong long has[maxn][4];\nvoid ins(int id){\n\tfor(int rot = 0; rot < 4; rot++){\n\t\thas[id][rot] = calc(id);\n\t\trotate(id);\n\t}\n\tsort(has[id], has[id] + 4);\n}\nint get_msk(int id, long long vals[4]){\n\tint i = 0, j = 0, msk = 0;\n\twhile(i < 4 && j < 4){\n\t\tif(has[id][i] == vals[j]) msk |= 1<<j, j++;\n\t\telse if(has[id][i] < vals[j]) i++;\n\t\telse j++;\n\t}\n\treturn msk;\n}\nmap<vector<long long>, int> magic;\nvoid add(int i, int s){\n\tset<vector<long long> > can;\n\tfor(int j = 1; j < 1<<4; j++){\n\t\tvector<long long> now;\n\t\tfor(int k = 0; k < 4; k++) if((j>>k)&1){\n\t\t\tif(now.empty() || now.back() != has[i][k]) now.push_back(has[i][k]);\n\t\t}\n\t\tcan.insert(now);\n\t}\n\tfor(auto e : can) magic[e] += s;\n}\nlong long need[4];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < 4; j++) cin >> c[i][j];\n\tfor(int i = 0; i < n; i++){\n\t\tins(i);\n\t\tadd(i, 1);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tadd(i, -1);\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tadd(j, -1);\n\t\t\tfor(int rotj = 0; rotj < 4; rotj++){\n\t\t\t\tint prot[4] = {};\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nik = (k + 1) % 4;\n\t\t\t\t\tint njk0 = (5 - k) % 4;\n\t\t\t\t\tint njk1 = (4 - k) % 4; \n\t\t\t\t\tneed[k] = 0;\n\t\t\t\t\tfor(int v : {c[i][nik], c[i][k], c[j][njk0], c[j][njk1]}){\n\t\t\t\t\t\tneed[k] = need[k] * 1000 + v;\n\t\t\t\t\t}\n\t\t\t\t\tc[n][0] = c[i][nik];\n\t\t\t\t\tc[n][1] = c[i][k];\n\t\t\t\t\tc[n][2] = c[j][njk0];\n\t\t\t\t\tc[n][3] = c[j][njk1];\n\t\t\t\t\tfor(int tk = 0; tk < 4; tk++){\n\t\t\t\t\t\tif(calc(n) == need[k]) prot[k]++;\n\t\t\t\t\t\trotate(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(need, need + 4);\n\t\t\t\tvector<int> cnt(1<<4);\n\t\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\t\tvector<long long> now;\n\t\t\t\t\tfor(int p = 0; p < 4; p++) if((k>>p)&1){\n\t\t\t\t\t\tif(now.empty() || now.back() != need[p]) now.push_back(need[p]);\n\t\t\t\t\t}\n\t\t\t\t\tcnt[k] = magic[now];\n\t\t\t\t}\n\t\t\t\tfor(int k = 15; k > 0; k--){\n\t\t\t\t\tfor(int sk = k; sk; sk = (sk - 1) & k){\n\t\t\t\t\t\tif(sk != k){\n\t\t\t\t\t\t\tcnt[sk] -= cnt[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<long long> f(1<<4, 0), nf(1<<4, 0);\n\t\t\t\tf[0] = 1;\n\t\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\t\tif(cnt[k]){\n\t\t\t\t\t\tnf = f;\n\t\t\t\t\t\tfor(int sk = k; sk; sk = k & (sk - 1)){\n\t\t\t\t\t\t\tassert((k&sk) == sk);\n\t\t\t\t\t\t\tlong long ways = 1;\n\t\t\t\t\t\t\tint bc = __builtin_popcount(sk);\n\t\t\t\t\t\t\tfor(int z = 0; z < bc; z++) ways *= (cnt[k] - z);\n\t\t\t\t\t\t\tif(ways > 0){\n\t\t\t\t\t\t\t\tfor(int msk = 0; msk < 1<<4; msk++){\n\t\t\t\t\t\t\t\t\tif((msk&sk) == 0){\n\t\t\t\t\t\t\t\t\t\tnf[msk|sk] += f[msk] * ways;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = nf;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\tfor(int k = 0; k < 4; k++) f[15] *= prot[k];\n\t\t\t\tans += f[15];\n\t\t\t\trotate(j);\n\t\t\t}\n\t\t\tadd(j, 1);\n\t\t}\n\t\tadd(i, 1);\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    #include<map>\n    using namespace std;\n    typedef long long ll;\n    int n;\n    struct node{int col[4];\n        node nxt(){ return node{col[1],col[2],col[3],col[0]};}\n        friend bool operator <(node a,node b)\n        {\n            for (int i=0;i<4;i++)\n                if (a.col[i]!=b.col[i]) return a.col[i]<b.col[i];\n            return 0;\n        }\n    }a[410],a1,a2,a3,a4;\n    map<node,int>mp;\n    void insert(node x,int v)\n    {for (int i=0;i<4;i++,x=x.nxt()) mp[x]+=v;}\n     \n     \n    node xx,yy;\n    int id1;\n    ll ans,re;\n    int main()\n    {\n        scanf(\"%d\",&n);\n        for (int i=1;i<=n;i++)\n        {\n            scanf(\"%d%d%d%d\",&a[i].col[0],&a[i].col[1],&a[i].col[2],&a[i].col[3]);    \n            insert(a[i],1);    \n        }\n        for (int i=1;i<=n;i++)\n        {\n            insert(a[i],-1);\n            for (int j=i+1;j<=n;j++)\n            {\n                insert(a[j],-1);\n                for (int t=0;t<4;t++)\n                {\n                    a1=node{a[j].col[1],a[i].col[0],a[i].col[3],a[j].col[2]};\n                    a2=node{a[i].col[1],a[j].col[0],a[j].col[3],a[i].col[2]};\n                    a3=node{a[j].col[1],a[j].col[0],a[i].col[1],a[i].col[0]};\n                    a4=node{a[i].col[3],a[i].col[2],a[j].col[3],a[j].col[2]};\n                    a[j]=a[j].nxt();                \n                    if (mp[a1]==0||mp[a2]==0||mp[a3]==0||mp[a4]==0) continue;\n                    re=1;\n                    re*=mp[a1];insert(a1,-1);\n                    re*=mp[a2];insert(a2,-1);\n                    re*=mp[a3];insert(a3,-1);\n                    re*=mp[a4];\n                    insert(a1,1);insert(a2,1);insert(a3,1);\n                    ans+=re;\n     \n                }\n                insert(a[j],1);\n            }\n        }\n        cout<<ans;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll get_num(vll tmp){\n  ll a = tmp[0]*1000000000+tmp[1]*1000000+tmp[2]*1000+tmp[3];\n  ll b = tmp[1]*1000000000+tmp[2]*1000000+tmp[3]*1000+tmp[0];\n  ll c = tmp[2]*1000000000+tmp[3]*1000000+tmp[0]*1000+tmp[1];\n  ll d = tmp[3]*1000000000+tmp[0]*1000000+tmp[1]*1000+tmp[2];\n  return min({a, b, c, d});\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  vvl v = VV(n, 4, 0, ll);\n  map<ll, ll> mp;\n\n  for(int i=0;i<n;i++){\n    scanf(\"%lld %lld %lld %lld\", &v[i][0], &v[i][1], &v[i][2], &v[i][3]);\n    ll num = get_num(v[i]);\n    auto itr = mp.find(num);\n    if(itr==mp.end()) mp.emplace(num, 1);\n    else (*itr).second++;\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    ll I = get_num(v[i]);\n    for(int j=i+1;j<n;j++){\n      ll J = get_num(v[j]);\n      for(int k=0;k<4;k++){\n        map<ll, ll> z;\n        for(int t=0;t<4;t++){\n          //t, t+1, t+k+1, t+k\n          ll num = get_num(vll{v[i][(t+1)%4], v[i][t], v[j][(-t+k+1+4)%4], v[j][(-t+k+4)%4]});\n          auto itr = z.find(num);\n          if(itr==z.end()) z.emplace(num, 1);\n          else (*itr).second++;\n        }\n        ll tmp = 1;\n\n        for(auto to:z){\n          //if(i==1&&j==3&&k==2) std::cout << to.first << '\\n';\n          ll num = to.first;\n          auto itr = mp.find(num);\n          if(itr==mp.end()){\n            tmp = 0;\n            break;\n          }\n          ll max_num = (*itr).second;\n          if(num==I) max_num--;\n          if(num==J) max_num--;\n          if(max_num<to.second){\n            tmp = 0;\n            break;\n          }\n          ll a = num/1000000000;\n          ll b = (num-a*1000000000)/1000000;\n          ll c = (num - a*1000000000 - b*1000000)/1000;\n          ll d = num%1000;\n          for(int p=0;p<to.second;p++) {\n            tmp *= (max_num - p);\n            if(a==b && b==c&&c==d) tmp *= 4;\n            else if(a==c&&b==d) tmp *= 2;\n          }\n        }\n        ans += tmp;\n      }\n    }\n  }\n  std::cout << ans/3 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef long long ll;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin p2(in a){\n  return 1<<a;\n}\nVI bcl;\nVVI cl;\nVVI cord={{0,5,4,1},{1,4,7,2},{2,7,6,3},{5,0,3,6}};\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  cl.resize(n,VI(4));\n  forn(z,n){\n    forn(i,4)\n      cin>>cl[z][i];\n  }\n  bcl.resize(8);\n  in sm=0;\n  forn(a,n){\n    forn(b,a){\n      forn(z,4){\n\trotate(cl[a].begin(),cl[a].begin()+1,cl[a].end());\n\tforn(k,4){\n\t  bcl[k]=cl[b][k];\n\t  bcl[k+4]=cl[a][k];\n\t}\n\tVI tw(p2(4),0);\n\tVI nuw(p2(4),0);\n\tVI wloc(4);\n\ttw[0]=1;\n\tfor(in i=b+1;i<n;++i){\n\t  if(i==a)\n\t    continue;\n\t  forn(zz,4)\n\t    wloc[zz]=0;\n\t  bool ok;\n\t  forn(zz,4){\n\t    rotate(cl[i].begin(),cl[i].begin()+1,cl[i].end());\n\t    forn(loc,4){\n\t      ok=1;\n\t      forn(k,4)\n\t\tok&=(cl[i][k]==bcl[cord[loc][k]]);\n\t      wloc[loc]+=ok;\n\t    }\n\t  }\n\t  forn(msk,p2(4))\n\t    nuw[msk]=tw[msk];\n\t  forn(msk,p2(4)){\n\t    forn(loc,4){\n\t      if(msk&p2(loc))\n\t\tcontinue;\n\t      nuw[msk|p2(loc)]+=tw[msk]*wloc[loc];\n\t    }\n\t  }\n\t  forn(msk,p2(4))\n\t    tw[msk]=nuw[msk];\n\t}\n\tsm+=tw[p2(4)-1];\n      }\n    }\n  }\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define f first\n#define s second\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%I64d\",&x)\n#define CLR(x)  memset(x,0,sizeof(x))\n#define RESET(x,a) memset(x,a,sizeof(x))\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<\">value (\"<<#x<<\") : \"<<x<<endl;\n\nconst int N=405;\nint a[N][4]; //tile\nll val[N];   //hash of tile\nint p[4];\nint sym[4];\nll g[4];\nll ans[16];\nint n;\n\ninline ll h(int p[4],int k)\n{\n    ll res=0LL;\n    for(int i=k;i<4;i++)\n        res = res<<10LL | (ll)p[i];\n    for(int i=0;i<k;i++)\n        res = res<<10LL | (ll)p[i];\n    return res;\n}\n\nll normalise(int p[4])\n{\n    return min(h(p,0),min(h(p,1),min(h(p,2),h(p,3))));\n}\n\nll way(int x, int y, int r)\n{\n    int i,j,k,b[4];\n    for(i=0;i<4;i++)\n        b[i]=a[y][ (i+r)%4 ];\n    ll e,f,c,d;\n    sym[0]=sym[1]=sym[2]=sym[3]=1;\n    p[0]=b[1];   p[1]=b[0];\n    p[2]=a[x][1];   p[3]=a[x][0];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[0]=4;\n    else if(e==c)sym[0]=2;\n    g[0]=min(e,min(f,min(c,d)));\n\n    p[0]=b[0];   p[1]=b[3];\n    p[2]=a[x][2];   p[3]=a[x][1];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[1]=4;\n    else if(e==c)sym[1]=2;\n    g[1]=min(e,min(f,min(c,d)));\n\n    p[0]=b[2];   p[1]=b[1];\n    p[2]=a[x][0];   p[3]=a[x][3];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[2]=4;\n    else if(e==c)sym[2]=2;\n    g[2]=min(e,min(f,min(c,d)));\n\n    p[0]=b[3];   p[1]=b[2];\n    p[2]=a[x][3];   p[3]=a[x][2];\n    e=h(p,0); f=h(p,1); c=h(p,2); d=h(p,3);\n    if(e==f)sym[3]=4;\n    else if(e==c)sym[3]=2;\n    g[3]=min(e,min(f,min(c,d)));\n\n    CLR(ans);\n    ans[0]=1;\n    for(i=x+1;i<n;i++)\n    {\n#define F(j,k) if ( !((j>>k)&1) && val[i]==g[k] ) ans[j|(1<<k)]+=sym[k]*ans[j]\n        if(i==y)continue;\n        F(14,0); F(14,1); F(14,2); F(14,3);\n        F(13,0); F(13,1); F(13,2); F(13,3);\n        F(12,0); F(12,1); F(12,2); F(12,3);\n        F(11,0); F(11,1); F(11,2); F(11,3);\n        F(10,0); F(10,1); F(10,2); F(10,3);\n        F(9,0); F(9,1); F(9,2); F(9,3);\n        F(8,0); F(8,1); F(8,2); F(8,3);\n        F(7,0); F(7,1); F(7,2); F(7,3);\n        F(6,0); F(6,1); F(6,2); F(6,3);\n        F(5,0); F(5,1); F(5,2); F(5,3);\n        F(4,0); F(4,1); F(4,2); F(4,3);\n        F(3,0); F(3,1); F(3,2); F(3,3);\n        F(2,0); F(2,1); F(2,2); F(2,3);\n        F(1,0); F(1,1); F(1,2); F(1,3);\n        F(0,0); F(0,1); F(0,2); F(0,3);\n//        for(j=14;j>=0;j--)\n//        {\n//            for(k=0;k<4;k++)\n//            {\n//                if(j&(1<<k))continue;\n//                if(val[i]==g[k])\n//                    ans[j|(1<<k)] += sym[k]*ans[j];\n//            }\n//        }\n    }\n    return ans[15];\n}\n\nint main()\n{\n    int i,j,k;\n    si(n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<4;j++)\n            si(a[i][j]);\n        val[i] = normalise(a[i]);\n    }\n    ll ans=0LL;\n    for(i=0;i<n;i++)\n        for(j=i+1;j<n;j++)\n            for(k=0;k<4;k++)\n                ans+=way(i,j,k);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\ntypedef tuple<int, int, int, int> T;\nT rotate(T x) {\n\treturn make_tuple(get<1>(x), get<2>(x), get<3>(x), get<0>(x));\n}\nT lex_min(T x) {\n\tT t = x;\n\tfor (int i = 0; i < 3; i++) {\n\t\tx = rotate(x);\n\t\tt = min(t, x);\n\t}\n\treturn t;\n}\nll perm(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = 1;\n\tfor (int i = n; i >= n - k + 1; i--) ret *= i;\n\treturn ret;\n}\nmap<T, int> cnt;\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<T> tile;\n\tfor (int i = 0; i < N; i++) {\n\t\tint C[4];\n\t\tfor (int j = 0; j < 4; j++) cin >> C[j];\n\t\tT x = make_tuple(C[0], C[1], C[2], C[3]);\n\t\tx = lex_min(x);\n\t\ttile.push_back(x);\n\t\tcnt[x]++;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < N; i++) for (int j = 0; j < 4; j++) {\n\t\tT x = tile[i];\n\t\tcnt[x]--;\n\t\tfor (int k = 0; k < j; k++) x = rotate(x);\n\t\tfor (int k = i + 1; k < N; k++) for (int l = 0; l < 4; l++) {\n\t\t\tT y = tile[k];\n\t\t\tcnt[y]--;\n\t\t\tfor (int m = 0; m < l; m++) y = rotate(y);\n\t\t\tmap<T, int> sel;\n\t\t\tT z = make_tuple(get<0>(x), get<3>(x), get<0>(y), get<3>(y));\n\t\t\tz = lex_min(z);\n\t\t\tsel[z]++;\n\t\t\tz = make_tuple(get<3>(x), get<2>(x), get<1>(y), get<0>(y));\n\t\t\tz = lex_min(z);\n\t\t\tsel[z]++;\n\t\t\tz = make_tuple(get<2>(x), get<1>(x), get<2>(y), get<1>(y));\n\t\t\tz = lex_min(z);\n\t\t\tsel[z]++;\n\t\t\tz = make_tuple(get<1>(x), get<0>(x), get<3>(y), get<2>(y));\n\t\t\tz = lex_min(z);\n\t\t\tsel[z]++;\n\t\t\tll tmp = 1;\n\t\t\tfor (auto p : sel) {\n\t\t\t\ttmp *= perm(cnt[p.first], p.second);\n\t\t\t\tT t = p.first;\n\t\t\t\tint n = 1;\n\t\t\t\tfor (int m = 0; m < 3; m++) {\n\t\t\t\t\tt = rotate(t);\n\t\t\t\t\tif (t == p.first) n++;\n\t\t\t\t}\n\t\t\t\tfor (int m = 0; m < p.second; m++) tmp *= n;\n\t\t\t}\n\t\t\tans += tmp;\n\t\t\ty = lex_min(y);\n\t\t\tcnt[y]++;\n\t\t}\n\t\tx = lex_min(x);\n\t\tcnt[x]++;\n\t}\n\tcout << ans / 12 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<deque<Int>, Int> cnt;\n  using face = deque<Int>;\n  \n  auto add=[&](face v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v.emplace_back(Int(v.front()));\n      v.pop_front();\n    }\n  };\n  \n  \n  for(Int i=0;i<n;i++){\n    face v(4);\n    for(Int j=0;j<4;j++) cin>>v[j];\n    add(v,1);\n  }\n  \n  vector<face> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = deque<Int>;\n  auto right=[&](const sq &v){\n    vector<Int> ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    vector<Int> ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    vector<Int> ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  set<sq> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(b);\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=b[i][k];\n      for(Int k=0;k<4;k++) a[k+4]=b[j][k];\n      if(used.count(a)) continue;\n      \n      face w({a[2],a[1],a[4],a[7]});\n      face x({a[0],a[3],a[6],a[5]});\n      face y({a[3],a[2],a[7],a[6]});\n      face z({a[1],a[0],a[5],a[4]});\n      \n      continue;\n\n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {}, e[16][4] = {};\n  \tfor (int i = 0; i < 16; i++) for (int j = 0; j < 4; j++) if (i & (1 << j)) e[i][j] = 1;\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                int c[4] = {}, b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}};\n              \tint d[16] = {1};\n                for (int l = i + 1; l <= n; l++) {\n                  \tfor (int m = 0; m < 4; m++) {\n                      \tc[m] = 0;\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[m]++;\n                    }\n                  \tif (l == j) continue;\n                    d[15] += c[0] * d[14];\n                    d[15] += c[1] * d[13];\n                    d[15] += c[2] * d[11];\n                    d[15] += c[3] * d[7];\n                    d[14] += c[1] * d[12];\n                    d[14] += c[2] * d[10];\n                    d[14] += c[3] * d[6];\n                    d[13] += c[0] * d[12];\n                    d[13] += c[2] * d[9];\n                    d[13] += c[3] * d[5];\n                    d[12] += c[2] * d[8];\n                    d[12] += c[3] * d[4];\n                    d[11] += c[0] * d[10];\n                    d[11] += c[1] * d[9];\n                    d[11] += c[3] * d[3];\n                    d[10] += c[1] * d[8];\n                    d[10] += c[3] * d[2];\n                    d[9] += c[0] * d[8];\n                    d[9] += c[3] * d[1];\n                    d[8] += c[3] * d[0];\n                    d[7] += c[0] * d[6];\n                    d[7] += c[1] * d[5];\n                    d[7] += c[2] * d[3];\n                    d[6] += c[1] * d[4];\n                    d[6] += c[2] * d[2];\n                    d[5] += c[0] * d[4];\n                    d[5] += c[2] * d[1];\n                    d[4] += c[2] * d[0];\n                    d[3] += c[0] * d[2];\n                    d[3] += c[1] * d[1];\n                    d[2] += c[1] * d[0];\n                    d[1] += c[0] * d[0];\n                }\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,a[405][4];\nmap<ll,int> cnt;\n\ninline ll make(int *a){\n\tll ans=1ll<<60;\n\tfor(int i=0;i<4;i++){\n\t\tll res=0;\n\t\tfor(int j=0;j<4;j++)\n\t\t\tres=res*1000+a[(i+j)%4];\n\t\tgmin(ans,res);\n\t}\n\treturn ans;\n}\ninline ll make(int a,int b,int c,int d){\n\tstatic int x[10];\n\tx[0]=a;x[1]=b;x[2]=c;x[3]=d;\n\treturn make(x);\n}\ninline int calc(int *a){\n\tll ans=make(a),cnt=0;\n\tfor(int i=0;i<4;i++){\n\t\tll res=0;\n\t\tfor(int j=0;j<4;j++)\n\t\t\tres=res*1000+a[(i+j)%4];\n\t\tif(res==ans) cnt++;\n\t}\n\treturn cnt;\n}\ninline int calc(int a,int b,int c,int d){\n\tstatic int x[10];\n\tx[0]=a;x[1]=b;x[2]=c;x[3]=d;\n\treturn calc(x);\n}\n\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tread(a[i][j]);\n\t\tcnt[make(a[i])]++;\n//\t\tdebug(make(a[i]));\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tcnt[make(a[i])]--;cnt[make(a[j])]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tstatic ll b[10],res;\n\t\t\t\tres=1;\n\t\t\t\tfor(int c=0;c<4;c++){\n\t\t\t\t\tb[c]=make(a[i][(c+1)&3],a[i][c],a[j][(k-c)&3],a[j][(k-c-1)&3]);\n\t\t\t\t\tres*=calc(a[i][(c+1)&3],a[i][c],a[j][(k-c)&3],a[j][(k-c-1)&3]);\n\t\t\t\t}\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tres=res*cnt[b[c]],cnt[b[c]]--;\n\t\t\t\tans+=res;\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tcnt[b[c]]++;\n\t\t\t}\n\t\t\tcnt[make(a[i])]++;cnt[make(a[j])]++;\n\t\t}\n\t}\n\tprint(ans/6);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nstruct kek{\n    short v[4];\n}a[404];\nbool operator<(const kek&x,const kek&y){\n    forn(i,4){\n        if(x.v[i]<y.v[i])return 1;\n        if(x.v[i]>y.v[i])return 0;\n    }\n    return 0;\n}\nbool operator==(const kek&x,const kek&y){\n    forn(i,4){\n        if(x.v[i]!=y.v[i])return 0;\n    }\n    return 1;\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    map<kek,int> cnt;\n    forn(i,n){\n        forn(j,4)cin>>a[i].v[j];\n        kek mn;\n        forn(q,4)mn.v[q]=a[i].v[q];\n        forn(it,4){\n            if(a[i]<mn)forn(q,4)mn.v[q]=a[i].v[q];\n            rotate(a[i].v,a[i].v+1,a[i].v+4);\n        }\n        forn(it,4){\n            if(mn==a[i])cnt[mn]++;\n            rotate(a[i].v,a[i].v+1,a[i].v+4);\n        }\n        forn(q,4)a[i].v[q]=mn.v[q];        \n    }\n    int ans=0;\n    forn(i,n){\n        forn(j,n){\n            if(i==j)continue;\n            short dal[4];\n            forn(x,4)dal[x]=a[j].v[x];\n            forn(rotzad,4){\n                map<kek,pii> g;\n                forn(side,4){\n                    kek need;\n                    need.v[0]=a[i].v[side];\n                    need.v[1]=dal[(4-side)&3];\n                    need.v[2]=dal[(4-((side+1)&3))&3];\n                    need.v[3]=a[i].v[(side+1)&3];\n                    kek mn;\n                    forn(q,4)mn.v[q]=need.v[q];\n                    forn(tmp,4){\n                        if(need<mn)forn(q,4)mn.v[q]=need.v[q];\n                        rotate(need.v,need.v+1,need.v+4);\n                    }\n                    int val=cnt[mn];\n                    forn(tmp,4){\n                        val-=a[i]==mn;\n                        val-=a[j]==mn;\n                        rotate(mn.v,mn.v+1,mn.v+4);\n                    }\n                    g[mn].f++;\n                    g[mn].s=val;\n                }\n                int cur=1;\n                for(auto&p:g){\n                    kek kok;\n                    forn(q,4)kok.v[q]=p.f.v[q];\n                    int r=0;\n                    forn(q,4){\n                        if(kok==p.f)r++;\n                        rotate(kok.v,kok.v+1,kok.v+4);\n                    }\n                    forn(q,p.s.f)cur*=p.s.s-q*r;\n                }\n                ans+=cur;\n                rotate(dal,dal+1,dal+4);\n            }\n        }\n    }\n    cout<<ans/6<<'\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=4e5;\nint n;\nint c[maxn][4];\nll val[maxn],ans;\nvoid rot(int *c){\n\tper(i,3,1)swap(c[i],c[(i+1)%4]);\n}\nll getv(int *c){\n\tll res=0;\n\trep(i,0,3)res=1000*res+c[i];\n\treturn res;\n}\nll get(int *c){\n\tll res=getv(c);\n\trot(c);res=min(res,getv(c));\n\trot(c);res=min(res,getv(c));\n\trot(c);res=min(res,getv(c));\n\treturn res;\n}\nint main(){\n\tread(n);\n\trep(i,1,n)rep(j,0,3)read(c[i][j]);\n\trep(i,1,n)val[i]=get(c[i]);\n\trep(i,1,n)rep(j,i+1,n){\n\t\trep(k,0,3){\n\t\t\tll res=1;\n\t\t\trot(c[j]);\n\t\t\tint v[4];\n\t\t\trep(l,0,3){\n\t\t\t\tint now[4];\n\t\t\t\tnow[0]=c[j][(5-l)%4];\n\t\t\t\tnow[1]=c[j][(4-l)%4];\n\t\t\t\tnow[2]=c[i][(l+1)%4];\n\t\t\t\tnow[3]=c[i][l];\n\t\t\t\tv[l]=get(now);\n\t\t\t\tint t=0,cnt=0;\n\t\t\t\tt+=(getv(now)==v[l]);\n\t\t\t\trot(now);t+=(getv(now)==v[l]);\n\t\t\t\trot(now);t+=(getv(now)==v[l]);\n\t\t\t\trot(now);t+=(getv(now)==v[l]);\n\t\t\t\trep(p,i+1,n)if(p!=j&&val[p]==v[l])cnt++;\n\t\t\t\trep(ll,0,l-1)if(v[ll]==v[l])cnt--;\n\t\t\t\tif(cnt<=0){\n\t\t\t\t\tres=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres*=t*cnt;\n\t\t\t}\n\n\t\t\tans+=res;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define whole(f,x,...) ([&](decltype((x)) y) { return (f)(begin(y), end(y), ## __VA_ARGS__); })(x)\ntypedef long long ll;\nusing namespace std;\ntemplate <class T> void setmax(T & a, T const & b) { if (a < b) a = b; }\ntemplate <class T> void setmin(T & a, T const & b) { if (b < a) a = b; }\ntemplate <typename T, typename X> auto vectors(T a, X x) { return vector<T>(x, a); }\ntemplate <typename T, typename X, typename Y, typename... Zs> auto vectors(T a, X x, Y y, Zs... zs) { auto cont = vectors(a, y, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> T input(istream & in) { T a; in >> a; return a; }\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nbool is_on_field(int y, int x, int h, int w) { return 0 <= y and y < h and 0 <= x and x < w; }\ntypedef uint16_t color_t;\narray<color_t,4> rotate(array<color_t,4> c, int r) {\n    rotate(c.begin(), c.begin() + r, c.end());\n    return c;\n}\nvoid normalize(array<color_t,4> & c) {\n    array<color_t,4> d = c;\n    repeat (r,4) setmin(c, rotate(d, r));\n}\nint multiplicity(array<color_t,4> const & c) {\n    int n = 0;\n    repeat (r,4) if (c == rotate(c, r)) n += 1;\n    return n;\n}\nint main() {\n    int n; cin >> n;\n    vector<array<color_t,4> > c(n);\n    repeat (i,n) repeat (j,4) cin >> c[i][j];\n    repeat (i,n) normalize(c[i]);\n    map<array<color_t,4>,int> cnt; repeat (i,n) cnt[c[i]] += 1;\n    map<array<color_t,4>,int> mul; for (auto it : cnt) mul[it.first] = multiplicity(it.first);\n    ll ans = 0;\n    repeat (bi,n) repeat (ai,bi) { // div 2\n        cnt[c[ai]] -= 1;\n        cnt[c[bi]] -= 1;\n        repeat (br,4) { // div 4\n            //    b0 -- b3\n            //   /     / |\n            // a0 -- a1  |\n            //  | _1  | b2\n            //  |     | /\n            // a3 -- a2\n            array<color_t,4> const & a = c[ai];\n            array<color_t,4> b = rotate(c[bi], br);\n            array<array<color_t,4>,4> ds;\n            ds[0] = { b[0], b[3], a[1], a[0] };\n            ds[1] = { b[3], b[2], a[2], a[1] };\n            ds[2] = { b[2], b[1], a[3], a[2] };\n            ds[3] = { b[1], b[0], a[0], a[3] };\n            ll acc = 1;\n            map<array<color_t,4>,int> used;\n            for (auto & d : ds) {\n                normalize(d);\n                if (not cnt.count(d)) { acc = 0; break; }\n                used[d] += 1;\n                acc *= mul[d] * (cnt[d] - used[d] + 1);\n            }\n            ans += acc;\n        }\n        cnt[c[ai]] += 1;\n        cnt[c[bi]] += 1;\n    }\n    assert (ans % 3 == 0);\n    ans /= 3;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n\n  vector<sq> ord(24,sq(8));\n  {\n    sq a(8);\n    iota(a.begin(),a.end(),0);\n    Int x=0;\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tfor(Int k=0;k<8;k++) ord[x][a[k]]=k;\n\ta=clock(a);\n\tx++;\n      }\n      if(i==0||i==4) a=right(a);\n      else a=front(a);\n    }\n  }\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(8);\n    for(Int i=0;i<24;i++){\n      for(Int k=0;k<8;k++) b[ord[i][k]]=a[k];\n      res+=(a==b);\n      used.emplace(conv(b));\n    }\n    //cout<<res<<endl;\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      if(cnt[w]==0||cnt[x]==0||cnt[y]==0||cnt[z]==0) continue;\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n\n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nint n;\nlong long bin[5],ans;\nint a[405][4],A[4],B[4];\nmap<long long,int>mp;\nlong long gao(int aa,int bb)\n{\n\tlong long qwq=0;\n\tfor(long long j=0;j<4;++j) qwq+=bin[j]*a[aa][(bb+j)%4];\n\treturn qwq;\n}\nint md(int aa,int bb,int cc)\n{\n\ta[n+1][0]=A[aa];a[n+1][1]=B[aa];\n\ta[n+1][2]=B[bb];a[n+1][3]=A[bb];\n\tint tmp=mp[gao(n+1,0)];\n\tfor(int i=0;i<4;++i) mp[gao(n+1,i)]-=cc;\n\treturn tmp;\n}\nvoid getans()\n{\n\tans+=md(0,1,1)*md(1,2,1)*md(2,3,1)*md(3,0,1);\n\tmd(0,1,-1);md(1,2,-1);md(2,3,-1);md(3,0,-1);\n\treturn;\n}\nint main()\n{\n\tn=read();bin[0]=1;\n\tfor(int i=1;i<4;++i) bin[i]=bin[i-1]*1000;\n\tfor(int i=1;i<=n;++i) \n\t{\n\t\tfor(int j=0;j<4;++j) a[i][j]=read();\n\t\tfor(int j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<4;++j) mp[gao(i,j)]--,A[j]=a[i][j];\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tfor(int l=0;l<4;++l) mp[gao(j,l)]--;\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(int l=0;l<4;++l)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<4;++k) B[k]=a[j][(k+l)%4];\n\t\t\t\tgetans();\n\t\t\t}\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(int l=0;l<4;++l) mp[gao(j,l)]++;\n\t\t}\n\t\tfor(int j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\twrite(ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nvoid rotate(vector<int> &o) {\n\tint temp = o.front();\n\tfor(int i=0; i<3; i++) o[i] = o[i+1]; o.back() = temp;\n}\n\nconst int MAX_N = 4e2 + 10;\n\nint N; \nvector<int> Nr[MAX_N];\nmap<vector<int>, int> Cnt;\n\nint main() {\n\tcin >> N;\n\tfor(int i=0; i<N; i++) {\n\t\tfor(int k=0, x; k<4; k++) scanf(\"%d\", &x), Nr[i].push_back(x);\n\t\tfor(int k=0; k<4; k++) Cnt[Nr[i]]++, rotate(Nr[i]);\n\t}\n\t\n\tvector<int> cube(8, 0);\n\tvector<vector<int>> faceIx({vector<int>({5, 4, 1, 0}), vector<int>({4, 7, 2, 1}), vector<int>({7, 6, 3, 2}), vector<int>({6, 5, 0, 3})});\n\tll ans = 0;\n\tfor(int l=0; l<N; l++) {\n\t\tfor(int k=0; k<4; k++) cube[k] = Nr[l][k];\n\t\tfor(int k=0; k<4; k++) Cnt[Nr[l]]--, rotate(Nr[l]);\n\t\tfor(int r=l+1; r<N; r++) {\n\t\t\tfor(int k=0; k<4; k++) Cnt[Nr[r]]--, rotate(Nr[r]);\n\t\t\tfor(int rt=0; rt<4; rt++) {\n\t\t\t\tfor(int k=0; k<4; k++) cube[4+k] = Nr[r][(k+rt)%4];\n\t\t\t\tll now = 1;\n\t\t\t\tvector<vector<int>> faces;\n\t\t\t\tfor(int f=0; f<4; f++) {\n\t\t\t\t\tvector<int> face(4, 0);\n\t\t\t\t\tfor(int k=0; k<4; k++) face[k] = cube[faceIx[f][k]];\n\t\t\t\t\tif((now *= Cnt[face]) == 0) break;\n\t\t\t\t\tfaces.push_back(face);\n\t\t\t\t\tfor(int k=0; k<4; k++) Cnt[face]--, rotate(face);\n\t\t\t\t}\n\t\t\t\tans += now;\n\t\t\t\tfor(int f=0; f<SZ(faces); f++) for(int k=0; k<4; k++) Cnt[faces[f]]++, rotate(faces[f]);\n\t\t\t}\n\t\t\tfor(int k=0; k<4; k++) Cnt[Nr[r]]++, rotate(Nr[r]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {};\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n          \tmap<pair<pii, pii>, ll> p;\n            for (int k = 0; k < 4; k++) {\n                if (p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}]) {\n                    z += p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}];\n                    continue;\n                }\n                int b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}}, c[404][4] = {}, d[16] = {};\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 0; m < 4; m++) {\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[l][m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[l][m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[l][m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[l][m]++;\n                    }\n                }\n                d[0] = 1;\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 15; m >= 0; m--) {\n                        if (l != j) {\n                            for (int o = 0; o < 4; o++) if (m & (1 << o)) d[m] += c[l][o] * d[m - (1 << o)];\n                        }\n                    }\n                }\n                p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}] = d[15];\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nunordered_map<long long, long long> cnt;\nlong long encoder(vector<long long> A) {\n\tlong long ans = 0;\n\tlong long cnt = 1;\n\tfor (int i = 0; i < A.size(); ++i) {\n\t\tans += A[i] * cnt;\n\t\tcnt *= 1000;\n\t}\n\treturn ans;\n}\nvoid ited(vector<long long> A,int pivot) {\n\tfor (int i = 0; i < A.size(); ++i) {\n\t\tfor (int q = 1; q < 4; ++q) {\n\t\t\tswap(A[q - 1], A[q]);\n\t\t}\n\t\tcnt[encoder(A)] += pivot;\n\t}\n\treturn;\n}\nint main() {\n#define int long long\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> inputs;\n\tREP(i, n) {\n\t\tvector<int> A;\n\t\tREP(q, 4) {\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tA.push_back(b);\n\t\t}\n\t\tvector<vector<int>> B;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tB.push_back(A);\n\t\t\tfor (int q = 1; q < 4; ++q) {\n\t\t\t\tswap(A[q - 1], A[q]);\n\t\t\t}\n\t\t}\n\t\tsort(B.begin(), B.end());\n\t\tinputs.push_back(B[0]);\n\t\tited(B[0], 1);\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\t//Bottom\n\t\tited(inputs[i], -1);\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\t//Top\n\t\t\tited(inputs[q], -1);\n\t\t\tswap(inputs[q][0], inputs[q][1]);\n\t\t\tswap(inputs[q][2], inputs[q][3]);\n\t\t\tREP(j, 4) {\n\t\t\t\tfor (int t = 1; t < 4; ++t) {\n\t\t\t\t\tswap(inputs[q][t-1], inputs[q][t]);\n\t\t\t\t}\n\t\t\t\t//direction,now we're ready to solve\n\t\t\t\tvector<vector<long long>> A;\n\t\t\t\tREP(b, 4) {\n\t\t\t\t\tvector<long long> B;\n\t\t\t\t\tB.push_back(inputs[q][b]);\n\t\t\t\t\tB.push_back(inputs[q][(b + 1) % 4]);\n\t\t\t\t\tB.push_back(inputs[i][(b + 1) % 4]);\n\t\t\t\t\tB.push_back(inputs[i][b]);\n\t\t\t\t\tA.push_back(B);\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (int i = 0; i < A.size(); ++i) {\n\t\t\t\t\ttmp *= cnt[encoder(A[i])];\n\t\t\t\t\tited(A[i], -1);\n\t\t\t\t}\n\t\t\t\tans += tmp;\n\t\t\t\tfor (int i = 0; i < A.size(); ++i) {\n\t\t\t\t\tited(A[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(inputs[q][0], inputs[q][1]);\n\t\t\tswap(inputs[q][2], inputs[q][3]);\n\t\t\tited(inputs[q], 1);\n\t\t}\n\t\tited(inputs[i], 1);\n\t}\n\tcout << ans/3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include <utility>\n#include <cstdio>\n#include<algorithm>\n#include<queue>\n#define ll  long long\n\nusing namespace std;\n\tint n;\nvoid rotate(vector<int> & vec){\n    vector<int> tmp(4);\n    int minind = min_element(vec.begin(), vec.end() ) - vec.begin();\n    for(int i=3; i>0; i--){\n\tif(vec[i]==vec[minind]){\n\t    minind=i;\n\t}else{\n\t    break;\n\t}\n    }\n    for(int i=0; i<4; i++){\n\ttmp[i] = vec[(i+minind)%4];\n    }\n    vec=tmp;\n}\nvoid rot1(vector<int> & vec){\n    int tmp = vec[0];\n    for(int i=0; i<4; i++){\n\tvec[i] = vec[i+1];\n    }\n    vec[3]=tmp;\n}\nint cntsq(vector<vector<int> > & c, vector<int>  & sq, int st, int sk){\n    int res=0;\n    for(int i=st; i<n; i++)\n\tif(i!=sk && c[i]==sq)res++;\n    return res;\n}\nint sym(vector<int> v){\n    if(v[0]!=v[2] || v[1]!=v[3])return 1;\n    if(v[0]!=v[1] || v[2]!=v[3])return 2;\n    return 4;\n}\nint main(){\n    cin>>n;\n    vector<vector<int> > c(n, vector<int>(4));\n    for(int i=0; i<n; i++){\n\tfor(int j=0; j<4; j++ )cin>>c[i][j];\n\trotate(c[i]);\n    }\n    double res = 0;\n    for(int f = 0; f<n; f++){\n\tfor(int s=f+1; s<n; s++){\n\t    for(int r=0; r<4; r++){\n\t\tunsigned ll mu=1;\n\t\tmap<vector<int>, int> occ; occ.clear();\n\t\tfor(int i=0; i<4; i++){\n\t\t    vector<int> tmp(4);\n\t\t    tmp[1] = c[f][i]; tmp[0] = c[f][(i+1)%4];\n\t\t    tmp[3] = c[s][3-(i+1)%4]; tmp[2] = c[s][3-i];\n\t\t    rotate(tmp);\n\t\t    int x = cntsq(c, tmp, f+1, s);\n\t\t    if(x)\n\t\t\tmu*=1LL*(x-occ[tmp])*sym(tmp);\n\t\t    else {mu=0; break; }\n//cout<<f<<\" \"<<s<<\" \"<<r<<\" \"<<i<<\" \"<<cntsq(c, tmp, f+1, s)<<\" \"<<mu<<\"\\n\";\n//cout<<tmp[0]<<tmp[1]<<tmp[2]<<tmp[3]<<\"\\n\";\n\t\t    occ[tmp]++;\n\t\t}\n\t\tres+=mu;\n\t\trot1(c[s]);\n//\t\tcout<<c[s][0]<<c[s][1]<<c[s][2]<<c[s][3]<<\"\\n\";\n\t    }\n\t}\n    }\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n \ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nint n;\nvector<int> c[400];\nll chash[400];\nint dup[400]; // 重複回数\n\ninline ll get_hash(vector<int> v) {\n\tll res = INF;\n\tREP(i, 4) {\n\t\tchmin(res, v[0] * 1000000000ll + v[1] * 1000000ll + v[2] * 1000ll + v[3]);\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tc[i].resize(4);\n\t\tREP(j, 4) scanf(\"%d\", &c[i][j]);\n\t\t\n\t\tif (c[i][0] == c[i][2] && c[i][1] == c[i][3]) {\n\t\t\tif (c[i][0] == c[i][1]) dup[i] = 4;\n\t\t\telse dup[i] = 2;\n\t\t}\n\t\telse dup[i] = 1;\n\t\t\n\t\tchash[i] = get_hash(c[i]);\n\t}\n\t\n\tmap<ll,  int> pat[5]; // 各タイルを正規化したもののそれぞれの個数\n\tREP(i, n) pat[ dup[i] ][ chash[i] ]++;\n\t\n\tll ans = 0;\n\t\n\tREP(i, n) REP(j, n) {\n\t\tif (i == j) continue;\n\t\t\n\t\tREP(p1, 4) REP(p2, 4) {\n\t\t\t\n\t\t\tvector<int> v(8); // 各頂点の色\n\t\t\tREP(k, 4) v[k] = c[i][(k + p1) % 4];\n\t\t\tREP(k, 4) v[k + 4] = c[j][(k + p2) % 4];\n\t\t\t\n\t\t\tint dd[4][4] = { {1,0,7,6}, {0,3,4,7}, {2,1,6,5}, {3,2,5,4} };\n\t\t\t\n\t\t\tmap<ll, int> now; // 各方向から見た色の配置\n\t\t\tREP(k, 4) {\n\t\t\t\tvector<int> u(4);\n\t\t\t\tREP(l, 4) u[l] = v[dd[k][l]];\n\t\t\t\tnow[get_hash(u)]++;\n\t\t\t}\n\t\t\t\n\t\t\tll add = 1;\n\t\t\t\n\t\t\tfor (map<ll, int>::iterator it = now.begin(); it != now.end(); ++it) {\n\t\t\t\tbool ng = true;\n\t\t\t\t\n\t\t\t\tREP(k, 5) {\n\t\t\t\t\tll cnt = pat[k][it->first];\n\t\t\t\t\t\n\t\t\t\t\tif (dup[i] == k && chash[i] == it->first) cnt--;\n\t\t\t\t\tif (dup[j] == k && chash[j] == it->first) cnt--;\n\t\t\t\t\t\n\t\t\t\t\tif (cnt < it->second) continue;\n\t\t\t\t\t\n\t\t\t\t\tng = false;\n\t\t\t\t\t\n\t\t\t\t\tREP(l, it->second) {\n\t\t\t\t\t\tadd *= (cnt - l) * k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ng) add = 0;\n\t\t\t}\n\t\t\t\n\t\t\tans += add;\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\tcout << ans / 24<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define Node(a,b,c,d) make_pair(a,make_pair(b,make_pair(c,d)))\n#define T pair<int,pair<int,pair<int,int> > >\n\ntypedef long long LL;\nmap<T,LL> cnt;\nconst int maxn = 500;\n\nint A[maxn][4];\nint n;\n\nT stand(T t)\n{\n    int num[4];\n    num[0] = t.first;\n    num[1] = t.second.first;\n    num[2] = t.second.second.first;\n    num[3] = t.second.second.second;\n\n    T tmp[4];\n\n\n    for(int s = 0;s < 4;++s)\n    {\n        tmp[s] = Node(num[(s+0)%4],num[(s+1)%4],num[(s+2)%4],num[(s+3)%4]);\n    }\n    sort(tmp,tmp+4);\n    return tmp[0];\n\n}\n\nvoid update(int id,int val)\n{\n//    int num[4];\n//    for(int s = 0;s < 4;++s)\n//    {\n//        for(int j = 0;j < 4;++j)\n//            num[j] = A[id][(s+j)%4];\n//        cnt[Node(num[0],num[1],num[2],num[3])] +=val;\n//    }\n    T now = stand(Node(A[id][0],A[id][1],A[id][2],A[id][3]));\n    cnt[now] += val;\n}\n\nint main()\n{\n    freopen(\"./test.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    cnt.clear();\n    for(int i = 1;i <= n;++i)\n    {\n        for(int j = 0;j < 4;++j)\n            scanf(\"%d\",&A[i][j]);\n        update(i,1);\n    }\n\n    LL res = 0;\n    for(int i = 1;i <= n;++i)\n    {\n        update(i,-1);\n\n        for(int j = 1;j <= n;++j)\n            if(i != j)\n            {\n                update(j,-1);\n\n\n                int Down[4];\n                for(int ds = 0;ds < 1;++ds)\n                {\n                    for(int x = 0;x < 4;++x)\n                        Down[x] = A[i][(ds+x)%4];\n\n                    int Up[4];\n                    for(int us = 0;us < 4;++us)\n                    {\n                        for(int y = 0;y < 4;++y)\n                            Up[y] = A[j][(us-y+4)%4];\n\n                        LL now = 1;\n\n                        T X[4];\n\n                        for(int k = 0;k < 4;++k)\n                        {\n                            X[k] = stand(Node(Down[k],Up[k],Up[(k+1)%4],Down[(k+1)%4]));\n                            int c = 0;\n//                            for(int w = 0;w < k;++w)\n//                                if(X[k] == X[w]) c++;\n                            now *= (cnt[X[k]]-c);\n\n                        }\n\n                        res += now;\n\n                       // printf(\"**** %d  %d\\n\",i,j);\n//                        for(int k = 0;k < 4;++k)\n//                            printf(\"%d%c\",Down[k],\" \\n\"[k == 3]);\n//\n//                        for(int k = 0;k < 4;++k)\n//                            printf(\"%d%c\",Up[k],\" \\n\"[k == 3]);\n//\n//                        puts(\"\");\n                    }\n\n                }\n\n\n\n                update(j,1);\n            }\n\n        update(i,1);\n    }\n\n    printf(\"%lld\\n\",res);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return calc(a[0],a[1],a[2],a[3])|(a[4]<<40)|(a[5]<<50);\n  };\n\n  vector<set<Int> > used(1<<20);\n\n  map<sq, Int> dp;\n  auto dup2=[&](const sq &a)->Int{\n    if(dp.count(a)) return dp[a];\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused[(b[7]<<10)|b[6]].emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return dp[a]=res;\n  };\n  \n  auto dup=[&](const sq &a)->Int{\n    sq b(8);\n    map<Int, Int> m;\n    Int sz=0;\n    for(Int i=0;i<8;i++){\n      if(!m.count(a[i])) m[a[i]]=sz++;\n      b[i]=m[a[i]];\n    }\n    return dup2(b);\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used[(a[7]<<10)|a[6]].count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n\n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);     \n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nstruct face{\n\tint a,b,c,d,orien;\n\tface(){}\n\tface(int aa, int bb, int cc, int dd){\n\t\ta=aa, b=bb, c=cc, d=dd;\n\t\torien = 1;\n\t\tif(a==c and b==d) orien = 2;\n\t\tif(a==b and b==c and c==d and d==a) orien = 4;\n\t}\n\tvoid rotate(){\n\t\tint t=a;\n\t\ta=b,b=c,c=d,d=t;\n\t}\n\tbool operator<(face f) const{\n\t\treturn make_tuple(a,b,c,d) < make_tuple(f.a,f.b,f.c,f.d);\n\t}\n\tbool operator==(face f) const{\n\t\treturn make_tuple(a,b,c,d) == make_tuple(f.a,f.b,f.c,f.d);\n\t}\n\tface arrange(){\n\t\tface best = face(a,b,c,d);\n\t\tface cur = face(a,b,c,d);\n\t\tfor(int i=0; i<4; ++i){\n\t\t\tcur.rotate();\n\t\t\tif(cur < best) best = cur;\n\t\t}\n\t\treturn best;\n\t}\n\tvoid print(){\n//\t\tprintf(\"(%d %d %d %d)\\n\",a,b,c,d);\n\t}\n};\nint n;\nface A[500];\nmap<face, int> cnt;\nint32_t main(){\n\tcin >> n;\n\tfor(int i=0; i<n; ++i){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tA[i] = face(a,b,c,d).arrange();\n\t\tif(cnt.find(A[i]) == cnt.end()) cnt[A[i]]=1;\n\t\telse cnt[A[i]]++;\n\t}\n\tsort(A, A+n);\n\tfor(int i=0; i<n; ++i){\n\t\tA[i].print();\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<n; ++i){\n\t\tfor(int j=i+1; j<n; ++j){\n\t\t\tface t=A[i], b=A[j];\n\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\tface q = face(t.b,b.a,b.d,t.c).arrange();\n\t\t\t\tface w = face(t.a,b.b,b.a,t.b).arrange();\n\t\t\t\tface e = face(b.b,t.a,t.d,b.c).arrange();\n\t\t\t\tface r = face(t.c,b.d,b.c,t.d).arrange();\n\t\t\t\tvector<face> four; \n\t\t\t\tfour.push_back(q);\n\t\t\t\tfour.push_back(w);\n\t\t\t\tfour.push_back(e);\n\t\t\t\tfour.push_back(r);\n\n\t\t\t\ttypedef pair<face,int> pf;\n\t\t\t\tvector<pf> v;\n\t\t\t\tfor(auto l : four){\n\t\t\t\t\tbool newone = true;\n\t\t\t\t\tfor(auto it = v.begin(); it!=v.end(); ++it){\n\t\t\t\t\t\tif(it->first == l){ it->second++; newone = false; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif(newone) v.push_back(pf(l,1));\n\t\t\t\t}\n\t\t\t\tint add = 1;\n\t\t\t\tfor(auto m : v){\n\t\t\t\t\tint c = cnt[m.first];\n\t\t\t\t\tif(m.first == t) c--;\n\t\t\t\t\tif(m.first == b.arrange()) c--;\n//\t\t\t\t\tm.first.print(); printf(\"x%d, %d\\n\", c, m.second);\n\t\t\t\t\tassert(c>=0);\n\t\t\t\t\twhile(m.second--){\n\t\t\t\t\t\tadd *= c--; \n\t\t\t\t\t\tadd *= m.first.orien;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += add;\n//\t\t\t\tprintf(\" === %d %d: +%d\\n\", i, j, add);\n\t\t\t\tb.rotate();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans/3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nll rot(ll c, int r){\n    ll p[4];\n    FORR(i,3,0){\n        p[i] = c % 1000;\n        c /= 1000;\n    }\n    ll ret = 0;\n    REP(i,4){\n        ret = 1000 * ret + p[(i+r)%4];\n    }\n    return ret;\n}\n\nll col(ll c, int x){\n    REP(i,3-x) c /= 1000;\n    return c % 1000;\n}\n\nll make(ll a, ll b, ll c, ll d){\n    return 1000000000LL * a + 1000000 * b + 1000 * c + d;\n}\n\nll calc(VVL c){\n    int n = c.size();\n    VVL dp(n+1, VL(16));\n    dp[0][0] = 1;\n    REP(i,n) REP(mask,16){\n        dp[i+1][mask] += dp[i][mask];\n        REP(j,4){\n            if ((mask >> j) & 1) continue;\n            dp[i+1][mask | (1 << j)] += dp[i][mask] * c[i][j];\n        }\n    }\n\n    // REP(i,n){\n    //     REP(j,4) cout << c[i][j] << \" \";\n    //     cout<< endl;\n    // }\n\n    // REP(i,n+1){\n    //     REP(j,16) cout << dp[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n\n    return dp[n][15];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    VL c(n);\n    REP(i,n){\n        REP(j,4){\n            ll x;\n            cin >> x;\n            c[i] = 1000 * c[i] + x;\n        }\n    }\n\n    ll ans = 0;\n    REP(i,n) REP(j,i) REP(r,4){\n        ll c1 = c[i], c2 = rot(c[j], r);\n        ll cs[4];\n        cs[0] = make(col(c1,1), col(c1,0), col(c2,1), col(c2,0));\n        cs[1] = make(col(c1,2), col(c1,1), col(c2,0), col(c2,3));\n        cs[2] = make(col(c1,3), col(c1,2), col(c2,3), col(c2,2));\n        cs[3] = make(col(c1,0), col(c1,3), col(c2,2), col(c2,1));\n\n        VVL cnt;\n        REP(k,n){\n            if (k == i || k == j) continue;\n            VL tmp(4);\n            bool zero = true;\n            REP(x,4) REP(y,4){\n                if (rot(c[k], y) == cs[x]){\n                    tmp[x]++;\n                    zero = false;\n                }\n            }\n            if (!zero) cnt.push_back(tmp);\n        }\n\n        ans += calc(cnt);\n    }\n    cout << ans / 3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#pragma GCC optimize(\"O3\")\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=404;\n\ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n\ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nint n,a[N][4];\nLL b[N];\n\nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n\n    // 1045, 2156, 3267, 0374\n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    // dump(VI(cc,cc+8));\n    // REP(i,4) dump(vector<LL>(c[i],c[i]+4));\n    LL dp[16]={1};\n    REP1(i,ti+1,n) if ( i!=bi ) {\n        for ( int j=14; j>=0; j-- ) REP(k,4) if ( !bit(j,k) ) {\n            REP(d,4) if ( b[i]==c[k][d] ) dp[j|(1<<k)]+=dp[j];\n        }\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[15];\n}\n\nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    REP1(i,1,n) b[i]=f(a[i][0],a[i][1],a[i][2],a[i][3]);\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    map<C, int> P;\n    map<C, int> R;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        R[x] = rot(x);\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        P[p]--;\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            P[q]--;\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}});\n                    int opts = P[u[l]];\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*rot(u[l]);\n                    }\n                    P[u[l]]--;\n                }\n                for (int l = 0; l < 4; l++) {\n                    P[u[l]]++;\n                }\n                ans += cur;\n            }\n            P[q]++;\n        }\n        P[p]++;\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*░░░░░░░▄▄▄▀▀▀▄▄███▄\n░░░░░▄▀▀░░░░░░░▐░▀██▌\n░░░▄▀░░░░▄▄███░▌▀▀░▀█\n░░▄█░░▄▀▀▒▒▒▒▒▄▐░░░░█▌\n░▐█▀▄▀▄▄▄▄▀▀▀▀▌░░░░░▐█▄\n░▌▄▄▀▀░░░░░░░░▌░░░░▄███████▄\n░░░░░░░░░░░░░▐░░░░▐███████████▄\n░░░░░le░░░░░░░▐░░░░▐█████████████▄\n░░░░toucan░░░░░░▀▄░░░▐██████████████▄\n░░░░░░has░░░░░░░░▀▄▄████████████████▄\n░░░░░arrived░░░░░░░░░░░░█▀██████*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct Side\n{\n\tint a, b, c, d;\n\tSide(){}\n\tSide(int _a, int _b, int _c, int _d)\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t\tc = _c;\n\t\td = _d;\n\t}\n\tpair<pair<int, int>, pair<int, int> > get()\n\t{\n\t\treturn make_pair(make_pair(a, b), make_pair(c, d));\n\t}\n};\nSide shift(Side s)\n{\n\treturn Side(s.b, s.c, s.d, s.a);\n}\nSide makeMin(Side s)\n{\n\tSide res = s;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\ts = shift(s);\n\t\tres = min(res, s);\n\t}\n\treturn res;\n}\nbool operator<(Side x, Side y)\n{\n\treturn x.get() < y.get();\n}\nbool operator==(Side x, Side y)\n{\n\treturn x.get() == y.get();\n}\nconst int MAXN = 407;\nSide s[MAXN];\nmap<Side, int> have;\nint cnt(Side s)\n{\n\tSide ss = s;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (ss == s) res++;\n\t\tss = shift(ss);\n\t}\n\treturn res;\n}\nSide mirror(Side s)\n{\n\treturn Side(s.d, s.c, s.b, s.a);\n}\nint go(Side s)\n{\n\ts = mirror(s);\n\ts = makeMin(s);\n\tint res = have[s];\n\tif (res > 0)\n\t{\n\t\thave[s]--;\n\t}\n\treturn res * cnt(s);\n}\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d %d %d %d\", &s[i].a, &s[i].b, &s[i].c, &s[i].d);\n\t\ts[i] = makeMin(s[i]);\n\t}\n\tll res = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tSide down = s[i];\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tSide up = mirror(s[j]);\n\t\t\tfor (int rot = 0; rot < 4; rot++)\n\t\t\t{\n\t\t\t\tif (i == 1 && j == 5)\n\t\t\t\t{\n\t\t\t\t\tint xxx = 12;\n\t\t\t\t}\n\t\t\t\tmap<Side, int> tmp = have;\n\t\t\t\thave[s[j]]--;\n\t\t\t\tll curRes = 1;\n\t\t\t\tcurRes *= go(Side(down.a, down.b, up.b, up.a));\n\t\t\t\tcurRes *= go(Side(down.b, down.c, up.c, up.b));\n\t\t\t\tcurRes *= go(Side(down.c, down.d, up.d, up.c));\n\t\t\t\tcurRes *= go(Side(down.d, down.a, up.a, up.d));\n\t\t\t\tup = shift(up);\n\t\t\t\thave = tmp;\n\t\t\t\tres += curRes;\n\t\t\t}\n\t\t}\n\t\thave[s[i]]++;\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mod 1000000007\n// #define mod 998244353\nusing namespace std;\n\nmap<vector<int>, int> mymap;\n\nvoid insert(vector<int> &v)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tmymap[v]++;\n\t}\n}\n\nvoid remove(vector<int> &v)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tmymap[v]--;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> c[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tc[i].resize(4);\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tinsert(c[i]);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvector<int> top = c[i];\n\t\tremove(top);\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tvector<int> rev_bot = c[j], bot = c[j];\n\t\t\treverse(bot.begin(), bot.end());\n\t\t\tremove(rev_bot);\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tvector<int> req[4];\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\treq[num].pb(top[num]);\n\t\t\t\t\treq[num].pb(top[(num + 1) % 4]);\n\t\t\t\t\treq[num].pb(bot[(num + 1) % 4]);\n\t\t\t\t\treq[num].pb(bot[num]);\n\t\t\t\t\treverse(req[num].begin(), req[num].end());\n\t\t\t\t}\n\t\t\t\tll temp_ans = 1;\n\t\t\t\tvector<bool> was_removed(4);\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\ttemp_ans *= mymap[req[num]];\n\t\t\t\t\tif (mymap[req[num]] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tremove(req[num]);\n\t\t\t\t\t\twas_removed[num] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\tif (was_removed[num])\n\t\t\t\t\t{\n\t\t\t\t\t\tinsert(req[num]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += temp_ans;\n\t\t\t\trotate(bot.begin(), bot.begin() + 1, bot.end());\n\t\t\t}\n\t\t\tinsert(rev_bot);\n\t\t}\n\t\tinsert(top);\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\ntypedef pair<pii,pii> s4;\nint n,c[555][4]; s4 t[555][4];\nll f[17];\n#define p4(a,b,c,d) make_pair(pii(a,b),pii(c,d))\nint main()\n{\n\tll aa=0; scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<4;++j) scanf(\"%d\",&c[i][j]);\n\tfor(int x=1;x<=n;++x)\n\t\tfor(int i=0;i<4;++i)\n\t\t\tt[x][i]=p4(c[x][i],c[x][(i+3)&3],\n\t\t\tc[x][(i+2)&3],c[x][(i+1)&3]);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\ts4 tar[4];\n\t\t\t\tfor(int p=0;p<4;++p)\n\t\t\t\t\ttar[p]=p4(c[i][p],c[i][(p+1)&3],\n\t\t\t\t\tc[j][(4-p+k)&3],c[j][(4-p+k+1)&3]);\n\t\t\t\tmemset(f,0,sizeof f);\n\t\t\t\tf[0]=1;\n\t\t\t\tfor(int s=1;s<=n;++s)\n\t\t\t\t{\n\t\t\t\t\tif(s==i||s==j) continue;\n\t\t\t\t\tint ma[4];\n\t\t\t\t\tfor(int k=0;k<4;++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[k]=0;\n\t\t\t\t\t\tfor(int g=0;g<4;++g)\n\t\t\t\t\t\t\tif(tar[k]==t[s][g]) ma[k]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int g=14;g>=0;--g)\n\t\t\t\t\t\tfor(int k=0;k<4;++k)\n\t\t\t\t\t\t\tif(!(g&(1<<k)))\n\t\t\t\t\t\t\t\tf[g|(1<<k)]+=f[g]*ma[k];\n\t\t\t\t}\n\t\t\t\taa+=f[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",aa/3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 400 + 5\n#define K 5\n#define base 1000\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, ans, C[N][K];\nunordered_map <int, int> M;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Hash(int a, int b, int c, int d){\n    int ans = 0;\n    ans = ans * base + a, ans = ans * base + b, ans = ans * base + c, ans = ans * base + d;\n    return ans;\n}\nvoid update(int val, int x){\n    int a, b, c, d;\n    d = val % base, val /= base;\n    c = val % base, val /= base;\n    b = val % base, val /= base;\n    a = val % base, val /= base;\n    M[Hash(a, b, c, d)] += x;\n    M[Hash(b, c, d, a)] += x;\n    M[Hash(c, d, a, b)] += x;\n    M[Hash(d, a, b, c)] += x;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n){\n        C[i][0] = read(), C[i][1] = read(), C[i][2] = read(), C[i][3] = read();\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    rep(i, 1, n){\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), -1);\n        rep(j, i + 1, n){\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), -1);\n            rep(k, 0, 3){\n                int AA = Hash(C[i][0], C[i][3], C[j][k], C[j][(3 + k) % 4]);\n                int BB = Hash(C[i][3], C[i][2], C[j][(1 + k) % 4], C[j][k]);\n                int CC = Hash(C[i][2], C[i][1], C[j][(2 + k) % 4], C[j][(1 + k) % 4]);\n                int DD = Hash(C[i][1], C[i][0], C[j][(3 + k) % 4], C[j][(2 + k) % 4]);\n                int a, b, c, d;\n                a = M[AA], update(AA, -1);\n                b = M[BB], update(BB, -1);\n                c = M[CC], update(CC, -1);\n                d = M[DD], update(DD, -1);\n                if(a > 0 && b > 0 && c > 0 && d > 0) ans += a * b * c * d;\n                update(AA, 1), update(BB, 1), update(CC, 1), update(DD, 1);\n            }\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), 1);\n        }\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    printf(\"%lld\", ans / 3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ninline int GetBit(int mask, int num) {\n    return (mask >> num) & 1;\n}\n\nint cFront[4];\nint cBack[4];\n\ninline bool CanLeft(int c0, int c1, int c2, int c3) {\n    return c0 == cBack[3] && c1 == cBack[2] && c2 == cFront[1] && c3 == cFront[0];\n}\n\ninline bool CanRight(int c0, int c1, int c2, int c3) {\n    return c0 == cFront[3] && c1 == cFront[2] && c2 == cBack[1] && c3 == cBack[0];\n}\n\ninline bool CanUp(int c0, int c1, int c2, int c3) {\n    return c0 == cFront[1] && c1 == cBack[2] && c2 == cBack[1] && c3 == cFront[2];\n}\n\ninline bool CanDown(int c0, int c1, int c2, int c3) {\n    return c0 == cBack[3] && c1 == cFront[0] && c2 == cFront[3] && c3 == cBack[0];\n}\n\ninline bool Can(int b, int c1, int c2, int c3, int c4) {\n    if (b == 0) {\n        return CanLeft(c1, c2, c3, c4);\n    } else if (b == 1) {\n        return CanRight(c1, c2, c3, c4);\n    } else if (b == 2) {\n        return CanUp(c1, c2, c3, c4);\n    } else {\n        return CanDown(c1, c2, c3, c4);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> colors(n, vector<int>(8));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n            colors[i][j + 4] = colors[i][j];\n        }\n    }\n\n    /*\n    vector<vector<int>> bits(1 << 4);\n    for (int mask = 0; mask < (1 << 4); ++mask) {\n        for (int b = 0; b < 4; ++b) {\n            if (!GetBit(mask, b)) {\n                bits[mask].push_back(b);\n            }\n        }\n    }\n    */\n\n    long long result[2][1 << 4];\n\n    int buffer[4];\n\n    long long glResult = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int t = 0; t < 4; ++t) {\n            cFront[t] = colors[i][t];\n        }\n\n        for (int j = i + 1; j < n; ++j) {\n            for (int dj = 0; dj < 4; ++dj) {\n                for (int t = 0; t < 4; ++t) {\n                    cBack[t] = colors[j][dj + t];\n                }\n\n                int curPtr = 0;\n                memset(result[curPtr], 0, sizeof(long long) * (1 << 4));\n                result[curPtr][0] = 1;\n\n                for (int k = i + 1; k < n; ++k) {\n                    if (k == j) {\n                        continue;\n                    }\n\n                    const int nxtPtr = 1 - curPtr;\n                    for (int t = 0; t < (1 << 4); ++t) {\n                        result[nxtPtr][t] = result[curPtr][t];\n                    }\n\n                    memset(buffer, 0, sizeof(int) * 4);\n\n                    for (int dk = 0; dk < 4; ++dk) {\n                        /*\n                        buffer[0] += CanLeft(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        buffer[1] += CanRight(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        buffer[2] += CanUp(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        buffer[3] += CanDown(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        */\n\n                        for (int b = 0; b < 4; ++b) {\n                            if (Can(b, colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3])) {\n                                ++buffer[b];\n                            }\n                        }\n                    }\n\n                    for (int mask = 0; mask < (1 << 4); ++mask) {\n                        for (int b = 0; b < 4; ++b) {\n                            if (!GetBit(mask, b)) {\n                                result[nxtPtr][mask + (1 << b)] += buffer[b] * result[curPtr][mask];\n                            }\n                        }\n                    }\n\n                    curPtr = nxtPtr;\n                }\n\n                glResult += result[curPtr][(1 << 4) - 1];\n            }\n        }\n    }\n\n    cout << glResult << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<map>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=405; \nint n,c[4][N];\nLL ans,id[N],re[4];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nmap<LL,int> num;\ninline LL getid(LL aa,LL bb,LL cc,LL dd){\n\treturn aa<<30|bb<<20|cc<<10|dd;\n}\ninline void rot(LL st,int kk)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tst=((st>>10)|(st&1023)<<30);\n\t\tnum[st]+=kk;\n\t}\n}\nint main()\n{\n\tfreopen(\"Building Cubes with AtCoDeer.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tread(c[0][i],c[1][i],c[2][i],c[3][i]);\n\t\tid[i]=getid(c[0][i],c[1][i],c[2][i],c[3][i]);\n//\t\tprintf(\"%lld asd\\n\",id[i]);\n\t\trot(id[i],1);\n\t}\n\tfor(int i=1;i<n-4;i++)\n\t{\n\t\trot(id[i],-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\trot(id[j],-1);\n\t\t\tfor(int l=0;l<4;l++)\n\t\t\t{\n\t\t\t\tLL tt=1;\n\t\t\t\tre[0]=getid(c[1][i],c[0][i],c[(l+1)%4][j],c[(l)%4][j]); if(!num[re[0]]) continue;\n\t\t\t\tre[1]=getid(c[2][i],c[1][i],c[(l)%4][j],c[(l+3)%4][j]); if(!num[re[1]]) continue;\n\t\t\t\tre[2]=getid(c[3][i],c[2][i],c[(l+3)%4][j],c[(l+2)%4][j]); if(!num[re[2]]) continue;\n\t\t\t\tre[3]=getid(c[0][i],c[3][i],c[(l+2)%4][j],c[(l+1)%4][j]); if(!num[re[3]]) continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\ttt*=num[re[k]];\n\t\t\t\t\trot(re[k],-1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++) rot(re[k],1);\n\t\t\t\tans+=tt;\n\t\t\t}\n\t\t\trot(id[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef tuple<int,int,int,int> Tile;\nmap<Tile,int> M;\nvector<Tile> V;\n\nint self_dub(Tile t){\n    int i=1;\n    if(t==Tile(get<1>(t),get<2>(t),get<3>(t),get<0>(t)))i++;\n    if(t==Tile(get<2>(t),get<3>(t),get<0>(t),get<1>(t)))i++;\n    if(t==Tile(get<3>(t),get<0>(t),get<1>(t),get<2>(t)))i++;\n    return i;\n}\n\nbool equal(Tile a, Tile b){\n    int A[4],B[4];\n    A[0]=get<0>(a);A[1]=get<1>(a);A[2]=get<2>(a);A[3]=get<3>(a);\n    B[0]=get<0>(b);B[1]=get<1>(b);B[2]=get<2>(b);B[3]=get<3>(b);\n    if(A[0]==B[0]&&A[1]==B[1]&&A[2]==B[2]&&A[3]==B[3]) return true;\n    if(A[0]==B[1]&&A[1]==B[2]&&A[2]==B[3]&&A[3]==B[0]) return true;\n    if(A[0]==B[2]&&A[1]==B[3]&&A[2]==B[0]&&A[3]==B[1]) return true;\n    if(A[0]==B[3]&&A[1]==B[0]&&A[2]==B[1]&&A[3]==B[2]) return true;\n    return false;\n}\n\nint64_t cnt(int i, int j, int d){\n    Tile T[6];\n    T[0]=V[i];\n    int Bo[4];\n    Bo[(0+d)%4]=get<0>(V[j]);\n    Bo[(1+d)%4]=get<1>(V[j]);\n    Bo[(2+d)%4]=get<2>(V[j]);\n    Bo[(3+d)%4]=get<3>(V[j]);    \n    T[1]=Tile(Bo[0],Bo[1],Bo[2],Bo[3]);\n    T[2]=Tile(get<1>(T[0]),get<0>(T[0]),get<1>(T[1]),get<0>(T[1]));\n    T[3]=Tile(get<2>(T[0]),get<1>(T[0]),get<0>(T[1]),get<3>(T[1]));\n    T[4]=Tile(get<3>(T[0]),get<2>(T[0]),get<3>(T[1]),get<2>(T[1]));\n    T[5]=Tile(get<0>(T[0]),get<3>(T[0]),get<2>(T[1]),get<1>(T[1]));\n    int Dub[6]={};\n    for(int a=0;a<6;a++){\n        for(int b=a+1;b<6;b++){\n            if(equal(T[a],T[b])){\n                Dub[b]+=self_dub(T[b]);\n            }\n        }\n    }\n    int64_t ret=1;\n    for(int i=2;i<6;i++){\n        int64_t p=0;\n        if(M.find(T[i])!=M.end()){\n            p=M[T[i]]-Dub[i];\n        }\n        ret*=p;\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int c0,c1,c2,c3;\n        cin>>c0>>c1>>c2>>c3;\n        V.emplace_back(c0,c1,c2,c3);\n        M[Tile(c0,c1,c2,c3)]++;\n        M[Tile(c1,c2,c3,c0)]++;\n        M[Tile(c2,c3,c0,c1)]++;\n        M[Tile(c3,c0,c1,c2)]++;\n    }\n    int64_t ans=0;\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            for(int d=0;d<4;d++){\n                ans+=cnt(i,j,d);\n                // if(cnt(i,j,d))cout<<i<<' '<<j<<' '<<d<<' '<<cnt(i,j,d)<<endl;\n            }\n        }\n    }\n    cout<<ans/3<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007\n#define f first\n#define s second\n#define si(x)   scanf(\"%d\",&x)\n#define sl(x)   scanf(\"%I64d\",&x)\n#define CLR(x)  memset(x,0,sizeof(x))\n#define RESET(x,a) memset(x,a,sizeof(x))\n#define pi pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debug(x) cerr<<\">value (\"<<#x<<\") : \"<<x<<endl;\n\nconst int N=405;\nint a[N][4]; //tile\nll val[N];   //hash of tile\nint n;\n\nll h(int p[4],int k)\n{\n    ll res=0LL;\n    for(int i=k;i<4;i++)\n        res = res<<10 + (ll)p[i];\n    for(int i=0;i<k;i++)\n        res = res<<10 + (ll)p[i];\n    return res;\n}\n\nll normalise(int p[4])\n{\n    return min(h(p,0),min(h(p,1),min(h(p,2),h(p,3))));\n}\n\nll way(int x, int y, int r)\n{\n    int i,j,k,b[4];\n    for(i=0;i<4;i++)\n        b[i]=a[y][ (i+r)%4 ];\n    int p[4];\n    int sym[4]={1,1,1,1};\n    ll d[4];\n    p[0]=b[1];   p[1]=b[0];\n    p[2]=a[x][1];   p[3]=a[x][0];\n    if(h(p,0)==h(p,1))sym[0]=4;\n    else if(h(p,0)==h(p,2))sym[0]=2;\n    d[0]=normalise(p);\n\n    p[0]=b[0];   p[1]=b[3];\n    p[2]=a[x][2];   p[3]=a[x][1];\n    if(h(p,0)==h(p,1))sym[1]=4;\n    else if(h(p,0)==h(p,2))sym[1]=2;\n    d[1]=normalise(p);\n\n    p[0]=b[2];   p[1]=b[1];\n    p[2]=a[x][0];   p[3]=a[x][3];\n    if(h(p,0)==h(p,1))sym[2]=4;\n    else if(h(p,0)==h(p,2))sym[2]=2;\n    d[2]=normalise(p);\n\n    p[0]=b[3];   p[1]=b[2];\n    p[2]=a[x][3];   p[3]=a[x][2];\n    if(h(p,0)==h(p,1))sym[3]=4;\n    else if(h(p,0)==h(p,2))sym[3]=2;\n    d[3]=normalise(p);\n\n    ll ans[16]={0};\n    ans[0]=1;\n    for(i=x+1;i<n;i++)\n    {\n        if(i==y)continue;\n        for(j=14;j>=0;j--)\n        {\n            for(k=0;k<4;k++)\n            {\n                if(j&(1<<k))continue;\n                if(val[i]==d[k])\n                    ans[j|(1<<k)] += 1LL*sym[k]*ans[j];\n            }\n        }\n    }\n    //printf(\"%d %d %lld %d\\n\",x+1,y+1,ans[15],sym[0]);\n    return ans[15];\n}\n\nint main()\n{\n    int i,j,k;\n    si(n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<4;j++)\n            si(a[i][j]);\n        val[i] = normalise(a[i]);\n    }\n    ll ans=0LL;\n    for(i=0;i<n;i++)\n        for(j=i+1;j<n;j++)\n            for(k=0;k<4;k++)\n                ans+=way(i,j,k);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n;\nlli dat[405][4];\nmap<lli,int> ds;\n\n\nvoid l2d(lli no,lli* d){\n\tirep(i,4){\n\t\td[i]=no%1000;\n\t\tno/=1000;\n\t}\n}\n\nlli d2l(lli* d){\n\tlli res=0;\n\trep(i,4){\n\t\tres*=1000;\n\t\tres+=d[i];\n\t}\n\treturn res;\n}\n\nlli same(lli p,lli q){\n\tlli dp[4],dq[4];\n\tl2d(p,dp);\n\tl2d(q,dq);\n\trep(i,4){\n\t\tbool ok=true;\n\t\trep(j,4){\n\t\t\tif(dp[j]!=dq[(i+j)%4])ok=false;\n\t\t}\n\t\tif(ok)return true;\n\t}\n\treturn false;\n}\n\nint ty(lli* d){\n\tint p=4;\n\tif(d[0]==d[2] && d[1]==d[3]){\n\t\tp=2;\n\t\tif(d[0]==d[1])p=1;\n\t}\n\treturn p;\n}\n\nlli sum(lli* d,lli p,lli q){\n\tlli res=1;\n\trep(i,4){\n\t\tlli no=d[i];\n\t\tlli x=ds[no];\n\t\tif(same(no,p))x--;\n\t\tif(same(no,q))x--;\n\t\trep(j,i){\n\t\t\tif(same(no,d[j]))x--;\n\t\t}\n\t\tif(x<=0)return 0;\n\t\tlli sd[4];\n\t\tl2d(no,sd);\n\t\tres *= x * 4 / ty(sd);\n\t}\n\t\n\t//rep(i,4)printf(\"%012lld \",d[i]);\n\t//printf(\"\\n%012lld %012lld  %lld\\n\",p,q,res);\n\treturn res;\n}\n\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tlli d[4];\n\t\trep(k,4)scanf(\"%lld\",&d[k]);\n\t\tint p=ty(d);\n\t\trep(j,4){\n\t\t\tlli ns=0;\n\t\t\trep(k,4){\n\t\t\t\tns*=1000;\n\t\t\t\tns+=d[(j+k)%4];\n\t\t\t}\n\t\t\tif(j<p){\n\t\t\t\tif(ds.count(ns)==0)ds[ns]=1;\n\t\t\t\telse ds[ns]++;\n\t\t\t}\n\t\t\tdat[i][j] = ns;\n\t\t}\n\t}\n\t\n\tlli ans=0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i==j)continue;\n\t\t\trep(pp,4){\n\t\t\t\tlli p[4];\n\t\t\t\tlli rp=dat[i][pp];\n\t\t\t\tl2d(rp,p);\n\t\t\t\trep(qq,4){\n\t\t\t\t\tlli q[4];\n\t\t\t\t\tlli rq=dat[j][qq];\n\t\t\t\t\tl2d(rq,q);\n\t\t\t\t\t\n\t\t\t\t\tlli dd[4][4] = {\n\t\t\t\t\t\t{p[1],p[0],q[3],q[2]},\n\t\t\t\t\t\t{p[2],p[1],q[2],q[1]},\n\t\t\t\t\t\t{p[3],p[2],q[1],q[0]},\n\t\t\t\t\t\t{p[0],p[3],q[0],q[3]}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tlli td[4];\n\t\t\t\t\t//printf(\"%012lld %012lld\\n\",rp,rq);\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\ttd[k] = d2l(dd[k]);\n\t\t\t\t\t\t//printf(\"%d .. %012lld\\n\",k,td[k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tans += sum(td,rp,rq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ans/24LL);\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) ((x)*1LL*1000000000+(y)*1000000+(z)*1000+(t))\nmap<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[G(fr.x1,fr.x0,bk.x1,bk.x0)];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[G(fr.x2,fr.x1,bk.x0,bk.x3)];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[G(fr.x3,fr.x2,bk.x3,bk.x2)];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[G(fr.x0,fr.x3,bk.x2,bk.x1)];key[4].dec();\n\t\tret+=ans;\n\t\tfor(int j=1;j<=4;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return calc(a[0],a[1],a[2],a[3])|(a[4]<<40)|(a[5]<<50);\n  };\n\n  vector<unordered_set<Int> > used(1<<20);\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused[(b[7]<<10)|b[6]].emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used[(a[7]<<10)|a[6]].count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i)%4];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)%4] < colors[(j+k)%4]) return true;\n            if (colors[(i+k)%4] > colors[(j+k)%4]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors a, Colors b, Colors brot) {\n    vector<Colors> dst = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    if (1) {\n        LL ans = 1;\n        for(auto & c: dst) {\n            ans *= 1ll * colcnt[c] * c.mult();\n            colcnt[c]--;\n        }\n        for(auto & c: dst) {\n            colcnt[c]++;\n        }\n        return ans;\n    }\n    vector<int> sz(4, 1);\n    FORN(i, 4) {\n        if (i >= dst.size()) break;\n        RFOR(j, i + 1, (int)dst.size()) {\n            if (dst[i] == dst[j]) {\n                sz[i] += sz[j];\n                sz.erase(sz.begin() + j);\n                dst.erase(dst.begin() + j);\n            }\n        }\n    }\n    assert(dst.size() == sz.size());\n    LL ans = 1;\n    FORN(i, (int)dst.size()) {\n        LL ccnt = colcnt[dst[i]];\n        int cnt = sz[i];\n        int ml = dst[i].mult();\n        EVARS(i, ccnt, cnt, ans, ml);\n        assert(cnt > 0);\n        if (cnt == 1) {\n            ans *= 1ll * ccnt * ml;\n        }\n        else if (cnt == 2) {\n            ans *= 1ll * ccnt * (ccnt - 1) * ml * ml;\n        }\n        else if (cnt == 3) {\n            ans *= 1ll * ccnt * (ccnt - 1) * (ccnt - 2) * ml * ml * ml;\n        }\n        else if (cnt == 4) {\n            ans *= 1ll * ccnt * (ccnt - 1) * (ccnt - 2) * (ccnt - 3) * ml * ml * ml * ml;\n        }\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    FOREACH(pb, colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL cccnt = pb.second;\n        colcnt[b]--;\n        FORN(rot, 4) {\n            EVARS(b.colors[0], b.colors[1], b.colors[2], b.colors[3], cccnt);\n            LL curans = countfit(a, b, brot);\n            ans += cccnt * 1ll * curans;\n            brot.rotate_left(1);\n            EVARS(curans, ans);;\n        }\n        colcnt[b]++;\n    }\n    EPR(\"ans smallest %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        EPR(\"tile %d\\n\", i);\n        Colors a = tiles[i];\n        EVARS(a.colors[0], a.colors[1], a.colors[2], a.colors[3]);\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 405, base = 1013, MOD = 1000007;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef pair<int, int> pii;\n\nint C[MAX_N][4], N;\n\nclass Hash_Table {\npublic:\n  int head[MOD], cnt, nxt[MOD], num[MOD];\n  u64 key[MOD];\n  void add(pair<pii, pii> x, int v) {\n    u64 val = (u64)x.first.first * base + (u64)x.first.second * base * base;\n    val += (u64)x.second.first * base * base * base;\n    val += (u64)x.second.second * base * base * base * base;\n    \n    int temp = val % MOD;\n    for (int i = head[temp]; i; i = nxt[i])\n      if (key[i] == val) {\n\tnum[i] += v;\n\treturn;\n      }\n    nxt[++cnt] = head[temp], head[temp] = cnt, num[cnt] = v, key[cnt] = val;\n  }\n  int query(pair<pii, pii> x) {\n    u64 val = (u64)x.first.first * base + (u64)x.first.second * base * base;\n    val += (u64)x.second.first * base * base * base;\n    val += (u64)x.second.second * base * base * base * base;\n    \n    int temp = val % MOD;\n    for (int i = head[temp]; i; i = nxt[i])\n      if (key[i] == val) return num[i];\n    return 0;\n  }\n} cnt;\n\nvoid insert(int col[4]) {\n  static int t[4];\n  for (int i = 0; i < 4; ++i) {\n    for (int j = 0; j < 4; ++j) t[j] = col[(j + i) % 4];\n    cnt.add(make_pair(make_pair(t[0], t[1]), make_pair(t[2], t[3])), 1);\n  }\n}\n\nvoid substract(int col[4]) {\n  static int t[4];\n  for (int i = 0; i < 4; ++i) {\n    for (int j = 0; j < 4; ++j) t[j] = col[(j + i) % 4];\n    cnt.add(make_pair(make_pair(t[0], t[1]), make_pair(t[2], t[3])), -1);\n  }  \n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i)\n    for (int j = 0; j < 4; ++j)\n      scanf(\"%d\", &C[i][j]);\n\n  i64 res = 0;\n  for (int i = 1; i <= N; ++i) {\n    for (int j = 1; j < i; ++j) {\n      substract(C[j]);\n      for (int d = 0; d < 4; ++d) {\n\tstatic int t[4], A[4], vis[MAX_N];\n\ti64 num = 1;\n\tfor (int k = 0; k < 4; ++k) t[k] = C[j][((k + d) % 4) ^ 1];\n\tfor (int k = 0; k < 4; ++k) {\n\t  A[0] = C[i][(k + 1) % 4], A[1] = C[i][k];\n\t  A[3] = t[(k + 1) % 4], A[2] = t[k];\n\t  int temp = cnt.query(make_pair(make_pair(A[0], A[1]), make_pair(A[2], A[3])));\n\t  num *= temp, vis[k] = 0;\n\t  if (temp) substract(A), vis[k] = 1;\n\t}\n\tfor (int k = 0; k < 4; ++k) {\n\t  A[0] = C[i][(k + 1) % 4], A[1] = C[i][k];\n\t  A[3] = t[(k + 1) % 4], A[2] = t[k];\n\t  if (vis[k]) insert(A);\n\t}\n\tres += num;\n      }\n      insert(C[j]);\n    }\n    insert(C[i]);\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<long,15>,4> >M;\nmap<long,map<int,int> >Q;\nint a[400],b[400],c[400],d[400];\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tlong C=conv(a[i],b[i],c[i],d[i]);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C]++;\n\t\t\tC=rotate(C);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<long,15>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<=j;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tA[0][j*(j+1)/2+k]=sum-j-k;\n\t\t\tA[1][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\tA[2][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\tA[3][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tint a=Q[t[k]][i];\n\t\t\t\t\tint b=Q[t[k]][j];\n\t\t\t\t\tif(a<b)a^=b^=a^=b;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][a*(a+1)/2+b];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int mo=1e7+9;\nint head[mo],nxt[N],w[N],v[N],tot;LL to[N];\nint c[N][4];\n//有旋转同构，我们强制其中标号最小的方块向前方正方\n//然后枚举最小的方块和最小的方块相对的方块，这样每个方块的四个角的颜色都确定了，用哈希求剩下四个面的方案数即可\n//有个小trick，四个角的颜色可能有循环节，注意到哈希值相同的方块循环节也一定相同，所以求值时同时乘上循环节大小\ninline void ins(LL s,int t) {\n\tint h=s%mo;\n\tfor (int i=head[h];i;i=nxt[i])\n\t\tif (to[i]==s) { w[i]+=t; return; }\n\tto[++tot]=s,nxt[tot]=head[h],head[h]=tot,w[tot]=t;\n\tv[tot]=s%1000000==s/1000000?(s%1000==s/1000000000?4:2):1;\n}\ninline int find(LL s) {\n\tfor (int i=head[s%mo];i;i=nxt[i])\n\t\tif (to[i]==s) return w[i]*v[i];\n\treturn 0;\n}\ninline LL get(int k,int t) { LL s=0; for (int i=0;i<4;i++) s=s*1000+c[k][(t+i)&3]; return s; }\ninline void Add(LL s,int t) {\n\tLL p[4];\n\tfor (int i=0;i<4;i++) p[i]=s,s=s/1000+s%1000*1000000000;\n\tsort(p,p+4);\n\tfor (int i=0;i<4;i++) if (!i||p[i]!=p[i-1]) ins(p[i],t);\n}\ninline void add(int k,int t) { Add(get(k,0),t); }\nint main()\n{\n\tint n=gi(),i,j,k,t;LL s,ans=0,pi;\n\tfor (i=0;i<n;add(i++,1))\n\t\tfor (j=0;j<4;j++)\n\t\t\tc[i][j]=gi();\n\tfor (i=0;i<n;i++) {\n\t\tadd(i,-1);\n\t\tfor (j=i+1;j<n;j++) {\n\t\t\tadd(j,-1);\n\t\t\treverse(c[j],c[j]+4);\n\t\t\tfor (k=0;k<4;k++) {\n\t\t\t\tpi=1;\n\t\t\t\tfor (t=0;t<4;t++) {\n\t\t\t\t\ts=((c[j][(k+t)&3]*1000LL+c[j][(k+t+1)&3])*1000+c[i][(t+1)&3])*1000+c[i][t];\n\t\t\t\t\tpi*=find(s);\n\t\t\t\t\tif (!pi) break;\n\t\t\t\t\tAdd(s,-1);\n\t\t\t\t}\n\t\t\t\twhile (t--) {\n\t\t\t\t\ts=((c[j][(k+t)&3]*1000LL+c[j][(k+t+1)&3])*1000+c[i][(t+1)&3])*1000+c[i][t];\n\t\t\t\t\tAdd(s,1);\n\t\t\t\t}\n\t\t\t\tans+=pi;\n\t\t\t}\n\t\t\treverse(c[j],c[j]+4);\n\t\t\tadd(j,1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n;\n    cin >> n;\n    int c[405][4];\n    vector<int> v[405][4];\n    map<vector<int>, ll> mp;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++) cin >> c[i][j];\n        for(int j = 0; j < 4; j++){\n            for(int k = 0; k < 4; k++){\n                v[i][j].push_back(c[i][(j + k) % 4]);\n            }\n            mp[v[i][j]]++;\n        }\n    }\n    ll ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++){\n            mp[v[i][j]]--;\n        }\n        for(int j = i + 1; j < n; j++){\n            for(int k = 0; k < 4; k++){\n                mp[v[j][k]]--;\n            }\n            for(int k = 0; k < 4; k++){\n                vector<int> ver(8);\n                for(int l = 0; l < 4; l++) ver[l] = c[i][l];\n                for(int l = 4; l < 8; l++) ver[l] = c[j][(7 - l + k) % 4];\n                ll s = 1;\n                int l;\n                for(l = 0; l < 4; l++){\n                    vector<int> r(4);\n                    r[0] = ver[l];\n                    r[1] = ver[(l + 3) % 4];\n                    r[2] = ver[(l + 3) % 4 + 4];\n                    r[3] = ver[l + 4];\n                    ll u = mp[r];\n                    s *= u;\n                    if(u == 0) break;\n                    for(int m = 0; m < 4; m++){\n                        vector<int> t(4);\n                        for(int p = 0; p < 4; p++) t[p] = r[(p + m) % 4];\n                        mp[t]--;\n                    }\n                }\n                l--;\n                ans += s;\n                for(; l >= 0; l--){\n                    vector<int> r(4);\n                    r[0] = ver[l];\n                    r[1] = ver[(l + 3) % 4];\n                    r[2] = ver[(l + 3) % 4 + 4];\n                    r[3] = ver[l + 4];\n                    for(int m = 0; m < 4; m++){\n                        vector<int> t(4);\n                        for(int p = 0; p < 4; p++) t[p] = r[(p + m) % 4];\n                        mp[t]++;\n                    }\n                }\n            }\n            for(int k = 0; k < 4; k++){\n                mp[v[j][k]]++;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> fs(n, std::vector<int>(4));\n    for (auto& f : fs) {\n        for (auto& x : f) {\n            std::cin >> x;\n        }\n    }\n\n    lint ans = 0;\n    std::vector<std::vector<int>> cs;\n    std::vector<lint> dp(1 << 4), ndp(1 << 4);\n\n    for (int i = 0; i < n; ++i) {\n        // top face (fixed)\n        auto& tf = fs[i];\n\n        for (int j = 0; j < i; ++j) {\n            // bottom face\n            auto& bf = fs[j];\n\n            for (int r = 0; r < 4; ++r) {\n                cs = std::vector<std::vector<int>>{\n                    {tf[3], tf[2], bf[1], bf[0]},\n                    {tf[2], tf[1], bf[2], bf[1]},\n                    {tf[1], tf[0], bf[3], bf[2]},\n                    {tf[0], tf[3], bf[0], bf[3]},\n                };\n\n                std::fill(dp.begin(), dp.end(), 0);\n                dp[0] = 1;\n                for (int k = 0; k < i; ++k) {\n                    if (k == j) continue;\n                    ndp = dp;\n\n                    auto& f = fs[k];\n                    for (int s = 0; s < 4; ++s) {\n                        for (int b = 0; b < (1 << 4); ++b) {\n                            for (int l = 0; l < 4; ++l) {\n                                if (((b >> l) & 1) ||\n                                    cs[l] != f) continue;\n                                ndp[b | (1 << l)] += dp[b];\n                            }\n                        }\n                        std::rotate(f.begin(), f.begin() + 1, f.end());\n                    }\n                    std::swap(dp, ndp);\n                }\n\n                ans += dp.back();\n                std::rotate(bf.begin(), bf.begin() + 1, bf.end());\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&x[i][j]);\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[i][1],x[i][0],x[ii][(j+1)%4],x[ii][(j+0)%4]);\n                    y[1] = pack(x[i][0],x[i][3],x[ii][(j+0)%4],x[ii][(j+3)%4]);\n                    y[2] = pack(x[i][3],x[i][2],x[ii][(j+3)%4],x[ii][(j+2)%4]);\n                    y[3] = pack(x[i][2],x[i][1],x[ii][(j+2)%4],x[ii][(j+1)%4]);\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m.count(y[p])?m[y[p]]:0;\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            if(m.count(a[i]))m[a[i]]++;\n            else m[a[i]] = 1;\n        }\n        printf(\"%I64d\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\n\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\n__int128_t check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  __int128_t res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[(k+z)%4][i];\n          x[k+4]=cs[k][j];\n        }\n        int way=0,flg=0;\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          if(used.count(make_hash(y))){\n            flg=1;\n            break;\n          }\n        }\n        if(flg) continue;\n        ans+=check(x)/way;\n        used.emplace(make_hash(x));\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nint n;\nstruct node{int col[4];\n    node nxt(){ return node{col[1],col[2],col[3],col[0]};}\n    friend bool operator <(node a,node b)\n    {\n        for (int i=0;i<4;i++)\n            if (a.col[i]!=b.col[i]) return a.col[i]<b.col[i];\n        return 0;\n    }\n}a[410],a1,a2,a3,a4;\nmap<node,int>mp;\nvoid insert(node x,int v)\n{for (int i=0;i<4;i++,x=x.nxt()) mp[x]+=v;}\n\n\nnode xx,yy;\nint id1;\nll ans,re;\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d%d%d\",&a[i].col[0],&a[i].col[1],&a[i].col[2],&a[i].col[3]);    \n        insert(a[i],1);    \n    }\n    for (int i=1;i<=n;i++)\n    {\n        insert(a[i],-1);\n        for (int j=i+1;j<=n;j++)\n        {\n            insert(a[j],-1);\n            for (int t=0;t<4;t++)\n            {\n                a1=node{a[j].col[1],a[i].col[0],a[i].col[3],a[j].col[2]};\n                a2=node{a[i].col[1],a[j].col[0],a[j].col[3],a[i].col[2]};\n                a3=node{a[j].col[1],a[j].col[0],a[i].col[1],a[i].col[0]};\n                a4=node{a[i].col[3],a[i].col[2],a[j].col[3],a[j].col[2]};\n                a[j]=a[j].nxt();                \n                if (mp[a1]==0||mp[a2]==0||mp[a3]==0||mp[a4]==0) continue;\n                re=1;\n                re*=mp[a1];insert(a1,-1);\n                re*=mp[a2];insert(a2,-1);\n                re*=mp[a3];insert(a3,-1);\n                re*=mp[a4];\n                insert(a1,1);insert(a2,1);insert(a3,1);\n                ans+=re;\n\n            }\n            insert(a[j],1);\n        }\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#define int long long\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=100050;\n//ここまでテンプレ\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\nll fact_mod(ll n, ll mod) {\n    ll f = 1; repq(i,2,n) f = f * (i % MOD) % MOD;\n    return f;\n}\n// 繰り返し二乗法 (再帰バージョン)\nll mod_pow(ll x, ll n, ll mod) {\n    if(n == 0) return 1;\n    ll res = mod_pow((x * x) % mod, n / 2 , mod);\n    if(n & 1) res = (res * x) % mod;\n    return res;\n}\n// 組み合わせ nCr を求める (modあり)\nll combination_mod(ll n, ll r, ll mod) {\n    if(r > n-r) r = n-r;\n    if(r == 0) return 1;\n    ll a = 1;\n    rep(i, 0, r) a = a * ((n-i) % mod) % mod;\n    ll b = mod_pow(fact_mod(r, mod), mod-2, mod);\n    return (a % mod) * (b % mod) % mod;\n}\n//4つの色を辞書順最小の並びで返す\nvint COLOR(int a,int b,int c,int d){\n\tvint A={a,b,c,d},B={b,c,d,a},C={c,d,a,b},D={d,a,b,c};\n\tvector<vint> vec={A,B,C,D};\n\tsort(vec.begin(),vec.end());\n\treturn vec[0];\n}\nsigned main(){\n\tint N;\n\tcin>>N;\n\tmap<vint,int> pam;\n\tvector<vint> panel;\n\t//それぞれのパネルに含まれる色を、昇順にソートして入れていく\n\tfor(int i=0;i<N;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\t//4つの角の順番を変えないように、辞書順最小の並びに揃える\n\t\tvint v=COLOR(a,b,c,d);\n\t\tpam[v]++;\n\t\tpanel.pb(v);\n\t}\n\tll ans=0;\n\t//立方体の底に使うパネルiと天井に使うパネルjを全探索する\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\t//天井のパネルの向きを全探索する\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvint cei,flo;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tflo.pb(panel[i][l]);\n\t\t\t\t\tcei.pb(panel[j][(k+l)%4]);\n\t\t\t\t}\n\t\t\t\t//側面の4つのパネルになりうるパネルがあるか？\n\t\t\t\tvint A=COLOR(cei[0],flo[0],flo[3],cei[1]);\n\t\t\t\tvint B=COLOR(cei[3],flo[1],flo[0],cei[0]);\n\t\t\t\tvint C=COLOR(cei[2],flo[2],flo[1],cei[3]);\n\t\t\t\tvint D=COLOR(cei[1],flo[3],flo[2],cei[2]);\n\t\t\t\t//pamから底と天井に使ったパネルを引く\n\t\t\t\tpam[panel[i]]--;\n\t\t\t\tpam[panel[j]]--;\n\t\t\t\t//立方体が何通りできるか？\n\t\t\t\t//側面に使うパネル\n\t\t\t\tmap<vint,int> use;\n\t\t\t\tuse[A]++,use[B]++,use[C]++,use[D]++;\n\t\t\t\tif(pam.find(A)==pam.end() || pam.find(B)==pam.end() || pam.find(C)==pam.end() || pam.find(D)==pam.end());\n\t\t\t\telse if(pam[A]<use[A] || pam[B]<use[B] || pam[C]<use[C] || pam[D]<use[D]);\n\t\t\t\telse{\n\t\t\t\t\tll temp=1;\n\t\t\t\t\tfor(pair<vint,int> P:use){\n\t\t\t\t\t\ttemp*=combination_mod(pam[P.first],P.second,(1<<31)-1);\n\t\t\t\t\t\tif(P.first[1]==P.first[0] && P.first[2]==P.first[0] && P.first[3]==P.first[0])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=4;\n\t\t\t\t\t\telse if(P.first[0]==P.first[2] && P.first[1]==P.first[3])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=2;\n\t\t\t\t\t\tfor(int l=1;l<=P.second;l++)\n\t\t\t\t\t\t\ttemp*=l;\n\t\t\t\t\t}\n\t\t\t\t\tans+=temp;\n\t\t\t\t}\n\t\t\t\t//pamに底と天井に使ったパネルを足す\n\t\t\t\tpam[panel[i]]++;\n\t\t\t\tpam[panel[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (short i = a; i <= b; ++ i) \nconst short N = 1005, base = 9971 ; \n\nconst short turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nunsigned long long id[N] ;\nmap <unsigned long long, short> Count ;\nshort col[N][5], n ;\n\ninline void getmin(vector <short> &p) {\n\tvector <short> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\ninline unsigned long long Hash(vector <short> &p) {\n\tunsigned long long ret = 0 ;\n\trep(i, 0, 3) ret = ret * base + p[i] ;\n\treturn ret ;\n}\n\nmap <unsigned long long, short>  mul, used ;\n\nint main() {\n\tcin >> n ;\n\trep(i, 1, n) rep(j, 0, 3) cin >> col[i][j] ;\n\trep(i, 1, n) {\n\t\tvector <short> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\t++ Count[Hash(ret)] ;\n\t\tid[i] = Hash(ret) ;\n\t\tshort tot = 0 ; \n\t\tvector <short> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[Hash(ret)] = tot ;\n\t}\t\n\tll ans = 0, sum ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\t-- Count[id[i]], -- Count[id[j]] ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <short> ret ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\tunsigned long long U[4] = {0} ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\tvector <short> x ;\n\t\t\t\trep(q, 0, 3) x.push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(x) ;\n\t\t\t\trep(q, 0, 3) U[p] = U[p] * base + x[q] ;\n\t\t\t\tsum *= (ll) mul[U[p]] * (Count[U[p]] - used[U[p]]) ;\n\t\t\t\t++ used[U[p]] ;\n\t\t\t}\n\t\t\trep(p, 0, 3) -- used[U[p]] ;\n\t\t\tans += sum ;\n\t\t}\n\t\t++ Count[id[i]], ++ Count[id[j]] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MN=10000+5;\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>T&IN(T&in){\n\tin=0;char c=getchar();int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c))in=in*10+c-'0',c=getchar();\n\tin*=f;return in;\n}\nstruct data{int c[4];}a[MN],t;\nint n;ll ans;\nll has[MN],fact[4],tmp[4];\nmap<ll,int>mp;\nvoid add(ll has,int d){\n\tfor(int i=3;i>=0;--i)tmp[i]=has%1000,has/=1000;\n\tfor(int i=0;i<4;++i){\n\t\thas=0;\n\t\tfor(int j=0;j<4;++j)\n\t\t\thas=has*1000+tmp[(i+j)&3];\n\t\tmp[has]+=d;\n\t}\n}\nll get(data a){ll res=0;for(int i=0;i<4;++i)res=res*1000+a.c[i];return res;}\nvoid input(){\n\tIN(n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<4;++j)IN(a[i].c[j]);\n\t\thas[i]=get(a[i]),add(has[i],1);\n\t}\n\tfor(int i=1;i<=n-5;++i){\n\t\tadd(has[i],-1);\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tadd(has[j],-1);\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tint F=0;ll s=1;\n\t\t\t\tfor(int l=0;l<4;++l){\n\t\t\t\t\tt.c[0]=a[i].c[(l+1)&3],t.c[1]=a[i].c[l];\n\t\t\t\t\tt.c[2]=a[j].c[(k-l+4)&3],t.c[3]=a[j].c[(k-l+3)&3];\n\t\t\t\t\tfact[l]=get(t);\n\t\t\t\t\tif(!mp[fact[l]]){F=1;break;}\n\t\t\t\t}\n\t\t\t\tif(F)continue;\n\t\t\t\tfor(int l=0;l<4;++l)s*=mp[fact[l]],add(fact[l],-1);\n\t\t\t\tfor(int l=0;l<4;++l)add(fact[l],1);\n\t\t\t\tans+=s;\n\t\t\t}\n\t\t\tadd(has[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t#if 1\n\tint n; cin >> n;\n\tvector<vi> c(n, vi(4));\n\trep(i, n) rep(j, 4) cin >> c[i][j];\n\t#else\n\tint n = 400;\n\tvector<vi> c(n, vi(4));\n\t//673205187207168000\n\t#endif\n\tll ans = 0;\n\tmap<vi, int> cnt;\n\tauto norm = [](const vi &v){\n\t\tvector<vi> u;\n\t\trep(j, 4){\n\t\t\tu.pb({v[j], v[(j + 1) % 4], v[(j + 2) % 4], v[(j + 3) % 4]});\n\t\t}\n\t\treturn *min_element(all(u));\n\t};\n\tauto count = [](const vi &v){\n\t\tvector<vi> u;\n\t\trep(j, 4){\n\t\t\tu.pb({v[j], v[(j + 1) % 4], v[(j + 2) % 4], v[(j + 3) % 4]});\n\t\t}\n\t\tif(u[0] == u[1]) return 4;\n\t\tif(u[0] == u[2]) return 2;\n\t\treturn 1;\n\t};\n\trep(i, n) ++cnt[c[i] = norm(c[i])];\n\t\n\t\n\trep(i, n){\n\t\t--cnt[c[i]];\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t--cnt[c[j]];\n\t\t\trep(k, 4){\n\t\t\t\tconst vi col = {c[i][0], c[i][1], c[i][2], c[i][3],\n\t\t\t\t\tc[j][(k + 3) % 4], c[j][(k + 2) % 4], c[j][(k + 1) % 4], c[j][k]};\n\t\t\t\tvector<vi> cs = {{0, 4, 5, 1}, {1, 5, 6, 2}, {3, 2, 6, 7}, {0, 3, 7, 4}};\n\t\t\t\tfor(auto &v : cs){\n\t\t\t\t\tfor(int &p : v) p = col[p];\n\t\t\t\t\tv = norm(v);\n\t\t\t\t}\n\t\t\t\tsort(all(cs));\n\t\t\t\t\n\t\t\t\tll x = cnt.count(cs[0]) ? cnt[cs[0]] : 0;\n\t\t\t\tll y = cnt.count(cs[1]) ? cnt[cs[1]] : 0;\n\t\t\t\tll z = cnt.count(cs[2]) ? cnt[cs[2]] : 0;\n\t\t\t\tll w = cnt.count(cs[3]) ? cnt[cs[3]] : 0;\n\t\t\t\tint rot = count(cs[0]) * count(cs[1]) * count(cs[2]) * count(cs[3]);\n\t\t\t\t/*\n\t\t\t\tif(x * y * z * w){\n\t\t\t\t\tdbg(i, j, k);\n\t\t\t\t\tdbg(x, y, z, w, rot);\n\t\t\t\t\trep(ii, 4) dbg(ii, cs[ii]);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(cs[0] == cs[3]){\n\t\t\t\t\tans += x * (x - 1) * (x - 2) * (x - 3) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[2]){\n\t\t\t\t\tans += x * (x - 1) * (x - 2) * w * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[1] == cs[3]){\n\t\t\t\t\tans += x * y * (y - 1) * (y - 2) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[1] && cs[2] == cs[3]){\n\t\t\t\t\tans += x * (x - 1) * z * (z - 1) * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[0] == cs[1]){\n\t\t\t\t\tans += x * (x - 1) * z * w * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[1] == cs[2]){\n\t\t\t\t\tans += x * y * (y - 1) * w * rot;\n\t\t\t\t}\n\t\t\t\telse if(cs[2] == cs[3]){\n\t\t\t\t\tans += x * y * z * (z - 1) * rot;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += x * y * z * w * rot;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++cnt[c[j]];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP2D(a, n, m) REP(i, n) REP(j, m) printf(\"%lld%c\", a[i][j], j + 1 == m ? '\\n' : ' '); puts(\"\")\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n\ntypedef long long ll;\n\nconst int N_MAX = 400;\n\nint N;\nll C[N_MAX][4];\n\nll h[N_MAX];\nmap<ll, ll> par;\nmap<ll, ll> car;\nmap<ll, ll> tb;\nmap<ll, ll> tbh;\nmap<ll, ll> tbs;\n\nvoid dumpC(ll c) {\n  printf(\"%lld, %lld, %lld, %lld\\n\",\n    c >> 30 & 1023,\n    c >> 20 & 1023,\n    c >> 10 & 1023,\n    c & 1023\n  );\n}\n\nll perm(ll n, ll k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  ll ret = 1;\n  REP(i, k) ret = ret * (k - i);\n  return ret;\n}\n\nvoid solve() {\n  REP(i, N) {\n    ll c = 0;\n    ll cs[4];\n    REP(d, 4) c = c << 10 | C[i][d];\n    REP(d, 4) {\n      // printf(\"i: %d, d: %d, c: %lld :\", i, d, c); dumpC(c);\n      cs[d] = c;\n      c = (c << 10  | c >> 30) & ((1LL << 40) - 1);\n    }\n    c = *min_element(cs, cs + 4);\n    h[i] = c;\n    tb[c]++;\n    car[c] = count(cs, cs + 4, c);\n    REP(d, 4) par[cs[d]] = c;\n  }\n\n  // ITR(par, it) printf(\"k: %lld, v: %lld\\n\", it->first, it->second);\n  // ITR(tb, it) printf(\"k: %lld, v: %lld\\n\", it->first, it->second);\n  // ITR(car, it) printf(\"k: %lld, v: %lld\\n\", it->first, it->second);\n\n  ll ans = 0;\n  REP(j, N) REP(i, j) {\n    // printf(\"h[%d]: \", i); dumpC(h[i]);\n    // printf(\"h[%d]: \", j); dumpC(h[j]);\n    tbh.clear();\n    tbh[par[h[i]]]++; tbh[par[h[j]]]++;\n    REP(k, 4) {\n      // printf(\"  k: %d\\n\", k);\n      tbs.clear();\n      REP(d, 4) {\n        ll s = 0;\n        s |= C[i][(1 + d) % 4] << 30;\n        s |= C[i][d % 4] << 20;\n        s |= C[j][(4 - d + k) % 4] << 10;\n        s |= C[j][(7 - d + k) % 4];\n        tbs[par[s]]++;\n      }\n      ll sp = 1;\n      ITR(tbs, it) {\n        ll s = it->first;\n        ll sc = it->second;\n        ll scb = perm(tb[s] - tbh[s], sc);\n        // if (scb != 0) {\n        //   printf(\" s: \"); dumpC(s);\n        //   printf(\" sc: %lld, scb: %lld, car: %lld\\n\", sc, scb, car[s]);\n        // }\n        REP(i, sc) scb *= car[s];\n        sp *= scb;\n      }\n      ans += sp;\n    }\n  }\n\n  printf(\"%lld\\n\", ans / 3);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) REP(j, 4) scanf(\"%lld\", &C[i][j]);\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(typename vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long  LL;\n\nint N;\nmap<P4 , int> M;\nmap<P4 , int>::iterator it[4];\nint C[444][4];\nint p[4][4];\nLL ans;\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,0,N){\n\t\trepp(j,0,4){\n\t\t\tscanf(\"%d\" , C[i] + j);\n\t\t}\n\t\trepp(j,0,4){\n\t\t\t++M[M4P(C[i][j%4] , C[i][(j+1)%4] , C[i][(j+2)%4] , C[i][(j+3)%4])];\n\t\t}\n\t}\n\trepp(i,0,N){\n\t\trepp(j,0,4){\n\t\t\t--M[M4P(C[i][j%4] , C[i][(j+1)%4] , C[i][(j+2)%4] , C[i][(j+3)%4])];\n\t\t}\n\t\trepp(j,i+1,N){\n\t\t\trepp(k,0,4){\n\t\t\t\t--M[M4P(C[j][k%4] , C[j][(k+1)%4] , C[j][(k+2)%4] , C[j][(k+3)%4])];\n\t\t\t}\n\t\t\trepp(z,0,4){\n\t\t\t\tLL x = 1;\n\t\t\t\trepp(k,0,4){\n\t\t\t\t\tp[k][0] = C[i][k];\n\t\t\t\t\tp[k][1] = C[j][(4-k+z)%4];\n\t\t\t\t\tp[k][2] = C[j][(3-k+z)%4];\n\t\t\t\t\tp[k][3] = C[i][(k + 1) % 4];\n\t\t\t\t\tit[k] = M.find(M4P(C[i][k] , C[j][(4-k+z)%4] , C[j][(3-k+z)%4] , C[i][(k + 1) % 4]));\n\t\t\t\t\tif(it[k] == M.end()){\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx *= (LL)max(0 , (*it[k]).second);\n\t\t\t\t\t\trepp(s,0,4){\n\t\t\t\t\t\t\t--M[M4P(p[k][s] , p[k][(s+1)%4] , p[k][(s+2)%4] , p[k][(s+3)%4])];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += x;\n\t\t\t\trepp(k,0,4){\n\t\t\t\t\tif(it[k] != M.end()){\n\t\t\t\t\t\trepp(s,0,4){\n\t\t\t\t\t\t\t++M[M4P(p[k][s] , p[k][(s+1)%4] , p[k][(s+2)%4] , p[k][(s+3)%4])];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trepp(k,0,4){\n\t\t\t\t++M[M4P(C[j][k%4] , C[j][(k+1)%4] , C[j][(k+2)%4] , C[j][(k+3)%4])];\n\t\t\t}\n\t\t}\n\t\trepp(j,0,4){\n\t\t\t++M[M4P(C[i][j%4] , C[i][(j+1)%4] , C[i][(j+2)%4] , C[i][(j+3)%4])];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , ans / 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void shift(long long &now)\n{\n    static const int div = 1000 * 1000 * 1000;\n    now = now % div * 1000 + now / div;\n}\n\ninline void reverse(long long &now)\n{\n    static const int div = 1000 * 1000 * 1000;\n    now = now % 1000 * div + now % 1000000 / 1000 * 1000 * 1000 + now % div / 1000000 * 1000 + now / div;\n}\n\nlong long hsh(const vector <int> &now)\n{\n    long long res = 0;\n \n    for (int i = 0; i < 4; i++) {\n        res = res * 1000 + now[i];\n    }\n    return res;\n}\n\nint get(long long a, int pos)\n{\n    static const int div = 1000 * 1000 * 1000;\n\n    if (pos == 0) {\n        return a / div;\n    }\n    if (pos == 1) {\n        return a % div / 1000000;\n    }\n    if (pos == 2) {\n        return a % 1000000 / 1000;\n    }\n    return a % 1000;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    map <long long, int> cnt;\n    vector <long long> A(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) {\n            int x;\n            cin >> x;\n            A[i] = A[i] * 1000 + x;\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            cnt[A[i]]++;\n            shift(A[i]);\n        }\n    }\n    long long res = 0;\n    vector <int> st = {1000 * 1000 * 1000, 1000 * 1000, 1000, 1};\n\n    for (int i = 0; i < n; i++) {\n        for (int k = 0; k < 4; k++) {\n            cnt[A[i]]--;\n            shift(A[i]);\n        }\n\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 0; k < 4; k++) {\n                cnt[A[j]]--;\n                shift(A[j]);\n            }\n            reverse(A[j]);\n\n            for (int sh = 0; sh < 4; sh++) {\n                long long add = 1;\n                map <long long, int> cross;\n\n                for (int k = 0; k < 4; k++) {\n                    long long now = hsh({get(A[i], k), get(A[j], k), get(A[j], (k + 1) % 4), get(A[i], (k + 1) % 4)});\n                    add *= cnt[now];\n\n                    for (int x = 0; x < 4; x++) {\n                        if (!cross.count((now))) {\n                            cross[now] = cnt[now];\n                        }\n                        cnt[now] -= 1;\n                        shift(now);\n                    }\n                }\n                res += add;\n\n                for (auto p: cross) {\n                    cnt[p.first] = p.second;\n                }\n                shift(A[j]);\n            }\n            reverse(A[j]);\n\n            for (int k = 0; k < 4; k++) {\n                cnt[A[j]]++;\n                shift(A[j]);\n            }\n        }\n    }\n    cout << res << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nvector<int> F(8, 0);\nint getP(vector<int> &o) {\n\tint k=-1; F[0] = -1;\n\tfor(int i=1; i<8; i++) {\n\t\twhile(k>=0 && F[k+1] != o[i%4]) k = F[k];\n\t\tif(F[k+1] == o[i%4]) k++;\n\t\tF[i] = k;\n\t}\n\treturn 8 / (8 - (k+1)) / 2;\n}\nvoid rotate(vector<int> &o) {\n\tint temp = o.front();\n\tfor(int i=0; i<3; i++) o[i] = o[i+1]; o.back() = temp;\n}\n\nconst int MAX_N = 4e2 + 10;\n\nint N; \nvector<int> Nr[MAX_N];\nmap<vector<int>, int> Cnt;\n\nint main() {\n\tcin >> N;\n\tfor(int i=0; i<N; i++) {\n\t\tfor(int k=0, x; k<4; k++) scanf(\"%d\", &x), Nr[i].push_back(x);\n\t\tfor(int k=0; k<4; k++) Cnt[Nr[i]]++, rotate(Nr[i]);\n\t}\n\t\n\tvector<int> cube(8, 0);\n\tvector<vector<int>> faceIx({vector<int>({5, 4, 1, 0}), vector<int>({4, 7, 2, 1}), vector<int>({7, 6, 3, 2}), vector<int>({6, 5, 0, 3})});\n\tll ans = 0;\n\tfor(int l=0; l<N; l++) {\n\t\tfor(int k=0; k<4; k++) cube[k] = Nr[l][k];\n\t\tfor(int k=0; k<4; k++) Cnt[Nr[l]]--, rotate(Nr[l]);\n\t\tfor(int r=l+1; r<N; r++) {\n\t\t\tfor(int k=0; k<4; k++) Cnt[Nr[r]]--, rotate(Nr[r]);\n\t\t\tfor(int rt=0; rt<4; rt++) {\n\t\t\t\tfor(int k=0; k<4; k++) cube[4+k] = Nr[r][(k+rt)%4];\n\t\t\t\tll now = 1;\n\t\t\t\tvector<vector<int>> faces;\n\t\t\t\tfor(int f=0; f<4; f++) {\n\t\t\t\t\tvector<int> face(4, 0);\n\t\t\t\t\tfor(int k=0; k<4; k++) face[k] = cube[faceIx[f][k]];\n\t\t\t\t\tif((now *= Cnt[face]) == 0) break;\n\t\t\t\t\tfaces.push_back(face);\n\t\t\t\t\tfor(int k=0; k<4; k++) Cnt[face]--, rotate(face);\n\t\t\t\t}\n\t\t\t\tans += now;\n\t\t\t\tfor(int f=0; f<SZ(faces); f++) for(int k=0; k<4; k++) Cnt[faces[f]]++, rotate(faces[f]);\n\t\t\t}\n\t\t\tfor(int k=0; k<4; k++) Cnt[Nr[r]]++, rotate(Nr[r]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\n\nclass AAtCoDeerBuildingCubesWithAtCoDeer {\npublic:\n\n    ll ncr(ll n, ll r){\n        ll ans=1;\n        if(n<r)\n            return 0;\n        for(ll i=n;i>n-r;i--)\n            ans*=i;\n\n        return ans;\n    }\n    vector<int> min_rotation(vector<int> s) {\n        int a=0, N=s.size();\n        for(int i=0;i<N;i++)\n            s.push_back(s[i]);\n        for(int b=0;b<N;b++) for(int i=0;i<N;i++) {\n            if (a+i == b || s[a+i] < s[b+i]) {b += max(0, i-1);\n                break;}\n            if (s[a+i] > s[b+i]) { a = b; break; }\n        }\n        return vector<int>(s.begin()+a, s.begin()+a+N);\n    }\n    int cntRotation(vector<int> v){\n        vector<int> rv=v;\n        int ans=0;\n        for(int i=0;i<4;i++){\n            if(rv==v)\n                ans++;\n            rv.push_back(rv[0]);\n            rv.erase(rv.begin());\n        }\n        return ans;\n    }\n    ll cnt(map<vector<int>, int> &mp, map<vector<int>,int> &req){\n        ll ans=1;\n        for(auto it:req){\n            if(mp.find(it.first)==mp.end())\n                return 0;\n            ll val=ncr(mp[it.first],it.second);\n            ll rot=cntRotation(it.first);\n            for(int i=0;i<it.second;i++)\n                val*=rot;\n            ans*=val;\n        }\n        return ans;\n\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n        map<vector<int>,int> mp;\n        vector<vector<int>> v;\n        for(int i=0;i<n;i++){\n            vector<int> s(4);\n            for(int j=0;j<4;j++)\n                cin>>s[j];\n            s=min_rotation(s);\n            mp[s]++;\n            v.push_back(s);\n        }\n        ll ans=0;\n        for(int i=0;i<n;i++){\n            mp[v[i]]--;\n            for(int j=0;j<n;j++){\n                if(i==j)\n                    continue;\n\n                mp[v[j]]--;\n                //v[i] at bottom v[j] at top;\n                for(int rotation=0;rotation<4;rotation++){\n                    //use v[j]\n                    map<vector<int>,int> req;\n                    req[min_rotation({v[i][0],v[i][3],v[j][0],v[j][3]})]++;\n                    req[min_rotation({v[i][3],v[i][2],v[j][1],v[j][0]})]++;\n                    req[min_rotation({v[i][2],v[i][1],v[j][2],v[j][1]})]++;\n                    req[min_rotation({v[i][1],v[i][0],v[j][3],v[j][2]})]++;\n                    ans+=cnt(mp, req);\n                    v[j].push_back(v[j][0]);\n                    v[j].erase(v[j].begin());\n\n                }\n\n                mp[v[j]]++;\n            }\n            mp[v[i]]++;\n        }\n        cout<<ans/6<<endl;\n\t}\n};\n\n\nint main() {\n\tAAtCoDeerBuildingCubesWithAtCoDeer solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef ONLINE_JUDGE\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int N; cin >> N;\n    vector<array<int, 4>> C(N);\n    rep(i,N) rep(j,4) cin >> C[i][j];\n\n    auto calc=[](const array<int, 4> &arr) {\n        array<array<int, 4>, 4> A;\n        rep(i,4) {\n            rep(j,4) {\n                A[i][j] = arr[(i+j)%4];\n            }\n        }\n\n        sort(all(A));\n\n        ll hash = 0;\n        ll k = 1;\n        if (A[0]==A[1] and A[1]==A[2] and A[2]==A[3]) k = 4;\n        else if (A[0]==A[1] and A[2]==A[3]) k = 2;\n        ll b = 1;\n        rep(i,4) {\n            hash += A[0][i]*b;\n            b *= 1000;\n        }\n        return pll(hash,k);\n    };\n\n    map<ll, ll> dic;\n    rep(i,N) {\n        auto[hash,k] = calc(C[i]);\n        dic[hash]++;\n    }\n\n    array<array<int, 4>, 4> sokumen;\n    vector<ll> D,kai,cnt;\n    ll ans = 0;\n    rep(i,N) {\n        {\n            auto[hash,k] = calc(C[i]);\n            dic[hash]--;\n        }\n\n        rep(j,i) {\n            {\n                auto[hash,k] = calc(C[j]);\n                dic[hash]--;\n            }\n\n            rep(k,4) { //底面の回転\n                D.clear();\n                kai.clear();\n                cnt.clear();\n                rep(l,4) {\n                    sokumen[l][0] = C[i][3-l];\n                    sokumen[l][1] = C[i][(6-l)%4];\n                    sokumen[l][2] = C[j][(1+l+k)%4];\n                    sokumen[l][3] = C[j][(l+k)%4];\n                }\n\n                rep(l,4) {\n                    auto[hash,k] = calc(sokumen[l]);\n                    bool same = false;\n                    rep(x,SZ(D)) {\n                        if (D[x]==hash) {\n                            same = true;\n                            cnt[x]++;\n                            break;\n                        }\n                    }\n                    if (!same) {\n                        D.emplace_back(hash);\n                        kai.emplace_back(k);\n                        cnt.emplace_back(1);\n                    }\n                }\n\n                ll val = 1;\n                rep(x,SZ(D)) {\n                    ll c = dic.count(D[x]) ? dic[D[x]] : 0;\n                    rep(y,cnt[x]) {\n                        val *= c;\n                        c--;\n                        val *= kai[x];\n                    }\n                }\n\n                ans += val;\n            }\n\n            {\n                auto[hash,k] = calc(C[j]);\n                dic[hash]++;\n            }\n        }\n\n        {\n            auto[hash,k] = calc(C[i]);\n            dic[hash]++;\n        }\n    }\n\n    cout << ans/3 << ln;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile &a, tile &b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) {return a.color[i] < b.color[i];}\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) {tmp.color[i] = t.color[i];}\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    for (int j = 0; j < 4; ++j) {tmp.color[j] = comp.color[j];}\n  }\n}\n\nbool same(tile &a, tile &b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= (a.color[i] == b.color[i]);\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile &s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile &s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) {\n      cin >> t[i].color[j];\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {regulation(t[i]);}\n  sort(t, t+N, comp_tile);\n\n\n  ll ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) {top.color[k] = t[i].color[k];}\n        for (int k = 0; k < 4; ++k) {bottom.color[k] = t[j].color[k];}\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) {tmp1.color[l] = bottom.color[l];}\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) {regulation(sides[l]);}\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) {tmp.color[n] = sides[m].color[n];}\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) ++symmetry_count[m];\n              for (int l = 0; l < 4; ++l) {tmp.color[l] = cmp.color[l];}\n            }\n          }\n\n          ll tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) {\n              if (same(sides[n],sides[m])) ++x;\n            }\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= (match_count[m] - x);\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define fo(f) freopen(f\".in\",\"r\",stdin);freopen(f\".out\",\"w\",stdout);\n#define gc getchar()\ninline int read()\n{\n\tint x=0;char c=gc;\n\tfor(;c<48||c>57;c=gc);\n\tfor(;c>47&&c<58;c=gc)\n\t\tx=(x<<1)+(x<<3)+c-48;\n\treturn x;\n}\n\ntypedef long long ll;\n#define maxn 405\nint n;\nstruct data\n{\n\tint c[4];\n\tdata(int c0=0,int c1=0,int c2=0,int c3=0)\n\t{\n\t\tc[0]=c0;c[1]=c1;c[2]=c2;c[3]=c3;\n\t}\n\tinline friend bool operator<(data a,data b)\n\t{\n\t\tfor(int i=0;i<4;++i)\n\t\t\tif(a.c[i]^b.c[i])return a.c[i]<b.c[i];\n\t\treturn 0;\n\t}\n\tinline void rotate()\n\t{\n\t\tint t=c[0];\n\t\tc[0]=c[1];c[1]=c[2];c[2]=c[3];c[3]=t;\n\t}\n\tinline friend bool operator==(data a,data b)\n\t{\n\t\tfor(int j=0;j<4;++j)\n\t\t{\n\t\t\tint fl=1;\n\t\t\tfor(int i=0;i<4;++i)\n\t\t\t\tif(a.c[i]!=b.c[(i+j)&3])\n\t\t\t\t{\n\t\t\t\t\tfl=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(fl)return true;\n\t\t}\n\t\treturn false;\n\t}\n}sq[maxn];\nmap<data,int> mp;\n\ninline void inc(data d)\n{\n\tfor(int i=0;i<4;++i)\n\t{\n\t\t++mp[d];\n\t\td.rotate();\n\t}\n}\ninline void dec(data d)\n{\n\tfor(int i=0;i<4;++i)\n\t{\n\t\t--mp[d];\n\t\td.rotate();\n\t}\n}\n\ninline void init()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<4;++j)\n\t\t\tsq[i].c[j]=read();\n\t\tinc(sq[i]);\n\t}\n}\n\nll ans;\n\ninline void calc(data l,data r,data u,data d)\n{\n\tif(!mp[l]||!mp[r]||!mp[u]||!mp[d])return;\n\tll a=mp[l],b,x,y;\n\tdec(l);\n\tb=mp[r];\n\tdec(r);\n\tx=mp[u];\n\tdec(u);\n\ty=mp[d];\n\tinc(u);\n\tinc(r);\n\tinc(l);\n\tans+=a*b*x*y;\n}\n\ninline void solve()\n{\n\n\tdata l,r,u,d;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tdec(sq[i]);\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tdec(sq[j]);\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tl=data(sq[j].c[1],sq[i].c[0],sq[i].c[3],sq[j].c[2]);\n\t\t\t\tr=data(sq[i].c[1],sq[j].c[0],sq[j].c[3],sq[i].c[2]);\n\t\t\t\tu=data(sq[j].c[1],sq[j].c[0],sq[i].c[1],sq[i].c[0]);\n\t\t\t\td=data(sq[i].c[3],sq[i].c[2],sq[j].c[3],sq[j].c[2]);\n\t\t\t\tcalc(l,r,u,d);\n\t\t\t\tsq[i].rotate();\n\t\t\t}\n\t\t\tinc(sq[j]);\n\t\t}\n\t\tinc(sq[i]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n}\n\nint main()\n{\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint c[444][4],n;\nint num[4][444];\nvoid fd(int*num,int A,int B,int C,int D,int from,int no){\n\tmemset(num,0,sizeof(int)*n);\n\tfor(int i=from+1; i<n; i++)if(i!=no){\n\t\tnum[i] = 0;\n\t\tfor(int k=0; k<4; k++)\n\t\t\tif(c[i][k%4] == A && \n\t\t\t\tc[i][(k+1)%4] == B &&\n\t\t\t\tc[i][(k+2)%4] == C &&\n\t\t\t\tc[i][(k+3)%4] == D)\n\t\t\t\tnum[i] ++;\n\t}\n}\n#define mod 1000000007\nint add(int x,int y){\n\treturn (x+=y)<mod?x:x-mod;\n}\nint sub(int x,int y){\n\treturn (x-=y)>=0?x:x+mod;\n}\nint mul(int x,int y){\n\treturn (int)((long long int)x*y%mod);\n}\nint calc(int id1,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres = add(res, num[id1][i]);\n\treturn res;\n}\nint calc(int id1,int id2,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres = add(res, num[id1][i]*num[id2][i]);\n\treturn res;\n}\nint calc(int id1,int id2,int id3,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres = add(res, num[id1][i]*num[id2][i]*num[id3][i]);\n\treturn res;\n}\nint calc(int id1,int id2,int id3,int id4,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres = add(res, num[id1][i]*num[id2][i]*num[id3][i]*num[id4][i]);\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<4; j++)\n\t\t\tscanf(\"%d\",&c[i][j]);\n\tint res=0;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=i+1; j<n; j++)\n\tfor(int k=0; k<4; k++){\n\t\tint A = c[i][0];\n\t\tint B = c[i][1];\n\t\tint C = c[i][2];\n\t\tint D = c[i][3];\n\t\tint E = c[j][k%4];\n\t\tint F = c[j][(k+1)%4];\n\t\tint G = c[j][(k+2)%4];\n\t\tint H = c[j][(k+3)%4];\n\t\tfd(num[0], B, E, H, C, i, j);\n\t\tfd(num[1], A, D, G, F, i, j);\n\t\tfd(num[2], F, E, B, A, i, j);\n\t\tfd(num[3], H, G, D, C, i, j);\n\n\t\tint A0 = calc(0,i);\n\t\tint A1 = calc(1,i);\n\t\tint A2 = calc(2,i);\n\t\tint A3 = calc(3,i);\n\t\tint A01 = calc(0,1,i);\n\t\tint A02 = calc(0,2,i);\n\t\tint A03 = calc(0,3,i);\n\t\tint A12 = calc(1,2,i);\n\t\tint A13 = calc(1,3,i);\n\t\tint A23 = calc(2,3,i);\n\t\tint A012 = calc(0,1,2,i);\n\t\tint A013 = calc(0,1,3,i);\n\t\tint A023 = calc(0,2,3,i);\n\t\tint A123 = calc(1,2,3,i);\n\t\tint A0123 = calc(0,1,2,3,i);\n\n\t\tres = add(res, mul(mul(A0,A1),mul(A2,A3)));\n\t\tres = sub(res, mul(mul(A2,A3),A01));\n\t\tres = sub(res, mul(mul(A1,A3),A02));\n\t\tres = sub(res, mul(mul(A1,A2),A03));\n\t\tres = sub(res, mul(mul(A0,A3),A12));\n\t\tres = sub(res, mul(mul(A0,A2),A13));\n\t\tres = sub(res, mul(mul(A0,A1),A23));\n\t\tres = add(res, mul(A01,A23));\n\t\tres = add(res, mul(A02,A13));\n\t\tres = add(res, mul(A03,A12));\n\t\tres = add(res, mul(mul(A0,A123),2));\n\t\tres = add(res, mul(mul(A1,A023),2));\n\t\tres = add(res, mul(mul(A2,A013),2));\n\t\tres = add(res, mul(mul(A3,A012),2));\n\t\tres = sub(res, mul(A0123,6));\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\nconst int MAXN=405;\n\nlong long encode(int a,int b,int c,int d)\n{\n\treturn (a<<30LL)|(b<<20LL)|(c<<10LL)|d;\n}\n\nmap<long long,long long> cnt;\nvoid Add(long long c,int delta)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tcnt[c]+=delta;\n\t\tc=(c>>10LL)|((c&1023)<<30);\n\t}\n}\n\nint n;\nint c[MAXN][4];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",c[i],c[i]+1,c[i]+2,c[i]+3);\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint u[4]=\n\t\t\t\t{encode(c[j][(k+0)%4],c[j][(k+1)%4],c[i][1],c[i][0]),\n\t\t\t\t encode(c[j][(k+1)%4],c[j][(k+2)%4],c[i][2],c[i][1]),\n\t\t\t\t encode(c[j][(k+2)%4],c[j][(k+3)%4],c[i][3],c[i][2]),\n\t\t\t\t encode(c[j][(k+3)%4],c[j][(k+0)%4],c[i][0],c[i][3])\n\t\t\t\t};\n\t\t\t\tlong long tmp=1;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\ttmp*=cnt[u[l]],Add(u[l],-1);\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tAdd(u[l],1);\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\ntypedef tuple<int, int, int, int> TP;\nTP narabi(int a, int b, int c, int d) {\n\tTP kari[4];\n\tkari[0] = tie(a, b, c, d);\n\tkari[1] = tie(b, c, d, a);\n\tkari[2] = tie(c, d, a, b);\n\tkari[3] = tie(d, a, b, c);\n\treturn *min_element(kari, kari + 4);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tTP C[400];\n\trep(i, N) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tC[i] = narabi(a, b, c, d);\n\t}\n\n\tsort(C, C + N);\n\tint kazu[400] = {};\n\trep(i, N) {\n\t\tint k = i;\n\t\twhile (k + 1 < N && C[k + 1] == C[i]) k++;\n\t\tkazu[i] = k - i + 1;\n\t\ti = k;\n\t}\n\n\tll kotae = 0;\n\trep(i, N) rep(j, N) if (i != j) {\n\t\tint inum = lower_bound(C, C + N, C[i]) - C;\n\t\tint jnum = lower_bound(C, C + N, C[j]) - C;\n\n\t\tkazu[inum]--;\n\t\tkazu[jnum]--;\n\n\t\tint a, b, c, d, e, f, g, h;\n\t\ta = get<0>(C[i]);\n\t\tb = get<1>(C[i]);\n\t\tc = get<2>(C[i]);\n\t\td = get<3>(C[i]);\n\t\te = get<0>(C[j]);\n\t\tf = get<1>(C[j]);\n\t\tg = get<2>(C[j]);\n\t\th = get<3>(C[j]);\n\n\t\trep(x, 4) {\n\t\t\tTP D[4];\n\t\t\tD[0] = narabi(a, d, f, e);\n\t\t\tD[1] = narabi(a, e, h, b);\n\t\t\tD[2] = narabi(b, h, g, c);\n\t\t\tD[3] = narabi(c, g, f, d);\n\t\t\tTP* itr[4];\n\t\t\trep(k, 4) itr[k] = lower_bound(C, C + N, D[k]);\n\t\t\tll kari = 1;\n\t\t\trep(k, 4) {\n\t\t\t\tif (itr[k] != C + N && *(itr[k]) == D[k]) {\n\t\t\t\t\tkari *= kazu[itr[k] - C]--;\n\t\t\t\t\tif (get<0>(D[k]) == get<2>(D[k]) && get<1>(D[k]) == get<3>(D[k])) {\n\t\t\t\t\t\tkari *= 2;\n\t\t\t\t\t\tif (get<1>(D[k]) == get<2>(D[k])) kari *= 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkari = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tif (itr[k] != C + N && *itr[k] == D[k]) {\n\t\t\t\t\tkazu[itr[k] - C]++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tkotae += kari;\n\n\t\t\tint tmp = e;\n\t\t\te = f;\n\t\t\tf = g;\n\t\t\tg = h;\n\t\t\th = tmp;\n\t\t}\n\t\tkazu[inum]++;\n\t\tkazu[jnum]++;\n\t}\n\tco(kotae / 6);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<map>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=410;\nstruct State {\n\tint a,b,c,d;\n\tbool operator < (const State& S) const {\n\t\tif(a!=S.a) return a<S.a;\n\t\tif(b!=S.b) return b<S.b;\n\t\tif(c!=S.c) return c<S.c;\n\t\treturn d<S.d;\n\t}\n\tbool operator == (const State& S) {\n\t\treturn a==S.a&&b==S.b&&c==S.c&&d==S.d;\n\t}\n}A[maxn][4];\nconst int HASH=152501;\nstruct Hash_Table {\n\tint first[HASH],nxt[maxn*4],sum[maxn*4],cnt;\n\tll val[maxn*4];\n\tint find(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) return sum[i];\n\t\treturn -HASH;\n\t}\n\tvoid add(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) {sum[i]++;return;}\n\t\tval[++cnt]=x;sum[cnt]=1;nxt[cnt]=first[p];first[p]=cnt;\n\t}\n\tvoid del(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) {sum[i]--;return;}\n\t}\n}M;\n#define hash(a,b,c,d) ((((ll)(a))<<30)+((b)<<20)+((c)<<10)+(d))\nvoid del(State x) {\n\tM.del(hash(x.a,x.b,x.c,x.d));\n\tM.del(hash(x.b,x.c,x.d,x.a));\n\tM.del(hash(x.c,x.d,x.a,x.b));\n\tM.del(hash(x.d,x.a,x.b,x.c));\n}\nvoid add(State x) {\n\tM.add(hash(x.a,x.b,x.c,x.d));\n\tM.add(hash(x.b,x.c,x.d,x.a));\n\tM.add(hash(x.c,x.d,x.a,x.b));\n\tM.add(hash(x.d,x.a,x.b,x.c));\n}\nint main() {\n\tint n=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tA[i][0]=(State){a,b,c,d};\n\t\tA[i][1]=(State){b,c,d,a};\n\t\tA[i][2]=(State){c,d,a,b};\n\t\tA[i][3]=(State){d,a,b,c};\n\t\tM.add(hash(a,b,c,d));M.add(hash(c,d,a,b));\n\t\tM.add(hash(b,c,d,a));M.add(hash(d,a,b,c));\n\t}\n\tll ans=0;\n\trep(i,1,n) rep(j,i+1,n) if(i!=j) {\n\t\tdel(A[i][0]);del(A[j][0]);\n\t\trep(y,0,3) {\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t\tState S[4];\n\t\t\tS[0]=(State){A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b};\n\t\t\tS[1]=(State){A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b};\n\t\t\tS[2]=(State){A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d};\n\t\t\tS[3]=(State){A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d};\n\t\t\tint c1=M.find(hash(A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b));del(S[0]);\n\t\t\tint c2=M.find(hash(A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b));del(S[1]);\n\t\t\tint c3=M.find(hash(A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d));del(S[2]);\n\t\t\tint c4=M.find(hash(A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d));del(S[3]);\n\t\t\tif(c1>0&&c2>0&&c3>0&&c4>0) ans+=(ll)c1*c2*c3*c4;\n\t\t\tif(c1!=-HASH) add(S[0]);\n\t\t\tif(c2!=-HASH) add(S[1]);\n\t\t\tif(c3!=-HASH) add(S[2]);\n\t\t\tif(c4!=-HASH) add(S[3]);\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t}\n\t\tadd(A[i][0]);add(A[j][0]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i) for(int i=0;i<4;i++)\nusing ll=long long;\nusing Token=array<int,4>;\nvoid norm(Token& t){\n    Token res = t;\n    rep(_){\n        Token sft = {t[(1+_)%4],t[(2+_)%4],t[(3+_)%4],t[_]};\n        res = min(res, sft);\n    }\n    t = res;\n}\nll repeat(const Token& t) {\n    if (t[0] != t[2]) return 1;\n    if (t[1] != t[3]) return 1;\n    return t[0]==t[1]?4:2;\n}\nvoid solve() {\n    int n; cin >> n;\n    vector<Token> a(n);\n    map<Token, ll> cnt;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i][0] >> a[i][1] >> a[i][2] >> a[i][3];\n        norm(a[i]);\n        cnt[a[i]]++;\n    }\n    ll res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            rep(k){\n                Token U = {a[j][(1+k)%4], a[j][(0+k)%4], a[i][1], a[i][0]}; norm(U);\n                Token R = {a[i][1], a[j][(0+k)%4], a[j][(3+k)%4], a[i][2]}; norm(R);\n                Token D = {a[i][2], a[j][(3+k)%4], a[j][(2+k)%4], a[i][3]}; norm(D);\n                Token L = {a[j][(1+k)%4], a[i][0], a[i][3], a[j][(2+k)%4]}; norm(L);\n                ll tmp = 1;\n                ll d = cnt[U] - (a[i]==U) - (a[j]==U);\n                tmp *= d>0?d:0;\n                d = cnt[R] - (a[i]==R) - (a[j]==R) - (U==R);\n                tmp *= d>0?d:0;\n                d = cnt[D] - (a[i]==D) - (a[j]==D) - (U==D) - (R==D);\n                tmp *= d>0?d:0;\n                d = cnt[L] - (a[i]==L) - (a[j]==L) - (U==L) - (R==L) - (D==L);\n                tmp *= repeat(U);\n                tmp *= repeat(R);\n                tmp *= repeat(D);\n                tmp *= repeat(L);\n                res += tmp;\n            }\n        }\n    }\n    res /= 3;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\ninline vi normarize(const vi &v)\n{\n    vector<vi> r(4);\n    rep(i,4)\n    {\n        vi t(4);\n        rep(j,4) t[j]=v[(i+j)%4];\n        r[i]=t;\n    }\n    sort(all(r));\n    return r[0];\n}\n\ninline ll DIM(const vi &v)\n{\n    if(v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) return 4;\n    if(v[0]==v[2] && v[1]==v[3]) return 2;\n    return 1;\n}\n\nint main()\n{\n    ll P[401][5]={0};\n    for(int i=1; i<=400; ++i)\n    {\n        P[i][1]=i;\n        for(int j=2; j<=min(4,i); ++j) P[i][j]=P[i][j-1]*(i-j+1);\n    }\n\n    ll POW[5][5];\n    rep(i,5)\n    {\n        POW[i][0]=1;\n        for(int j=1; j<5; ++j) POW[i][j]=POW[i][j-1]*i;\n    }\n\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<vi> c(n,vi(4));\n    rep(i,n)rep(j,4) scanf(\" %d\", &c[i][j]);\n\n    map<vi,int> ct;\n    rep(i,n)\n    {\n        c[i]=normarize(c[i]);\n        if(ct.find(c[i])==ct.end()) ct[c[i]]=1;\n        else ++ct[c[i]];\n    }\n\n    ll ans=0;\n    // 上面i, 下面j, 下面の向きを設定\n    rep(i,n)rep(j,i)rep(k,4)\n    {\n        vi u(4);\n        rep(x,4) u[x]=c[j][(k+x)%4];\n        swap(u[1],u[3]);\n\n        vector<vi> sides(4);\n        rep(x,4)\n        {\n            vi t(4);\n            t[0]=c[i][(x+1)%4];\n            t[1]=c[i][x];\n            t[2]=u[x];\n            t[3]=u[(x+1)%4];\n            sides[x]=normarize(t);\n        }\n        sort(all(sides));\n\n        ll add=1;\n        int idx=0, st=0;\n        while(1)\n        {\n            while(idx<4 && sides[st]==sides[idx]) ++idx;\n            vi key=sides[st];\n            int value=idx-st;\n\n            // 使ってないタイルのうち当てはめられる個数\n            int num=ct[key];\n            if(c[i]==key) --num;\n            if(c[j]==key) --num;\n\n            if(num<value)\n            {\n                add=0;\n                break;\n            }\n\n            // 選び方、向き、位置\n            add*=P[num][value]*POW[DIM(key)][value];\n\n            if(idx==4) break;\n            st=idx;\n        }\n        ans+=add;\n    }\n\n    // 向かい合う面の個数ぶん重複する\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    unordered_map<C, int> P;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}});\n                    int opts = P[u[l]];\n                    if (u[l] == p) --opts;\n                    if (u[l] == q) --opts;\n                    for (int m = 0; m < l; m++) {\n                        if (u[m] == u[l]) --opts;\n                    }\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*rot(u[l]);\n                    }\n                }\n                ans += cur;\n            }\n        }\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nvi rotate_square(vi a) {\n  a.push_back(a[0]);\n  a.erase(a.begin());\n  return a;\n}\n\nvi normalize_square(vi a) {\n  vii temp;\n  rep (i, 4) {\n    temp.push_back(a);\n    a = rotate_square(a);\n  }\n  sort(all(temp));\n  return temp[0];\n}\n\n\nclass Box {\npublic:\n  vi color;\n  \n  Box(){\n    color.resize(8);\n  }\n  void set_up(vi a) {\n    rep (i, 4) color[i] = a[i];\n  }\n  void set_down(vi a) {\n    rep (i, 4) color[i + 4] = a[3 - i];\n  }\n\n  vii get_side() {\n    vii res(4, vi(4));\n    rep (i, 4) {\n      res[i][0] = i;\n      res[i][1] = (i + 3) % 4;\n      res[i][2] = res[i][1] + 4;\n      res[i][3] = res[i][2] + 1;\n      if (res[i][3] == 8) res[i][3] = 4;\n      rep (j, 4) {\n        res[i][j] = color[res[i][j]];\n      }\n    }\n    return res;\n  }\n  \n};\n\nll nCr(ll n, ll r) {\n  assert(r <= 4);\n  ll ans = 1;\n  rep (i, r) {\n    ans *= n;\n    n--;\n  }\n  return ans;\n}\n\nint square_num(vi a) {\n  vi initial = a;\n  int ans = 0;\n  rep (i, 4) {\n    if (initial == a) ans++;\n    a = rotate_square(a);\n  }\n  return ans;\n}\n\nll solve(Box box, vii& c) {\n  if (c.size() < 4) return 0;\n  vii sides = box.get_side();\n  map<vi, int> mp;\n  rep (i, 4) {\n    sides[i] = normalize_square(sides[i]);\n    mp[sides[i]] = 0;\n  }\n\n  rep (i, c.size()) {\n    if (mp.count(c[i])) {\n      mp[c[i]]++;\n    }\n  }\n\n  ll ans = 1;\n  rep (i, 4) {\n    ll n = mp[sides[i]];\n    ans = ans * n * square_num(sides[i]);\n    mp[sides[i]]--;\n  }\n  return ans;\n}\n\nsigned main() {\n  int n;\n  cin >> n;\n\n  vii c(n, vi(4));\n  rep (i, n) {\n    rep (j, 4) {\n      cin >> c[i][j];\n    }\n    c[i] = normalize_square(c[i]);\n  }\n\n  Box box;\n  ll ans = 0;\n  rep (i, n) {\n    box.set_up(c[i]);\n    for (int j = i + 1; j < n; j++) {\n      vi ccc = c[j];\n      rep (_, 4) {\n        box.set_down(ccc);\n        vii temp;\n        for (int k = i + 1; k < n; k++) {\n          if (j == k) continue;\n          temp.push_back(c[k]);\n        }\n        ll add = solve(box, temp);\n        ans += add;\n        ccc = rotate_square(ccc);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint num[4][4]={{2, 5, 4, 3}, {0, 7, 6, 1}, {1, 6, 5, 2}, {3, 4, 7, 0}};\nint main()\n{\n\tint n;\n\tcin>>n;\n\tunordered_map<ll, ll> mp;\n\tvector<ll> c;\n\tfor(int i=0; i<n; i++){\n\t\tll c1[4], cp[4];\n\t\tfor(int j=0; j<4; j++) cin>>c1[j];\n\t\tfor(int j=0; j<4; j++){\n\t\t\tll p=1; cp[j]=0;\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tcp[j]+=(c1[(j+k)%4]*p);\n\t\t\t\tp*=1000;\n\t\t\t}\n\t\t}\n\t\tsort(cp, cp+4);\n\t\tmp[cp[0]]++;\n\t}\n\tfor(auto p:mp) c.push_back(p.first);\n\tll ans=0;\n\tfor(int i=0; i<c.size(); i++){\n\t\tll c2[8];\n\t\tll c1=c[i];\n\t\tfor(int j=0; j<4; j++){\n\t\t\tc2[j]=c1%1000;\n\t\t\tc1/=1000;\n\t\t}\n\t\tfor(int j=0; j<c.size(); j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tll c3=c[j];\n\t\t\t\tfor(int l=0; l<4; l++){\n\t\t\t\t\tc2[4+(k+l)%4]=c3%1000; c3/=1000;\n\t\t\t\t}\n\t\t\t\tfor(int q=0; q<256; q++){\n\t\t\t\t\tunordered_map<ll, int> mp2;\n\t\t\t\t\tmp2[c[i]]++; mp2[c[j]]++;\n\t\t\t\t\tint q1=q;\n\t\t\t\t\tfor(int l=0; l<4; l++){\n\t\t\t\t\t\tll p=1, c4=0;\n\t\t\t\t\t\tfor(int m=0; m<4; m++){\n\t\t\t\t\t\t\tc4+=c2[num[l][(m+q1)%4]]*p;\n\t\t\t\t\t\t\tp*=1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmp2[c4]++;\n\t\t\t\t\t\tq1/=4;\n\t\t\t\t\t}\n\t\t\t\t\tll ans1=1;\n\t\t\t\t\tfor(auto p:mp2){\n\t\t\t\t\t\tll x=mp[p.first];\n\t\t\t\t\t\tfor(ll l=0; l<p.second; l++){\n\t\t\t\t\t\t\tans1*=(x-l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans+=ans1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nvector<int> rot(vector<int> &v) {\n\tvector<int> ret(4);\n\tfor (int i = 0; i < 4; i++) {\n\t\tret[i] = v[(i + 1) % 4];\n\t}\n\treturn ret;\n}\nvector<int> lex_min(vector<int> v) {\n\tvector<int> ret = v;\n\tfor (int i = 1; i < 4; i++) {\n\t\tv = rot(v);\n\t\tret = min(ret, v);\n\t}\n\treturn ret;\n}\nvector<int> tile[400];\nmap<vector<int>, int> cnt;\nmap<vector<int>, int> same;\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<int> v;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tv.push_back(C);\n\t\t}\n\t\tv = lex_min(v);\n\t\ttile[i] = v;\n\t\tcnt[v]++;\n\t\tsame[v] = 1;\n\t\tvector<int> t = v;\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\tt = rot(t);\n\t\t\tif (v == t) same[v]++;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcnt[tile[i]]--;\n\t\tvector<int> v1 = tile[i];\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tcnt[tile[j]]--;\n\t\t\tvector<int> v2 = tile[j];\n\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\tmap<vector<int>, int> use;\n\t\t\t\tvector<int> v(4);\n\t\t\t\tv[0] = v1[0]; v[1] = v1[3]; v[2] = v2[2]; v[3] = v2[1];\n\t\t\t\tv = lex_min(v);\n\t\t\t\tuse[v]++;\n\t\t\t\tv[0] = v1[3]; v[1] = v1[2]; v[2] = v2[3]; v[3] = v2[2];\n\t\t\t\tv = lex_min(v);\n\t\t\t\tuse[v]++;\n\t\t\t\tv[0] = v1[2]; v[1] = v1[1]; v[2] = v2[0]; v[3] = v2[3];\n\t\t\t\tv = lex_min(v);\n\t\t\t\tuse[v]++;\n\t\t\t\tv[0] = v1[1]; v[1] = v1[0]; v[2] = v2[1]; v[3] = v2[0];\n\t\t\t\tv = lex_min(v);\n\t\t\t\tuse[v]++;\n\t\t\t\tll t = 1;\n\t\t\t\tfor (auto p : use) {\n\t\t\t\t\tif (cnt.find(p.first) == cnt.end() || cnt[p.first] < p.second) {\n\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < p.second; i++) {\n\t\t\t\t\t\tt *= cnt[p.first] - i;\n\t\t\t\t\t\tt *= same[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\tv2 = rot(v2);\n\t\t\t}\n\t\t\tcnt[tile[j]]++;\n\t\t}\n\t\tcnt[tile[i]]++;\n\t}\n\tcout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll X = 1000;\n\nll h(vec<int> C){\n    ll res = 0,r = 1;\n    for(int i=0;i<4;i++){\n        res += C[i]*r;\n        r *= X;\n    }\n    return res;\n}\n\nvoid set_hash(vec<int> C,unordered_map<ll,ll>& mp,int d){\n    for(int i=0;i<4;i++){\n        ll c = h(C);\n        mp[c] += d;\n        int a = C[0];\n        C.erase(C.begin());\n        C.push_back(a);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    unordered_map<ll,ll> mp;\n    vvec<int> C(N,vec<int>(4));\n    for(int i=0;i<N;i++){\n        for(int k=0;k<4;k++) cin >> C[i][k];\n        set_hash(C[i],mp,1);\n    }\n    ll ans = 0;\n    for(int i=0;i<N;i++){\n        ll c0 = h(C[i]);\n        ll now = 1;\n        set_hash(C[i],mp,-1);\n        for(int j=i+1;j<N;j++) for(int b=0;b<4;b++){\n            ll c1 = h(C[j]);\n            ll val = now;\n            set_hash(C[j],mp,-1);\n            for(int l=0;l<4;l++){\n                vec<int> D = {C[j][(4-l)%4],C[j][(4-l+3)%4],C[i][(l+1)%4],C[i][l]};\n                ll v = h(D);\n                val *= mp[v];\n                set_hash(D,mp,-1);\n            }\n            for(int l=0;l<4;l++){\n                vec<int> D = {C[j][(4-l)%4],C[j][(4-l+3)%4],C[i][(l+1)%4],C[i][l]};\n                set_hash(D,mp,1);\n            }\n            set_hash(C[j],mp,1);\n            int x = C[j][0];\n            C[j].erase(C[j].begin());\n            C[j].push_back(x);\n            ans += val;\n        }\n        set_hash(C[i],mp,1);\n    }\n    cout << ans/3 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) &&                                                     \\\n    (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst double PI = atan(1.0) * 4.0;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\nll calchash(VL v) {\n    ll mi = LINF;\n    REP(loop, 4) {\n        rotate(v.begin(), v.begin() + 1, v.end());\n        mi = min(mi, v[3] + v[2] * 1000 + v[1] * 1000000 + v[0] * 1000000000);\n    }\n    return mi;\n}\n\nll dfs(ll rem, ll n1, ll n2, ll n4) {\n    ll ret = 0;\n    if(rem == 0) return 1;\n    if(n1) ret += n1 * dfs(rem - 1, n1 - 1, n2, n4);\n    if(n2) ret += 2 * n2 * dfs(rem - 1, n1, n2 - 1, n4);\n    if(n4) ret += 4 * n4 * dfs(rem - 1, n1, n2, n4 - 1);\n    return ret;\n}\n\nsigned main() {\n    LCIN(N);\n    map<ll, ll> memo[5];\n    VVL x(N, VL(4));\n    VL hs(N), rs(N);\n    REP(i, N) {\n        VECCIN(x[i]);\n        ll h = calchash(x[i]);\n        ll r = 1;\n        if(x[i][0] == x[i][2] && x[i][1] == x[i][3]) {\n            if(x[i][0] == x[i][1])\n                r = 4;\n            else\n                r = 2;\n        }\n        hs[i] = h, rs[i] = r;\n        memo[r][h]++;\n    }\n    ll ans = 0;\n    REP(i, N) {\n        memo[rs[i]][hs[i]]--;\n        FOR(j, i + 1, N) {\n            memo[rs[j]][hs[j]]--;\n            REP(loop, 4) {\n                map<ll, ll> cnt;\n                cnt[calchash({x[i][1], x[i][0], x[j][1], x[j][0]})]++;\n                cnt[calchash({x[i][2], x[i][1], x[j][0], x[j][3]})]++;\n                cnt[calchash({x[i][3], x[i][2], x[j][3], x[j][2]})]++;\n                cnt[calchash({x[i][0], x[i][3], x[j][2], x[j][1]})]++;\n                ll tmp = 1;\n                FOREACH(c, cnt) {\n                    tmp *=\n                        dfs(c.se, memo[1][c.fi], memo[2][c.fi], memo[4][c.fi]);\n                    if(tmp == 0) break;\n                }\n                ans += tmp;\n                rotate(x[j].begin(), x[j].begin() + 1, x[j].end());\n            }\n            memo[rs[j]][hs[j]]++;\n        }\n    }\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nusing namespace std;\nnamespace IO{/*{{{*/\n\tconst int S=8005;\n\tchar buf[S];\n\tint pos;\n\tvoid Load(){\n\t\tfread(buf,1,S,stdin);\n\t\tpos=0;\n\t}\n\tchar getChar(){\n\t\treturn buf[pos++];\n\t}\n\tint getInt(){\n\t\tint x=0,f=1;\n\t\tchar c=getChar();\n\t\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}\n\t\twhile('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}\n\t\treturn x*f;\n\t}\n}/*}}}*/\nusing IO::getInt;\nconst int N=405;\nnamespace HASH{/*{{{*/\n\tconst int N=2005;\n\tconst int MOD=9875321;\n\tint sz,h[MOD],nex[N],val[N];\n\tll key[N];\n\tinline int getHash(ll x){\n\t\treturn x%MOD;\n\t}\n\tvoid add(ll x,int y){\n\t\tint pos=getHash(x),u;\n\t\tfor(u=h[pos];u&&nex[u]&&key[u]!=x;u=nex[u]);\n\t\tif(key[u]==x)\n\t\t\tval[u]+=y;\n\t\telse{\n\t\t\tif(!h[pos])\n\t\t\t\th[pos]=++sz;\n\t\t\telse nex[u]=++sz;\n\t\t\tkey[sz]=x;\n\t\t\tval[sz]=y;\n\t\t}\n\t}\n\tint query(ll x){\n\t\tint pos=getHash(x),u;\n\t\tfor(u=h[pos];u&&nex[u]&&key[u]!=x;u=nex[u]);\n\t\treturn key[u]==x?val[u]:0;\n\t}\n}/*}}}*/\nint n;\nint c[N][4];\ninline ll getKey(int *c){\n\treturn c[0]+c[1]*1000+1ll*c[2]*1000000+1ll*c[3]*1000000000;\n}\ninline void rotate(int *c){\n\tint c0=c[0];\n\tfor(int i=0;i<3;i++)\n\t\tc[i]=c[i+1];\n\tc[3]=c0;\n}\ninline void pattern_add(int *c,int x){\n\tfor(int i=0;i<4;i++){\n\t\tHASH::add(getKey(c),x);\t\n\t\trotate(c);\n\t}\n}\nvoid readData(){\n\tIO::Load();\n\tn=getInt();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tc[i][j]=getInt();\n\t\tpattern_add(c[i],1);\n\t}\n}\nvoid solve(){\n\tll ans=0;\n\tfor(int i=1;i<n;i++){\n\t\tpattern_add(c[i],-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tpattern_add(c[j],-1);\n\t\t\tfor(int l=0;l<4;l++){// rotate up face\n\t\t\t\tstatic int s[4]; //state of side face (iterated)\n\t\t\t\tll now=1;\n\t\t\t\tint k;\n\t\t\t\tbool flag=false;\n\t\t\t\tfor(k=0;k<4&&now;k++){// count 4 side faces\n\t\t\t\t\ts[3]=c[i][k]; s[2]=c[i][(k+1)%4]; s[0]=c[j][3-k]; s[1]=c[j][3-(k+1)%4];\n\t\t\t\t\tnow*=HASH::query(getKey(s));\n\t\t\t\t\tif(now)\n\t\t\t\t\t\tpattern_add(s,-1);\n\t\t\t\t\telse flag=true;\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t\tfor(k--;k>=0;k--){// backspace \n\t\t\t\t\ts[3]=c[i][k]; s[2]=c[i][(k+1)%4]; s[0]=c[j][3-k]; s[1]=c[j][3-(k+1)%4];\n\t\t\t\t\tif(!flag)\n\t\t\t\t\t\tpattern_add(s,1);\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\trotate(c[j]);\n\t\t\t}\n\t\t\tpattern_add(c[j],1);\t\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<algorithm>\nusing namespace std;\nlong get(int a,int b,int c,int d)\n{\n\tlong ret=a*1000000000L+b*1000000+c*1000+d;\n\tret=min(ret,b*1000000000L+c*1000000+d*1000+a);\n\tret=min(ret,c*1000000000L*d*1000000+a*1000+b);\n\tret=min(ret,d*1000000000L+a*1000000+b*1000+c);\n\treturn ret;\n}\nmap<long,set<int> >M;\nint a[400],b[400],c[400],d[400];\nint N;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tM[get(a[i],b[i],c[i],d[i])].insert(i);\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tswap(a[j],b[j]);\n\t\t\t\tswap(b[j],c[j]);\n\t\t\t\tswap(c[j],d[j]);\n\t\t\t\tlong t[4]={\n\t\t\t\t\tget(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tget(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tget(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tget(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(t[I]==t[J])cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tif(M.find(t[k])==M.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint C=M[t[k]].size();\n\t\t\t\t\tif(M[t[k]].find(i)!=M[t[k]].end())C--;\n\t\t\t\t\tif(M[t[k]].find(j)!=M[t[k]].end())C--;\n\t\t\t\t\tint L=1;\n\t\t\t\t\tif(t[k]==t[k]%1000*1001001001L)L=4;\n\t\t\t\t\telse if(t[k]==t[k]%1000000*1000001L)L=2;\n\t\t\t\t\tfor(int l=0;l<cc[k];l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=now*(C-l)*L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <unordered_map>\nusing namespace std;\nconst int MAXN=405;\ntypedef long long ll;\nstruct Node{\n\tint a,b,c,d;\n}a[MAXN];\nint n;\nunordered_map<ll,int>mp;\ninline ll gethsh(Node x)\n{\n\treturn (ll)x.a<<30|(ll)x.b<<20|(ll)x.c<<10|(ll)x.d;\n}\nll hsh[MAXN];\nbool flag=true;\ninline void add(ll x,int v)\n{\n\tfor(int i=0;i<4;++i,x=(x>>10)|((x&1023)<<30))\n\t\tmp[x]+=v;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tNode x;\n\t\tscanf(\"%d%d%d%d\",&x.a,&x.b,&x.c,&x.d);\n\t\ta[i]=x;\n\t\thsh[i]=gethsh(x);\n\t\tadd(hsh[i],1);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n-5;++i){\n\t\tadd(hsh[i],-1);\n\t\tNode x=a[i];\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tadd(hsh[j],-1);\n\t\t\tNode y=a[j];\n\t\t\tfor(int p2=0;p2<4;++p2){\n\t\t\t\tll now=1;\n\t\t\t\tll t[5]={0};\n\t\t\t\tt[0]=gethsh((Node){x.b,x.a,y.b,y.a});\n\t\t\t\tt[1]=gethsh((Node){x.c,x.b,y.a,y.d});\n\t\t\t\tt[2]=gethsh((Node){x.a,x.d,y.c,y.b});\n\t\t\t\tt[3]=gethsh((Node){x.d,x.c,y.d,y.c});\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tint o=mp.count(t[k])?mp[t[k]]:0;\n\t\t\t\t\tnow*=o;\n\t\t\t\t\tadd(t[k],-1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;++k)\n\t\t\t\t\tadd(t[k],1);\n\t\t\t\tans+=now;\n\t\t\t\tswap(y.a,y.b),swap(y.b,y.c),swap(y.c,y.d);\n\t\t\t}\n\t\t\tadd(hsh[j],1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<array<long,5>,5>,4> >M;\nmap<long,map<int,int> >Q;\nint a[400],b[400],c[400],d[400];\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tlong C=conv(a[i],b[i],c[i],d[i]);\n\t\tmap<long,int>now;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tnow[C]++;\n\t\t\tC=rotate(C);\n\t\t}\n\t\tfor(map<long,int>::iterator it=now.begin();it!=now.end();it++)\n\t\t{\n\t\t\tQ[it->first][i]=it->second;\n\t\t}\n\t}\n\tfor(map<long,map<int,int> >::iterator it=Q.begin();it!=Q.end();it++)\n\t{\n\t\tarray<array<array<long,5>,5>,4>&A=M[it->first];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(map<int,int>::iterator jt=it->second.begin();jt!=it->second.end();jt++)\n\t\t{\n\t\t\tsum+=jt->second;\n\t\t\tct[jt->second]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<5;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tif(j<k)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<4;i++)A[i][j][k]=A[i][k][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA[0][j][k]=sum-j-k;\n\t\t\t\tA[1][j][k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\t\tA[2][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\t\tA[3][j][k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\t}\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tnow*=M[t[k]][cc[k]-1][Q[t[k]][i]][Q[t[k]][j]];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <map>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define DBG1(a) cerr<<#a<<\" = \"<<(a)<<\"\\n\"\n#define DBG2(a,b) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n#define y1 frgrwegreg\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\n\nconst double PI = acos(-1.0);\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int MAX = 100017;\n\nstruct G\n{\n\tint a[4];\n\tint db;\n\n\tG()\n\t{\n\t\tdb = 1;\n\t}\n\n\tbool less(G t)\n\t{\n\t\treturn MP(MP(a[0],a[1]),MP(a[2],a[3])) > MP(MP(t.a[0],t.a[1]),MP(t.a[2],t.a[3]));\n\t}\n\n\tbool equals(G t)\n\t{\n\t\treturn MP(MP(a[0],a[1]),MP(a[2],a[3])) == MP(MP(t.a[0],t.a[1]),MP(t.a[2],t.a[3]));\n\t}\n\n\tvoid norm()\n\t{\n\t\tint b[4];\n\t\tFOR (i,0,4) b[i] = a[i];\n\t\tFOR (e,1,4)\n\t\tif (MP(MP(b[(0+e)%4], b[(1+e)%4]), MP(b[(2+e)%4], b[(3+e)%4])) < MP(MP(a[0],a[1]),MP(a[2],a[3])))\n\t\t{\n\t\t\tFOR (i,0,4) a[i] = b[(i+e)%4];\n\t\t}\n\t\tdb = 1;\n\t\tif (a[0] == a[2] && a[1] == a[3])\n\t\t{\n\t\t\tdb*=2;\n\t\t\tif (a[0] == a[1]) db*=2;\n\t\t}\n\t\t//cout << \"*\" << db << endl;\n\t}\n} W[1000];\nint n;\nLL ans = 0;\n\nint main()\n{\n\t//freopen(\"C.in\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\t//ios::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n;\n\tFOR (i,0,n)\n\t{\n\t\tFOR (j,0,4) cin >> W[i].a[j];\n\t\tW[i].norm();\n\t\t//FOR (j,0,4) cout << W[i].a[j]<<\" \";\n\t\t//cout << endl;\n\t}\n\tFOR (fr,0,n)\n\tFOR (tl,fr+1,n)\n\tFOR (Q,0,4)\n\t{\n\t\tG ms[4];\n\t\tms[0].a[0] = W[fr].a[0];\n\t\tms[0].a[3] = W[fr].a[1];\n\t\tms[1].a[0] = W[fr].a[1];\n\t\tms[1].a[3] = W[fr].a[2];\n\t\tms[2].a[0] = W[fr].a[2];\n\t\tms[2].a[3] = W[fr].a[3];\n\t\tms[3].a[0] = W[fr].a[3];\n\t\tms[3].a[3] = W[fr].a[0];\n\n\t\tms[0].a[2] = W[tl].a[(4-1+Q)%4];\n\t\tms[0].a[1] = W[tl].a[(4-0+Q)%4];\n\t\tms[1].a[2] = W[tl].a[(4-2+Q)%4];\n\t\tms[1].a[1] = W[tl].a[(4-1+Q)%4];\n\t\tms[2].a[2] = W[tl].a[(4-3+Q)%4];\n\t\tms[2].a[1] = W[tl].a[(4-2+Q)%4];\n\t\tms[3].a[2] = W[tl].a[(4-0+Q)%4];\n\t\tms[3].a[1] = W[tl].a[(4-3+Q)%4];\n\t\tms[0].norm(); ms[1].norm();\n\t\tms[2].norm(); ms[3].norm();\n\t\t/*cout << fr<<\" \"<<tl<<endl;\n\t\tFOR (z,0,4)\n\t\t{\n\t\t\tFOR (zz,0,4)\n\t\t\tcout << ms[z].a[zz]<<\" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint NUM[4] = {0};\n\t\tFOR (k,fr+1,n)\n\t\t{\n\t\t\tif (k == tl) continue;\n\t\t\tFOR (TYPE,0,4)\n\t\t\t{\n\t\t\t\tbool ok = 1;\n\t\t\t\tFOR (QWE,0,4)\n\t\t\t\t{\n\t\t\t\t\tif (W[k].a[QWE] != ms[TYPE].a[QWE])\n\t\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t\tif (ok) NUM[TYPE]++;\n\t\t\t}\n\t\t}\n\t\tLL QSW = 1;\n\t\tFOR (F,0,4)\n\t\t{\n\t\t\tint R = 0;\n\t\t\tFOR (D,0,F)\n\t\t\t{\n\t\t\t\tif (ms[D].equals(ms[F])) R++;\n\t\t\t}\n\t\t\tQSW *= (NUM[F]-R)*ms[F].db;\n\t\t\t//cout << \"<<\"<<NUM[F]<<\" \";\n\t\t}\n\t\t//cout << QSW<<\"\\n\";\n\t\tans += QSW;\n\t\t/*if (QSW)\n\t\t{\n\t\t\tcout << QSW << endl;\n\t\t\tFOR (i,0,4) cout << NUM[i]<<\" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nvoid rot(vector<int> &tile) {\n  REP(i, 3) swap(tile[i], tile[i+1]);\n}\n\nvoid rm_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]--;\n    rot(tile);\n  }\n}\n\nvoid add_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]++;\n    rot(tile);\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[tile], 0);\n    rm_tile(tile, colors);\n  }\n\n  for (vector<int> &tile : side_tiles) {\n    add_tile(tile, colors);\n  }\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[tiles[i]]++;\n      rot(tiles[i]);\n    }\n  }\n\n  ll ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rot(tiles[low]);\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nunordered_map<ll, int>cnt;\nint g2;\nll calc (int *a) {\n\tll ans = 0; g2 = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tll tmp = 0;\n\t\tfor (int j = 0; j < 4; ++j) tmp = tmp << 10 | a[(i + j) & 3];\n\t\tif (tmp > ans) ans = tmp, g2 = 1;\n\t\telse if (tmp == ans) ++g2;\n\t}\n\treturn ans;\n}\n\nconst int N = 404;\n\nint p[N][4], n, tt[4];\nll a[4], ans, v;\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) scanf(\"%d\", &p[i][j]), ++p[i][j];\n\t\t++cnt[calc(p[i])];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\t\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\n\t\t\t--cnt[calc(p[i])]; --cnt[calc(p[j])];\n\t\t\t\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\n\t\t\t\tv = 1;\n\t\t\t\tfor (int t = 0; t < 4; ++t) {\n\t\t\t\t\ttt[0] = p[i][(t + 1) & 3];\n\t\t\t\t\ttt[1] = p[i][t];\n\t\t\t\t\ttt[2] = p[j][(k + 5 - t) & 3];\n\t\t\t\t\ttt[3] = p[j][(k - t + 4) & 3];\n\t\t\t\t\ta[t] = calc(tt);\n\t\t\t\t\tv *= g2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int t = 0; t < 4; ++t) v *= cnt[a[t]]--;\n\t\t\t\t\n\t\t\t\tfor (int t = 0; t < 4; ++t) ++cnt[a[t]];\n\t\t\t\t\n\t\t\t\tans += v;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t++cnt[calc(p[i])]; ++cnt[calc(p[j])];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define lowbit(i) i&-i\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\tull ans=0; For(i,0,5)ans=ans<<15^rand(); return ans;\n}\nconst int N=405;\nint a[N][4],ycl[4];\nll yc[N];\nmap<ll,int> to,t;\nll chu(int a[4]){\n\tll ans=0; \n\tvector<int> v;\n\tFor(i,0,3)v.pb(a[i]);\n\tFor(i,1,3){\n\t\tvector<int> b;\n\t\tFor(j,0,3)b.pb(a[(i+j)%4]);\n\t\tif(b<v)v=b;\n\t}\n\t//For(i,0,3)cout<<a[i]<<\" \"; puts(\"\"); for(auto i:v)wri(i); puts(\"fjz\");\n\tFor(i,0,3)ans+=(ll)v[i]*ycl[i];\n\treturn ans;\n}\nll c(int a,int b){\n\tll ans=1; \n\tfor(int i=a;i>a-b;i--)ans*=i;\n\t//For(i,2,b)ans/=i;\n\treturn ans;\n}\nint get(ll x){\n\tauto it=to.find(x);\n\tif(it!=to.end())return it->second; else return 0;\n}\nvoid add(int i,int y){\n\tto[yc[i]]+=y;\n}\nint main(){\n\tint n=read();\n\tFor(i,ycl[0]=1,3)ycl[i]=ycl[i-1]*1000;\n\tFor(i,1,n){\n\t\tFor(j,0,3){a[i][j]=read();} yc[i]=chu(a[i]); add(i,1);\n\t}\n\tll ans=0;\n\tFor(i,1,n){\n\t\tadd(i,-1);\n\t\tFor(j,i+1,n){\n\t\t\tadd(j,-1);\n\t\t\tFor(k,0,3){\n\t\t\t\tint q[4],B[4];\n\t\t\t\tFor(l,0,3)B[l]=a[j][3^((l+k)%4)];\n\t\t\t\tt.clear();\n\t\t\t\tll sum=1;\n\t\t\t\tFor(l,0,3){\n\t\t\t\t\tq[3]=a[i][l]; q[2]=a[i][(l+1)%4];\n\t\t\t\t\tq[0]=B[l]; q[1]=B[(l+1)%4];\n\t\t\t\t\t/*if(i==1&&j==5&&k==2){\n\t\t\t\t\t\tFor(o,0,3)wri(q[o]); puts(\"\");\n\t\t\t\t\t}*/\n\t\t\t\t\tif(q[0]==q[2]&&q[1]==q[3]){sum*=2;\n\t\t\t\t\tif(q[0]==q[1])sum*=2;}\n\t\t\t\t\t//cerr<<sum<<endl;\n\t\t\t\t\tt[chu(q)]++;\n\t\t\t\t}\n\t\t\t\tfor(auto i:t){\n\t\t\t\t\tsum=sum*c(get(i.fi),i.se);\n\t\t\t\t}\n\t\t\t\t//if(i==1&&j==8&&k==0)cout<<sum<<\" \"<<t.size()<<endl;\n\t\t\t\tans+=sum;\n\t\t\t}\n\t\t\tadd(j,1);\n\t\t}\n\t\tadd(i,1);\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n#include <stack>\n#include <string>\n#define SIZE 405\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\ntypedef pair <P,P> PP;\n\nint C[SIZE][4];\nmap <PP,int> mp;\n\nvoid rem(int a,int b,int c,int d)\n{\n\tmp[PP(P(a,b),P(c,d))]--;\n\tmp[PP(P(b,c),P(d,a))]--;\n\tmp[PP(P(c,d),P(a,b))]--;\n\tmp[PP(P(d,a),P(b,c))]--;\n}\nvoid remp(PP p)\n{\n\trem(p.first.first,p.first.second,p.second.first,p.second.second);\n}\nvoid ins(int a,int b,int c,int d)\n{\n\tmp[PP(P(a,b),P(c,d))]++;\n\tmp[PP(P(b,c),P(d,a))]++;\n\tmp[PP(P(c,d),P(a,b))]++;\n\tmp[PP(P(d,a),P(b,c))]++;\n}\nvoid insp(PP p)\n{\n\tins(p.first.first,p.first.second,p.second.first,p.second.second);\n}\nint same(PP p,PP q)\n{\n\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\tint ret=0;\n\tif(q==PP(P(a,b),P(c,d))) ret++;\n\tif(q==PP(P(b,c),P(d,a))) ret++;\n\tif(q==PP(P(c,d),P(a,b))) ret++;\n\tif(q==PP(P(d,a),P(b,c))) ret++;\n\treturn ret;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d %d %d %d\",&C[i][0],&C[i][1],&C[i][2],&C[i][3]);\n\tvector <PP> vx;\n\tll ret=0;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tfor(int j=0;j<vx.size();j++)\n\t\t{\n\t\t\tPP p=vx[j];\n\t\t\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\t\t\t//rem(a,b,c,d);\n\t\t\tPP x=PP(P(C[i][0],C[i][1]),P(b,a));\n\t\t\tPP y=PP(P(C[i][1],C[i][2]),P(c,b));\n\t\t\tPP z=PP(P(C[i][2],C[i][3]),P(d,c));\n\t\t\tPP w=PP(P(C[i][3],C[i][0]),P(a,d));\n\t\t\tll all=1;\n\t\t\tall*=(ll) mp[x]-same(p,x);\n\t\t\tint A=same(x,y);\n\t\t\tall*=(ll) mp[y]-A-same(p,y);\n\t\t\tint B=same(x,z)+same(y,z);\n\t\t\tall*=(ll) mp[z]-B-same(p,z);\n\t\t\tint D=same(x,w)+same(y,w)+same(z,w);\n\t\t\tall*=(ll) mp[w]-D-same(p,w);\n\t\t\t//if(i==1&&a==1&&b==1&&c==0&&d==0) printf(\"%d : %d %d %d %d : %d %d %d %d : %lld\\n\",i,a,b,c,d,mp[x],mp[y],mp[z],mp[w],all);\n\t\t\tret+=all;\n\t\t\t//ins(a,b,c,d);\n\t\t}\n\t\tint a=C[i][0],b=C[i][3],c=C[i][2],d=C[i][1];\n\t\tins(a,b,c,d);\n\t\tvx.push_back(PP(P(a,b),P(c,d)));\n\t\tvx.push_back(PP(P(b,c),P(d,a)));\n\t\tvx.push_back(PP(P(c,d),P(a,b)));\n\t\tvx.push_back(PP(P(d,a),P(b,c)));\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        int way=0,flg=0;\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          if(used.count(make_hash(y))){\n            flg=1;\n            break;\n          }\n        }\n        if(flg) continue;\n        ans+=check(x)/way;\n        used.emplace(make_hash(x));\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<map>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=405; \nint n,c[4][N];\nLL ans,id[N],re[4];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nmap<LL,int> num;\ninline LL getid(LL aa,LL bb,LL cc,LL dd){\n\treturn aa<<30|bb<<20|cc<<10|dd;\n}\ninline void rot(LL st,int kk) {\n\tfor(RG int i=0;i<4;i++) {\n\t\tst=((st>>10)|(st&1023)<<30);\n\t\tnum[st]+=kk;\n\t}\n}\nint main()\n{\n//\tfreopen(\"Building Cubes with AtCoDeer.in\",\"r\",stdin);\n\tread(n);\n\tfor(RG int i=1;i<=n;i++)\n\t{\n\t\tread(c[0][i],c[1][i],c[2][i],c[3][i]);\n\t\tid[i]=getid(c[0][i],c[1][i],c[2][i],c[3][i]);\n\t\trot(id[i],1);\n\t}\n\tfor(RG int i=1;i<n-4;i++)\n\t{\n\t\trot(id[i],-1);\n\t\tfor(RG int j=i+1;j<=n;j++)\n\t\t{\n\t\t\trot(id[j],-1);\n\t\t\tfor(RG int l=0;l<4;l++)\n\t\t\t{\n\t\t\t\tLL tt=1;\n\t\t\t\tre[0]=getid(c[1][i],c[0][i],c[(l+1)%4][j],c[(l)%4][j]); if(!num[re[0]]) continue;\n\t\t\t\tre[1]=getid(c[2][i],c[1][i],c[(l)%4][j],c[(l+3)%4][j]); if(!num[re[1]]) continue;\n\t\t\t\tre[2]=getid(c[3][i],c[2][i],c[(l+3)%4][j],c[(l+2)%4][j]); if(!num[re[2]]) continue;\n\t\t\t\tre[3]=getid(c[0][i],c[3][i],c[(l+2)%4][j],c[(l+1)%4][j]); if(!num[re[3]]) continue;\n\t\t\t\tfor(RG int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\ttt*=num[re[k]];\n\t\t\t\t\trot(re[k],-1);\n\t\t\t\t}\n\t\t\t\tfor(RG int k=0;k<4;k++) rot(re[k],1);\n\t\t\t\tans+=tt;\n\t\t\t}\n\t\t\trot(id[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\ninline unsigned long long rot90(unsigned long long x) {\n  return (x << 16) | (x >> 48);\n}\n\ninline bool same180(unsigned long long x) {\n  return (x >> 32) == ((x << 32) >> 32);\n}\n\ninline bool same90(unsigned long long x) {\n  return (x >> 48) == ((x << 48) >> 48);\n}\n\ninline void multi(unsigned long long side, long& cnt) {\n  if (same180(side)) {\n    cnt *= 2;\n    if (same90(side)) {\n      cnt *= 2;\n    }\n  }\n}\n\ninline unsigned long long get_min(unsigned long long a,\n                                  unsigned long long b,\n                                  unsigned long long c,\n                                  unsigned long long d) {\n  assert(a < (1 << 16));\n  assert(b < (1 << 16));\n  assert(c < (1 << 16));\n  assert(d < (1 << 16));\n  return std::min(\n      {\n          (a << 48) | (b << 32) | (c << 16) | d,\n          (b << 48) | (c << 32) | (d << 16) | a,\n          (c << 48) | (d << 32) | (a << 16) | b,\n          (d << 48) | (a << 32) | (b << 16) | c\n      }\n  );\n}\n\ninline unsigned long long get0(unsigned long long x) { return x >> 48; }\ninline unsigned long long get1(unsigned long long x) { return (x << 16) >> 48; }\ninline unsigned long long get2(unsigned long long x) { return (x << 32) >> 48; }\ninline unsigned long long get3(unsigned long long x) { return (x << 48) >> 48; }\n\nint main() {\n  unsigned N;\n  std::cin >> N;\n  std::vector<unsigned long long> tile(N);\n  for (unsigned i = 0; i < N; ++i) {\n    unsigned long long a, b, c, d;\n    std::cin >> a >> b >> c >> d;\n    tile[i] = get_min(a, b, c, d);\n  }\n  std::sort(tile.begin(), tile.end());\n  unsigned long long ans = 0ull;\n  for (auto p0 = tile.begin(); p0 < tile.end(); ++p0) {\n    for (auto p1 = p0 + 1; p1 < tile.end(); ++p1) {\n      //0\n      unsigned long long x = *p0;\n      unsigned long long y = *p1;\n      unsigned long long a, b, c, d;\n      auto yy = y;\n      for (unsigned k = 0; k < 4; ++k) {\n        a = get_min(get1(x), get0(x), get1(y), get0(y));\n        b = get_min(get2(x), get1(x), get0(y), get3(y));\n        c = get_min(get3(x), get2(x), get3(y), get2(y));\n        d = get_min(get0(x), get3(x), get2(y), get1(y));\n        auto s = std::upper_bound(p0 + 1, tile.end(), a) - std::lower_bound(p0 + 1, tile.end(), a);\n        auto t = std::upper_bound(p0 + 1, tile.end(), b) - std::lower_bound(p0 + 1, tile.end(), b);\n        auto q = std::upper_bound(p0 + 1, tile.end(), c) - std::lower_bound(p0 + 1, tile.end(), c);\n        auto r = std::upper_bound(p0 + 1, tile.end(), d) - std::lower_bound(p0 + 1, tile.end(), d);\n        if (yy == a) { --s; };\n        if (yy == b) { --t; };\n        if (a == b) { --t; };\n        if (yy == c) { --q; };\n        if (a == c) { --q; };\n        if (b == c) { --q; };\n        if (yy == d) { --r; };\n        if (a == d) { --r; };\n        if (b == d) { --r; };\n        if (c == d) { --r; };\n        multi(a, s);\n        multi(b, t);\n        multi(c, q);\n        multi(d, r);\n        ans += s * t * q * r;\n        y = rot90(y);\n      }\n    }\n  }\n  std::cout << ans << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int, int> P;\n\nP rot(P p) {\n\tint a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn make_tuple(b, c, d, a);\n}\n\nlong long unpack(P p) {\n\tlong long a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn a * 1000000000LL + b * 1000000LL + c * 1000LL + d;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n * 4), b(n * 4), c(n * 4), d(n * 4);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 4] >> b[i * 4] >> c[i * 4] >> d[i * 4];\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\ta[i * 4 + j] = d[i * 4 + j - 1];\n\t\t\tb[i * 4 + j] = a[i * 4 + j - 1];\n\t\t\tc[i * 4 + j] = b[i * 4 + j - 1];\n\t\t\td[i * 4 + j] = c[i * 4 + j - 1];\n\t\t}\n\t}\n\tn *= 4;\n\n\tmap<long long, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp[unpack(make_tuple(a[i], b[i], c[i], d[i]))]++;\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i / 4 == j / 4) continue;\n\t\t\tP x(a[i], b[i], c[i], d[i]);\n\t\t\tP y(a[j], b[j], c[j], d[j]);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[unpack(x)]--;\n\t\t\t\tmp[unpack(y)]--;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tP p[4];\n\t\t\tp[0] = P(d[j], c[j], b[i], a[i]);\n\t\t\tp[1] = P(b[i], c[j], b[j], c[i]);\n\t\t\tp[2] = P(d[j], a[i], d[i], a[j]);\n\t\t\tp[3] = P(d[i], c[i], b[j], a[j]);\n\n\t\t\tlong long cnt = 1;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt *= mp[unpack(p[k])];\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[unpack(p[k])]--;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[unpack(p[k])]++;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[unpack(x)]++;\n\t\t\t\tmp[unpack(y)]++;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tans += cnt;\n\t\t}\n\t}\n\tcout << ans / 24 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<map>\n#define RG register\n#define LL long long\nusing namespace std;\nconst int N=405; \nint n,c[4][N];\nLL ans,id[N],re[4];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nmap<LL,int> num;\ninline LL getid(LL aa,LL bb,LL cc,LL dd){\n\treturn aa<<30|bb<<20|cc<<10|dd;\n}\ninline void rot(LL st,int kk) {\n\tfor(RG int i=0;i<4;i++) {\n\t\tst=((st>>10)|(st&1023)<<30);\n\t\tnum[st]+=kk;\n\t}\n}\nint main()\n{\n//\tfreopen(\"Building Cubes with AtCoDeer.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n);\n\tfor(RG int i=1;i<=n;i++)\n\t{\n\t\tread(c[0][i],c[1][i],c[2][i],c[3][i]);\n\t\tid[i]=getid(c[0][i],c[1][i],c[2][i],c[3][i]);\n\t\trot(id[i],1);\n\t}\n\tfor(RG int i=1;i<n-4;i++)\n\t{\n\t\trot(id[i],-1);\n\t\tfor(RG int j=i+1;j<=n;j++)\n\t\t{\n\t\t\trot(id[j],-1);\n\t\t\tfor(RG int l=0;l<4;l++)\n\t\t\t{\n\t\t\t\tLL tt=1;\n\t\t\t\tre[0]=getid(c[1][i],c[0][i],c[(l+1)%4][j],c[(l)%4][j]); if(!num[re[0]]) continue;\n\t\t\t\tre[1]=getid(c[2][i],c[1][i],c[(l)%4][j],c[(l+3)%4][j]); if(!num[re[1]]) continue;\n\t\t\t\tre[2]=getid(c[3][i],c[2][i],c[(l+3)%4][j],c[(l+2)%4][j]); if(!num[re[2]]) continue;\n\t\t\t\tre[3]=getid(c[0][i],c[3][i],c[(l+2)%4][j],c[(l+1)%4][j]); if(!num[re[3]]) continue;\n\t\t\t\tfor(RG int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\ttt*=num[re[k]];\n\t\t\t\t\trot(re[k],-1);\n\t\t\t\t}\n\t\t\t\tfor(RG int k=0;k<4;k++) rot(re[k],1);\n\t\t\t\tans+=tt;\n\t\t\t}\n\t\t\trot(id[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 400 + 10;\nint n; \nll ans;\nll a[maxn][4], b[maxn][4], tmp[4];\nmap<ll, int> M;\nvoid solve(int x, int y, int z)\n{\n\tll ret = 1;\n\tvector<ll> res;\n\tfor(int i = 0; i < 4; ++i) --M[b[x][i]], res.push_back(b[x][i]);\n\tfor(int i = 0; i < 4; ++i) --M[b[y][i]], res.push_back(b[y][i]);\n\tfor(int i = 0; i < 4; ++i)\n\t{\n\t\ttmp[0] = a[x][(i + 1) % 4]; tmp[1] = a[x][i]; tmp[2] = a[y][(3 - i + z) % 4]; tmp[3] = a[y][(6 - i + z) % 4]; \n\t\tll id = 0; for(int j = 0; j < 4; ++j) id = id * 1000 + tmp[j];\n\t\tif(M[id] == 0) \n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tret = ret * M[id];\n\t\tfor(int j = 0; j < 4; ++j)\n\t\t{\n\t\t\tid = 0;\n\t\t\tfor(int k = 0; k < 4; ++k)\n\t\t\t\tid = id * 1000 + tmp[(j + k) % 4];\n\t\t\t--M[id], res.push_back(id);\n\t\t}\n\t}\n\tans += ret;\n\tfor(auto v : res) ++M[v];\n}\nint main()\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfor(int j = 0; j < 4; ++j)\n\t\t\tcin >> a[i][j];\n\t\tfor(int j = 0; j < 4; ++j)\n\t\t{\n\t\t\tfor(int k = 0; k < 4; ++k)\n\t\t\t\tb[i][j] = b[i][j] * 1000 + a[i][(j + k) % 4];\n\t\t\tM[b[i][j]]++;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tfor(int k = 0; k < 4; ++k)\n\t\t\t\tsolve(i, j, k);\n\tans /= 3;\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nunordered_map<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\n\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\n__int128_t check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  __int128_t res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[(k+z)%4][i];\n          x[k+4]=cs[k][j];\n        }\n\n        int way=0;\n        A w(x);\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          chmin(w,y);\n        }\n\n        if(used.count(make_hash(w))) continue;\n        used.emplace(make_hash(w));\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=405, INF=1e9;\nusing namespace std;\nint n, ans = 0, c[N][4];\nmap<array<int, 4>, int> mp;\nvector< array<int, 4> > rottn;\nint match(array<int, 4> x, array<int, 4> y)\n{\n    int ret = 0;\n    for(int i = 0; i < 4; i++)\n    {\n        array<int, 4> tmp;\n        for(int j = 0; j < 4; j++)\n        {\n            tmp[j] = y[(j+i)%4];\n        }\n        if(tmp==x) ret++;\n    }\n    return ret;\n}\nvoid print(array<int, 4> a)\n{\n    cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << endl;\n}\nsigned main()\n{\n    cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < 4; j++)\n        {\n            cin >> c[i][j];\n        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        for(auto opp: rottn)\n        {\n            vector< array<int, 4> > prevo;\n            array<int, 4> ori[4];\n            ori[0] = {opp[1], opp[0], c[i][1], c[i][0]};\n            ori[1] = {opp[3], opp[2], c[i][3], c[i][2]};\n            ori[2] = {opp[0], opp[3], c[i][2], c[i][1]};\n            ori[3] = {opp[2], opp[1], c[i][0], c[i][3]};\n            int cnt = 1;\n            prevo.pb(opp);\n            for(int j = 0; j < 4; j++)\n            {\n                int tmpsum = mp[ori[j]];\n                for(auto prev: prevo) tmpsum -= match(ori[j], prev);\n                prevo.pb(ori[j]);\n                cnt*=tmpsum;\n            }\n            ans += cnt;\n        }\n        for(int j = 0; j < 4; j++)\n        {\n            array<int, 4> tbp;\n            for(int k = 0; k < 4; k++)\n            {\n                tbp[k] = c[i][(j+k)%4];\n            }\n            rottn.pb(tbp);\n            mp[tbp]++;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<short,short> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,ll> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,ll &delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)-4*((i+delta)>=4)]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid add(vi &nuevo,ll delta,map<iiii,ll> &mapa)\n{\n    //permutar(nuevo);\n    forr(i,0,4)\n    {\n        mapa[move(nuevo,i)]+=delta;\n    }\n}\nvector<iiii> vcaras(4);\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras[0]=auxcara;\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras[1]=auxcara;\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras[2]=auxcara;\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras[3]=auxcara;\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   ll n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   //permutar(V[2]);\n   map<iiii,ll> extra;\n   ll totp,answer=0,auxtotp;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,i+1,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                //forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    ll meh=0;\n                    fiiv(cara2,move(V[j],meh));\n                    /*<<\"comenzamos\\n\";\n                    prll(cara1);\n                    prll(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prll(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxtotp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxtotp);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //cout<<answer<<endl;\n   cout<<answer/3<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nstruct Unionfind{\n  vi size, par;\n  Unionfind(){}\n  Unionfind( int n ) :  size(n,1), par(n){\n    REP( i , n ) par[i] = i;\n  }\n  void init( int n ){\n    size = vi( n , 1 );\n    par.resize( n );\n    REP( i , n ) par[i] = i;\n  }\n  int find( int x ){\n    if( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n  bool unite( int x , int y ){\n    x = find(x);\n    y = find(y);\n    if( x == y ) return false;\n    if( size[y] < size[x] ) swap( x , y );\n    par[x] = y;\n    size[y] += size[x];\n    return true;\n  }\n  bool same( int x , int y ){\n    return find(x) == find(y);\n  }\n};\n\n\nint n;\n\nvi c[410];\n\nUnionfind uf;\n\nvi rot( vi v ){\n  return { v[1] , v[2] , v[3] , v[0] };\n}\n\nbool same( vi a , vi b ){\n  REP( i , 4 ){\n    if( a == b ){\n      return true;\n    }\n    b = rot( b );\n  }\n  return false;\n}\n\nint weight( vi v ){\n  vi cur = v;\n  int cnt = 1;\n  REP( i , 3 ){\n    cur = rot( cur );\n    if( cur == v ){\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\nll perm( ll a , ll b ){\n  if( a < b ){\n    return 0;\n  }\n  ll res = 1;\n  REP( i , b ){\n    res *= a - i;\n  }\n  return res;\n}\n\nint main(){\n\n  n = in();\n  REP( i , n ){\n    REP( j , 4 ){\n      c[i].pb( in() );\n    }\n  }\n\n  ll ans = 0;\n  REP( up , n ){\n    vi u = c[up];\n    REP( down , n ){\n      if( up == down ){\n\tcontinue;\n      }\n      vi d = c[down];\n      REP( rotation , 4 ){\n\tmi s(4,vi(4));\n\tREP( i , 4 ){\n\t  s[i][0] = u[i];\n\t  s[i][1] = d[(5-i)%4];\n\t  s[i][2] = d[(4-i)%4];\n\t  s[i][3] = u[(i+1)%4];\n\t}\n\n\tuf.init( 4 );\n\tREP( i , 4 ){\n\t  REP( j , i ){\n\t    if( same( s[i] , s[j] ) ){\n\t      uf.unite( i , j );\n\t    }\n\t  }\n\t}\n\n\tvi we(4,1);\n\tREP( i , 4 ){\n\t  we[ uf.find( i ) ] *= weight( s[i] );\n\t}\n\n\tvi cnt(4,0);\n\tREP( i , n ){\n\t  if( i == up or i == down ){\n\t    continue;\n\t  }\n\t  REP( j , 4 ){\n\t    if( same( s[j] , c[i] ) ){\n\t      cnt[j]++;\n\t    }\n\t  }\n\t}\n\n\tll cur = 1;\n\tREP( i , 4 ){\n\t  if( uf.find( i ) == i ){\n\t    cur *= we[i] * perm( cnt[i] , uf.size[i] );\n\t    /*\n\t    if( up == 0 and down == 4 and rotation == 0 ){\n\t      cout << i << \" \" << we[i] << \" \" << cnt[i] << \" \" << uf.size[i] << endl;\n\t      cout << we[i] * perm( cnt[i] , uf.size[i] ) << endl;\n\t    }\n\t    */\n\t  }\n\t}\n\n\tans += cur;\n\n\td = rot( d );\n      }\n    }\n  }\n\n  cout << ans / 6 << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans,c[410][4],h[410],v[4],tmp[4];\nunordered_map<ll,int>mp;\nvoid upd(ll x,int d)\n{\n    for(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll))\n        mp[x]+=d;\n    return;\n}\nll Hash(ll *a)\n{\n    ll ret=0;\n    for(int i=0;i<4;i++)\n        ret|=(a[i]<<(i*10ll));\n    return ret;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n        h[i]=Hash(c[i]);\n        upd(h[i],1);\n    }\n    for(int i=1;i<=n-5;i++)\n    {\n        upd(h[i],-1);\n        for(int j=i+1;j<=n;j++)\n        {\n            upd(h[j],-1);\n            for(int k=0;k<4;k++)\n            {\n                ll res=1;\n                for(int l=0;l<4;l++)\n                {\n                    ll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n                    v[l]=Hash(tmp);\n                    if(!mp.count(v[l]))\n                        goto to;\n                }\n                for(int l=0;l<4;l++)\n                {\n                    res*=mp[v[l]];\n                    upd(v[l],-1);\n                }\n                ans+=res;\n                for(int l=0;l<4;l++)\n                    upd(v[l],1);\n                to: ;\n            }\n            upd(h[j],1);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nll h[maxn];\ninline ll cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tll ret = 1234567891234567ll;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tll num = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tnum = num*1000+col[(rot+i)%4];\n\t\t\tret = min(ret,num);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nint fac[5];\ninline ll C(int n,int m) {\n\tif(n < m)\treturn 0;\n\tll ret = 1;\n\tfor(int i=n-m+1;i<=n;i++)\n\t\tret *= i;\n\tfor(int i=1;i<=m;i++)\n\t\tret /= i;\n\treturn ret;\n}\nmap<ll,pii> cnt;\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tint now_cnt = 0;\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tll num = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tnum = num*1000+col[i][(rot+j)%4];\n\t\t\t\tif(num == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tnow_cnt = max(now_cnt,tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t\tcnt[h[i]].first++;\n\t\tcnt[h[i]].second = now_cnt;\n\t}\n\t\n\tfac[0] = 1;\n\tfor(int i=1;i<5;i++)\n\t\tfac[i] = fac[i-1] * i;\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tcnt[h[i]].first--;\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tcnt[h[j]].first--;\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tmap<ll,int> need;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k])]++;\n\t\t\t\tll now = 1;\n\t\t\t\tfor(pii x : need)\n\t\t\t\t\tnow *= C(cnt[x.first].first,x.second) * pow(cnt[x.first].second,x.second) * fac[x.second];\n\t\t\t\tans += now;\n\t\t\t}\n\t\t\tcnt[h[j]].first++;\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n//\t\tcnt[h[i]].first++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long li;\n\nli hash_color(const vector<int> &colors) {\n    li v = 0;\n    li pow = 1;\n    for (int i = 0; i < 4; ++i) {\n        v += colors[i] * pow;\n        pow *= 1000;\n    }\n    return v;\n}\n\nvector<int> rotate(const vector<int> &colors) {\n    return {colors[1], colors[2], colors[3], colors[0]};\n}\n\nvector<int> rotate(const vector<int> &colors, const int count) {\n    vector<int> ret = colors;\n    for (int i = 0; i < count; ++i) {\n        ret = rotate(ret);\n    }\n    return ret;\n}\n\nli normalized_hash(const vector<int> &colors) {\n    vector<int> c = colors;\n    li h = hash_color(c);\n    for (int i = 0; i < 3; ++i) {\n        c = rotate(c);\n        h = min(h, hash_color(c));\n    }\n    return h;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n//    n = 400;\n    vector<vector<int>> colors(n, vector<int>(4));\n    map<li, li> card_counts;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n        }\n        card_counts[normalized_hash(colors[i])] += 1;\n    }\n\n    li ans = 0;\n    for (int bottom = 0; bottom < n; ++bottom) {\n        const li bottom_hash = normalized_hash(colors[bottom]);\n//        cerr << bottom << endl;\n        // flipped\n        const vector<int> bottom_colors = {\n                colors[bottom][3],\n                colors[bottom][2],\n                colors[bottom][1],\n                colors[bottom][0]\n        };\n        for (int top = bottom + 1; top < n; ++top) {\n            const li top_hash = normalized_hash(colors[top]);\n\n            for (int top_dir = 0; top_dir < 4; ++top_dir) {\n                const vector<int> top_colors = rotate(colors[top], top_dir);\n\n                li subans = 1;\n                map<li, int> used_hash;\n                for (int side_index = 0; side_index < 4; ++side_index) {\n                    const vector<int> side_colors = {\n                            bottom_colors[side_index],\n                            bottom_colors[(side_index + 1) % 4],\n                            top_colors[(side_index + 1) % 4],\n                            top_colors[side_index]\n                    };\n                    if (\n                            side_colors[0] == side_colors[1] &&\n                            side_colors[1] == side_colors[2] &&\n                            side_colors[2] == side_colors[3] &&\n                            side_colors[3] == side_colors[0]\n                    ) {\n                        subans *= 4;\n                    } else if (\n                            side_colors[0] == side_colors[2] &&\n                            side_colors[1] == side_colors[3]\n                    ) {\n                        subans *= 2;\n                    } else {\n                        subans *= 1;\n                    }\n\n                    const li side_hash = normalized_hash(side_colors);\n                    subans *= (card_counts[side_hash] - used_hash[side_hash] - (side_hash == bottom_hash) - (side_hash == top_hash));\n                    used_hash[side_hash]++;\n                }\n\n                ans += subans;\n            }\n        }\n    }\n    cout << ans / 3 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <unordered_map>\nusing namespace std;\nconst int MAXN=405;\ntypedef long long ll;\nstruct Node{\n\tint a,b,c,d;\n}a[MAXN];\nint n;\nunordered_map<ll,int>mp;\ninline ll gethsh(Node x)\n{\n\treturn (ll)x.a<<30|(ll)x.b<<20|(ll)x.c<<10|(ll)x.d;\n}\nll hsh[MAXN];\nbool flag=true;\ninline void add(ll x,int v)\n{\n\tfor(int i=0;i<4;++i,x=(x>>10)|((x&1023)<<30))\n\t\tmp[x]+=v;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tNode x;\n\t\tscanf(\"%d%d%d%d\",&x.a,&x.b,&x.c,&x.d);\n\t\ta[i]=x;\n\t\thsh[i]=gethsh(x);\n\t\tadd(hsh[i],1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n-5;++i){\n\t\tadd(hsh[i],-1);\n\t\tNode x=a[i];\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tadd(hsh[j],-1);\n\t\t\tNode y=a[j];\n\t\t\tfor(int p2=0;p2<4;++p2){\n\t\t\t\tint now=1;\n\t\t\t\tll t[5]={0};\n\t\t\t\tt[0]=gethsh((Node){x.b,x.a,y.b,y.a});\n\t\t\t\tt[1]=gethsh((Node){x.c,x.b,y.a,y.d});\n\t\t\t\tt[2]=gethsh((Node){x.a,x.d,y.c,y.b});\n\t\t\t\tt[3]=gethsh((Node){x.d,x.c,y.d,y.c});\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tint o=mp.count(t[k])?mp[t[k]]:0;\n\t\t\t\t\tnow*=o;\n\t\t\t\t\tadd(t[k],-1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;++k)\n\t\t\t\t\tadd(t[k],1);\n\t\t\t\tans+=now;\n\t\t\t\tswap(y.a,y.b),swap(y.b,y.c),swap(y.c,y.d);\n\t\t\t}\n\t\t\tadd(hsh[j],1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ndeque<int> f(deque<int> d) {\n\tdeque<int> ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d.front());\n\t\td.pop_front();\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint count_overlap(deque<int> d) {\n\tint ret = 1;\n\tdeque<int> t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d.front());\n\t\td.pop_front();\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\ndeque<int> C[400];\n\nll P(int n, int k) {\n\tll ret = 1;\n\tfor(int i = n - k + 1; i <= n; i++) {\n\t\tret *= i;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tmap<deque<int>, int> m;\n\tmap<deque<int>, int> cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tdeque<int> d;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\td.push_back(c);\n\t\t}\n\t\td = f(d);\n\t\tC[i] = d;\n\t\tm[d]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = count_overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tdeque<int> d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tif(i == j) continue;\n\t\t\tdeque<int> d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<deque<int>, int> t;\n\t\t\t\tdeque<int> p1({ d1[1], d1[0], d2[1], d2[0] });\n\t\t\t\tdeque<int> p2({ d1[0], d1[3], d2[2], d2[1] });\n\t\t\t\tdeque<int> p3({ d1[3], d1[2], d2[3], d2[2] });\n\t\t\t\tdeque<int> p4({ d1[2], d1[1], d2[0], d2[3] });\n\t\t\t\tt[f(p1)]++;\n\t\t\t\tt[f(p2)]++;\n\t\t\t\tt[f(p3)]++;\n\t\t\t\tt[f(p4)]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P(m[p.first], p.second);\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\td1.push_back(d1[0]);\n\t\t\t\td1.pop_front();\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 6 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#define ll long long\nusing namespace std;\nconst int N=405;\nint n,i,j,k,x,c[N][4];ll a[N],v[4],ans;\nll num(int a,int b,int c,int d){\n\treturn ((ll)a<<30)+(b<<20)+(c<<10)+d;\n}\nmap<ll,int> mp;\nvoid add(ll x,int k){\n\tfor (int i=4;i--;x=x>>10|(x&1023)<<30) mp[x]+=k;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;add(a[i],1),i++) for (j=0;j<4;j++)\n\t\tscanf(\"%d\",&c[i][j]),a[i]=(a[i]<<10)+c[i][j];\n\tfor (i=1;i<=n-5;i++)\n\t\tfor (add(a[i],-1),j=i+1;j<=n;j++){\n\t\t\tadd(a[j],-1);\n\t\t\tfor (k=4;k--;){\n\t\t\t\tv[0]=num(c[i][0],c[j][k],c[j][(k+3)&3],c[i][1]);\n\t\t\t\tv[1]=num(c[i][1],c[j][(k+3)&3],c[j][(k+2)&3],c[i][2]);\n\t\t\t\tv[2]=num(c[i][2],c[j][(k+2)&3],c[j][(k+1)&3],c[i][3]);\n\t\t\t\tv[3]=num(c[i][3],c[j][(k+1)&3],c[j][k],c[i][0]);\n\t\t\t\tll res=1;\n\t\t\t\tfor (x=4;x--;) res*=mp[v[x]],add(v[x],-1);\n\t\t\t\tfor (ans+=res,x=4;x--;) add(v[x],1);\n\t\t\t}\n\t\t \tadd(a[j],1);\n\t\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\n#define dtz 1023\n#define id(A,B,C,D) ((A<<30)+(B<<20)+(C<<10)+D)\n#define get1(A) (A>>30)\n#define get2(A) ((A>>20)&dtz)\n#define get3(A) ((A>>10)&dtz)\n#define get4(A) (A&dtz)\n#define rotate(A) (((A&dtz)<<30)|(A>>10))\n#define MOD 19260817\n#define next DEEP_DARK_FANTASY\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nnamespace HASH{\n\tint first[MOD],cnt,next[100010],siz[100010];ll w[100010];\n\tvoid insert(ll val,int num){\n\t\tint pval=val%MOD,u=first[pval];\n//\t\tcout<<\"\tinsert \"<<val<<' '<<pval<<' '<<num<<'\\n';\n\t\tif(!u){\n\t\t\tcnt++;\n\t\t\tfirst[pval]=cnt;w[cnt]=val;siz[cnt]=num;\n\t\t\treturn;\n\t\t}\n\t\tfor(;next[u]&(w[u]!=val);u=next[u]);\n\t\tif(w[u]==val) siz[u]+=num;\n\t\telse{\n\t\t\tcnt++;\n\t\t\tnext[u]=cnt;\n\t\t\tw[cnt]=val;\n\t\t\tsiz[cnt]=num;\n\t\t}\n\t}\n\tint query(ll val){\n\t\tint pval=val%MOD,u=first[pval];\n\t\tfor(;u&&next[u]&&(w[u]!=val);u=next[u]);\n//\t\tcout<<\"\tquery \"<<val<<' '<<pval<<' '<<((w[u]==val)?siz[u]:0)<<'\\n';\n\t\treturn w[u]==val?siz[u]:0;\n\t}\n}\nvoid change(ll val,int num){\n\tHASH::insert(val,num);\n\tval=rotate(val);\n\tHASH::insert(val,num);\n\tval=rotate(val);\n\tHASH::insert(val,num);\n\tval=rotate(val);\n\tHASH::insert(val,num);\n}\nint n;ll c0[510],c1[510],c2[510],c3[510];\nint main(){\n\tn=read();int i,j;ll t1,t2,t3,t4,ans=0,cur,val;\n\tfor(i=1;i<=n;i++){\n\t\tt1=read();t2=read();t3=read();t4=read();\n\t\tc0[i]=id(t1,t2,t3,t4);\n\t\tc1[i]=id(t2,t3,t4,t1);\n\t\tc2[i]=id(t3,t4,t1,t2);\n\t\tc3[i]=id(t4,t1,t2,t3);\n\t\tHASH::insert(c0[i],1);\n\t\tHASH::insert(c1[i],1);\n\t\tHASH::insert(c2[i],1);\n\t\tHASH::insert(c3[i],1);\n\t}\n\tfor(i=1;i<n;i++){\n\t\tHASH::insert(c0[i],-1);\n\t\tHASH::insert(c1[i],-1);\n\t\tHASH::insert(c2[i],-1);\n\t\tHASH::insert(c3[i],-1);\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tHASH::insert(c0[j],-1);\n\t\t\tHASH::insert(c1[j],-1);\n\t\t\tHASH::insert(c2[j],-1);\n\t\t\tHASH::insert(c3[j],-1);\n//\t\t\tcout<<\"do \"<<i<<' '<<j<<' '<<ans<<'\\n';\n//\t\t\t**********************************************************************0 degree rotation\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get2(c0[j]),get1(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_0_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get2(c3[j]),get1(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_0_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get2(c2[j]),get1(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_0_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get2(c1[j]),get1(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n\t\t\tif(!val) goto jump_0_4;\n\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n\t\t\tchange(t4,1);\n\t\t\tjump_0_4:\n\t\t\t//back face 4\n\t\t\tchange(t3,1);\n\t\t\tjump_0_3:\n\t\t\t//back face 4\n\t\t\tchange(t2,1);\n\t\t\tjump_0_2:\n\t\t\t//back face 4\n\t\t\tchange(t1,1);\n\t\t\tjump_0_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 0 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t**********************************************************************90 degree rotation counter-clockwise\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get3(c0[j]),get2(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_90_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get3(c3[j]),get2(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_90_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get3(c2[j]),get2(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_90_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get3(c1[j]),get2(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n\t\t\tif(!val) goto jump_90_4;\n\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n\t\t\tchange(t4,1);\n\t\t\tjump_90_4:\n\t\t\t//back face 4\n\t\t\tchange(t3,1);\n\t\t\tjump_90_3:\n\t\t\t//back face 4\n\t\t\tchange(t2,1);\n\t\t\tjump_90_2:\n\t\t\t//back face 4\n\t\t\tchange(t1,1);\n\t\t\tjump_90_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 90 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t**********************************************************************180 degree rotation counter-clockwise\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get4(c0[j]),get3(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_180_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get4(c3[j]),get3(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_180_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get4(c2[j]),get3(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_180_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get4(c1[j]),get3(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n\t\t\tif(!val) goto jump_180_4;\n\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n\t\t\tchange(t4,1);\n\t\t\tjump_180_4:\n\t\t\t//back face 4\n\t\t\tchange(t3,1);\n\t\t\tjump_180_3:\n\t\t\t//back face 4\n\t\t\tchange(t2,1);\n\t\t\tjump_180_2:\n\t\t\t//back face 4\n\t\t\tchange(t1,1);\n\t\t\tjump_180_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 180 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t**********************************************************************270 degree rotation counter-clockwise\n\t\t\tcur=1;\n\t\t\t//in face 1\n\t\t\tt1=id(get2(c0[i]),get1(c0[i]),get1(c0[j]),get4(c0[j]));\n\t\t\tval=HASH::query(t1);cur*=val;\n\t\t\tif(!val) goto jump_270_1;\n\t\t\tchange(t1,-1);\n\t\t\t//in face 2\n\t\t\tt2=id(get2(c1[i]),get1(c1[i]),get1(c3[j]),get4(c3[j]));\n\t\t\tval=HASH::query(t2);cur*=val;\n\t\t\tif(!val) goto jump_270_2;\n\t\t\tchange(t2,-1);\n\t\t\t//in face 3\n\t\t\tt3=id(get2(c2[i]),get1(c2[i]),get1(c2[j]),get4(c2[j]));\n\t\t\tval=HASH::query(t3);cur*=val;\n\t\t\tif(!val) goto jump_270_3;\n\t\t\tchange(t3,-1);\n\t\t\t//in face 4\n\t\t\tt4=id(get2(c3[i]),get1(c3[i]),get1(c1[j]),get4(c1[j]));\n\t\t\tval=HASH::query(t4);cur*=val;\n\t\t\tif(!val) goto jump_270_4;\n\t\t\tchange(t4,-1);\n\t\t\t//back face 4\n\t\t\tchange(t4,1);\n\t\t\tjump_270_4:\n\t\t\t//back face 4\n\t\t\tchange(t3,1);\n\t\t\tjump_270_3:\n\t\t\t//back face 4\n\t\t\tchange(t2,1);\n\t\t\tjump_270_2:\n\t\t\t//back face 4\n\t\t\tchange(t1,1);\n\t\t\tjump_270_1:\n\t\t\tans+=cur;\n//\t\t\tcout<<\"finish 270 degree \"<<t1<<' '<<t2<<' '<<t3<<' '<<t4<<'\\n';\n//\t\t\t******************************back j\n\t\t\tHASH::insert(c0[j],1);\n\t\t\tHASH::insert(c1[j],1);\n\t\t\tHASH::insert(c2[j],1);\n\t\t\tHASH::insert(c3[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#define ll long long\nusing namespace std;\nll c[405][4],h[405],v[4];\nmap<ll,int> mp;\nvoid upd(ll x,int d){\n    for(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll)){\n    \tmp[x]+=d;\n\t}\n    return;\n}\nll Hash(ll *a){\n    ll ret=0;\n    for(int i=0;i<4;i++){\n    \tret|=(a[i]<<(i*10ll));\n\t}\n    return ret;\n}\nint main(){\n\tint n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n        h[i]=Hash(c[i]);\n        upd(h[i],1);\n    }\n    ll ans=0,res;\n    for(int i=1;i<=n-5;i++){\n        upd(h[i],-1);\n        for(int j=i+1;j<=n;j++){\n            upd(h[j],-1);\n            for(int k=0;k<4;k++){\n                res=1;\n                for(int l=0;l<4;l++){\n                    ll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n                    v[l]=Hash(tmp);\n                    if(!mp.count(v[l])){\n                    \tgoto to;\n\t\t\t\t\t}\n                }\n                for(int l=0;l<4;l++){\n                    res*=mp[v[l]];\n                    upd(v[l],-1);\n                }\n                ans+=res;\n                for(int l=0;l<4;l++){\n                \tupd(v[l],1);\n\t\t\t\t}\n                to:;\n            }\n            upd(h[j],1);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<vector<int>> masks(4);\n    for (int i=0;i<16;++i){\n        for (int j=0;j<4;++j){\n            if (!(i&1<<j)) masks[j].emplace_back(i);\n        }\n    }\n    vector<vector<ll>> hash(N,vector<ll>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            ll po=1;\n            for (int k=0;k<4;++k,po*=1000){\n                hash[i][j]+=C[i][(j+k)%4]*po;\n            }\n        }\n    }\n    vector<int> rot(4);\n    vector<vector<int>> surface(4,vector<int>(4));\n    vector<ll> hashedsurface(4);\n    vector<vector<ll>> dp(N+1,vector<ll>(16));\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                    if (surface[q][0]==surface[q][1]\n                        &&surface[q][1]==surface[q][2]\n                        &&surface[q][2]==surface[q][3]\n                        &&surface[q][3]==surface[q][0]) rot[q]=4;\n                    else if (surface[q][0]==surface[q][2]\n                            &&surface[q][1]==surface[q][3]) rot[q]=2;\n                    else rot[q]=1;\n                    hashedsurface[q]=0; ll po=1;\n                    for (int r=0;r<4;++r,po*=1000){\n                        hashedsurface[q]+=surface[q][r]*po;\n                    }\n                }\n                for (int k=i+1;k<=N;++k){\n                    for (int l=0;l<16;++l){\n                        dp[k][l]=0;\n                    }\n                }\n                dp[i+1][0]=1;\n                for (int k=i+1;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]+=dp[k][l];\n                    if (k==j) continue;\n                    for (int l=0;l<4;++l){\n                        bool flag=false;\n                        for (int m=0;m<4;++m){\n                            if (hashedsurface[l]==hash[k][m]){\n                                flag=true;\n                            }\n                        }\n                        if (flag){\n                            for (int mask:masks[l]){\n                            dp[k+1][mask|1<<l]+=dp[k][mask]*rot[l];\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<unordered_map>\nusing namespace std;\nvector<int>rotate(vector<int>v)\n{\n\tvector<int>r;\n\tr.resize(4);\n\tr[0] = v[1], r[1] = v[2], r[2] = v[3], r[3] = v[0];\n\treturn r;\n}\nvector<int>d[444];\ntypedef long long ll;\nunordered_map<ll, ll>ma;\nll conv(vector<int>v)\n{\n\treturn (((ll)v[0]) << 30) + (((ll)v[1]) << 20) + (((ll)v[2]) << 10) + ((ll)v[3]);\n}\nvoid add(vector<int>v)\n{\n\tll t = conv(v);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tma[t]++;\n\t\tt = ((t&((1LL << 40) - (1LL << 30))) >> 30) + ((t&((1LL << 30) - 1)) << 10);\n\t}\n}\nvoid sub(vector<int>v)\n{\n\tll t = conv(v);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tma[t]--;\n\t\tt = ((t&((1LL << 40) - (1LL << 30))) >> 30) + ((t&((1LL << 30) - 1)) << 10);\n\t}\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tvector<int>v;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tv.push_back(z);\n\t\t}\n\t\td[i] = v;\n\t\tadd(v);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = i + 1; j < num; j++)\n\t\t{\n\t\t\tvector<int>s = d[i], t = d[j];\n\t\t\tsub(s), sub(t);\n\t\t\tswap(t[0], t[2]);\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tll x = 1;\n\t\t\t\tvector<vector<int> >ddd;\n\t\t\t\tfor (int l = 0; l < 4; l++)\n\t\t\t\t{\n\t\t\t\t\tvector<int>z;\n\t\t\t\t\tz.resize(4);\n\t\t\t\t\tz[0] = s[1], z[1] = s[0], z[2] = t[0], z[3] = t[1];\n\t\t\t\t\tx *= ma[conv(z)];\n\t\t\t\t\tsub(z);\n\t\t\t\t\tddd.push_back(z);\n\t\t\t\t\ts = rotate(s), t = rotate(t);\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < 4; l++)add(ddd[l]);\n\t\t\t\t//if (x > 0)printf(\"%d %d %lld\\n\", i, j, x);\n\t\t\t\tans += x;\n\t\t\t\tt = rotate(t);\n\t\t\t}\n\t\t\tswap(t[0], t[2]);\n\t\t\tadd(s), add(t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans,c[410][4],h[410],v[4],tmp[4];\nunordered_map<ll,int>mp;\nvoid upd(ll x,int d){\n    for(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll))\n        mp[x]+=d;\n    return;\n}\nll Hash(ll *a){\n    ll ret=0;\n    for(int i=0;i<4;i++)\n        ret|=(a[i]<<(i*10ll));\n    return ret;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n        h[i]=Hash(c[i]);\n        upd(h[i],1);\n    }\n    for(int i=1;i<=n-5;i++){\n        upd(h[i],-1);\n        for(int j=i+1;j<=n;j++){\n            upd(h[j],-1);\n            for(int k=0;k<4;k++){\n                ll res=1;\n                for(int l=0;l<4;l++){\n                    ll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n                    v[l]=Hash(tmp);\n                    if(!mp.count(v[l]))\n                        goto to;\n                }\n                for(int l=0;l<4;l++){\n                    res*=mp[v[l]];\n                    upd(v[l],-1);\n                }\n                ans+=res;\n                for(int l=0;l<4;l++)\n                    upd(v[l],1);\n                to: ;\n            }\n            upd(h[j],1);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll ans;\nint n;\nstruct node{\n\tint a1,a2,a3,a4;\n\tnode() {}\n\tnode(int aa1,int aa2,int aa3,int aa4):a1(aa1),a2(aa2),a3(aa3),a4(aa4) {}\n\tbool operator <(const node &a) const {\n\t\tif(a1!=a.a1)\n\t\t\treturn a1<a.a1;\n\t\tif(a2!=a.a2)\n\t\t\treturn a2<a.a2;\n\t\tif(a3!=a.a3)\n\t\t\treturn a3<a.a3;\n\t\treturn a4<a.a4;\n\t}\n\tbool operator ==(const node &a) const{\n\t\tif(a1==a.a1&&a2==a.a2&&a3==a.a3&&a4==a.a4)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}t[MAXN];\nmap<node,ll> used;\nvoid solve(int b1,int b2,int b3,int b4){\n\tused[node(b1,b2,b3,b4)]++;\n}\nll check(node x,node y){\n\tll res=0;\n\tif(x==y)\n\t\tres++;\n\tint tx=y.a1;\n\ty.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\treturn res;\n}\t\nvoid count(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8){\n\t//PF(\"{%d %d %d %d %d %d %d %d}\\n\",b1,b2,b3,b4,b5,b6,b7,b8);\n\tnode x1=node(b1,b2,b6,b5);\n\tnode x2=node(b2,b3,b7,b6);\n\tnode x3=node(b3,b4,b8,b7);\n\tnode x4=node(b4,b1,b5,b8);\n\tnode sp1=node(b4,b3,b2,b1);\n\tnode sp2=node(b5,b6,b7,b8);\n\tll res1=used[x1];\n\tll res2=used[x2];\n\tll res3=used[x3];\n\tll res4=used[x4];\n\tres1=res1-check(sp1,x1)-check(sp2,x1);\n\tres2=res2-check(sp1,x2)-check(sp2,x2)-check(x1,x2);\n\tres3=res3-check(sp1,x3)-check(sp2,x3)-check(x1,x3)-check(x2,x3);\n\tres4=res4-check(sp1,x4)-check(sp2,x4)-check(x1,x4)-check(x2,x4)-check(x3,x4);\n\tans+=res1*res2*res3*res4;\n\t//PF(\"{%lld %lld %lld %lld %lld}\\n\",used[x1],res1,check(sp1,x1),check(sp2,x1),res4);\n}\nint main(){\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&t[i].a1,&t[i].a2,&t[i].a3,&t[i].a4);\n\t\tsolve(t[i].a4,t[i].a3,t[i].a2,t[i].a1);\n\t\tsolve(t[i].a3,t[i].a2,t[i].a1,t[i].a4);\n\t\tsolve(t[i].a2,t[i].a1,t[i].a4,t[i].a3);\n\t\tsolve(t[i].a1,t[i].a4,t[i].a3,t[i].a2);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a4,t[j].a3,t[j].a2,t[j].a1);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a3,t[j].a2,t[j].a1,t[j].a4);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a2,t[j].a1,t[j].a4,t[j].a3);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a1,t[j].a4,t[j].a3,t[j].a2);\t\n\t\t}\n\tPF(\"%lld\",ans/3ll);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\n//#include <cv.h>\n//#include <highgui.h>\n#include <stdlib.h>\n#include <string>\n\nlong long pow_mod(long long x, long long n, long long mod_num) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) { res = (res * x) % mod_num; }\n        x = (x * x) % mod_num;\n        n = (n >> 1);\n    }\n    return res;\n}\n\nclass Combi_Num {\n    public:\n    long long mod_num;\n    std::vector<long long> factorial, factorial_inv, inv;\n    Combi_Num() {}\n    Combi_Num(const int n, const long long mod_num_in) {\n        mod_num = mod_num_in;\n        factorial.resize(n+1, 0);\n        factorial_inv.resize(n+1, 0);\n        inv.resize(n+1, 0);\n        factorial[0] = 1;\n        factorial_inv[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i-1] * i) % mod_num;\n            inv[i] = pow_mod(i, mod_num - 2, mod_num);\n            factorial_inv[i] = (factorial_inv[i-1] * inv[i]) % mod_num;\n        }\n    }\n\n    long long combi(const int n, const int r) {\n        return (factorial[n] * ((factorial_inv[r] * factorial_inv[n-r]) % mod_num)) % mod_num;\n    }\n\n    long long perm(const int n, const int r) {\n        return (factorial[n] * factorial_inv[n-r]) % mod_num;\n    }\n};\n\n//const long long MOD = 1000000007;\nconst long long MOD = (long long)67280421310721;\nconst int MAX_N = 500;\nint N;\nint C[MAX_N][4];\n\nCombi_Num cn = Combi_Num(MAX_N, MOD);\n\nstd::vector<int> get_colors(int id, int rot) {\n    std::vector<int> ret;\n    for (int i = 0; i < 4; i++) {\n        ret.push_back(C[id][(i + rot) % 4]);\n    }\n    return ret;\n}\n\nstd::vector<int> get_std_colors(int id) {\n    std::vector<std::vector<int>> vec;\n    for (int i = 0; i < 4; i++) {\n        vec.push_back(get_colors(id, i));\n    }\n    std::sort(vec.begin(), vec.end());\n    return vec[0];\n}\n\nstd::vector<int> get_std_colors(const std::vector<int>& colors) {\n    assert(colors.size() == 4);\n    std::vector<std::vector<int>> vec;\n    for (int r = 0; r < 4; r++) {\n        std::vector<int> tmp;\n        for (int i = 0; i < 4; i++) {\n            tmp.push_back(colors[(i+r)%4]);\n        }\n        vec.push_back(tmp);\n    }\n    std::sort(vec.begin(), vec.end());\n    return vec[0];\n}\n\nint symmetry(const std::vector<int>& colors) {\n    assert(colors.size() == 4);\n    if (colors[0] == colors[1] && colors[1] == colors[2] && colors[2] == colors[3]) {\n        return 4;\n    }\n\n    if (colors[0] == colors[2] && colors[1] == colors[3]) {\n        return 2;\n    }\n    return 1;\n}\n\nstd::vector<std::vector<int>> get_middle(const std::vector<int>& c1, const std::vector<int>& c5) {\n    assert(c1.size() == 4);\n    assert(c5.size() == 4);\n    std::vector<std::vector<int>> ret;\n    ret.push_back(std::vector<int>({c1[0], c5[1], c5[0], c1[1]}));\n    ret.push_back(std::vector<int>({c1[1], c5[0], c5[3], c1[2]}));\n    ret.push_back(std::vector<int>({c1[2], c5[3], c5[2], c1[3]}));\n    ret.push_back(std::vector<int>({c1[3], c5[2], c5[1], c1[0]}));\n    return ret;\n}\n\nbool is_same(const std::vector<int>& c1, const std::vector<int>& c2) {\n    assert(c1.size() == 4);\n    assert(c2.size() == 4);\n    for (int i = 0; i < 4; i++) {\n        if (c1[i] != c2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::map<std::vector<int>, int> mp;\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    for (int i = 1; i <= N; i++) {\n        std::cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        mp[get_std_colors(i)]++;\n    }\n    \n    long long ret = 0;\n    for (int s1 = 1; s1 <= N; s1++) {\n        for (int s5 = s1 + 1; s5 <= N; s5++) {\n            for (int r5 = 0; r5 < 4; r5++) {\n                std::vector<std::vector<int>> middle = get_middle(get_colors(s1, 0), get_colors(s5, r5));\n                std::map<std::vector<int>, int> cnt;\n                for (auto m : middle) {\n                    cnt[get_std_colors(m)]++;\n                }\n                long long tmp = 1;\n                for (auto itr = cnt.begin(); itr != cnt.end(); ++itr) {\n                    if (mp.find(itr->first) == mp.end()) {\n                        tmp = 0;\n                        break;\n                    } else {\n                        long long cand_num = mp[itr->first];\n                        if (is_same(itr->first, get_std_colors(s1))) { cand_num--; }\n                        if (is_same(itr->first, get_std_colors(s5))) { cand_num--; }\n                        if (cand_num < itr->second) {\n                            tmp = 0;\n                            break;\n                        }\n                        tmp = tmp * cn.perm(cand_num, itr->second) * pow_mod(symmetry(itr->first), itr->second, MOD);\n                    }\n                }\n                ret += tmp;\n            }\n        }\n    }\n\n    std::cout << ret / 3 << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nlong long int converter(const int a, const int b, const int c, const int d) {\n\treturn ((a * 1000 + b) * 1000 + c) * 1000 + d;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>box(N, vector<int>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tlong long int ans = 0;\n\tmap<long long int, int>mp;\n\tmap<long long int, int>sz;\n\tmap<long long int, int>oold;\n\tfor (int i = N - 5; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 6; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<int>old(4, -1);\n\t\t\t\tvector<int>num(4, 0);\n\t\t\t\tvector<int>sum(4, 0);\n\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\tauto it = oold.find(converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4]));\n\t\t\t\t\tif (it != oold.end()) {\n\t\t\t\t\t\told[n] = it->second;\n\t\t\t\t\t\tsum[n] = mp[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t\tnum[n] = sz[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[j][m] && box[i][n] == box[j][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[j][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[j][(m + 3) % 4]) {\n\t\t\t\t\t\t\tsum[n]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m] && num[l]) {\n\t\t\t\t\t\t\tsum[l] -= num[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  map<sq, Int> dp;\n  auto dup=[&](const sq &a)->Int{\n    if(dp.count(a)) return dp[a];\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return dp[a]=res;\n  };\n  \n  auto norm=[&](const sq &a)->sq{\n    sq b(8);\n    map<Int, Int> m;\n    Int sz=0;\n    for(Int i=0;i<8;i++){\n      if(!m.count(a[i])) m[a[i]]=sz++;\n      b[i]=m[a[i]];\n    }\n    return b;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(norm(a)))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(norm(a));\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 405;\n\nint col[MAX][4];\n\nvoid rotate(int tmp[4])\n{\n  int poc = tmp[0];\n  for (int i=0; i<3; i++)\n    tmp[i] = tmp[i+1];\n  tmp[3] = poc;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i=0; i<n; i++)\n    for (int j=0; j<4; j++)\n      scanf(\"%d\", &col[i][j]);\n\n  ll rje = 0;\n  for (int i=0; i<n; i++) {\n    for (int j=i+1; j<n; j++) {\n      for (int rot=0; rot<4; rot++) {\n        int ima[4] = {0, 0, 0, 0};\n        int isti[4][4];\n        int sus[4] = {col[j][1], col[j][0], col[j][3], col[j][2]};\n        memset(isti, 0, sizeof isti);\n\n        for (int k=i+1; k<n; k++) {\n          if (k == j)\n            continue;\n          \n          int da[4] = {0, 0, 0, 0};\n          for (int r=0; r<4; r++) {\n            for (int l=0; l<4; l++) {\n              if (col[k][(l+0)%4] == col[i][(l+0)%4] &&\n                  col[k][(l+3)%4] == col[i][(l+1)%4] &&\n                  col[k][(l+2)%4] == sus[(l+1)%4] &&\n                  col[k][(l+1)%4] == sus[(l+0)%4]) {\n                da[l] = 1;\n\n              }\n            }\n\n            rotate(col[k]);\n          }\n\n          for (int l=0; l<4; l++) {\n            if (!ima[l] && da[l]) {\n              for (int dr=0; dr<4; dr++)\n                if (da[dr])\n                  isti[dr][l] = 1;\n            }\n            ima[l] += da[l];\n          }\n        }\n\n        int koef = 1;\n        for (int l=0; l<4; l++) {\n          int poc[4] = { col[i][l%4], col[i][(l+1)%4], sus[(l+1)%4], sus[l] };\n          int tmp[4];\n          memcpy(tmp, poc, sizeof tmp);\n\n          int br=0;\n          for (int r=0; r<4; r++) {\n            if (memcmp(tmp, poc, sizeof tmp) == 0)\n              br++;\n\n            rotate(tmp);\n          }\n\n          koef *= br;\n        }\n\n        ll tmp = 1;\n        for (int l=0; l<4; l++) {\n          tmp *= ima[l];\n          for (int k=0; k<4; k++)\n            if (isti[l][k])\n              ima[k]--;\n        }\n\n        rje += tmp * koef;\n        rotate(col[j]);\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", rje);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst LL MAX = 1e9;\nconst int SIZE = 410;\nLL an;\nint d[SIZE][4];\nLL val[SIZE];\nmap<LL,int>H,C;\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n}\nLL fix(LL x){\n    LL xx=x;\n    int cnt=1;\n    LL mi=x;\n    REP(k,3){\n        LL tmp=x/MAX;\n        x=(x-tmp*MAX)*1000+tmp;\n        mi=min(mi,x);\n        if(x==xx)cnt++;\n    }\n    C[mi]=cnt;\n    return mi;\n}\nint main(){\n    DRI(N);\n    REP(i,N){\n        //printf(\"%d:%lld\\n\",i,an);\n        REP(j,4)\n            RI(d[i][j]);\n        REP(j,i){\n            H[val[j]]--;\n            REP(r,4){\n                map<LL,int>shik;\n                REP(k,4){\n                    LL v=0;\n                    v=v*1000+d[j][(r-k+4)&3];\n                    v=v*1000+d[j][(r-k+3)&3];\n                    v=v*1000+d[i][(k+1)&3];\n                    v=v*1000+d[i][k&3];\n                    shik[fix(v)]++;\n                }\n                LL my_v=1;\n                for(map<LL,int>::iterator it=shik.begin();it!=shik.end();it++){\n                    if(H.count(it->F)){\n                        LL nn=H[it->F];\n                        REP(ker,it->S){\n                            my_v=my_v*nn%MOD;\n                            nn--;\n                            my_v=my_v*C[it->F]%MOD;\n                        }\n                    }\n                    else my_v=0;\n                }\n                ADD(an,my_v);\n            }\n            H[val[j]]++;\n        }\n        {\n            LL v=0;\n            REP(k,4)\n                v=v*1000+d[i][k];\n            val[i]=fix(v);\n            H[val[i]]++;\n        }\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n#define rep(i,a) for(int i=0; i<a; i++)\n#define rrep(i,a) for(int i=a; i>=0; i--)\n#define rep1(i,a) for(int i=1; i<=a; i++)\n#define cout1(a) cout << a << endl;\n#define cout2(a,b) cout << a << \" \" << b << endl;\n#define cout3(a,b,c) cout << a << \" \" << b << \" \" << c << endl;\n#define cout4(a,b,c,d) cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n#define mem(a,n) memset( a, n, sizeof(a))\n#define all(a) a.begin(),a.end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LLINF = 1e18;\nstatic const double pi = 3.141592653589793;\n\nint N;\nvector<ll> C[404];\nll vv[404];\nint R[404];\nmap<ll,int> B[5];\n\nll getkey(vector<ll> v){\n    ll r=1LL<<60;\n    rep(i,4){\n        rotate(v.begin(),v.begin()+1,v.end());\n        r=min(r,v[0]*1000000000+v[1]*1000000+v[2]*1000+v[3]);\n    }\n    return r;\n}\n\nll dfs(int cur, int n1, int n2, int n4){\n    if(cur==0) return 1;\n    ll ret=0;\n    if(n1) ret+=n1*dfs(cur-1,n1-1,n2,n4);\n    if(n2) ret+=2*n2*dfs(cur-1,n1,n2-1,n4);\n    if(n4) ret+=4*n4*dfs(cur-1,n1,n2,n4-1);\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>N;\n    rep(i,N){\n        vector<ll> v(4,0);\n        rep(j,4) cin>>v[j];\n        C[i]=v;\n        vv[i]=getkey(C[i]);\n        R[i]=1;\n        if(C[i][0]==C[i][2]&&C[i][1]==C[i][3]){\n            R[i]=2;\n            if(C[i][0]==C[i][1]) R[i]=4;\n        }\n        B[R[i]][vv[i]]++;\n    }\n    \n    ll ret=0;\n    rep(x,N){\n        B[R[x]][vv[x]]--;\n        for(int y=x+1;y<N;y++){\n            B[R[y]][vv[y]]--;\n            rep(z,4){\n                map<ll,int> mp;\n                mp[getkey({C[x][1],C[x][0],C[y][1],C[y][0]})]++;\n                mp[getkey({C[x][2],C[x][1],C[y][0],C[y][3]})]++;\n                mp[getkey({C[x][3],C[x][2],C[y][3],C[y][2]})]++;\n                mp[getkey({C[x][0],C[x][3],C[y][2],C[y][1]})]++;\n                \n                ll tmp=1;\n                for(auto r:mp){\n                    tmp*=dfs(r.second,B[1][r.first],B[2][r.first],B[4][r.first]);\n                    if(tmp==0)break;\n                }\n                ret += tmp;\n                rotate(C[y].begin(),C[y].begin()+1,C[y].end());\n            }\n            B[R[y]][vv[y]]++;\n        }\n    }\n    cout1(ret);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    cout << ans / 6 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=440,D=4;\nint i,j,k,n,m,ch,ff;\nll ans;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nstruct cc {\n\tint a[D];\n\tbool operator < (const cc &n) const {\n\t\tfor (int i=0;i<D;i++) if (a[i]!=n.a[i]) return a[i]<n.a[i];\n\t\treturn 0;\n\t}\n\tvoid rev() {\n\t\tint t=a[0];\n\t\tfor (int i=1;i<D;i++) a[i-1]=a[i];\n\t\ta[D-1]=t;\n\t}\n\tvoid change() {\n\t\tint t=a[1];a[1]=a[3];a[3]=t;\n\t}\n\t/*void change() {\n\t\tint i,j,k=0;\n\t\tint b[D];\n\t\tfor (i=0;i<D;i++) b[i]=a[i];\n\t\tfor (i=1;i<D;i++) {\n\t\t\tfor (j=0;j<D;j++) if (b[(i+j)%D]!=b[(k+j)%D]) {\n\t\t\t\tif (b[(i+j)%D]<b[(k+j)%D]) k=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i=0;i<D;i++) a[i]=b[(k+i)%D];\n\t}*/\n\tvoid read() {\n\t\tfor (int i=0;i<D;i++) R(a[i]);\n\t\t//change();\n\t}\n} A[N];\nmap<cc,int> Map;\nll work(cc a,cc b) {\n\tint i,j,k;\n\tcc t;\n\tll ans=1;\n\tfor (i=0;i<D;i++) {\n\t\tt.a[0]=a.a[(i+1)%D];t.a[1]=a.a[i];\n\t\tt.a[2]=b.a[i];t.a[3]=b.a[(i+1)%D];\n\t\tans*=Map[t];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t]--;\n\t\t}\n\t}\n\tfor (i=0;i<D;i++) {\n\t\tt.a[0]=a.a[(i+1)%D];t.a[1]=a.a[i];\n\t\tt.a[2]=b.a[i];t.a[3]=b.a[(i+1)%D];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t]++;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tR(n);ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tA[i].read();\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i]]++;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i]]--;\n\t\t}\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j]]--;\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[i].rev();\n\t\t\t\tans+=work(A[i],A[j]);\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j]]++;\n\t\t\t}\n\t\t}\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i]]++;\n\t\t}\n\t}\n\tW(ans/3);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nvvi a;\nmap<vi,int> m;\n\nvoid f(vi a,int t){\n\tfor(int i=0;i<4;i++){\n\t\tm[a]+=t;\n\t\tfor(int j=0;j<3;j++) swap(a[j],a[j+1]);\n\t}\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n,vi(4));\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<4;j++) cin>>a[i][j];\n\t\tf(a[i],1);\n\t}\n\tll res=0;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(i!=j){\n\t\tf(a[i],-1);f(a[j],-1);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint A[2][4];\n\t\t\tfor(int l=0;l<4;l++) A[0][l]=a[i][l];\n\t\t\tfor(int l=0;l<4;l++) A[1][l]=a[j][(4-l+k)%4];\n\t\t\tmap<vi,int> M;\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tvi b(4);\n\t\t\t\tb[0]=A[0][(l+1)%4];b[1]=A[0][l];\n\t\t\t\tb[3]=A[1][(l+1)%4];b[2]=A[1][l];\n\t\t\t\tvi b_=b;\n\t\t\t\tfor(int I=0;I<3;I++){\n\t\t\t\t\tfor(int J=0;J<3;J++) swap(b_[J],b_[J+1]);\n\t\t\t\t\tb=min(b,b_);\n\t\t\t\t}\n\t\t\t\tM[b]++;\n\t\t\t}\n\t\t\tll tmp=1;\n\t\t\tfor(auto it=M.begin();it!=M.end();it++){\n\t\t\t\tvi b=it->first;\n\t\t\t\tll t=it->second,B=m[b],type=1;\n\t\t\t\tif(b[0]==b[1]&&b[0]==b[2]&&b[0]==b[3]) type=4;\n\t\t\t\telse if(b[0]==b[2]&&b[1]==b[3]) type=2;\n\t\t\t\tfor(int l=0;l<t;l++) tmp*=B-type*l;\n\t\t\t}\n\t\t\tres+=tmp;\n\t\t}\n\t\tf(a[i],1);f(a[j],1);\n\t}\n\tcout<<res/6<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans,c[410][4],h[410],v[4],tmp[4];\nunordered_map<ll,int>mp;\nvoid upd(ll x,int d){\n    for(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll))\n        mp[x]+=d;\n    return;\n}\nll Hash(ll *a){\n    ll ret=0;\n    for(int i=0;i<4;i++)\n        ret|=(a[i]<<(i*10ll));\n    return ret;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n        h[i]=Hash(c[i]);\n        upd(h[i],1);\n    }\n    for(int i=1;i<=n-5;i++){\n        upd(h[i],-1);\n        for(int j=i+1;j<=n;j++){\n            upd(h[j],-1);\n            for(int k=0;k<4;k++){\n                ll res=1;\n                for(int l=0;l<4;l++){\n                    ll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n                    v[l]=Hash(tmp);\n                    if(!mp.count(v[l]))\n                        goto to;\n                }\n                for(int l=0;l<4;l++){\n                    res*=mp[v[l]];\n                    upd(v[l],-1);\n                }\n                ans+=res;\n                for(int l=0;l<4;l++)\n                    upd(v[l],1);\n                to: ;\n            }\n            upd(h[j],1);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint a[maxn], b[maxn], c[maxn], d[maxn];\nstd::unordered_map<ll, int> map;\nint n;\ninline ll pr(int a,int b,int c,int d) { return (ll) (a << 16 | b) << 32 | (c << 16 | d); }\ninline ll minpr(int a,int b,int c,int d) {\n\treturn std::min(std::min(pr(a, b, c, d), pr(b, c, d, a)), std::min(pr(c, d, a, b), pr(d, a, b, c)));\n}\ninline void swap(int & a,int & b,int & c,int & d) { int t = a; a = b, b = c, c = d, d = t; }\ninline void add(int a,int b,int c,int d,int v) { map[minpr(a, b, c, d)] += v; }\ninline ll C(int x,int v) {\n\tif(v == 1) return x;\n\tif(v == 2) return x * (x - 1);\n\tif(v == 3) return x * (x - 1) * (x - 2);\n\treturn (ll) x * (x - 1) * (x - 2) * (x - 3);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tmap.rehash(1e6 + 7);\n\tcin >> n;\n\trep(i, 1, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tadd(a[i], b[i], c[i], d[i], 1);\n\t}\n\tll ans = 0;\n\trep(i, 1, n) rep(j, 1, i - 1) {\n\t\tadd(a[i], b[i], c[i], d[i], -1);\n\t\tadd(a[j], b[j], c[j], d[j], -1);\n\t\tfor(int t = 0;t < 4;++t) {\n\t\t\tstd::map<ll, int> mp;\n\t\t\t++ mp[minpr(b[j], a[j], b[i], a[i])];\n\t\t\t++ mp[minpr(a[j], d[j], c[i], b[i])];\n\t\t\t++ mp[minpr(d[j], c[j], d[i], c[i])];\n\t\t\t++ mp[minpr(c[j], b[j], a[i], d[i])];\n\t\t\tll mul = 1;\n\t\t\tfor(auto i : mp) {\n\t\t\t\tif(i.first >> 16 == i.first << 16 >> 16) mul <<= i.second;\n\t\t\t\tif(i.first >> 32 == i.first << 32 >> 32) mul <<= i.second;\n\t\t\t\tmul *= C(map[i.first], i.second);\n\t\t\t}\n\t\t\tans += mul;\n\t\t\tswap(a[i], b[i], c[i], d[i]);\n\t\t}\n\t\tadd(a[i], b[i], c[i], d[i], 1);\n\t\tadd(a[j], b[j], c[j], d[j], 1);\n\t}\n\tcout << ans / 3 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mod 1000000007\n// #define mod 998244353\nusing namespace std;\n\nmap<vector<ll>, ll> mymap;\n\nvoid insert(vector<ll> &v)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tmymap[v]++;\n\t}\n}\n\nvoid remove(vector<ll> &v)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tmymap[v]--;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<ll> c[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tc[i].resize(4);\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tinsert(c[i]);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvector<ll> top = c[i];\n\t\tremove(top);\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tvector<ll> rev_bot = c[j], bot = c[j];\n\t\t\treverse(bot.begin(), bot.end());\n\t\t\tremove(rev_bot);\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tvector<ll> req[4];\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\treq[num].pb(top[num]);\n\t\t\t\t\treq[num].pb(top[(num + 1) % 4]);\n\t\t\t\t\treq[num].pb(bot[(num + 1) % 4]);\n\t\t\t\t\treq[num].pb(bot[num]);\n\t\t\t\t\treverse(req[num].begin(), req[num].end());\n\t\t\t\t}\n\t\t\t\tll temp_ans = 1;\n\t\t\t\tvector<bool> was_removed(4);\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\ttemp_ans *= mymap[req[num]];\n\t\t\t\t\tif (mymap[req[num]] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tremove(req[num]);\n\t\t\t\t\t\twas_removed[num] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\tif (was_removed[num])\n\t\t\t\t\t{\n\t\t\t\t\t\tinsert(req[num]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if (i == 1 && j == 3)\n\t\t\t\t// {\n\t\t\t\t// \tfor (int x : top)\n\t\t\t\t// \t{\n\t\t\t\t// \t\tcout << x << \" \";\n\t\t\t\t// \t}\n\t\t\t\t// \tcout << endl;\n\t\t\t\t// \tfor (int x : bot)\n\t\t\t\t// \t{\n\t\t\t\t// \t\tcout << x << \" \";\n\t\t\t\t// \t}\n\t\t\t\t// \tcout << endl;\n\t\t\t\t// \tfor (int num = 0; num < 4; num++)\n\t\t\t\t// \t{\n\t\t\t\t// \t\tfor (int x : req[num])\n\t\t\t\t// \t\t{\n\t\t\t\t// \t\t\tcout << x << \" \";\n\t\t\t\t// \t\t}\n\t\t\t\t// \t\tcout << endl;\n\t\t\t\t// \t}\n\t\t\t\t// \tcout << temp_ans << endl;\n\t\t\t\t// \tcout << endl;\n\t\t\t\t// }\n\t\t\t\tans += temp_ans;\n\t\t\t\trotate(bot.begin(), bot.begin() + 1, bot.end());\n\t\t\t}\n\t\t\tinsert(rev_bot);\n\t\t}\n\t\tinsert(top);\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef int ut;\ntypedef complex<int> cli;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr> PQ;\ntypedef tuple<int,int,int,int> TP;\ntypedef vector<TP> VTP;\nconst int INF=1<<30;\nconst int SIZE=1000;\nint C[SIZE][6];\nint countivity[SIZE];\nTP CC;\nTP conv(int a,int b,int c,int d){\n\treturn min(min(TP(a,b,c,d),TP(b,c,d,a)),min(TP(c,d,a,b),TP(d,a,b,c)));\n}\nTP conv(int x){\n\treturn conv(C[x][0],C[x][1],C[x][2],C[x][3]);\n}\nLL mult(TP x){\n\tif(get<0>(x)==get<2>(x) && get<1>(x)==get<3>(x)){\n\t\tif(get<0>(x)==get<1>(x)) return 4;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\nmap<TP,LL> mtp; \nLL getter(TP x,int t){\n\tif(t==0) return get<0>(x);\n\tif(t==1) return get<1>(x);\n\tif(t==2) return get<2>(x);\n\tif(t==3) return get<3>(x);\n}\nLL solve(int a,int b){\n\tLL ALLans=0;\n\tmtp[conv(a)]--;\n\tmtp[conv(b)]--;\n\tREP(k,4){\n\t\tLL ans=1;\n\t\tREP(i,4){\n\t\t\tTP next=conv(C[a][i],C[a][(i+1)%4],C[b][(i+1+k)%4],C[b][(i+k)%4]); \n\t\t\tans*=mtp[next]*mult(next);\n\t\t\tmtp[next]--;\n\t\t}\n\t\tREP(i,4){\n\t\t\tTP next=conv(C[a][i],C[a][(i+1)%4],C[b][(i+1+k)%4],C[b][(i+k)%4]); \n\t\t\tmtp[next]++;\n\t\t}\n\t\tALLans+=max<LL>(0,ans);\n\t}\n\tmtp[conv(a)]++;\n\tmtp[conv(b)]++;\n\treturn ALLans;\n}\nint main(){\n\tLL N;\n\tcin.tie(0);\n\tcin >> N;\n\tREP(i,N){\n\t\tREP(j,4){\n\t\t\tcin >> C[i][j];\t\t\n\t\t}\n\t\tmtp[conv(i)]=mtp[conv(i)]+1;\n\t}\n\tLL ans=0;\n\tREP(i,N)\n\t\tREP(j,i)\n\t\t\tans += solve(i,j);\n\tcout << ans/3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct Side\n{\n\tint a, b, c, d;\n\tSide(){}\n\tSide(int _a, int _b, int _c, int _d)\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t\tc = _c;\n\t\td = _d;\n\t}\n\tpair<pair<int, int>, pair<int, int> > get() const\n\t{\n\t\treturn make_pair(make_pair(a, b), make_pair(c, d));\n\t}\n};\nSide shift(Side s)\n{\n\treturn Side(s.b, s.c, s.d, s.a);\n}\nSide makeMin(Side s)\n{\n\tSide res = s;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\ts = shift(s);\n\t\tif (s.get() < res.get())\n                {\n                      res = s;\n                }\n\t}\n\treturn res;\n}\nbool operator<(const Side x, const Side y)\n{\n\treturn x.get() < y.get();\n}\nbool operator==(const Side x, const Side y)\n{\n\treturn x.get() == y.get();\n}\nconst int MAXN = 407;\nSide s[MAXN];\nmap<Side, int> have;\nint cnt(Side s)\n{\n\tSide ss = s;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (ss == s) res++;\n\t\tss = shift(ss);\n\t}\n\treturn res;\n}\nSide mirror(Side s)\n{\n\treturn Side(s.d, s.c, s.b, s.a);\n}\nint go(Side s)\n{\n\ts = mirror(s);\n\ts = makeMin(s);\n\tint res = have[s];\n\tif (res > 0)\n\t{\n\t\thave[s]--;\n\t}\n\treturn res * cnt(s);\n}\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d %d %d %d\", &s[i].a, &s[i].b, &s[i].c, &s[i].d);\n\t\ts[i] = makeMin(s[i]);\n\t}\n\tll res = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tSide down = s[i];\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tSide up = mirror(s[j]);\n\t\t\tfor (int rot = 0; rot < 4; rot++)\n\t\t\t{\n\t\t\t\tmap<Side, int> tmp = have;\n\t\t\t\thave[s[j]]--;\n\t\t\t\tll curRes = 1;\n\t\t\t\tcurRes *= go(Side(down.a, down.b, up.b, up.a));\n\t\t\t\tcurRes *= go(Side(down.b, down.c, up.c, up.b));\n\t\t\t\tcurRes *= go(Side(down.c, down.d, up.d, up.c));\n\t\t\t\tcurRes *= go(Side(down.d, down.a, up.a, up.d));\n\t\t\t\tup = shift(up);\n\t\t\t\thave = tmp;\n\t\t\t\tres += curRes;\n\t\t\t}\n\t\t}\n\t\thave[s[i]]++;\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000000000000000ll\n#define N 409\nusing namespace std;\n\nint n,a[N][4]; ll ans,sum,p[N],q[4];\nstruct hsh{\n\tint tot,fst[20000003],sz[N],tp[N],nxt[N]; ll pnt[N];\n\tvoid ins(ll x,int y){\n\t\tint i,z=x%20000003;\n\t\tfor (i=fst[z]; i; i=nxt[i]) if (pnt[i]==x){\n\t\t\tsz[i]+=y; return;\n\t\t}\n\t\tpnt[++tot]=x; sz[tot]=y;\n\t\tif ((x>>20)==(x&(1<<20)-1))\n\t\t\ttp[tot]=((x>>30)==(x&(1<<10)-1)?4:2);\n\t\telse tp[tot]=1;\n\t\tnxt[tot]=fst[z]; fst[z]=tot;\n\t}\n\tvoid solve(ll &x){\n\t\tint i,z=x%20000003;\n\t\tfor (i=fst[z]; i; i=nxt[i]) if (pnt[i]==x){\n\t\t\tsum*=tp[i]*(sz[i]--);\n\t\t\treturn;\n\t\t}\n\t\tx=-1; sum=0;\n\t}\n}hsh;\nll calc(int x1,int x2,int x3,int x4){\n\tint num[4]={x1,x2,x3,x4},i,j; ll tmp,mn=inf;\n\tfor (i=0; i<4; i++){\n\t\tfor (j=0,tmp=0; j<4; j++) tmp=tmp<<10|num[(i+j)&3];\n\t\tmn=min(mn,tmp);\n\t}\n\treturn mn;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j,k,l;\n\tfor (i=1; i<=n; i++){\n\t\tfor (j=0; j<4; j++) scanf(\"%d\",&a[i][j]);\n\t\tp[i]=calc(a[i][0],a[i][1],a[i][2],a[i][3]);\n\t\thsh.ins(p[i],1);\n\t}\n\tfor (i=1; i<n; i++){\n\t\thsh.ins(p[i],-1);\n\t\tfor (j=i+1; j<=n; j++){\n\t\t\thsh.ins(p[j],-1);\n\t\t\tfor (k=0; k<4; k++){\n\t\t\t\tfor (l=0,sum=1; l<4; l++){\n\t\t\t\t\tq[l]=calc(a[i][(l+1)&3],a[i][l],a[j][(k-l+5)&3],a[j][(k-l+4)&3]);\n\t\t\t\t\thsh.solve(q[l]);\n\t\t\t\t}\n\t\t\t\tans+=sum;\n\t\t\t\tfor (l=0; l<4; l++) if (q[l]!=-1) hsh.ins(q[l],1);\n\t\t\t}\n\t\t\thsh.ins(p[j],1);\n\t\t}\n\t\thsh.ins(p[i],1);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nconst LL LLINF = 1LL * INF * INF;\n\nLL choose[410][5], fac[5], ex[5][5];\n\nint n;\nLL c1[4], c2[4], c3[4], c4[4];\n\nvector<LL> tiles;\nmap<LL,LL> tileCnt;\n\nvoid rot4(LL arr[4]) {\n    swap(arr[0], arr[1]);\n    swap(arr[1], arr[2]);\n    swap(arr[2], arr[3]);\n}\n\nvoid reflect(LL arr[4]) {\n    swap(arr[0], arr[3]);\n    swap(arr[1], arr[2]);\n}\n\nvoid load(LL arr[4], LL t) {\n    FORD(i, 4) {\n        arr[i] = t % 1000;\n        t /= 1000;\n    }\n}\n\nLL rep(LL arr[4]) {\n    LL base = 1; LL res = 0;\n\n    FORD(i, 4) {\n        res += arr[i] * base;\n        base *= 1000;\n    }\n\n    return res;\n}\n\nLL minRep(LL arr[4]) {\n    LL best = LLINF;\n\n    FORN(i, 4) {\n        best = min(best, rep(arr));\n        rot4(arr);\n    }\n    \n    return best;\n}\n\nint main() {\n    choose[1][0] = choose[1][1] = 1;\n    for (int i = 2; i < 410; i++) {\n        choose[i][0] = 1;\n        for (int j = 1; j < 5; j++) {\n            choose[i][j] = choose[i-1][j-1] + choose[i-1][j];\n        }\n    }\n\n    fac[0] = 1; fac[1] = 1; fac[2] = 2; fac[3] = 6; fac[4] = 24;\n\n    FORN(i, 5) {\n        ex[i][0] = 1;\n        FOR1(j, 4) ex[i][j] = ex[i][j-1] * i;\n    }\n\n    GI(n);\n\n    FORN(i, n) {\n        FORN(j, 4) GLL(c1[j]);\n\n        LL mr = minRep(c1);\n        tiles.PB(mr); tileCnt[mr]++;\n    }\n\n//    PR0(tiles, n);\n    \n    LL res = 0;\n    \n    FORN(i, tiles.size()) { // top tile\n        tileCnt[tiles[i]]--; load(c1, tiles[i]);\n\n        for (int j = i + 1; j < tiles.size(); j++) { // bottom tile\n            tileCnt[tiles[j]]--; load(c2, tiles[j]); reflect(c2);\n\n            FORN(k, 4) { // for each rotation of the bottom tile\n                map<LL,LL> need; LL curr = 1;\n\n                FORN(l, 4) { // populate the tiles we need\n                    c3[0] = c1[l];\n                    c3[1] = c1[(l+3)%4];\n                    c3[2] = c2[(l+3)%4];\n                    c3[3] = c2[l];\n                    need[minRep(c3)]++;\n                }\n\n                for (auto& kv : need) {\n                    LL needTile = kv.FF; LL needCnt = kv.SS;\n                    \n                    if (tileCnt[needTile] < needCnt) {\n                        curr *= 0;\n                    }\n                    else {\n                        // count rotational symmetries of needTile\n                        load(c3, needTile); LL rotSym = 0;\n\n                        FORN(m, 4) {\n                            rotSym += (rep(c3) == needTile);\n                            rot4(c3);\n                        }\n\n                        // choices * tile ordering * rotations\n                        curr *= choose[tileCnt[needTile]][needCnt] * fac[needCnt] * ex[rotSym][needCnt];\n                    }\n                }\n\n                res += curr;\n                rot4(c2);\n            }\n            tileCnt[tiles[j]]++;\n        }\n        tileCnt[tiles[i]]++;\n    }\n\n    cout << res / 3 << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int> >t;\nmultiset<vector<int> >v;\nint n,c;\nlong long ans,cnt,tt;\nvector<int> rot(vector<int> vv){return {vv[1],vv[2],vv[3],vv[0]};}\nint main()\n{\n\tvector<int>t1,t2;\n\tvector<vector<int> >::iterator it1,it2;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tt.push_back({a,b,c,d});\n\t}\n\tsort(t.begin(),t.end());\n\tfor(it1=t.begin();it1!=t.end();it1++)\n\t{\n\t\tfor(it2=it1,it2++;it2!=t.end();it2++)\n\t\t{\n\t\t\tt1=*it1;t2=*it2;\n\t\t\tfor(int d=0;d<4;d++,t2=rot(t2))\n\t\t\t{\n\t\t\t\tv.clear();\n\t\t\t\tv.insert(t1);\n\t\t\t\tv.insert(t2);\n\t\t\t\tcnt=1;\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\t{\n\t\t\t\t\ttt=0;\n\t\t\t\t\tvector<int> vv={t1[(i+1)%4],t1[i%4],t2[(4-i)%4],t2[(7-i)%4]};\n\t\t\t\t\tfor(int j=0;j<4;j++,vv=rot(vv))\n\t\t\t\t\t{\n\t\t\t\t\t\ttt+=upper_bound(t.begin(),t.end(),t)-lower_bound(t.begin(),t.end(),t);\n\t\t\t\t\t\ttt-=v.count(vv);\n\t\t\t\t\t}\n\t\t\t\t\ttt=max(tt,0ll);\n\t\t\t\t\tcnt*=tt;\n\t\t\t\t\tv.insert(vv);\n\t\t\t\t}\n\t\t\t\tans+=cnt;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n;\nlong long bin[5],ans;\nlong long a[405][4],A[4],B[4];\nmap<long long,long long>mp;\nlong long gao(long long aa,long long bb)\n{\n\tlong long qwq=0;\n\tfor(long long j=0;j<4;++j) qwq+=bin[j]*a[aa][(bb+j)%4];\n\treturn qwq;\n}\nlong long md(long long aa,long long bb,long long cc)\n{\n\ta[n+1][0]=A[aa];a[n+1][1]=B[aa];\n\ta[n+1][2]=B[bb];a[n+1][3]=A[bb];\n\tlong long tmp=mp[gao(n+1,0)];\n\tfor(long long i=0;i<4;++i) mp[gao(n+1,i)]-=cc;\n\treturn tmp;\n}\nvoid getans()\n{\n\tans+=md(0,1,1)*md(1,2,1)*md(2,3,1)*md(3,0,1);\n\tmd(0,1,-1);md(1,2,-1);md(2,3,-1);md(3,0,-1);\n\treturn;\n}\nint main()\n{\n\tn=read();bin[0]=1;\n\tfor(long long i=1;i<4;++i) bin[i]=bin[i-1]*1000;\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tfor(long long j=0;j<4;++j) a[i][j]=read();\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]--,A[j]=a[i][j];\n\t\tfor(long long j=i+1;j<=n;++j)\n\t\t{\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]--;\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l)\n\t\t\t{\n\t\t\t\tfor(long long k=0;k<4;++k) B[k]=a[j][(k+l)%4];\n\t\t\t\tgetans();\n\t\t\t}\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]++;\n\t\t}\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\twrite(ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t5005\n#define MAXV\t1000\n#define P\t1200007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct Hash_Table {\n\tvector <long long> value[P];\n\tvector <int> cnt[P];\n\tint query(long long val) {\n\t\tint head = val % P;\n\t\tfor (unsigned i = 0; i < value[head].size(); i++)\n\t\t\tif (value[head][i] == val) return cnt[head][i];\n\t\treturn 0;\n\t}\n\tvoid modify(long long val, int delta) {\n\t\tint head = val % P;\n\t\tfor (unsigned i = 0; i < value[head].size(); i++)\n\t\t\tif (value[head][i] == val) {\n\t\t\t\tcnt[head][i] += delta;\n\t\t\t\treturn;\n\t\t\t}\n\t\tvalue[head].push_back(val);\n\t\tcnt[head].push_back(delta);\n\t}\n} cnt;\nint n, a[MAXN], b[MAXN], c[MAXN], d[MAXN];\nlong long Hash(int a, int b, int c, int d) {\n\tlong long ans = a;\n\tans = ans * MAXV + b;\n\tans = ans * MAXV + c;\n\tans = ans * MAXV + d;\n\treturn ans;\n}\nint Count(int a, int b, int c, int d) {\n\treturn cnt.query(Hash(a, b, c, d));\n}\nvoid Modify(int a, int b, int c, int d, int x) {\n\tcnt.modify(Hash(a, b, c, d), x);\n\tcnt.modify(Hash(d, a, b, c), x);\n\tcnt.modify(Hash(c, d, a, b), x);\n\tcnt.modify(Hash(b, c, d, a), x);\n}\nlong long Query(int a, int b, int c, int d, int A, int B, int C, int D) {\n\tlong long ans = 1;\n\tans *= Count(a, A, B, b);\n\tModify(a, A, B, b, -1);\n\tans *= Count(b, B, C, c);\n\tModify(b, B, C, c, -1);\n\tans *= Count(c, C, D, d);\n\tModify(c, C, D, d, -1);\n\tans *= Count(d, D, A, a);\n\tModify(a, A, B, b, 1);\n\tModify(b, B, C, c, 1);\n\tModify(c, C, D, d, 1);\n\treturn ans;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]), read(b[i]), read(c[i]), read(d[i]);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tModify(a[j], b[j], c[j], d[j], -1);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], d[j], c[j], b[j], a[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], a[j], d[j], c[j], b[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], b[j], a[j], d[j], c[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], c[j], b[j], a[j], d[j]);\n\t\t\tModify(a[j], b[j], c[j], d[j], 1);\n\t\t}\n\t\tModify(a[i], b[i], c[i], d[i], 1);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int mod=1e7+9;\nconst int MAX_H=1e5+5;\n\nstruct Hash\n{\n    int nex, w, s;\n    ll val;\n    Hash(int _n=0, int _w=0, int _s=0, ll _v=0):nex(_n), w(_w), s(_s), val(_v){}\n}h[MAX*10];\n\nint tot, N, t, C[MAX][5], head[MAX_H*10];\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    if(id)\n    {\n        h[id].w+=t;\n        return;\n    }\n    id=++tot, h[id].nex=head[fr], h[id].val=H, head[fr]=id, h[id].w=t;\n    h[id].s=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n}\n\ninline int Find(ll H)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    return h[id].w*h[id].s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            vector<pair<int,int>> update;\n            vector<i64> sum(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(k!=i and k!=j){\n                    rep(i_,0,4){\n                        if(b&(1<<i_) or Csum[k]!=sum[i_]) continue;\n                        rep(j_,0,4) if(match(rotatedC[k][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                rep(i_,0,4){\n                    sum[i_]=0;\n                    rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                }\n                \n                ans+=rec(i+1,0);\n                \n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> cyc(V<int> a) {\n\tVV<int> cand;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(a[(j+k)%4]);\n\t\t}\n\t\tcand.pb(vec);\n\t}\n\treturn *min_element(ALL(cand));\n}\n\nint com(V<int>& v) {\n\tint cnt = 0;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(v[(j+k)%4]);\n\t\t}\n\t\tif (vec == v) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> vf;\n\n\tmap<V<int>, int> T, coef;\n\n\trep(i, N) {\n\t\tV<int> a(4);\n\t\trep(j, 4) cin >> a[j];\n\n\t\tauto vec = cyc(a);\n\t\tvf.pb(vec);\n\t\t++T[vec];\n\t\tdump(vec);\n\t\tcoef[vec] = com(vec);\n\t}\n\n\tll ans = 0;\n\n\trep(i, N) {\n\t\trep(j, N) if (i != j) {\n\t\t\t--T[vf[i]];\n\t\t\t--T[vf[j]];\n\n\t\t\trep(k, 4) {\n\t\t\t\tint up[4], dw[4];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tup[l] = vf[i][l];\n\t\t\t\t\tdw[l] = vf[j][(k-l+4)%4];\n\t\t\t\t}\n\n\t\t\t\tll t = 1;\n\n\t\t\t\tVV<int> use;\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tV<int> vec{up[l],up[(l+3)%4],dw[(l+3)%4],dw[l]};\n\t\t\t\t\tvec = cyc(vec);\n\t\t\t\t\tuse.pb(vec);\n\t\t\t\t\tt *= T[vec] * coef[vec];\n\t\t\t\t\t--T[vec];\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\trep(l, 4) ++T[use[l]];\n\t\t\t}\n\n\t\t\t++T[vf[i]];\n\t\t\t++T[vf[j]];\t\t\t\n\t\t}\n\t}\n\tdump(ans);\n\n\tcout << ans / 6 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nint n;\nvi B[1010];\nmap<ll,int> Mp;\nvi CirA , CirB , Tmp , Block[4];\nll h[1010][4] , Min[1010];\nll C[1010][1010] = {{1}};\nll id(vi v){\n    ll r = 0;\n    rep(i,0,sz(v)) r = r * 1000 + v[i];\n    return r;\n}\nll Hash(vi v,int rot){\n    Tmp = v;\n    rep(i,0,4) Tmp[i] = v[(i+rot)&3];\n    return id(Tmp);\n}\nll solve(int a,int b,int rot){\n    CirB = CirA = B[a];Tmp = B[b];\n    swap(Tmp[0],Tmp[1]);swap(Tmp[2],Tmp[3]);\n    rep(i,0,4) CirB[i] = Tmp[(i+rot)&3];\n    ll hash[4][4] , mm[4] , cc[4] = {0};\n    ll mul = 1;\n    map<ll,int> Cnt;\n    rep(i,0,4){\n        Block[i] = vi{CirA[(i+1)&3] , CirA[i] , CirB[i] , CirB[(i+1)&3]};\n        mm[i] = 1ll<<62;\n        rep(j,0,4) hash[i][j] = Hash(Block[i] , j) , mm[i] = min(mm[i] , hash[i][j]);\n        rep(j,0,4) cc[i] += hash[i][j] == hash[i][0];\n        Cnt[mm[i]]++;\n        mul *= cc[i];\n    }\n    static int f[10] = {1};\n    rep(i,1,10) f[i] = f[i-1] * i;\n    for(auto e : Cnt){\n        ll x = e.fi;int y = e.se;\n        if(Mp.count(x) == 0) return 0;\n        int c = Mp[x];\n        if(c < y) return 0;\n        else mul *= C[c][y] * f[y];\n    }\n    return mul;\n}\n\n\nint main(){\n    rep(i,1,1010) rep(j,0,1010) C[i][j] = j ? C[i-1][j-1] + C[i-1][j] : 1;\n    scanf(\"%d\",&n);\n    rep(i,0,n){\n        int x;rep(j,0,4) scanf(\"%d\",&x) , B[i].pb(x);\n    }\n    rep(i,0,n) Min[i] = 1ll<<62;\n    rep(i,0,n) rep(j,0,4) h[i][j] = Hash(B[i] , j) , Min[i] = min(Min[i] , h[i][j]);\n    rep(i,0,n) Mp[Min[i]]++;\n    ll ans = 0;\n    rep(i,0,n) rep(j,i+1,n) rep(d,0,4){\n        Mp[Min[i]]--;Mp[Min[j]]--;\n        ans += solve(i , j , d);\n        Mp[Min[i]]++;Mp[Min[j]]++;\n    }\n    ans /= 3;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> c; assign(c, n, 4, 0);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < 4; ++j) cin >> c[i][j];\n  lint res = 0;\n  for (int d = 0; d < n; ++d) for (int u = 0; u < n; ++u) if (d != u) {\n    for (int dir = 0; dir < 4; ++dir) {\n      VV<> cnt; assign(cnt, n, 4, 0);\n      for (int i = 0; i < n; ++i) if (i != d and i != u) {\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < 4; ++k) {\n            if (c[i][k + 0 & 3] != c[u][dir - j & 3]) continue;\n            if (c[i][k + 1 & 3] != c[u][dir - j - 1 & 3]) continue;\n            if (c[i][k + 2 & 3] != c[d][j + 1 & 3]) continue;\n            if (c[i][k + 3 & 3] != c[d][j & 3]) continue;\n            ++cnt[i][j];\n          }\n        }\n      }\n      V<lint> dp0(16), dp1(16);\n      dp0[0] = 1;\n      for (int i = 0; i < n; ++i) {\n        dp1 = dp0;\n        for (int bit = 1; bit < 16; ++bit) {\n          for (int j = 0; j < 4; ++j) if (bit & 1 << j) {\n            dp1[bit] += dp0[bit ^ 1 << j] * cnt[i][j];\n          }\n        }\n        swap(dp0, dp1);\n      }\n      res += dp0[15];\n    }\n  }\n  cout << res / 6 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nlint key(const V<>& v) {\n  lint res = 0;\n  for (int i = 0; i < 4; ++i) {\n    lint curr = 0;\n    for (int j = 0; j < 4; ++j) curr += static_cast<lint>(v[i + j & 3]) << 10 * j;\n    res = max(res, curr);\n  }\n  return res;\n}\n\nint coeff(lint key) {\n  V<> v(4);\n  for (int i = 0; i < 4; ++i) {\n    v[i] = key & 1023;\n    key >>= 10;\n  }\n  if (v[0] == v[2] and v[1] == v[3]) {\n    if (v[0] == v[1]) return 4;\n    return 2;\n  }\n  return 1;\n}\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> c; assign(c, n, 4, 0);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < 4; ++j) cin >> c[i][j];\n  map<lint, lint> mp;\n  for (int i = 0; i < n; ++i) ++mp[key(c[i])];\n  lint res = 0;\n  for (int d = 0; d < n; ++d) for (int u = d + 1; u < n; ++u) {\n    --mp[key(c[d])], --mp[key(c[u])];\n    for (int dir = 0; dir < 4; ++dir) {\n      V<lint> keys(4);\n      for (int i = 0; i < 4; ++i) keys[i] = key({c[u][dir - i & 3], c[u][dir - i - 1 & 3], c[d][i + 1 & 3], c[d][i]});\n      sort(begin(keys), end(keys));\n      int bit = 0;\n      for (int i = 0; i < 3; ++i) if (keys[i] == keys[i + 1]) bit |= 1 << i;\n      auto f = [&](const V<>& v) -> lint {\n        lint res = 1;\n        for (int i = 0; i < 4; ++i) {\n          if (mp.count(keys[i])) res *= coeff(keys[i]) * (mp[keys[i]] - v[i]);\n          else return 0;\n        }\n        return res;\n      };\n      switch (bit) {\n        case 0b000: res += f({0, 0, 0, 0}); break;\n        case 0b001: res += f({0, 1, 0, 0}); break;\n        case 0b010: res += f({0, 0, 1, 0}); break;\n        case 0b011: res += f({0, 1, 2, 0}); break;\n        case 0b100: res += f({0, 0, 0, 1}); break;\n        case 0b101: res += f({0, 1, 0, 1}); break;\n        case 0b110: res += f({0, 0, 1, 2}); break;\n        case 0b111: res += f({0, 1, 2, 3}); break;\n      }\n    }\n    ++mp[key(c[d])], ++mp[key(c[u])];\n  }\n  cout << res / 3 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=410;\nint n,c[N][8];\nll state(int a,int b,int c,int d){\n\tll ans=0;\n\tans=ans*1000+a;\n\tans=ans*1000+b;\n\tans=ans*1000+c;\n\tans=ans*1000+d;\n\treturn ans;\n}\nmap<ll,int> M;ll ans;\nvoid add(int a,int b,int c,int d,int v){\n\tM[state(a,b,c,d)]+=v;\n\tM[state(b,c,d,a)]+=v;\n\tM[state(c,d,a,b)]+=v;\n\tM[state(d,a,b,c)]+=v;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&c[i][j]),c[i][j+4]=c[i][j];\n\t\tadd(c[i][0],c[i][1],c[i][2],c[i][3],1);\n\t}\n\t//标号最小的正方形作为正面\n\tfor (int i=1;i<=n;i++){\n\t\tadd(c[i][0],c[i][1],c[i][2],c[i][3],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tadd(c[j][0],c[j][1],c[j][2],c[j][3],-1);\n\t\t\tfor (int *C=c[j];C<c[j]+4;C++){//枚举反面和旋转后的方向\n\t\t\t\tll calc=1;\n\t\t\t\tcalc*=M[state(c[i][1],c[i][0],C[1],C[0])];\n\t\t\t\tadd(c[i][1],c[i][0],C[1],C[0],-1);\n\t\t\t\tcalc*=M[state(c[i][0],c[i][3],C[2],C[1])];\n\t\t\t\tadd(c[i][0],c[i][3],C[2],C[1],-1);\n\t\t\t\tcalc*=M[state(c[i][3],c[i][2],C[3],C[2])];\n\t\t\t\tadd(c[i][3],c[i][2],C[3],C[2],-1);\n\t\t\t\tcalc*=M[state(c[i][2],c[i][1],C[0],C[3])];\n\t\t\t\tadd(c[i][3],c[i][2],C[3],C[2],1);\n\t\t\t\tadd(c[i][0],c[i][3],C[2],C[1],1);\n\t\t\t\tadd(c[i][1],c[i][0],C[1],C[0],1);\n\t\t\t\tans+=calc;\n\t\t\t}\n\t\t\tadd(c[j][0],c[j][1],c[j][2],c[j][3],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<vector<int> > pane(N,vector<int>(4));\n\tfor(int i=0;i<N;++i){\n\t\tvector<int> temp(4),res(4);\n\t\tfor(int j=0;j<4;++j){\n\t\t\tcin >> temp[j];\n\t\t}\n\t\tres = temp;\n\t\tfor(int j=0;j<3;++j){\n\t\t\trotate(temp.begin(),temp.begin()+1,temp.end());\n\t\t\tres = min(res,temp);\n\t\t}\n\t\tpane[i] = res;\n\t}\n\tmap<vector<int>,int> pMap;\n\tfor(int i=0;i<N;++i){\n\t\tpMap[ pane[i] ]++;\n\t}\n\t/*\n\t\t  5---4\n\t\t /|  /|\n\t\t0-6-1 7 ←6が裏\n\t\t|/  |/\n\t\t3---2\n\t*/\n\tvector< vector<int> > men(6,vector<int>(4));\n\tmen[0][0]=0;men[0][1]=1;men[0][2]=2;men[0][3]=3;\n\tmen[1][0]=1;men[1][1]=0;men[1][2]=5;men[1][3]=4;\n\tmen[2][0]=2;men[2][1]=1;men[2][2]=4;men[2][3]=7;\n\tmen[3][0]=3;men[3][1]=2;men[3][2]=7;men[3][3]=6;\n\tmen[4][0]=0;men[4][1]=3;men[4][2]=6;men[4][3]=5;\n\tmen[5][0]=4;men[5][1]=5;men[5][2]=6;men[5][3]=7;\n\t//0,5面を決定して[1,4]面を探す\n\t\n\tmap<vector<int>,LL> Bmap;\n\tvector<int> pos(8);\n\tLL ans = 0;\n\tfor(int A=0;A<=N-6;++A){\n\t\tfor(int i=0;i<4;++i){\n\t\t\tpos[i] = pane[A][i];\n\t\t}\n\t\tpMap[ pane[A] ]--;//減らす\n\t\tfor(int B=A+1;B<N;++B){\n\t\t\tvector<int> temp = pane[B];\n\t\t\tfor(int d=0;d<4;++d){//Bの回転\n\t\t\t\t/*if( Bmap[ temp ] ){\n\t\t\t\t\tans += Bmap[ temp ];\n\t\t\t\t\trotate(temp.begin(),temp.begin()+1,temp.end());\n\t\t\t\t\tcontinue;\n\t\t\t\t}*/\n\t\t\t\tLL resABD = 1;//A,Bと回転での通り数\n\t\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\t\tpos[i+4] = temp[i];\n\t\t\t\t}\n\t\t\t\t//8頂点の色が決まった\n\t\t\t\t\n\t\t\t\tmultiset<vector<int> > inSet;//\n\t\t\t\tinSet.insert( pane[B] );\n\t\t\t\t//4枚決める\n\t\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\t\tvector<int> ter(4);//探す面\n\t\t\t\t\tLL mul = 1;//対称の場合\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tter[j] = pos[ men[i+1][j] ];\n\t\t\t\t\t}\n\t\t\t\t\t{//小さい値の並びを代表とする\n\t\t\t\t\t\tvector<int> temp = ter;\n\t\t\t\t\t\tfor(int k=0;k<3;++k){\n\t\t\t\t\t\t\trotate(temp.begin(),temp.begin()+1,temp.end());\n\t\t\t\t\t\t\tif( ter == temp ){\n\t\t\t\t\t\t\t\tmul++;\n\t\t\t\t\t\t\t}else if( temp < ter ){\n\t\t\t\t\t\t\t\tter = temp;\n\t\t\t\t\t\t\t\tmul = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLL res = pMap[ ter ];\n\t\t\t\t\tLL sub = inSet.count( ter );//既に配置しているかチェック\n\t\t\t\t\tres -= sub;\n\t\t\t\t\tif( res <= 0 ){\n\t\t\t\t\t\tresABD = 0;//配置できなかった\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tresABD *= (res*mul);\n\t\t\t\t\t}\n\t\t\t\t\tinSet.insert( ter );\n\t\t\t\t}\n\n\t\t\t\tBmap[ temp ] = resABD;\n\t\t\t\tans += resABD;\n\t\t\t\t//次のための回転\n\t\t\t\trotate(temp.begin(),temp.begin()+1,temp.end());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\t\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvi shift(vi vec, int c) { //shift in << this direction\n\tvi res(sz(vec));\n\trep(i, 0, sz(vec)) {\n\t\tres[i] = vec[(i + c) % sz(vec)];\n\t}\n\treturn res;\n}\n\nvi norm(vi vec) {\n\tvi res = vec;\n\trep(i, 1, sz(vec)) {\n\t\tvi tmp = shift(vec, i);\n\t\tif(res > tmp) res = tmp;\n\t}\n\treturn res;\n}\n\nll mypow(int a, int b) {\n\tll res = 1;\n\twhile(b--) res *= a;\n\treturn res;\n}\n\n\nll P(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\tll res = 1;\n\trep(i, 0, b) {\n\t\tres *= a - i;\n\t}\n\treturn res;\n}\n\nint N;\nvi D[MAX_N];\nmap<vi, int> E;\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\trep(j, 0, 4) {\n\t\t\tint a; cin >> a;\n\t\t\tD[i].pb(a);\n\t\t}\n\t\tD[i] = norm(D[i]);\n\t\tE[D[i]]++;\n\t}\n\tll ans = 0;\n\trep(i, 0, N) {\n\t\tvi v1 = D[i];\n\t\tE[D[i]]--;\n\t\trep(j, i + 1, N) {\n\t\t\tE[D[j]]--;\n\t\t\trep(k, 0, 4) {\n\t\t\t\tvi v2 = shift(D[j], k);\n\n\t\t\t\tmap<vi, int> M;\n\t\t\t\trep(l, 0, 4) {\n\t\t\t\t\tint at1 = l, at2 = (l + 1) % 4;\n\t\t\t\t\tint bt1 = (4 - l) % 4, bt2 = (4 - l + 1) % 4;\n\t\t\t\t\tvi tmp(4);\n\t\t\t\t\ttmp[0] = v1[at2];\n\t\t\t\t\ttmp[1] = v1[at1];\n\t\t\t\t\ttmp[2] = v2[bt2];\n\t\t\t\t\ttmp[3] = v2[bt1];\n\t\t\t\t\tM[norm(tmp)]++;\n\t\t\t\t}\n\t\t\t\tll tmp = 1;\n\t\t\t\tfor(auto pp: M) {\n\t\t\t\t\tif(E.count(pp.fst)) tmp *= P(E[pp.fst], pp.sec);\n\t\t\t\t\telse tmp = 0;\n\t\t\t\t\tll coef = 1;\n\t\t\t\t\tif(count(all(pp.fst), pp.fst[0]) == sz(pp.fst)) coef = 4;\n\t\t\t\t\telse if(pp.fst[0] == pp.fst[2] && pp.fst[1] == pp.fst[3]) coef = 2;\n\t\t\t\t\ttmp *= mypow(coef, pp.sec);\n\t\t\t\t\t// debug(i, j, k, v1, v2, tmp, pp.fst, coef, pp.sec, vector<pair<vi, int>>(all(E)));\n\t\t\t\t}\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tE[D[j]]++;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\nbool cmp(vector<ll> a, vector<ll> b) {\n\trep(j, 4) {\n\t\tif (a[j] < b[j]) { return true; }\n\t\tif (a[j] > b[j]) { return false; }\n\t}\n\treturn false;\n}\n\nll com(ll a, ll b) {\n\tif (a < b) { return 0; }\n\n\tll ret = 1;\n\tfor (ll i = a; i >= a - b + 1; i--)ret *= i;\n\t\n\treturn ret;\n}\n\nvector<ll> rotate(vector<ll> s, ll j) {\n\tvector<ll> ret(4);\n\n\trep(i, 4) { ret[i] = s[(i + j) % 4]; }\n\t\n\treturn ret;\n}\n\nvector<ll> normalize(vector<ll> s) {\n\tvector<ll> ret = s;\n\n\trep(i, 4) { if (cmp(rotate(s, i), ret)) { ret = rotate(s, i); } }\n\n\treturn ret;\n}\n\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\tmap<vector<ll>, ll> mp;\n\t\n\trepn(i, N) {\n\t\tvector<ll> s(4);\n\t\trep(j, 4) cin >> s[j];\n\n\t\ts = normalize(s);\n\t\t//cout << s << endl;\n\t\tmp[s]++;\n\t}\n\n\tll ans = 0;\n\n\tfor (auto p : mp)for (auto q : mp) {\n\t\tvector<vector<ll>> s(6, vector<ll>(4, 0));\n\n\t\ts[0] = p.first;\n\n\t\t\n\n\t\trep(j, 4) {\n\t\t\ts[1] = rotate(q.first, j);\n\n\t\t\trep(k, 4) {\n\t\t\t\ts[k + 2][0] = s[0][k];\n\t\t\t\ts[k + 2][1] = s[1][3-k];\n\t\t\t\ts[k + 2][2] = s[1][(6-k) % 4];\n\t\t\t\ts[k + 2][3] = s[0][(k + 1) % 4];\n\t\t\t\t\n\t\t\t}\n\t\t\t//rep(k, 6) cout << s[k] << \" \";\n\t\t\t//cout << endl;\n\t\t\t\n\t\t\trep(k, 6) { s[k] = normalize(s[k]); }\n\n\t\t\t//rep(k, 6) cout << s[k] << \" \";\n\t\t\t//cout << endl;\n\n\t\t\tmap<vector<ll>, ll> men;\n\t\t\trep(k, 6) { men[s[k]]++; }\n\n\t\t\tll count = 1;\n\t\t\tfor (auto r : men) {\n\t\t\t\tvector<ll> u = r.first;\n\t\t\t\tif (!mp.count(u)) { count = 0; break; }\n\t\t\t\tcount *= com(mp[u], men[u]);\n\t\t\t\t//cout << u <<\" \"<< mp[u] <<\" \"<< men[u] << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\n\t\t\trep(k, 4) {\n\t\t\t\tll c = 0;\n\t\t\t\trep(l, 4) { if (s[k+2] == rotate(s[k+2], l)) { c++; } }\n\t\t\t\tcount *= c;\n\t\t\t}\n\n\t\t\tans += count;\n\t\t}\n\t}\n\n\tcout << ans/6 << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\n// @@ !! LIM(debug)\n// --> f:<< debug\n// ---- inserted function << from util.cc\ntemplate <typename T1, typename T2>\nostream& operator<< (ostream& os, const pair<T1,T2>& p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\n\ntemplate <typename T1, typename T2, typename T3>\nostream& operator<< (ostream& os, const tuple<T1,T2,T3>& t) {\n  os << \"(\" << get<0>(t) << \", \" << get<1>(t)\n     << \", \" << get<2>(t) << \")\";\n  return os;\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nostream& operator<< (ostream& os, const tuple<T1,T2,T3,T4>& t) {\n  os << \"(\" << get<0>(t) << \", \" << get<1>(t)\n     << \", \" << get<2>(t) << \", \" << get<3>(t) << \")\";\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const vector<T>& v) {\n  os << '[';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << ']';\n\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const set<T>& v) {\n  os << '{';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << '}';\n\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const multiset<T>& v) {\n  os << '{';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << '}';\n\n  return os;\n}\n\ntemplate <typename T1, typename T2>\nostream& operator<< (ostream& os, const map<T1, T2>& mp) {\n  os << '[';\n  for (auto it = mp.begin(); it != mp.end(); it++) {\n    if (it != mp.begin()) os << \", \";\n    os << it->first << \": \" << it->second;\n  }\n  os << ']';\n\n  return os;\n}\n\ntemplate <typename T, typename T2, typename T3>\nostream& operator<< (ostream& os, const priority_queue<T, T2, T3>& orig) {\n  priority_queue<T, T2, T3> pq(orig);\n  bool first = true;\n  os << '[';\n  while (!pq.empty()) {\n    T x = pq.top(); pq.pop();\n    if (!first) os << \", \";\n    os << x;\n    first = false;\n  }\n  return os << ']';\n}\n// ---- end <<\n// ---- inserted library file debug.cc\ntemplate <class... Args>\nstring dbgFormat(const char* fmt, Args... args) {\n  size_t len = snprintf(nullptr, 0, fmt, args...);\n  char buf[len + 1];\n  snprintf(buf, len + 1, fmt, args...);\n  return string(buf);\n}\n\ntemplate <class Head>\nvoid dbgLog(Head&& head) {\n  cerr << head << endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid dbgLog(Head&& head, Tail&&... tail)\n{\n  cerr << head << \" \";\n  dbgLog(forward<Tail>(tail)...);\n}\n\n#if DEBUG\n  #define DLOG(...)        dbgLog(__VA_ARGS__)\n  #define DFMT(...)        cerr << dbgFormat(__VA_ARGS__) << endl\n  #define DCALL(func, ...) func(__VA_ARGS__)\n#else\n  #define DLOG(...)\n  #define DFMT(...)\n  #define DCALL(func, ...)\n#endif\n\n// ---- end debug.cc\n// @@ !! LIM  -- end mark --\n\nll mask4 = 0xFFFFFFFFFFLL;\nll mask1 = 0x3FFLL;\n\nll rot(ll c, ll e) {\n  if (c == 1) { return ((e << 10) | (e >> 30)) & mask4; }\n  if (c == 2) { return ((e << 20) | (e >> 20)) & mask4; }\n  if (c == 3) { return ((e << 30) | (e >> 10)) & mask4; }\n  assert(0);\n}\n\nll dNum(ll e) {\n  if (rot(1, e) == e) return 4;\n  if (rot(2, e) == e) return 2;\n  return 1;\n}\n\nll enc(ll x1, ll x2, ll x3, ll x4) {\n  ll e = (x1 << 30) | (x2 << 20) | (x3 << 10) | x4;\n  return min(min(min(e, rot(1,e)), rot(2,e)), rot(3,e));\n}\n\nll dec(ll e, ll i) { return (e >> ((3 - i) * 10)) & mask1; }\n\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << setprecision(20);\n\n  ll N; cin >> N;\n  vector<ll> vec(N);\n  unordered_map<ll, ll> mp, dbl;\n  for (ll i = 0; i < N; i++) {\n    ll x1, x2, x3, x4; cin >> x1 >> x2 >> x3 >> x4;\n    ll e = enc(x1, x2, x3, x4);\n    vec.at(i) = e;\n    if (mp[e]++ == 0) dbl[e] = dNum(e);\n  }\n  ll tot = 0;\n  for (ll i = 0; i < N; i++) {\n    mp[vec.at(i)]--;\n    ll head = vec.at(i);\n    DLOG(\"i = \", i, \"tot = \", tot);\n    for (ll j = 0; j < N; j++) {\n      if (j == i) continue;\n      mp[vec.at(j)]--;\n      ll tail = vec.at(j);\n      for (ll k = 0; k < 4; k++, tail = rot(1, tail)) {\n\tll cnt = 1;\n\tvector<ll> used;\n\tauto op = [&](ll p, ll q, ll r, ll s) -> bool{\n\t  ll e = enc(dec(head, p), dec(head, q), dec(tail, r), dec(tail, s));\n\t  auto it = mp.find(e);\n\t  if (it == mp.end()) {\n\t    cnt = 0;\n\t    return false;\n\t  }\n\t  DLOG(\"FOUND: \", i, j, k, it->second, dbl.at(e));\n\t  cnt *= it->second * dbl.at(e);\n\t  mp[e]--;\n\t  used.push_back(e);\n\t  return true;\n\t};\n\top(1, 0, 1, 0) && op(2, 1, 0, 3) && op(3, 2, 3, 2) && op(0, 3, 2, 1);\n\ttot += cnt;\n\tfor (ll u : used) mp[u]++;\n      }\n      mp[vec.at(j)]++;\n    }\n    mp[vec.at(i)]++;\n  }\n\n  cout << tot / 6 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nlong long int converter(const int a, const int b, const int c, const int d) {\n\treturn ((a * 1000 + b) * 1000 + c) * 1000 + d;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<short>>box(N, vector<short>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tlong long int ans = 0;\n\tunordered_map<long long int, int>mp;\n\tunordered_map<long long int, int>sz;\n\tunordered_map<long long int, int>oold;\n\tfor (int i = N - 5; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 6; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<char>old(4, -1);\n\t\t\t\tvector<short>num(4, 0);\n\t\t\t\tvector<short>sum(4, 0);\n\t\t\t\tif (N > 50) {\n\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\t\tauto it = oold.find(converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4]));\n\t\t\t\t\t\tif (it != oold.end()) {\n\t\t\t\t\t\t\told[n] = it->second;\n\t\t\t\t\t\t\tsum[n] = mp[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t\t\tnum[n] = sz[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[j][m] && box[i][n] == box[j][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[j][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[j][(m + 3) % 4]) {\n\t\t\t\t\t\t\t\tsum[n]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int l = i + 1; l < N; l++) {\n\t\t\t\t\t\tif (j == l)continue;\n\t\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[l][m] && box[i][n] == box[l][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[l][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[l][(m + 3) % 4]) {\n\t\t\t\t\t\t\t\t\tsum[n]++;\n\t\t\t\t\t\t\t\t\tif (old[n] != l) {\n\t\t\t\t\t\t\t\t\t\tnum[n]++;\n\t\t\t\t\t\t\t\t\t\told[n] = l;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\tif(num[n])\tnum[n] = sum[n] / num[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m] && num[l]) {\n\t\t\t\t\t\t\tsum[l] -= num[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<set>\n#include<iomanip>\n#include<map>\n#define sqr(x)(x)*(x)\n#define fz1(i,n) for (i=1;i<=n;i++)\n#define fd1(i,n) for (i=n;i>=1;i--)\n#define fz0g(i,n) for (i=0;i<=n;i++)\n#define fd0g(i,n) for (i=n;i>=0;i--)\n#define fz0k(i,n) for (i=0;i<n;i++)\n#define fd0k(i,n) for (i=(long long)(n-1);i>=0;i--)\n#define fz(i,x,y) for (i=x;i<=y;i++)\n#define fd(i,y,x) for (i=y;i>=x;i--)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){char ss[len];scanf(\"%s\",ss);(st)=ss;}\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\nlong long n,m,i,j,k,l,ans,a[405][6];\nmap<pair<pair<long long,long long>,pair<long long,long long> >,long long> mp;\nvoid mve(long long &w,long long &x,long long &y,long long &z)\n{\n\tlong long t=z;\n\tz=y;y=x;x=w;w=t;\n}\nvoid add(long long w,long long x,long long y,long long z)\n{\n\tint i;\n\tfz1(i,4)\n\t{\n\t\tmp[make_pair(make_pair(w,x),make_pair(y,z))]++;\n\t\tmve(w,x,y,z);\n\t}\n}\nvoid del(long long w,long long x,long long y,long long z)\n{\n\tint i;\n\tfz1(i,4)\n\t{\n\t\tmp[make_pair(make_pair(w,x),make_pair(y,z))]--;\n\t\tmve(w,x,y,z);\n\t}\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfz1(i,n)\n\t{\n\t\tfz1(j,4)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t\tadd(a[i][1],a[i][2],a[i][3],a[i][4]);\n\t}\n\tfz1(i,n)\n\t{\n\t\tdel(a[i][1],a[i][2],a[i][3],a[i][4]);\n\t\tfz(j,i+1,n)\n\t\t{\n\t\t\tdel(a[j][1],a[j][2],a[j][3],a[j][4]);\n\t\t\tfz1(k,4)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tmve(a[j][1],a[j][2],a[j][3],a[j][4]);\n\t\t\t}\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define X first\n#define Y second\nusing namespace std;\n\nconst int N=4e2+10;\n\nstruct info{\n    int a[4];\n    void roll(){\n        int tmp=a[3];\n        for(int i=3;i>=1;i--) a[i]=a[i-1];\n        a[0]=tmp;\n    }\n    info (int _a0=0,int _a1=0,int _a2=0,int _a3=0){\n        a[0]=_a0;\n        a[1]=_a1;\n        a[2]=_a2;\n        a[3]=_a3;\n    }\n};\nstruct infocomp{\n    bool operator ()(const info& a,const info& b){\n        for(int i=0;i<4;i++) if (a.a[i]!=b.a[i])\n            return a.a[i]<b.a[i];\n        return 0;\n    }\n};\nmap <info,int,infocomp> need,store;\nint n;\ninfo a[N];\n\nint tu1[5],tu2[5];\nvoid prepare(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<4;j++) scanf(\"%d\",&a[i].a[j]);\n        for(int j=0;j<4;j++){\n//            cout<<\"=>\";\n//                for(int k=0;k<4;k++) cout<<a[i].a[k]<<\" \\n\"[k==3];\n            store[a[i]]++;\n            a[i].roll();\n        }\n    }\n//    for(auto i:store) {\n//        for(int j=0;j<4;j++) cout<<i.X.a[j]<<\" \";\n//        cout<<i.Y<<'\\n';\n//    }\n}\nint getstorage(info a){\n    auto ite=store.find(a);\n    if (ite==store.end()) return 0;\n    return ite->Y;\n}\nvoid takestorage(info a,int val){\n    auto ite=store.find(a);\n    if (ite==store.end()) return;\n    store[a]-=val;\n}\nll A(int x,int y){\n    if (y>x||y<0) return 0;\n    ll ans=1;\n    for(int i=0;i<y;i++) ans*=(x-i);\n    return ans;\n}\nbool unidi(info a){\n    for(int i=1;i<4;i++) if (a.a[i]!=a.a[1]) return 0;\n    return 1;\n}\nll solve(){\n    ll ans=0;\n    for(int u1=1;u1<=n;u1++){\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]--;\n            a[u1].roll();\n        }\n        for(int u2=u1+1;u2<=n;u2++){\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]--;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                need.clear();\n                for(int i=0;i<5;i++) tu1[i]=a[u1].a[i%4];\n                for(int i=0;i<5;i++) tu2[i]=a[u2].a[(1-i+4)%4];\n                for(int i=0;i<4;i++) need[info(tu1[i+1],tu1[i],tu2[i],tu2[i+1])]++;\n                ll cans=1;\n                for(auto cur:need){\n                    if (unidi(cur.X)){\n                        int n1=getstorage(cur.X)/4;\n                        cans*=A(n1,cur.Y);\n                        for(int i=0;i<cur.Y;i++) cans*=4;\n                    }else cans*=A(getstorage(cur.X),cur.Y);\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,cur.Y);\n                        tmp.roll();\n                    }\n                }\n                for(auto cur:need){\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,-cur.Y);\n                        tmp.roll();\n                    }\n                }\n                ans+=cans;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]++;\n                a[u2].roll();\n            }\n        }\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]++;\n            a[u1].roll();\n        }\n    }\n    return ans/3;\n}\nint main(){\n    prepare();\n    cout<<solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=405;\nconst int mod=1e7;\nint n;\nll ans;\nint a[4];\nclass tile{\npublic:\n\tint c[4],cnt;\n\ttile(){\n\t\tmemset(c,0,sizeof(c));\n\t}\n\ttile(int a[]){\n\t\trep(i,4)c[i]=a[i];\n\t}\n\tbool operator <(const tile &other)const{\n\t\trep(i,3)if(c[i]!=other.c[i])return c[i]<other.c[i];\n\t\treturn c[3]<other.c[3];\n\t}\n\tbool operator ==(const tile &other)const{\n\t\trep(i,4)if(c[i]!=other.c[i])return false;\n\t\treturn true;\n\t}\n\ttile Rotate(){\n\t\ttile res=tile();\n\t\trep(i,4)res.c[i]=c[(i+3)%4];\n\t\treturn res;\n\t}\n\ttile change(){\n\t\tcnt=0;\n\t\ttile t[4];\n\t\trep(i,4)t[0].c[i]=c[i];\n\t\tREP(i,3)t[i]=t[i-1].Rotate();\n\t\tsort(t,t+4);\n\t\trep(i,4)if(t[i]==t[0])cnt++;\n\t\treturn t[0];\n\t}\n\tint get_hash(){\n\t\tint hsh=0;\n\t\trep(i,4)hsh=((1LL*hsh*101%mod)+c[i])%mod;\n\t\treturn hsh;\n\t}\n\tvoid debug(){\n\t\trep(i,4)printf(\"%d \",c[i]);\n\t\tputs(\"\");\n\t}\n}t[maxn];\nint mp[mod+5];\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\trep(j,4)scanf(\"%d\",&a[j]);\n\t\tt[i]=tile(a);\n\t\tmp[t[i].change().get_hash()]++;\n\t}\n\trep(i,n)\n\t\tfor(int j=i+1;j<n;j++){\n\t\ttile A=t[i],B=t[j];\n\t\tint C=A.change().get_hash(),D=B.change().get_hash();\n\t\tmp[C]--;\n\t\tmp[D]--;\n\t\trep(C,4){\n\t\t\tvector<int>ch;\n\t\t\tint cur1=0,cur2=0;\n\t\t\tll res=1LL;\n\t\t\trep(k,4){\n\t\t\t\ta[0]=A.c[cur1],a[1]=A.c[(cur1+3)%4],a[2]=B.c[cur2],a[3]=B.c[(cur2+3)%4];\n\t\t\t\ttile now=tile(a);\n\t\t\t\tint NOW=now.change().get_hash();\n\t\t\t\tres*=1LL*mp[NOW]*now.cnt;\n\t\t\t\tif(mp[NOW])mp[NOW]--,ch.push_back(NOW);\n\t\t\t\tcur1=(cur1+3)%4;\n\t\t\t\tcur2=(cur2+1)%4;\n\t\t\t}\n\t\t\tans+=res;\n\t\t\tB=B.Rotate();\n\t\t\trep(i,ch.size())mp[ch[i]]++;\n\t\t} \n\t\tmp[C]++;\n\t\tmp[D]++;\n\t}\n\tprintf(\"%lld\",ans/3);\n\treturn 0;\n}\n/*\n6\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n    template <>\n    class hash<std::pair<Int, Int>> {\n    public:\n        size_t operator()(const std::pair<Int, Int>& x) const{\n            return hash<Int>()(x.first) ^ hash<Int>()(x.second);\n        }\n    };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define int long long\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    /*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*/\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nsigned main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay2(v);\n    }\n    int ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    /*tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];*/\n                    tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=100050;\n//ここまでテンプレ\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\nll fact_mod(ll n, ll mod) {\n    ll f = 1; repq(i,2,n) f = f * (i % MOD) % MOD;\n    return f;\n}\n// 繰り返し二乗法 (再帰バージョン)\nll mod_pow(ll x, ll n, ll mod) {\n    if(n == 0) return 1;\n    ll res = mod_pow((x * x) % mod, n / 2 , mod);\n    if(n & 1) res = (res * x) % mod;\n    return res;\n}\n// 組み合わせ nCr を求める (modあり)\nll combination_mod(ll n, ll r, ll mod) {\n    if(r > n-r) r = n-r;\n    if(r == 0) return 1;\n    ll a = 1;\n    rep(i, 0, r) a = a * ((n-i) % mod) % mod;\n    ll b = mod_pow(fact_mod(r, mod), mod-2, mod);\n    return (a % mod) * (b % mod) % mod;\n}\n//4つの色を辞書順最小の並びで返す\nvint COLOR(int a,int b,int c,int d){\n\tvint A={a,b,c,d},B={b,c,d,a},C={c,d,a,b},D={d,a,b,c};\n\tvector<vint> vec={A,B,C,D};\n\tsort(vec.begin(),vec.end());\n\treturn vec[0];\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tmap<vint,int> pam;\n\tvector<vint> panel;\n\t//それぞれのパネルに含まれる色を、昇順にソートして入れていく\n\tfor(int i=0;i<N;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\t//4つの角の順番を変えないように、辞書順最小の並びに揃える\n\t\tvint v=COLOR(a,b,c,d);\n\t\tpam[v]++;\n\t\tpanel.pb(v);\n\t}\n\tll ans=0;\n\t//立方体の底に使うパネルiと天井に使うパネルjを全探索する\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\t//天井のパネルの向きを全探索する\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvint cei,flo;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tflo.pb(panel[i][l]);\n\t\t\t\t\tcei.pb(panel[j][(k+l)%4]);\n\t\t\t\t}\n\t\t\t\t//側面の4つのパネルになりうるパネルがあるか？\n\t\t\t\tvint A=COLOR(cei[0],flo[0],flo[3],cei[1]);\n\t\t\t\tvint B=COLOR(cei[3],flo[1],flo[0],cei[0]);\n\t\t\t\tvint C=COLOR(cei[2],flo[2],flo[1],cei[3]);\n\t\t\t\tvint D=COLOR(cei[1],flo[3],flo[2],cei[2]);\n\t\t\t\t//pamから底と天井に使ったパネルを引く\n\t\t\t\tpam[panel[i]]--;\n\t\t\t\tpam[panel[j]]--;\n\t\t\t\t//立方体が何通りできるか？\n\t\t\t\t//側面に使うパネル\n\t\t\t\tmap<vint,int> use;\n\t\t\t\tuse[A]++,use[B]++,use[C]++,use[D]++;\n\t\t\t\tif(pam.find(A)==pam.end() || pam.find(B)==pam.end() || pam.find(C)==pam.end() || pam.find(D)==pam.end());\n\t\t\t\telse if(pam[A]<use[A] || pam[B]<use[B] || pam[C]<use[C] || pam[D]<use[D]);\n\t\t\t\telse{\n\t\t\t\t\tll temp=1;\n\t\t\t\t\tfor(pair<vint,int> P:use){\n\t\t\t\t\t\ttemp*=combination_mod(pam[P.first],P.second,(1<<31)-1);\n\t\t\t\t\t\tif(P.first[1]==P.first[0] && P.first[2]==P.first[0] && P.first[3]==P.first[0])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=4;\n\t\t\t\t\t\telse if(P.first[0]==P.first[2] && P.first[1]==P.first[3])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=2;\n\t\t\t\t\t\tfor(int l=1;l<=P.second;l++)\n\t\t\t\t\t\t\ttemp*=l;\n\t\t\t\t\t}\n\t\t\t\t\tans+=temp;\n\t\t\t\t}\n\t\t\t\t//pamに底と天井に使ったパネルを足す\n\t\t\t\tpam[panel[i]]++;\n\t\t\t\tpam[panel[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    mat C(N, vec(4));\n    vector<mat> C2(N, mat(4, vec(4)));\n    map<vec, int> m;\n    REP(i, N){\n        readv(C[i]);\n        REP(r, 4){\n            REP(j, 4) C2[i][r][j] = C[i][(j + r) % 4];\n            m[C2[i][r]] += 1;\n        }\n    }\n\n    int ans = 0;\n    REP(i, N){\n        REP(r, 4) m[C2[i][r]] -= 1;\n        FOR(j, i + 1, N){\n            REP(r, 4) m[C2[j][r]] -= 1;\n\n            REP(r, 4){\n                int tmp = 1;\n                mat side(4, vec(4));\n                REP(s, 4) side[s] = vec({C2[i][0][(4 - s) % 4], C2[i][0][3 - s], C2[j][r][(1 + s) % 4], C2[j][r][s]});\n                REP(s, 4){\n                    tmp *= m[side[s]];\n                    REP(r2, 4) m[vec({side[s][(0 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3]})] -= 1;\n                }\n                REP(s, 4) REP(r2, 4) m[vec({side[s][(0 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3]})] += 1;\n                ans += tmp;\n            }\n\n            REP(r, 4) m[C2[j][r]] += 1;\n        }\n        REP(r, 4) m[C2[i][r]] += 1;\n    }\n    cout << ans / 3;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = unsigned long long;\nconst int N = 400;\nint C[N][4];\nll mask(ll a, ll b, ll c, ll d) {\n\treturn (a << 30) | (b << 20) | (c << 10) | d;\n}\nll rotate(ll m) {\n\tll a = (m >> 30) & ((1 << 10) - 1);\n\tll b = (m >> 20) & ((1 << 10) - 1);\n\tll c = (m >> 10) & ((1 << 10) - 1);\n\tll d = (m >> 0) & ((1 << 10) - 1);\n\treturn mask(b, c, d, a);\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tmap<ll, int> counter;\n\tauto add = [&](int i) {\n\t\tfor(int roti = 0; roti < 4; roti++) {\n\t\t\tcounter[mask(C[i][(0 + roti) % 4], C[i][(1 + roti) % 4], C[i][(2 + roti) % 4], C[i][(3 + roti) % 4])]++;\n\t\t}\n\t};\n\tauto remove = [&](int i) {\n\t\tfor(int roti = 0; roti < 4; roti++) {\n\t\t\tcounter[mask(C[i][(0 + roti) % 4], C[i][(1 + roti) % 4], C[i][(2 + roti) % 4], C[i][(3 + roti) % 4])]--;\n\t\t}\n\t};\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tcin >> C[i][j];\n\t\t}\n\t\tadd(i);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tremove(i), remove(j);\n\t\t\tfor(int roti = 0; roti < 4; roti++) {\n\t\t\t\tfor(int rotj = 0; rotj < 4; rotj++) {\n\t\t\t\t\tauto fixi = [roti](int x) { return (x + roti) % 4; };\n\t\t\t\t\tauto fixj = [rotj](int x) { return (x + rotj) % 4; };\n\t\t\t\t\tll m[4] = {\n\t\t\t\t\t\tmask(C[j][fixj(3)], C[j][fixj(2)], C[i][fixi(1)], C[i][fixi(0)]),\n\t\t\t\t\t\tmask(C[j][fixj(3)], C[i][fixi(0)], C[i][fixi(3)], C[j][fixj(0)]),\n\t\t\t\t\t\tmask(C[i][fixi(1)], C[j][fixj(2)], C[j][fixj(1)], C[i][fixi(2)]),\n\t\t\t\t\t\tmask(C[i][fixi(3)], C[i][fixi(2)], C[j][fixj(1)], C[j][fixj(0)]),\n\t\t\t\t\t};\n\t\t\t\t\tbool valid = true;\n\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\tvalid &= counter.count(m[k]) and counter[m[k]] > 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(valid) {\n\t\t\t\t\t\tll cur = 1;\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tcur *= counter[m[k]];\n\t\t\t\t\t\t\tfor(int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\tcounter[m[k]]--;\n\t\t\t\t\t\t\t\tm[k] = rotate(m[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += cur;\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tfor(int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\tcounter[m[k]]++;\n\t\t\t\t\t\t\t\tm[k] = rotate(m[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(i), add(j);\n\t\t}\n\t}\n\tcout << ans / 12 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...)\\\n  std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::istream& operator>> (std::istream& is, Container& v) {\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T, typename U>\nstd::ostream& operator<< (std::ostream& os, const std::pair<T, U>& pair)\n  { return os << \"(\" << pair.first << \",\" << pair.second << \")\"; }\n\ntemplate <typename T, typename U>\nstd::istream& operator>> (std::iostream& is, std::pair<T, U>& pair)\n  { return is >> pair.first >> pair.second; }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto data = make_vector< 2, int >(n, 4);\n  std::cin >> data;\n  auto multiplicity = [&] (auto a) {\n    if (a.at(0) != a.at(2) || a.at(1) != a.at(3))\n      { return 1; }\n    if (a.at(0) != a.at(1))\n      { return 2;}\n    return 4;\n  };\n  auto power = [&] (auto x, auto y) {\n    auto ret = 1LL;\n    loop(y) ret *= x;\n    return ret;\n  };\n  auto normalized = [&] (auto a) {\n    auto z = a;\n    loop(3) {\n      std::rotate(a.begin(), a.begin() + 1, a.end());\n      cmn(z, a);\n    }\n    return z;\n  };\n  for (auto & v : data) v = normalized(v);\n  std::multiset< std::vector< int > > set(data.begin(), data.end());\n  auto cal = [&] (auto n, auto k) {\n    if (n < k) return 0LL;\n    auto ret = 1LL;\n    rep(i, 0, k) ret *= (n - i);\n    return ret;\n  };\n  lint ret = 0;\n  rep(i, 0, n) rep(j, i + 1, n) {\n    auto x = data.at(i);\n    auto y = data.at(j);\n    auto seq = std::vector< int >{1, 0, 1, 0};\n    loop(4) {\n      std::map< std::vector< int >, int > map;\n      loop(4) {\n        auto z = std::vector< int >{\n          x.at(seq.at(0)), x.at(seq.at(1)),\n          y.at(seq.at(2)), y.at(seq.at(3))\n        };\n        map[normalized(z)]++;\n        for (auto & x : std::vector< std::reference_wrapper< int > >{ seq.at(0), seq.at(1) })\n          { (x += 1) %= 4; }\n        for (auto & x : std::vector< std::reference_wrapper< int > >{ seq.at(2), seq.at(3) })\n          { (x += 3) %= 4; }\n      }\n      auto now = 1LL;\n      for (auto p : map) {\n        std::vector< int > v; int l; std::tie(v, l) = p;\n        auto m = (lint)set.count(v) - (x == v) - (y == v);\n        assert(m >= 0);\n        now *= cal(m, l) * power(multiplicity(v)  , l);\n      }\n      ret += now;\n      for (auto & x : std::vector< std::reference_wrapper< int > >{ seq.at(2), seq.at(3) })\n        { (x += 3) %= 4; }\n    }\n  }\n  assert(ret % 3 == 0);\n  ret /= 3;\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N*4];\nint pa[4]={1,0,3,2};\n\nint main(){\n\tscanf(\"%d\",&N);\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tT[i*4]=TILE(a,b,c,d,i);\n\t\tFOR(j,1,4){\n\t\t\tT[i*4+j]=rotate(T[i*4],j);\n\t\t}\n\t}\n\tsort(T,T+N*4);\n\tll ans=0;\n\tTILE TI[6];\n\tint cnt[4];\n\tint cnt2[4][4];\n\tREP(i,N*4){\n\t\tTI[0]=T[i];\n\t\tREP(j,N*4){\n\t\t\tif (TI[0].index==T[j].index) continue;\n\t\t\tTI[1]=T[j];\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tREP(k,4){\n\t\t\t\tTI[k+2]=TILE(TI[0].c[(k+1)%4],TI[0].c[k],TI[1].c[pa[k]],TI[1].c[pa[(k+1)%4]],0);\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tcnt[k]=upper_bound(T,T+N*4,TI[k+2])-lower_bound(T,T+N*4,TI[k+2]);\n\t\t\t\tREP(a,2){\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a],b)){\n\t\t\t\t\t\t\tcnt[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tFOR(a,k+1,4){\n\t\t\t\t\tcnt2[k][a]=0;\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a+2],b)){\n\t\t\t\t\t\t\tcnt2[k][a]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tll c=1;\n\t\t\tll temp;\n\t\t\tREP(k,4){\n\t\t\t\ttemp=cnt[k];\n\t\t\t\tREP(a,k){\n\t\t\t\t\ttemp-=cnt2[a][k];\n\t\t\t\t}\n\t\t\t\tif (temp<0){\n\t\t\t\t\tf=true;\n\t\t\t\t}else{\n\t\t\t\t\tc*=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f){\n\t\t\t\tans+=c;\n\t\t\t}\n\t\t}\n\t}\n\tans/=24;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <map>\n\nusing tile = std::array<int, 4>;\nconstexpr int coeff[] = { 1, 2, 4 };\nconstexpr int perm[] = { 1, 1, 2, 6, 24 };\n\ntile rotate(const tile &t, int r) {\n  tile res{};\n  for (int i = 0; i < 4; ++i) {\n    res[i] = t[(i + r) & 3];\n  }\n  return res;\n}\n\ntile normalize(const tile &t) {\n  std::array<tile, 4> tmp{};\n  for (int i = 0; i < 4; ++i) {\n    tmp[i] = rotate(t, i);\n  }\n  std::sort(tmp.begin(), tmp.end());\n  return tmp.front();\n}\n\nint type(const tile &t) {\n  if (t[0] == t[1] && t[1] == t[2] && t[2] == t[3]) return 2;\n  if (t[0] == t[2] && t[1] == t[3]) return 1;\n  return 0;\n}\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<tile> C(N);\n  std::vector<int> T(N);\n  std::map<tile, std::array<int, 3>> memo;\n  for (int i = 0; i < N; ++i) {\n    for (auto &x: C[i]) {\n      std::cin >> x;\n    }\n    C[i] = normalize(C[i]);\n    T[i] = type(C[i]);\n    memo[C[i]][T[i]]++;\n  }\n  int64_t ans = 0;\n  for (int i = 0; i < N; ++i) {\n    memo[C[i]][T[i]]--;\n    const auto &up = C[i];\n    for (int j = i + 1; j < N; ++j) {\n      memo[C[j]][T[j]]--;\n      for (int k = 0; k < 4; ++k) {\n        auto down = rotate(C[j], k);\n        std::map<tile, int> query;\n        query[normalize(tile{ up[0], up[3], down[2], down[1] })]++;\n        query[normalize(tile{ up[1], up[0], down[1], down[0] })]++;\n        query[normalize(tile{ up[2], up[1], down[0], down[3] })]++;\n        query[normalize(tile{ up[3], up[2], down[3], down[2] })]++;\n        int64_t add = 1;\n        for (auto &q: query) {\n          auto itr = memo.find(q.first);\n          if (itr == memo.end()) {\n            add = 0;\n            break;\n          }\n          const auto &data = itr -> second;\n          std::array<std::array<int64_t, 5>, 4> dp{};\n          dp[0][0] = 1;\n          for (int l = 0; l < 3; ++l) {\n            for (int m = 0; m <= 4; ++m) {\n              int64_t cur = 1;\n              for (int n = 0; m + n <= 4; ++n) {\n                dp[l + 1][m + n] += dp[l][m] * cur;\n                cur *= (data[l] - n) * coeff[l];\n                cur /= (n + 1);\n              }\n            }\n          }\n          add *= dp[3][q.second] * perm[q.second];\n        }\n        ans += add;\n      }\n      memo[C[j]][T[j]]++;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nvoid rm_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]--;\n    rotate(tile.begin(), tile.begin() + 1, tile.end());\n  }\n}\n\nvoid add_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]++;\n    rotate(tile.begin(), tile.begin() + 1, tile.end());\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  for (vector<int> tile : side_tiles) {\n    ret *= max(colors[tile], 0);\n    rm_tile(tile, colors);\n  }\n\n  for (vector<int> tile : side_tiles) {\n    add_tile(tile, colors);\n  }\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[tiles[i]]++;\n      rotate(tiles[i].begin(), tiles[i].begin() + 1, tiles[i].end());\n    }\n  }\n\n  int ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rotate(tiles[low].begin(), tiles[low].begin() + 1, tiles[low].end());\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n#define MAXN 600\n\ntypedef array<short,4> tile;\n\nint n;\ntile a[MAXN];\nlong d[MAXN];\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%hd\", &a[i][j]);\n\treturn 1;\n}\n\nvoid init() {\n}\n\ntile rotate(const tile &x, int k=1) {\n\ttile y;\n\tfor (int i=0; i<4; i++) y[(i+k) % 4] = x[i];\n\treturn y;\n}\n\ntile normalize(const tile &x) {\n\ttile z=x;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y<z) z=y;\n\t}\n\treturn z;\n}\n\nint mirror(const tile &x) {\n\tint r = 1;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y==x) r++;\n\t}\n\treturn r;\n}\n\ntile get_face(const tile &u, const tile &d, int x, int y) {\n\treturn normalize({u[x], u[y], d[3-y], d[3-x]});\n}\n\n//use id to speed up\nlong id(const tile &x) {\n\treturn x[0]*1000000000L + x[1]*1000000L + x[2]*1000L + x[3];\n}\n\nlong get_face_id(const tile &u, const tile &d, int x, int y) {\n\tlong z = id({u[x], u[y], d[3-y], d[3-x]});\n\tlong r = z;\n\tfor (int i=0; i<3; i++) {\n\t\tz = z/1000L + z%1000L * 1000000000L;\n\t\tif (z<r) r = z;\n\t}\n\treturn r;\n}\n\nlong solve() {\n\tmap<long,long> ct;\n\tmap<long,long> mi;\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] = normalize(a[i]);\n\t\td[i] = id(a[i]);\n\t\tct[d[i]]++;\n\t\tmi[d[i]] = mirror(a[i]);\n\t}\n\tlong ans = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tct[d[i]]--;\n\t\tfor (int j=i+1; j<n; j++) {\n\t\t\tct[d[j]]--;\n\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\ttile d=a[i], u=rotate(a[j], k);\n\t\t\t\t//tile f[4];\n\t\t\t\tlong g[4];\n\t\t\t\tlong r = 1;\n\t\t\t\tfor (int t=0; t<4; t++) {\n\t\t\t\t\t//f[t] = get_face(u, d, t, (t+3)%4);\n\t\t\t\t\t//g[t] = id(f[t]);\n\t\t\t\t\tg[t] = get_face_id(u, d, t, (t+3)%4);\n\t\t\t\t\tr *= mi[g[t]] * ct[g[t]]--;\n\t\t\t\t}\n\t\t\t\t//printf(\"* %d %d %d: %ld\\n\", i, j, k, r);\n\t\t\t\tans += r;\n\t\t\t\tfor (int t=0; t<4; t++) ct[g[t]]++;\n\t\t\t}\n\t\t\tct[d[j]]++;\n\t\t}\n\t\tct[d[i]]++;\n\t}\n\treturn ans/3;\n}\n\nvoid output(long ans) {\n\tprintf(\"%ld\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<unordered_map>\nusing namespace std;\nvector<int>rotate(vector<int>v)\n{\n\tvector<int>r;\n\tr.resize(4);\n\tr[0] = v[1], r[1] = v[2], r[2] = v[3], r[3] = v[0];\n\treturn r;\n}\nvector<int>d[444];\ntypedef long long ll;\nunordered_map<ll, ll>ma;\nll conv(vector<int>v)\n{\n\treturn (((ll)v[0]) << 30) + (((ll)v[1]) << 20) + (((ll)v[2]) << 10) + ((ll)v[3]);\n}\nvoid add(vector<int>v)\n{\n\tll t = conv(v);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tma[t]++;\n\t\tt = ((t&((1LL << 40) - (1LL << 30))) >> 30) + ((t&((1LL << 30) - 1)) << 10);\n\t}\n}\nvoid sub(vector<int>v)\n{\n\tll t = conv(v);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tma[t]--;\n\t\tt = ((t&((1LL << 40) - (1LL << 30))) >> 30) + ((t&((1LL << 30) - 1)) << 10);\n\t}\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tvector<int>v;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tv.push_back(z);\n\t\t}\n\t\td[i] = v;\n\t\tadd(v);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = i + 1; j < num; j++)\n\t\t{\n\t\t\tvector<int>s = d[i], t = d[j];\n\t\t\tsub(s), sub(t);\n\t\t\tswap(t[0], t[2]);\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tll x = 1;\n\t\t\t\tvector<vector<int> >ddd;\n\t\t\t\tfor (int l = 0; l < 4; l++)\n\t\t\t\t{\n\t\t\t\t\tvector<int>z;\n\t\t\t\t\tz.resize(4);\n\t\t\t\t\tz[0] = s[1], z[1] = s[0], z[2] = t[0], z[3] = t[1];\n\t\t\t\t\tx *= ma[conv(z)];\n\t\t\t\t\tsub(z);\n\t\t\t\t\tddd.push_back(z);\n\t\t\t\t\ts = rotate(s), t = rotate(t);\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < 4; l++)add(ddd[l]);\n\t\t\t\t//if (x > 0)printf(\"%d %d %lld\\n\", i, j, x);\n\t\t\t\tans += x;\n\t\t\t\tt = rotate(t);\n\t\t\t}\n\t\t\tswap(t[0], t[2]);\n\t\t\tadd(s), add(t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 410, M = 1000;\n\nstruct Face{\n\tint col[4];\n\n\tFace change(int mn){\n\t\tint tmp[4];\n\t\tFace ret;\n\t\tFor(i, 0, 3) tmp[i] = col[i];\n\t\tFor(i, 0, 3) ret.col[i] = tmp[(mn + i) % 4];\n\t\treturn ret;\n\t}\n\n\tvoid Rotate(){\n\t\tint mn = 0;\n\t\tlong long v = 1ll << 60;\n\t\tFor(i, 0, 3){\n\t\t\tlong long s = 0;\n\t\t\tFor(j, 0, 3) s = s * M + col[(i + j) % 4];\n\t\t\tif(s < v) v = s, mn = i;\n\t\t}\n\t\t*this = change(mn);\n\t}\n\n\tbool operator < (const Face& A) const{\n\t\tFor(i, 0, 3) if(col[i] ^ A.col[i]) return col[i] < A.col[i];\n\t\treturn false;\n\t}\n\n\tbool operator == (const Face& A) const{\n\t\treturn !(*this < A || A < *this);\n\t}\n}A[N];\n\nint n;\nmultiset<Face> S;\n\nint main(){\n\t\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) For(j, 0, 3) scanf(\"%d\", &A[i].col[j]);\n\tFor(i, 1, n) A[i].Rotate(), S.insert(A[i]);\n\n\tlong long ans = 0;\n\tFor(i, 1, n) For(j, i + 1, n){\n\t\tFor(d, 0, 3){\n\t\t\tFace B[4];\n\t\t\tlong long ret = 1;\n\t\t\tFor(k, 0, 3){\n\t\t\t\tB[k].col[1] = A[i].col[k], B[k].col[0] = A[i].col[(k + 1) % 4];\n\t\t\t\tB[k].col[3] = A[j].col[(4 - k + d) % 4], B[k].col[2] = A[j].col[(4 - k + d + 1) % 4];\n\t\t\t\tB[k].Rotate();\n\t\t\t\tint same = (B[k] == A[i]) + (B[k] == A[j]);\n\t\t\t\tFor(v, 0, k - 1) same += B[v] == B[k];\n\t\t\t\tret *= (S.count(B[k]) - same);\n\t\t\t\t\n\t\t\t\tsame = 1;\n\t\t\t\tFor(v, 1, 3) if(B[k].change(v) == B[k]) ++same;\n\t\t\t\tret *= same;\n\t\t\t}\n\t\t\tans += max(0ll, ret);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<pair<int,int>, pair<int,int> > pt;\n\nconst int MOD = 1e9 + 7;\nconst int C = 1001;\n\nunordered_map<ll,int> ma;\n\nll hsh(int a, int b, int c, int d)\n{\n\tll x = ll(a)*ll(C)*ll(C)*ll(C);\n\tx += ll(b)*ll(C)*ll(C);\n\tx += ll(c)*ll(C);\n\tx += d;\n\treturn x;\n}\n\nvoid cyc(int &a, int &b, int &c, int &d)\n{\n\tswap(a, b);\n\tswap(a, c);\n\tswap(a, d);\n}\n\nvector<pt> vec;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tvec.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> vec[i].fi.fi >> vec[i].fi.se >> vec[i].se.fi >> vec[i].se.se;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a = vec[i].fi.fi; int b = vec[i].fi.se;\n\t\tint c = vec[i].se.fi; int d = vec[i].se.se;\n\t\tma[hsh(a,b,c,d)]++;\n\t\tma[hsh(b,c,d,a)]++;\n\t\tma[hsh(c,d,a,b)]++;\n\t\tma[hsh(d,a,b,c)]++;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i == j) continue;\n\t\t\tint xa, xb, xc, xd, ya, yb, yc, yd;\n\t\t\txa = vec[i].fi.fi; xb = vec[i].fi.se; xc = vec[i].se.fi; xd = vec[i].se.se;\n\t\t\tya = vec[j].fi.fi; yb = vec[j].fi.se; yc = vec[j].se.fi; yd = vec[j].se.se;\n\t\t\tswap(xb,xd);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint a,b,c,d; map<ll,int> ma2;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\tll h1 = hsh(ya,yd,xd,xa);\n\t\t\t\tll h2 = hsh(yd,yc,xc,xd);\n\t\t\t\tll h3 = hsh(yc,yb,xb,xc);\n\t\t\t\tll h4 = hsh(yb,ya,xa,xb);\n\t\t\t\t//set<ll> ss;\n\t\t\t\t//ss.insert(h1); ss.insert(h2); ss.insert(h3); ss.insert(h4);\n\t\t\t\tmap<ll,int> ss;\n\t\t\t\t////cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\tll tmp = 0;\n\t\t\t\t\n\t\t\t\t\t////cerr<<w<<' '<<x<<' '<<y<<' '<<z<<'\\n';\n\t\t\t\t\tll x1 = ma[h1];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tll x2 = ma[h2];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tll x3 = ma[h3];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[y][h3]--; ma[y][h2]--; ma[y][h1]--; ma[y][h4]--;\n\t\t\t\t\tll x4 = ma[h4];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[w][h1]++; ma[x][h2]++; ma[y][h3]++;\n\t\t\t\t\t//ma[w][h1]++; ma[w][h2]++; ma[w][h3]++; ma[w][h4]++;\n\t\t\t\t\t//ma[x][h2]++; ma[x][h1]++; ma[x][h3]++; ma[x][h4]++;\n\t\t\t\t\t//ma[y][h3]++; ma[y][h2]++; ma[y][h1]++; ma[y][h4]++;\n\t\t\t\t\tx1=max(x1,0LL); x2=max(x2,0LL); x3=max(x3,0LL); x4 = max(x4,0LL);\n\t\t\t\t\ttmp += (x1*x2*x3*x4);\n\n\t\t\t\t/*\n\t\t\t\ttmp*=ma[h1];\n\t\t\t\tma[h1]--;\n\t\t\t\ttmp*=ma[h2];\n\t\t\t\tma[h2]--;\n\t\t\t\ttmp*=ma[h3];\n\t\t\t\tma[h3]--;\n\t\t\t\ttmp*=ma[h4];\n\t\t\t\tma[h1]++; ma[h2]++; ma[h3]++;\n\t\t\t\t*/\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<xa<<' '<<xb<<' '<<xc<<' '<<xd<<' '<<ya<<' '<<yb<<' '<<yc<<' '<<yd<<' '<<tmp<<'\\n';\n\t\t\t\tans += tmp;\n\t\t\t\tma2.clear();\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\tcyc(ya,yb,yc,yd);\n\t\t\t}\n\t\t}\n\t}\n\t//assert(ans%6==0);\n\tans/=6;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N; vector<int> a[409]; map<vector<int>, int> d;\nlong long perm(int n, int k) {\n\tlong long ret = 1;\n\tfor (int i = n; i > n - k; i--) ret *= i;\n\treturn ret;\n}\nvector<int> univec(vector<int> v) {\n\tvector<int> ret = v;\n\tfor (int i = 0; i < 3; i++) {\n\t\tv.push_back(v[0]);\n\t\tv.erase(v.begin());\n\t\tret = min(ret, v);\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\ta[i].resize(4);\n\t\tfor (int j = 0; j < 4; j++) cin >> a[i][j];\n\t\ta[i] = univec(a[i]);\n\t\td[a[i]]++;\n\t}\n\tlong long ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\td[a[i]]--;\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\td[a[j]]--;\n\t\t\tfor (int ri = 0; ri < 4; ri++) {\n\t\t\t\ta[i].push_back(a[i][0]); a[i].erase(a[i].begin());\n\t\t\t\tfor (int rj = 0; rj < 4; rj++) {\n\t\t\t\t\ta[j].push_back(a[j][0]); a[j].erase(a[j].begin());\n\t\t\t\t\tmap<vector<int>, int> e;\n\t\t\t\t\te[univec({ a[j][1], a[j][0], a[i][1], a[i][0] })]++;\n\t\t\t\t\te[univec({ a[j][0], a[j][3], a[i][2], a[i][1] })]++;\n\t\t\t\t\te[univec({ a[j][3], a[j][2], a[i][3], a[i][2] })]++;\n\t\t\t\t\te[univec({ a[j][2], a[j][1], a[i][0], a[i][3] })]++;\n\t\t\t\t\tlong long res = 1;\n\t\t\t\t\tfor (pair<vector<int>, int> k : e) {\n\t\t\t\t\t\tres *= perm(d[k.first], k.second);\n\t\t\t\t\t\tif (d[k.first] == 0) d.erase(k.first);\n\t\t\t\t\t\tif (k.first[0] == k.first[1] && k.first[1] == k.first[2] && k.first[2] == k.first[3]) {\n\t\t\t\t\t\t\tfor (int l = 0; l < k.second; l++) res *= 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (k.first[0] == k.first[2] && k.first[1] == k.first[3]) {\n\t\t\t\t\t\t\tfor (int l = 0; l < k.second; l++) res *= 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += res;\n\t\t\t\t}\n\t\t\t}\n\t\t\td[a[j]]++;\n\t\t}\n\t}\n\tcout << ret / 4 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nint c[400][4];\nLL h[400];\nint e[5], f[5];\nint sides[4][4];\nLL sh[4];\nbool used[4];\nmap<LL, int> cnt;\n\nint getHash(int *a) {\n    LL h = 0;\n    forn(i, 4) {\n        h <<= 10;\n        h |= a[i];\n    }\n    return h;\n}\n\nvoid lexMin(int *a) {\n    int cur[4];\n    forn(i, 4) cur[i] = a[i];\n    forn(i, 3) {\n        int tmp = a[0];\n        forn(j, 3) a[j] = a[j + 1];\n        a[3] = tmp;\n        bool ok = false;\n        forn(j, 4) if (a[j] != cur[j]) {\n            ok = a[j] < cur[j];\n            break;\n        }\n        if (ok) {\n            forn(j, 4) {\n                cur[j] = a[j];\n            }\n        }\n    }\n    forn(i, 4) a[i] = cur[i];\n}\n\nint calcSameRots(int *a) {\n    int same = 1;\n    int b[4];\n    forn(i, 4) {\n        b[i] = a[i];\n    }\n    forn(i, 3) {\n        int tmp = b[0];\n        forn(j, 3) b[j] = b[j + 1];\n        b[3] = tmp;\n        bool ok = true;\n        forn(j, 4) if (b[j] != a[j]) {\n            ok = false;\n            break;\n        }\n        if (ok) {\n            ++same;\n        }\n    }\n    return same;\n}\n\nLL C[1111][6];\nLL fac[10] = {};\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    fac[0] = 1;\n    for (int i = 1; i < 10; ++i) {\n        fac[i] = fac[i - 1] * i;\n    }\n    forn(i, 6) C[0][i] = 0;\n    C[0][0] = 1;\n    for (int i = 1; i < 1111; ++i) {\n        C[i][0] = 1;\n        for (int j = 1; j < 6; ++j) {\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n        }\n    }\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    forn(i, n) forn(j, 4) {\n        cin >> c[i][j];\n    }\n    forn(i, n) {\n        lexMin(c[i]);\n        h[i] = getHash(c[i]);\n    }\n    LL ans = 0;\n    forn(i, n) {\n        forn(z, 4) {\n            e[z] = c[i][z];\n        }\n        e[4] = e[0];\n        forn(j, i) {\n            --cnt[h[j]];\n            forn(k, 4) {\n                forn(z, 4) {\n                    f[z] = c[j][(z + k) % 4];\n                }\n                reverse(f, f + 4);\n                f[4] = f[0];\n                forn(z, 4) {\n                    sides[z][0] = e[z + 1];\n                    sides[z][1] = e[z];\n                    sides[z][2] = f[z];\n                    sides[z][3] = f[z + 1];\n                    lexMin(sides[z]);\n                    sh[z] = getHash(sides[z]);\n                }\n                forn(z, 4) {\n                    used[z] = false;\n                }\n                LL cur = 1;\n                forn(z, 4) {\n                    if (used[z]) {\n                        continue;\n                    }\n                    used[z] = true;\n                    int same = 1;\n                    for (int y = z + 1; y < 4; ++y) {\n                        if (sh[z] == sh[y]) {\n                            ++same;\n                            used[y] = true;\n                        }\n                    }\n                    cur *= C[cnt[sh[z]]][same] * fac[same];\n                }\n                forn(z, 4) {\n                    cur *= calcSameRots(sides[z]);\n                }\n                ans += cur;\n            }\n            ++cnt[h[j]];\n        }\n        ++cnt[h[i]];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\npa4 rot(pa4 z){\n\treturn {z.w,z.x,z.y,z.z};\n}\nint hen(pa4 z){\n\treturn z.x+1000*z.y+1000000*z.z+1000000000*z.w;\n}\n\n\nint ki(int z0){\n\tint ans=z0;\n\tfor(int i=0;i<3;i++){\n\t\tint am=z0%1000;\n\t\tz0/=1000;\n\t\tz0+=am*1000000000ll;\n\t\tans=min(ans,z0);\n\t}\n\treturn ans;\n}\n\nint tai(int z){\n\tint y0=z%1000;\n\tz/=1000;\n\tint y1=z%1000;\n\tz/=1000;\n\tint y2=z%1000;\n\tz/=1000;\n\tint y3=z%1000;\n\tz/=1000;\n\t\n\tif(y1==y2 && y1==y0 && y1==y3) return 4;\n\tif(y1==y3 && y0==y2) return 2;\n\treturn 1;\n}\npa4 iro[400][4];\n\nint kijun[400];\nmap<int,int> K; \nint b(int n,int r){\n\tif(r==0) return 1;\n\tif(r==1) return n;\n\tif(r%2)return b(n,r-1)*n;\n\tint z=b(n,r/2);\n\treturn z*z;\n}\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n // \tcin>>n;\n  n=400;\t\n  \tfor(int i=0;i<n;i++){\n  \t\tint y1,y2,y3,y4;\n  \t//\tcin>>y1>>y2>>y3>>y4;\n  \t\ty1=0,y2=0,y3=0,y4=0;\n  \t\tiro[i][0]={y1,y2,y3,y4};\n  \t\tfor(int j=1;j<4;j++)iro[i][j]=rot(iro[i][j-1]);\n  \t\tkijun[i]=ki(hen(iro[i][0]));\n  \t\tK[kijun[i]]++;\n  \t\n  \t}\n  \t\n  \tint ans=0,amari=0;\n  \tfor(int s=0;s<n;s++)for(int t=0;t<n;t++)if(s!=t)for(int l=0;l<4;l++)for(int r=0;r<4;r++){\n  \t\t\n  \t\tint e[4];\n  \t\te[0]=hen({iro[s][l].x,iro[s][l].w,iro[t][r].x,iro[t][r].w});\n  \t\te[1]=hen({iro[s][l].w,iro[s][l].z,iro[t][r].y,iro[t][r].x});\n  \t\te[2]=hen({iro[s][l].z,iro[s][l].y,iro[t][r].z,iro[t][r].y});\n  \t\te[3]=hen({iro[s][l].y,iro[s][l].x,iro[t][r].w,iro[t][r].z});\n  \t\t\n  \t\tfor(int i=0;i<4;i++)e[i]=ki(e[i]);\n  \t\tK[kijun[s]]--;\n  \t\tK[kijun[t]]--;\n  \t\tbool bo=true;\n  \t\tfor(int i=0;i<4;i++)if(K.count(e[i])==0||K[e[i]]==0) bo=false;\n  \t\t\n  \t\tif(bo){\n  \t\t//int cnt=0;\n  \t\tvector<pa> Pair;\n  \t\tmap<int,int >w;\n  \t\tfor(int i=0;i<4;i++){\n  \t\t\tw[e[i]]++;\n  \t\t}\n  \t\tint ka=1;\n  \t\t\t/*\n  \t\t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\t\tcout<<it->first<<\" \"<<it->second<<endl;\n  \t\t\t}\n  \t\t\tcout<<endl;\n  \t\t\t*/\n  \t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\tif(it->second==4){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<4){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*(num-3)*b(tai(it->first),4);\n  \t\t\t}\n  \t\t\tif(it->second==3){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<3){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*b(tai(it->first),3);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==2){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<2){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*b(tai(it->first),2);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==1){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<1){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t//\t\tcout<<tai(it->first)<<endl;\n  \t\t\t\tka*=num*b(tai(it->first),1);\n  \t\t\t}\n  \t\t}\n  \t\t\t//cout<<ka<<endl;\n  \t\t\tans+=ka/24;\n  \t\t\tamari+=ka%24;\n  \t\t\twhile(amari>=24){\n  \t\t\tamari-=24;\n  \t\t\t\tans++;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\tK[kijun[s]]++;\n  \t\tK[kijun[t]]++;\n  \t}\n  \tassert(amari==0);\n  \t\n  \tcout<<ans<<endl;\n  \t\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nlong long int converter(const int a, const int b, const int c, const int d) {\n\treturn ((a * 1000 + b) * 1000 + c) * 1000 + d;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<short>>box(N, vector<short>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tlong long int ans = 0;\n\tmap<long long int, int>mp;\n\tmap<long long int, int>sz;\n\tmap<long long int, int>oold;\n\tfor (int i = N - 5; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 6; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<char>old(4, -1);\n\t\t\t\tvector<short>num(4, 0);\n\t\t\t\tvector<short>sum(4, 0);\n\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\tauto it = oold.find(converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4]));\n\t\t\t\t\tif (it != oold.end()) {\n\t\t\t\t\t\told[n] = it->second;\n\t\t\t\t\t\tsum[n] = mp[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t\tnum[n] = sz[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[j][m] && box[i][n] == box[j][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[j][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[j][(m + 3) % 4]) {\n\t\t\t\t\t\t\tsum[n]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m] && num[l]) {\n\t\t\t\t\t\t\tsum[l] -= num[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\npa4 rot(pa4 z){\n\treturn {z.w,z.x,z.y,z.z};\n}\nint hen(pa4 z){\n\treturn z.x+1000*z.y+1000000*z.z+1000000000*z.w;\n}\n\n\nint ki(int z0){\n\tint ans=z0;\n\tfor(int i=0;i<3;i++){\n\t\tint am=z0%1000;\n\t\tz0/=1000;\n\t\tz0+=am*1000000000ll;\n\t\tans=min(ans,z0);\n\t}\n\treturn ans;\n}\n\nint tai(int z){\n\tint y0=z%1000;\n\tz/=1000;\n\tint y1=z%1000;\n\tz/=1000;\n\tint y2=z%1000;\n\tz/=1000;\n\tint y3=z%1000;\n\tz/=1000;\n\t\n\tif(y1==y2 && y1==y0 && y1==y3) return 4;\n\tif(y1==y3 && y0==y2) return 2;\n\treturn 1;\n}\npa4 iro[400][4];\n\nint kijun[400];\nmap<int,int> K; \nint b(int n,int r){\n\tif(r==0) return 1;\n\tif(r==1) return n;\n\tif(r%2)return b(n,r-1)*n;\n\tint z=b(n,r/2);\n\treturn z*z;\n}\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n  \tcin>>n;\n // n=400;\t\n  \tfor(int i=0;i<n;i++){\n  \t\tint y1,y2,y3,y4;\n  \t\tcin>>y1>>y2>>y3>>y4;\n  \t//\ty1=0,y2=0,y3=0,y4=0;\n  \t\tiro[i][0]={y1,y2,y3,y4};\n  \t\tfor(int j=1;j<4;j++)iro[i][j]=rot(iro[i][j-1]);\n  \t\tkijun[i]=ki(hen(iro[i][0]));\n  \t\tK[kijun[i]]++;\n  \t\n  \t}\n  \t\n  \tint ans=0,amari=0;\n  \tfor(int s=0;s<n;s++)for(int t=0;t<n;t++)if(s!=t)for(int l=0;l<4;l++)for(int r=0;r<4;r++){\n  \t\t\n  \t\tint e[4];\n  \t\te[0]=hen({iro[s][l].x,iro[s][l].w,iro[t][r].x,iro[t][r].w});\n  \t\te[1]=hen({iro[s][l].w,iro[s][l].z,iro[t][r].y,iro[t][r].x});\n  \t\te[2]=hen({iro[s][l].z,iro[s][l].y,iro[t][r].z,iro[t][r].y});\n  \t\te[3]=hen({iro[s][l].y,iro[s][l].x,iro[t][r].w,iro[t][r].z});\n  \t\t\n  \t\tfor(int i=0;i<4;i++)e[i]=ki(e[i]);\n  \t\tK[kijun[s]]--;\n  \t\tK[kijun[t]]--;\n  \t\tbool bo=true;\n  \t\tfor(int i=0;i<4;i++)if(K.count(e[i])==0||K[e[i]]==0) bo=false;\n  \t\t\n  \t\tif(bo){\n  \t\t//int cnt=0;\n  \t\tvector<pa> Pair;\n  \t\tmap<int,int >w;\n  \t\tfor(int i=0;i<4;i++){\n  \t\t\tw[e[i]]++;\n  \t\t}\n  \t\tint ka=1;\n  \t\t\t/*\n  \t\t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\t\tcout<<it->first<<\" \"<<it->second<<endl;\n  \t\t\t}\n  \t\t\tcout<<endl;\n  \t\t\t*/\n  \t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\tif(it->second==4){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<4){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*(num-3)*b(tai(it->first),4);\n  \t\t\t}\n  \t\t\tif(it->second==3){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<3){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*b(tai(it->first),3);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==2){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<2){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*b(tai(it->first),2);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==1){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<1){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t//\t\tcout<<tai(it->first)<<endl;\n  \t\t\t\tka*=num*b(tai(it->first),1);\n  \t\t\t}\n  \t\t}\n  \t\t\t//cout<<ka<<endl;\n  \t\t\tans+=ka/24;\n  \t\t\tamari+=ka%24;\n  \t\t\twhile(amari>=24){\n  \t\t\tamari-=24;\n  \t\t\t\tans++;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\tK[kijun[s]]++;\n  \t\tK[kijun[t]]++;\n  \t}\n  \tassert(amari==0);\n  \t\n  \tcout<<ans<<endl;\n  \t\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <map>\nconst int N = 405;\ntypedef long long ll; \nusing namespace std;\n\nint n, c[N][4], pos[4], u[4], d[4], cnt, sum[N * N], nxt[N * N]; \nstruct nd\n{\n\tint u, r, d, l;\n\tnd(int a = 0, int b = 0, int c = 0, int e = 0) { u = a, r = b, d = c, l = e; }\n\tbool operator < (const nd &p) const\n\t\t{\n\t\t\treturn u == p.u ? (r == p.r ? (d == p.d ? l < p.l : d < p.d) : (r < p.r)) : (u < p.u) ;\n\t\t}\n}; \nmap<nd, int> mp; \nll ans; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); //, freopen(\"cpp.out\", \"w\", stdout); \n#endif\n\tn = read <int> ();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tc[i][0] = read <int> (), c[i][1] = read <int> (), c[i][2] = read <int> (), c[i][3] = read <int> (); \n\t\tfor(int n1, n2, n3, n4, j = 0; j < 4; j++)\n\t\t{\n\t\t\tn1 = c[i][j], n2 = c[i][(j + 1) % 4], n3 = c[i][(j + 2) % 4], n4 = c[i][(j + 3) % 4]; \n\t\t\tif(mp.find(nd(n1, n2, n3, n4)) == mp.end()) mp[nd(n1, n2, n3, n4)] = ++cnt; \n\t\t\tsum[pos[j] = mp[nd(n1, n2, n3, n4)]]++; \n\t\t}\n\t\tfor(int j = 0; j < 4; j++) nxt[pos[j]] = pos[(j + 1) % 4]; \n\t}\n\tll res; \n\tfor(int x, i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tx = mp.find(nd(c[i][0], c[i][1], c[i][2], c[i][3])) != mp.end() ? mp[nd(c[i][0], c[i][1], c[i][2], c[i][3])] : 0; \n\t\t\tfor(int k = 0; k < 4; k++) sum[x]--, x = nxt[x]; \n\t\t\tx = mp.find(nd(c[j][0], c[j][1], c[j][2], c[j][3])) != mp.end() ? mp[nd(c[j][0], c[j][1], c[j][2], c[j][3])] : 0; \n\t\t\tfor(int k = 0; k < 4; k++) sum[x]--, x = nxt[x]; \n\t\t\tif(i != j)\n\t\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tres = 1; \n\t\t\t\t\tfor(int l = 0; l < 4; l++) u[l] = c[i][l], d[l] = c[j][(4 - l + k) % 4]; \n\t\t\t\t\tfor(int t, x, s = 0; s < 4; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tt = (s + 3) % 4; x = (mp.find(nd(u[s], u[t], d[t], d[s])) != mp.end() ? mp[nd(u[s], u[t], d[t], d[s])] : 0); \n\t\t\t\t\t\tres = res * (sum[x] >= 0 ? sum[x] : 0); \n\t\t\t\t\t\tfor(int l = 0; l < 4; l++) sum[x]--, x = nxt[x]; \n\t\t\t\t\t}\n\t\t\t\t\tans = ans + res; \n\t\t\t\t\tfor(int x, t, s = 0; s < 4; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tt = (s + 3) % 4; x = mp.find(nd(u[s], u[t], d[t], d[s])) != mp.end() ? mp[nd(u[s], u[t], d[t], d[s])] : 0; \n\t\t\t\t\t\tfor(int l = 0; l < 4; l++) sum[x]++, x = nxt[x]; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tx = mp.find(nd(c[i][0], c[i][1], c[i][2], c[i][3])) != mp.end() ? mp[nd(c[i][0], c[i][1], c[i][2], c[i][3])] : 0; \n\t\t\tfor(int k = 0; k < 4; k++) sum[x]++, x = nxt[x]; \n\t\t\tx = mp.find(nd(c[j][0], c[j][1], c[j][2], c[j][3])) != mp.end() ? mp[nd(c[j][0], c[j][1], c[j][2], c[j][3])] : 0; \n\t\t\tfor(int k = 0; k < 4; k++) sum[x]++, x = nxt[x];\n\t\t}\n\tprintf(\"%lld\\n\", ans / 6); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nconstexpr ll T[4]={1,1000,1000000,1000000000};\ninline ll f(const ar &x,int k){\n    ll res=0;\n    rep(i,4)res+=T[(i+k)&3]*x[i];\n    return res;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    rep3(i,15,1){\n        rep(j,4){\n            if(i&(1<<j)){\n                printf(\"if(cnt[%d]) dp[%d]+=dp[%d]*cnt[%d];\\n\",j,i,i^(1<<j),j);\n            }\n        }\n    }\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin >> v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i],j);\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                rep(ii,4){\n                    s[ii] = f(ar{v[i][(4+1-ii)&3],v[i][(4-ii)&3],v[j][(1+k+ii)&3],v[j][(k+ii)&3]},0);\n                }\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    if(cnt[0]) dp[15]+=dp[14]*cnt[0];\nif(cnt[1]) dp[15]+=dp[13]*cnt[1];\nif(cnt[2]) dp[15]+=dp[11]*cnt[2];\nif(cnt[3]) dp[15]+=dp[7]*cnt[3];\nif(cnt[1]) dp[14]+=dp[12]*cnt[1];\nif(cnt[2]) dp[14]+=dp[10]*cnt[2];\nif(cnt[3]) dp[14]+=dp[6]*cnt[3];\nif(cnt[0]) dp[13]+=dp[12]*cnt[0];\nif(cnt[2]) dp[13]+=dp[9]*cnt[2];\nif(cnt[3]) dp[13]+=dp[5]*cnt[3];\nif(cnt[2]) dp[12]+=dp[8]*cnt[2];\nif(cnt[3]) dp[12]+=dp[4]*cnt[3];\nif(cnt[0]) dp[11]+=dp[10]*cnt[0];\nif(cnt[1]) dp[11]+=dp[9]*cnt[1];\nif(cnt[3]) dp[11]+=dp[3]*cnt[3];\nif(cnt[1]) dp[10]+=dp[8]*cnt[1];\nif(cnt[3]) dp[10]+=dp[2]*cnt[3];\nif(cnt[0]) dp[9]+=dp[8]*cnt[0];\nif(cnt[3]) dp[9]+=dp[1]*cnt[3];\nif(cnt[3]) dp[8]+=dp[0]*cnt[3];\nif(cnt[0]) dp[7]+=dp[6]*cnt[0];\nif(cnt[1]) dp[7]+=dp[5]*cnt[1];\nif(cnt[2]) dp[7]+=dp[3]*cnt[2];\nif(cnt[1]) dp[6]+=dp[4]*cnt[1];\nif(cnt[2]) dp[6]+=dp[2]*cnt[2];\nif(cnt[0]) dp[5]+=dp[4]*cnt[0];\nif(cnt[2]) dp[5]+=dp[1]*cnt[2];\nif(cnt[2]) dp[4]+=dp[0]*cnt[2];\nif(cnt[0]) dp[3]+=dp[2]*cnt[0];\nif(cnt[1]) dp[3]+=dp[1]*cnt[1];\nif(cnt[1]) dp[2]+=dp[0]*cnt[1];\nif(cnt[0]) dp[1]+=dp[0]*cnt[0];\n                }\n                ans += dp[15];\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\n//#include <cv.h>\n//#include <highgui.h>\n#include <stdlib.h>\n#include <string>\n\nlong long pow_mod(long long x, long long n, long long mod_num) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) { res = (res * x) % mod_num; }\n        x = (x * x) % mod_num;\n        n = (n >> 1);\n    }\n    return res;\n}\n\n//const long long MOD = 1000000007;\nconst long long MOD = (long long)67280421310721;\nconst int MAX_N = 500;\nint N;\nint C[MAX_N][4];\n\nstd::vector<int> get_colors(int id, int rot) {\n    std::vector<int> ret;\n    for (int i = 0; i < 4; i++) {\n        ret.push_back(C[id][(i + rot) % 4]);\n    }\n    return ret;\n}\n\nstd::vector<int> get_std_colors(int id) {\n    std::vector<std::vector<int>> vec;\n    for (int i = 0; i < 4; i++) {\n        vec.push_back(get_colors(id, i));\n    }\n    std::sort(vec.begin(), vec.end());\n    return vec[0];\n}\n\nstd::vector<int> get_std_colors(const std::vector<int>& colors) {\n    assert(colors.size() == 4);\n    std::vector<std::vector<int>> vec;\n    for (int r = 0; r < 4; r++) {\n        std::vector<int> tmp;\n        for (int i = 0; i < 4; i++) {\n            tmp.push_back(colors[(i+r)%4]);\n        }\n        vec.push_back(tmp);\n    }\n    std::sort(vec.begin(), vec.end());\n    return vec[0];\n}\n\nint symmetry(const std::vector<int>& colors) {\n    assert(colors.size() == 4);\n    if (colors[0] == colors[1] && colors[1] == colors[2] && colors[2] == colors[3]) {\n        return 4;\n    }\n\n    if (colors[0] == colors[2] && colors[1] == colors[3]) {\n        return 2;\n    }\n    return 1;\n}\n\nstd::vector<std::vector<int>> get_middle(const std::vector<int>& c1, const std::vector<int>& c5) {\n    assert(c1.size() == 4);\n    assert(c5.size() == 4);\n    std::vector<std::vector<int>> ret;\n    ret.push_back(std::vector<int>({c1[0], c5[1], c5[0], c1[1]}));\n    ret.push_back(std::vector<int>({c1[1], c5[0], c5[3], c1[2]}));\n    ret.push_back(std::vector<int>({c1[2], c5[3], c5[2], c1[3]}));\n    ret.push_back(std::vector<int>({c1[3], c5[2], c5[1], c1[0]}));\n    return ret;\n}\n\nbool is_same(const std::vector<int>& c1, const std::vector<int>& c2) {\n    assert(c1.size() == 4);\n    assert(c2.size() == 4);\n    for (int i = 0; i < 4; i++) {\n        if (c1[i] != c2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nlong long perm(const long long n, const long long r) {\n    long long ret = 1;\n    for (int i = 0; i < r; i++) {\n        ret = ret * (n - i);\n    }\n    return ret;\n}\n\nstd::map<std::vector<int>, int> mp;\n\nint main(int argc, char **argv) {\n    std::cin >> N;\n    for (int i = 1; i <= N; i++) {\n        std::cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        mp[get_std_colors(i)]++;\n    }\n    \n    long long ret = 0;\n    for (int s1 = 1; s1 <= N; s1++) {\n        for (int s5 = s1 + 1; s5 <= N; s5++) {\n            for (int r5 = 0; r5 < 4; r5++) {\n                std::vector<std::vector<int>> middle = get_middle(get_colors(s1, 0), get_colors(s5, r5));\n                std::map<std::vector<int>, int> cnt;\n                for (auto m : middle) {\n                    cnt[get_std_colors(m)]++;\n                }\n                long long tmp = 1;\n                for (auto itr = cnt.begin(); itr != cnt.end(); ++itr) {\n                    if (mp.find(itr->first) == mp.end()) {\n                        tmp = 0;\n                        break;\n                    } else {\n                        long long cand_num = mp[itr->first];\n                        if (is_same(itr->first, get_std_colors(s1))) { cand_num--; }\n                        if (is_same(itr->first, get_std_colors(s5))) { cand_num--; }\n                        if (cand_num < itr->second) {\n                            tmp = 0;\n                            break;\n                        }\n                        //tmp = tmp * cn.perm(cand_num, itr->second) * pow_mod(symmetry(itr->first), itr->second, MOD);\n                        tmp = tmp * perm(cand_num, itr->second) * pow_mod(symmetry(itr->first), itr->second, MOD);\n                    }\n                }\n                ret += tmp;\n            }\n        }\n    }\n\n    std::cout << ret / 3 << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n;\nvector<int> c[4][401];\n\nint fIdx[4][4] = {\n\t{1 + 4, 0, 3, 2 + 4},\n\t{1 + 4, 0 + 4, 1, 0},\n\t{1, 0 + 4, 3 + 4, 2},\n\t{3, 2, 3 + 4, 2 + 4}\n};\nmap< vector<int> , int > cnt;\n\n\nvoid addFace(vector<int> v , int val) {\n\tfor (int it = 0 ; it < 4 ;++it) {\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tcnt[v] += val;\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0 ; j < 4 ; ++j)c[j][i].resize(4);\n\t\tfor (int j = 0 ; j < 4 ; ++j) {\n\t\t\tscanf(\"%d\", &c[0][i][j]);\n\t\t}\n\t\tfor (int j = 1 ; j < 4; ++j) {\n\t\t\tc[j][i] = c[j - 1][i];\n\t\t\trotate(c[j][i].begin(), c[j][i].begin() + 1, c[j][i].end());\n\t\t}\n\t\tfor (int j = 0 ; j < 4 ; ++j)cnt[c[j][i]]++;\n\t}\n\tll res = 0;\n\tfor (int i = 0 ; i < n ; ++i) {\n\t\tfor (int rt = 0 ; rt < 4 ; ++rt) {\n\t\t\tcnt[c[rt][i]]--;\n\t\t}\n\t\tfor (int rt = 0 ; rt < 4 ; ++rt) {\n\t\t\tfor (int j = i + 1 ; j < n ; ++j) {\n\t\t\t\tfor (int rt2 = 0 ; rt2 < 4 ; rt2++) {\n\t\t\t\t\tcnt[c[rt2][j]]--;\n\t\t\t\t}\n\t\t\t\tfor (int rt2 = 0 ; rt2 < 4 ; rt2++) {\n\t\t\t\t\tll ans =  1;\n\t\t\t\t\tvector< vector<int> > allFc;\n\t\t\t\t\tfor (int faces = 0; faces < 4 ; ++faces) {\n\t\t\t\t\t\tvector<int> v;\n\t\t\t\t\t\tfor (int kk = 0 ; kk < 4 ; ++kk) {\n\t\t\t\t\t\t\tint idx = fIdx[faces][kk];\n\t\t\t\t\t\t\tv.pb(idx >= 4 ? c[rt2][j][idx - 4] : c[rt][i][idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans *= cnt[v];\n\t\t\t\t\t\tif(ans==0)break;\n\t\t\t\t\t\tallFc.push_back(v);\n\t\t\t\t\t\taddFace(v, -1);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int p = 0; p < allFc.size(); ++p) {\n\t\t\t\t\t\taddFace(allFc[p], +1);\n\t\t\t\t\t}\n\t\t\t\t\tres += ans;\n\t\t\t\t}\n\t\t\t\tfor (int rt2 = 0 ; rt2 < 4 ; rt2++) {\n\t\t\t\t\tcnt[c[rt2][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res/4 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef long long ll;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin p2(in a){\n  return 1<<a;\n}\nin sel(in a, in b){\n  if(a<b)\n    return 0;\n  in c=1;\n  for(in i=a;i>a-b;--i)\n    c*=i;\n  return c;\n}\nVI bcl;\nVVI cl;\nVVI cord={{0,5,4,1},{1,4,7,2},{2,7,6,3},{5,0,3,6}};\nmap<VI,in> hv;\nVVI socl;\nVI cnn(VI a){\n  VI r=a;\n  forn(z,4){\n    rotate(a.begin(),a.begin()+1,a.end());\n    r=min(r,a);\n  }\n  return r;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  cl.resize(n,VI(4));\n  forn(z,n){\n    forn(i,4)\n      cin>>cl[z][i];\n  }\n  socl=cl;\n  forn(z,n){\n    socl[z]=cnn(socl[z]);\n    ++hv[socl[z]];\n  }\n  bcl.resize(8);\n  ll sm=0;\n  forn(b,n){\n    --hv[socl[b]];\n    for(in a=b+1;a<n;++a){\n      --hv[socl[a]];\n      forn(z,4){\n\trotate(cl[a].begin(),cl[a].begin()+1,cl[a].end());\n\tforn(k,4){\n\t  bcl[k]=cl[b][k];\n\t  bcl[k+4]=cl[a][k];\n\t}\n\tVVI tr(4,VI(4));\n\tforn(i,4){\n\t  forn(j,4){\n\t    tr[i][j]=bcl[cord[i][j]];\n\t  }\n\t  tr[i]=cnn(tr[i]);\n\t}\n\tsort(all(tr));\n\tll cw=1;\n\tin sf=0;\n\tforn(i,4){\n\t  if(i!=0 && tr[i]!=tr[i-1]){\n\t    cw*=sel(hv[tr[i-1]],sf);\n\t    sf=1;\n\t  }\n\t  else\n\t    ++sf;\n\t}\n\tcw*=sel(hv[tr[3]],sf);\n\tVI tp;\n\tforn(i,4){\n\t  tp=tr[i];\n\t  in ss=0;\n\t  forn(j,4){\n\t    rotate(tp.begin(),tp.begin()+1,tp.end());\n\t    ss+=(tp==tr[i]);\n\t  }\n\t  cw*=ss;\n\t}\n\tsm+=cw;\n      }\n      ++hv[socl[a]];\n    }\n  }\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,ll> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,ll &delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)%4]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid permutar(vi &nuevo)\n{\n    vper.clear();\n    forr(i,0,4)\n    vper.pb(move(nuevo,i));\n\n}\nvoid add(vi &nuevo,ll delta,map<iiii,ll> &mapa)\n{\n    //permutar(nuevo);\n    forr(i,0,4)\n    {\n        mapa[move(nuevo,i)]+=delta;\n    }\n}\nvector<iiii> vcaras;\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n        vcaras.clear();\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   ll n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   //permutar(V[2]);\n   map<iiii,ll> extra;\n   ll totp,answer=0,auxtotp;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,i+1,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    fiiv(cara2,move(V[j],kj));\n                    /*<<\"comenzamos\\n\";\n                    prll(cara1);\n                    prll(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prll(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxtotp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxtotp);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //cout<<answer<<endl;\n   cout<<answer/12<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#include<map>\n#define maxn 405\n#define int long long \nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nstruct P{\n    int a1,a2,a3,a4;\n}c[maxn];\nmap<P,int>ma;\nll ans;\nbool operator < (P x,P y)\n{\n    if(x.a1!=y.a1)  return x.a1<y.a1;\n    if(x.a2!=y.a2)  return x.a2<y.a2;\n    if(x.a3!=y.a3)  return x.a3<y.a3;\n    return x.a4<y.a4;\n}\nint check(P x,P y)\n{\n    int res=0;\n    if(x.a1==y.a1&&x.a2==y.a2&&x.a3==y.a3&&x.a4==y.a4)  res++;\n    if(x.a1==y.a2&&x.a2==y.a3&&x.a3==y.a4&&x.a4==y.a1)  res++;\n    if(x.a1==y.a3&&x.a2==y.a4&&x.a3==y.a1&&x.a4==y.a2)  res++;\n    if(x.a1==y.a4&&x.a2==y.a1&&x.a3==y.a2&&x.a4==y.a3)  res++;    \n    return res;\n}\nvoid solve(P x,P y)\n{\n    P s1=(P){y.a1,y.a2,x.a2,x.a1};\n    P s2=(P){y.a3,y.a4,x.a4,x.a3};\n    P s3=(P){y.a2,y.a3,x.a3,x.a2};\n    P s4=(P){y.a4,y.a1,x.a1,x.a4};\n    int res1=ma[s1]-check(s1,x)-check(s1,y);\n    int res2=ma[s2]-check(s2,x)-check(s2,y)-check(s2,s1);\n    int res3=ma[s3]-check(s3,x)-check(s3,y)-check(s3,s2)-check(s3,s1);\n    int res4=ma[s4]-check(s4,x)-check(s4,y)-check(s4,s3)-check(s4,s2)-check(s4,s1);\n    ans+=1ll*res1*res2*res3*res4;\n}\nmain()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  c[i].a1=read(),c[i].a2=read(),c[i].a3=read(),c[i].a4=read();\n    for(int i=1;i<=n;i++)\n    {\n        ma[(P){c[i].a1,c[i].a2,c[i].a3,c[i].a4}]++;\n        ma[(P){c[i].a2,c[i].a3,c[i].a4,c[i].a1}]++;\n        ma[(P){c[i].a3,c[i].a4,c[i].a1,c[i].a2}]++;\n        ma[(P){c[i].a4,c[i].a1,c[i].a2,c[i].a3}]++;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i+1;j<=n;j++)\n        {\n            solve(c[i],(P){c[j].a2,c[j].a1,c[j].a4,c[j].a3});\n            solve(c[i],(P){c[j].a1,c[j].a4,c[j].a3,c[j].a2});\n            solve(c[i],(P){c[j].a4,c[j].a3,c[j].a2,c[j].a1});\n            solve(c[i],(P){c[j].a3,c[j].a2,c[j].a1,c[j].a4});\n        }\n    }\n    cout<<ans/3<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 404;\nint c[maxn][4];\nvoid rotate(int id){\n\tint p0 = c[id][0];\n\tfor(int j = 0; j < 3; j++) c[id][j] = c[id][j + 1];\n\tc[id][3] = p0;\n}\nlong long calc(int id){\n\tlong long val = 0;\n\tfor(int k = 0; k < 4; k++) val = val * 1000 + c[id][k];\n\treturn val;\n}\nlong long has[maxn][4];\nvoid ins(int id){\n\tfor(int rot = 0; rot < 4; rot++){\n\t\thas[id][rot] = calc(id);\n\t\trotate(id);\n\t}\n\tsort(has[id], has[id] + 4);\n}\nint get_msk(int id, long long vals[4]){\n\tint i = 0, j = 0, msk = 0;\n\twhile(i < 4 && j < 4){\n\t\tif(has[id][i] == vals[j]) msk |= 1<<j, j++;\n\t\telse if(has[id][i] < vals[j]) i++;\n\t\telse j++;\n\t}\n\treturn msk;\n}\nunordered_map<vector<long long>, int, function<size_t(const vector<long long> &v)> > magic(1000000, [](const vector<long long> &v){\n\tsize_t res = 0;\n\tfor(auto e : v) res ^= ((e >> 31) ^ e) & ((1u<<31) - 1);\n\treturn res;\n\t});\nvoid add(int i, int s){\n\tset<vector<long long> > can;\n\tfor(int j = 1; j < 1<<4; j++){\n\t\tvector<long long> now;\n\t\tfor(int k = 0; k < 4; k++) if((j>>k)&1){\n\t\t\tif(now.empty() || now.back() != has[i][k]) now.push_back(has[i][k]);\n\t\t}\n\t\tcan.insert(now);\n\t}\n\tfor(auto e : can) magic[e] += s;\n}\nlong long need[4];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < 4; j++) cin >> c[i][j];\n\tfor(int i = 0; i < n; i++){\n\t\tins(i);\n\t\tadd(i, 1);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tadd(i, -1);\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tadd(j, -1);\n\t\t\tfor(int rotj = 0; rotj < 4; rotj++){\n\t\t\t\tint prot[4] = {};\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nik = (k + 1) % 4;\n\t\t\t\t\tint njk0 = (5 - k) % 4;\n\t\t\t\t\tint njk1 = (4 - k) % 4; \n\t\t\t\t\tneed[k] = 0;\n\t\t\t\t\tfor(int v : {c[i][nik], c[i][k], c[j][njk0], c[j][njk1]}){\n\t\t\t\t\t\tneed[k] = need[k] * 1000 + v;\n\t\t\t\t\t}\n\t\t\t\t\tc[n][0] = c[i][nik];\n\t\t\t\t\tc[n][1] = c[i][k];\n\t\t\t\t\tc[n][2] = c[j][njk0];\n\t\t\t\t\tc[n][3] = c[j][njk1];\n\t\t\t\t\tfor(int tk = 0; tk < 4; tk++){\n\t\t\t\t\t\tif(calc(n) == need[k]) prot[k]++;\n\t\t\t\t\t\trotate(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(need, need + 4);\n\t\t\t\tvector<int> cnt(1<<4);\n\t\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\t\tvector<long long> now;\n\t\t\t\t\tfor(int p = 0; p < 4; p++) if((k>>p)&1){\n\t\t\t\t\t\tif(now.empty() || now.back() != need[p]) now.push_back(need[p]);\n\t\t\t\t\t}\n\t\t\t\t\tcnt[k] = magic[now];\n\t\t\t\t}\n\t\t\t\tfor(int k = 15; k > 0; k--){\n\t\t\t\t\tfor(int sk = k; sk; sk = (sk - 1) & k){\n\t\t\t\t\t\tif(sk != k){\n\t\t\t\t\t\t\tcnt[sk] -= cnt[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<long long> f(1<<4, 0), nf(1<<4, 0);\n\t\t\t\tf[0] = 1;\n\t\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\t\tif(cnt[k]){\n\t\t\t\t\t\tnf = f;\n\t\t\t\t\t\tfor(int sk = k; sk; sk = k & (sk - 1)){\n\t\t\t\t\t\t\tassert((k&sk) == sk);\n\t\t\t\t\t\t\tlong long ways = 1;\n\t\t\t\t\t\t\tint bc = __builtin_popcount(sk);\n\t\t\t\t\t\t\tfor(int z = 0; z < bc; z++) ways *= (cnt[k] - z);\n\t\t\t\t\t\t\tif(ways > 0){\n\t\t\t\t\t\t\t\tfor(int msk = 0; msk < 1<<4; msk++){\n\t\t\t\t\t\t\t\t\tif((msk&sk) == 0){\n\t\t\t\t\t\t\t\t\t\tnf[msk|sk] += f[msk] * ways;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = nf;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\tfor(int k = 0; k < 4; k++) f[15] *= prot[k];\n\t\t\t\tans += f[15];\n\t\t\t\trotate(j);\n\t\t\t}\n\t\t\tadd(j, 1);\n\t\t}\n\t\tadd(i, 1);\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile a, tile b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) return a.color[i] < b.color[i];\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) tmp.color[i] = t.color[i];\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    for (int j = 0; j < 4; ++j) tmp.color[j] = comp.color[j];\n  }\n}\n\nbool same(tile a, tile b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= a.color[i] == b.color[i];\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) cin >> t[i].color[j];\n  }\n\n  for (int i = 0; i < N; ++i) regulation(t[i]);\n  sort(t, t+N, comp_tile);\n\n\n  ll ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) top.color[k] = t[i].color[k];\n        for (int k = 0; k < 4; ++k) bottom.color[k] = t[j].color[k];\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) tmp1.color[l] = bottom.color[l];\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) regulation(sides[l]);\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) tmp.color[n] = sides[m].color[n];\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) symmetry_count[m]++;\n              tmp = cmp;\n            }\n          }\n\n          ll tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) {\n              if (same(sides[n],sides[m])) ++x;\n            }\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= match_count[m] - x;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll X = 1000;\n\nll h(vec<int> C){\n    ll res = 0,r = 1;\n    for(int i=0;i<4;i++){\n        res += C[i]*r;\n        r *= X;\n    }\n    return res;\n}\n\nvoid set_hash(vec<int> C,map<ll,ll>& mp,int d){\n    for(int i=0;i<4;i++){\n        ll c = h(C);\n        mp[c] += d;\n        int a = C[0];\n        C.erase(C.begin());\n        C.push_back(a);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    map<ll,ll> mp;\n    vvec<int> C(N,vec<int>(4));\n    for(int i=0;i<N;i++){\n        for(int k=0;k<4;k++) cin >> C[i][k];\n        set_hash(C[i],mp,1);\n    }\n    ll ans = 0;\n    for(int i=0;i<N;i++){\n        ll c0 = h(C[i]);\n        ll now = 1;\n        set_hash(C[i],mp,-1);\n        for(int j=i+1;j<N;j++) for(int b=0;b<4;b++){\n            ll c1 = h(C[j]);\n            ll val = now;\n//            cerr << \"i : \" << i << \" j : \" << j << \"\\n\";\n//            for(int k=0;k<4;k++) cerr << C[j][k] << (k!=3? \" \":\"\\n\");\n            set_hash(C[j],mp,-1);\n            for(int l=0;l<4;l++){\n                vec<int> D = {C[j][(4-l)%4],C[j][(4-l+3)%4],C[i][(l+1)%4],C[i][l]};\n//                for(int k=0;k<4;k++) cerr << D[k] << (k!=3? \" \":\"\\n\");\n                ll v = h(D);\n                val *= mp[v];\n                set_hash(D,mp,-1);\n            }\n//            cerr << \"\\n\";\n            for(int l=0;l<4;l++){\n                vec<int> D = {C[j][(4-l)%4],C[j][(4-l+3)%4],C[i][(l+1)%4],C[i][l]};\n                set_hash(D,mp,1);\n            }\n            set_hash(C[j],mp,1);\n            int x = C[j][0];\n            C[j].erase(C[j].begin());\n            C[j].push_back(x);\n            assert(val>=0);\n            ans += val;\n        }\n        set_hash(C[i],mp,1);\n    }\n    cout << ans/3 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\n\nmap<pii,int> cnt[1111][1111];\nstruct tile\n{\n\tint c[4];\n\ttile(int a1,int a2,int a3,int a4){c[0]=a1;c[1]=a2;c[2]=a3;c[3]=a4;}\n\ttile(){}\n\tvoid add(int x){for(int i=0;i<4;i++)cnt[c[i]][c[i+1&3]][mp(c[i+2&3],c[i+3&3])]+=x;}\n\tint getnum(){return cnt[c[0]][c[1]][mp(c[2],c[3])];}\n\ttile rev()\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i]=c[i^3];\n\t\treturn ret;\n\t}\n\ttile rotate(int x)\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i+x&3]=c[i];\n\t\treturn ret;\n\t}\n\ttile print(){printf(\"tile %d %d %d %d\\n\",c[0],c[1],c[2],c[3]);}\n}a[411],tmp[4];\n\nLL getnum(const tile up,const tile down)\n{\n\tLL ret=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n//\t\tcur.print();printf(\"num= %d\\n\",cur.getnum());\n\t\tret*=cur.getnum();\n\t\tcur.add(-1);\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n\t\tcur.add(1);\n\t}\n\treturn ret;\n}\nint n;\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t\tget1(a[i].c[j]);\n\t\ta[i].add(1);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t{\n\t\tif(i==j)continue;\n\t\tfor(int k=0;k<4;k++)\n\t\t{\n\t\t\ta[i].add(-1);a[j].add(-1);\n\t\t\tans+=getnum(a[i],a[j].rev().rotate(k));\n\t\t\ta[i].add(1);a[j].add(1);\n\t\t}\n\t}\n\tprintendl(ans/6);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nint color[408][4];\nll has(int a[])\n{\n\tll res=0;\n\tfor(int i=N-1;i>=0;i--) res=res*1000+a[i];\n\treturn res;\n}\nvector<ll> _rotate(int c[])\n{\n\tvector<ll> res;\n//\tfor(int i=0;i<N;i++) cout<<c[i]<<\"   \";\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tint a[4];\n\t\tfor(int j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nint same(ll x,ll y)\n{\n\tint a[N],c[N];int sum=0;\n\tfor(int i=0;i<N;i++) a[i]=x%1000,x/=1000;\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tfor(int j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(int x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(int i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(int c1[],int c2[])\n{\n//\tfor(int i=0;i<N;i++) cout<<c1[i]<<\" \";cout<<\"\\n\";\n//\tfor(int i=0;i<N;i++) cout<<c2[i]<<\" \";cout<<\"\\n\";system(\"pause\");\n\tll p=has(c1);\n\tint a[4];ll ck[4];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(int j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t\tif(m[ck[i]]<=0) return 0;\n\t\tcnt*=(ll)m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint bel[]={0,3,2,1};\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<N;j++) cin>>color[i][j];\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint a[N],b[N];for(int k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tint c[4];\n\t\t\t\tc[0]=color[j][0],c[1]=color[j][3],c[2]=color[j][2],c[3]=color[j][1];\n\t\t\t\tfor(int l=0;l<N;l++)\n\t\t\t\t\ta[l]=c[(l+k)%N];\n\t\t\t\tans+=operate(a,b);\n\t\t\t}\n\t\t}ins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\nint c[444][4],n;\nint num[4][444];\nvoid fd(int*num,int A,int B,int C,int D,int from,int no){\n\tmemset(num,0,sizeof(int)*n);\n\tfor(int i=from+1; i<n; i++)if(i!=no){\n\t\tint E = c[i][0], F = c[i][1], G = c[i][2], H = c[i][3];\n\t\tnum[i] = 0;\n\t\tif(A == E && B == F && C == G && D == H)num[i]++;\n\t\tif(B == E && C == F && D == G && A == H)num[i]++;\n\t\tif(C == E && D == F && A == G && B == H)num[i]++;\n\t\tif(D == E && A == F && B == G && C == H)num[i]++;\n\t}\n}\nlong long int add(long long int x,long long int y){\n\treturn x+y;\n}\nlong long int sub(long long int x,long long int y){\n\treturn x-y;\n}\nlong long int mul(long long int x,long long int y){\n\treturn x*y;\n}\nint calc(int id1,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i];\n\treturn res;\n}\nint calc(int id1,int id2,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i]*num[id2][i];\n\treturn res;\n}\nint calc(int id1,int id2,int id3,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i]*num[id2][i]*num[id3][i];\n\treturn res;\n}\nint calc(int id1,int id2,int id3,int id4,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i]*num[id2][i]*num[id3][i]*num[id4][i];\n\treturn res;\n}\nint main(){\n\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<4; j++)\n\t\t\tscanf(\"%d\",&c[i][j]);\n\n\tlong long int res=0;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=i+1; j<n; j++)\n\tfor(int k=0; k<4; k++){\n\t\tint A = c[i][0];\n\t\tint B = c[i][1];\n\t\tint C = c[i][2];\n\t\tint D = c[i][3];\n\t\tint E = c[j][k%4];\n\t\tint F = c[j][(k+1)%4];\n\t\tint G = c[j][(k+2)%4];\n\t\tint H = c[j][(k+3)%4];\n\t\tfd(num[0], B, E, H, C, i, j);\n\t\tfd(num[1], A, D, G, F, i, j);\n\t\tfd(num[2], F, E, B, A, i, j);\n\t\tfd(num[3], H, G, D, C, i, j);\n\n\t\tlong long int A0 = calc(0,i);\n\t\tlong long int A1 = calc(1,i);\n\t\tlong long int A2 = calc(2,i);\n\t\tlong long int A3 = calc(3,i);\n\t\tlong long int A01 = calc(0,1,i);\n\t\tlong long int A02 = calc(0,2,i);\n\t\tlong long int A03 = calc(0,3,i);\n\t\tlong long int A12 = calc(1,2,i);\n\t\tlong long int A13 = calc(1,3,i);\n\t\tlong long int A23 = calc(2,3,i);\n\t\tlong long int A012 = calc(0,1,2,i);\n\t\tlong long int A013 = calc(0,1,3,i);\n\t\tlong long int A023 = calc(0,2,3,i);\n\t\tlong long int A123 = calc(1,2,3,i);\n\t\tlong long int A0123 = calc(0,1,2,3,i);\n\n\t\tres = add(res, mul(mul(A0,A1),mul(A2,A3)));\n\t\tres = sub(res, mul(mul(A2,A3),A01));\n\t\tres = sub(res, mul(mul(A1,A3),A02));\n\t\tres = sub(res, mul(mul(A1,A2),A03));\n\t\tres = sub(res, mul(mul(A0,A3),A12));\n\t\tres = sub(res, mul(mul(A0,A2),A13));\n\t\tres = sub(res, mul(mul(A0,A1),A23));\n\t\tres = add(res, mul(A01,A23));\n\t\tres = add(res, mul(A02,A13));\n\t\tres = add(res, mul(A03,A12));\n\t\tres = add(res, mul(mul(A0,A123),2));\n\t\tres = add(res, mul(mul(A1,A023),2));\n\t\tres = add(res, mul(mul(A2,A013),2));\n\t\tres = add(res, mul(mul(A3,A012),2));\n\t\tres = sub(res, mul(A0123,6));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    using Tile = array<int, 4>;\n    auto normalize = [&](Tile &a) {\n        Tile b = a;\n        for (int i = 1; i < 4; i++) {\n            Tile c;\n            for (int j = 0; j < 4; j++) c[j] = b[(i+j)%4];\n            if (c < a) a = c;\n        }\n    };\n    auto type = [&](Tile &a) {\n        if (a[0] == a[2] && a[1] == a[3]) {\n            if (a[0] == a[1]) return 4;\n            else return 2;\n        }\n        return 1;\n    };\n    vector<Tile> v(n);\n    map<Tile, long long> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) cin >> v[i][j];\n        normalize(v[i]); m[v[i]]++;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        m[v[i]]--;\n        for (int j = i+1; j < n; j++) {\n            m[v[j]]--;\n            for (int r = 0; r < 4; r++) {\n                vector<Tile> w;\n                long long curr = 1;\n                for (int c = 0; c < 4; c++) {\n                    Tile a = {v[i][(c+1)%4], v[i][c], v[j][(r-c+5)%4], v[j][(r-c+4)%4]};\n                    normalize(a); w.emplace_back(a);\n                    curr *= m[a] * type(a);\n                    m[a]--;\n                    if (curr == 0) break;\n                }\n                for (auto &x: w) m[x]++;\n                ans += curr;\n            }\n            m[v[j]]++;\n        }\n        m[v[i]]++;\n    }\n    cout << ans / 3 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db double\n#define inf 409\n#define infm 100009\n#define INF (ll)1e15\n#define mod ((ll)1e9+7)\n#define pi acos(-1)\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\nint n;\n\nstruct brick{\n\tint a,b,c,d;\n\tbrick(){}\n\tbrick(int aa,int bb,int cc,int dd){\n\t\ta=aa,b=bb,c=cc,d=dd;\n\t}\n}a[inf];\n\nbool operator<(brick _1,brick _2){\n\tif (_1.a==_2.a){\n\t\tif (_1.b==_2.b){\n\t\t\tif (_1.c==_2.c){\n\t\t\t\treturn _1.d<_2.d;\n\t\t\t}\n\t\t\treturn _1.c<_2.c;\n\t\t}\n\t\treturn _1.b<_2.b;\n\t}\n\treturn _1.a<_2.a;\n}\n\nbrick Nxt(brick x){\n\treturn brick(x.b,x.c,x.d,x.a);\n}\n\nmap <brick,ll> mp;\n\nvoid insert(brick x,int val){\n\tfor (int i=1;i<=4;i++){\n\t\tmp[x]+=val;\n\t\tx=Nxt(x);\n\t}\n\treturn;\n}\n\nbool check(brick x){\n\treturn mp.count(x);\n}\n\nint main(){\n\trd(n)\n\tfor (int i=1;i<=n;i++){\n\t\trd(a[i].a) rd(a[i].b) rd(a[i].c) rd(a[i].d)\n\t\tinsert(a[i],1);\n\t}\n\tll ans=0LL;\n\tfor (int i=1;i<=n;i++){\n\t\tinsert(a[i],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tinsert(a[j],-1);\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\ta[j]=Nxt(a[j]);\n\t\t\t\tbrick t1,t2,t3,t4;\n\t\t\t\tt1=brick(a[i].b,a[i].a,a[j].a,a[j].d);\n\t\t\t\tt2=brick(a[i].c,a[i].b,a[j].d,a[j].c);\n\t\t\t\tt3=brick(a[i].d,a[i].c,a[j].c,a[j].b);\n\t\t\t\tt4=brick(a[i].a,a[i].d,a[j].b,a[j].a);\n\t\t\t\tif (check(t1) && check(t2) && check(t3) && check(t4)){\n\t\t\t\t\tll now=1LL;\n\t\t\t\t\tnow*=mp[t1];\n\t\t\t\t\tinsert(t1,-1);\n\t\t\t\t\tnow*=mp[t2];\n\t\t\t\t\tinsert(t2,-1);\n\t\t\t\t\tnow*=mp[t3];\n\t\t\t\t\tinsert(t3,-1);\n\t\t\t\t\tnow*=mp[t4];\n\t\t\t\t\tinsert(t1,1);\n\t\t\t\t\tinsert(t2,1);\n\t\t\t\t\tinsert(t3,1);\n\t\t\t\t\tans+=now;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsert(a[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> color[505];\nmap<vector<int>, int> has;\nint jiao[8];\nint use[4][4]={\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid add(vector<int> color)\n{\n  for (int i=0; i<4; i++)\n  {\n      has[color]++;\n      rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid reduce(vector<int> color)\n{\n\n    for (int i=0; i<4; i++)\n    {\n        has[color]--;\n        rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid dfs(int dep,int& ans,int res=1)\n{\n    if (dep==4) ans+=res;\n    else\n    {\n        vector<int> tmp(4);\n        for (int i=0; i<4; i++)\n            tmp[i]=jiao[use[dep][i]];\n        if (has.count(tmp))\n        {\n            int cnt=has[tmp];\n            reduce(tmp);\n            dfs(dep+1,ans,res*cnt);\n            add(tmp);\n        }\n    }\n}\n\nint solve(int a,int b)\n{\n    for (int i=0; i<4; i++)\n    {\n        jiao[i]=color[a][i];\n        jiao[i+4]=color[b][i];\n    }\n    int ans=0;\n    for (int i=0; i<4; i++)\n    {\n        dfs(0,ans);\n        rotate(jiao+4,jiao+5,jiao+8);\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++)\n    {\n        color[i].resize(4);\n        for (int j=0; j<4; j++)\n        {\n            scanf(\"%d\",&color[i][j]);\n        }\n        add(color[i]);\n    }\n    int ans1=0;\n    for (int i=0; i<n; i++)\n    {\n      for (int j=i+1; j<n; j++)\n      {\n          reduce(color[i]);\n          reduce(color[j]);\n          ans1+=solve(i,j);\n          add(color[i]);\n          add(color[j]);\n      }\n      reduce(color[i]);\n    }\n    printf(\"%d\\n\",ans1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint a[405][4];\nint id[1000][1000];\nvector<P>vec;\nint cnt[3333][3333];\nll calc(vector<P2>vi){\n\tll ret = 1; assert(vi.size() == 4);\n\tbool used[4]={};\n\tfor(int i=0;i<4;i++){\n\t\tif(used[i]) continue;\n\t\tint x[4];\n\t\tx[0]=vi[i].fi.fi,x[1]=vi[i].fi.sc,x[2]=vi[i].sc.sc,x[3]=vi[i].sc.fi;\n\t\tused[i] = true; int C = 1;\n\t\tfor(int j=i+1;j<4;j++){\n\t\t\tif(used[j]) continue;\n\t\t\tint y[4];\n\t\t\ty[0]=vi[j].fi.fi,y[1]=vi[j].fi.sc,y[2]=vi[j].sc.sc,y[3]=vi[j].sc.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(x[l] != y[(k+l)%4]) goto bad;\n\t\t\t\t}\n\t\t\t\tused[j] = true;\n\t\t\t\tC++; break; bad:;\n\t\t\t}\n\t\t}\n\t\tif(x[0] == x[1] && x[1] == x[2] && x[2] == x[3]){\n\t\t\tint p = cnt[id[x[0]][x[1]]][id[x[3]][x[2]]];\n\t\t\t\n\t\t\tfor(int i=0;i<C;i++){\n\t\t\t\tret *= 1LL*p;\n\t\t\t\tp -= 4;\n\t\t\t}\n\t\t}\n\t\telse if(x[0] == x[2] && x[1] == x[3]){\n\t\t\tint p = cnt[id[x[0]][x[1]]][id[x[3]][x[2]]];\n\t\t\t\n\t\t\tfor(int i=0;i<C;i++){\n\t\t\t\tret *= 1LL*p;\n\t\t\t\tp -= 2;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint p = cnt[id[x[0]][x[1]]][id[x[3]][x[2]]];\n\t\t\t\n\t\t\tfor(int i=0;i<C;i++){\n\t\t\t\tret *= 1LL*p;\n\t\t\t\tp --;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<4;j++) cin >> a[i][j];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tvec.pb(mp(a[i][j],a[i][(j+1)%4]));\n\t\t\tvec.pb(mp(a[i][(j+1)%4],a[i][j]));\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end()); vec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tmemset(id,-1,sizeof(id));\n\tfor(int i=0;i<vec.size();i++){\n\t\tid[vec[i].fi][vec[i].sc] = i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint aa = 0,b = 1,c = 3,d = 2;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint p = id[a[i][aa]][a[i][b]];\n\t\t\tint q = id[a[i][c]][a[i][d]];\n\t\t\tcnt[p][q]++;\n\t\t\taa=(aa+1)%4;\n\t\t\tb=(b+1)%4;\n\t\t\tc=(c+1)%4;\n\t\t\td=(d+1)%4;\n\t\t}\n\t}\n\tll ret = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint aa = 0,b = 1,c = 3,d = 2;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint p = id[a[i][aa]][a[i][b]];\n\t\t\tint q = id[a[i][c]][a[i][d]];\n\t\t\tcnt[p][q]--;\n\t\t\taa=(aa+1)%4;\n\t\t\tb=(b+1)%4;\n\t\t\tc=(c+1)%4;\n\t\t\td=(d+1)%4;\n\t\t}\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\taa = 0,b = 1,c = 3,d = 2;\n\t\t\tfor(int jj=0;jj<4;jj++){\n\t\t\t\tint p = id[a[j][aa]][a[j][b]];\n\t\t\t\tint q = id[a[j][c]][a[j][d]];\n\t\t\t\tcnt[p][q]--;\n\t\t\t\taa=(aa+1)%4;\n\t\t\t\tb=(b+1)%4;\n\t\t\t\tc=(c+1)%4;\n\t\t\t\td=(d+1)%4;\n\t\t\t}\n\t\t\tint w[4]={1,0,2,3};\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvector<P2>V; V.clear();\n\t\t\t\tV.pb(mp(mp(a[i][3],a[i][2]),mp(a[j][w[2]],a[j][w[3]])));\n\t\t\t\tV.pb(mp(mp(a[i][2],a[i][1]),mp(a[j][w[3]],a[j][w[1]])));\n\t\t\t\tV.pb(mp(mp(a[i][1],a[i][0]),mp(a[j][w[1]],a[j][w[0]])));\n\t\t\t\tV.pb(mp(mp(a[i][0],a[i][3]),mp(a[j][w[0]],a[j][w[2]])));\n\t\t\t\tret += calc(V); \n\t\t\t\tfor(int l=0;l<4;l++) w[l] = (w[l]+1)%4;\n\t\t\t}\n\t\t\taa = 0,b = 1,c = 3,d = 2;\n\t\t\tfor(int jj=0;jj<4;jj++){\n\t\t\t\tint p = id[a[j][aa]][a[j][b]];\n\t\t\t\tint q = id[a[j][c]][a[j][d]];\n\t\t\t\tcnt[p][q]++;\n\t\t\t\taa=(aa+1)%4;\n\t\t\t\tb=(b+1)%4;\n\t\t\t\tc=(c+1)%4;\n\t\t\t\td=(d+1)%4;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 62;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n;\n\tcin >> n;\n\tmap<Array, ll> mp;\n\tvector<Array> a(n);\n\tauto normalize = [](Array c) {\n\t\tArray t = c;\n\t\tREP(j, 4) {\n\t\t\trotate(c.begin(), c.begin() + 1, c.end());\n\t\t\tif (t > c)t = c;\n\t\t}\n\t\treturn t;\n\t};\n\tREP(i, n) {\n\t\tArray c(4);\n\t\tREP(j, 4)cin >> c[j];\n\t\tArray t = normalize(c);\n\t\tmp[t]++;\n\t\ta[i] = t;\n\t}\n\tauto show = [](Array c) {\n\t\tREP(i, 4)cout << c[i] << (i == 3 ? \"\\n\" : \" \");\n\t};\n\tll ans = 0;\n\tREP(i, n) {\n\t\tmp[a[i]]--;\n\t\trep(j, i + 1, n) {\n\t\t\tmp[a[j]]--;\n\t\t\tREP(k, 4) {\n\t\t\t\tll tmp = 1;\n\t\t\t\tREP(l, 4) {\n\t\t\t\t\tArray c(4);\n\t\t\t\t\tc[0] = a[i][(l + 1) % 4];\n\t\t\t\t\tc[1] = a[i][l % 4];\n\t\t\t\t\tc[2] = a[j][(k - l+1 + 4) % 4];\n\t\t\t\t\tc[3] = a[j][(k - l +4) % 4];\n\t\t\t\t\tArray t = normalize(c);\n\t\t\t\t\tif (mp.count(t) == 0)tmp = 0;\n\t\t\t\t\telse tmp *= mp[t], mp[t]--;\n\t\t\t\t\tif (t[0] == t[1] && t[0] == t[2] && t[0] == t[3])tmp *= 4;\n\t\t\t\t\telse if (t[0] == t[2] && t[1] == t[3])tmp *= 2;\n\t\t\t\t}\n\t\t\t\tans += tmp;\n\t\t\t\tREP(l, 4) {\n\t\t\t\t\tArray c(4);\n\t\t\t\t\tc[0] = a[i][(l + 1) % 4];\n\t\t\t\t\tc[1] = a[i][(l) % 4];\n\t\t\t\t\tc[2] = a[j][(k - l+1+4) % 4];\n\t\t\t\t\tc[3] = a[j][(k - l + 4) % 4];\n\t\t\t\t\tArray t = normalize(c);\n\t\t\t\t\tif (mp.count(t) != 0)mp[t]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp[a[j]]++;\n\t\t}\n\t\tmp[a[i]]++;\n\t}\n\tcout << ans / 3<< \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&x[i][j]);\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[ii][(j+1)%4],x[ii][(j+0)%4],x[i][1],x[i][0]);\n                    y[1] = pack(x[ii][(j+0)%4],x[ii][(j+3)%4],x[i][2],x[i][1]);\n                    y[2] = pack(x[ii][(j+3)%4],x[ii][(j+2)%4],x[i][3],x[i][2]);\n                    y[3] = pack(x[ii][(j+2)%4],x[ii][(j+1)%4],x[i][0],x[i][3]);\n\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m.count(y[p])?m[y[p]]:0;\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            if(m.count(a[i]))m[a[i]]++;\n            else m[a[i]] = 1;\n        }\n        printf(\"%I64d\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\nvector<int>rotate(vector<int>v)\n{\n\tvector<int>r;\n\tr.resize(4);\n\tr[0] = v[1], r[1] = v[2], r[2] = v[3], r[3] = v[0];\n\treturn r;\n}\nvector<int>d[444];\ntypedef long long ll;\nmap<vector<int>, ll>ma;\nvoid add(vector<int>v)\n{\n\tfor (int i = 0; i < 4; i++)ma[v]++, v = rotate(v);\n}\nvoid sub(vector<int>v)\n{\n\tfor (int i = 0; i < 4; i++)ma[v]--, v = rotate(v);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tvector<int>v;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tv.push_back(z);\n\t\t}\n\t\td[i] = v;\n\t\tadd(v);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = i + 1; j < num; j++)\n\t\t{\n\t\t\tvector<int>s = d[i], t = d[j];\n\t\t\tsub(s), sub(t);\n\t\t\tswap(t[0], t[2]);\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tll x = 1;\n\t\t\t\tvector<vector<int> >ddd;\n\t\t\t\tfor (int l = 0; l < 4; l++)\n\t\t\t\t{\n\t\t\t\t\tvector<int>z;\n\t\t\t\t\tz.push_back(s[1]);\n\t\t\t\t\tz.push_back(s[0]);\n\t\t\t\t\tz.push_back(t[0]);\n\t\t\t\t\tz.push_back(t[1]);\n\t\t\t\t\tx *= ma[z];\n\t\t\t\t\tsub(z);\n\t\t\t\t\tddd.push_back(z);\n\t\t\t\t\ts = rotate(s), t = rotate(t);\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < 4; l++)add(ddd[l]);\n\t\t\t\t//if (x > 0)printf(\"%d %d %lld\\n\", i, j, x);\n\t\t\t\tans += x;\n\t\t\t\tt = rotate(t);\n\t\t\t}\n\t\t\tswap(t[0], t[2]);\n\t\t\tadd(s), add(t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cctype>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<cstdlib>\n#include<ctime>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<fstream>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int,int >\n#define P pair<pii,pii >\n#define F first\n#define S second\n#define d0 first.first\n#define d1 first.second\n#define d2 second.first\n#define d3 second.second\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)\ninline int getint(){\n    int x=0,p=1;char c=getchar();\n    while (c<=32)c=getchar();\n    if(c==45)p=-p,c=getchar();\n    while (c>32)x=x*10+c-48,c=getchar();\n    return x*p;\n}\nusing namespace std;\n//ruogu\nconst int N=410;\nint n,c[N][4];\nvector<P >v;\nll res;\nmap<P,ll >Mp;\n//\nvector<P>doit(int x,int y,int z,int w){\n\tvector<P >ans;\n\tans.push_back(mp(mp(x,y),mp(z,w)));\n\tans.push_back(mp(mp(y,z),mp(w,x)));\n\tans.push_back(mp(mp(z,w),mp(x,y)));\n\tans.push_back(mp(mp(w,x),mp(y,z)));\n\treturn ans;\n}\nll cntsame(P xx,P yy){\n\tll ans=0;\n\tint x=xx.F.F,y=xx.F.S,z=xx.S.F,w=xx.S.S;\n\tif(mp(mp(x,y),mp(z,w))==yy)ans++;\n\tif(mp(mp(y,z),mp(w,x))==yy)ans++;\n\tif(mp(mp(z,w),mp(x,y))==yy)ans++;\n\tif(mp(mp(w,x),mp(y,z))==yy)ans++;\n\treturn ans;\n}\nll cnt(P xx,P yy){return cntsame(xx,yy);}\nint main(){\n\tn=getint();\n\trep(i,n)rep(j,4)c[i][j]=getint();\n\trep(i,n){\n\t\tint x=c[i][0],y=c[i][1],z=c[i][2],w=c[i][3];\n\t\trep(j,v.size()){\n\t\t\tP xx=mp(mp(x,y),mp(v[j].d1,v[j].d0));\n\t\t\tP yy=mp(mp(y,z),mp(v[j].d2,v[j].d1));\n\t\t\tP zz=mp(mp(z,w),mp(v[j].d3,v[j].d2));\n\t\t\tP ww=mp(mp(w,x),mp(v[j].d0,v[j].d3));\n\t\t\tll ans=1;\n\t\t\tans*=Mp[xx]-cntsame(xx,v[j]);\n\t\t\tans*=Mp[yy]-cntsame(xx,yy)-cntsame(yy,v[j]);\n\t\t\tans*=Mp[zz]-cntsame(zz,xx)-cnt(zz,yy)-cnt(zz,v[j]);\n\t\t\tans*=Mp[ww]-cntsame(ww,xx)-cntsame(ww,yy)-cntsame(ww,zz)-cntsame(ww,v[j]);\n\t\t//cout<<ans<<endl;\n\t\t\tres+=ans;\n\t\t}\n\t\tx=c[i][0],y=c[i][3],z=c[i][2],w=c[i][1];\n\t\tvector<P >vv=doit(x,y,z,w);\n\t\trep(k,vv.size()){\n\t\t\tMp[vv[k]]++;\n\t\t\tv.push_back(vv[k]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef pair<ll,pi> pii;\ntypedef vector<pi> vpi;\ntypedef set<ll> si;\ntypedef long double ld;\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\nll INF = 1e9;\nll MOD = 1e9;\n#define lb lower_bound\n#define ub upper_bound\n#define SZ(x) (ll)x.size()\n#define ALL(x) x.begin(),x.end()\n#define count(V,x) ub(ALL(V),x,cmp) - lb(ALL(V),x,cmp)\n\nstruct cube{\n  ll a, b, c, d, orien;\n  cube(ll _a, ll _b, ll _c, ll _d): a(_a), b(_b), c(_c), d(_d), orien(1){\n    ll m = min({a,b,c,d});\n    if (a == b && a == c && a == d)orien = 4;\n    else if (a == c && b == d)orien = 2;\n  }\n\n  bool fit(cube cmp){\n    return a == cmp.a && b == cmp.b && c == cmp.c && d == cmp.d;\n  }\n\n  cube rotate(){\n    return cube({b,c,d,a});\n  }\n\n  void pp(){\n    cout<<a<<' '<<b<<' '<<c<<' '<<d<<'\\n';\n  }\n};\n\nbool cmp(cube a, cube b){\n  if (a.a != b.a)return a.a < b.a;\n  if (a.b != b.b)return a.b < b.b;\n  if (a.c != b.c)return a.c < b.c;\n  return a.d < b.d;\n}\n\nbool biggay = 0;\n\ncube bal(cube t){\n  cube q = t.rotate();\n  cube r = q.rotate();\n  cube u = r.rotate();\n  if (cmp(q, t))t = q;\n  if (cmp(r, t))t = r;\n  if (cmp(u, t))t = u;\n  return t;\n}\n\nll N;\nll a,b,c,d;\nvector<cube> V,faces;\nvi rep;\n\nint main(){\n  // freopen(\"in.txt\",\"r\",stdin);\n  cin >> N;\n  for (int i=0;i<N;++i){\n    cin >>a >> b >> c >> d;\n    V.pb({a,b,c,d});\n    V[i] = bal(V[i]);\n  }\n  sort(ALL(V), cmp);\n  // for (auto i : V)i.pp();\n  // cout<<'\\n';\n  // cout<<cmp (cube(0,1,2,3), cube(0,1,2,4) )<<'\\n';\n  // return 0;\n  ll ans=0;\n  for (int i=0;i<N-1;++i){\n    // Base\n    // if (i != 1)continue;\n    for (int j=i+1;j<N;++j){\n      // if (j != 3)continue;\n      cube top = V[i];\n      cube btm = V[j];\n      rep.clear();\n      faces.clear();\n      // cout<<\"Top \" << V[i].a<<' '<<V[i].b<<' '<<V[i].c<<' '<<V[i].d<<'\\n';\n      // cout << \"Bottom \" << V[j].a<<' '<<V[j].b<<' '<<V[j].c<<' '<<V[j].d<<'\\n';\n      for (int k=0;k<4;++k){\n        ll r = 1;\n\n        faces.pb(bal(cube(top.d,top.c,btm.c,btm.b)));\n        rep.pb(1);\n        r *= faces.back().orien;\n        \n        if (faces.back().fit(bal(cube(top.c,top.b,btm.d,btm.c) ) ) ){\n          ++rep.back();\n        }else{\n          faces.pb( bal(cube(top.c,top.b,btm.d,btm.c)) );\n          rep.pb(1);\n        }\n        r *= faces.back().orien;\n        if (faces.back().fit( bal(cube(top.a,top.d,btm.b,btm.a)) ) ){\n          ++rep.back();\n        }else{\n          faces.pb( bal(cube(top.c,top.b,btm.d,btm.c)) );\n          rep.pb(1);\n        }\n        r *= faces.back().orien;\n\n        if (faces.back().fit( bal(cube(top.b,top.a,btm.a,btm.d)) ) ){\n          ++rep.back();\n        }else{\n          faces.pb( bal(cube(top.c,top.b,btm.d,btm.c)) );\n          rep.pb(1);\n        }\n        r *= faces.back().orien;\n\n        for (int k=0;k<SZ(faces); ++k){\n          cube it = faces[k];\n          int cnt = count(V, it);\n          if (V[i].fit(it))--cnt;\n          if (V[j].fit(it))--cnt;\n          while(rep[k]){\n            --rep[k];\n            r *= cnt;\n            cnt--;\n          }\n        }\n        // cout<<'\\n';\n        // cout<<r<<' ';\n        ans += r;\n        top = top.rotate();\n      }\n      // cout<<'\\n';\n    }\n  }\n  cout<<ans/3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 500\n#define int long long\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint c[N][4],n,C[N][6],fac[5];\nll A[N],Ans;\nmap <ll,int> M;\ninline int fnd(long long y)\n{\n\tint x[4]; \n\tfor(int i=0;i<4;i++) x[i]=y&((1<<10)-1),y>>=10;\n\tif(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3]) return 4;\n\tif(x[0]==x[2]&&x[1]==x[3]) return 2;\n\treturn 1;\n}\ninline ll hsh(int x,int y,int z,int s)\n{\n\tll xs=(1ll*x<<30)+(1ll*y<<20)+(1ll*z<<10)+s;\n\treturn xs;\n}\ninline ll trans(int x,int y,int z,int s)\n{\n\treturn min(min(hsh(x,y,z,s),hsh(y,z,s,x)),min(hsh(z,s,x,y),hsh(s,x,y,z)));\n}\nsigned main()\n{\n\tn=read(); for(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++) c[i][j]=read();\n\t\tA[i]=trans(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t}\n\tfac[0]=1; fac[1]=1; fac[2]=2; fac[3]=6; fac[4]=24;\n\tC[0][0]=1; for(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;for(int j=1;j<=4;j++)\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t} \n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint y[4];\n\t\t\t\ty[0]=trans(c[i][(k+1)%4],c[i][(k+0)%4],c[j][1],c[j][0]);\n\t\t\t\ty[1]=trans(c[i][(k+0)%4],c[i][(k+3)%4],c[j][2],c[j][1]);\n\t\t\t\ty[2]=trans(c[i][(k+3)%4],c[i][(k+2)%4],c[j][3],c[j][2]);\n\t\t\t\ty[3]=trans(c[i][(k+2)%4],c[i][(k+1)%4],c[j][0],c[j][3]);\n\t\t\t\tsort(y,y+4); ll ret=1;\n\t\t\t\tfor(int p=0;p<4;p++)\n\t\t\t\t{\n\t\t\t\t\tint s=p; while(y[s]==y[p]) s++;\n\t\t\t\t\tint tot=M[y[p]];\n\t\t\t\t\tif(A[j]==y[p]) tot--;\n\t\t\t\t\tif(s-p>tot) ret=0;\n\t\t\t\t\tfor(int t=1;t<=s-p;t++) ret*=fnd(y[p]); \n\t\t\t\t\tret*=C[tot][s-p]*fac[s-p];\n\t\t\t\t\tp=s-1;\n\t\t\t\t}\n\t\t\t\tAns+=ret;\n\t\t\t}\n\t\t}\n\t\tM[A[i]]++;\n\t\t//cout << A[i] << \" \" << M[A[i]] << endl;\n\t}\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=405;\nint n;\nlong long C[maxn][4];\nmap<long long,int> mp;\ninline long long get(int x) {\n    return (C[x][0]<<30)|(C[x][1]<<20)|(C[x][2]<<10)|C[x][3];\n}\ninline long long get(long long a,long long b,long long c,long long d) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\ninline void update(long long x,int y) {\n    for (int i=0;i<4;++i) {\n        mp[x]+=y;\n        x=((x<<10)|(x>>30))&((1ll<<40)-1);\n        //x=(x>>10)|((x&1023)<<30);\n    }\n}\ninline bool check(long long a,long long b,long long c,long long d) {\n    if (mp.find(a)==mp.end()) return false;\n    if (mp.find(b)==mp.end()) return false;\n    if (mp.find(c)==mp.end()) return false;\n    if (mp.find(d)==mp.end()) return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;++i) {\n        for (int j=0;j<4;++j) cin>>C[i][j];\n        update(get(i),1);\n    }\n    long long res=0;\n    for (int i=0;i<n;++i) {\n        update(get(i),-1);\n        for (int j=i+1;j<n;++j) {\n            update(get(j),-1);\n            for (int k=0;k<4;++k) {\n                long long a=get(C[i][1],C[i][0],C[j][(1+k)&3],C[j][(  k)&3]);\n                long long b=get(C[i][2],C[i][1],C[j][(  k)&3],C[j][(3+k)&3]);\n                long long c=get(C[i][0],C[i][3],C[j][(2+k)&3],C[j][(1+k)&3]);\n                long long d=get(C[i][3],C[i][2],C[j][(3+k)&3],C[j][(2+k)&3]);\n                if (!check(a,b,c,d)) continue;\n                long long c1=mp[a];\n                update(a,-1);\n                long long c2=mp[b];\n                update(b,-1);\n                long long c3=mp[c];\n                update(c,-1);\n                long long c4=mp[d];\n                if (c1>0&&c2>0&&c3>0&&c4>0) res+=c1*c2*c3*c4;\n                update(a,1);\n                update(b,1);\n                update(c,1);\n            }\n            update(get(j),1);\n        }\n        update(get(i),1);\n    }\n    cout<<res/3<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define INF 2147483647\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\n#define _ 0\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nnamespace Mymath{\n\tLL qp(LL x,LL p,LL mod){\n\t\tLL ans=1;\n\t\twhile (p){\n\t\t\tif (p&1) ans=ans*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tp>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tLL inv(LL x,LL mod){\n\t\treturn qp(x,mod-2,mod);\n\t}\n\tLL C(LL N,LL K,LL fact[],LL mod){\n\t\treturn fact[N]*inv(fact[K],mod)%mod*inv(fact[N-K],mod)%mod;\n\t}\n\ttemplate <typename Tp> Tp gcd(Tp A,Tp B){\n\t\tif (B==0) return A;\n\t\treturn gcd(B,A%B);\n\t}\n\ttemplate <typename Tp> Tp lcm(Tp A,Tp B){\n\t\treturn A*B/gcd(A,B);\n\t}\n};\nnamespace fwt{\n\tusing namespace Mymath;\n\tvoid FWT(int a[],int n,LL mod)\n\t{\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;\n\t                //xor:a[i+j]=x+y,a[i+j+d]=x-y;\n\t                //and:a[i+j]=x+y;\n\t                //or:a[i+j+d]=x+y;\n\t            }\n\t}\n\n\tvoid UFWT(int a[],int n,LL mod)\n\t{\n\t\tLL rev=inv(2,mod);\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;\n\t                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n\t                //and:a[i+j]=x-y;\n\t                //or:a[i+j+d]=y-x;\n\t            }\n\t}\n\tvoid solve(int a[],int b[],int n,LL mod)\n\t{\n\t    FWT(a,n,mod);\n\t    FWT(b,n,mod);\n\t    for(int i=0;i<n;i++) a[i]=1LL*a[i]*b[i]%mod;\n\t    UFWT(a,n,mod);\n\t}\n};\nnamespace Maxflow{\n\tconst int Maxn=1005;\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tedge(int _to,int _rev,int _cap){\n\t\t\tto=_to,rev=_rev,cap=_cap;\n\t\t}\n\t};\n\tint src=1002,snk=1003;\n\tvector<edge> G[Maxn];\n\tint dist[Maxn],seen[Maxn];\n\tint n;\n\tvoid Clear(){\n\t\tfor (int i=0;i<Maxn;i++) G[i].clear();\n\t}\n\tvoid bfs(int s){\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=-1;\n\t\tdist[s]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()){\n\t\t\tint x=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tedge &e=G[x][i];\n\t\t\t\tif (e.cap && dist[e.to]==-1){\n\t\t\t\t\tdist[e.to]=dist[x]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int now,int dest,int fl){\n\t\tif (now==dest) return fl;\n\t\tfor (int &i=seen[now];i<G[now].size();i++){\n\t\t\tedge &ed=G[now][i];\n\t\t\tif (ed.cap && dist[ed.to]==dist[now]+1){\n\t\t\t\tint f=dfs(ed.to,dest,min(fl,ed.cap));\n\t\t\t\tif (f){\n\t\t\t\t\ted.cap-=f;\n\t\t\t\t\tG[ed.to][ed.rev].cap+=f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dinic(int s=src,int t=snk){\n\t\tint ret=0;\n\t\twhile (1){\n\t\t\tmemset(seen,0,sizeof(seen));\n\t\t\tbfs(s);\n\t\t\tif (dist[t]==-1) return ret;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\twhile(f){\n\t\t\t\tret+=f;\n\t\t\t\tf=dfs(s,t,INF);\n\t\t\t}\n\t\t}\n\t}\n};\nnamespace Geometry{\n\tstruct iP{\n\t\tLL x,y;\n\t\tiP(LL _x,LL _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tiP(){\n\t\t\tx=y=0;\n\t\t}\n\t\tiP operator +(iP p){\n\t\t\treturn iP(x+p.x,y+p.y);\n\t\t}\n\t\tiP operator -(iP p){\n\t\t\treturn iP(x-p.x,y-p.y);\n\t\t}\n\t\tiP operator *(LL k){\n\t\t\treturn iP(x*k,y*k);\n\t\t}\n\t\tLL det(iP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tLL dot(iP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tLL dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const iP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tstruct dP{\n\t\tdouble x,y;\n\t\tdP(double _x,double _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tdP(){\n\t\t\tx=y=0.0;\n\t\t}\n\t\tdP operator +(dP p){\n\t\t\treturn dP(x+p.x,y+p.y);\n\t\t}\n\t\tdP operator -(dP p){\n\t\t\treturn dP(x-p.x,y-p.y);\n\t\t}\n\t\tdP operator *(double k){\n\t\t\treturn dP(x*k,y*k);\n\t\t}\n\t\tdouble det(dP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tdouble dot(dP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tdouble dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const dP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tvector<iP> convex_hull(iP X[],int l){\n\t\t#define sz ret.size()\n\t\tvector<iP> ret;\n\t\tsort(X+1,X+1+l);\n\t\tret.pb(X[1]);\n\t\tfor (int i=2;i<=l;i++){\n\t\t\twhile (sz>=2 && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\tint rs=ret.size()+1;\n\t\tfor (int i=l-1;i>=1;i--){\n\t\t\twhile (sz>=rs && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst int Maxn=405;\nint c[Maxn][4];\nint n;\nint now[4][4];\nint cc[Maxn][4];\nLL V[4];\nLL ha[Maxn][4];\nLL dp[16],dp2[16];\nmap<pair<LL,LL>,LL> D;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t}\n\t\tfor (int st=0;st<4;st++){\n\t\t\tha[i][st]=0;\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tha[i][st]*=1000LL;\n\t\t\t\tha[i][st]+=c[i][(st+k)%4];\n\t\t\t}\n\t\t//\tcout<<ha[i][st]<<endl;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tLL dlt=0;\n\t\t\tbool ff=false;\n\t\t\tfor (int p1=0;p1<4;p1++){\n\t\t\t\tfor (int p2=0;p2<4;p2++){\n\t\t\t\t\tif (D.count(mp(ha[i][p1],ha[j][p2]))){\n\t\t\t\t\t\tff=true;\n\t\t\t\t\t\tans+=D[mp(ha[i][p1],ha[j][p2])];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ff) break;\n\t\t\t}\n\t\t\tif (ff) continue;\n\t\t\tfor (int k=0;k<4;k++){\n//\t\t\t\tbool flag=true;\n\t\t\t\tnow[0][0]=c[j][k];\n\t\t\t\tnow[0][1]=c[j][(k+3)%4];\n\t\t\t\tnow[0][2]=c[i][1];\n\t\t\t\tnow[0][3]=c[i][0];\n\t\t\t\t\n\t\t\t\tnow[1][0]=c[j][(k+3)%4];\n\t\t\t\tnow[1][1]=c[j][(k+2)%4];\n\t\t\t\tnow[1][2]=c[i][2];\n\t\t\t\tnow[1][3]=c[i][1];\n\t\t\t\t\n\t\t\t\tnow[2][0]=c[j][(k+2)%4];\n\t\t\t\tnow[2][1]=c[j][(k+1)%4];\n\t\t\t\tnow[2][2]=c[i][3];\n\t\t\t\tnow[2][3]=c[i][2];\n\t\t\t\t\n\t\t\t\tnow[3][0]=c[j][(k+1)%4];\n\t\t\t\tnow[3][1]=c[j][(k)%4];\n\t\t\t\tnow[3][2]=c[i][0];\n\t\t\t\tnow[3][3]=c[i][3];\n\t\t\t\t\n\t\t\t\tfor (int l=0;l<4;l++){\n\t\t\t\t\tV[l]=0;\n\t\t\t\t\tfor (int o=0;o<4;o++){\n\t\t\t\t\t\tV[l]=V[l]*1000+now[l][o];\n\t\t\t\t\t}\n\t\t\t\t\t//if (i==1 && j==5) cout<<k<<' '<<V[l]<<endl;\n\t\t\t\t//\tcout<<V[l]<<endl;\n\t\t\t\t}\n\t\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t\tdp[0]=1;\n\t\t\t\tfor (int l=1;l<=n;l++){\n\t\t\t\t\tif (l==i || l==j) continue;\n\t\t\t\t\tmemset(dp2,0,sizeof(dp2));\n\t\t\t\t\tfor (int jj=0;jj<4;jj++){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\tfor (int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\tif (ha[l][kk]==V[jj]) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (cnt){\n\t\t\t\t\t\t//\tcout<<cnt<<endl;\n\t\t\t\t\t\t\tfor (int q=15;q>=0;q--){\n\t\t\t\t\t\t\t\tif (q>>jj&1){\n\t\t\t\t\t\t\t\t\tdp2[q]+=dp[q^(1<<jj)]*cnt;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int jj=0;jj<16;jj++) dp[jj]+=dp2[jj];\n\t\t\t\t}\n\t\t\t\t//cout<<dp[15]<<endl;\n\t\t\t\tdlt+=dp[15];\n\t\t\t}\n\t\t\tD[mp(ha[i][0],ha[j][0])]=dlt;\n\t\t\tans+=dlt;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n\n  set<P> used;\n  map<sq, Int> dp;\n  auto dup=[&](const sq &a)->Int{\n    if(dp.count(a)) return dp[a];\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return dp[a]=res;\n  };\n  \n  auto norm=[&](const sq &a)->sq{\n    sq b(8);\n    map<Int, Int> m;\n    Int sz=0;\n    for(Int i=0;i<8;i++){\n      if(!m.count(a[i])) m[a[i]]=sz++;\n      b[i]=m[a[i]];\n    }\n    return b;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      //if(used.count(conv(norm(a)))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(norm(a));\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define MODULE 1000000007\n#define MP make_pair\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n        //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint n;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay(v);\n    }\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    /*tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];*/\n                    tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> c(n, vector<vector<int>>(4, vector<int>(4)));\n    map<vector<int>, int> mp;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) {\n            cin >> c[i][0][j];\n        }\n        for (int j = 1; j < 4; j++) {\n            c[i][j] = c[i][j - 1];\n            c[i][j].insert(c[i][j].begin(), c[i][j].back());\n            c[i][j].pop_back();\n        }\n        sort(c[i].begin(), c[i].end());\n        mp[c[i][0]]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        mp[c[i][0]]--;\n        for (int j = i + 1; j < n; j++) {\n            mp[c[j][0]]--;\n            for (int k = 0; k < 4; k++) {\n                vector<int> a = c[i][0], b = c[j][k];\n                vector<vector<int>> s = {\n                    {b[1], b[0], a[1], a[0]},\n                    {a[1], b[0], b[3], a[2]},\n                    {a[3], a[2], b[3], b[2]},\n                    {b[1], a[0], a[3], b[2]}};\n                vector<int> val(4, 1);\n                for (int l = 0; l < 4; l++) {\n                    vector<vector<int>> x(4, s[l]);\n                    for (int m = 1; m < 4; m++) {\n                        x[m] = x[m - 1];\n                        x[m].insert(x[m].begin(), x[m].back());\n                        x[m].pop_back();\n                    }\n                    sort(x.begin(), x.end());\n                    s[l] = x[0];\n                    for (int m = 1; m < 4; m++) {\n                        if (x[0] == x[m]) {\n                            val[l]++;\n                        }\n                    }\n                }\n                ll cnt = 1;\n                for (int l = 0; l < 4; l++) {\n                    cnt *= mp[s[l]] * val[l];\n                    mp[s[l]]--;\n                }\n                for (int l = 0; l < 4; l++) {\n                    mp[s[l]]++;\n                }\n                ans += cnt;\n            }\n            mp[c[j][0]]++;\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<vector<ll>,ll>mp;\n  ll access(vector<ll>v){\n    ll ret=0;\n    ret+=mp[{v[0],v[1],v[2],v[3]}];\n    ret+=mp[{v[1],v[2],v[3],v[0]}];\n    ret+=mp[{v[2],v[3],v[0],v[1]}];\n    ret+=mp[{v[3],v[0],v[1],v[2]}];\n    //cout<<ret<<endl;\n    return max(0LL,ret);\n  }\n  void change(vector<ll>v,ll w){\n    mp[v]+=w;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,0LL);\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.change(c[i],1);\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<ll>now1(4);\n        rep(k,0,4){\n          now1[k]=c[j][(k+jj)%4];\n        }\n        //debug(now1,4);\n        if(now1[0]!=c[i][3]||now1[1]!=c[i][2])continue;\n        rep(o,i+1,n){\n          if(j==o)continue;\n          dict.change(c[o],-1);\n          rep(oo,0,4){\n            vector<ll>now2(4);\n            rep(k,0,4){\n              now2[k]=c[o][(k+oo)%4];\n            }\n            if(now2[0]!=c[i][1]||now2[1]!=c[i][0])continue;\n            ll tmp=1;\n            vector<ll>ret1={now1[1],now2[0],now2[3],now1[2]};\n            vector<ll>ret2={now2[1],now1[0],now1[3],now2[2]};\n            vector<ll>ret3={now1[3],now1[2],now2[3],now2[2]};\n            //cout<<\"test\"<<endl;\n            //debug(now1,4);debug(now2,4);debug(c[i],4);\n            //debug(ret1,4);debug(ret2,4);debug(ret3,4);\n            tmp*=dict.access(ret1);\n            dict.change(ret1,-1);\n            tmp*=dict.access(ret2);\n            dict.change(ret2,-1);\n            tmp*=dict.access(ret3);\n            dict.change(ret2,1);\n            dict.change(ret1,1);\n            res+=tmp;\n          }\n          dict.change(c[o],1);\n        }\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\ninline int GetBit(int mask, int num) {\n    return (mask >> num) & 1;\n}\n\nint cFront[4];\nint cBack[4];\n\ninline bool CanLeft(int c0, int c1, int c2, int c3) {\n    return c0 == cBack[3] && c1 == cBack[2] && c2 == cFront[1] && c3 == cFront[0];\n}\n\ninline bool CanRight(int c0, int c1, int c2, int c3) {\n    return c0 == cFront[3] && c1 == cFront[2] && c2 == cBack[1] && c3 == cBack[0];\n}\n\ninline bool CanUp(int c0, int c1, int c2, int c3) {\n    return c0 == cFront[1] && c1 == cBack[2] && c2 == cBack[1] && c3 == cFront[2];\n}\n\ninline bool CanDown(int c0, int c1, int c2, int c3) {\n    return c0 == cBack[3] && c1 == cFront[0] && c2 == cFront[3] && c3 == cBack[0];\n}\n\ninline bool Can(int b, int c1, int c2, int c3, int c4) {\n    if (b == 0) {\n        return CanLeft(c1, c2, c3, c4);\n    } else if (b == 1) {\n        return CanRight(c1, c2, c3, c4);\n    } else if (b == 2) {\n        return CanUp(c1, c2, c3, c4);\n    } else {\n        return CanDown(c1, c2, c3, c4);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> colors(n, vector<int>(8));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n            colors[i][j + 4] = colors[i][j];\n        }\n    }\n\n    /*\n    vector<vector<int>> bits(1 << 4);\n    for (int mask = 0; mask < (1 << 4); ++mask) {\n        for (int b = 0; b < 4; ++b) {\n            if (!GetBit(mask, b)) {\n                bits[mask].push_back(b);\n            }\n        }\n    }\n    */\n\n    long long result[2][1 << 4];\n\n    int buffer[4];\n\n    long long glResult = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int t = 0; t < 4; ++t) {\n            cFront[t] = colors[i][t];\n        }\n\n        for (int j = i + 1; j < n; ++j) {\n            for (int dj = 0; dj < 4; ++dj) {\n                for (int t = 0; t < 4; ++t) {\n                    cBack[t] = colors[j][dj + t];\n                }\n\n                int curPtr = 0;\n                memset(result[curPtr], 0, sizeof(long long) * (1 << 4));\n                result[curPtr][0] = 1;\n\n                for (int k = i + 1; k < n; ++k) {\n                    if (k == j) {\n                        continue;\n                    }\n\n                    const int nxtPtr = 1 - curPtr;\n                    for (int t = 0; t < (1 << 4); ++t) {\n                        result[nxtPtr][t] = result[curPtr][t];\n                    }\n\n                    memset(buffer, 0, sizeof(int) * 4);\n\n                    for (int dk = 0; dk < 4; ++dk) {\n                        /*\n                        buffer[0] += CanLeft(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        buffer[1] += CanRight(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        buffer[2] += CanUp(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        buffer[3] += CanDown(colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3]);\n                        */\n\n                        for (int b = 0; b < 4; ++b) {\n                            if (Can(b, colors[k][dk], colors[k][dk + 1], colors[k][dk + 2], colors[k][dk + 3])) {\n                                ++buffer[b];\n                            }\n                        }\n                    }\n\n                    for (int mask = 0; mask < (1 << 4); ++mask) {\n                        for (int b = 0; b < 4; ++b) {\n                            if (!GetBit(mask, b)) {\n                                result[nxtPtr][mask + (1 << b)] += buffer[b] * result[curPtr][mask];\n                            }\n                        }\n                    }\n\n                    curPtr = nxtPtr;\n                }\n\n                glResult += result[curPtr][(1 << 4) - 1];\n            }\n        }\n    }\n\n    cout << glResult << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\n#define mkpr make_pair\n\nconst int N = 405;\nint n;\npair<ii, ii> c[N];\n\nmap<pair<ii, ii>, int> gesicht;\n\npair<ii, ii> rotate(pair<ii, ii> f) {\n\tpair<ii, ii> fans = f;\n\n\tint tmp = fans.second.second;\n\tfans.second.second = fans.second.first;\n\tfans.second.first = fans.first.second;\n\tfans.first.second = fans.first.first;\n\tfans.first.first = tmp;\n\n\treturn fans;\n}\n\nint main() {\n\tcin >> n;\n\tint c0, c1, c2, c3;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> c0 >> c1 >> c2 >> c3;\n\t\tc[i] = mkpr(mkpr(c0, c1), mkpr(c2, c3));\n\t\tpair<ii, ii> tmp = c[i];\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(gesicht.find(c[i]) == gesicht.end()) gesicht.insert(mkpr(c[i], 1));\n\t\t\telse gesicht[c[i]]++;\n\t\t\tc[i] = rotate(c[i]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int f1i = 0; f1i < n; f1i++) {\n\t\tpair<ii, ii> f1 = c[f1i];\n\t\tfor(int f4i = f1i+1; f4i < n; f4i++) {\n\t\t\tpair<ii, ii> f4 = c[f4i];\n\t\t\tfor(int rot = 0; rot < 4; rot++) {\n\t\t\t\tint partAns = 1;\n\t\t\t\tpair<ii, ii> f2, f3, f5, f6;\n\t\t\t\tf2 = mkpr(mkpr(f1.first.second, f4.first.first), mkpr(f4.second.second, f1.second.first));\n\t\t\t\tf3 = mkpr(mkpr(f1.second.first, f4.second.second), mkpr(f4.second.first, f1.second.second));\n\t\t\t\tf5 = mkpr(mkpr(f1.second.second, f4.second.first), mkpr(f4.first.second, f1.first.first));\n\t\t\t\tf6 = mkpr(mkpr(f1.first.first, f4.first.second), mkpr(f4.first.first, f1.first.second));\n\n\t\t\t\tint matches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f2 == f1) matches++; if(f2 == f4) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f2]-matches);\n\n\t\t\t\tmatches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f3 == f1) matches++; if(f3 == f4) matches++; if(f3 == f2) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4); f2 = rotate(f2);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f3]-matches);\n\n\t\t\t\tmatches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f5 == f1) matches++; if(f5 == f4) matches++; if(f5 == f2) matches++; if(f5 == f3) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4); f2 = rotate(f2); f3 = rotate(f3);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f5]-matches);\n\n\t\t\t\tmatches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f6 == f1) matches++; if(f6 == f4) matches++; if(f6 == f2) matches++; if(f6 == f3) matches++; if(f6 == f5) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4); f2 = rotate(f2); f3 = rotate(f3); f5 = rotate(f5);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f6]-matches);\n\n\t\t\t\tans += partAns;\n\t\t\t\tf4 = rotate(f4);\n\t\t\t}\n\t\t}\n\t}\n\n\tans /= 3; //Answers are overcounted twice\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 400 + 5\n#define K 5\n#define base 1000\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, ans, C[N][K];\nunordered_map <int, int> M;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Hash(int a, int b, int c, int d){\n    int ans = 0;\n    ans = ans * base + a, ans = ans * base + b, ans = ans * base + c, ans = ans * base + d;\n    return ans;\n}\nvoid update(int val, int x){\n    int a, b, c, d;\n    d = val % base, val /= base;\n    c = val % base, val /= base;\n    b = val % base, val /= base;\n    a = val % base, val /= base;\n    M[Hash(a, b, c, d)] += x;\n    M[Hash(b, c, d, a)] += x;\n    M[Hash(c, d, a, b)] += x;\n    M[Hash(d, a, b, c)] += x;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n){\n        C[i][0] = read(), C[i][1] = read(), C[i][2] = read(), C[i][3] = read();\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    rep(i, 1, n){\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), -1);\n        rep(j, i + 1, n){\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), -1);\n            rep(k, 0, 3){\n                int AA = Hash(C[i][0], C[i][3], C[j][k], C[j][(3 + k) % 4]); if(!M[AA]) continue;\n                int BB = Hash(C[i][3], C[i][2], C[j][(1 + k) % 4], C[j][k]); if(!M[BB]) continue;\n                int CC = Hash(C[i][2], C[i][1], C[j][(2 + k) % 4], C[j][(1 + k) % 4]); if(!M[CC]) continue;\n                int DD = Hash(C[i][1], C[i][0], C[j][(3 + k) % 4], C[j][(2 + k) % 4]); if(!M[DD]) continue;\n                int a, b, c, d;\n                a = M[AA], update(AA, -1);\n                b = M[BB], update(BB, -1);\n                c = M[CC], update(CC, -1);\n                d = M[DD], update(DD, -1);\n                if(a > 0 && b > 0 && c > 0 && d > 0) ans += a * b * c * d;\n                update(AA, 1), update(BB, 1), update(CC, 1), update(DD, 1);\n            }\n            update(Hash(C[j][0], C[j][1], C[j][2], C[j][3]), 1);\n        }\n        update(Hash(C[i][0], C[i][1], C[i][2], C[i][3]), 1);\n    }\n    printf(\"%lld\", ans / 3);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<int> standard(vector<int> x) {\n  for (int i = 0; i < 4; i++) x.push_back(x[i]);\n\n  vector<int> ret = {10000, 10000, 100000, 100000};\n  for (int j = 0; j < 4; j++) {\n    vector<int> color;\n    for (int k = 0; k < 4; k++) color.push_back(x[j + k]);\n    if (ret > color) ret = color;\n  }\n  return ret;\n}\n\nLL MAX;\nLL encode(const vector<int> x) {\n  LL val = 0;\n  for (int i = 0; i < 4; i++) {\n    val *= 1000;\n    val += x[i];\n  }\n  LL best = val;\n  for (int i = 0; i < 4; i++) {\n    val *= 1000;\n    val %= MAX;\n    val += x[i];\n    best = min(best, val);\n  }\n\n  return best;\n}\n\nvoid dump(vector<int> x) {\n  for (auto val : x) cout << val << \" \";\n  cout << endl;\n}\n\nint main() {\n  MAX = 1000000;\n  MAX *= MAX;\n  int N;\n  cin >> N;\n  // map<vector<int>, int> colors;\n  // map<vector<int>, int> muls;\n  map<LL, int> colors;\n  map<LL, int> muls;\n  set<vector<int>> keys;\n  for (int i = 0; i < N; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    vector<int> base_color = {a, d, c, b, a, d, c, b};\n    vector<vector<int>> tmp_color;\n    for (int j = 0; j < 4; j++) {\n      vector<int> color;\n      for (int k = 0; k < 4; k++) color.push_back(base_color[j + k]);\n      tmp_color.push_back(color);\n    }\n    vector<int> color = standard(tmp_color[0]);\n    colors[encode(color)]++;\n    int mul = 0;\n    for (int j = 0; j < 4; j++)\n      if (tmp_color[0] == tmp_color[j]) mul++;\n    muls[encode(color)] = mul;\n    keys.insert(color);\n  }\n\n  LL ans = 0;\n  vector<vector<int>> keyv;\n  for (auto key : keys) {\n    keyv.push_back(key);\n  }\n\n  for (auto low : keyv) {\n    for (auto up : keyv) {\n      for (int z = 0; z < 4; z++) {\n        LL low_key = encode(low);\n        LL up_key = encode(up);\n        LL ret = 1;\n        ret *= colors[low_key];\n        colors[low_key]--;\n        ret *= colors[up_key];\n        colors[up_key]--;\n\n        vector<LL> hozon;\n        for (int i = 0; i < 4; i++) {\n          vector<int> cur;\n          cur = {low[(7 - i) % 4], low[(6 - i) % 4], up[(1 + i + z) % 4],\n                 up[(i + z) % 4]};\n          LL key = encode(cur);\n          ret *= colors[key] * muls[key];\n\n          colors[key]--;\n          hozon.push_back(key);\n        }\n        for (auto key : hozon) {\n          colors[key]++;\n        }\n\n        ans += ret;\n        colors[low_key]++;\n        colors[up_key]++;\n      }\n    }\n\n    // colors[low] = 0;\n  }\n  cout << ans / 6 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\ninline int GetBit(int mask, int num) {\n    return (mask >> num) & 1;\n}\n\nint cFront[4];\nint cBack[4];\n\ninline long long GetId(int c0, int c1, int c2, int c3) {\n    return c0 + 1000LL * (c1 + 1000LL * (c2 + 1000LL * c3));\n}\n\ninline long long GetLeftId() {\n    return GetId(cBack[3], cBack[2], cFront[1], cFront[0]);\n}\n\ninline long long GetRightId() {\n    return GetId(cFront[3], cFront[2], cBack[1], cBack[0]);\n}\n\ninline long long GetUpId() {\n    return GetId(cFront[1], cBack[2], cBack[1], cFront[2]);\n}\n\ninline long long GetDownId() {\n    return GetId(cBack[3], cFront[0], cFront[3], cBack[0]);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    // n = 400;\n\n    vector<vector<int>> colors(n, vector<int>(8));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            // colors[i][j] = 0;\n            cin >> colors[i][j];\n            colors[i][j + 4] = colors[i][j];\n        }\n    }\n\n    vector<vector<long long>> ids(n, vector<long long>(4));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            ids[i][j] = GetId(colors[i][j], colors[i][j + 1], colors[i][j + 2], colors[i][j + 3]);\n        }\n    }\n\n    long long result[2][1 << 4];\n\n    long long curIds[4];\n\n    int buffer[4];\n\n    long long glResult = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int t = 0; t < 4; ++t) {\n            cFront[t] = colors[i][t];\n        }\n\n        for (int j = i + 1; j < n; ++j) {\n            for (int dj = 0; dj < 4; ++dj) {\n                for (int t = 0; t < 4; ++t) {\n                    cBack[t] = colors[j][dj + t];\n                }\n\n                curIds[0] = GetLeftId();\n                curIds[1] = GetRightId();\n                curIds[2] = GetUpId();\n                curIds[3] = GetDownId();\n\n                int curPtr = 0;\n                for (int t = 0; t < (1 << 4); ++t) {\n                    result[curPtr][t] = 0;\n                }\n                result[curPtr][0] = 1;\n\n                for (int k = i + 1; k < n; ++k) {\n                    if (k == j) {\n                        continue;\n                    }\n\n                    const int nxtPtr = 1 - curPtr;\n                    for (int t = 0; t < (1 << 4); ++t) {\n                        result[nxtPtr][t] = result[curPtr][t];\n                    }\n\n                    for (int t = 0; t < 4; ++t) {\n                        buffer[t] = 0;\n                    }\n                    for (int s = 0; s < 4; ++s) {\n                        for (int t = 0; t < 4; ++t) {\n                            if (curIds[t] == ids[k][s]) {\n                                ++buffer[t];\n                            }\n                        }\n                    }\n\n                    for (int mask = 0; mask < (1 << 4); ++mask) {\n                        for (int b = 0; b < 4; ++b) {\n                            if (!GetBit(mask, b)) {\n                                result[nxtPtr][mask + (1 << b)] += buffer[b] * result[curPtr][mask];\n                            }\n                        }\n                    }\n\n                    curPtr = nxtPtr;\n                }\n\n                glResult += result[curPtr][(1 << 4) - 1];\n            }\n        }\n    }\n\n    cout << glResult << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint64_t make_key(tuple<int, int, int, int> &t)\n{\n    return ((int64_t)get<0>(t) << 30) |\n           ((int64_t)get<1>(t) << 20) |\n           ((int64_t)get<2>(t) << 10) |\n           ((int64_t)get<3>(t) <<  0);\n}\n\ntuple<int, int, int, int> ext_key(int64_t k)\n{\n    return make_tuple((int)(k >> 30) & 0x3ff,\n                      (int)(k >> 20) & 0x3ff,\n                      (int)(k >> 10) & 0x3ff,\n                      (int)(k >>  0) & 0x3ff);\n}\n\nvoid rot(tuple<int, int, int, int> &t)\n{\n    swap(get<0>(t), get<1>(t));\n    swap(get<1>(t), get<2>(t));\n    swap(get<2>(t), get<3>(t));\n}\n\ntypedef tuple<int, int, int, int> tup;\n\nint main()\n{\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<tuple<int, int, int, int>> cs(n);\n    for (auto &tpl: cs) {\n        cin >> get<0>(tpl) >> get<1>(tpl) >> get<2>(tpl) >> get<3>(tpl);\n    }\n\n    map<int64_t, set<int>> mm;\n\n    for (int i = 0; i < n; i++) {\n        tup t = cs[i];\n        mm[make_key(t)].insert(i);\n        rot(t);\n        mm[make_key(t)].insert(i);\n        rot(t);\n        mm[make_key(t)].insert(i);\n        rot(t);\n        mm[make_key(t)].insert(i);\n    }\n\n    int64_t ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        tup t = cs[i];\n\n        for (int j = i + 1; j < n; j++) {\n            tup u = cs[j];\n\n            for (int r = 0; r < 4; r++) {\n                tup x1(get<0>(t), get<1>(u), get<0>(u), get<1>(t));\n                tup x2(get<3>(t), get<2>(u), get<1>(u), get<0>(t));\n                tup x3(get<2>(t), get<3>(u), get<2>(u), get<3>(t));\n                tup x4(get<1>(t), get<0>(u), get<3>(u), get<2>(t));\n\n                ans +=\n                    mm[make_key(x1)].size() *\n                    mm[make_key(x2)].size() *\n                    mm[make_key(x3)].size() *\n                    mm[make_key(x4)].size();\n\n                rot(u);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<pair<int,int>, pair<int,int> > pt;\n\nconst int MOD = 1e9 + 7;\nconst int C = 1001;\n\nunordered_map<ll,int> ma;\n\nll hsh(int a, int b, int c, int d)\n{\n\tll x = ll(a)*ll(C)*ll(C)*ll(C);\n\tx += ll(b)*ll(C)*ll(C);\n\tx += ll(c)*ll(C);\n\tx += d;\n\treturn x;\n}\n\nvoid cyc(int &a, int &b, int &c, int &d)\n{\n\tswap(a, b);\n\tswap(a, c);\n\tswap(a, d);\n}\n\nvector<pt> vec;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tvec.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> vec[i].fi.fi >> vec[i].fi.se >> vec[i].se.fi >> vec[i].se.se;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a = vec[i].fi.fi; int b = vec[i].fi.se;\n\t\tint c = vec[i].se.fi; int d = vec[i].se.se;\n\t\tma[hsh(a,b,c,d)]++;\n\t\tma[hsh(b,c,d,a)]++;\n\t\tma[hsh(c,d,a,b)]++;\n\t\tma[hsh(d,a,b,c)]++;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i == j) continue;\n\t\t\tint xa, xb, xc, xd, ya, yb, yc, yd;\n\t\t\txa = vec[i].fi.fi; xb = vec[i].fi.se; xc = vec[i].se.fi; xd = vec[i].se.se;\n\t\t\tya = vec[j].fi.fi; yb = vec[j].fi.se; yc = vec[j].se.fi; yd = vec[j].se.se;\n\t\t\tswap(xb,xd);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint a,b,c,d;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\tll h1 = hsh(ya,yd,xd,xa);\n\t\t\t\tll h2 = hsh(yd,yc,xc,xd);\n\t\t\t\tll h3 = hsh(yc,yb,xb,xc);\n\t\t\t\tll h4 = hsh(yb,ya,xa,xb);\n\t\t\t\t//set<ll> ss;\n\t\t\t\t//ss.insert(h1); ss.insert(h2); ss.insert(h3); ss.insert(h4);\n\t\t\t\tunordered_map<ll,int> ss;\n\t\t\t\t////cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\tll tmp = 0;\n\t\t\t\t\n\t\t\t\t\t////cerr<<w<<' '<<x<<' '<<y<<' '<<z<<'\\n';\n\t\t\t\t\tll x1 = ma[h1];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tll x2 = ma[h2];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tll x3 = ma[h3];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[y][h3]--; ma[y][h2]--; ma[y][h1]--; ma[y][h4]--;\n\t\t\t\t\tll x4 = ma[h4];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[w][h1]++; ma[x][h2]++; ma[y][h3]++;\n\t\t\t\t\t//ma[w][h1]++; ma[w][h2]++; ma[w][h3]++; ma[w][h4]++;\n\t\t\t\t\t//ma[x][h2]++; ma[x][h1]++; ma[x][h3]++; ma[x][h4]++;\n\t\t\t\t\t//ma[y][h3]++; ma[y][h2]++; ma[y][h1]++; ma[y][h4]++;\n\t\t\t\t\tx1=max(x1,0LL); x2=max(x2,0LL); x3=max(x3,0LL); x4 = max(x4,0LL);\n\t\t\t\t\ttmp += (x1*x2*x3*x4);\n\n\t\t\t\t/*\n\t\t\t\ttmp*=ma[h1];\n\t\t\t\tma[h1]--;\n\t\t\t\ttmp*=ma[h2];\n\t\t\t\tma[h2]--;\n\t\t\t\ttmp*=ma[h3];\n\t\t\t\tma[h3]--;\n\t\t\t\ttmp*=ma[h4];\n\t\t\t\tma[h1]++; ma[h2]++; ma[h3]++;\n\t\t\t\t*/\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<xa<<' '<<xb<<' '<<xc<<' '<<xd<<' '<<ya<<' '<<yb<<' '<<yc<<' '<<yd<<' '<<tmp<<'\\n';\n\t\t\t\tans += tmp;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\tcyc(ya,yb,yc,yd);\n\t\t\t}\n\t\t}\n\t}\n\t//assert(ans%6==0);\n\tans/=6;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nunordered_map<ll, int>cnt;\nint g2;\nll calc (int *a) {\n\tll ans = 0; g2 = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tll tmp = 0;\n\t\tfor (int j = 0; j < 4; ++j) tmp = tmp << 10 | a[(i + j) & 3];\n\t\tif (tmp > ans) ans = tmp, g2 = 1;\n\t\telse if (tmp == ans) ++g2;\n\t}\n\treturn ans;\n}\n\nconst int N = 404;\n\nint p[N][4], n, tt[4], v, ans;\nll a[4];\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) scanf(\"%d\", &p[i][j]), ++p[i][j];\n\t\t++cnt[calc(p[i])];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\t\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\n\t\t\t--cnt[calc(p[i])]; --cnt[calc(p[j])];\n\t\t\t\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\n\t\t\t\tv = 1;\n\t\t\t\tfor (int t = 0; t < 4; ++t) {\n\t\t\t\t\ttt[0] = p[i][(t + 1) & 3];\n\t\t\t\t\ttt[1] = p[i][t];\n\t\t\t\t\ttt[2] = p[j][(k + 5 - t) & 3];\n\t\t\t\t\ttt[3] = p[j][(k - t + 4) & 3];\n\t\t\t\t\ta[t] = calc(tt);\n\t\t\t\t\tv *= g2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int t = 0; t < 4; ++t) v *= cnt[a[t]]--;\n\t\t\t\t\n\t\t\t\tfor (int t = 0; t < 4; ++t) ++cnt[a[t]];\n\t\t\t\t\n\t\t\t\tans += v;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t++cnt[calc(p[i])]; ++cnt[calc(p[j])];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans / 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nusing T = array<int, 4>;\n\nint n;\nT c[400];\nmap<T, int> d;\n\nT rotate(T a){\n  rep(i, 3) swap(a[i], a[i + 1]);\n  return a;\n}\n\nT normalize(T a){\n  T res = a;\n  rep(i, 4){\n    chmin(res, a);\n    a = rotate(a);\n  }\n  return res;\n}\n\nint main(){\n  cin >> n;\n  rep(i, n) rep(j, 4) cin >> c[i][j];\n  rep(i, n) c[i] = normalize(c[i]);\n  rep(i, n){\n    d[normalize(c[i])] = 0;\n    rep(j, 4){\n      if (c[i] == normalize(c[i])) d[normalize(c[i])]++;\n      c[i] = rotate(c[i]);\n    }\n  }\n\n  map<T, int> s;\n  rep(i, n) s[c[i]]++;\n\n  ll res = 0;\n\n  rep(i, n) rep(j, i){\n    s[c[i]]--;\n    s[c[j]]--;\n    \n    rep(k, 4){\n      T b[4] = {\n        normalize({c[i][1], c[i][0], c[j][1], c[j][0]}),\n        normalize({c[i][2], c[i][1], c[j][0], c[j][3]}),\n        normalize({c[i][3], c[i][2], c[j][3], c[j][2]}),\n        normalize({c[i][0], c[i][3], c[j][2], c[j][1]})\n      };\n\n      ll t = 1;\n      rep(l, 4){\n        t *= s[b[l]] * d[b[l]];\n        s[b[l]]--;\n      }\n\n      res += t;\n\n      rep(l, 4) s[b[l]]++;\n      c[j] = rotate(c[j]);\n    }\n    \n    s[c[i]]++;\n    s[c[j]]++;\n  }\n\n  cout << res / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const N = 1234;\n\nlong long f[N];\nint c[N][4];\nlong long dp[42];\nint can[42];\nlong long cr[N][4];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", c[i] + j);\n    }\n    for (int rot = 0; rot < 4; rot++) {\n      long long z = 0;\n      for (int e = 0; e < 4; e++) {\n        z = z * 1000 + c[i][(e + rot) & 3];\n      }\n      cr[i][rot] = z;\n    }\n  }\n  long long ans = 0;\n  for (int first = 0; first < n; first++) {\n    for (int back = first + 1; back < n; back++) {\n      for (int rb = 0; rb < 4; rb++) {\n        for (int i = 0; i < 4; i++) {\n          f[i] = c[first][(i + 1) & 3];\n          f[i] = f[i] * 1000 + c[first][i];\n          f[i] = f[i] * 1000 + c[back][(-i + rb + 1) & 3];\n          f[i] = f[i] * 1000 + c[back][(-i + rb) & 3];\n        }\n        for (int i = 0; i < 1 << 4; i++) dp[i] = 0;\n        dp[0] = 1;\n        for (int i = first + 1; i < n; i++) {\n          if (i == back) continue;\n          for (int j = 0; j < 4; j++) {\n            can[j] = 0;\n            for (int rot = 0; rot < 4; rot++) {\n              if (f[j] == cr[i][rot]) {\n                ++can[j];\n              }\n            }\n          }\n          // for (int mask = 15; mask >= 0; mask--) {\n          //   for (int j = 0; j < 4; j++) {\n          //     if (can[j] == 0 || ((mask >> j) & 1) == 0) continue;\n          //     dp[mask] += dp[mask & ~(1 << j)] * can[j];\n          //   }\n          // }\n          dp[15] += dp[14] * can[0];\n          dp[15] += dp[13] * can[1];\n          dp[15] += dp[11] * can[2];\n          dp[15] += dp[7] * can[3];\n          dp[14] += dp[12] * can[1];\n          dp[14] += dp[10] * can[2];\n          dp[14] += dp[6] * can[3];\n          dp[13] += dp[12] * can[0];\n          dp[13] += dp[9] * can[2];\n          dp[13] += dp[5] * can[3];\n          dp[12] += dp[8] * can[2];\n          dp[12] += dp[4] * can[3];\n          dp[11] += dp[10] * can[0];\n          dp[11] += dp[9] * can[1];\n          dp[11] += dp[3] * can[3];\n          dp[10] += dp[8] * can[1];\n          dp[10] += dp[2] * can[3];\n          dp[9] += dp[8] * can[0];\n          dp[9] += dp[1] * can[3];\n          dp[8] += dp[0] * can[3];\n          dp[7] += dp[6] * can[0];\n          dp[7] += dp[5] * can[1];\n          dp[7] += dp[3] * can[2];\n          dp[6] += dp[4] * can[1];\n          dp[6] += dp[2] * can[2];\n          dp[5] += dp[4] * can[0];\n          dp[5] += dp[1] * can[2];\n          dp[4] += dp[0] * can[2];\n          dp[3] += dp[2] * can[0];\n          dp[3] += dp[1] * can[1];\n          dp[2] += dp[0] * can[1];\n          dp[1] += dp[0] * can[0];\n        }\n        ans += dp[15];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#define ll long long\nusing namespace std;\nconst int N=405;\nint n,i,j,k,x,c[N][4];ll a[N],v[4],ans;\nll num(int a,int b,int c,int d){\n\treturn ((ll)a<<30)+(b<<20)+(c<<10)+d;\n}\nmap<ll,int> mp;\nvoid add(ll x,int k){\n\tfor (int i=4;i--;x=x>>10|(x&1023)<<30) mp[x]+=k;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;add(a[i],1),i++) for (j=0;j<4;j++)\n\t\tscanf(\"%d\",&c[i][j]),a[i]=(a[i]<<10)+c[i][j];\n\tfor (i=1;i<=n-5;i++)\n\t\tfor (add(a[i],-1),j=i+1;j<=n;j++){\n\t\t\tadd(a[j],-1);\n\t\t\tfor (k=4;k--;){\n\t\t\t\tv[0]=num(c[i][0],c[j][k],c[j][(k+3)&3],c[i][1]);\n\t\t\t\tv[1]=num(c[i][1],c[j][(k+3)&3],c[j][(k+2)&3],c[i][2]);\n\t\t\t\tv[2]=num(c[i][2],c[j][(k+2)&3],c[j][(k+1)&3],c[i][3]);\n\t\t\t\tv[3]=num(c[i][3],c[j][(k+1)&3],c[j][k],c[i][0]);\n\t\t\t\tif (!mp[v[0]]||!mp[v[1]]||!mp[v[2]]||!mp[v[3]]) continue;\n\t\t\t\tll res=1;\n\t\t\t\tfor (x=4;x--;) res*=mp[v[x]],add(v[x],-1);\n\t\t\t\tfor (ans+=res,x=4;x--;) add(v[x],1);\n\t\t\t}\n\t\t \tadd(a[j],1);\n\t\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (short i = a; i <= b; ++ i) \nconst short N = 1005 ; \n\nconst short turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <short>, short> Count ;\nshort col[N][5], n ;\n\ninline void getmin(vector <short> &p) {\n\tvector <short> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nmap <vector <short>, short>  mul ;\n\nint main() {\n\tcin >> n ;\n\trep(i, 1, n) rep(j, 0, 3) cin >> col[i][j] ;\n\trep(i, 1, n) {\n\t\tvector <short> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\t++ Count[ret] ;\n\t\tshort tot = 0 ; \n\t\tvector <short> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0, sum ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\tvector <short> ret ;\n\t\trep(k, 0, 3) ret.push_back(col[i][k]) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <short> ret ;\n\t\t\tmap <vector <short>, short> used ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\tvector <short> U ;\n\t\t\t\trep(q, 0, 3) U.push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(U) ;\n\t\t\t\tsum *= (ll) mul[U] * (Count[U] - used[U]) ;\n\t\t\t\t++ used[U] ;\n\t\t\t}\n\t\t\tans += sum ;\n\t\t}\n\t\trep(k, 0, 3) ret[k] = col[i][k] ;\n\t\t++ Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ;\n\t\t++ Count[ret] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<vector<ll> , vector<ll> > vp;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nvector<ll> reg(const vector<ll> &a){\n  vector<ll> res=a;\n  repl(d,1,4){\n    vector<ll> b;\n    rep(i,4)b.push_back(a[(i+d)%4]);\n    minch(res,b);\n  }\n  return res;\n}\n\nll vcnt(const vector<ll> &a){\n  if(a[0]==a[2]&&a[1]==a[3]){\n    if(a[0]==a[1])return 4;\n    else return 2;\n  }else return 1;\n}\n\nll n;\nvector<ll> c[404][2];\nmap<vector<ll> ,ll> cnt;\n\nint main(){\n\tcin>>n;\n  ll res=0;\n  rep(i,n){\n    rep(j,4){\n      ll cc;\n      cin>>cc;\n      c[i][0].push_back(cc);\n    }\n    c[i][0]=reg(c[i][0]);\n    c[i][1]=c[i][0];\n    reverse(all(c[i][1]));\n    c[i][1]=reg(c[i][1]);\n    cnt[c[i][0]]++;\n  }\n  rep(i,n){\n    cnt[c[i][0]]--;\n    repl(j,i+1,n){\n      cnt[c[j][0]]--;\n      rep(d,4){\n        vector<ll> vi,vj;\n        rep(k,4)vj.push_back(c[j][1][(k+d)%4]);\n        vi=c[i][0];\n        map<vector<ll> ,ll> sccnt;\n        rep(k,4){\n          vector<ll> sc;\n          sc.push_back(vi[k]);\n          sc.push_back(vj[k]);\n          sc.push_back(vj[(k+1)%4]);\n          sc.push_back(vi[(k+1)%4]);\n          sc=reg(sc);\n          sccnt[sc]++;\n        }\n        ll sum=1;\n        for(auto it : sccnt){\n          rep(k,it.se)sum*=(cnt[it.fi]-k)*vcnt(it.fi);\n        }\n        res+=max(0LL,sum);\n      }\n      cnt[c[j][0]]++;\n    }\n    cnt[c[i][0]]++;\n  }\n  cout<<res/3<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<pair<int,int>, pair<int,int> > pt;\n\nconst int MOD = 1e9 + 7;\nconst int C = 1001;\n\nunordered_map<ll,int> ma;\n\nll hsh(int a, int b, int c, int d)\n{\n\tll x = ll(a)*ll(C)*ll(C)*ll(C);\n\tx += ll(b)*ll(C)*ll(C);\n\tx += ll(c)*ll(C);\n\tx += d;\n\treturn x;\n}\n\nvoid cyc(int &a, int &b, int &c, int &d)\n{\n\tswap(a, b);\n\tswap(a, c);\n\tswap(a, d);\n}\n\nvector<pt> vec;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tvec.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> vec[i].fi.fi >> vec[i].fi.se >> vec[i].se.fi >> vec[i].se.se;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a = vec[i].fi.fi; int b = vec[i].fi.se;\n\t\tint c = vec[i].se.fi; int d = vec[i].se.se;\n\t\tma[hsh(a,b,c,d)]++;\n\t\tma[hsh(b,c,d,a)]++;\n\t\tma[hsh(c,d,a,b)]++;\n\t\tma[hsh(d,a,b,c)]++;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i == j) continue;\n\t\t\tint xa, xb, xc, xd, ya, yb, yc, yd;\n\t\t\txa = vec[i].fi.fi; xb = vec[i].fi.se; xc = vec[i].se.fi; xd = vec[i].se.se;\n\t\t\tya = vec[j].fi.fi; yb = vec[j].fi.se; yc = vec[j].se.fi; yd = vec[j].se.se;\n\t\t\tswap(xb,xd);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint a,b,c,d;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\tll h1 = hsh(ya,yd,xd,xa);\n\t\t\t\tll h2 = hsh(yd,yc,xc,xd);\n\t\t\t\tll h3 = hsh(yc,yb,xb,xc);\n\t\t\t\tll h4 = hsh(yb,ya,xa,xb);\n\t\t\t\t//set<ll> ss;\n\t\t\t\t//ss.insert(h1); ss.insert(h2); ss.insert(h3); ss.insert(h4);\n\t\t\t\tunordered_map<ll,int> ss;\n\t\t\t\t////cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\tll tmp = 0;\n\t\t\t\t\n\t\t\t\t\t////cerr<<w<<' '<<x<<' '<<y<<' '<<z<<'\\n';\n\t\t\t\t\tll x1 = ma[h1];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unordered_map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tll x2 = ma[h2];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unordered_map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tll x3 = ma[h3];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unordered_map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[y][h3]--; ma[y][h2]--; ma[y][h1]--; ma[y][h4]--;\n\t\t\t\t\tll x4 = ma[h4];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unordered_map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unordered_map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unordered_map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[w][h1]++; ma[x][h2]++; ma[y][h3]++;\n\t\t\t\t\t//ma[w][h1]++; ma[w][h2]++; ma[w][h3]++; ma[w][h4]++;\n\t\t\t\t\t//ma[x][h2]++; ma[x][h1]++; ma[x][h3]++; ma[x][h4]++;\n\t\t\t\t\t//ma[y][h3]++; ma[y][h2]++; ma[y][h1]++; ma[y][h4]++;\n\t\t\t\t\tx1=max(x1,0LL); x2=max(x2,0LL); x3=max(x3,0LL); x4 = max(x4,0LL);\n\t\t\t\t\ttmp += (x1*x2*x3*x4);\n\n\t\t\t\t/*\n\t\t\t\ttmp*=ma[h1];\n\t\t\t\tma[h1]--;\n\t\t\t\ttmp*=ma[h2];\n\t\t\t\tma[h2]--;\n\t\t\t\ttmp*=ma[h3];\n\t\t\t\tma[h3]--;\n\t\t\t\ttmp*=ma[h4];\n\t\t\t\tma[h1]++; ma[h2]++; ma[h3]++;\n\t\t\t\t*/\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<xa<<' '<<xb<<' '<<xc<<' '<<xd<<' '<<ya<<' '<<yb<<' '<<yc<<' '<<yd<<' '<<tmp<<'\\n';\n\t\t\t\tans += tmp;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\tcyc(ya,yb,yc,yd);\n\t\t\t}\n\t\t}\n\t}\n\t//assert(ans%6==0);\n\tans/=6;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define ppp pair<pii,pii>\n\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:2\n*Problem:E - AtCoDeerくんと立方体づくり / Building Cubes with AtCoDeer\n*Date:2018-10-21\n*Algorithm:My Brute Force\n*Stats:Unknown*/\n\nbool debug=false;\n\nint n;\nppp a[405];\nll ans;\nvector<ppp> has;\nmap<ppp,int> cnt;\n\ninline ppp bp(int a,int b,int c,int d){\n\treturn make_pair(make_pair(a,b),make_pair(c,d));\n}\n\nvoid Ins(int xa,int xb,int xc,int xd){\n\tcnt[bp(xa,xb,xc,xd)]++;\n\tcnt[bp(xb,xc,xd,xa)]++;\n\tcnt[bp(xc,xd,xa,xb)]++;\n\tcnt[bp(xd,xa,xb,xc)]++;\n}\n\nint cntsame(ppp a,ppp b){\n\tint ba=b.first.first,bb=b.first.second,bc=b.second.first,bd=b.second.second;\n\tint ret=0;\n\tif(a==bp(ba,bb,bc,bd)) ret++;\n\tif(a==bp(bb,bc,bd,ba)) ret++;\n\tif(a==bp(bc,bd,ba,bb)) ret++;\n\tif(a==bp(bd,ba,bb,bc)) ret++;\n\treturn ret;\n}\n\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint x1,x2,x3,x4;\n\t\tcin>>x1>>x2>>x3>>x4;\n\t\ta[i]=bp(x1,x2,x3,x4);\n\t}\n\t\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=0;j<has.size();j++){\n\t\t\tppp ano=has[j];\n\t\t\t\n\t\t\tint ca=ano.first.first,cb=ano.first.second,cc=ano.second.first,cd=ano.second.second;\n\t\t\t\n\t\t\tppp b1=bp(a[i].first.first,a[i].first.second,cb,ca);\n\t\t\tppp b2=bp(a[i].first.second,a[i].second.first,cc,cb);\n\t\t\tppp b3=bp(a[i].second.first,a[i].second.second,cd,cc);\n\t\t\tppp b4=bp(a[i].second.second,a[i].first.first,ca,cd);\n\t\t\t\n\t\t\tll ret=1;\n\t\t\tret*=cnt[b1]-cntsame(ano,b1);\n\t\t\tret*=cnt[b2]-cntsame(b1,b2)-cntsame(ano,b2);\n\t\t\tret*=cnt[b3]-cntsame(b1,b3)-cntsame(b2,b3)-cntsame(ano,b3);\n\t\t\tret*=cnt[b4]-cntsame(b1,b4)-cntsame(b2,b4)-cntsame(b3,b4)-cntsame(ano,b4);\n\t\t\t\n\t\t\tans+=ret;\n\t\t}\n\t\t\n\t\tint xa=a[i].first.first,xb=a[i].second.second,xc=a[i].second.first,xd=a[i].first.second;\n\t\t\n\t\tIns(xa,xb,xc,xd);\n\t\thas.push_back(bp(xa,xb,xc,xd));\n\t\thas.push_back(bp(xb,xc,xd,xa));\n\t\thas.push_back(bp(xc,xd,xa,xb));\n\t\thas.push_back(bp(xd,xa,xb,xc));\n\t\t\n\t}\n\t\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile a, tile b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) {return a.color[i] < b.color[i];}\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) {tmp.color[i] = t.color[i];}\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) {t = comp;}\n    for (int j = 0; j < 4; ++j) {tmp.color[j] = comp.color[j];}\n  }\n}\n\nbool same(tile a, tile b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= (a.color[i] == b.color[i]);\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) {ub = mid;}\n    else {lb = mid;}\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(s,ts[mid])) {ub = mid;}\n    else {lb = mid;}\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 4; ++j) {\n      cin >> t[i].color[j];\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {regulation(t[i]);}\n  sort(t, t+N, comp_tile);\n\n\n  ull ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) {top.color[k] = t[i].color[k];}\n        for (int k = 0; k < 4; ++k) {bottom.color[k] = t[j].color[k];}\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) {tmp1.color[l] = bottom.color[l];}\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) {regulation(sides[l]);}\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) {tmp.color[n] = sides[m].color[n];}\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) ++symmetry_count[m];\n              for (int l = 0; l < 4; ++l) {tmp.color[l] = cmp.color[l];}\n            }\n          }\n\n          ull tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) {\n              if (same(sides[n],sides[m])) {++x;}\n            }\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= (match_count[m] - x);\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n/*==========================================================*/\n/*    Template ver 2017-0720    |    Created by JollyBee    */\n/* DOMINUS pascit me, et nihil mihi deerit (Psalmorum 23:1) */\n/*==========================================================*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<pii> vii;\nconst double EPS=(double)1e-9;\nconst double PI=(double)acos(-1.0);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define REPP(i,l,r,c) for(int i=l;i<=r;i+=c)\n#define REP(i,l,r) REPP(i,l,r,1)\n#define FORD(i,n) for(int i=n-1;i>=0;i--)\n#define REVV(i,l,r,c) for(int i=l;i>=r;i-=c)\n#define REV(i,l,r) REVV(i,l,r,1)\n//random\nint irand(int lo, int hi){\n    return (((double)rand())/(RAND_MAX+1.0)) * (hi-lo+1) + lo;\n}\n//ll to string\nstring toString(ll x) {\n    stringstream ss;\n    ss << x;\n    return ss.str();\n}\n//string to ll\nll toNumber(string S) {\n    ll ret;\n    sscanf(S.c_str(),\"%lld\",&ret);\n    return ret;\n}\n// std::fill(start, end, value);\n// for(auto it: DS){}\n\nconst int INF=(int)2e9;\nconst ll MOD=(ll)1e9+7;\n/*==========================================================*/\n/*                     END OF TEMPLATE                      */\n/* DOMINUS pascit me, et nihil mihi deerit (Psalmorum 23:1) */\n/*==========================================================*/\n\ntypedef pair<pii,pii> square;\n\nsquare rotate(square a){\n    return mp(mp(a.fi.se,a.se.fi), mp(a.se.se, a.fi.fi));\n}\nsquare normalize(square a){\n    square res = a;\n    FOR(i,4) res = min(res, a=rotate(a));\n    return res;\n}\nint cnt_rotate(square a){\n    int res = 0; square b = a;\n    FOR(i,4) res += (a == (b=rotate(b)));\n    return res;\n}\n\nvector<square> get_list(square a, square b){\n    vector<square> res; res.clear();\n    res.pb(normalize(mp(mp(a.fi.fi,b.fi.se), mp(b.fi.fi,a.fi.se))));\n    res.pb(normalize(mp(mp(a.fi.se,b.fi.fi), mp(b.se.se,a.se.fi))));\n    res.pb(normalize(mp(mp(a.se.fi,b.se.se), mp(b.se.fi,a.se.se))));\n    res.pb(normalize(mp(mp(a.se.se,b.se.fi), mp(b.fi.se,a.fi.fi))));\n    return res;\n}\n\nsquare dat[405];\nmap<square,int> cnt;\n\nint main(){\n    cnt.clear();\n    //\n    int n; scanf(\"%d\", &n);\n    REP(i,1,n){\n        scanf(\"%d %d\", &dat[i].fi.fi, &dat[i].fi.se);\n        scanf(\"%d %d\", &dat[i].se.fi, &dat[i].se.se);\n        dat[i] = normalize(dat[i]);\n        //\n        if(cnt.find(dat[i]) == cnt.end()) cnt[dat[i]] = 0;\n        cnt[dat[i]] += 1;\n    }\n    //\n    ll res = 0;\n    REP(i,1,n) REP(j,1,n) if(i != j){\n        square a = dat[i], b = dat[j];\n        //\n        cnt[a] -= 1; cnt[b] -= 1;\n        FOR(i,4){\n            vector<square> datt = get_list(a, b=rotate(b));\n            // count\n            ll ret = 1;\n            for(square x: datt){\n                ret *= (ll)cnt_rotate(x) * (ll)max(0, cnt[x]);\n                cnt[x] -= 1;\n            }\n            for(square x: datt) cnt[x] += 1;\n            //\n            res += ret;\n        }\n        assert(b == dat[j]);\n        cnt[a] += 1; cnt[b] += 1;\n    }\n    //\n    printf(\"%lld\\n\", res / (ll)6);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n\nvoid shift(vector<int> &a){\n    rotate(a.begin(),a.begin()+1,a.end());\n};\n\nvoid normalize(vector<int>& a){\n    auto amin=a;\n    rep(i,0,4){\n        amin=min(amin,a);\n        shift(a);\n    }\n    a=amin;\n}\n\ni64 encode(vector<int>& a){\n    i64 res=0;\n    rep(i,0,4){\n        res*=1000;\n        res+=a[i];\n    }\n    return res;\n}\n\nvector<int> reverse(vector<int> &a){\n    auto b=a;\n    swap(b[0],b[1]);\n    swap(b[3],b[2]);\n    return b;\n}\n\nint f(vector<int>& a){\n    if(a[0]==a[1] and a[1]==a[2] and a[2]==a[3]) return 4;\n    if(a[0]==a[2] and a[1]==a[3]) return 2;\n    return 1;\n}\n\nvoid input(int& N,vector<vector<int>> &C){\n    cin >> N;\n    C.resize(N);\n    rep(i,0,N){\n        C[i].resize(4);\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        normalize(C[i]);\n    }\n}\n\nvoid solve(){\n    int N;\n    vector<vector<int>> C;\n    input(N,C);\n\n    map<i64,i64> count[5]; //1,2,4\n    rep(i,0,N) ++count[f(C[i])][encode(C[i])];\n \n    auto make_sides=[&](int i,int j){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i][(k+1)%4];\n            sides[k][1]=C[i][k];\n            sides[k][2]=C[j][k];\n            sides[k][3]=C[j][(k+1)%4];\n        }\n        return sides;\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        --count[f(C[i])][encode(C[i])];\n        rep(j,i+1,N){\n            --count[f(C[j])][encode(C[j])];\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto sides=make_sides(i,j);\n                for(auto &side:sides) normalize(side);\n                i64 tmp1=1;\n                rep(i_,0,4){\n                    i64 tmp2=count[f(sides[i_])][encode(sides[i_])];\n                    rep(j_,0,i_) if(encode(sides[j_])==encode(sides[i_])) --tmp2;\n                    tmp1*=tmp2*f(sides[i_]);\n                }\n                ans+=tmp1;\n                shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n            ++count[f(C[j])][encode(C[j])];\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef deque<int> D;\n\nvoid rot(D& d) {\n\td.push_back(d[0]);\n\td.pop_front();\n}\n\nD f(D d) {\n\tD ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\trot(d);\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint overlap(D d) {\n\tint ret = 1;\n\tD t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\trot(d);\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\nll P(int n, int k) {\n\tll ret = 1;\n\tfor(int i = n - k + 1; i <= n; i++) ret *= i;\n\treturn ret;\n}\n\nD C[400];\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tmap<D, int> m, cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tC[i] = D(4);\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tcin >> C[i][j];\n\t\t}\n\t\tC[i] = f(C[i]);\n\t\tm[C[i]]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tD d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\tD d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<D, int> t;\n\t\t\t\tt[f(D({ d1[1], d1[0], d2[1], d2[0] }))]++;\n\t\t\t\tt[f(D({ d1[0], d1[3], d2[2], d2[1] }))]++;\n\t\t\t\tt[f(D({ d1[3], d1[2], d2[3], d2[2] }))]++;\n\t\t\t\tt[f(D({ d1[2], d1[1], d2[0], d2[3] }))]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P(m[p.first], p.second);\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\trot(d1);\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> color[505];\nmap<vector<int>, int> has;\nint jiao[8];\nint use[4][4]={\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid add(vector<int> color)\n{\n  for (int i=0; i<4; i++)\n  {\n      has[color]++;\n      rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid reduce(vector<int> color)\n{\n\n    for (int i=0; i<4; i++)\n    {\n        has[color]--;\n        rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid dfs(int dep,int& ans,int res=1)\n{\n    if (dep==4) ans+=res;\n    else\n    {\n        vector<int> tmp(4);\n        for (int i=0; i<4; i++)\n            tmp[i]=jiao[use[dep][i]];\n        if (has.count(tmp))\n        {\n            int cnt=has[tmp];\n            reduce(tmp);\n            dfs(dep+1,ans,res*cnt);\n            add(tmp);\n        }\n    }\n}\n\nint solve(int a,int b)\n{\n    for (int i=0; i<4; i++)\n    {\n        jiao[i]=color[a][i];\n        jiao[i+4]=color[b][i];\n    }\n    int ans=0;\n    for (int i=0; i<4; i++)\n    {\n        dfs(0,ans);\n        rotate(jiao+4,jiao+5,jiao+6);\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++)\n    {\n        color[i].resize(4);\n        for (int j=0; j<4; j++)\n        {\n            scanf(\"%d\",&color[i][j]);\n        }\n        add(color[i]);\n    }\n    int ans1=0;\n    for (int i=0; i<n; i++)\n    {\n      for (int j=i+1; j<n; j++)\n      {\n          reduce(color[i]);\n          reduce(color[j]);\n          ans1+=solve(i,j);\n          add(color[i]);\n          add(color[j]);\n      }\n      reduce(color[i]);\n    }\n    printf(\"%d\\n\",ans1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n\nusing namespace std;\n\nstruct cube{\n\tint a,b,c,d;\n\tcube():a(0),b(0),c(0),d(0){}\n\tcube(int m,int n,int p,int q):a(m),b(n),c(p),d(q){}\n\tfriend bool operator<(const cube &cb1,const cube &cb2){if(cb1.a!=cb2.a)return cb1.a<cb2.a;if(cb1.b!=cb2.b)return cb1.b<cb2.b;if(cb1.c!=cb2.c)return cb1.c<cb2.c;return cb1.d<cb2.d;}\n\tvoid rotate(){int t=a;a=b,b=c,c=d,d=t;}\n};\n\nclass FastFileReader{char buffer[10000001];char *h;int len;inline char gchar(){return *h++;}inline bool validdigit(char c){return c>='0' && c<='9';}public:inline void init(){len=fread(buffer,1,10000000,stdin);h=buffer;}inline int nextint(){register int i=0;register char c;do c=gchar();while(!validdigit(c));do{i=i*10+c-48;c=gchar();}while(validdigit(c));return i;}inline int nextsigned(){register int i=0,f=1;register char c;do{c=gchar();if(c=='-')f=-1;}while(!validdigit(c));do{i=i*10+c-48;c=gchar();}while(validdigit(c));return i*f;}inline long long nextlonglong(){register long long i=0;register char c;do c=gchar();while(!validdigit(c));do{i=i*10+c-48;c=gchar();}while(validdigit(c));return i;}inline long long nextsignedlonglong(){register long long i=0,f=1;register char c;do{c=gchar();if(c=='-')f=-1;}while(!validdigit(c));do{i=i*10+c-48;c=gchar();}while(validdigit(c));return i*f;}inline char nextchar(){register char c;do c=gchar();while(c<=' ');return c;}};\n\nFastFileReader fs;\nmap<cube,int> m;\nint n;\nlong long ans;\ncube c[401];\n\nvoid insert(cube c,int x){for(int i=1;i<=4;++i)m[c]+=x,c.rotate();}\n\nint main(){\n\tfs.init();n=fs.nextint();for(int i=1;i<=n;++i)c[i].a=fs.nextint(),c[i].b=fs.nextint(),c[i].c=fs.nextint(),c[i].d=fs.nextint(),insert(c[i],1);\n\tfor(int i=1;i<=n;++i){\n\t\tinsert(c[i],-1);\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tinsert(c[j],-1);\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tc[j].rotate();\n\t\t\t\tcube c1(c[i].b,c[i].a,c[j].a,c[j].d),c2(c[i].c,c[i].b,c[j].d,c[j].c),c3(c[i].d,c[i].c,c[j].c,c[j].b),c4(c[i].a,c[i].d,c[j].b,c[j].a);\n\t\t\t\tif(m.count(c1)&&m.count(c2)&&m.count(c3)&&m.count(c4)){long long sum=1ll;sum*=m[c1],insert(c1,-1),sum*=m[c2],insert(c2,-1),sum*=m[c3],insert(c3,-1),ans+=sum*m[c4],insert(c1,1),insert(c2,1),insert(c3,1);}\n\t\t\t}\n\t\t\tinsert(c[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n\n  vector<sq> ord(24,sq(8));\n  {\n    sq a(8);\n    iota(a.begin(),a.end(),0);\n    Int x=0;\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tfor(Int k=0;k<8;k++) ord[x][a[k]]=k;\n\ta=clock(a);\n\tx++;\n      }\n      if(i==0||i==4) a=right(a);\n      else a=front(a);\n    }\n  }\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(8);\n    for(Int i=0;i<24;i++){\n      for(Int k=0;k<8;k++) b[ord[i][k]]=a[k];\n      res+=(a==b);\n      used.emplace(conv(b));\n    }\n    //cout<<res<<endl;\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      if(cnt[w]==0||cnt[x]==0||cnt[y]==0||cnt[z]==0) continue;\n      \n      __int128_t res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n\n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\nint c[444][4],n;\nint num[4][444];\nvoid fd(int*num,int A,int B,int C,int D,int from,int no){\n\tlong long int W = ((((((long long int)A << 10) + B) <<10) + C) <<10) + D;\n\tfor(int i=from+1; i<n; i++){\n\t\tnum[i] = 0;\n\t\tif(i == no)continue;\n\t\tint E = c[i][0], F = c[i][1], G = c[i][2], H = c[i][3];\n\t\tlong long int hash = ((((((long long int)E << 10) + F) <<10) + G) <<10) + H;\n\n\t\tif(hash == W)num[i] ++;\n\t\thash = ((hash & ((1<<30)-1))<<10) + E;\n\t\tif(hash == W)num[i] ++;\n\t\thash = ((hash & ((1<<30)-1))<<10) + F;\n\t\tif(hash == W)num[i] ++;\n\t\thash = ((hash & ((1<<30)-1))<<10) + G;\n\t\tif(hash == W)num[i] ++;\n\t}\n}\nlong long int add(long long int x,long long int y){\n\treturn x+y;\n}\nlong long int sub(long long int x,long long int y){\n\treturn x-y;\n}\nlong long int mul(long long int x,long long int y){\n\treturn x*y;\n}\nint calc(int id1,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i];\n\treturn res;\n}\nint calc(int id1,int id2,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i]*num[id2][i];\n\treturn res;\n}\nint calc(int id1,int id2,int id3,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i]*num[id2][i]*num[id3][i];\n\treturn res;\n}\nint calc(int id1,int id2,int id3,int id4,int from){\n\tint res=0;\n\tfor(int i=from+1; i<n; i++)\n\t\tres += num[id1][i]*num[id2][i]*num[id3][i]*num[id4][i];\n\treturn res;\n}\nint main(){\n\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<4; j++)\n\t\t\tscanf(\"%d\",&c[i][j]);\n\n\tlong long int res=0;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=i+1; j<n; j++)\n\tfor(int k=0; k<4; k++){\n\t\tint A = c[i][0];\n\t\tint B = c[i][1];\n\t\tint C = c[i][2];\n\t\tint D = c[i][3];\n\t\tint E = c[j][k%4];\n\t\tint F = c[j][(k+1)%4];\n\t\tint G = c[j][(k+2)%4];\n\t\tint H = c[j][(k+3)%4];\n\t\tfd(num[0], B, E, H, C, i, j);\n\t\tfd(num[1], A, D, G, F, i, j);\n\t\tfd(num[2], F, E, B, A, i, j);\n\t\tfd(num[3], H, G, D, C, i, j);\n\n\t\tlong long int A0 = calc(0,i);\n\t\tlong long int A1 = calc(1,i);\n\t\tlong long int A2 = calc(2,i);\n\t\tlong long int A3 = calc(3,i);\n\t\tlong long int A01 = calc(0,1,i);\n\t\tlong long int A02 = calc(0,2,i);\n\t\tlong long int A03 = calc(0,3,i);\n\t\tlong long int A12 = calc(1,2,i);\n\t\tlong long int A13 = calc(1,3,i);\n\t\tlong long int A23 = calc(2,3,i);\n\t\tlong long int A012 = calc(0,1,2,i);\n\t\tlong long int A013 = calc(0,1,3,i);\n\t\tlong long int A023 = calc(0,2,3,i);\n\t\tlong long int A123 = calc(1,2,3,i);\n\t\tlong long int A0123 = calc(0,1,2,3,i);\n\n\t\tres = add(res, mul(mul(A0,A1),mul(A2,A3)));\n\t\tres = sub(res, mul(mul(A2,A3),A01));\n\t\tres = sub(res, mul(mul(A1,A3),A02));\n\t\tres = sub(res, mul(mul(A1,A2),A03));\n\t\tres = sub(res, mul(mul(A0,A3),A12));\n\t\tres = sub(res, mul(mul(A0,A2),A13));\n\t\tres = sub(res, mul(mul(A0,A1),A23));\n\t\tres = add(res, mul(A01,A23));\n\t\tres = add(res, mul(A02,A13));\n\t\tres = add(res, mul(A03,A12));\n\t\tres = add(res, mul(mul(A0,A123),2));\n\t\tres = add(res, mul(mul(A1,A023),2));\n\t\tres = add(res, mul(mul(A2,A013),2));\n\t\tres = add(res, mul(mul(A3,A012),2));\n\t\tres = sub(res, mul(A0123,6));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#define int         int64_t\n#define ii          pair<int,int>\n#define dd          pair<double,double>\n#define vi          vector<int>\n#define pb          push_back\n#define all(x)      (x).begin(), (x).end()\n#define checkBit(v, p)      (v&(1LL << p))\n#define loop(i,a,b) for(int i = a;i < int(b);i++)\n#define x           first\n#define y           second\nusing namespace std;\n\nint inf = 4e18, mod = 1e9+7;\n\nvoid rot(vi& val){\n    rotate(val.begin(),val.begin()+1,val.end());\n}\n\nmap<vi, int> mp;\n\nvoid upd(vi &p, bool f){\n    for(int i=0;i<4;i++, rot(p)){\n        if(f) ++mp[p];\n        else --mp[p];\n    }\n}\n\nint check(vi u, vi d){\n    int ans = 1;\n    vector<vi> rem;\n    reverse(d.begin()+1,d.end());\n    for(int i=0;i<4;i++, rot(u), rot(d)){\n        vi can(4);\n        can[0] = u[1];\n        can[1] = u[0];\n        can[2] = d[0];\n        can[3] = d[1];\n\n        if(mp.find(can) == mp.end()){\n            ans = 0;\n            break;\n        }\n        rem.pb(can);\n        ans *= mp[can];\n        upd(can, false);\n    }\n    for(auto &p:rem) upd(p,true);\n    return ans;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false); cout << fixed <<setprecision(0);\n    int n,sum = 0,hol = 0, num = 1; cin >> n;\n    for(int i=0;i<8;i++) num *=24;\n    vi val(4);\n    for(int i=0;i<n;i++){\n        for(auto &v:val) cin >> v;\n        upd(val,true);\n    }\n    for(auto &up:mp){\n        vi curUp = up.first;\n        int valUp = up.second;\n        upd(curUp,false);\n\n        for(auto &down : mp){\n            int valDown = down.second;\n            vi curDown = down.first;\n            upd(curDown,false);\n            int res = check(curUp,curDown);\n            hol += res * valUp / num * valDown;\n            sum += check(curUp, curDown) * valUp % num * valDown;\n            upd(curDown,true);\n        }\n        upd(curUp,true);\n    }\n    cout << hol * (num / 24) + sum / 24<< endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n#include<iomanip>\n#include<stack>\nusing namespace std;\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nlong long READ(){\n    long long xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nchar one(){\n\tchar ch=getchar();\n\twhile(ch==' '||ch=='\\n')\n\t\tch=getchar();\n\treturn ch;\n}\nconst int maxn=410;\nint N;\nstruct sqr{\n\tint a[4];\n\tsqr(int q=0,int w=0,int e=0,int r=0){\n\t\ta[0]=q,a[1]=w,a[2]=e,a[3]=r;\n\t}\n\tvoid rotate(){\n\t\tint t=a[0];\n\t\tfor(int i=0;i<3;i++)\n\t\t\ta[i]=a[i+1];\n\t\ta[3]=t;\n\t}\n\tbool friend operator<(const sqr&A,const sqr&B){\n\t\tfor(int i=0;i<4;i++)\n\t\t\tif(A.a[i]<B.a[i])\n\t\t\t\treturn 1;\n\t\t\telse if(A.a[i]>B.a[i])\n\t\t\t\treturn 0;\n\t\treturn 0;\n\t}\n}s[maxn];\nmap<sqr,int>mp;\nvoid add(sqr A,int v){\n\tfor(int i=0;i<4;i++){\n\t\tmp[A]+=v;\n\t\tA.rotate();\n\t}\n}\nint main(){\n\t//freopen(\"in\",\"r\",stdin);\n\tN=read();\n\tfor(int i=1;i<=N;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&s[i].a[j]);\n\t\tadd(s[i],1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=N;i++){\n\t\tadd(s[i],-1);\n\t\tfor(int j=i+1;j<=N;j++){\n\t\t\tadd(s[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tlong long now=1;\n\t\t\t\tsqr tmp1(s[j].a[1],s[i].a[0],s[i].a[3],s[j].a[2]);\n\t\t\t\tsqr tmp2(s[i].a[1],s[j].a[0],s[j].a[3],s[i].a[2]);\n\t\t\t\tsqr tmp3(s[j].a[1],s[j].a[0],s[i].a[1],s[i].a[0]);\n\t\t\t\tsqr tmp4(s[i].a[3],s[i].a[2],s[j].a[3],s[j].a[2]);\n\t\t\t\t\n\t\t\t\tnow*=mp[tmp1];add(tmp1,-1);\n\t\t\t\tnow*=mp[tmp2];add(tmp2,-1);\n\t\t\t\tnow*=mp[tmp3];add(tmp3,-1);\n\t\t\t\tnow*=mp[tmp4];add(tmp4,-1);\n\t\t\t\t\n\t\t\t\tadd(tmp1,1);\n\t\t\t\tadd(tmp2,1);\n\t\t\t\tadd(tmp3,1);\n\t\t\t\tadd(tmp4,1);\n\n\t\t\t\ts[j].rotate();\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t\tadd(s[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid shift(vector <int> &now)\n{\n    int first = now[0];\n    now.erase(now.begin());\n    now.push_back(first);\n}\n\nlong long hsh(const vector <int> &now)\n{\n    long long res = 0;\n\n    for (int i = 0; i < 4; i++) {\n        res = res * 1000 + now[i];\n    }\n    return res;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    map <long long, int> cnt;\n    vector <vector <int> > A(n, vector <int>(4));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) {\n            cin >> A[i][j];\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            cnt[hsh(A[i])]++;\n            shift(A[i]);\n        }\n    }\n    long long res = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int k = 0; k < 4; k++) {\n            cnt[hsh(A[i])]--;\n            shift(A[i]);\n        }\n\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 0; k < 4; k++) {\n                cnt[hsh(A[j])]--;\n                shift(A[j]);\n            }\n            reverse(A[j].begin(), A[j].end());\n\n            for (int sh = 0; sh < 4; sh++) {\n                long long add = 1;\n                map <long long, int> cross;\n\n                for (int k = 0; k < 4; k++) {\n                    vector <int> now = {A[i][k], A[j][k], A[j][(k + 1) % 4], A[i][(k + 1) % 4]};\n                    add *= cnt[hsh(now)];\n\n                    for (int x = 0; x < 4; x++) {\n                        if (!cross.count(hsh(now))) {\n                            cross[hsh(now)] = cnt[hsh(now)];\n                        }\n                        cnt[hsh(now)] -= 1;\n                        shift(now);\n                    }\n                }\n                res += add;\n\n                for (auto p: cross) {\n                    cnt[p.first] = p.second;\n                }\n                shift(A[j]);\n            }\n            reverse(A[j].begin(), A[j].end());\n\n            for (int k = 0; k < 4; k++) {\n                cnt[hsh(A[j])]++;\n                shift(A[j]);\n            }\n        }\n    }\n    cout << res << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n#include<iomanip>\n#include<stack>\nusing namespace std;\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nlong long READ(){\n    long long xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nchar one(){\n\tchar ch=getchar();\n\twhile(ch==' '||ch=='\\n')\n\t\tch=getchar();\n\treturn ch;\n}\nconst int maxn=410;\nint N;\nstruct sqr{\n\tint a[4];\n\tsqr(int q=0,int w=0,int e=0,int r=0){\n\t\ta[0]=q,a[1]=w,a[2]=e,a[3]=r;\n\t}\n\tvoid rotate(){\n\t\tint t=a[0];\n\t\tfor(int i=0;i<3;i++)\n\t\t\ta[i]=a[i+1];\n\t\ta[3]=t;\n\t}\n\tbool friend operator<(const sqr&A,const sqr&B){\n\t\tfor(int i=0;i<4;i++)\n\t\t\tif(A.a[i]<B.a[i])\n\t\t\t\treturn 1;\n\t\t\telse if(A.a[i]>B.a[i])\n\t\t\t\treturn 0;\n\t\treturn 0;\n\t}\n}s[maxn];\nmap<sqr,int>mp;\ninline void add(sqr A,int v){\n\tfor(int i=0;i<4;i++){\n\t\tmp[A]+=v;\n\t\tA.rotate();\n\t}\n}\nint main(){\n\t//freopen(\"in\",\"r\",stdin);\n\tN=read();\n\tfor(int i=1;i<=N;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\ts[i].a[j]=read();\n\t\tadd(s[i],1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=N;i++){\n\t\tadd(s[i],-1);\n\t\tfor(int j=i+1;j<=N;j++){\n\t\t\tadd(s[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tlong long now=1;\n\t\t\t\tsqr tmp1(s[j].a[1],s[i].a[0],s[i].a[3],s[j].a[2]);\n\t\t\t\tsqr tmp2(s[i].a[1],s[j].a[0],s[j].a[3],s[i].a[2]);\n\t\t\t\tsqr tmp3(s[j].a[1],s[j].a[0],s[i].a[1],s[i].a[0]);\n\t\t\t\tsqr tmp4(s[i].a[3],s[i].a[2],s[j].a[3],s[j].a[2]);\n\t\t\t\t\n\t\t\t\tif(!(mp[tmp1]&&mp[tmp2]&&mp[tmp3]&&mp[tmp4]))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tnow*=mp[tmp1];add(tmp1,-1);\n\t\t\t\tnow*=mp[tmp2];add(tmp2,-1);\n\t\t\t\tnow*=mp[tmp3];add(tmp3,-1);\n\t\t\t\tnow*=mp[tmp4];add(tmp4,-1);\n\t\t\t\t\n\t\t\t\tadd(tmp1,1);\n\t\t\t\tadd(tmp2,1);\n\t\t\t\tadd(tmp3,1);\n\t\t\t\tadd(tmp4,1);\n\n\t\t\t\ts[j].rotate();\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t\tadd(s[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef unsigned int U;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl; using std::cerr;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n) { cerr << #a << \" = {\"; \\\n      for(int qwq = (st); qwq <= (n); ++qwq) cerr << a[qwq] << (qwq == (n) ? '}' : ',') << (qwq == (n) ? '\\n' : ' '); }\n#define displayv(a) display(a, 0, (int)(a.size()-1))\n#include <ctime>\nclass MyTimer {\n  clock_t st;\npublic:\n  MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n  ~MyTimer() { report(); }\n  void reset() { st = clock_t(); }\n  void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) {}\n#define displayv(a) {}\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifdef QUICK_READ\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n  int a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\ninline LL readLL() {\n  LL a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\n\nconst int maxN = 400 + 5;\nconst int maxC = 1000 + 23;\nint n;\nstruct Tile {\n  int c[4];\n  Tile() {}\n  int& operator [](const int id) {\n    return c[id];\n  }\n  Tile(int x, int y, int z, int w) {\n    c[0] = x; c[1] = y; c[2] = z; c[3] = w;\n  }\n  friend bool operator < (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return A[i] < B[i];\n    return false;\n  }\n  friend bool operator == (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return false;\n    return true;\n  }\n  void rotate() {\n    int t = c[3];\n    for(int i = 3; i > 0; --i) c[i] = c[i - 1];\n    c[0] = t;\n  }\n}a[maxN];\n\nLL f[16], g[16];\nint c[4];\n\nLL solve() {\n  LL ans = 0;\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j) {\n      for(int t = 0; t < 4; ++t) {\n        a[j].rotate();\n        Tile sample[4] = {Tile(a[j][2], a[j][1], a[i][0], a[i][3]), Tile(a[j][3], a[j][2], a[i][3], a[i][2]),\n\t\t\t\t\t\t\tTile(a[j][0], a[j][3], a[i][2], a[i][1]), Tile(a[j][1], a[j][0], a[i][1], a[i][0])};\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for(int k = i + 1; k < n; ++k) if(k != j) {\n\t\t\t\t\tfor(int i = 0; i < 4; ++i) c[i] = 0;\n\t\t\t\t  for(int tt = 0; tt < 4; ++tt) {\n\t\t\t\t    a[k].rotate();\n\t\t\t\t    for(int i = 0; i < 4; ++i) if(a[k] == sample[i]) c[i]++;\n\t\t\t\t  }\n\t\t\t\t  \n\t\t\t\t\tfor(int S = 0; S < 16; ++S) g[S] = f[S];\n\t\t\t\t  for(int i = 0; i < 4; ++i) if(c[i]) {\n\t\t\t\t    int num = 1 << i;\n\t\t\t\t    int full = 15 ^ num;\n\t\t\t\t    LL tc = c[i];\n\t\t\t\t    for(int S = full; S; S = full & (S - 1)) f[S | num] += g[S] * tc;\n\t\t\t\t    f[num] += g[0] * tc;\n\t\t\t\t  }\n//          for(int S = 15; S >= 0; --S) {\n//          \tfor(int i = 0; i < 4; ++i) if(S >> i & 1)\n//          \t\tf[S] += f[S ^ (1 << i)] * c[i];\n//\t\t\t\t\t}\n        }\n        ans += f[15];\n      }\n    }\n  return ans;\n}\n\nint main() {\n  n = readint();\n  for(int i = 0; i < n; ++i) for(int j = 0; j < 4; ++j) a[i][j] = readint();\n\tprintf(\"%lld\\n\", solve());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\ntypedef tuple<int, int, int, int> TP;\nTP narabi(int a, int b, int c, int d) {\n\tTP kari[4];\n\tkari[0] = tie(a, b, c, d);\n\tkari[1] = tie(b, c, d, a);\n\tkari[2] = tie(c, d, a, b);\n\tkari[3] = tie(d, a, b, c);\n\tsort(kari, kari + 4);\n\treturn kari[0];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tTP C[400];\n\tmap<TP, int> MP;\n\trep(i, N) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tC[i] = narabi(a, b, c, d);\n\t\tMP[C[i]]++;\n\t}\n\n\tll kotae = 0;\n\trep(i, N) rep(j, N) if (i != j) {\n\t\tMP[C[i]]--;\n\t\tMP[C[j]]--;\n\n\t\tint a, b, c, d, e, f, g, h;\n\t\ta = get<0>(C[i]);\n\t\tb = get<1>(C[i]);\n\t\tc = get<2>(C[i]);\n\t\td = get<3>(C[i]);\n\t\te = get<0>(C[j]);\n\t\tf = get<1>(C[j]);\n\t\tg = get<2>(C[j]);\n\t\th = get<3>(C[j]);\n\n\t\trep(x, 4) {\n\t\t\tTP D[4];\n\t\t\tD[0] = narabi(a, d, f, e);\n\t\t\tD[1] = narabi(a, e, h, b);\n\t\t\tD[2] = narabi(b, h, g, c);\n\t\t\tD[3] = narabi(c, g, f, d);\n\t\t\tll kari = 1;\n\t\t\trep(k, 4) {\n\t\t\t\tkari *= MP[D[k]]--;\n\t\t\t\tif (get<0>(D[k]) == get<2>(D[k]) && get<1>(D[k]) == get<3>(D[k])) {\n\t\t\t\t\tkari *= 2;\n\t\t\t\t\tif (get<1>(D[k]) == get<2>(D[k])) kari *= 2;\n\t\t\t\t}\n\t\t\t\tif (kari < 0) kari = 0;\n\t\t\t}\n\t\t\trep(k, 4) MP[D[k]]++;\n\t\t\tkotae += kari;\n\n\t\t\tint tmp = e;\n\t\t\te = f;\n\t\t\tf = g;\n\t\t\tg = h;\n\t\t\th = tmp;\n\t\t}\n\n\t\tMP[C[i]]++;\n\t\tMP[C[j]]++;\n\t}\n\tco(kotae / 6);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 400\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nmap<LL,LL> mp;\nint col[MAXN+5][4];\nLL Translate(int seq[4])\n{\n\tLL x=0;\n\tfor(int i=3;i>=0;i--)\n\t\tx=1000LL*x+1LL*seq[i];\n\treturn x;\n}\nvoid Add(int seq[4],int val)//以块为单位进行计算 \n{\n\tLL num=Translate(seq);\n\tfor(int tmn=0;tmn<4;tmn++)\n\t{\n\t\tnum/=1000LL;\n\t\tnum+=seq[tmn]*1000000000LL;\n\t\tmp[num]+=val;\n\t}\n}\nLL Query(LL x)\n{\n\tif(mp.find(x)==mp.end())\n\t\treturn 0LL;\n\treturn mp[x];\n}\nvoid GetSeq(int a0,int a1,int a2,int a3,int seq[4])\n{\n\tseq[0]=a0;seq[1]=a1;seq[2]=a2;seq[3]=a3;\n}\nint main()\n{\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tAdd(col[i],1);\n\t}\n\tint val[4][4];\n\tLL ans=0,tot=0;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int tmn=1;tmn<=4;tmn++)\n\t\t{\n\t\t\tAdd(col[i],-1L);\n\t\t\tfor(int j=i+1;j<=N;j++)\n\t\t\t{\n\t\t\t\tAdd(col[j],-1LL);\n\t\t\t\ttot=1LL;\n\t\t\t\tGetSeq(col[j][1],col[j][0],col[i][1],col[i][0],val[0]);\n\t\t\t\tGetSeq(col[j][2],col[j][1],col[i][0],col[i][3],val[1]);\n\t\t\t\tGetSeq(col[j][0],col[j][3],col[i][2],col[i][1],val[2]);\n\t\t\t\tGetSeq(col[j][3],col[j][2],col[i][3],col[i][2],val[3]);\n\t\t\t\t//==================\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\ttot*=Query(Translate(val[k]));\n\t\t\t\t\tAdd(val[k],-1LL);\n\t\t\t\t}\n\t\t\t\t//==================\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tAdd(val[k],1LL);\n\t\t\t\tans+=tot;\n\t\t\t\tAdd(col[j],1LL);\n\t\t\t}\n\t\t\tAdd(col[i],1LL);\n\t\t\tint first=col[i][0];\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\tcol[i][k]=col[i][k+1];\n\t\t\tcol[i][3]=first;\n\t\t} \n\t}\n\tprintf(\"%lld\\n\",ans/3LL);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\ntypedef pair<pii,pii> s4;\nint n,c[555][4],cc[555]; s4 t[555][4],g[555];\n#define S 5\nmap<s4,ll> ms[S];\nll f[17];\n#define p4(a,b,c,d) make_pair(pii(a,b),pii(c,d))\ns4 py(s4 x)\n{\n\treturn min(min(x,p4(x.fi.se,x.se.fi,x.se.se,x.fi.fi)),\n\tmin(p4(x.se.fi,x.se.se,x.fi.fi,x.fi.se),\n\tp4(x.se.se,x.fi.fi,x.fi.se,x.se.fi)));\n}\nll fac[S];\nvoid add(int x)\n{\n\tfor(int j=S-1;j>1;--j)\n\t\tms[j][g[x]]+=ms[j-1][g[x]]*cc[x];\n\tms[1][g[x]]+=cc[x];\n}\nvoid del(int x)\n{\n\tms[1][g[x]]-=cc[x];\n\tfor(int j=1;j<S;++j)\n\t\tms[j][g[x]]-=ms[j-1][g[x]]*cc[x];\n}\nint main()\n{\n\tfac[0]=1; ll aa=0;\n\tfor(int i=1;i<S;++i) fac[i]=fac[i-1]*i;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<4;++j) scanf(\"%d\",&c[i][j]);\n\tfor(int x=1;x<=n;++x)\n\t{\n\t\tfor(int i=0;i<4;++i)\n\t\t\tt[x][i]=p4(c[x][i],c[x][(i+3)&3],\n\t\t\tc[x][(i+2)&3],c[x][(i+1)&3]);\n\t\tg[x]=min(min(t[x][0],t[x][1]),min(t[x][2],t[x][3]));\n\t\tfor(int i=0;i<4;++i)\n\t\t\tcc[x]+=(g[x]==t[x][i]);\n\t\tadd(x);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tdel(i); del(j);\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tmap<s4,int> tar;\n\t\t\t\tfor(int p=0;p<4;++p)\n\t\t\t\t\t++tar[py(p4(c[i][p],c[i][(p+1)&3],\n\t\t\t\t\tc[j][(4-p+k)&3],c[j][(4-p+k+1)&3]))];\n\t\t\t\tll ans=1;\n\t\t\t\tfor(auto s:tar)\n\t\t\t\t\tans*=ms[s.se][s.fi]*fac[s.se];\n\t\t\t\taa+=ans;\n\t\t\t}\n\t\t\tadd(i); add(j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",aa/3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<ll> po(4,1);\n    for (int i=0;i<3;++i) po[i+1]=po[i]*1000;\n    vector<vector<ll>> hash(N,vector<ll>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            for (int k=0;k<4;++k){\n                hash[i][j]+=C[i][(j+k)%4]*po[k];\n            }\n        }\n    }\n    vector<int> rot(4),check(4);\n    vector<vector<int>> surface(4,vector<int>(4));\n    vector<ll> hashedsurface(4);\n    vector<ll> dp(16);\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                    if (surface[q][0]==surface[q][1]\n                        &&surface[q][1]==surface[q][2]\n                        &&surface[q][2]==surface[q][3]\n                        &&surface[q][3]==surface[q][0]) rot[q]=4;\n                    else if (surface[q][0]==surface[q][2]\n                            &&surface[q][1]==surface[q][3]) rot[q]=2;\n                    else rot[q]=1;\n                    hashedsurface[q]=0;\n                    for (int r=0;r<4;++r){\n                        hashedsurface[q]+=surface[q][r]*po[r];\n                    }\n                }\n                for (int l=0;l<16;++l) dp[l]=0;\n                dp[0]=1;\n                for (int k=i+1;k<N;++k){\n                    if (k==j) continue;\n                    for (int l=0;l<4;++l){\n                        check[l]=0;\n                        for (int m=0;m<4;++m){\n                            if (hashedsurface[l]==hash[k][m]){\n                                check[l]=1;\n                            }\n                        }\n                    }\n                    for (int mask=16;mask>=0;--mask){\n                        for (int l=0;l<4;++l){\n                            if ((mask&1<<l)&&check[l]){\n                                dp[mask]+=dp[mask^1<<l]*rot[l];\n                            }\n                        }\n                    }\n                }\n                ans+=dp[15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n;\npair<pii,pii> cubes[525];\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    cubes[i] = make_pair(pii(a,b),pii(c,d));\n  }\n  typedef pii E;\n  typedef pair<pii,pii> S;\n  // one edge, another edge, [count, multiple]\n  map<E, map<E,pii> > edges;\n  // surface, [count, multiple]\n  map<S, pii> surfaces;\n\n  // surface to edges\n  map<S,set<pair<E,E> > > s2e;\n  // surface to surfaces\n  map<S,set<S> > s2s;\n\n  {\n    int a[4];\n    REP(i,n){\n      map<pii,map<pii,int> > ae;\n      map<pair<pii,pii>,int> as;\n      a[0] = cubes[i].first.first;\n      a[1] = cubes[i].first.second;\n      a[2] = cubes[i].second.first;\n      a[3] = cubes[i].second.second;\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        ae[e][oe]+=1;\n        as[s]+=1;\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        if(ae[e][oe]>0){\n          edges[e][oe].first += 1;\n          edges[e][oe].second = ae[e][oe];\n          ae[e][oe] = 0;\n        }\n        if(as[s]>0){\n          surfaces[s].first += 1;\n          surfaces[s].second = as[s];\n          as[s] = 0;\n        }\n        for(auto _s:as){\n          S s = _s.first;\n          s2e[s].insert(make_pair(e,oe));\n        }\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      for(auto _s:as){\n        S s = _s.first;\n        for(auto _t:as){\n          S t = _t.first;\n          s2s[s].insert(t);\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  // 1. determine first surface(a,b,c,d)\n  for(auto _s1:surfaces){\n    S s1 = _s1.first;\n    ll u1 = _s1.second.first * _s1.second.second;\n    int a = s1.first.first;\n    int b = s1.first.second;\n    int c = s1.second.first;\n    int d = s1.second.second;\n    // decrement\n    for(S s:s2s[s1])surfaces[s].first--;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first--;\n    // 2. determine second surface(e,f)\n    E e1 = pii(b,a);\n    for(auto _e2:edges[e1]){\n      E e2 = _e2.first;\n      ll u2 = u1 * _e2.second.first * _e2.second.second;\n      if(u2==0)continue;\n      int e = e2.first;\n      int f = e2.second;\n      // decrement\n      S s2 = make_pair(e1,e2);\n      for(S s:s2s[s2])surfaces[s].first--;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first--;\n      // 3. determine third surface(g,h)\n      E e3 = pii(d,c);\n      for(auto _e4:edges[e3]){\n        E e4 = _e4.first;\n        ll u3 = u2 * _e4.second.first * _e4.second.second;\n        if(u3==0)continue;\n        int g = e4.first;\n        int h = e4.second;\n        // decrement\n        S s3 = make_pair(e3,e4);\n        for(S s:s2s[s3])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first--;\n        // 4,5,6 the other 3 surfaces\n        S s4 = make_pair(pii(a,d),pii(h,e));\n        S s5 = make_pair(pii(e,h),pii(g,f));\n        S s6 = make_pair(pii(c,b),pii(f,g));\n        // s4\n        ll u4 = u3 * surfaces[s4].first * surfaces[s4].second;\n        for(S s:s2s[s4])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first--;\n        // s5\n        ll u5 = u4 * surfaces[s5].first * surfaces[s5].second;\n        for(S s:s2s[s5])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first--;\n        // s4\n        ll u6 = u5 * surfaces[s6].first * surfaces[s6].second;\n        for(S s:s2s[s6])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first--;\n        // add\n        ans += u6;\n        // s4\n        for(S s:s2s[s4])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first++;\n        // s5\n        for(S s:s2s[s5])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first++;\n        // s4\n        for(S s:s2s[s6])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first++;\n        // s3\n        for(S s:s2s[s3])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first++;\n      }\n      for(S s:s2s[s2])surfaces[s].first++;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first++;\n    }\n    for(S s:s2s[s1])surfaces[s].first++;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first++;\n  }\n  printf(\"%lld\\n\",ans/24);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nvector<int> Normalize(const vector<int>& xs) {\n  vector<deque<int>> rs;\n  deque<int> q(xs.begin(), xs.end());\n  rs.push_back(q);\n  for (int i = 0; i < 3; i++) {\n    q.push_back(q.front());\n    q.pop_front();\n    rs.push_back(q);\n  }\n  sort(rs.begin(), rs.end());\n  return vector<int>(rs[0].begin(), rs[0].end());\n}\n\nint64 Encode(const vector<int>& xs) {\n  int64 r = 0;\n  for (int i = 0; i < 4; i++) {\n    r *= 2000;\n    r += xs[i];\n  }\n  return r;\n}\n\nint Symmetry(const vector<int>& xs) {\n  if (xs[0] == xs[1] && xs[1] == xs[2] && xs[2] == xs[3]) return 4;\n  if (xs[0] == xs[2] && xs[1] == xs[3]) return 2;\n  return 1;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  s << \"[\";\n  for (int i = 0; i < len; i++) {\n    if (i > 0) s << \", \";\n    s << v[i];\n  }\n  s << \"]\";\n  return s;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> faces;\n  for (int i = 0; i < n; i++) {\n    vector<int> cs(4);\n    for (int j = 0; j < 4; j++) {\n      cin >> cs[j];\n    }\n    faces.push_back(Normalize(cs));\n  }\n  vector<int64> encoded_faces(n);\n  for (int i = 0; i < n; i++) {\n    encoded_faces[i] = Encode(faces[i]);\n  }\n\n  unordered_map<int64, int> f_count_map;\n  for (int i = 0; i < n; i++) {\n    f_count_map[encoded_faces[i]]++;\n  }\n  unordered_map<int64, int> symmetry_map;\n  for (int i = 0; i < n; i++) {\n    symmetry_map[encoded_faces[i]] = Symmetry(faces[i]);\n  }\n\n  int64 ans = 0;\n  for (int f1 = 0; f1 < n; f1++) {\n    f_count_map[encoded_faces[f1]]--;\n    for (int f2 = f1 + 1; f2 < n; f2++) {\n      f_count_map[encoded_faces[f2]]--;\n\n      for (int d2 = 0; d2 < 4; d2++) {\n        vector<int> vs(8);\n        for (int i = 0; i < 4; i++) vs[i] = faces[f1][i];\n        for (int i = 0; i < 4; i++) vs[7 - i] = faces[f2][(d2 + i) % 4];\n        // cout << vs << endl;\n\n        unordered_map<int64, int> r_count;\n        r_count[Encode(Normalize({vs[4], vs[5], vs[1], vs[0]}))]++;\n        r_count[Encode(Normalize({vs[5], vs[6], vs[2], vs[1]}))]++;\n        r_count[Encode(Normalize({vs[6], vs[7], vs[3], vs[2]}))]++;\n        r_count[Encode(Normalize({vs[7], vs[4], vs[0], vs[3]}))]++;\n\n        int64 inc = 1;\n        for (const auto& kv : r_count) {\n          int r = kv.second;\n          int s = f_count_map[kv.first];\n          if (r > s) {\n            inc *= 0;\n            continue;\n          }\n          for (int k = 0; k < r; k++) {\n            inc *= (s - k);\n            inc *= symmetry_map[kv.first];\n          }\n        }\n        ans += inc;\n      }\n\n      f_count_map[encoded_faces[f2]]++;\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\n#ifdef CT\n\t#define debug(...) printf(__VA_ARGS__)\n\t#define setfile() \n#else\n\t#define debug(...)\n\t#define filename \"\"\n\t#define setfile() freopen(filename\".in\", \"r\", stdin); freopen(filename\".out\", \"w\", stdout)\n#endif\n\n#define R register\n#define getc() (_S == _T && (_T = (_S = _B) + fread(_B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)\n#define dmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))\n#define dmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))\n#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)\n#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)\n#define cabs(_x) ((_x) < 0 ? (- (_x)) : (_x))\nchar _B[1 << 15], *_S = _B, *_T = _B;\ninline int F()\n{\n\tR char ch; R int cnt = 0; R bool minus = 0;\n\twhile (ch = getc(), (ch < '0' || ch > '9') && ch != '-') ;\n\tch == '-' ? minus = 1 : cnt = ch - '0';\n\twhile (ch = getc(), ch >= '0' && ch <= '9') cnt = cnt * 10 + ch - '0';\n\treturn minus ? -cnt : cnt;\n}\n#define maxn 410\ntypedef long long ll;\n#define P std::pair<ll, int>\ninline P hash(R int _a, R int _b, R int _c, R int _d)\n{\n\tR int num[4] = {_a, _b, _c, _d};\n\tR int ans[4], c[4];\n\tfor (R int i = 0; i < 4; ++i) ans[i] = 1001;\n\tfor (R int i = 0; i < 4; ++i)\n\t{\n\t\tfor (R int j = 0; j < 4; ++j)\n\t\t\tc[j] = num[(i + j) % 4];\n\t\tfor (R int j = 0; j < 4; ++j)\n\t\t\tif (c[j] != ans[j])\n\t\t\t{\n\t\t\t\tif(c[j] < ans[j]) break;\n\t\t\t\telse goto failed;\n\t\t\t}\n\t\tmemcpy(ans, c, 16);\n\t\tfailed: continue;\n\t}\n\tR ll key = 0;\n\tR int cir;\n\tfor (R int i = 0; i < 4; ++i)\n\t\tkey = key * 10 + ans[i];\n\tif (ans[0] == ans[1] && ans[1] == ans[2] && ans[2] == ans[3]) cir = 4;\n\telse if (ans[0] == ans[2] && ans[1] == ans[3]) cir = 2;\n\telse cir = 1;\n\treturn P(key, cir);\n}\nP A[maxn];\nint c[maxn][4];\nstd::map<ll, int> mp;\nint main()\n{\n//\tsetfile();\n\tR int n = F();\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t\tc[i][j] = F();\n\t\tA[i] = hash(c[i][0], c[i][1], c[i][2], c[i][3]);\n\t\tmp[A[i].first] += A[i].second;\n\t}\n\tll ans = 0;\n\tfor (R int i = 1; i <= n; ++i)\n\t{\n\t\tmp[A[i].first] -= A[i].second;\n\t\tfor (R int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tmp[A[j].first] -= A[j].second;\n\t\t\tfor (R int k = 0; k < 4; ++k)\n\t\t\t{\n\t\t\t\tR ll ret = 1;\n\t\t\t\tfor (R int kk = 0; kk < 4; ++kk)\n\t\t\t\t{\n\t\t\t\t\tR P temp = hash(c[i][(kk + 1) % 4], c[i][kk],\n\t\t\t\t\t\t\t\tc[j][(k + (kk ^ 1)) % 4], c[j][(k + ((kk + 1) ^ 1)) % 4]);\n\t\t\t\t\tret *= mp[temp.first];\n\t\t\t\t\tmp[temp.first] -= temp.second;\n\t\t\t\t}\n\t\t\t\tif (ret > 0) ans += ret;\n\t\t\t\tfor (R int kk = 0; kk < 4; ++kk)\n\t\t\t\t{\n\t\t\t\t\tR P temp = hash(c[i][(kk + 1) % 4], c[i][kk],\n\t\t\t\t\t\t\t\tc[j][(k + (kk ^ 1)) % 4], c[j][(k + ((kk + 1) ^ 1)) % 4]);\n\t\t\t\t\tmp[temp.first] += temp.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp[A[j].first] += A[j].second;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst int DEBUG = 0;\n\nconst int N = 400;\nint c[N][4];\nll hashes[N];\n\nmap<ll, int> dict;\nmap<ll, int> mult;\n\npair<ll, int> norm(ll hash) {\n  ll mi = hash;\n  map<ll, int> t;\n  REP(j, 0, 4) {\n    if (t.count(hash) == 0) {\n      t[hash] = 0;\n    }\n    t[hash]++;\n    mi = min(mi, hash);\n    hash = hash * 1000 % 999999999999;\n  }\n  return pair<ll, int>(mi, t[hash]);\n}\n\nll calc(const VI &cols, int j) { // calucates #ways to fill in the rest 4 squares in [i, n) - {j}\n  ll jhash = hashes[j];\n  ll prod = 1;\n  map<ll, int> alt;\n  REP(k, 0, 4) {\n    ll hash = cols[k] + cols[4 + k] * 1000;\n    hash += ll(cols[4 + ((1 + k) % 4)]) * 1000000;\n    hash += ll(cols[(k + 1) % 4]) * 1000000000;\n    hash = norm(hash).first;\n    if (alt.count(hash) == 0) {\n      alt[hash] = 0;\n    }\n    alt[hash]++;\n  }\n  for (map<ll, int>::iterator it = alt.begin(); it != alt.end(); ++it) {\n    ll hash = it->first;\n    int times = it->second;\n    if (dict.count(hash) == 0) {\n      return 0;\n    }\n    int numh = dict[hash];\n    if (DEBUG) { cerr << \"original numh = \" << numh << endl; }\n    if (jhash == hash) {\n      numh--;\n    }\n    assert (numh >= 0);\n    ll tmp = 1;\n    REP(k, 0, times) {\n      tmp *= numh - k;\n      tmp *= mult[hash];\n    }\n    prod *= tmp;\n    if (DEBUG) { cerr << \"C(\" << numh << \",\" << times << \") * mult^times=\" << tmp << endl; }\n  }\n  return prod;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n) {\n    REP(j, 0, 4) {\n      cin >> c[i][j];\n    }\n  }\n  ll sum = 0;\n  for (int i = n - 1; i >= 0; --i) { // the top facet is fixed (including its direction)\n    if (i < n - 5) {\n      REP(j, i + 1, n) { // the bottom facet is fixed\n\tif (DEBUG) {\n\t  cerr << \"(i, j) = \" << i << \", \" << j << endl;\n\t}\n\tREP(k, 0, 4) { // the direction of the bottom facet is fixed\n\t  if (DEBUG) { cerr << \"rotation \" << k << endl; }\n\t  VI cols(8);\n\t  REP(l, 0, 4) {\n\t    cols[l] = c[i][l];\n\t  }\n\t  REP(l, 0, 4) {\n\t    cols[7 - l] = c[j][(l + k) % 4];\n\t  }\n\t  sum += calc(cols, j);\n\t  if (DEBUG) { cerr << \"sum = \" << sum << endl; }\n\t}\n      }\n    }\n    ll hash = 0; // c0 + 10^3 c1 + 10^6 c2 + 10^9 c3\n    REP(j, 0, 4) {\n      hash *= 1000;\n      hash += c[i][3 - j];\n    }\n    pair<ll, int> normed = norm(hash);\n    hashes[i] = hash = normed.first;\n    if (dict.count(hash) == 0) {\n      dict[hash] = 0;\n    }\n    dict[hash]++;\n    mult[hash] = normed.second;\n    if (DEBUG) { cerr << \"added: \" << hash << \"[\" << dict[hash] << \"]\" << endl;}\n\n  }\n  cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=410;\nstruct Tile{\n\tconst static int D=4;\n\tint a[D];\n\tinline Tile nxt(){\n\t\treturn (Tile){a[1],a[2],a[3],a[0]};\n\t}\n\tinline friend bool operator < (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t\t}\n\t\treturn false;\n\t}\n\tinline friend ostream & operator <<(ostream & out,const Tile &b){\n\t\tout<<b.a[0]<<\" \"<<b.a[1]<<\" \"<<b.a[2]<<\" \"<<b.a[3]<<\" \";\n\t\treturn out;\n\t}\n}tile[N];\nmap<Tile,int>m;\ninline void add(Tile x,int v){\n\tfor(int i=0;i<Tile::D;i++,x=x.nxt()){\n\t\tm[x]+=v;\n\t}\n}\nint main(){\n\tint n=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ttile[i]=(Tile){ni,ni,ni,ni};\n\t\tadd(tile[i],1);\n\t}\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tadd(tile[i],-1);\n\t\tint *a=tile[i].a;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint *b=tile[j].a;\n\t\t\tadd(tile[j],-1);\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\ttile[j]=tile[j].nxt();\n\t\t\t\tTile f1=(Tile){a[1],a[0],b[0],b[3]};\n\t\t\t\tTile f2=(Tile){a[2],a[1],b[3],b[2]};\n\t\t\t\tTile f3=(Tile){a[3],a[2],b[2],b[1]};\n\t\t\t\tTile f4=(Tile){a[0],a[3],b[1],b[0]};\n\t\t\t\tlint tmp=1;\n\t\t\t\ttmp*=m[f1],add(f1,-1);\n\t\t\t\ttmp*=m[f2],add(f2,-1);\n\t\t\t\ttmp*=m[f3],add(f3,-1);\n\t\t\t\ttmp*=m[f4];\n\t\t\t\tadd(f1,1),add(f2,1),add(f3,1);\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tadd(tile[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n\nint N;\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            vector<i64> sum(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_) or Csum[indexes[k]]!=sum[i_]) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                rep(i_,0,4){\n                    sum[i_]=0;\n                    rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                }\n\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n                \n                auto nextCj=shift(C[j]);\n                if(nextCj==C[j]) continue;\n                C[j]=nextCj;\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n                indexes.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 20005;\nconst int mod = 1e9+7;\n\nmap<LL,int> h;LL x[maxn],ans;\nint n,a[maxn][4],cnt[maxn],v[maxn],tot,p[maxn];\nLL cal[maxn][5],pw[maxn][5];\nbool cmp(int p,int q) {\n\tfor (int i=0;i<4;i++)\n\t\tif (x[p+i]!=x[q+i]) return x[p+i]<x[q+i];\n\treturn 0;\n}\nint getId(int a,int b,int c,int d,bool ins=false)\n{\n\tx[0]=x[4]=a;x[1]=x[5]=b;x[2]=x[6]=c;x[3]=x[7]=d;int p=0;\n\tfor (int i=1;i<4;i++) if (cmp(i,p)) p=i;\n\tLL num=(x[p]<<30)|(x[p+1]<<20)|(x[p+2]<<10)|x[p+3];\n\tins&&!h[num]?h[num]=++tot:0;return h[num];\n}\nint getv(int a,int b,int c,int d)\n{\n\treturn (a!=c||b!=d)?1:(a!=b?2:4);\n}\nvoid calc(int a,int b,int c,int d,int e,int f,int g,int h)\n{\n\t/*\n      e-----h               \n\t /|    /|            \n\ta-----b |           \n\t| |   | |           \n\t| f---|-g           \n\t|/    |/\n\td-----c         \n\t*/\n\tp[1]=getId(e,h,b,a);\n\tp[2]=getId(h,g,c,b);\n\tp[3]=getId(g,f,d,c);\n\tp[4]=getId(f,e,a,d);\n\tsort(p+1,p+5);LL res=1ll;\n\tfor (int i=1;i<=4;) {\n\t\tint j=i;while (j<=4&&p[j]==p[i]) ++j;\n\t\tif (cnt[p[i]]<j-i) return ;\n\t\tres*=pw[v[p[i]]][j-i]*cal[cnt[p[i]]][j-i];i=j;\n\t}\n\tans+=res;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc062e.in\",\"r\",stdin);\n\t\tfreopen(\"arc062e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%d %d %d %d\",&a[i][0],&a[i][1],&a[i][2],&a[i][3]);\n\t\tint id=getId(a[i][0],a[i][1],a[i][2],a[i][3],1);cnt[id]++;\n\t\tv[id]=getv(a[i][0],a[i][1],a[i][2],a[i][3]);\n\t}\n\tfor (int i=1;i<=4;i++) {\n\t\tpw[i][0]=1ll;\n\t\tfor (int j=1;j<=4;j++)\n\t\t\tpw[i][j]=pw[i][j-1]*i;\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tcal[i][0]=1ll;\n\t\tfor (int j=1;j<=4;j++)\n\t\t\tcal[i][j]=cal[i][j-1]*(i-j+1);\n\t}\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++) {\n\t\tint id1=getId(a[i][0],a[i][1],a[i][2],a[i][3]);\n\t\tint id2=getId(a[j][0],a[j][1],a[j][2],a[j][3]);\n\t\tcnt[id1]--;cnt[id2]--;\n\t\tcalc(a[i][0],a[i][1],a[i][2],a[i][3],a[j][0],a[j][1],a[j][2],a[j][3]);\n\t\tcalc(a[i][0],a[i][1],a[i][2],a[i][3],a[j][1],a[j][2],a[j][3],a[j][0]);\n\t\tcalc(a[i][0],a[i][1],a[i][2],a[i][3],a[j][2],a[j][3],a[j][0],a[j][1]);\n\t\tcalc(a[i][0],a[i][1],a[i][2],a[i][3],a[j][3],a[j][0],a[j][1],a[j][2]);\n\t\tcnt[id1]++;cnt[id2]++;\n\t}\n\tprintf(\"%lld\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nmap<vi,int> ma;\nmap<vi,int> rotar;\nvi A[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvi V; \n\t\tfor(int j=0;j<4;j++){int x; cin>>x; V.pb(x);} \n\t\tA[i]=V;\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tma[V]++;\n\t\t\tV.pb(*V.begin()); V.erase(V.begin());\n\t\t}\n\t}\n\tfor(auto X:ma)\n\t{\n\t\tvi v=X.fi; vi ori=v; int cnt=0;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tv.pb(*v.begin()); v.erase(v.begin());\n\t\t\tif(v==ori) cnt++;\n\t\t}\n\t\trotar[v]=cnt;\n\t}\n\tll ans = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tvi a = A[i];\n\t\t\tvi b = A[j];\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tma[a]--; ma[b]--;\n\t\t\t\ta.pb(*a.begin()); a.erase(a.begin());\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tvi F[4];\n\t\t\t\tF[0] = {a[0],b[1],b[0],a[1]};\n\t\t\t\tF[1] = {a[3],a[2],b[3],b[2]};\n\t\t\t\tF[2] = {b[1],a[0],a[3],b[2]};\n\t\t\t\tF[3] = {a[1],b[0],b[3],a[2]};\n\t\t\t\tll res = 1;\n\t\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\t{\n\t\t\t\t\tres*=ma[F[z]];\n\t\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[F[z]]--;\n\t\t\t\t\t\tF[z].pb(*F[z].begin()); F[z].erase(F[z].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int z=0;z<4;z++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[F[z]]++;\n\t\t\t\t\t\tF[z].pb(*F[z].begin()); F[z].erase(F[z].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += res;\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tma[a]++; ma[b]++;\n\t\t\t\ta.pb(*a.begin()); a.erase(a.begin());\n\t\t\t\tb.pb(*b.begin()); b.erase(b.begin());\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass tile{\n\tint edge[4];\n\tint rev_edge[4];\t\n};\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tint t[400][4];\n\tint r_t[400][4];\n\tint i1,i2,i3,i4,i5,i6,i7,i8;\n\t\n\tint r = 0;\n\t\t\n\tfor(int i=0;i<n;i++){\n\t\tcin >> t[i][0] >> t[i][1] >> t[i][2] >> t[i][3];\n\t}\n\t\t\n\tfor(int i=0;i<n;i++){\n\t\ti1 = t[i][0];\n\t\ti2 = t[i][1];\n\t\ti3 = t[i][2];\n\t\ti4 = t[i][3];\n\t\tfor(int j=i;j<n;j++){\n\t\t\ti5 = t[j][0];\n\t\t\ti6 = t[j][1];\n\t\t\ti7 = t[j][2];\n\t\t\ti8 = t[j][3];\n\t\t\t\n\t\t\tfor(int j1 = i; j1 < n; j1++){\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i; j2 < n; j2++){\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti5 = t[j][1];\n\t\t\ti6 = t[j][2];\n\t\t\ti7 = t[j][3];\n\t\t\ti8 = t[j][0];\n\n\t\t\tfor(int j1 = i; j1 < n; j1++){\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i; j2 < n; j2++){\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\ti5 = t[j][2];\n\t\t\ti6 = t[j][3];\n\t\t\ti7 = t[j][0];\n\t\t\ti8 = t[j][1];\n\n\t\t\tfor(int j1 = i; j1 < n; j1++){\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i; j2 < n; j2++){\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\ti5 = t[j][3];\n\t\t\ti6 = t[j][0];\n\t\t\ti7 = t[j][1];\n\t\t\ti8 = t[j][2];\n\t\t\t\n\t\t\tfor(int j1 = i; j1 < n; j1++){\n\t\t\t\tif((t[j1][0] == i1 && t[j1][1] == i6 && t[j1][2] == i5 && t[j1][3] == i2)||\n\t\t\t\t\t(t[j1][0] == i6 && t[j1][1] == i5 && t[j1][2] == i2 && t[j1][3] == i1)||\n\t\t\t\t\t(t[j1][0] == i5 && t[j1][1] == i2 && t[j1][2] == i1 && t[j1][3] == i6)||\n\t\t\t\t\t(t[j1][0] == i2 && t[j1][1] == i1 && t[j1][2] == i6 && t[j1][3] == i5)){\n\t\t\t\t\t\n\t\t\t\t\tint mul1 = 1;\n\t\t\t\t\t\n\t\t\t\t\tif(t[j1][0] == t[j1][2] && t[j1][1] == t[j1][3]){\n\t\t\t\t\t\tmul1 = 2;\n\t\t\t\t\t\tif(t[j1][0] == t[j1][1]){\n\t\t\t\t\t\t\tmul1 = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tfor(int j2 = i; j2 < n; j2++){\n\t\t\t\t\t\tif((t[j2][0] == i2 && t[j2][1] == i5 && t[j2][2] == i8 && t[j2][3] == i3)||\n\t\t\t\t\t\t\t(t[j2][0] == i5 && t[j2][1] == i8 && t[j2][2] == i3 && t[j2][3] == i2)||\n\t\t\t\t\t\t\t(t[j2][0] == i8 && t[j2][1] == i3 && t[j2][2] == i2 && t[j2][3] == i5)||\n\t\t\t\t\t\t\t(t[j2][0] == i3 && t[j2][1] == i2 && t[j2][2] == i5 && t[j2][3] == i8)){\n\n\t\t\t\t\t\t\tint mul2 = 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(t[j2][0] == t[j2][2] && t[j2][1] == t[j2][3]){\n\t\t\t\t\t\t\t\tmul2 = 2;\n\t\t\t\t\t\t\t\tif(t[j2][0] == t[j2][1]){\n\t\t\t\t\t\t\t\t\tmul2 = 4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j3 = i; j3 < n; j3++){\n\t\t\t\t\t\t\t\tif((t[j3][0] == i6 && t[j3][1] == i1 && t[j3][2] == i4 && t[j3][3] == i7)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i1 && t[j3][1] == i4 && t[j3][2] == i7 && t[j3][3] == i6)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i4 && t[j3][1] == i7 && t[j3][2] == i6 && t[j3][3] == i1)||\n\t\t\t\t\t\t\t\t\t(t[j3][0] == i7 && t[j3][1] == i6 && t[j3][2] == i1 && t[j3][3] == i4)){\n\n\t\t\t\t\t\t\t\t\tint mul3 = 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][2] && t[j3][1] == t[j3][3]){\n\t\t\t\t\t\t\t\t\t\tmul3 = 2;\n\t\t\t\t\t\t\t\t\t\tif(t[j3][0] == t[j3][1]){\n\t\t\t\t\t\t\t\t\t\t\tmul3 = 4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor(int j4 = i; j4 < n; j4++){\n\t\t\t\t\t\t\t\t\t\tif((t[j4][0] == i4 && t[j4][1] == i3 && t[j4][2] == i8 && t[j4][3] == i7)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i3 && t[j4][1] == i8 && t[j4][2] == i7 && t[j4][3] == i4)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i8 && t[j4][1] == i7 && t[j4][2] == i4 && t[j4][3] == i3)||\n\t\t\t\t\t\t\t\t\t\t\t(t[j4][0] == i7 && t[j4][1] == i4 && t[j4][2] == i3 && t[j4][3] == i8)){\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tint mul4 = 1;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][2] && t[j4][1] == t[j4][3]){\n\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tif(t[j4][0] == t[j4][1]){\n\t\t\t\t\t\t\t\t\t\t\t\t\tmul4 = 4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tr += (mul1 * mul2 * mul3 * mul4);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\t\t\n\tprintf(\"%d\\n\",r);\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ninline ll encode(vector<int> &tile) {\n  ll now = 0, base = 1000;\n  for (int c : tile) {\n    now += c;\n    now *= base;\n  }\n  return now;\n}\n\ninline void rot(vector<int> &tile) {\n  rotate(tile.begin(), tile.begin() + 1, tile.end());\n}\n\ninline void rm_tile(vector<int> &tile, map<ll, int> &colors) {\n  REP(i, 4) {\n    colors[encode(tile)]--;\n    rot(tile);\n  }\n}\n\ninline void add_tile(vector<int> &tile, map<ll, int> &colors) {\n  REP(i, 4) {\n    colors[encode(tile)]++;\n    rot(tile);\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<ll, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  vector<vector<int>> used;\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[encode(tile)], 0);\n    //if (ret == 0) break;\n    rm_tile(tile, colors);\n    used.emplace_back(tile);\n  }\n\n  for (vector<int> &tile : used) add_tile(tile, colors);\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<ll, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[encode(tiles[i])]++;\n      rot(tiles[i]);\n    }\n  }\n\n  ll ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rot(tiles[low]);\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\nint mod = 1e9+7;\n\nvi normalize(vi v){\n\tvi ret(4,1e9);\n\trep(i,4){\n\t\tchmin(ret,v);\n\t\trotate(v.begin(),v.begin()+1,v.end());\n\t}\n\treturn ret;\n}\n\nint calc(vi v){\n\tint ret = 0;\n\tvi vc = v;\n\trep(i,4){\n\t\tif(v == vc)ret++;\n\t\trotate(v.begin(), v.begin()+1, v.end());\n\t}\n\treturn ret;\n}\n\nvi fs[500];\nmap<vi, P> cnt1;\nmap<vi, int> cnt2;\n\nsigned main(){\n\tint n;\n\tscanf(\"%lld\", &n);\n\trep(i,n){\n\t\tvi v(4);\n\t\trep(j,4)cin >> v[j];\n\t\tfs[i] = normalize(v);\n\t\tint t = calc(fs[i]);\n\t\tcnt1[fs[i]].fi++;\n\t\tcnt1[fs[i]].se = t;\n\t}\n\trep(i,n)printf(\"%lld \", cnt1[fs[i]].fi);\n\tprintf(\"\\n\");\n\t\n\tint ans = 0;\n\trep(i,n)rep(j,n){\n\t\tif(i == j)continue;\n\t\trep(k,4){\n\t\t\tvi bot = fs[i], top = fs[j];\n\t\t\tcnt2[bot]++;cnt2[top]++;\n\t\t\trotate(top.begin(), top.begin()+k, top.end());\n\t\t\tint tmp = 1;\n\t\t\trep(l,4){\n\t\t\t\tvi side = {bot[0], top[1], top[0], bot[1]};\n\t\t\t\tside = normalize(side);\n\t\t\t\t//if(cnt2[side]+1 > cnt1[side].fi)tmp = 0;\n\t\t\t\ttmp *= cnt1[side].se*(cnt1[side].fi-cnt2[side]);\n\t\t\t\tcnt2[side]++;\n\t\t\t\trotate(top.begin(), top.begin()+1, top.end());\n\t\t\t\trotate(bot.begin(), bot.begin()+3, bot.end());\n\t\t\t}\n\t\t\tans += tmp;\n\t\t\tcnt2.clear();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans/6);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<vector<ll>,ll>mp;\n  ll access(const vector<ll>&v){\n    ll ret=0;\n    ret+=mp[{v[0],v[1],v[2],v[3]}];\n    ret+=mp[{v[1],v[2],v[3],v[0]}];\n    ret+=mp[{v[2],v[3],v[0],v[1]}];\n    ret+=mp[{v[3],v[0],v[1],v[2]}];\n    //cout<<ret<<endl;\n    return max(0LL,ret);\n  }\n  void change(const vector<ll>&v,ll w){\n    //if(!mp.count(v))return;\n    mp[v]+=w;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,0LL);\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.mp[c[i]]++;\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<ll>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<ll>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long li;\n\nli hash_color(const vector<int> &colors) {\n    li v = 0;\n    li pow = 1;\n    for (int i = 0; i < 4; ++i) {\n        v += colors[i] * pow;\n        pow *= 1000;\n    }\n    return v;\n}\n\nvector<int> rotate(const vector<int> &colors) {\n    return {colors[1], colors[2], colors[3], colors[0]};\n}\n\nvector<int> rotate(const vector<int> &colors, const int count) {\n    vector<int> ret = colors;\n    for (int i = 0; i < count; ++i) {\n        ret = rotate(ret);\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> colors(n, vector<int>(4));\n    map<li, vector<int>> card_index;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n        }\n        for (int d = 0; d < 4; ++d) {\n            card_index[hash_color(rotate(colors[i], d))].emplace_back(i);\n        }\n    }\n\n    li ans = 0;\n    for (int bottom = 0; bottom < n; ++bottom) {\n        // flipped\n        const vector<int> bottom_colors = {\n                colors[bottom][3],\n                colors[bottom][2],\n                colors[bottom][1],\n                colors[bottom][0]\n        };\n        for (int top = bottom + 1; top < n; ++top) {\n            for (int top_dir = 0; top_dir < 4; ++top_dir) {\n                const vector<int> top_colors = rotate(colors[top], top_dir);\n\n                vector<vector<int>> choices(n, vector<int>(4));\n\n                for (int side_index = 0; side_index < 4; ++side_index) {\n                    const vector<int> side_colors = {\n                            bottom_colors[side_index],\n                            bottom_colors[(side_index + 1) % 4],\n                            top_colors[(side_index + 1) % 4],\n                            top_colors[side_index]\n                    };\n                    const li side_hash = hash_color(side_colors);\n                    for (int card_id : card_index[side_hash]) {\n                        if (card_id > bottom && card_id != top) {\n                            choices[card_id][side_index] += 1;\n                        }\n                    }\n                }\n\n                vector<li> dp(16, 0);\n                dp[0] = 1;\n                for (int i = 0; i < n; ++i) {\n                    vector<li> ndp = dp;\n                    for (int j = 0; j < 15; ++j) {\n                        for (int side = 0; side < 4; ++side) {\n                            int nj = j | (1LL << side);\n                            if (nj == j) {\n                                continue;\n                            }\n                            ndp[nj] += dp[j] * choices[i][side];\n                        }\n                    }\n                    dp = ndp;\n                }\n\n                ans += dp[15];\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<ll,ii> iii;\ntypedef vector<int> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<vi,int> todo;\nvector<vi> vper;\nvi move(vi &nuevo,int delta)\n{\n    vi ans;\n    forr(i,0,4)\n    {\n        ans.pb(nuevo[(i+delta)%4]);\n    }\n    return ans;\n}\nvoid permutar(vi &nuevo)\n{\n    vper.clear();\n    forr(i,0,4)\n    vper.pb(move(nuevo,i));\n\n}\nvoid add(vi nuevo,int delta,map<vi,int> &mapa)\n{\n    permutar(nuevo);\n    forr(i,0,vper.size())\n    {\n        mapa[vper[i]]+=delta;\n    }\n}\nvector<vi> vcaras;\nvoid gocaras(vi &v1,vi& v2)\n{\n        vcaras.clear();\n    vi auxcara(4,0);\n    auxcara[0]=v1[0],auxcara[3]=v1[1],auxcara[1]=v2[0],auxcara[2]=v2[3];vcaras.pb(auxcara);\n    auxcara[0]=v1[1],auxcara[3]=v1[2],auxcara[1]=v2[3],auxcara[2]=v2[2];vcaras.pb(auxcara);\n    auxcara[0]=v1[2],auxcara[3]=v1[3],auxcara[1]=v2[2],auxcara[2]=v2[1];vcaras.pb(auxcara);\n    auxcara[0]=v1[0],auxcara[3]=v2[0],auxcara[1]=v1[3],auxcara[2]=v2[1];vcaras.pb(auxcara);\n\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   int n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   permutar(V[2]);\n   map<vi,int> extra;\n   ll totp,answer=0;\n   //return 0;\n   forr(i,0,n)\n   {\n        forr(j,0,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    cara1=move(V[i],ki);\n                    cara2=move(V[j],kj);\n                    /*<<\"comenzamos\\n\";\n                    print(cara1);\n                    print(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        print(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        totp*=(todo[vcaras[l]]-extra[vcaras[l]]);\n                        add(vcaras[l],1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //<<answer<<endl;\n   cout<<answer/24<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\nint64 normalize(vector< int > &v) {\n  int64 ret = INF;\n  for(int i = 0; i < 4; i++) {\n    rotate(begin(v), begin(v) + 1, end(v));\n    int64 val = 0;\n    for(int j = 0; j < 4; j++) {\n      val = val * 400 + v[j];\n    }\n    ret = min(ret, val);\n  }\n  return ret;\n}\n\nusing int64 = long long;\n\nint main() {\n  int N;\n  cin >> N;\n  vector< vector< int > > C(N, vector< int >(4));\n  vector< int64 > normal(N);\n  map< int64, int > cnt, mul;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 4; j++) cin >> C[i][j];\n    normal[i] = normalize(C[i]);\n    if(!mul.count(normal[i])) {\n      int beet = 0;\n      auto base = C[i];\n      for(int j = 0; j < 4; j++) {\n        rotate(begin(C[i]), begin(C[i]) + 1, end(C[i]));\n        beet += base == C[i];\n      }\n      mul[normal[i]] = beet;\n    }\n    cnt[normal[i]]++;\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    cnt[normal[i]]--;\n    for(int j = 0; j < i; j++) {\n      cnt[normal[j]]--;\n      for(int k = 0; k < 4; k++) {\n        vector< int > key1{C[i][1], C[i][0], C[j][1], C[j][0]};\n        vector< int > key2{C[i][2], C[i][1], C[j][0], C[j][3]};\n        vector< int > key3{C[i][3], C[i][2], C[j][3], C[j][2]};\n        vector< int > key4{C[i][0], C[i][3], C[j][2], C[j][1]};\n        auto ei1 = normalize(key1);\n        auto ei2 = normalize(key2);\n        auto ei3 = normalize(key3);\n        auto ei4 = normalize(key4);\n        int64 latte = 1;\n        latte *= 1LL * mul[ei1] * cnt[ei1];\n        --cnt[ei1];\n        latte *= 1LL * mul[ei2] * cnt[ei2];\n        --cnt[ei2];\n        latte *= 1LL * mul[ei3] * cnt[ei3];\n        --cnt[ei3];\n        latte *= 1LL * mul[ei4] * cnt[ei4];\n        --cnt[ei4];\n        ret += latte;\n        ++cnt[ei1];\n        ++cnt[ei2];\n        ++cnt[ei3];\n        ++cnt[ei4];\n        rotate(begin(C[j]), begin(C[j]) + 1, end(C[j]));\n      }\n      cnt[normal[j]]++;\n    }\n    cnt[normal[i]]++;\n  }\n  cout << ret / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef unsigned int U;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl; using std::cerr;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n) { cerr << #a << \" = {\"; \\\n      for(int qwq = (st); qwq <= (n); ++qwq) cerr << a[qwq] << (qwq == (n) ? '}' : ',') << (qwq == (n) ? '\\n' : ' '); }\n#define displayv(a) display(a, 0, (int)(a.size()-1))\n#include <ctime>\nclass MyTimer {\n  clock_t st;\npublic:\n  MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n  ~MyTimer() { report(); }\n  void reset() { st = clock_t(); }\n  void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) {}\n#define displayv(a) {}\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifdef QUICK_READ\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n  int a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\ninline LL readLL() {\n  LL a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\n\nconst int maxN = 400 + 5;\nconst int maxC = 1000 + 23;\nint n;\nstruct Tile {\n  int c[4];\n  Tile() {}\n  int& operator [](const int id) {\n    return c[id];\n  }\n  Tile(int x, int y, int z, int w) {\n    c[0] = x; c[1] = y; c[2] = z; c[3] = w;\n  }\n  friend bool operator < (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return A[i] < B[i];\n    return false;\n  }\n  friend bool operator == (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return false;\n    return true;\n  }\n  void rotate() {\n    int t = c[3];\n    for(int i = 3; i > 0; --i) c[i] = c[i - 1];\n    c[0] = t;\n  }\n  Tile normal() {\n    Tile r = *this;\n    for(int j = 0; j < 4; ++j) {\n      rotate(); if(*this < r) r = *this;\n    }\n    return r;\n  }\n  string tos() {\n  \tstatic char s[100];\n  \tsprintf(s, \"(%d, %d, %d, %d)\", c[0], c[1], c[2], c[3]);\n  \treturn string(s);\n\t}\n}a[maxN];\n\nmap<Tile, int> M;\nvoid add(Tile x, int val) {\n\tfor(int i = 0; i < 4; ++i) {\n\t\tx.rotate(); M[x] += val;\n\t}\n}\n\nLL solve() {\n  LL ans = 0;\n  for(int i = n - 1; i >= 0; --i) {\n    for(int j = i + 1; j < n; ++j) {\n      add(a[j], -1);\n      for(int t = 0; t < 4; ++t) {\n        a[j].rotate();\n        Tile ai = a[i], aj = a[j];\n        Tile sample[4] = {Tile(aj[2], aj[1], ai[0], ai[3]), Tile(aj[3], aj[2], ai[3], ai[2]),\n              Tile(aj[0], aj[3], ai[2], ai[1]), Tile(aj[1], aj[0], ai[1], ai[0])};\n        for(int k = 0; k < 4; ++k) sample[k] = sample[k].normal();\n        LL prod = 1;\n        for(int k = 0; k < 4; ++k) {\n          prod *= M[sample[k]]; add(sample[k], -1);\n        }\n        for(int k = 0; k < 4; ++k) add(sample[k], 1);\n        ans += prod;\n      }\n      add(a[j], 1);\n    }\n    add(a[i], 1);\n  }\n  return ans;\n}\n\nint main() {\n  n = readint();\n  for(int i = 0; i < n; ++i) for(int j = 0; j < 4; ++j) a[i][j] = readint();\n  for(int i = 0; i < n; ++i) a[i] = a[i].normal();\n\tprintf(\"%lld\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst LL A=1000,B=1000000,C=1000000000ll;\nint col[410][4];\nLL num[4];\nunordered_map<LL,LL> cnt;\n\nLL gethash(int x1,int x2,int x3,int x4){return x1+A*x2+B*x3+C*x4;}\n\nvoid add(int x1,int x2,int x3,int x4,int k)\n{\n\tcnt[gethash(x1,x2,x3,x4)]+=k;\n\tcnt[gethash(x2,x3,x4,x1)]+=k;\n\tcnt[gethash(x3,x4,x1,x2)]+=k;\n\tcnt[gethash(x4,x1,x2,x3)]+=k;\n}\n\nvoid add(LL x,int k)\n{\n\tint x1=x%A;x/=A;\n\tint x2=x%A;x/=A;\n\tint x3=x%A;x/=A;\n\tint x4=x%A;x/=A;\n\tadd(x1,x2,x3,x4,k);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tadd(col[i][0],col[i][1],col[i][2],col[i][3],1);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(col[i][0],col[i][1],col[i][2],col[i][3],-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tadd(col[j][0],col[j][1],col[j][2],col[j][3],-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<4;l++) num[l]=gethash(col[i][l],col[j][(k+5-l)&3],col[j][(k+4-l)&3],col[i][(l+1)&3]);\n\t\t\t\tif(!cnt[num[0]]||!cnt[num[1]]||!cnt[num[2]]||!cnt[num[3]]) continue;\n\t\t\t\tLL res=1;\n\t\t\t\tfor(int l=0;l<4;l++) res*=cnt[num[l]],add(num[l],-1);\n\t\t\t\tfor(int l=0;l<4;l++) add(num[l],1);\n\t\t\t\tans+=res;\n\t\t\t}\n\t\t\tadd(col[j][0],col[j][1],col[j][2],col[j][3],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> cyc(V<int> a) {\n\tVV<int> cand;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(a[(j+k)%4]);\n\t\t}\n\t\tcand.pb(vec);\n\t}\n\treturn *min_element(ALL(cand));\n}\n\nint com(V<int>& v) {\n\tint cnt = 0;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(v[(j+k)%4]);\n\t\t}\n\t\tif (vec == v) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> vf;\n\n\tmap<V<int>, int> T, coef;\n\n\trep(i, N) {\n\t\tV<int> a(4);\n\t\trep(j, 4) cin >> a[j];\n\n\t\tauto vec = cyc(a);\n\t\tvf.pb(vec);\n\t\t++T[vec];\n\t\tdump(vec);\n\t\tcoef[vec] = com(vec);\n\t}\n\n\tll ans = 0;\n\n\trep(i, N) {\n\t\trep(j, i) {\n\t\t\t--T[vf[i]];\n\t\t\t--T[vf[j]];\n\n\t\t\trep(k, 4) {\n\t\t\t\tint up[4], dw[4];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tup[l] = vf[i][l];\n\t\t\t\t\tdw[l] = vf[j][(k-l+4)%4];\n\t\t\t\t}\n\n\t\t\t\tll t = 1;\n\n\t\t\t\tVV<int> use;\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tV<int> vec{up[l],up[(l+3)%4],dw[(l+3)%4],dw[l]};\n\t\t\t\t\tvec = cyc(vec);\n\t\t\t\t\tuse.pb(vec);\n\t\t\t\t\tt *= T[vec] * coef[vec];\n\t\t\t\t\t--T[vec];\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\trep(l, 4) ++T[use[l]];\n\t\t\t}\n\n\t\t\t++T[vf[i]];\n\t\t\t++T[vf[j]];\t\t\t\n\t\t}\n\t}\n\tdump(ans);\n\n\tcout << ans / 3 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T,typename U, typename H=hash<T> >\nusing gmap = cc_hash_table<T, U, H>;\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\ngmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\n\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\n__int128_t check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(cnt.find(a)==cnt.end()) return 0;\n  if(cnt.find(b)==cnt.end()) return 0;\n  if(cnt.find(c)==cnt.end()) return 0;\n  if(cnt.find(d)==cnt.end()) return 0;\n  if(cnt.find(e)==cnt.end()) return 0;\n  if(cnt.find(f)==cnt.end()) return 0;\n\n  __int128_t res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[(k+z)%4][i];\n          x[k+4]=cs[k][j];\n        }\n\n        int way=0;\n        A w(x);\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          chmin(w,y);\n        }\n\n        if(used.count(make_hash(w))) continue;\n        used.emplace(make_hash(w));\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<map>\n#define ll long long\nusing namespace std;\nint n;\nll ans;\nstruct Node\n{\n    int a[4];\n    Node(){}\n    Node(int x,int y,int z,int w)\n    {\n        a[0]=x,a[1]=y,a[2]=z,a[3]=w;\n    }\n    bool operator < (const Node &ags) const\n    {\n        if(a[0]!=ags.a[0])\n            return a[0]<ags.a[0];\n        if(a[1]!=ags.a[1])\n            return a[1]<ags.a[1];\n        if(a[2]!=ags.a[2])\n            return a[2]<ags.a[2];\n        return a[3]<ags.a[3];\n    }\n    bool operator == (const Node &ags) const\n    {\n        for(int i=0;i<4;i++)\n            if(a[i]!=ags.a[i])\n                return false;\n        return true;\n    }\n}t[100010];\nmap<Node,ll >mp;\nvoid AddNode(int s1,int s2,int s3,int s4)\n{\n    mp[Node(s1,s2,s3,s4)]++;\n}\nll judge(Node x,Node y)\n{\n    ll res=0;\n    if(x==y) //1\n        res++;\n\n    int temp=y.a[0];\n    for(int i=0;i<3;i++)\n        y.a[i]=y.a[i+1];\n    y.a[3]=temp;\n    if(x==y) //2\n        res++;\n\n    temp=y.a[0];\n    for(int i=0;i<3;i++)\n        y.a[i]=y.a[i+1];\n    y.a[3]=temp;\n    if(x==y) //3\n        res++;\n\n    temp=y.a[0];\n    for(int i=0;i<3;i++)\n        y.a[i]=y.a[i+1];\n    y.a[3]=temp;\n    if(x==y) //4\n        res++;\n    return res;\n}\nvoid jisuan(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8)\n{\n    Node x1=Node(b1,b2,b6,b5);\n    Node x2=Node(b2,b3,b7,b6);\n    Node x3=Node(b3,b4,b8,b7);\n    Node x4=Node(b4,b1,b5,b8);\n    Node sp1=Node(b4,b3,b2,b1);\n    Node sp2=Node(b5,b6,b7,b8);\n    ll res1=mp[x1];\n    ll res2=mp[x2];\n    ll res3=mp[x3];\n    ll res4=mp[x4];\n\n    res1=res1-judge(sp1,x1)-judge(sp2,x1);\n    res2=res2-judge(sp1,x2)-judge(sp2,x2)-judge(x1,x2);\n    res3=res3-judge(sp1,x3)-judge(sp2,x3)-judge(x1,x3)-judge(x2,x3);\n    res4=res4-judge(sp1,x4)-judge(sp2,x4)-judge(x1,x4)-judge(x2,x4)-judge(x3,x4);\n\n    ans+=res1*res2*res3*res4;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=0;j<4;j++)\n            scanf(\"%d\",&t[i].a[j]);\n\n        AddNode(t[i].a[3],t[i].a[2],t[i].a[1],t[i].a[0]);\n        AddNode(t[i].a[2],t[i].a[1],t[i].a[0],t[i].a[3]);\n        AddNode(t[i].a[1],t[i].a[0],t[i].a[3],t[i].a[2]);\n        AddNode(t[i].a[0],t[i].a[3],t[i].a[2],t[i].a[1]);\n    }\n    ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n        {\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3], t[j].a[3],t[j].a[2],t[j].a[1],t[j].a[0]);\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3], t[j].a[2],t[j].a[1],t[j].a[0],t[j].a[3]);\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3], t[j].a[1],t[j].a[0],t[j].a[3],t[j].a[2]);\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3], t[j].a[0],t[j].a[3],t[j].a[2],t[j].a[1]);\n        }\n    printf(\"%lld\",ans/3ll);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=410;\nint n,c[N][8];\nll state(int a,int b,int c,int d){\n\tll ans=0;\n\tans=ans*1000+a;\n\tans=ans*1000+b;\n\tans=ans*1000+c;\n\tans=ans*1000+d;\n\treturn ans;\n}\nmap<ll,int> M;ll ans;\nvoid add(int a,int b,int c,int d,int v){\n\tM[state(a,b,c,d)]+=v;\n\tM[state(b,c,d,a)]+=v;\n\tM[state(c,d,a,b)]+=v;\n\tM[state(d,a,b,c)]+=v;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&c[i][j]),c[i][j+4]=c[i][j];\n\t\tadd(c[i][0],c[i][1],c[i][2],c[i][3],1);\n\t}\n\t//标号最小的正方形作为正面\n\tfor (int i=1;i<=n;i++){\n\t\tadd(c[i][0],c[i][1],c[i][2],c[i][3],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tadd(c[j][0],c[j][1],c[j][2],c[j][3],-1);\n\t\t\tfor (int *C=c[j];C<c[j]+4;C++){//枚举反面和旋转后的方向\n\t\t\t\tll S0=state(c[i][1],c[i][0],C[1],C[0]);\n\t\t\t\tll S1=state(c[i][0],c[i][3],C[2],C[1]);\n\t\t\t\tll S2=state(c[i][3],c[i][2],C[3],C[2]);\n\t\t\t\tll S3=state(c[i][2],c[i][1],C[0],C[3]);\n\t\t\t\tif (!M.count(S0)||!M.count(S1)||!M.count(S2)||!M.count(S3)) continue;\n\t\t\t\tll calc=1;\n\t\t\t\tcalc*=M[S0];\n\t\t\t\tadd(c[i][1],c[i][0],C[1],C[0],-1);\n\t\t\t\tcalc*=M[S1];\n\t\t\t\tadd(c[i][0],c[i][3],C[2],C[1],-1);\n\t\t\t\tcalc*=M[S2];\n\t\t\t\tadd(c[i][3],c[i][2],C[3],C[2],-1);\n\t\t\t\tcalc*=M[S3];\n\t\t\t\tadd(c[i][3],c[i][2],C[3],C[2],1);\n\t\t\t\tadd(c[i][0],c[i][3],C[2],C[1],1);\n\t\t\t\tadd(c[i][1],c[i][0],C[1],C[0],1);\n\t\t\t\tans+=calc;\n\t\t\t}\n\t\t\tadd(c[j][0],c[j][1],c[j][2],c[j][3],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\nint cc[500][4];\n\nstruct abcd {\n  int a, b, c, d;\n  abcd() {}\n  abcd(int _a, int _b, int _c, int _d) { a = _a; b = _b; c = _c; d = _d; }\n  bool operator < (const abcd & another) const {\n    if (a != another.a) return a < another.a;\n    if (b != another.b) return b < another.b;\n    if (c != another.c) return c < another.c;\n    return d < another.d;\n  };\n};\n\nint same(int a0, int a1, int a2, int a3, int b0, int b1, int b2, int b3) {\n  int cc = 0;\n  if (a0 == b0 && a1 == b1 && a2 == b2 && a3 == b3) cc ++;\n  if (a0 == b1 && a1 == b2 && a2 == b3 && a3 == b0) cc ++;\n  if (a0 == b2 && a1 == b3 && a2 == b0 && a3 == b1) cc ++;\n  if (a0 == b3 && a1 == b0 && a2 == b1 && a3 == b2) cc ++;\n  return cc;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  map<abcd, int> cnt;\n  for (int i=0; i<n; i++) {\n    cin >> cc[i][0] >> cc[i][1] >> cc[i][2] >> cc[i][3];\n    cnt[abcd(cc[i][0], cc[i][1], cc[i][2], cc[i][3])] ++;\n    cnt[abcd(cc[i][1], cc[i][2], cc[i][3], cc[i][0])] ++;\n    cnt[abcd(cc[i][2], cc[i][3], cc[i][0], cc[i][1])] ++;\n    cnt[abcd(cc[i][3], cc[i][0], cc[i][1], cc[i][2])] ++;\n  }\n\n  long long res = 0;\n  for (int i=0; i<n; i++)\n    for (int j=i+1; j<n; j++) {\n      int a0 = cc[i][0], a1 = cc[i][1], a2 = cc[i][2], a3 = cc[i][3];\n      int b0 = cc[j][3], b1 = cc[j][2], b2 = cc[j][1], b3 = cc[j][0];\n      for (int ord=0; ord<4; ord++) {\n        int ll_cnt = cnt[abcd(a0, a3, b0, b1)];\n        int rr_cnt = cnt[abcd(a2, a1, b2, b3)];\n        int uu_cnt = cnt[abcd(a1, a0, b1, b2)];\n        int dd_cnt = cnt[abcd(a3, a2, b3, b0)];\n        ll_cnt -= same(a0, a1, a2, a3, a0, a3, b0, b1);\n        ll_cnt -= same(b3, b2, b1, b0, a0, a3, b0, b1);\n        rr_cnt -= same(a0, a1, a2, a3, a2, a1, b2, b3);\n        rr_cnt -= same(b3, b2, b1, b0, a2, a1, b2, b3);\n        uu_cnt -= same(a0, a1, a2, a3, a1, a0, b1, b2);\n        uu_cnt -= same(b3, b2, b1, b0, a1, a0, b1, b2);\n        dd_cnt -= same(a0, a1, a2, a3, a3, a2, b3, b0);\n        dd_cnt -= same(b3, b2, b1, b0, a3, a2, b3, b0);\n\n        rr_cnt -= same(a0, a3, b0, b1, a2, a1, b2, b3);\n        uu_cnt -= same(a0, a3, b0, b1, a1, a0, b1, b2);\n        uu_cnt -= same(a2, a1, b2, b3, a1, a0, b1, b2);\n        dd_cnt -= same(a0, a3, b0, b1, a3, a2, b3, b0);\n        dd_cnt -= same(a2, a1, b2, b3, a3, a2, b3, b0);\n        dd_cnt -= same(a1, a0, b1, b2, a3, a2, b3, b0);\n        res += 1LL * ll_cnt * rr_cnt * uu_cnt * dd_cnt;\n//        printf(\"%d %d %d : %d %d %d %d\\n\", i,j,ord, ll_cnt, rr_cnt, uu_cnt, dd_cnt);\n        int b4 = b0;\n        b0 = b1;\n        b1 = b2;\n        b2 = b3;\n        b3 = b4;\n      }\n    }\n  cout << res / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans,c[410][4],h[410],v[4],tmp[4];\nunordered_map<ll,int>mp;\nvoid upd(ll x,int d){\n    for(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll))\n        mp[x]+=d;\n    return;\n}\nll Hash(ll *a){\n    ll ret=0;\n    for(int i=0;i<4;i++)\n        ret|=(a[i]<<(i*10ll));\n    return ret;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n        h[i]=Hash(c[i]);\n        upd(h[i],1);\n    }\n    for(int i=1;i<=n-5;i++){\n        upd(h[i],-1);\n        for(int j=i+1;j<=n;j++){\n            upd(h[j],-1);\n            for(int k=0;k<4;k++){\n                ll res=1;\n                for(int l=0;l<4;l++){\n                    ll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n                    v[l]=Hash(tmp);\n                    if(!mp.count(v[l]))\n                        goto to;\n                }\n                for(int l=0;l<4;l++){\n                    res*=mp[v[l]];\n                    upd(v[l],-1);\n                }\n                ans+=res;\n                for(int l=0;l<4;l++)\n                    upd(v[l],1);\n                to: ;\n            }\n            upd(h[j],1);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nunordered_map < ll, int > mp;\nint n;\nconst int maxN = 405;\nvector < int > c[maxN];\nvoid transform(vector < int >& a) {\n    int ans[4];\n    for (int j = 0; j < 4; j++) {\n        ans[j] = a[j];\n    }\n    for (int i = 1; i < 4; i++) {\n        int b[4];\n        for (int j = 0; j < 4; j++) {\n            b[j] = a[(i + j) % 4];\n        }\n        for (int j = 0; j < 4; j++) {\n            if (ans[j] != b[j]) {\n                if (ans[j] > b[j]) {\n                    for (int k = 0; k < 4; k++) {\n                        ans[k] = b[k];\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (int j = 0; j < 4; j++) {\n        a[j] = ans[j];\n    }\n}\nll val[maxN];\nint cnt[maxN];\nint get(vector < int >& a) {\n    int f = 0;\n    for (int j = 0; j < 4; j++) {\n        bool ok = true;\n        for (int p = 0; p < 4; p++) {\n            if (a[p] != a[(j + p) % 4]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) f++;\n    }\n    assert(f >= 1);\n    return f;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n//    n = 400;\n    for (int i = 0; i < n; i++) {\n        c[i].resize(4);\n        for (int j = 0; j < 4; j++) {\n            cin >> c[i][j];\n//            c[i][j] = 0;\n        }\n        transform(c[i]);\n        val[i] = 0;\n        for (int j = 0; j < 4; j++) {\n            val[i] = 1000 * val[i] + c[i][j];\n        }\n        mp[val[i]]++;\n    }\n    ll ans = 0;\n    for (int first = 0; first < n; first++) {\n        for (int rot1 = 0; rot1 < 1; rot1++) {\n            for (int second = first + 1; second < n; second++) {\n//                if (first == second) continue;\n                for (int rot2 = 0; rot2 < 4; rot2++) {\n                    vector < int > f1, f2;\n                    for (int p = 0; p < 4; p++) {\n                        f1.emplace_back(c[first][(p + rot1) % 4]);\n                        f2.emplace_back(c[second][(p + rot2) % 4]);\n                    }\n                    vector < vector < int > > r;\n                    r.push_back({f1[0], f2[1], f2[0], f1[1]});\n                    r.push_back({f1[1], f2[0], f2[3], f1[2]});\n                    r.push_back({f2[3], f2[2], f1[3], f1[2]});\n                    r.push_back({f2[1], f1[0], f1[3], f2[2]});\n                    for (int p = 0; p < 4; p++) {\n                        transform(r[p]);\n                    }\n                    ll ways = 1;\n                    for (int gg = 0; gg < 4; gg++) {\n                        bool ok = true;\n                        for (int vv = 0; vv < gg; vv++) {\n                            if (r[vv] == r[gg]) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if (!ok) continue;\n                        int z = 1;\n                        for (int vv = gg + 1; vv < 4; vv++) {\n                            if (r[vv] == r[gg]) z++;\n                        }\n                        int per = get(r[gg]);\n                        ll his_val = 0;\n                        for (int al = 0; al < 4; al++) {\n                            his_val = 1000 * his_val + r[gg][al];\n                        }\n                        if (!mp.count(his_val)) {\n                            ways = 0;\n                            break;\n                        }\n                        int total = mp[his_val];\n                        total *= per;\n                        if (his_val == val[first]) total -= per;\n                        if (his_val == val[second]) total -= per;\n                        for (int m = 1; m <= z; m++) {\n                            int cnt_now = (total - (m - 1) * per);\n                            cnt_now = max(cnt_now, 0);\n                            ways *= cnt_now;\n                        }\n                    }\n                    ans += ways;\n                }\n            }\n        }\n    }\n    assert(ans % 3 == 0);\n    cout << ans / 3;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define INF 2147483647\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\n#define _ 0\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nnamespace Mymath{\n\tLL qp(LL x,LL p,LL mod){\n\t\tLL ans=1;\n\t\twhile (p){\n\t\t\tif (p&1) ans=ans*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tp>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tLL inv(LL x,LL mod){\n\t\treturn qp(x,mod-2,mod);\n\t}\n\tLL C(LL N,LL K,LL fact[],LL mod){\n\t\treturn fact[N]*inv(fact[K],mod)%mod*inv(fact[N-K],mod)%mod;\n\t}\n\ttemplate <typename Tp> Tp gcd(Tp A,Tp B){\n\t\tif (B==0) return A;\n\t\treturn gcd(B,A%B);\n\t}\n\ttemplate <typename Tp> Tp lcm(Tp A,Tp B){\n\t\treturn A*B/gcd(A,B);\n\t}\n};\nnamespace fwt{\n\tusing namespace Mymath;\n\tvoid FWT(int a[],int n,LL mod)\n\t{\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;\n\t                //xor:a[i+j]=x+y,a[i+j+d]=x-y;\n\t                //and:a[i+j]=x+y;\n\t                //or:a[i+j+d]=x+y;\n\t            }\n\t}\n\n\tvoid UFWT(int a[],int n,LL mod)\n\t{\n\t\tLL rev=inv(2,mod);\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;\n\t                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n\t                //and:a[i+j]=x-y;\n\t                //or:a[i+j+d]=y-x;\n\t            }\n\t}\n\tvoid solve(int a[],int b[],int n,LL mod)\n\t{\n\t    FWT(a,n,mod);\n\t    FWT(b,n,mod);\n\t    for(int i=0;i<n;i++) a[i]=1LL*a[i]*b[i]%mod;\n\t    UFWT(a,n,mod);\n\t}\n};\nnamespace Maxflow{\n\tconst int Maxn=1005;\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tedge(int _to,int _rev,int _cap){\n\t\t\tto=_to,rev=_rev,cap=_cap;\n\t\t}\n\t};\n\tint src=1002,snk=1003;\n\tvector<edge> G[Maxn];\n\tint dist[Maxn],seen[Maxn];\n\tint n;\n\tvoid Clear(){\n\t\tfor (int i=0;i<Maxn;i++) G[i].clear();\n\t}\n\tvoid bfs(int s){\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=-1;\n\t\tdist[s]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()){\n\t\t\tint x=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tedge &e=G[x][i];\n\t\t\t\tif (e.cap && dist[e.to]==-1){\n\t\t\t\t\tdist[e.to]=dist[x]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int now,int dest,int fl){\n\t\tif (now==dest) return fl;\n\t\tfor (int &i=seen[now];i<G[now].size();i++){\n\t\t\tedge &ed=G[now][i];\n\t\t\tif (ed.cap && dist[ed.to]==dist[now]+1){\n\t\t\t\tint f=dfs(ed.to,dest,min(fl,ed.cap));\n\t\t\t\tif (f){\n\t\t\t\t\ted.cap-=f;\n\t\t\t\t\tG[ed.to][ed.rev].cap+=f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dinic(int s=src,int t=snk){\n\t\tint ret=0;\n\t\twhile (1){\n\t\t\tmemset(seen,0,sizeof(seen));\n\t\t\tbfs(s);\n\t\t\tif (dist[t]==-1) return ret;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\twhile(f){\n\t\t\t\tret+=f;\n\t\t\t\tf=dfs(s,t,INF);\n\t\t\t}\n\t\t}\n\t}\n};\nnamespace Geometry{\n\tstruct iP{\n\t\tLL x,y;\n\t\tiP(LL _x,LL _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tiP(){\n\t\t\tx=y=0;\n\t\t}\n\t\tiP operator +(iP p){\n\t\t\treturn iP(x+p.x,y+p.y);\n\t\t}\n\t\tiP operator -(iP p){\n\t\t\treturn iP(x-p.x,y-p.y);\n\t\t}\n\t\tiP operator *(LL k){\n\t\t\treturn iP(x*k,y*k);\n\t\t}\n\t\tLL det(iP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tLL dot(iP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tLL dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const iP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tstruct dP{\n\t\tdouble x,y;\n\t\tdP(double _x,double _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tdP(){\n\t\t\tx=y=0.0;\n\t\t}\n\t\tdP operator +(dP p){\n\t\t\treturn dP(x+p.x,y+p.y);\n\t\t}\n\t\tdP operator -(dP p){\n\t\t\treturn dP(x-p.x,y-p.y);\n\t\t}\n\t\tdP operator *(double k){\n\t\t\treturn dP(x*k,y*k);\n\t\t}\n\t\tdouble det(dP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tdouble dot(dP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tdouble dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const dP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tvector<iP> convex_hull(iP X[],int l){\n\t\t#define sz ret.size()\n\t\tvector<iP> ret;\n\t\tsort(X+1,X+1+l);\n\t\tret.pb(X[1]);\n\t\tfor (int i=2;i<=l;i++){\n\t\t\twhile (sz>=2 && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\tint rs=ret.size()+1;\n\t\tfor (int i=l-1;i>=1;i--){\n\t\t\twhile (sz>=rs && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst int Maxn=405;\nint c[Maxn][4];\nint n;\nint now[4][4];\nint cc[Maxn][4];\nLL V[4];\nLL ha[Maxn][4];\nLL dp[16],dp2[16];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t}\n\t\tfor (int st=0;st<4;st++){\n\t\t\tha[i][st]=0;\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tha[i][st]*=1000LL;\n\t\t\t\tha[i][st]+=c[i][(st+k)%4];\n\t\t\t}\n\t\t//\tcout<<ha[i][st]<<endl;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tfor (int k=0;k<4;k++){\n//\t\t\t\tbool flag=true;\n\t\t\t\tnow[0][0]=c[j][k];\n\t\t\t\tnow[0][1]=c[j][(k+3)%4];\n\t\t\t\tnow[0][2]=c[i][1];\n\t\t\t\tnow[0][3]=c[i][0];\n\t\t\t\t\n\t\t\t\tnow[1][0]=c[j][(k+3)%4];\n\t\t\t\tnow[1][1]=c[j][(k+2)%4];\n\t\t\t\tnow[1][2]=c[i][2];\n\t\t\t\tnow[1][3]=c[i][1];\n\t\t\t\t\n\t\t\t\tnow[2][0]=c[j][(k+2)%4];\n\t\t\t\tnow[2][1]=c[j][(k+1)%4];\n\t\t\t\tnow[2][2]=c[i][3];\n\t\t\t\tnow[2][3]=c[i][2];\n\t\t\t\t\n\t\t\t\tnow[3][0]=c[j][(k+1)%4];\n\t\t\t\tnow[3][1]=c[j][(k)%4];\n\t\t\t\tnow[3][2]=c[i][0];\n\t\t\t\tnow[3][3]=c[i][3];\n\t\t\t\t\n\t\t\t\tfor (int l=0;l<4;l++){\n\t\t\t\t\tV[l]=0;\n\t\t\t\t\tfor (int o=0;o<4;o++){\n\t\t\t\t\t\tV[l]=V[l]*1000+now[l][o];\n\t\t\t\t\t}\n\t\t\t\t\t//if (i==1 && j==5) cout<<k<<' '<<V[l]<<endl;\n\t\t\t\t//\tcout<<V[l]<<endl;\n\t\t\t\t}\n\t\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t\tdp[0]=1;\n\t\t\t\tfor (int l=i+1;l<=n;l++){\n\t\t\t\t\tif (l==i || l==j) continue;\n\t\t\t\t\tmemset(dp2,0,sizeof(dp2));\n\t\t\t\t\tfor (int jj=0;jj<4;jj++){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\tfor (int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\tif (ha[l][kk]==V[jj]) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (cnt){\n\t\t\t\t\t\t//\tcout<<cnt<<endl;\n\t\t\t\t\t\t\tfor (int q=15;q>=0;q--){\n\t\t\t\t\t\t\t\tif (q>>jj&1){\n\t\t\t\t\t\t\t\t\tdp2[q]+=dp[q^(1<<jj)]*cnt;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int jj=0;jj<16;jj++) dp[jj]+=dp2[jj];\n\t\t\t\t}\n\t\t\t\t//cout<<dp[15]<<endl;\n\t\t\t\tans+=dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntemplate<typename A, typename B> inline ostream& operator<< (ostream& out, const pair<A, B>& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\ntemplate<typename T> inline ostream& operator<< (ostream& out, const vector<T>& a) { out << \"[\"; forn(i, sz(a)) { if (i) out << ','; out << ' ' << a[i]; } return out << \" ]\"; } \ntemplate<typename T> inline ostream& operator<< (ostream& out, const set<T>& a) { return out << vector<T>(all(a)); }\ntemplate<typename X, typename Y> inline ostream& operator<< (ostream& out, const map<X, Y>& a) { return out << vector<pair<X, Y>>(all(a)); }\ntemplate<typename T> inline ostream& operator<< (ostream& out, pair<T*, int> a) { return out << vector<T>(a.x, a.x + a.y); }\n\ninline ld gett() { return ld(clock()) / CLOCKS_PER_SEC; }\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\n#ifdef SU1\n#define LOG\n#endif\n\nint n;\nconst int N = 500;\nint c[N][4];\n\nbool read() {\n\tif (!(cin >> n))\n\t\treturn false;\n\tforn(i, n)\n\t\tforn(j, 4)\n\t\t\tassert(cin >> c[i][j]);\n\treturn true;\n}\n\nvector <int> rotate(vector <int> v) {\n\tvector <int> res = v;\n\tforn(i, sz(v))\n\t\tres[(i + 1) % sz(v)] = v[i];\n\treturn res;\n}\n\nint deg(vector <int> v) {\n\tint res = 0;\n\tvector <int> x = v;\n\tforn(i, 4) {\n\t\tif (x == v)\n\t\t\tres++;\n\t\tx = rotate(x);\n\t}\n\treturn res;\n}\n\nbool same(vector <int> v, vector <int> u) {\n\tvector <int> x = v;\n\tforn(i, 4) {\n\t\tif (x == u)\n\t\t\treturn true;\n\t\tx = rotate(x);\n\t}\n\treturn false;\n}\n\nvector <int> mv(int a, int b, int c, int d) {\n\tvector <int> res(4);\n\tres[0] = a;\n\tres[1] = b;\n\tres[2] = c;\n\tres[3] = d;\n\treturn res;\n}\n\nmap <li, int> cnt;\n\nvoid inccnt(vector <int> x, int delta) {\n\tli v = 0;\n\tfor (auto c: x)\n\t\tv = v * 1000 + c;\n\tcnt[v] += delta;\n}\n\nint getcnt(vector <int> x) {\n\tli v = 0;\n\tfor (auto c: x)\n\t\tv = v * 1000 + c;\n\tif (!cnt.count(v))\n\t\treturn 0;\n\treturn cnt[v];\n}\n\nvoid inccnt(int i, int delta) {\n\tvector <int> x = vector <int> (c[i], c[i] + 4);\n\tforn(_, 4) {\n\t\tx = rotate(x);\n\t\tinccnt(x, delta);\n\t}\n}\n\nvector <int> vs[4];\n\nvoid solve() {\n\tcnt.clear();\n\tforn(i, n)\n\t\tinccnt(i, +1);\n\n\tli res = 0;\n\tforn(i, n) {\n\t\tvector <int> ci = vector <int> (c[i], c[i] + 4);\n\t\tinccnt(i, -1);\n/*\t\tcerr << \"-----\" << endl;\n\t\tfor (auto x: cnt)\n\t\t\tcerr << x.y << endl;\n\t\tcerr << \"-----\" << endl;*/\n\t\tfore(j, i + 1, n) {\n\t\t\tinccnt(j, -1);\n\t\t\tvector <int> cj = vector <int> (c[j], c[j] + 4);\n\t\t\tforn(_, 4) {\n\t\t\t\tcj = rotate(cj);\n\t\t\t\tvs[0] = mv(ci[0], cj[1], cj[0], ci[1]);\n\t\t\t\tvs[1] = mv(ci[0], ci[3], cj[2], cj[1]);\n\t\t\t\tvs[2] = mv(ci[1], cj[0], cj[3], ci[2]);\n\t\t\t\tvs[3] = mv(ci[3], ci[2], cj[3], cj[2]);\n\t\t\t\tli ans = 1;\n\t\t\t\tforn(k, 4) {\n\t\t\t\t\tli cur = getcnt(vs[k]);\n\t\t\t\t\tint d = deg(vs[k]);\n\t\t\t\t\tforn(t, k) {\n\t\t\t\t\t\tif (same(vs[t], vs[k]))\n\t\t\t\t\t\t\tcur -= d;\n\t\t\t\t\t}\n\t\t\t\t\tif (cur > 0)\n\t\t\t\t\t\tans *= cur;\n\t\t\t\t\telse\n\t\t\t\t\t\tans = 0;\n\t\t\t\t}\n/*\t\t\t\tif (ans)\n\t\t\t\t\tcerr << i << \" \" << j << \" \" << _ << \" \" << ans << endl;*/\n\t\t\t\tres += ans;\n\t\t\t}\n\t\t\tinccnt(j, +1);\n\t\t}\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n#ifdef SU1\n    assert(freopen(\"input.txt\", \"rt\", stdin));\n    //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n    \n    cout << setprecision(10) << fixed;\n    cerr << setprecision(5) << fixed;\n\n    while (read()) {\n\t\tld stime = gett();\n\t\tsolve();\n\t\tcerr << \"Time: \" << gett() - stime << endl;\n\t\t//break;\n\t}\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nll rot(ll c, int r){\n    ll p[4];\n    FORR(i,3,0){\n        p[i] = c % 1000;\n        c /= 1000;\n    }\n    ll ret = 0;\n    REP(i,4){\n        ret = 1000 * ret + p[(i+r)%4];\n    }\n    return ret;\n}\n\nll col(ll c, int x){\n    REP(i,3-x) c /= 1000;\n    return c % 1000;\n}\n\nll make(ll a, ll b, ll c, ll d){\n    return 1000000000LL * a + 1000000 * b + 1000 * c + d;\n}\n\nll calc(VVL c){\n    int n = c.size();\n    VVL dp(n+1, VL(16));\n    dp[0][0] = 1;\n    REP(i,n) REP(mask,16){\n        dp[i+1][mask] += dp[i][mask];\n        REP(j,4){\n            if ((mask >> j) & 1) continue;\n            dp[i+1][mask | (1 << j)] += dp[i][mask] * c[i][j];\n        }\n    }\n\n    // REP(i,n){\n    //     REP(j,4) cout << c[i][j] << \" \";\n    //     cout<< endl;\n    // }\n\n    // REP(i,n+1){\n    //     REP(j,16) cout << dp[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n\n    return dp[n][15];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    VL c(n);\n    REP(i,n){\n        REP(j,4){\n            ll x;\n            cin >> x;\n            c[i] = 1000 * c[i] + x;\n        }\n    }\n\n    ll ans = 0;\n    REP(i,n) REP(j,i) REP(r,4){\n        ll c1 = c[i], c2 = rot(c[j], r);\n        ll cs[4];\n        cs[0] = make(col(c1,1), col(c1,0), col(c2,1), col(c2,0));\n        cs[1] = make(col(c1,2), col(c1,1), col(c2,0), col(c2,3));\n        cs[2] = make(col(c1,3), col(c1,2), col(c2,3), col(c2,2));\n        cs[3] = make(col(c1,0), col(c1,3), col(c2,2), col(c2,1));\n\n        VVL cnt;\n        REP(k,n){\n            if (k == i || k == j) continue;\n            VL tmp(4);\n            REP(x,4) REP(y,4) if (rot(c[k], y) == cs[x]) tmp[x]++;\n            cnt.push_back(tmp);\n        }\n\n        ans += calc(cnt);\n    }\n    cout << ans / 3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=410;\nstruct Tile{\n\tconst static int D=4;\n\tint a[D];\n\tinline Tile nxt(){\n\t\treturn (Tile){a[1],a[2],a[3],a[0]};\n\t}\n\tinline friend bool operator < (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t\t}\n\t\treturn false;\n\t}\n}tile[N];\nmap<Tile,int>m;\ninline void add(Tile x,int v){\n\tfor(int i=0;i<Tile::D;i++,x=x.nxt()){\n\t\tm[x]+=v;\n\t}\n}\ninline bool vis(Tile x){\n\treturn m.find(x)!=m.end();\n}\nint main(){\n\tint n=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ttile[i]=(Tile){ni,ni,ni,ni};\n\t\tadd(tile[i],1);\n\t}\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tadd(tile[i],-1);\n\t\tint *a=tile[i].a;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint *b=tile[j].a;\n\t\t\tadd(tile[j],-1);\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\ttile[j]=tile[j].nxt();\n\t\t\t\tTile f1=(Tile){a[1],a[0],b[0],b[3]};\n\t\t\t\tTile f2=(Tile){a[2],a[1],b[3],b[2]};\n\t\t\t\tTile f3=(Tile){a[3],a[2],b[2],b[1]};\n\t\t\t\tTile f4=(Tile){a[0],a[3],b[1],b[0]};\n\t\t\t\tif(!(vis(f1)&&vis(f2)&&vis(f3)&&vis(f4)))continue;\n\t\t\t\tlint tmp=1;\n\t\t\t\ttmp*=m[f1],add(f1,-1);\n\t\t\t\ttmp*=m[f2],add(f2,-1);\n\t\t\t\ttmp*=m[f3],add(f3,-1);\n\t\t\t\ttmp*=m[f4];\n\t\t\t\tadd(f1,1),add(f2,1),add(f3,1);\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tadd(tile[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<boost/variant.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<boost::variant<bool, ll, int, string, double, char*, const char*>> any;\ntemplate<typename T> inline void pr(const vector<T> &xs){\n\tfor(int i=0; i<xs.size()-1; i++) cout<<xs[i]<<\" \";\n\t(xs.empty()?cout:(cout<<xs[xs.size()-1]))<<endl;\n}\ntemplate<typename T> inline void debug(const vector<T> &xs){\n#ifdef DEBUG\n\tpr(xs);\n#endif\n}\n\nll canonical(const vector<int> &c){\n\tll x = 1LL<<62;\n\tfor(int i=0; i<4; i++){\n\t\tll t = 0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tt = (t<<10) + c[(i+j)%4];\n\t\t}\n\t\tx = min(x, t);\n\t}\n\treturn x;\n}\n\nint count_greater(const vector<int> &v, int n, int m){\n\tauto it = lower_bound(v.begin(), v.end(), n);\n\tint x = v.end()-it;\n\tif(x>0&&*it==n) x--;\n\tif(binary_search(v.begin(), v.end(), m)) x--;\n\treturn x;\n}\n\nint mul(ll x){\n\tll c0 = (x>>30)&((1<<10)-1);\n\tll c1 = (x>>20)&((1<<10)-1);\n\tll c2 = (x>>10)&((1<<10)-1);\n\tll c3 = (x>>0)&((1<<10)-1);\n\tif(c0==c1&&c1==c2&&c2==c3) return 4;\n\tif(c0==c2&&c1==c3) return 2;\n\telse return 1;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tvector<vector<int>> C(N, vector<int>(4));\n\tfor(int i=0; i<N; i++) for(int k=0; k<4; k++) cin >> C[i][k];\n\n\tmap<ll, vector<int>> faces;\n\tfor(int i=0; i<N; i++){\n\t\tfaces[canonical(C[i])].push_back(i);\n\t}\n\n\tll ans = 0;\n\tfor(int i=0; i<N; i++) for(int j=i+1; j<N; j++) for(int k=0; k<4; k++){\n\t\tll side[4];\n\t\tfor(int l=0; l<4; l++){\n\t\t\tside[l] = canonical({C[i][l], C[j][(k+3-l+1)%4], C[j][(k+3-l)%4], C[i][(l+1)%4]});\n\t\t}\n\t\tsort(side, side+4);\n\t\tll x[4];\n\t\tll a = 1;\n\t\tfor(int l=0; l<4; l++){\n\t\t\tx[l] = count_greater(faces[side[l]], i, j);\n\t\t\ta *= mul(side[l]);\n\t\t}\n\t\tif(side[0]==side[1]&&side[1]==side[2]&&side[2]==side[3]){\n\t\t\ta *= x[0]*(x[0]-1)*(x[0]-2)*(x[0]-3);\n\t\t} else if(side[0]==side[1]&&side[1]==side[2]){\n\t\t\ta *= x[0]*(x[0]-1)*(x[0]-2)*x[3];\n\t\t} else if(side[1]==side[2]&&side[2]==side[3]){\n\t\t\ta *= x[0]*x[1]*(x[1]-1)*(x[1]-2);\n\t\t} else if(side[0]==side[1]&&side[2]==side[3]){\n\t\t\ta *= x[0]*(x[0]-1)*x[2]*(x[2]-1);\n\t\t} else if(side[0]==side[1]){\n\t\t\ta *= x[0]*(x[0]-1)*x[2]*x[3];\n\t\t} else if(side[1]==side[2]){\n\t\t\ta *= x[0]*x[1]*(x[1]-1)*x[3];\n\t\t} else if(side[2]==side[3]){\n\t\t\ta *= x[0]*x[1]*x[2]*(x[2]-1);\n\t\t} else {\n\t\t\ta *= x[0]*x[1]*x[2]*x[3];\n\t\t}\n\t\tdebug(any{i, j, k, a, x[0], x[1], x[2], x[3]});\n\t\tans += a;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 400;\nmap<LL,LL> occ;\nLL arr[N + 5][4];\nLL f[N + 5];\nLL tmp[4];\n\nvoid shifting(LL x, int add) { //rotate \n\tfor(int i = 0;i < 4;i++) {\n\t\tocc[x] += add;\n\t\tx = ((x >> 10) | ((x & 1023) << 30));\n\t}\n}\n\nLL hash(LL a, LL b, LL c, LL d) { //hashing four corner color into one integer\n\treturn (a << 30LL) | (b << 20LL) | (c << 10LL) | d;\n}\n\n\nint main(){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i = 0;i < n;i++) {\n\t\tfor(int j = 0;j < 4;j++) cin>>arr[i][j];\n\t\tf[i] = hash(arr[i][0], arr[i][1], arr[i][2], arr[i][3]);\n\t\tshifting(f[i], 1);\n\t}\n\tLL tot = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\tshifting(f[i], -1); //fixing front side\n\t\tfor(int j = i + 1;j < n;j++) {\n\t\t\tshifting(f[j], -1); //fixing back side\n\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\ttmp[0] = hash(arr[i][3], arr[i][2], arr[j][(1 + k) % 4], arr[j][k % 4]);\n\t\t\t\ttmp[1] = hash(arr[i][2], arr[i][1], arr[j][(2 + k) % 4], arr[j][(k + 1) % 4]);\n\t\t\t\ttmp[2] = hash(arr[i][1], arr[i][0], arr[j][(3 + k) % 4], arr[j][(k + 2) % 4]);\n\t\t\t\ttmp[3] = hash(arr[i][0], arr[i][3], arr[j][(k) % 4], arr[j][(k + 3) % 4]);\n\t\t\t\tLL res = 1;\n\t\t\t\tfor(int i = 0;i < 4;i++) {\n\t\t\t\t\tres *= occ[tmp[i]];\n\t\t\t\t\tshifting(tmp[i], -1);\n\t\t\t\t}\n\t\t\t\ttot += res;\n\t\t\t\tfor(int i = 0;i < 4;i++) shifting(tmp[i], 1);\n\t\t\t}\n\t\t\tshifting(f[j], 1); \n\t\t}\n\t}\n\tcout<<tot<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// arc062_e\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../arg.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    int N;\n    cin >> N;\n\n    vector<vector<int>> Colors;\n    Colors.assign(N, vector<int>(4,0));\n\n    map<P, vector<pair<int, P>>> mp;\n\n    using color = pair<P, P>;\n    map<color, vector<int>> mp2;\n\n    REP(i, N){\n\n        vector<int>& C = Colors[i];\n        REP(j, 4) cin >> C[j];\n\n        // 2週にしとく\n        REP(j, 4) C.emplace_back(C[j]);\n\n        REP(j, 4) {\n            mp[P(C[j], C[j+1])].emplace_back(i, P(C[j+3], C[j+2]));\n\n            color c{{C[j], C[j+1]}, {C[j+2], C[j+3]}};\n            mp2[c].emplace_back(i);\n        }\n\n    }\n\n    /*\n     *   □\n     * □ □ □ □\n     *   □\n     *   真ん中が一番小さい数字になるようにする\n     */\n\n    ll ans = 0;\n    int cnt = 0;\n    REP(i, N){\n\n        vector<int>& C = Colors[i];\n\n        for (auto a: mp[P(C[3], C[2])])\n        for (auto b: mp[P(C[2], C[1])])\n        for (auto c: mp[P(C[1], C[0])])\n        for (auto d: mp[P(C[0], C[3])]) {\n//            cnt++;\n            int aa = a.first;\n            int bb = b.first;\n            int cc = c.first;\n            int dd = d.first;\n\n            // 今見てるやつが一番小さくないとだめ\n            if (aa <= i || bb <= i || cc <= i || dd <= i) continue;\n\n            // 全部違くないとだめ\n            set<int> st{aa,bb,cc,dd};\n            if (st.size() != 4) continue;\n\n            int z1 = a.second.first;\n            int w0 = a.second.second;\n            int w1 = b.second.first;\n            int x0 = b.second.second;\n            int x1 = c.second.first;\n            int y0 = c.second.second;\n            int y1 = d.second.first;\n            int z0 = d.second.second;\n\n            if (x0 != x1 || y0 != y1 || z0 != z1 || w0 != w1) continue;\n\n            color ura{{x0, y0}, {z0, w0}};\n\n            for (auto idx: mp2[ura]){\n//                cnt++;\n                if (idx <= i || idx == aa || idx == bb || idx == cc || idx == dd) continue;\n                ans++;\n//                print(i, mp2[ura], a.first, b.first, c.first, d.first, idx);\n            }\n\n        }\n    }\n\n    print(ans);\n//    print(cnt);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nmap<LL,int> f;\nint c[405][4];\nLL a[405];\nLL Ch(LL x0,int x1,int x2,int x3){\n\treturn x0<<30|x1<<20|x2<<10|x3;\n}\nvoid add(LL x,int v){\n\tfor (int i=0;i<4;i++){\n\t\tx=(x>>10)+((x&1023)<<30);\n\t\tf[x]+=v;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&c[i][j]),a[i]=a[i]<<10|c[i][j];\n\t\tadd(a[i],1);\n\t}\n\tLL ans=0;\n\tfor (int i=1;i<=n-5;i++){\n\t\tadd(a[i],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tadd(a[j],-1);\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tLL A[4];\n\t\t\t\tA[0]=Ch(c[i][0],c[j][k],c[j][(k+3)&3],c[i][1]);\n\t\t\t\tA[1]=Ch(c[i][1],c[j][(k+3)&3],c[j][(k+2)&3],c[i][2]);\n\t\t\t\tA[2]=Ch(c[i][2],c[j][(k+2)&3],c[j][(k+1)&3],c[i][3]);\n\t\t\t\tA[3]=Ch(c[i][3],c[j][(k+1)&3],c[j][k],c[i][0]);\n\t\t\t\tLL cnt=1;\n\t\t\t\tfor (int l=0;l<4;l++) cnt*=f[A[l]],add(A[l],-1);\n\t\t\t\tfor (int l=0;l<4;l++) add(A[l],1);\n\t\t\t\tans+=cnt;\n\t\t\t}\n\t\t\tadd(a[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int Nmax = 400;\nint N, C[4][Nmax];\n\nlong encode(int c0,int c1,int c2,int c3){\n\tlong base=1000;\n\tlong x = c3+base*c2+base*base*c1+base*base*base*c0;\n\tlong m = x;\n\tfor(int i=0; i<3; i++){\n\t\tx = x/base+(x%base)*base*base*base;\n\t\tm = min(m, x);\n\t}\n\treturn m;\n}\n\nint rot(long code){\n\tint c[4];\n\tint base = 1000;\n\tfor(int i=0; i<4; i++) {\n\t\tc[i] = code%base;\n\t\tcode /= base;\n\t}\n\tif(c[0]==c[1]&&c[1]==c[2]&&c[2]==c[3]) return 4;\n\tif(c[0]==c[2]&&c[1]==c[3]) return 2;\n\treturn 1;\n}\n\nlong pow(long a,long n){\n\tif(n==0) return 1;\n\tif(n%2) return pow(a,n-1)*a;\n\treturn pow(a,n/2);\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> C[j][i];\n\t\t}\n\t}\n\n\tmap<long, vector<int> > e2f;\n\tfor(int i=0; i<N; i++){\n\t\tlong x = encode(C[0][i],C[1][i],C[2][i],C[3][i]);\n\t\te2f[x].push_back(i);\n\t}\n\n\tlong ans = 0;\n\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tlong f[4];\n\t\t\t\tf[0] = encode(C[1][i],C[0][i],C[(k+0)%4][j],C[(k+3)%4][j]);\n\t\t\t\tf[1] = encode(C[2][i],C[1][i],C[(k+3)%4][j],C[(k+2)%4][j]);\n\t\t\t\tf[2] = encode(C[3][i],C[2][i],C[(k+2)%4][j],C[(k+1)%4][j]);\n\t\t\t\tf[3] = encode(C[0][i],C[3][i],C[(k+1)%4][j],C[(k+0)%4][j]);\n\t\t\t\tif(e2f.find(f[0]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[1]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[2]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[3]) == e2f.end()) continue;\n\t\t\t\t/*\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tcout << f[0] << endl;\n\t\t\t\tcout << f[1] << endl;\n\t\t\t\tcout << f[2] << endl;\n\t\t\t\tcout << f[3] << endl;\n\t\t\t\t*/\n\t\t\t\tlong c[4];\n\t\t\t\tlong a=0;\n\t\t\t\tfor(int m=0; m<4; m++){\n\t\t\t\t\tc[m]=0;\n\t\t\t\t\tfor(auto l=e2f[f[m]].begin(); l!=e2f[f[m]].end(); l++){\n\t\t\t\t\t\t//cout << \" \" << *l << endl;\n\t\t\t\t\t\tif(*l==i || *l==j) continue;\n\t\t\t\t\t\tc[m]++;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << c[m] << \" \";\n\t\t\t\t}\n\t\t\t\tif(f[0]==f[1]&&f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=4){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*(c[0]-3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=2&&c[1]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*(c[1]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[3]){\n\t\t\t\t\tif(c[2]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[2]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[2]==f[3]){\n\t\t\t\t\tif(c[2]>=2){\n\t\t\t\t\t\ta = c[2]*(c[2]-1)*c[0]*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[3]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta = c[0]*c[1]*c[2]*c[3];\n\t\t\t\t}\n\t\t\t\tfor(int m=0; m<4; m++) a*=rot(f[m]);\n\t\t\t\t//cout << a << endl;\n\t\t\t\tans += a;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans/3 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nlong long int converter(const int a, const int b, const int c, const int d) {\n\treturn ((a * 1000 + b) * 1000 + c) * 1000 + d;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<short>>box(N, vector<short>(4));\n\tfor (auto &i : box)for (auto &j : i)cin >> j;\n\tlong long int ans = 0;\n\tunordered_map<long long int, int>mp;\n\tunordered_map<long long int, int>sz;\n\tunordered_map<long long int, int>oold;\n\tfor (int i = N - 5; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = N - 6; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<char>old(4, -1);\n\t\t\t\tvector<short>num(4, 0);\n\t\t\t\tvector<short>sum(4, 0);\n\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\tauto it = oold.find(converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4]));\n\t\t\t\t\tif (it != oold.end()) {\n\t\t\t\t\t\told[n] = it->second;\n\t\t\t\t\t\tsum[n] = mp[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t\tnum[n] = sz[converter(box[i][(1 + n) % 4], box[i][n], box[j][(k + 5 - n) % 4], box[j][(k + 4 - n) % 4])];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[j][m] && box[i][n] == box[j][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[j][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[j][(m + 3) % 4]) {\n\t\t\t\t\t\t\tsum[n]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\tfor (int l = i + 1; l < N; l++) {\n\t\t\t\t\tif (j == l)continue;\n\t\t\t\t\tfor (int n = 0; n < 4; n++) {\n\t\t\t\t\t\tfor (int m = 0; m < 4; m++) {\n\t\t\t\t\t\t\tif (box[i][(1 + n) % 4] == box[l][m] && box[i][n] == box[l][(m + 1) % 4] && box[j][(k + 5 - n) % 4] == box[l][(m + 2) % 4] && box[j][(k + 4 - n) % 4] == box[l][(m + 3) % 4]) {\n\t\t\t\t\t\t\t\tsum[n]++;\n\t\t\t\t\t\t\t\tif (old[n] != l) {\n\t\t\t\t\t\t\t\t\tnum[n]++;\n\t\t\t\t\t\t\t\t\told[n] = l;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tlong long int add = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tfor (int m = 0; m < l; m++) {\n\t\t\t\t\t\tif (old[l] == old[m] && num[l]) {\n\t\t\t\t\t\t\tsum[l] -= num[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd *= sum[l];\n\t\t\t\t}\n\t\t\t\tans += add;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tmp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\tif (mp[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] == 1) {\n\t\t\t\toold[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])] = i;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4]) == converter(box[i][k], box[i][(k + 1) % 4], box[i][(k + 2) % 4], box[i][(k + 3) % 4]))sz[converter(box[i][j], box[i][(j + 1) % 4], box[i][(j + 2) % 4], box[i][(j + 3) % 4])]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pw(x) (1ll << (x))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\n#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n\n//-----\nconst int N = 4e2 + 7;\nll nxt(ll d) { return d / 1000 + (d % 1000) * 1000000000; }\nunordered_map<ll, int > cnt;\nvoid chg(ll d, int v) { rep(i, 0, 4) { cnt[d] += v; d = nxt(d); } }\n\nll v2d(vi v) { ll d = 0; rep(i, 0, 4) d = d * 1000 + v[i]; return d; }\nvi d2v(ll d) { vi v(4); per(i, 0, 4) v[i] = d % 1000, d /= 1000; return v; }\n\nint n;\nll c[N];\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tcin >> n; \n\trep(i, 0, n) {\n\t\tvi v(4); rep(j, 0, 4) cin >> v[j];\n\t\tc[i] = v2d(v);\n\t\tchg(c[i], 1);\n\t}\n\tll ans = 0, rel = 0;\n\trep(i, 0, n) {\n\t\tchg(c[i], -1);\n\t\tll ci = c[i];\n\t\tvi a = d2v(ci);\n\t\trep(j, 0, n) if (j != i) {\n\t\t\tchg(c[j], -1);\n\t\t\tll cj = c[j];\n\t\t\trep(dj, 0, 4) {\n\t\t\t\tvi b = d2v(cj); cj = nxt(cj);\n\t\t\t\tll up = v2d({b[1], b[0], a[1], a[0]});\n\t\t\t\tll dn = v2d({a[3], a[2], b[3], b[2]});\n\t\t\t\tll lf = v2d({b[1], a[0], a[3], b[2]});\n\t\t\t\tll rt = v2d({a[1], b[0], b[3], a[2]});\n\t\t\t\tll tmp = 1;\n\t\t\t\ttmp *= cnt[up]; chg(up, -1);\n\t\t\t\ttmp *= cnt[dn]; chg(dn, -1);\n\t\t\t\ttmp *= cnt[lf]; chg(lf, -1);\n\t\t\t\ttmp *= cnt[rt]; \n\t\t\t\tans += tmp;\n\t\t\t\tll q = ans / 6;\n\t\t\t\trel += q;\n\t\t\t\tans -= q * 6;\n\t\t\t\tchg(lf, 1);\n\t\t\t\tchg(dn, 1);\n\t\t\t\tchg(up, 1);\n\t\t\t}\n\t\t\tchg(c[j], 1);\n\t\t}\n\t\tchg(c[i], 1);\n\t}\n\tcout << rel;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n;\n    cin >> n;\n    int c[405][4];\n    vector<int> v[405][4];\n    map<vector<int>, ll> mp;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++) cin >> c[i][j];\n        for(int j = 0; j < 4; j++){\n            for(int k = 0; k < 4; k++){\n                v[i][j].push_back(c[i][(j + k) % 4]);\n            }\n            mp[v[i][j]]++;\n        }\n    }\n    ll ans = 0;\n/*    for(auto itr = mp.begin(); itr != mp.end(); itr++){\n        vector<int> t = itr->first;\n        for(int q = 0; q < 4; q++) cout << t[q];\n        cout << \" \" << itr->second << endl;\n    }*/\n/*    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++){\n            for(int k = 0; k < 4; k++) cout << v[i][j][k];\n            cout << endl;\n        }\n        cout << endl;\n    }*/\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 4; j++){\n            mp[v[i][j]]--;\n        }\n        for(int j = i + 1; j < n; j++){\n            for(int k = 0; k < 4; k++){\n                mp[v[j][k]]--;\n            }\n            for(int k = 0; k < 4; k++){\n                vector<int> ver(8);\n                for(int l = 0; l < 4; l++) ver[l] = c[i][l];\n                for(int l = 4; l < 8; l++) ver[l] = c[j][(7 - l + k) % 4];\n                ll s = 1;\n                for(int l = 0; l < 4; l++){\n                    vector<int> r(4);\n                    r[0] = ver[l];\n                    r[1] = ver[(l + 3) % 4];\n                    r[2] = ver[(l + 3) % 4 + 4];\n                    r[3] = ver[l + 4];\n                    s *= mp[r];\n                    for(int m = 0; m < 4; m++){\n                        vector<int> t(4);\n                        for(int p = 0; p < 4; p++) t[p] = r[(p + m) % 4];\n                        mp[t]--;\n                    }\n                }\n                ans += s;\n                for(int l = 0; l < 4; l++){\n                    vector<int> r(4);\n                    r[0] = ver[l];\n                    r[1] = ver[(l + 3) % 4];\n                    r[2] = ver[(l + 3) % 4 + 4];\n                    r[3] = ver[l + 4];\n                    for(int m = 0; m < 4; m++){\n                        vector<int> t(4);\n                        for(int p = 0; p < 4; p++) t[p] = r[(p + m) % 4];\n                        mp[t]++;\n                    }\n                }\n            }\n            for(int k = 0; k < 4; k++){\n                mp[v[j][k]]++;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll ans;\nint n;\nstruct node{\n\tint a1,a2,a3,a4;\n\tnode() {}\n\tnode(int aa1,int aa2,int aa3,int aa4):a1(aa1),a2(aa2),a3(aa3),a4(aa4) {}\n\tbool operator <(const node &a) const {\n\t\tif(a1!=a.a1)\n\t\t\treturn a1<a.a1;\n\t\tif(a2!=a.a2)\n\t\t\treturn a2<a.a2;\n\t\tif(a3!=a.a3)\n\t\t\treturn a3<a.a3;\n\t\treturn a4<a.a4;\n\t}\n\tbool operator ==(const node &a) const{\n\t\tif(a1==a.a1&&a2==a.a2&&a3==a.a3&&a4==a.a4)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}t[MAXN];\nmap<node,ll> used;\nvoid solve(int b1,int b2,int b3,int b4){\n\tused[node(b1,b2,b3,b4)]++;\n}\nll check(node x,node y){\n\tll res=0;\n\tif(x==y)\n\t\tres++;\n\tint tx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\treturn res;\n}\t\nvoid count(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8){\n\t//PF(\"{%d %d %d %d %d %d %d %d}\\n\",b1,b2,b3,b4,b5,b6,b7,b8);\n\tnode x1=node(b1,b2,b6,b5);\n\tnode x2=node(b2,b3,b7,b6);\n\tnode x3=node(b3,b4,b8,b7);\n\tnode x4=node(b4,b1,b5,b8);\n\tnode sp1=node(b4,b3,b2,b1);\n\tnode sp2=node(b8,b7,b6,b5);\n\tll res1=used[x1];\n\tll res2=used[x2];\n\tll res3=used[x3];\n\tll res4=used[x4];\n\tres1=res1-check(sp1,x1)-check(sp2,x1);\n\tres2=res2-check(sp1,x2)-check(sp2,x2)-check(x1,x2);\n\tres3=res3-check(sp1,x3)-check(sp2,x3)-check(x1,x3)-check(x2,x3);\n\tres4=res4-check(sp1,x4)-check(sp2,x4)-check(x1,x4)-check(x2,x4)-check(x3,x4);\n\tans+=res1*res2*res3*res4;\n\t//PF(\"{%lld %lld %lld %lld %lld}\\n\",used[x1],res1,check(sp1,x1),check(sp2,x1),res4);\n}\nint main(){\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&t[i].a1,&t[i].a2,&t[i].a3,&t[i].a4);\n\t\tsolve(t[i].a4,t[i].a3,t[i].a2,t[i].a1);\n\t\tsolve(t[i].a3,t[i].a2,t[i].a1,t[i].a4);\n\t\tsolve(t[i].a2,t[i].a1,t[i].a4,t[i].a3);\n\t\tsolve(t[i].a1,t[i].a4,t[i].a3,t[i].a2);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a4,t[j].a3,t[j].a2,t[j].a1);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a3,t[j].a2,t[j].a1,t[j].a4);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a2,t[j].a1,t[j].a4,t[j].a3);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a1,t[j].a4,t[j].a3,t[j].a2);\t\n\t\t}\n\tPF(\"%lld\",ans/3ll);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint a[maxn], b[maxn], c[maxn], d[maxn];\nstd::unordered_map<ll, int> map;\nint n;\ninline ll pr(int a,int b,int c,int d) { return (ll) (a << 16 | b) << 32 | (c << 16 | d); }\ninline ll minpr(int a,int b,int c,int d) {\n\treturn std::min(std::min(pr(a, b, c, d), pr(b, c, d, a)), std::min(pr(c, d, a, b), pr(d, a, b, c)));\n}\ninline void swap(int & a,int & b,int & c,int & d) { int t = a; a = b, b = c, c = d, d = t; }\ninline void add(int a,int b,int c,int d,int v) { map[minpr(a, b, c, d)] += v; }\ninline int C(int x,int v) {\n\tif(v == 1) return x;\n\tif(v == 2) return x * (x - 1);\n\tif(v == 3) return x * (x - 1) * (x - 2);\n\treturn x * (x - 1) * (x - 2) * (x - 3);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tmap.rehash(1e6 + 7);\n\tcin >> n;\n\trep(i, 1, n) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tadd(a[i], b[i], c[i], d[i], 1);\n\t}\n\tll ans = 0;\n\trep(i, 1, n) rep(j, 1, i - 1) {\n\t\tadd(a[i], b[i], c[i], d[i], -1);\n\t\tadd(a[j], b[j], c[j], d[j], -1);\n\t\tfor(int t = 0;t < 4;++t) {\n\t\t\tstd::map<ll, int> mp;\n\t\t\t++ mp[minpr(b[j], a[j], b[i], a[i])];\n\t\t\t++ mp[minpr(a[j], d[j], c[i], b[i])];\n\t\t\t++ mp[minpr(d[j], c[j], d[i], c[i])];\n\t\t\t++ mp[minpr(c[j], b[j], a[i], d[i])];\n\t\t\tll mul = 1;\n\t\t\tfor(auto i : mp) {\n\t\t\t\tif(i.first >> 16 == i.first << 16 >> 16) mul <<= i.second;\n\t\t\t\tif(i.first >> 32 == i.first << 32 >> 32) mul <<= i.second;\n\t\t\t\tmul *= C(map[i.first], i.second);\n\t\t\t}\n\t\t\tans += mul;\n\t\t\tswap(a[i], b[i], c[i], d[i]);\n\t\t}\n\t\tadd(a[i], b[i], c[i], d[i], 1);\n\t\tadd(a[j], b[j], c[j], d[j], 1);\n\t}\n\tcout << ans / 3 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n;\nusing Panel = array<int, 4>;\n\nPanel rotate(Panel a) {\n  tie(a[0], a[1], a[2], a[3]) = make_tuple(a[1], a[2], a[3], a[0]);\n  return a;\n}\n\nPanel normalize(Panel a) {\n  Panel p[4];\n  for(int i = 0; i < 4; i++) {\n    p[i] = a;\n    a = rotate(a);\n  }\n  return *min_element(p, p + 4);\n}\n\nconst int N = 400;\n\nint rotcount(Panel a) {\n  auto b = a;\n  int res = 0;\n  for(int i = 0; i < 4; i++) {\n    b = rotate(b);\n    if(a == b) res++;\n  }\n  return res;\n}\n\nll fact[10];\nll comb[N + 1][10];\n\nPanel a[N];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n\n  map<Panel, int> cnt;\n  for(int i = 0; i < n; i++) {\n    cin >> a[i][0] >> a[i][1] >> a[i][2] >> a[i][3];\n    a[i] = normalize(a[i]);\n    cnt[a[i]]++;\n  }\n\n  comb[0][0] = 1;\n\n  for(int i = 1; i <= n; i++) for(int j = 0; j <= 9; j++) {\n    // Pascal's identity\n    if(j == 0) {\n      comb[i][j] = 1;\n      continue;\n    }\n    comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n  }\n\n  fact[0] = 1;\n  for(int i = 1; i <= 9; i++) fact[i] = fact[i-1] * i;\n\n  ll ans = 0;\n  for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) {\n    auto it = a[i];\n    for(int rot = 0; rot < 4; rot++) {\n      it = rotate(it);\n      map<Panel, int> target;\n      for(int k = 0; k < 4; k++) {\n        Panel f{it[(k + 1) % 4], it[k + 0], a[j][(4 - k) % 4], a[j][3 - k]};\n        f = normalize(f);\n        target[f]++;\n      }\n\n      int ng = 0;\n      ll res = 1;\n      for(auto &p : target) {\n        Panel pan;\n        int tar;\n        tie(pan, tar) = p;\n        int c = cnt[pan] - (pan == a[i]) - (pan == a[j]);\n        if(c < tar) {ng = 1; break;}\n        res *= comb[c][tar] * pow((ll) rotcount(pan), (ll) tar) * fact[tar];\n      }\n      if(ng) continue;\n      ans += res;\n    }\n  }\n  assert(ans % 3 == 0);\n  cout << ans/3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\ntypedef long long s64;\n\nstruct object\n{\n\tint a, b, c, d;\n\tobject() {}\n\tobject(const int &_a, const int &_b, const int &_c, const int &_d)\n\t\t: a(_a), b(_b), c(_c), d(_d) {}\n\n\tinline s64 value() const\n\t{\n\t\treturn ((s64)a << 30) | (b << 20) | (c << 10) | d;\n\t}\n\n\tinline object rotate() const\n\t{\n\t\treturn {b, c, d, a};\n\t}\n};\nmap<s64, int> all;\n\ninline void add(object cur, int delta)\n{\n\tfor (int k = 0; k < 4; ++k)\n\t\tall[(cur = cur.rotate()).value()] += delta;\n}\n\ninline int query(const object &a)\n{\n\treturn all[a.value()];\n}\n\ninline bool existed(const object &a)\n{\n\treturn all.find(a.value()) != all.end();\n}\n\nconst int MaxN = 400;\n\nint n;\nobject f[MaxN + 1];\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> f[i].a >> f[i].b;\n\t\tcin >> f[i].c >> f[i].d;\n\t\tadd(f[i], 1);\n\t}\n\n\ts64 res = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tadd(f[i], -1);\n\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tadd(f[j], -1);\n\n\t\t\tobject cur = f[j];\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t{\n\t\t\t\tobject f1(cur.b, cur.a, f[i].b, f[i].a);\n\t\t\t\tobject f2(cur.a, cur.d, f[i].c, f[i].b);\n\t\t\t\tobject f3(cur.d, cur.c, f[i].d, f[i].c);\n\t\t\t\tobject f4(cur.c, cur.b, f[i].a, f[i].d);\n\n\t\t\t\tif (!existed(f1) || !existed(f2) || !existed(f3) || !existed(f4))\n\t\t\t\t{\n\t\t\t\t\tcur = cur.rotate();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ts64 ways = 1;\n\t\t\t\tways *= query(f1), add(f1, -1);\n\t\t\t\tways *= query(f2), add(f2, -1);\n\t\t\t\tways *= query(f3), add(f3, -1);\n\t\t\t\tways *= query(f4);\n\n\t\t\t\tadd(f1, 1), add(f2, 1), add(f3, 1);\n\n\t\t\t\tres += ways;\n\n\t\t\t\tcur = cur.rotate();\n\t\t\t}\n\n\t\t\tadd(f[j], 1);\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst LL MAX = 1e9;\nconst int SIZE = 410;\nLL an;\nint d[SIZE][4];\nLL val[SIZE];\nmap<LL,int>H,C;\nvoid ADD(LL& x,LL v){\n    x=(x+v);\n}\nLL fix(LL x){\n    vector<LL>ker;\n    ker.PB(x);\n    LL mi=x;\n    REP(k,3){\n        LL tmp=x/MAX;\n        x=(x-tmp*MAX)*1000+tmp;\n        mi=min(mi,x);\n        ker.PB(x);\n    }\n    if(ker[0]==ker[3]&&ker[0]==ker[1]&&ker[2]==ker[3])\n        C[mi]=4;\n    else if(ker[0]==ker[2]&&ker[1]==ker[3])C[mi]=2;\n    else C[mi]=1;\n    return mi;\n}\nint main(){\n    DRI(N);\n    REP(i,N){\n        //printf(\"%d:%lld\\n\",i,an);\n        REP(j,4)\n            RI(d[i][j]);\n        REP(j,i){\n            H[val[j]]--;\n            REP(r,4){\n                map<LL,int>shik;\n                REP(k,4){\n                    LL v=0;\n                    v=v*1000+d[j][(r-k+4)&3];\n                    v=v*1000+d[j][(r-k+3)&3];\n                    v=v*1000+d[i][(k+1)&3];\n                    v=v*1000+d[i][k&3];\n                    shik[fix(v)]++;\n                }\n                LL my_v=1;\n                for(map<LL,int>::iterator it=shik.begin();it!=shik.end();it++){\n                    if(H.count(it->F)){\n                        LL nn=H[it->F];\n                        REP(ker,it->S){\n                            my_v=my_v*nn;\n                            nn--;\n                            my_v=my_v*C[it->F];\n                        }\n                    }\n                    else my_v=0;\n                }\n                ADD(an,my_v);\n            }\n            H[val[j]]++;\n        }\n        {\n            LL v=0;\n            REP(k,4)\n                v=v*1000+d[i][k];\n            val[i]=fix(v);\n            H[val[i]]++;\n        }\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\nint cc[500][4];\n\nstruct abcd {\n  int a, b, c, d;\n  abcd() {}\n  abcd(int _a, int _b, int _c, int _d) { a = _a; b = _b; c = _c; d = _d; }\n  bool operator < (const abcd & another) const {\n    if (a != another.a) return a < another.a;\n    if (b != another.b) return b < another.b;\n    if (c != another.c) return c < another.c;\n    return d < another.d;\n  };\n};\n\nint same(int a0, int a1, int a2, int a3, int b0, int b1, int b2, int b3) {\n  int cc = 0;\n  if (a0 == b0 && a1 == b1 && a2 == b2 && a3 == b3) cc ++;\n  if (a0 == b1 && a1 == b2 && a2 == b3 && a3 == b0) cc ++;\n  if (a0 == b2 && a1 == b3 && a2 == b0 && a3 == b1) cc ++;\n  if (a0 == b3 && a1 == b0 && a2 == b1 && a3 == b2) cc ++;\n  return cc;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  map<abcd, int> cnt;\n  for (int i=0; i<n; i++) {\n    cin >> cc[i][0] >> cc[i][1] >> cc[i][2] >> cc[i][3];\n    cnt[abcd(cc[i][0], cc[i][1], cc[i][2], cc[i][3])] ++;\n    cnt[abcd(cc[i][1], cc[i][2], cc[i][3], cc[i][0])] ++;\n    cnt[abcd(cc[i][2], cc[i][3], cc[i][0], cc[i][1])] ++;\n    cnt[abcd(cc[i][3], cc[i][0], cc[i][1], cc[i][2])] ++;\n  }\n\n  long long res = 0;\n  for (int i=0; i<n; i++)\n    for (int j=i+1; j<n; j++) {\n      int a0 = cc[i][0], a1 = cc[i][1], a2 = cc[i][2], a3 = cc[i][3];\n      int b0 = cc[j][3], b1 = cc[j][2], b2 = cc[j][1], b3 = cc[j][0];\n      for (int ord=0; ord<4; ord++) {\n        int ll_cnt = cnt[abcd(a0, a3, b0, b1)];\n        int rr_cnt = cnt[abcd(a2, a1, b2, b3)];\n        int uu_cnt = cnt[abcd(a1, a0, b1, b2)];\n        int dd_cnt = cnt[abcd(a3, a2, b3, b0)];\n        ll_cnt -= same(a0, a1, a2, a3, a0, a3, b0, b1);\n        ll_cnt -= same(b0, b1, b2, b3, a0, a3, b0, b1);\n        rr_cnt -= same(a0, a1, a2, a3, a2, a1, b2, b3);\n        rr_cnt -= same(b0, b1, b2, b3, a2, a1, b2, b3);\n        uu_cnt -= same(a0, a1, a2, a3, a1, a0, b1, b2);\n        uu_cnt -= same(b0, b1, b2, b3, a1, a0, b1, b2);\n        dd_cnt -= same(a0, a1, a2, a3, a3, a2, b3, b0);\n        dd_cnt -= same(b0, b1, b2, b3, a3, a2, b3, b0);\n\n        rr_cnt -= same(a0, a3, b0, b1, a2, a1, b2, b3);\n        uu_cnt -= same(a0, a3, b0, b1, a1, a0, b1, b2);\n        uu_cnt -= same(a2, a1, b2, b3, a1, a0, b1, b2);\n        dd_cnt -= same(a0, a3, b0, b1, a3, a2, b3, b0);\n        dd_cnt -= same(a2, a1, b2, b3, a3, a2, b3, b0);\n        dd_cnt -= same(a1, a0, b1, b2, a3, a2, b3, b0);\n        res += 1LL * ll_cnt * rr_cnt * uu_cnt * dd_cnt;\n//        printf(\"%d %d %d : %d %d %d %d\\n\", i,j,ord, ll_cnt, rr_cnt, uu_cnt, dd_cnt);\n        int b4 = b0;\n        b0 = b1;\n        b1 = b2;\n        b2 = b3;\n        b3 = b4;\n      }\n    }\n  cout << res / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int rot[4][4]{{0, 1, 2, 3}, {1, 2, 3, 0}, {2, 3, 0, 1}, {3, 0, 1, 2}};\n\nint N, t;\nmap<vi,pi> MP;\nmap<vi,pi>::iterator it;\nvi C[MAX];\nll tt, ret; \n\ninline void Insert(vi&T, int t)\n{\n    it=MP.find(T);\n    if(it!=MP.end())\n    {\n        it->s.s+=t;\n        return;\n    }\n    int repeat=(mp(T[0], T[1])==mp(T[2], T[3])?(T[0]==T[3]?4:2):1);\n    MP[T]=mp(repeat, t);\n}\n\ninline void Add(vi&T, int t)\n{\n    vi tmp[4];\n    forn(i, 4)\n    {\n        vi &tt=tmp[i];\n        tt.resize(4);\n        forn(j, 4)\n            tt[j]=T[rot[i][j]];\n    }\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline int Find(vi&T)\n{\n    it=MP.find(T);\n    return it->s.s*it->s.f;\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        C[i].resize(4);\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    \n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(all(C[j]));\n            forn(k, 4)\n            {\n                tt=1;\n                vi kk;\n                for(t=0; t<4; ++t)\n                {\n                    kk={C[j][(k+t)&3], C[j][(k+t+1)&3], C[i][(t+1)&3], C[i][t]};\n                    tt*=Find(kk);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(kk, -1);\n                }\n                while(t--)\n                {\n                    kk={C[j][(k+t)&3], C[j][(k+t+1)&3], C[i][(t+1)&3], C[i][t]};\n                    Add(kk, 1);\n                }\n                ret+=tt;\n            }\n            reverse(all(C[j]));\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#define N 410\n#define lint long long\n#define gc getchar()\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nint Gc;map<lint,int> cnt;lint val[1000];\nint c[N][5];\ninline lint hv(int a,int b,int c,int d)\n{\n\treturn a*1000000000ll+b*1000000ll+c*1000ll+d;\n}\ninline lint hv(int *a)\n{\n\treturn hv(a[0],a[1],a[2],a[3]);\n}\ninline int Rot(int *a,int c)\n{\n\trep(i,1,c)\n\t{\n\t\tint tmp=a[0];\n\t\trep(j,1,3) a[j-1]=a[j];\n\t\ta[3]=tmp;\n\t}\n\treturn 0;\n}\ninline int Upd(int *a,int c,int v)\n{\n\tstatic int b[5];\n\trep(i,0,3) b[i]=a[i];\n\tRot(b,c);\n\tcnt[hv(b)]+=v;\n\treturn 0;\n}\ninline int Add(int *a)\n{\n\trep(i,0,3) Upd(a,i,1);return 0;\n}\ninline int Del(int *a)\n{\n\trep(i,0,3) Upd(a,i,-1);return 0;\n}\ninline int Get(int a,int b,int c,int d)\n{\n\tint t=cnt[hv(a,b,c,d)];\n\tcnt[val[++Gc]=hv(a,b,c,d)]--;\n\tcnt[val[++Gc]=hv(b,c,d,a)]--;\n\tcnt[val[++Gc]=hv(c,d,a,b)]--;\n\tcnt[val[++Gc]=hv(d,a,b,c)]--;\n\treturn t;\n}\ninline int Back()\n{\n\trep(i,1,Gc) cnt[val[i]]++;\n\tGc=0;return 0;\n}\nint main()\n{\n\tint n=inn();lint ans=0ll;\n\trep(i,1,n) rep(j,0,3) c[i][j]=inn();\n\trep(i,1,n) rep(j,0,3) Upd(c[i],j,1);\n\trep(i,1,n) rep(p,0,3)\n\t{\n\t\tRot(c[i],p);\n\t\tDel(c[i]);\n\t\trep(j,1,n) if(i!=j) rep(q,0,3)\n\t\t{\n\t\t\tRot(c[j],q);\n\t\t\tDel(c[j]);\n\t\t\tint s=Get(c[j][1],c[j][0],c[i][1],c[i][0]);//S\n\t\t\tint x=Get(c[j][2],c[i][3],c[i][2],c[j][3]);//X\n\t\t\tint z=Get(c[j][1],c[i][0],c[i][3],c[j][2]);//Z\n\t\t\tint y=Get(c[i][1],c[j][0],c[j][3],c[i][2]);//Y\n\t\t\tans+=1ll*s*x*z*y;\n\t\t\tBack();\n\t\t\tAdd(c[j]);\n\t\t\tRot(c[j],(4-q)%4);\n\t\t}\n\t\tAdd(c[i]);\n\t\tRot(c[i],(4-p)%4);\n\t}\n\treturn !printf(\"%lld\\n\",ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-ff;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar(aa%10+'0');\n\treturn;\n}\nlong long n;\nlong long bin[5],ans;\nlong long a[405][4],A[4],B[4];\nmap<long long,long long>mp;\nlong long gao(long long aa,long long bb)\n{\n\tlong long qwq=0;\n\tfor(long long j=0;j<4;++j) qwq+=bin[j]*a[aa][(bb+j)%4];\n\treturn qwq;\n}\nlong long md(long long aa,long long bb,long long cc)\n{\n\ta[n+1][0]=A[aa];a[n+1][1]=B[aa];\n\ta[n+1][2]=B[bb];a[n+1][3]=A[bb];\n\tlong long tmp=mp[gao(n+1,0)];\n\tfor(long long i=0;i<4;++i) mp[gao(n+1,i)]-=cc;\n\treturn tmp;\n}\nvoid getans()\n{\n\tans+=md(0,1,1)*md(1,2,1)*md(2,3,1)*md(3,0,1);\n\tmd(0,1,-1);md(1,2,-1);md(2,3,-1);md(3,0,-1);\n\treturn;\n}\nint main()\n{\n\tn=read();bin[0]=1;\n\tfor(long long i=1;i<4;++i) bin[i]=bin[i-1]*1000;\n\tfor(long long i=1;i<=n;++i) \n\t{\n\t\tfor(long long j=0;j<4;++j) a[i][j]=read();\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\tfor(long long i=1;i<=n;++i)\n\t{\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]--,A[j]=a[i][j];\n\t\tfor(long long j=i+1;j<=n;++j)\n\t\t{\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]--;\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l)\n\t\t\t{\n\t\t\t\tfor(long long k=0;k<4;++k) B[k]=a[j][(k+l)%4];\n\t\t\t\tgetans();\n\t\t\t}\n\t\t\tswap(a[j][0],a[j][1]);swap(a[j][2],a[j][3]);\n\t\t\tfor(long long l=0;l<4;++l) mp[gao(j,l)]++;\n\t\t}\n\t\tfor(long long j=0;j<4;++j) mp[gao(i,j)]++;\n\t}\n\twrite(ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int, int> P;\n\nP rot(P p) {\n\tint a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn make_tuple(b, c, d, a);\n}\n\nlong long unpack(P p) {\n\tlong long a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn a * 1000000000LL + b * 1000000LL + c * 1000LL + d;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n * 4), b(n * 4), c(n * 4), d(n * 4);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 4] >> b[i * 4] >> c[i * 4] >> d[i * 4];\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\ta[i * 4 + j] = d[i * 4 + j - 1];\n\t\t\tb[i * 4 + j] = a[i * 4 + j - 1];\n\t\t\tc[i * 4 + j] = b[i * 4 + j - 1];\n\t\t\td[i * 4 + j] = c[i * 4 + j - 1];\n\t\t}\n\t}\n\tn *= 4;\n\n\tunordered_map<long long, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp[unpack(make_tuple(a[i], b[i], c[i], d[i]))]++;\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i / 4 == j / 4) continue;\n\t\t\tP x(a[i], b[i], c[i], d[i]);\n\t\t\tP y(a[j], b[j], c[j], d[j]);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[unpack(x)]--;\n\t\t\t\tmp[unpack(y)]--;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tP p[4];\n\t\t\tp[0] = P(d[j], c[j], b[i], a[i]);\n\t\t\tp[1] = P(b[i], c[j], b[j], c[i]);\n\t\t\tp[2] = P(d[j], a[i], d[i], a[j]);\n\t\t\tp[3] = P(d[i], c[i], b[j], a[j]);\n\n\t\t\tlong long cnt = 1;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt *= mp[unpack(p[k])];\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[unpack(p[k])]--;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[unpack(p[k])]++;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[unpack(x)]++;\n\t\t\t\tmp[unpack(y)]++;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tans += cnt;\n\t\t}\n\t}\n\tcout << ans / 24 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define int long long\nusing namespace std;\nconst int bas=1013;\nstruct data {\n\tint a,b,c,d;\n\tfriend bool operator <(data a,data b) {\n\t\treturn a.a==b.a?(a.b==b.b?(a.c==b.c?a.d<b.d:a.c<b.c):a.b<b.b):a.a<b.a;\n\t}\n} zhuan[1010];\nmap<data,int> mp;\ndata make(int a,int b,int c,int d) {\n\treturn (data) {\n\t\ta,b,c,d\n\t};\n}\ndata nxt(data x) {\n\treturn make(x.b,x.c,x.d,x.a);\n}\nvoid inc(data x,int val) {\n\tfor(int i=1; i<=4; ++i) {\n\t\tmp[x]+=val;\n\t\tx=nxt(x);\n\t}\n}\nint ans,n;\nvoid solve(int a,int b) {\n\tdata x=zhuan[a],y=zhuan[b];\n\tfor(int i=1; i<=4; ++i) {\n\t\ty=nxt(y);\n\t\tdata r1=make(x.b,x.a,y.a,y.d);\n\t\tdata r2=make(x.c,x.b,y.d,y.c);\n\t\tdata r3=make(x.d,x.c,y.c,y.b);\n\t\tdata r4=make(x.a,x.d,y.b,y.a);\n\t\tif(!mp[r1]||!mp[r2]||!mp[r3]||!mp[r4])continue;\n//\t\tcout<<mp[r1]<<' '<<mp[r2]<<\" \"<<mp[r3]<<' '<<mp[r4]<<endl;\n//\t\tcout<<r4.a<<' '<<r4.b<<r4.c<<r4.d<<endl;\n\t\tint res=1;\n\t\tres*=mp[r1];\n\t\tinc(r1,-1);\n\t\tres*=mp[r2];\n\t\tinc(r2,-1);\n\t\tres*=mp[r3];\n\t\tinc(r3,-1);\n\t\tres*=mp[r4];\n\t\tans+=res;\n\t\tinc(r1,1);\n\t\tinc(r2,1);\n\t\tinc(r3,1);\n\t}\n}\nsigned main() {\n\tscanf(\"%lld\",&n);\n\tfor(int i=1; i<=n; ++i) {\n\t\tscanf(\"%lld%lld%lld%lld\",&zhuan[i].a,&zhuan[i].b,&zhuan[i].c,&zhuan[i].d);\n\t\tinc(zhuan[i],1);\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tinc(zhuan[i],-1);\n\t\tfor(int j=1+i; j<=n; ++j) {\n\t\t\tinc(zhuan[j],-1);\n\t\t\tsolve(i,j);\n\t\t\tinc(zhuan[j],1);\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...)\\\n  std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::istream& operator>> (std::istream& is, Container& v) {\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T, typename U>\nstd::ostream& operator<< (std::ostream& os, const std::pair<T, U>& pair)\n  { return os << \"(\" << pair.first << \",\" << pair.second << \")\"; }\n\ntemplate <typename T, typename U>\nstd::istream& operator>> (std::iostream& is, std::pair<T, U>& pair)\n  { return is >> pair.first >> pair.second; }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto data = make_vector< 2, int >(n, 4);\n  std::cin >> data;\n  auto multiplicity = [&] (auto a) {\n    if (a.at(0) != a.at(2) || a.at(1) != a.at(3))\n      { return 1; }\n    if (a.at(0) != a.at(1))\n      { return 2;}\n    return 4;\n  };\n  auto power = [&] (auto x, auto y) {\n    auto ret = 1LL;\n    loop(y) ret *= x;\n    return ret;\n  };\n  auto normalized = [&] (auto a) {\n    auto z = a;\n    loop(3) {\n      std::rotate(a.begin(), a.begin() + 1, a.end());\n      cmn(z, a);\n    }\n    return z;\n  };\n  for (auto & v : data) v = normalized(v);\n  std::multiset< std::vector< int > > set(data.begin(), data.end());\n  auto cal = [&] (auto n, auto k) {\n    if (n < k) return 0LL;\n    auto ret = 1LL;\n    rep(i, 0, k) ret *= (n - i);\n    return ret;\n  };\n  lint ret = 0;\n  rep(i, 0, n) rep(j, i + 1, n) {\n    auto x = data.at(i);\n    auto y = data.at(j);\n    auto seq = std::vector< int >{1, 0, 1, 0};\n    loop(4) {\n      std::map< std::vector< int >, int > map;\n      loop(4) {\n        auto z = std::vector< int >{\n          x.at(seq.at(0)), x.at(seq.at(1)),\n          y.at(seq.at(2)), y.at(seq.at(3))\n        };\n        map[normalized(z)]++;\n        for (auto & x : std::vector< std::reference_wrapper< int > >{ seq.at(0), seq.at(1) })\n          { (x += 1) %= 4; }\n        for (auto & x : std::vector< std::reference_wrapper< int > >{ seq.at(2), seq.at(3) })\n          { (x += 3) %= 4; }\n      }\n      auto now = 1;\n      for (auto p : map) {\n        std::vector< int > v; int l; std::tie(v, l) = p;\n        auto m = (lint)set.count(v) - (x == v) - (y == v);\n        // assert(m >= 0);\n        now *= cal(m, l) * power(multiplicity(v), l);\n      }\n      ret += now;\n      for (auto & x : std::vector< std::reference_wrapper< int > >{ seq.at(2), seq.at(3) })\n        { (x += 3) %= 4; }\n    }\n  }\n  // assert(ret % 3 == 0);\n  ret /= 3;\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N;\n  cin>>N;\n  vector<vector<int>> A(N,vector<int>(4));\n  cin>>A;\n  map<vector<int>,int> M;\n  map<vector<int>,int> sq2idx;\n  using itr=map<vector<int>,int>::iterator;\n  vector<vector<itr>> cnt(N,vector<itr>(4));\n  vector<int> col(4,0);\n  vector<int> uku(4,0);\n  for(int idx=0;idx<N;idx++){\n    auto &I=A[idx];\n    for(int i=0;i<4;i++){\n      for(int j=0;j<4;j++){\n        col[j]=I[(i+j)&3];\n      }\n      M[col]++;\n      cnt[idx][i]=M.find(col);\n      sq2idx[col]=idx;\n    }\n  }\n  ll ans=0;\n  for(int i=0;i<N;i++){\n    for(int k=0;k<4;k++){\n      cnt[i][k]->S--;\n    }\n    for(int j=0;j<N;j++){\n      if(i==j){continue;}\n      for(int k=0;k<4;k++){\n        cnt[j][k]->S--;\n      }\n      for(int k=0;k<4;k++){\n        ll dif=1;\n        for(int l=0;l<4;l++){\n          uku[0]=A[i][(l+1)&3];\n          uku[1]=A[i][l];\n          uku[2]=A[j][(16-(k+l-1))&3];\n          uku[3]=A[j][(16-(k+l))&3];\n          //if(i==4 && j==0 && k==0){\n          //cout<<i<<\" \"<<j<<\" \"<<k<<\" ! \"<<l<<endl<<uku<<\" \"<<M[uku]<<endl;\n          //}\n          if(sq2idx.count(uku)==0){dif=0; break;}\n          int idx=sq2idx[uku];\n          if(uku[0]==uku[2] && uku[1]==uku[3]){\n            if(uku[0]==uku[1]){dif*=M[uku];}\n            else{dif*=M[uku];}\n          }\n          else{dif*=M[uku];}\n          for(auto &I:cnt[idx]){I->S--;}\n        }\n        //assert(dif>=0);\n        ans+=dif;\n        //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dif<<endl;\n        for(int l=0;l<4;l++){\n          uku[0]=A[i][(l+1)&3];\n          uku[1]=A[i][l];\n          uku[2]=A[j][(16-(k+l-1))&3];\n          uku[3]=A[j][(16-(k+l))&3];\n          if(sq2idx.count(uku)==0){dif=0; break;}\n          int idx=sq2idx[uku];\n          for(auto &I:cnt[idx]){I->S++;}\n        }\n      }\n      for(int k=0;k<4;k++){\n        cnt[j][k]->S++;\n      }\n    }\n    for(int k=0;k<4;k++){\n      cnt[i][k]->S++;\n    }\n  }\n  //cout<<ans<<endl;\n  ans/=6;\n  cout<<ans<<endl;\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconst ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\n\n// https://atcoder.jp/contests/arc062/submissions/6354580\n\nmap<ll, ll> symmetry;\nmap<ll, vll> decode;\nmap<ll, ll> counter;\n\nll encode(vll &v){\n  ll t = INF;\n  rep(i, 4){\n    rotate(v.begin(), v.begin()+1, v.end());\n    ll tmp = 0;\n    rep(j, 4){\n      tmp += v[j]*(1ll << (10*j));\n    }\n    chmin(t, tmp);\n  }\n  return t;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  ll n;\n  cin >> n;\n  vll tiles;\n  rep(i, n){\n    vll col(4);\n    rep(j, 4){\n      cin >> col[j];\n    }\n    // 正規化してタイルを管理\n    ll t = encode(col);\n    tiles.emplace_back(t);\n    counter[t]++;\n    decode[t] = col;\n    // C4, C2 対称\n    if(col[0] == col[1] && col[1] == col[2] && col[2] == col[3]){\n      symmetry[t] = 4;\n    }else if(col[0] == col[2] && col[1] == col[3]){\n      symmetry[t] = 2;\n    }else{\n      symmetry[t] = 1;\n    }\n  }\n  ll ans = 0;\n  // 対面、回転　全探索\n  rep(ii, n)repr(jj, ii+1, n){\n    ll bottom = tiles[ii], top = tiles[jj];\n    // 消費\n    counter[bottom]--;\n    counter[top]--;\n    vll colb = decode[bottom];\n    vll colt = decode[top];\n    rep(rot, 4){\n      rotate(colt.begin(), colt.begin()+1, colt.end());\n      vll tls;\n      vll t{colb[1], colb[0], colt[0], colt[3]};\n      tls.emplace_back(encode(t));\n      t = {colb[2], colb[1], colt[3], colt[2]};\n      tls.emplace_back(encode(t));\n      t = {colb[3], colb[2], colt[2], colt[1]};\n      tls.emplace_back(encode(t));\n      t = {colb[0], colb[3], colt[1], colt[0]};\n      tls.emplace_back(encode(t));\n      \n      // 必要量の算出\n      map<ll, ll> need;\n      ll x = 1;\n      for(auto&& e: tls){\n        need[e]++;\n      }\n      for(auto&& tile: need){\n        ll have = counter[tile.first];\n        if(have < tile.second){\n          x = 0;\n          break;\n        }\n        // P(使用可能タイル数, 使用量)\n        rep(i, tile.second){\n          x *= counter[tile.first]-i;\n        }\n        // 対称性\n        rep(i, tile.second){\n          x *= symmetry[tile.first];\n        }\n      }\n      ans += x;\n    }\n    counter[bottom]++;\n    counter[top]++;\n  }\n  print(ans/3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nvoid rot(vector<int> &tile) {\n  rotate(tile.begin(), tile.begin() + 1, tile.end());\n}\n\nvoid rm_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]--;\n    rot(tile);\n  }\n}\n\nvoid add_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]++;\n    rot(tile);\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[tile], 0);\n    rm_tile(tile, colors);\n  }\n\n  for (vector<int> &tile : side_tiles) {\n    add_tile(tile, colors);\n  }\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[tiles[i]]++;\n      rot(tiles[i]);\n    }\n  }\n\n  ll ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rot(tiles[low]);\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nchar c[404][4];\n\nusing VC = vector<char>;\n\nVC normalize(const VC &v){\n  VC cand(v);\n  rep(i,1,4){\n    VC nv;\n    rep(j,4) nv.pb(v[(i+j)%4]);\n    if(nv < cand) cand = nv;\n  }\n  return cand;\n}\n\nint main(){\n  map<VC, int> ma;\n  int n;\n  cin>>n;\n  rep(i,n) rep(j,4) cin>>c[i][j];\n  rep(i,n){\n    ma[normalize(VC(c[i], c[i+1]))]++;\n  }\n// dbg(vector<pair<VC,int>>(all(ma)));\n  const int d[4][4] = { {0,3,1,0}, {3,2,2,1}, {2,1,3,2}, {1,0,0,3} };\n\n  // vc をx個選ぶ方法\n  auto sel = [&](const VC &vc, int x, int dup){\n    if(ma[vc]-dup <= 0) return 0L;\n    long mul = 1;\n    if(vc[0] == vc[2] && vc[1] == vc[3]){\n      if(vc[0] == vc[1]) mul = 4;\n      else mul = 2;\n    }\n    long ret = 1;\n    rep(i,x) ret *= (ma[vc]-i-dup)*mul;\n    return ret;\n  };\n\n  long ans = 0;\n  rep(i,n) rep(j,i){\n    VC vi = normalize(VC(c[i], c[i+1]));\n    VC vj = normalize(VC(c[j], c[j+1]));\n    rep(ri,4) rep(rj,4){\n      map<VC, int> cur;\n      rep(k,4){\n        auto vc = normalize({\n          c[i][(ri+d[k][0])%4],\n          c[i][(ri+d[k][1])%4],\n          c[j][(rj+d[k][2])%4],\n          c[j][(rj+d[k][3])%4]\n        });\n        cur[vc]++;\n      }\n      long tmp = 1;\n      for(auto &pp : cur){\n        int dup = 0;\n        if(pp.fi == vi) dup++;\n        if(pp.fi == vj) dup++;\n        tmp *= sel(pp.first, pp.second, dup);\n      }\n      ans += tmp;\n    }\n  }\n\n  cout << ans << endl;\n  cout << ans / 12 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); i--)\n#define debug(x) cout << #x << \" => \" << x << endl\nusing namespace std;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 7 + 400;\n///----------------------------------------------\n//int qpow(int\n\nint col[10];\nvoid rote() {\n    int tmp[4]; rep(i,0,4) tmp[i]=col[i];\n    rep(beg,1,4) {\n        int i; for (i=0; i<3&&tmp[(beg+i)%4]==col[i]; ) i++;\n        if(tmp[(beg+i)%4]<col[i]) {\n            rep(i,0,4) col[i]=tmp[(beg+i)%4];\n        }\n    }\n}\n\nconst int B[4]={1000000000, 1000000, 1000, 1};\nll getval() {\n    ll val=0;\n    rep(i,0,4) val+=1ll*col[i]*B[i];\n    return val;\n}\n\nbool same() {\n    rep(i,1,4) if (col[i]!=col[0]) return false;\n    return true;\n}\nbool same2() {\n    return col[0]==col[2]&&col[1]==col[3];\n}\n\n\nmap<ll,int> num;\nint tab[MAX_N][4];\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///init\n    ///read\n    int n; cin>>n;\n    rep(i,0,n) {\n        rep(j,0,4) scanf(\"%d\",&col[j]);\n        rep(j,0,4) tab[i][j]=col[j];\n        rote();\n        num[getval()]++;\n\n    }\n\n    ///work\n    ll ans=0;\n    rep(i,0,n) {\n        rep(j,0,4) col[j]=tab[i][j]; rote();\n        num[getval()]--;\n        rep(j,i+1,n) rep(off,0,4) {\n\n            rep(k,0,4) col[k]=tab[j][k]; rote();\n            num[getval()]--;\n\n            int tmp=1;\n\n            ///front\n            col[0]=tab[i][1]; col[1]=tab[j][(off+0)%4];\n            col[3]=tab[i][2]; col[2]=tab[j][(off+3)%4]; rote();\n            ll val1 = getval();\n            ll tmp1 = same() ? 4 : same2() ? 2 : 1;\n            tmp=1ll*tmp*(num[val1]--)*tmp1;\n\n            ///top\n            col[0]=tab[i][0]; col[1]=tab[j][(off+1)%4];\n            col[3]=tab[i][1]; col[2]=tab[j][(off+0)%4]; rote();\n            ll val2 = getval();\n            ll tmp2 = same() ? 4 : same2() ? 2 : 1;\n            tmp=1ll*tmp*(num[val2]--)*tmp2;\n\n            ///buttom\n            col[0]=tab[i][2]; col[1]=tab[j][(off+3)%4];\n            col[3]=tab[i][3]; col[2]=tab[j][(off+2)%4]; rote();\n            ll val3 = getval();\n            ll tmp3 = same() ? 4 : same2() ? 2 : 1;\n            tmp=1ll*tmp*(num[val3]--)*tmp3;\n\n            ///back\n            col[0]=tab[i][3]; col[1]=tab[j][(off+2)%4];\n            col[3]=tab[i][0]; col[2]=tab[j][(off+1)%4]; rote();\n            ll val4 = getval();\n            ll tmp4 = same() ? 4 : same2() ? 2 : 1;\n            tmp=1ll*tmp*(num[val4]--)*tmp4;\n\n            ans=ans+tmp;\n            num[val1]++;\n            num[val2]++;\n            num[val3]++;\n            num[val4]++;\n            rep(k,0,4) col[k]=tab[j][k]; rote();\n            num[getval()]++;\n       }\n    }\n\n    ///print\n    cout << ans << endl;\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma GCC optimize(\"O3\")\n#endif\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n \n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n \ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n \n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n \ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n \ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n \ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n \nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n \ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n \nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n \n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n \n// }}}\n \nconst int N=404;\n \ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n \ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n \ninline LL norm( LL x ) {\n    return min(x,min(rot(x),min(rot(rot(x)),rot(rot(rot(x))))));\n}\n \ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n \nint n,a[N][4],rc[16];\nLL b[N],dp[16];\n \nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n \n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    int lc[4]={1,1,1,1};\n    REP(i,4) while ( lc[i]<4 && c[i][lc[i]]!=c[i][0] ) lc[i]++;\n    REP(i,4) rc[i]=4/lc[i];\n    REP(i,4) sort(c[i],c[i]+lc[i]);\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    REP1(i,ti+1,n) if ( i!=bi ) {\n        for ( int j=14; j>=0; j-- ) REP(k,4) if ( !bit(j,k) && b[i]==c[k][0] ) {\n            dp[j|(1<<k)]+=rc[k]*dp[j];\n        }\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[15];\n}\n \nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    // n=400;\n    REP1(i,1,n) b[i]=norm(f(a[i][0],a[i][1],a[i][2],a[i][3]));\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<array>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nstruct Data {\n    int cnt, kind;\n    Data() {\n\tcnt = 0;\n\tkind = 0;\n    }\n    bool operator<(const Data &o) const {\n\treturn false;\n    }\n};\n\nusing Arr = array<int, 4>;\n\nint N;\nArr C[411];\nArr Z[4];\n\nvoid normal(Arr &src) {\n    Arr b = src;\n    REP (_, 3) {\n\tint tmp = b[0];\n\tREP (i, 3) b[i] = b[i+1];\n\tb[3] = tmp;\n\tamin(src, b);\n    }\n}\n\nmap<Arr, Data> mp;\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) {\n\tREP (t, 4) scanf(\"%d\", &C[i][t]);\n\tnormal(C[i]);\n\tmp[C[i]].cnt++;\n    }\n    EACH (e, mp) {\n\tconst Arr &a = e->first;\n\tint r = 0;\n\tREP (s, 4) {\n\t    bool ok = true;\n\t    REP (i, 4) if (a[i] != a[(i+s)%4]) { ok = false; break; }\n\t    if (ok) r++;\n\t}\n\te->second.kind = r;\n    }\n\n    LL ans = 0;\n\n    REP (i, N) {\n\tmp[C[i]].cnt--;\n\tfor (int j=i+1; j<N; j++) {\n\t    mp[C[j]].cnt--;\n\t    REP (b, 4) {\n\t\tvector<pair<Arr, Data> > v; v.reserve(4);\n\t\tREP (c, 4) {\n\t\t    Z[c][2] = C[i][(c+1)%4];\n\t\t    Z[c][3] = C[i][(c)%4];\n\t\t    Z[c][0] = C[j][(b-c+4)%4];\n\t\t    Z[c][1] = C[j][(b-c+3)%4];\n\t\t    normal(Z[c]);\n\n\t\t    auto it = mp.find(Z[c]);\n\t\t    if (it == mp.end()) {\n\t\t\tbreak;\n\t\t    } else {\n\t\t\tv.push_back(*it);\n\t\t    }\n\t\t}\n\n\t\tif (v.size() == 4u) {\n\t\t    sort(v.begin(), v.end());\n\t\t    LL tmp = 1;\n\t\t    for (int l=0; l<4; ) {\n\t\t\tint r = l;\n\t\t\tLL p = v[l].second.cnt;\n\t\t\twhile (r < 4 && v[l].first == v[r].first ) {\n\t\t\t    tmp *= p*v[l].second.kind;\n\t\t\t    p--;\n\t\t\t    r++;\n\t\t\t}\n\t\t\tl = r;\n\t\t    }\n\t\t    ans += tmp;\n\t\t}\n\t    }\n\t    mp[C[j]].cnt++;\n\t}\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nchar c[404][4];\n\nusing VC = vector<char>;\n\nVC normalize(const VC &v){\n  VC cand(v);\n  rep(i,1,4){\n    VC nv;\n    rep(j,4) nv.pb(v[(i+j)%4]);\n    if(nv < cand) cand = nv;\n  }\n  return cand;\n}\n\nint main(){\n  map<VC, int> ma;\n  int n;\n  cin>>n;\n  rep(i,n) rep(j,4) cin>>c[i][j];\n  rep(i,n){\n    ma[normalize(VC(c[i], c[i+1]))]++;\n  }\n// dbg(vector<pair<VC,int>>(all(ma)));\n  const int d[4][4] = { {0,3,1,0}, {3,2,2,1}, {2,1,3,2}, {1,0,0,3} };\n\n  // vc をx個選ぶ方法\n  auto sel = [&](const VC &vc, int x, int dup){\n    if(ma[vc]-dup <= 0) return 0L;\n    long mul = 1;\n    if(vc[0] == vc[2] && vc[1] == vc[3]){\n      if(vc[0] == vc[1]) mul = 4;\n      else mul = 2;\n    }\n    long ret = 1;\n    rep(i,x) ret *= (ma[vc]-i-dup)*mul;\n    return ret;\n  };\n\n  long ans = 0;\n  rep(i,n) rep(j,i){\n    VC vi = normalize(VC(c[i], c[i+1]));\n    VC vj = normalize(VC(c[j], c[j+1]));\n    rep(ri,4) rep(rj,4){\n      map<VC, int> cur;\n      rep(k,4){\n        auto vc = normalize({\n          c[i][(ri+d[k][0])%4],\n          c[i][(ri+d[k][1])%4],\n          c[j][(rj+d[k][2])%4],\n          c[j][(rj+d[k][3])%4]\n        });\n        cur[vc]++;\n      }\n      long tmp = 1;\n      for(auto &pp : cur){\n        int dup = 0;\n        if(pp.fi == vi) dup++;\n        if(pp.fi == vj) dup++;\n        tmp *= sel(pp.first, pp.second, dup);\n      }\n      ans += tmp;\n    }\n  }\n\n  cout << ans / 12 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<vector<int>> masks(4);\n    for (int i=0;i<16;++i){\n        for (int j=0;j<4;++j){\n            if (!(i&1<<j)) masks[j].emplace_back(i);\n        }\n    }\n    vector<ll> po(4,1);\n    for (int i=0;i<3;++i) po[i+1]=po[i]*1000;\n    vector<vector<ll>> hash(N,vector<ll>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            for (int k=0;k<4;++k){\n                hash[i][j]+=C[i][(j+k)%4]*po[k];\n            }\n        }\n    }\n    vector<int> rot(4);\n    vector<vector<int>> surface(4,vector<int>(4));\n    vector<ll> hashedsurface(4);\n    vector<vector<ll>> dp(N+1,vector<ll>(16));\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                    if (surface[q][0]==surface[q][1]\n                        &&surface[q][1]==surface[q][2]\n                        &&surface[q][2]==surface[q][3]\n                        &&surface[q][3]==surface[q][0]) rot[q]=4;\n                    else if (surface[q][0]==surface[q][2]\n                            &&surface[q][1]==surface[q][3]) rot[q]=2;\n                    else rot[q]=1;\n                    hashedsurface[q]=0;\n                    for (int r=0;r<4;++r){\n                        hashedsurface[q]+=surface[q][r]*po[r];\n                    }\n                }\n                for (int k=i+1;k<=N;++k){\n                    for (int l=0;l<16;++l){\n                        dp[k][l]=0;\n                    }\n                }\n                dp[i+1][0]=1;\n                for (int k=i+1;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]=dp[k][l];\n                    if (k==j) continue;\n                    for (int l=0;l<4;++l){\n                        bool flag=false;\n                        for (int m=0;m<4;++m){\n                            if (hashedsurface[l]==hash[k][m]){\n                                flag=true;\n                            }\n                        }\n                        if (flag){\n                            for (int mask:masks[l]){\n                                dp[k+1][mask|1<<l]+=dp[k][mask]*rot[l];\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a1,const sq &a2)->Int{\n    const sq a({a1[0],a1[1],a1[2],a1[3],a2[0],a2[1],a2[2],a2[3]});\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  unordered_set<Int> used_f;\n  vector<sq> as(b.size(),sq(4));\n  for(Int i=0;i<(Int)b.size();i++)\n    for(Int k=0;k<4;k++)\n      as[i][k]=(b[i]>>(k*10))&1023;\n  \n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    if(used_f.count(b[i])) continue;\n    \n    for(Int j=i;j<(Int)b.size();j++){\n      if(used.count(P(b[i],b[j]))) continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n\n      if(cnt[b[j]]==0){\n\tadd(b[i],1);\n\tcontinue;\n      }\n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n            \n      Int w=calc(as[i][2],as[i][1],as[j][0],as[j][3]);\n      Int x=calc(as[i][0],as[i][3],as[j][2],as[j][1]);\n      Int y=calc(as[i][3],as[i][2],as[j][3],as[j][2]);\n      Int z=calc(as[i][1],as[i][0],as[j][1],as[j][0]);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(as[i],as[j]);\n      ans+=res;\n    }\n    \n    Int v=b[i];\n    for(Int j=0;j<4;j++){\n      v=((v&1023)<<30)|(v>>10);\n      used_f.emplace(v);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=410;\nstruct Tile{\n\tconst static int D=4;\n\tint a[D];\n\tinline Tile nxt(){\n\t\treturn (Tile){a[1],a[2],a[3],a[0]};\n\t}\n\tinline friend bool operator < (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t\t}\n\t\treturn false;\n\t}\n}tile[N];\nmap<Tile,int>m;\ninline void add(Tile x,int v){\n\tfor(int i=0;i<Tile::D;i++,x=x.nxt()){\n\t\tm[x]+=v;\n\t}\n}\ninline bool vis(Tile x){\n\treturn m.find(x)!=m.end();\n}\nint main(){\n\tint n=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ttile[i]=(Tile){ni,ni,ni,ni};\n\t\tadd(tile[i],1);\n\t}\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tadd(tile[i],-1);\n\t\tint *a=tile[i].a;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint *b=tile[j].a;\n\t\t\tadd(tile[j],-1);\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\ttile[j]=tile[j].nxt();\n\t\t\t\tTile f1=(Tile){a[1],a[0],b[0],b[3]};\n\t\t\t\tTile f2=(Tile){a[2],a[1],b[3],b[2]};\n\t\t\t\tTile f3=(Tile){a[3],a[2],b[2],b[1]};\n\t\t\t\tTile f4=(Tile){a[0],a[3],b[1],b[0]};\n\t\t\t\tif(!(vis(f1)&&vis(f2)&&vis(f3)&&vis(f4)))continue;\n\t\t\t\tlint tmp=1;\n\t\t\t\ttmp*=m[f1],add(f1,-1);\n\t\t\t\ttmp*=m[f2],add(f2,-1);\n\t\t\t\ttmp*=m[f3],add(f3,-1);\n\t\t\t\ttmp*=m[f4];\n\t\t\t\tadd(f1,1),add(f2,1),add(f3,1);\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tadd(tile[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <string>\n    #include <set>  \n    #include <stack>\n    #include <algorithm>\n    #include <vector>\n    #include <cmath>\n    #include <queue>\n    #include <deque>\n    #include <cstring>\n    #include <cstdio>\n    #include <map>\n    #include <numeric>\n    #include <cassert>\n    #include <iomanip>\n    #include <sstream>\n    #include <ctime>\n    #include <bitset> \n    #include <unordered_set>\nusing namespace std;\n#define for1(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define rep(i,maxn) for1(i,0,maxn)\n#define ford(i,b,a) for(int i=(int)(b)-1;i>=a;--i)\ntypedef long long ll;\ntypedef unsigned long long int128;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii > piii;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define eps 1e-10\n#define pi acos(-1)\n#define st first\n#define nd second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define dprintf(...) printf(__VA_ARGS__)\n#define lson(x) ((x)<<1)\n#define rson(x) ((x)<<1^1)\nconst int maxn=405;\nint C[maxn][4];\nstruct tile\n{\n\tint a,b,c,d;\n\ttile(){}\n\ttile(int _a,int _b,int _c,int _d):a(_a),b(_b),c(_c),d(_d){} \n\tbool operator < (const tile &t)const\n\t{\n\t\treturn (a!=t.a?a<t.a:b!=t.b?b<t.b:c!=t.c?c<t.c:d<t.d);\n\t}\n\tbool operator == (const tile &t)\n\t{\n\t\treturn a==t.a&&b==t.b&&c==t.c&&d==t.d;\n\t}\n};\nmap<tile,int> m;\nvoid ins(int a,int b,int c,int d)\n{\n\tm[tile(a,b,c,d)]++;\n\tm[tile(b,c,d,a)]++;\n\tm[tile(c,d,a,b)]++;\n\tm[tile(d,a,b,c)]++;\n}\nvector<tile> vx;\nint same(tile a,tile b)\n{\n\tint ans=0;\n\tint aa=b.a,bb=b.b,cc=b.c,dd=b.d;\n\tif(a==tile(aa,bb,cc,dd))ans++;\n\tif(a==tile(bb,cc,dd,aa))ans++;\n\tif(a==tile(cc,dd,aa,bb))ans++;\n\tif(a==tile(dd,aa,bb,cc))ans++;\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,n)rep(j,4)cin>>C[i][j];\n\tll ans=0;\n\tford(i,n,0)\n\t{\n\t\trep(j,vx.size())\n\t\t{\n\t\t\ttile cur=vx[j];\n\t\t\tint a=cur.a,b=cur.b,c=cur.c,d=cur.d;\n\t\t//\tcout<<C[i][0]<<\" \"<<C[i][1]<<\" \"<<C[i][2]<<\" \"<<C[i][3]<<endl;\n\t\t//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\t//\tsystem(\"pause\"); \n\t\t\ttile x=tile(C[i][0],C[i][1],b,a);\n\t\t\ttile y=tile(C[i][1],C[i][2],c,b);\n\t\t\ttile z=tile(C[i][2],C[i][3],d,c);\n\t\t\ttile w=tile(C[i][3],C[i][0],a,d);\n\t\t//\tcout<<\"x: \"<<x.a<<\" \"<<x.b<<\" \"<<x.c<<\" \"<<x.d<<\" \"<<m[x]<<endl;\n\t\t//\tcout<<\"y: \"<<y.a<<\" \"<<y.b<<\" \"<<y.c<<\" \"<<y.d<<\" \"<<m[y]<<endl;\n\t\t//\tcout<<\"z: \"<<z.a<<\" \"<<z.b<<\" \"<<z.c<<\" \"<<z.d<<\" \"<<m[z]<<endl;\n\t\t//\tcout<<\"w: \"<<w.a<<\" \"<<w.b<<\" \"<<w.c<<\" \"<<w.d<<\" \"<<m[w]<<endl; \n\t\t\tll res=1;\n\t\t\tres*=1ll*m[x]-same(cur,x);\n\t\t//\tcout<<m[x]<<\" \"<<same(cur,x)<<endl;\n\t\t\tres*=1ll*m[y]-same(x,y)-same(cur,y);\n\t\t//\tcout<<m[y]<<\" \"<<same(x,y)<<\" \"<<same(cur,y)<<endl;\n\t\t\tres*=1ll*m[z]-same(x,z)-same(y,z)-same(cur,z);\n\t\t//\tcout<<m[z]<<\" \"<<same(x,z)<<\" \"<<same(y,z)<<\" \"<<same(cur,z)<<endl;\n\t\t\tres*=1ll*m[w]-same(x,w)-same(y,w)-same(z,w)-same(cur,w);\n\t\t//\tcout<<m[w]<<\" \"<<same(x,w)<<\" \"<<same(y,w)<<\" \"<<same(z,w)<<\" \"<<same(cur,w)<<endl;\n\t\t\tans+=res;\n\t\t//\tcout<<res<<\" \"<<ans<<endl;\n\t\t//\tsystem(\"pause\");\n\t\t}\n\t\tint a=C[i][0],b=C[i][3],c=C[i][2],d=C[i][1];\n\t\tins(a,b,c,d);\n\t\tvx.pb(tile(a,b,c,d));\n\t\tvx.pb(tile(b,c,d,a));\n\t\tvx.pb(tile(c,d,a,b));\n\t\tvx.pb(tile(d,a,b,c));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n            reverse(all(d));\n            mp[d] ++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n            reverse(all(d));\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n                reverse(all(d));\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                reverse(all(d));\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    // if(i == 0 && j == 4) cerr << res << endl;\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    // if(i == 0 && j == 4) {\n                    //     cerr << c[i][l] << \" \" << c[i][(l + 1) % 4] << \" \" << d[(l + 1) % 4] << \" \" << d[l] << endl;\n                    // }\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                            reverse(all(e));\n                            mp[e] --;\n                        }\n                    } else {\n                        res = 0;\n                        break;\n                    }\n                }\n                //if(i == 0 && j == 4) cerr << res << endl;\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                        reverse(all(e));\n                        mp[e] ++;\n                    }\n                }\n                //if(res) cerr << i << \" \" << j << \" \" << res << endl;\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n                reverse(all(d));\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n            reverse(all(d));\n            mp[d] ++;\n        }\n    }\n    cout << ans / 6 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=410;\nint n,c[N][8];\nll state(int a,int b,int c,int d){\n\tll ans=0;\n\tans=ans*1000+a;\n\tans=ans*1000+b;\n\tans=ans*1000+c;\n\tans=ans*1000+d;\n\treturn ans;\n}\nstruct table{\n\tvector<ll> A;\n\tvector<int> cnt;\n\tvoid push(int a,int b,int c,int d){\n\t\tA.push_back(state(a,b,c,d));\n\t\tA.push_back(state(b,c,d,a));\n\t\tA.push_back(state(c,d,a,b));\n\t\tA.push_back(state(d,a,b,c));\n\t}\n\tvoid init(){\n\t\tsort(A.begin(),A.end());\n\t\tcnt.resize(A.size(),0);\n\t}\n\tint& operator [](const ll x){\n\t\treturn cnt[lower_bound(A.begin(),A.end(),x)-A.begin()];\n\t}\n}M;\nll ans;\nvoid add(int a,int b,int c,int d,int v){\n\tM[state(a,b,c,d)]+=v;\n\tM[state(b,c,d,a)]+=v;\n\tM[state(c,d,a,b)]+=v;\n\tM[state(d,a,b,c)]+=v;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++)\n\t\t\tscanf(\"%d\",&c[i][j]),c[i][j+4]=c[i][j];\n\t\tM.push(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t}\n\tM.init();\n\tfor (int i=1;i<=n;i++) add(c[i][0],c[i][1],c[i][2],c[i][3],1);\n\t//标号最小的正方形作为正面\n\tfor (int i=1;i<=n;i++){\n\t\tadd(c[i][0],c[i][1],c[i][2],c[i][3],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tadd(c[j][0],c[j][1],c[j][2],c[j][3],-1);\n\t\t\tfor (int *C=c[j];C<c[j]+4;C++){//枚举反面和旋转后的方向\n\t\t\t\tll calc=1;\n\t\t\t\tcalc*=M[state(c[i][1],c[i][0],C[1],C[0])];\n\t\t\t\tadd(c[i][1],c[i][0],C[1],C[0],-1);\n\t\t\t\tcalc*=M[state(c[i][0],c[i][3],C[2],C[1])];\n\t\t\t\tadd(c[i][0],c[i][3],C[2],C[1],-1);\n\t\t\t\tcalc*=M[state(c[i][3],c[i][2],C[3],C[2])];\n\t\t\t\tadd(c[i][3],c[i][2],C[3],C[2],-1);\n\t\t\t\tcalc*=M[state(c[i][2],c[i][1],C[0],C[3])];\n\t\t\t\tadd(c[i][3],c[i][2],C[3],C[2],1);\n\t\t\t\tadd(c[i][0],c[i][3],C[2],C[1],1);\n\t\t\t\tadd(c[i][1],c[i][0],C[1],C[0],1);\n\t\t\t\tans+=calc;\n\t\t\t}\n\t\t\tadd(c[j][0],c[j][1],c[j][2],c[j][3],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include <utility>\n#include <cstdio>\n#include<algorithm>\n#include<queue>\n#define ll  long long\n\nusing namespace std;\n\tint n;\nvoid rotate(vector<int> & vec){\n    vector<int> tmp(4);\n    int minind = min_element(vec.begin(), vec.end() ) - vec.begin();\n    for(int i=3; i>0; i--){\n\tif(vec[i]==vec[minind]){\n\t    minind=i;\n\t}else{\n\t    break;\n\t}\n    }\n    for(int i=0; i<4; i++){\n\ttmp[i] = vec[(i+minind)%4];\n    }\n    vec=tmp;\n}\nvoid rot1(vector<int> & vec){\n    int tmp = vec[0];\n    for(int i=0; i<4; i++){\n\tvec[i] = vec[i+1];\n    }\n    vec[3]=tmp;\n}\nint cntsq(vector<vector<int> > & c, vector<int>  & sq, int st, int sk){\n    int res=0;\n    for(int i=st; i<n; i++)\n\tif(i!=sk && c[i]==sq)res++;\n    return res;\n}\nint sym(vector<int> v){\n    if(v[0]!=v[2] || v[1]!=v[3])return 1;\n    if(v[0]!=v[1] || v[2]!=v[3])return 2;\n    return 4;\n}\nint main(){\n    cin>>n;\n    vector<vector<int> > c(n, vector<int>(4));\n    for(int i=0; i<n; i++){\n\tfor(int j=0; j<4; j++ )cin>>c[i][j];\n\trotate(c[i]);\n    }\n    unsigned ll res = 0;\n    for(int f = 0; f<n; f++){\n\tfor(int s=f+1; s<n; s++){\n\t    for(int r=0; r<4; r++){\n\t\tunsigned ll mu=1;\n\t\tmap<vector<int>, int> occ; occ.clear();\n\t\tfor(int i=0; i<4; i++){\n\t\t    vector<int> tmp(4);\n\t\t    tmp[1] = c[f][i]; tmp[0] = c[f][(i+1)%4];\n\t\t    tmp[3] = c[s][3-(i+1)%4]; tmp[2] = c[s][3-i];\n\t\t    rotate(tmp);\n\t\t    mu*=(cntsq(c, tmp, f+1, s)-occ[tmp])*sym(tmp);\n//cout<<f<<\" \"<<s<<\" \"<<r<<\" \"<<i<<\" \"<<cntsq(c, tmp, f+1, s)<<\" \"<<mu<<\"\\n\";\n//cout<<tmp[0]<<tmp[1]<<tmp[2]<<tmp[3]<<\"\\n\";\n\t\t    occ[tmp]++;\n\t\t}\n\t\tres+=mu;\n\t\trot1(c[s]);\n//\t\tcout<<c[s][0]<<c[s][1]<<c[s][2]<<c[s][3]<<\"\\n\";\n\t    }\n\t}\n    }\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n     \ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nstruct Unionfind{\n  vi size, par;\n  Unionfind(){}\n  Unionfind( int n ) :  size(n,1), par(n){\n    REP( i , n ) par[i] = i;\n  }\n  void init( int n ){\n    size = vi( n , 1 );\n    par.resize( n );\n    REP( i , n ) par[i] = i;\n  }\n  int find( int x ){\n    if( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n  bool unite( int x , int y ){\n    x = find(x);\n    y = find(y);\n    if( x == y ) return false;\n    if( size[y] < size[x] ) swap( x , y );\n    par[x] = y;\n    size[y] += size[x];\n    return true;\n  }\n  bool same( int x , int y ){\n    return find(x) == find(y);\n  }\n};\n\n\nint n;\n\nvi c[410];\nll ha[410];\n\nUnionfind uf;\n\nvi rot( vi v ){\n  return { v[1] , v[2] , v[3] , v[0] };\n}\n\nbool same( vi a , vi b ){\n  REP( i , 4 ){\n    if( a == b ){\n      return true;\n    }\n    b = rot( b );\n  }\n  return false;\n}\n\nint weight( vi v ){\n  vi cur = v;\n  int cnt = 1;\n  REP( i , 3 ){\n    cur = rot( cur );\n    if( cur == v ){\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\nll perm( ll a , ll b ){\n  if( a < b ){\n    return 0;\n  }\n  ll res = 1;\n  REP( i , b ){\n    res *= a - i;\n  }\n  return res;\n}\n\n\nvi norm( vi v ){\n  vi res = v;\n  REP( i , 3 ){\n    v = rot( v );\n    chmin( res , v );\n  }\n  return res;\n}\n\nll calchash( vi v ){\n  return (ll)v[0] * 1000000000 + v[1] * 1000000 + v[2] * 1000 + v[3];\n}\n\nint main(){\n\n  n = in();\n  REP( i , n ){\n    REP( j , 4 ){\n      c[i].pb( in() );\n    }\n    c[i] = norm( c[i] );\n    ha[i] = calchash( c[i] );\n  }\n\n\n  /*\n  n = 400;\n  REP( i , n ){\n    REP( j , 4 ){\n      c[i].pb( 0 );\n    }\n    c[i] = norm( c[i] );\n    ha[i] = calchash( c[i] );\n  }\n  */\n  \n\n  int cnn = 0;\n  ll ans = 0;\n  REP( up , n ){\n    vi u = c[up];\n    REP( down , up ){\n      vi d = c[down];\n      REP( rotation , 4 ){\n\tmi s(4,vi(4));\n\tvl sh(4);\n\tREP( i , 4 ){\n\t  s[i][0] = u[i];\n\t  s[i][1] = d[(5-i)%4];\n\t  s[i][2] = d[(4-i)%4];\n\t  s[i][3] = u[(i+1)%4];\n\t  s[i] = norm( s[i] );\n\t  sh[i] = calchash( s[i] );\n\t}\n\n\tuf.init( 4 );\n\tREP( i , 4 ){\n\t  REP( j , i ){\n\t    if( sh[i] == sh[j] ){\n\t      uf.unite( i , j );\n\t    }\n\t  }\n\t}\n\n\tvi we(4,1);\n\tREP( i , 4 ){\n\t  we[ uf.find( i ) ] *= weight( s[i] );\n\t}\n\n\tvi cnt(4,0);\n\tREP( i , up ){\n\t  if( i == down ){\n\t    continue;\n\t  }\n\t  REP( j , 4 ){\n\t    if( sh[j] == ha[i] ){\n\t      cnt[j]++;\n\t    }\n\t  }\n\t}\n\n\tll cur = 1;\n\tREP( i , 4 ){\n\t  if( uf.find( i ) == i ){\n\t    cur *= we[i] * perm( cnt[i] , uf.size[i] );\n\t    /*\n\t    if( up == 5 and down == 2 and rotation == 0 ){\n\t      cout << i << \" \" << we[i] << \" \" << cnt[i] << \" \" << uf.size[i] << endl;\n\t      cout << we[i] * perm( cnt[i] , uf.size[i] ) << endl;\n\t    }\n\t    */\n\t  }\n\t}\n\n\tans += cur;\n\n\td = rot( d );\n      }\n    }\n  }\n\n  // cout << cnn << endl;\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ninline void rot(vector<int> &tile) {\n  rotate(tile.begin(), tile.begin() + 1, tile.end());\n}\n\ninline void rm_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]--;\n    rot(tile);\n  }\n}\n\ninline void add_tile(vector<int> &tile, map<vector<int>, int> &colors) {\n  REP(i, 4) {\n    colors[tile]++;\n    rot(tile);\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  vector<vector<int>> used;\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[tile], 0);\n    if (ret == 0) break;\n    rm_tile(tile, colors);\n    used.emplace_back(tile);\n  }\n\n  for (vector<int> &tile : used) add_tile(tile, colors);\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[tiles[i]]++;\n      rot(tiles[i]);\n    }\n  }\n\n  ll ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rot(tiles[low]);\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef array<int,4> A;\n\nLL toLL(A a){\n\tA r=a;\n\tfor(int i=0;i<3;i++){\n\t\trotate(a.begin(),a.begin()+1,a.end());\n\t\tr=min(r,a);\n\t}\n\tLL v=0;\n\tfor(int i=0;i<4;i++){\n\t\tv<<=10;\n\t\tv+=r[i];\n\t}\n\treturn v;\n}\nLL ord(A a){\n\tif(a[0]==a[2]&&a[1]==a[3]){\n\t\tif(a[0]==a[1]){\n\t\t\treturn 4;\n\t\t}\n\t\treturn 2;\n\t}\n\treturn 1;\n}\nconst LL M=1e9+7;\nLL vs[400];\nA C[400];\nint main() {\n\tint N;\n\tscanf(\"%d\",&N);\n\tunordered_map<LL,int> cnt;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tC[i][j]=a;\n\t\t}\n\t\tvs[i]=toLL(C[i]);\n\t\tcnt[vs[i]]++;\n\t}\n\tLL ret=0;\n\tfor(int i=0;i<N;i++){\n\t\tcnt[vs[i]]--;\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tcnt[vs[j]]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tLL r=1;\n\t\t\t\tint u[4];\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tA a={{C[i][(4-l+1)%4],C[i][(4-l)%4],C[j][(l+k+1)%4],C[j][(l+k)%4]}};\n\t\t\t\t\tLL v=toLL(a);\n\t\t\t\t\tr*=ord(a)*cnt[v];\n\t\t\t\t\tr%=M;\n#if 0\n\t\t\t\t\tif(i==0&&j==4){\n\t\t\t\t\t\tcerr << a[0] << \", \" << a[1] << \", \" << a[2] << \", \" << a[3] << endl;\n\t\t\t\t\t\tcerr << v << \" \" << cnt[v] << endl;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tu[l]=v;\n\t\t\t\t\tcnt[v]--;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tcnt[u[l]]++;\n\t\t\t\t}\n\t\t\t\tret+=r;\n\t\t\t\tret%=M;\n\t\t\t}\n\t\t\tcnt[vs[j]]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 400;\nunordered_map<LL,int> occ;\nLL arr[N + 5][4];\nLL f[N + 5];\nLL tmp[4];\n\nvoid shifting(LL x, int add) { //rotate \n\tfor(int i = 0;i < 4;i++) {\n\t\tocc[x] += add;\n\t\tx = ((x >> 10) | ((x & 1023) << 30));\n\t}\n}\n\nLL hashw(LL a, LL b, LL c, LL d) { //hashing four corner color into one integer\n\treturn (a << 30) | (b << 20) | (c << 10) | d;\n}\n\n\nint main(){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i = 0;i < n;i++) {\n\t\tfor(int j = 0;j < 4;j++) cin>>arr[i][j];\n\t\tf[i] = hashw(arr[i][0], arr[i][1], arr[i][2], arr[i][3]);\n\t\tshifting(f[i], 1);\n\t}\n\tLL tot = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\tshifting(f[i], -1); //fixing front side\n\t\tfor(int j = i + 1;j < n;j++) {\n\t\t\tshifting(f[j], -1); //fixing back side\n\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\ttmp[0] = hashw(arr[i][3], arr[i][2], arr[j][(1 + k) % 4], arr[j][k % 4]);\n\t\t\t\ttmp[1] = hashw(arr[i][2], arr[i][1], arr[j][(2 + k) % 4], arr[j][(k + 1) % 4]);\n\t\t\t\ttmp[2] = hashw(arr[i][1], arr[i][0], arr[j][(3 + k) % 4], arr[j][(k + 2) % 4]);\n\t\t\t\ttmp[3] = hashw(arr[i][0], arr[i][3], arr[j][(k) % 4], arr[j][(k + 3) % 4]);\n\t\t\t\tLL res = 1;\n\t\t\t\tfor(int i = 0;i < 4;i++) {\n\t\t\t\t\tres *= occ[tmp[i]];\n\t\t\t\t\tshifting(tmp[i], -1);\n\t\t\t\t}\n\t\t\t\ttot += res;\n\t\t\t\tfor(int i = 0;i < 4;i++) shifting(tmp[i], 1);\n\t\t\t}\n\t\t\tshifting(f[j], 1); \n\t\t}\n\t}\n\tcout<<tot<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint vtoi(int a, int b, int c, int d){\n    return a + 1000 * b + 1000000 * c + 1000000000 * d;\n}\nint vtoi(vec v){\n    return vtoi(v[0], v[1], v[2], v[3]);\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    mat C(N, vec(4));\n    vector<mat> C2(N, mat(4, vec(4)));\n    map<int, int> m;\n    REP(i, N){\n        readv(C[i]);\n        REP(r, 4){\n            REP(j, 4) C2[i][r][j] = C[i][(j + r) % 4];\n            m[vtoi(C2[i][r])] += 1;\n        }\n    }\n\n    int ans = 0;\n    mat side(4, vec(4));\n    REP(i, N){\n        REP(r, 4) m[vtoi(C2[i][r])] -= 1;\n        FOR(j, i + 1, N){\n            REP(r, 4) m[vtoi(C2[j][r])] -= 1;\n\n            REP(r, 4){\n                int tmp = 1;\n                REP(s, 4){\n                    side[s][0] = C2[i][0][(4 - s) % 4];\n                    side[s][1] = C2[i][0][3 - s];\n                    side[s][2] = C2[j][r][(1 + s) % 4];\n                    side[s][3] = C2[j][r][s];\n                }\n                REP(s, 4){\n                    tmp *= m[vtoi(side[s])];\n                    REP(r2, 4) m[vtoi(side[s][(0 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3])] -= 1;\n                }\n                REP(s, 4) REP(r2, 4) m[vtoi(side[s][(0 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3], side[s][(1 + r2) % 3])] += 1;\n                ans += tmp;\n            }\n\n            REP(r, 4) m[vtoi(C2[j][r])] += 1;\n        }\n        REP(r, 4) m[vtoi(C2[i][r])] += 1;\n    }\n    cout << ans / 3;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD = 1000000007ll;\n\n\nll modSum(ll a, ll b) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x) {\n  return getPowMod(x, MOD-2);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 401;\n\n\nint N;\ntuple<int, int, int, int> ar[MAXN];\nmap< tuple<int, int, int, int>, int> freq;\nset< pair< int, tuple<int, int, int, int> > > seen;\n\n\n\nvoid input() {\n  cin >> N;\n  vector<int> tmp(4);\n  for (int i = 1 ; i <= N ; i++) {\n    for (int j = 0 ; j < 4 ; j++) {\n      cin >> tmp[j];\n    }\n    bool inserted = false;\n    for (int j = 0 ; j < 4 ; j++) {\n      rotate(tmp.begin(), tmp.begin()+1, tmp.end());\n      if (freq.find({tmp[0], tmp[1], tmp[2], tmp[3]}) != freq.end()) {\n        inserted = true;\n        freq[{tmp[0], tmp[1], tmp[2], tmp[3]}]++;\n        break;\n      }\n    }\n    if (!inserted) {\n      freq[{tmp[0], tmp[1], tmp[2], tmp[3]}]++;\n    }\n    ar[i] = {tmp[0], tmp[1], tmp[2], tmp[3]};\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  ll ans = 0;\n  //for (auto p : freq) {\n  //  cerr << \"(\" << get<0>(p.first) << \", \" << get<1>(p.first) << \", \" << get<2>(p.first) << \", \" << get<3>(p.first) << \") - \" << p.second << \"\\n\";\n // }\n  vector< vector<int> > tmp(4, vector<int>(4));\n  for (int i = 1 ; i <= N ; i++) {\n    auto t1 = ar[i];\n    freq[t1]--;\n    for (int j = i+1 ; j <= N ; j++) {\n      auto t2 = ar[j];\n      if (seen.find({i, t2}) != seen.end()) {\n        continue;\n      }\n      //cerr << \"I = \" << i << \", J = \" << j << \", Ans = \" << ans << \"\\n\";\n      vector<int> tmp1 = {get<0>(t1), get<1>(t1), get<2>(t1), get<3>(t1)};\n      vector<int> tmp2 = {get<0>(t2), get<1>(t2), get<2>(t2), get<3>(t2)};\n      reverse(tmp2.begin(), tmp2.end());\n      ll origMul = freq[t2];\n      freq[t2]--;\n\n      for (int o = 0 ; o <= 3 ; o++) {\n        ll mul = origMul;\n        for (int s = 0 ; s <= 3 ; s++) {\n          tmp[s][3] = tmp1[(s+0) % 4]; \n          tmp[s][2] = tmp1[(s+1) % 4]; \n          tmp[s][1] = tmp2[(s+o+1) % 4]; \n          tmp[s][0] = tmp2[(s+o+0) % 4]; \n          //for (auto x : tmp[s]) {\n          //  cerr << x << \", \"; \n         // }\n          //cerr << \"\\n\";\n          ll add = 0;\n          for (int r = 0 ; r < 4 ; r++) {\n            rotate(tmp[s].begin(), tmp[s].begin()+1, tmp[s].end());\n            auto it = freq.find({tmp[s][0], tmp[s][1], tmp[s][2], tmp[s][3]});\n            if (it != freq.end()) {\n              add += it->second;\n            }\n          }\n          for (int r = 0 ; r < 4 ; r++) {\n            rotate(tmp[s].begin(), tmp[s].begin()+1, tmp[s].end());\n            auto it = freq.find({tmp[s][0], tmp[s][1], tmp[s][2], tmp[s][3]});\n            if (it != freq.end()) {\n              freq[it->first]--;\n              break;\n            }\n          }\n          //cerr << \"Add = \" << add << \"\\n\";\n          mul *= add;\n        }\n       // tuple<int, int, int, int> tup0 = {tmp[0][0], tmp[0][1], tmp[0][2], tmp[0][3]};\n       // tuple<int, int, int, int> tup1 = {tmp[1][0], tmp[1][1], tmp[1][2], tmp[1][3]};\n       // tuple<int, int, int, int> tup2 = {tmp[2][0], tmp[2][1], tmp[2][2], tmp[2][3]};\n       // tuple<int, int, int, int> tup3 = {tmp[3][0], tmp[3][1], tmp[3][2], tmp[3][3]};\n       // if (seen.find({tup0, tup2}) == seen.end() && seen.find({tup1, tup3}) == seen.end()) {\n       //   if (mul > 0) {\n       //     cerr << \"O = \" << o << \"\\n\";\n       //   }\n          ans += mul;\n        //}\n        for (int s = 0 ; s <= 3 ; s++) {\n          auto it = freq.find({tmp[s][0], tmp[s][1], tmp[s][2], tmp[s][3]});\n          if (it != freq.end()) {\n            freq[it->first]++;\n          }\n        }\n      }\n      freq[t2]++;\n      seen.insert({i, t2});\n    }\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Square = array<int, 4>;\n\nmap<Square, ll> memo;\n\nconst Square indices[] = {{1,0,1,0},{2,1,0,3},{3,2,3,2},{0,3,2,1}};\n\nvoid normalize(Square& s) {\n\tset<Square> tmp;\n\tfor (int i = 0; i < 4; i++) {\n\t\ttmp.insert(s);\n\t\trotate(s.begin(), s.begin() + 1, s.end());\n\t}\n\ts = *tmp.begin();\n}\n\nint pattern(Square& s) {\n\tif (s[0] == s[2] && s[1] == s[3]) {\n\t\tif (s[0] == s[1]) return 4;\n\t\telse return 2;\n\t}\n\treturn 1;\n}\n\nll solve(const Square& s1, const Square& s2) {\n\tll res = 1;\n\tint used = -1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tSquare tmp = {s1[indices[i][0]], s1[indices[i][1]], s2[indices[i][2]], s2[indices[i][3]]};\n\t\tnormalize(tmp);\n\t\tif (memo.find(tmp) == memo.end() || memo[tmp] == 0) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tres *= memo[tmp] * pattern(tmp);\n\t\tmemo[tmp]--;\n\t\tused++;\n\t}\n\n\tfor (int i = 0; i <= used; i++) {\n\t\tSquare tmp = {s1[indices[i][0]], s1[indices[i][1]], s2[indices[i][2]], s2[indices[i][3]]};\n\t\tnormalize(tmp);\n\t\tmemo[tmp]++;\t\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Square> c(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tnormalize(c[i]);\n\t\tmemo[c[i]]++;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tmemo[c[i]]--;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tmemo[c[j]]--;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tans += solve(c[i], c[j]);\n\t\t\t\trotate(c[j].begin(), c[j].begin() + 1, c[j].end());\n\t\t\t}\n\t\t\tmemo[c[j]]++;\n\t\t}\n\t\tmemo[c[i]]++;\t\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1))\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tvector<array<int, 4>>c(N);\n\trep(i, N)rep(j, 4)cin >> c[i][j];\n\tmap<array<int, 4>, vector<array<int, 2>>>m4;\n\trep(i, N) {\n\t\tif (c[i][0] == c[i][1] && c[i][1] == c[i][2] && c[i][2] == c[i][3]) {\n\t\t\tm4[{ c[i][0], c[i][0], c[i][0], c[i][0] }].push_back({ i,4 });\n\t\t}\n\t\telse if (c[i][0] == c[i][2] && c[i][1] == c[i][3]) {\n\t\t\tm4[{ c[i][0], c[i][1], c[i][0], c[i][1] }].push_back({ i,2 });\n\t\t\tm4[{ c[i][1], c[i][0], c[i][1], c[i][0] }].push_back({ i,2 });\n\n\t\t}\n\t\telse {\n\t\t\trep(j, 4) {\n\t\t\t\tm4[{ c[i][j], c[i][(j + 1) % 4], c[i][(j + 2) % 4], c[i][(j + 3) % 4] }].push_back({ i,1 });\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, N)REP(j, i + 1, N)rep(k, 4) {\n\t\tarray<int, 4>a1 = { c[i][0],c[j][(k + 1) % 4],c[j][(k + 0) % 4],c[i][1] };\n\t\tarray<int, 4>a2 = { c[i][1],c[j][(k + 0) % 4],c[j][(k + 3) % 4],c[i][2] };\n\t\tarray<int, 4>a3 = { c[i][2],c[j][(k + 3) % 4],c[j][(k + 2) % 4],c[i][3] };\n\t\tarray<int, 4>a4 = { c[i][3],c[j][(k + 2) % 4],c[j][(k + 1) % 4],c[i][0] };\n\t\tfor (auto x1 : m4[a1])if (i < x1[0] && j != x1[0]) {\n\t\t\tfor (auto x2 : m4[a2])if (i < x2[0] && j != x2[0] && x1[0] != x2[0]) {\n\t\t\t\tfor (auto x3 : m4[a3])if (i < x3[0] && j != x3[0] && x1[0] != x3[0] && x2[0] != x3[0]) {\n\t\t\t\t\tfor (auto x4 : m4[a4])if (i < x4[0] && j != x4[0] && x1[0] != x4[0] && x2[0] != x4[0] && x3[0] != x4[0]) {\n\t\t\t\t\t\tans+=x1[1]*x2[1]*x3[1]*x4[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {}, mm = 0;\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j], mm = max(mm, a[i][j]);\n    for (int i = 1; i <= n; i++) {\n        map<pair<pii, pii>, ll> p;\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                if (mm <= 1 && p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}]) {\n                    z += p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}];\n                    continue;\n                }\n                int b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}}, c[404][4] = {};\n                ll d[16] = {};\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 0; m < 4; m++) {\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[l][m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[l][m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[l][m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[l][m]++;\n                    }\n                }\n                d[0] = 1;\n                for (int l = i + 1; l <= n; l++) {\n                    for (int m = 15; m >= 0; m--) {\n                        if (l != j) {\n                            for (int o = 0; o < 4; o++) if (m & (1 << o)) d[m] += c[l][o] * d[m - (1 << o)];\n                        }\n                    }\n                }\n                if (mm <= 1) p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}] = d[15];\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int N=410;\nint K;\nll a[N],C[N];\nint A[N],B[N];\nmap <ll,int> w;\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline ll F(ll x) {return x/1000+x%1000*1000000000;}\ninline ll get(ll x) {\n    ll ret=x;K=1;\n    for(int i=0;i<3;i++) {\n\tx=F(x);\n\tif(x<ret) ret=x,K=0;\n\tif(x==ret) ++K;\n    }\n    return ret;\n}\nint main() {\n    int n;\n    ll ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n\tll x=0;\n\tfor(int j=0;j<4;j++) x=x*1000+gi();\n\t++w[a[i]=get(x)];\n    }\n    for(int i=1;i<=n;i++) {\n\t--w[a[i]];\n\tfor(int j=i+1;j<=n;j++) {\n\t    --w[a[j]];\n\t    for(int k=0;k<4;k++) {\n\t\tll x=a[i],y=a[j]=F(a[j]),res=1;\n\t\tfor(int p=0;p<4;p++,x/=1000,y/=1000)\n\t\t    A[3-p]=x%1000,B[3-p]=y%1000;\n\t\tswap(B[1],B[3]);\n\t\tfor(int p=0;p<4;p++) {\n\t\t    C[p]=get(A[p]*1000000000LL+B[p]*1000000+B[(p+1)%4]*1000+A[(p+1)%4]);\n\t\t    res*=K*w[C[p]]--;\n\t\t}\n\t\tans+=res;\n\t\tfor(int p=0;p<4;p++) ++w[C[p]];\n\t    }\n\t    ++w[a[j]];\n\t}\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<vector<ll>,ll>mp;\n  ll access(vector<ll>v){\n    ll ret=0;\n    ret+=mp[{v[0],v[1],v[2],v[3]}];\n    ret+=mp[{v[1],v[2],v[3],v[0]}];\n    ret+=mp[{v[2],v[3],v[0],v[1]}];\n    ret+=mp[{v[3],v[0],v[1],v[2]}];\n    //cout<<ret<<endl;\n    return max(0LL,ret);\n  }\n  void change(vector<ll>v,ll w){\n    if(!mp.count(v))return;\n    mp[v]+=w;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,0LL);\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.mp[c[i]]++;\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<ll>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<ll>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 400\nint aa[] = {4, 0, 3, 7}, bb[] = {1, 5, 6, 2}, cc[] = {5, 4, 7, 6};\nint n;\nvector<int> c[N];\nvector<int> c2[4*N];\nvector<int> c3[N];\nint rr[N];\nmap<vector<int>, int> cnt;\n\nvoid rot(vector<int> &a){\n\tint t = a[0];\n\trep(i, 3) a[i] = a[i+1];\n\ta[3] = t;\n}\n\nvoid rot2(vector<int> &a){\n\tvector<int> b(a);\n\trep(i, 3){\n\t\trot(b);\n\t\tif(a>b) a = b;\n\t}\n}\n\nint f(vector<int> &a){\n\tif(a[0]!=a[2] || a[1]!=a[3]) return 1;\n\tif(a[0]!=a[1]) return 2;\n\treturn 4;\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n){\n\t\tc[i] = vector<int>(4);\n\t\trep(j, 4) cin>>c[i][j];\n\t\trot2(c[i]);\n\t\tc3[i] = c[i];\n\t\trr[i] = f(c[i]);\n\t\trep(j, 4){\n\t\t\tc2[i*4+j] = c[i];\n\t\t\t++cnt[c[i]];\n\t\t\trot(c[i]);\n\t\t}\n\n\t}\n\tll res = 0;\n\tvector<int> e(8);\n\tfor(int i = 0; i < n; i++){\n\t\trep(_, 4) e[_] = c[i][_];\n\t\tfor(int jj = 0; jj < n*4; jj++){\n\t\t\tint j = jj/4, j2 = j%4;\n\t\t\tif(i==j) continue;\n\t\t\t//if(rr[j]*(j2)>=4) continue;\n\t\t\tif(!(c2[jj][2]==c[i][1]&&c2[jj][3]==c[i][0])) continue;\n\t\t\te[4] = c2[jj][0];\n\t\t\te[5] = c2[jj][1];\n\t\t\tfor(int kk = 0; kk < n*4; kk++){\n\t\t\t\tint k = kk/4, k2 = k%4;\n\t\t\t\tif(i==k || j==k) continue;\n\t\t\t\t//if((rr[k]*k2)>=4) continue;\n\t\t\t\tif(!(c2[kk][0]==c[i][3]&&c2[kk][1]==c[i][2])) continue;\n\t\t\t\te[6] = c2[kk][2];\n\t\t\t\te[7] = c2[kk][3];\n\n\t\t\t\tvector<int> a(4), b(4), c(4);\n\t\t\t\trep(_, 4){\n\t\t\t\t\ta[_] = e[aa[_]];\n\t\t\t\t\tb[_] = e[bb[_]];\n\t\t\t\t\tc[_] = e[cc[_]];\n\t\t\t\t}\n\t\t\t\trot2(a); rot2(b); rot2(c);\n\t\t\t\tif(!cnt[a]||!cnt[b]||!cnt[c]) continue;\n\t\t\t\tll tres = 0;\n\t\t\t\tif(a==b && b==c){\n\t\t\t\t\tll t = cnt[a];\n\t\t\t\t\tll r = f(a);\n\t\t\t\t\tll s = 0;\n\t\t\t\t\tif(c3[i]==a) s++;\n\t\t\t\t\tif(c3[j]==a) s++;\n\t\t\t\t\tif(c3[k]==a) s++;\n\t\t\t\t\tt -= s*r;\n\t\t\t\t\ttres = t*(t-r)*(t-r*2);\n\t\t\t\t} else {\n\t\t\t\t\tif(a==c) swap(b, c);\n\t\t\t\t\tif(b==c) swap(a, c);\n\t\t\t\t\tif(a==b){\n\t\t\t\t\t\tll t = cnt[a];\n\t\t\t\t\t\tll r = f(a), r2 = f(c);\n\t\t\t\t\t\tll s = 0, s2 = 0;\n\t\t\t\t\t\tif(c3[i]==a) s++;\n\t\t\t\t\t\tif(c3[j]==a) s++;\n\t\t\t\t\t\tif(c3[k]==a) s++;\n\t\t\t\t\t\tif(c3[i]==c) s2++;\n\t\t\t\t\t\tif(c3[j]==c) s2++;\n\t\t\t\t\t\tif(c3[k]==c) s2++;\n\t\t\t\t\t\tt -= s*r;\n\t\t\t\t\t\ttres = t*(t-r)*(cnt[c]-s2*r2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tll r = f(a), r2 = f(b), r3 = f(c);\n\t\t\t\t\t\tll s = 0, s2 = 0, s3 = 0;\n\t\t\t\t\t\tif(c3[i]==a) s++;\n\t\t\t\t\t\tif(c3[j]==a) s++;\n\t\t\t\t\t\tif(c3[k]==a) s++;\n\t\t\t\t\t\tif(c3[i]==b) s2++;\n\t\t\t\t\t\tif(c3[j]==b) s2++;\n\t\t\t\t\t\tif(c3[k]==b) s2++;\n\t\t\t\t\t\tif(c3[i]==c) s3++;\n\t\t\t\t\t\tif(c3[j]==c) s3++;\n\t\t\t\t\t\tif(c3[k]==c) s3++;\n\t\t\t\t\t\ttres = (cnt[a]-s*r)*(cnt[b]-s2*r2)*(cnt[c]-s3*r3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//res += tres*rr[j]*rr[k];\n\t\t\t\tres += tres;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res/6<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<ll,int>mp;\n  const ll tmp=(1<<10)-1;\n  ll access(const vector<short>&v){\n    ll ret=0;\n    ll now=trans(v);\n    rep(i,0,4){\n      ret+=mp[now];\n      now=shift(now);\n    }\n    return max(0LL,ret);\n  }\n  void change(const vector<short>&v,ll w){\n    //ll t=trans(v);\n    //if(!mp.count(t))return;\n    mp[trans(v)]+=w;\n  }\n  ll trans(const vector<short>&v){\n    return v[0]+((ll)v[1]<<10)+((ll)v[2]<<20)+((ll)v[3]<<30);\n  }\n  ll shift(ll x){\n    return (x>>10)+((x&tmp)<<30);\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,short(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.mp[dict.trans(c[i])]++;\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<short>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<short>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define MD 100007\n#define MX 444\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\ntemplate <typename T> void read(T& x)\n{\n\tx = 0; char c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n}\n\nstruct HASH\n{\n\tint fst[MD], nxt[MX*4], hnum;\n\tull key[MX*4], val[MX*4];\n\tull rehash(ull *a) {return (a[0]) | (a[1]<<10) | (a[2]<<20) | (a[3]<<30);}\n\tvoid insert(ull k, ull x)\n\t{\n\t\tint p = k % MD;\n\t\tfor(int i=fst[p]; i; i=nxt[i])\n\t\t\tif(key[i] == k)\n\t\t\t{\n\t\t\t\tval[i] += x;\n\t\t\t\treturn;\n\t\t\t}\n\t\tnxt[++hnum] = fst[p];\n\t\tfst[p] = hnum;\n\t\tkey[hnum] = k;\n\t\tval[hnum] = x;\n\t}\n\tull query(ull k)\n\t{\n\t\tfor(int i=fst[k%MD]; i; i=nxt[i])\n\t\t\tif(key[i] == k)\n\t\t\t\treturn val[i];\n\t\treturn 0;\n\t}\n} H;\n\null col[MX][4];\nint N;\n\nvoid rotate(ull* t, ull* x)\n{\n\tull a = x[0];\n\tt[0] = x[1], t[1] = x[2], t[2] = x[3], t[3] = a;\n}\n\nvoid comb(ull* t, const ull* x, const ull* y, int p)\n{\n\tt[0] = x[p&3], t[1] = y[(3-p)&3], t[2] = y[(2-p)&3], t[3] = x[(p+1)&3];\n}\n\nvoid input()\n{\n\tread(N);\n\tfor(int i=1; i<=N; i++)\n\t{\n\t\tread(col[i][0]);\n\t\tread(col[i][1]);\n\t\tread(col[i][2]);\n\t\tread(col[i][3]);\n\t}\n}\n\nvoid add(ull* f, ull x)\n{\n\tfor(int i=0; i<4; i++) rotate(f, f), H.insert(H.rehash(f), x);\n}\n\nvoid work()\n{\n\tfor(int i=1; i<=N; i++) add(col[i], +1);\n\tull ans = 0;\n\tull f[6][4], n[6];\n\tmemset(f, 0, sizeof(f)), memset(n, 0, sizeof(n));\n\tfor(int i=1; i<=N; i++)\n\t{\n\t\tmemmove(f[0], col[i], sizeof(f[0])), add(f[0], -1);\n\t\tfor(int j=i+1; j<=N; j++)\n\t\t{\n\t\t\tmemmove(f[1], col[j], sizeof(f[1])), add(f[1], -1);\n\t\t\tfor(int k=0; k<4; k++)\n\t\t\t{\n\t\t\t\tbool ok = 1;\n\t\t\t\trotate(f[1], f[1]);\n\t\t\t\tfor(int p=2; p<6; p++) comb(f[p], f[0], f[1], p-2);\n\t\t\t\tfor(int p=2; p<6; p++)\n\t\t\t\t{\n\t\t\t\t\tn[p] = H.query(H.rehash(f[p]));\n\t\t\t\t\tif(!n[p]) ok = 0;\n\t\t\t\t\tif(n[p]) add(f[p], -1);\n\t\t\t\t}\n\t\t\t\tfor(int p=2; p<6; p++) if(n[p]) add(f[p], +1);\n\t\t\t\tif(ok) ans += n[2] * n[3] * n[4] * n[5];\n\t\t\t}\n\t\t\tadd(f[1], +1);\n\t\t}\n\t\tadd(f[0], +1);\n\t}\n\tprintf(\"%llu\\n\", ans/3);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include <utility>\n#include <cstdio>\n#include<algorithm>\n#include<queue>\n#define ll  long long\n\nusing namespace std;\n\tint n;\nvoid rotate(vector<int> & vec){\n    vector<int> tmp(4);\n    int minind = min_element(vec.begin(), vec.end() ) - vec.begin();\n    for(int i=3; i>0; i--){\n\tif(vec[i]==vec[minind]){\n\t    minind=i;\n\t}else{\n\t    break;\n\t}\n    }\n    for(int i=0; i<4; i++){\n\ttmp[i] = vec[(i+minind)%4];\n    }\n    vec=tmp;\n}\nvoid rot1(vector<int> & vec){\n    int tmp = vec[0];\n    for(int i=0; i<4; i++){\n\tvec[i] = vec[i+1];\n    }\n    vec[3]=tmp;\n}\nint cntsq(vector<vector<int> > & c, vector<int>  & sq, int st, int sk){\n    int res=0;\n    for(int i=st; i<n; i++)\n\tif(i!=sk && c[i]==sq)res++;\n    return res;\n}\nint sym(vector<int> v){\n    if(v[0]!=v[2] || v[1]!=v[3])return 1;\n    if(v[0]!=v[1] || v[2]!=v[3])return 2;\n    return 4;\n}\nint main(){\n    cin>>n;\n    vector<vector<int> > c(n, vector<int>(4));\n    for(int i=0; i<n; i++){\n\tfor(int j=0; j<4; j++ )cin>>c[i][j];\n\trotate(c[i]);\n    }\n    double res = 0;\n    for(int f = 0; f<n; f++){\n\tfor(int s=f+1; s<n; s++){\n\t    for(int r=0; r<4; r++){\n\t\tunsigned ll mu=1;\n\t\tmap<vector<int>, int> occ; occ.clear();\n\t\tfor(int i=0; i<4; i++){\n\t\t    vector<int> tmp(4);\n\t\t    tmp[1] = c[f][i]; tmp[0] = c[f][(i+1)%4];\n\t\t    tmp[3] = c[s][3-(i+1)%4]; tmp[2] = c[s][3-i];\n\t\t    rotate(tmp);\n\t\t    mu*=(cntsq(c, tmp, f+1, s)-occ[tmp])*sym(tmp);\n//cout<<f<<\" \"<<s<<\" \"<<r<<\" \"<<i<<\" \"<<cntsq(c, tmp, f+1, s)<<\" \"<<mu<<\"\\n\";\n//cout<<tmp[0]<<tmp[1]<<tmp[2]<<tmp[3]<<\"\\n\";\n\t\t    occ[tmp]++;\n\t\t}\n\t\tres+=mu;\n\t\trot1(c[s]);\n//\t\tcout<<c[s][0]<<c[s][1]<<c[s][2]<<c[s][3]<<\"\\n\";\n\t    }\n\t}\n    }\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 11116\n\nint n,c[N][4],e[4][4],f[N];\nlong long h[N],ans;\n\nint query(int c[]){\n\tlong long tmp=((c[0]*1000ll+c[1])*1000+c[2])*1000+c[3];\n\tint x=lower_bound(h+1,h+4*n+1,tmp)-h;\n\treturn h[x]==tmp?f[x]:0;\n}\n\nvoid modify(int c[],int t){\n\tf[lower_bound(h+1,h+4*n+1,((c[0]*1000ll+c[1])*1000+c[2])*1000+c[3])-h]+=t;\n\tf[lower_bound(h+1,h+4*n+1,((c[1]*1000ll+c[2])*1000+c[3])*1000+c[0])-h]+=t;\n\tf[lower_bound(h+1,h+4*n+1,((c[2]*1000ll+c[3])*1000+c[0])*1000+c[1])-h]+=t;\n\tf[lower_bound(h+1,h+4*n+1,((c[3]*1000ll+c[0])*1000+c[1])*1000+c[2])-h]+=t;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\tc[i][0]=c[n+i][1]=c[2*n+i][2]=c[3*n+i][3]=read();\n\t\tc[i][1]=c[n+i][2]=c[2*n+i][3]=c[3*n+i][0]=read();\n\t\tc[i][2]=c[n+i][3]=c[2*n+i][0]=c[3*n+i][1]=read();\n\t\tc[i][3]=c[n+i][0]=c[2*n+i][1]=c[3*n+i][2]=read();\n\t}\n\tfor (int i=1;i<=4*n;i++)\n\t\th[i]=((c[i][0]*1000ll+c[i][1])*1000+c[i][2])*1000+c[i][3];\n\tsort(h+1,h+4*n+1);h[4*n+1]=1e12;\n\tfor (int i=1;i<=n;i++)\n\t\tmodify(c[i],1);\n\t\n\tfor (int i=1;i<=4*n;i++)\n\t\tfor (int j=i+1;j<=4*n;j++)\n\t\t\tif (i%n!=j%n){\n\t\t\t\tmodify(c[i],-1);modify(c[j],-1);\n\t\t\t\te[0][0]=c[i][1];e[0][1]=c[i][0];e[0][2]=c[j][1];e[0][3]=c[j][0];\n\t\t\t\te[1][0]=c[i][2];e[1][1]=c[i][1];e[1][2]=c[j][0];e[1][3]=c[j][3];\n\t\t\t\te[2][0]=c[i][3];e[2][1]=c[i][2];e[2][2]=c[j][3];e[2][3]=c[j][2];\n\t\t\t\te[3][0]=c[i][0];e[3][1]=c[i][3];e[3][2]=c[j][2];e[3][3]=c[j][1];\n\t\t\t\tlong long tmp=query(e[0]);modify(e[0],-1);\n\t\t\t\ttmp*=query(e[1]);modify(e[1],-1);\n\t\t\t\ttmp*=query(e[2]);modify(e[2],-1);\n\t\t\t\tans+=tmp*query(e[3]);\n\t\t\t\tmodify(e[0],1);modify(e[1],1);modify(e[2],1);\n\t\t\t\tmodify(c[i],1);modify(c[j],1);\n\t\t\t}\n\tprintf(\"%lld\\n\",ans/12);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t5005\n#define MAXV\t1000\n#define P\t1000003\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct Hash_Table {\n\tvector <int> value[P], cnt[P];\n\tint query(long long val) {\n\t\tint head = val % P;\n\t\tfor (unsigned i = 0; i < value[head].size(); i++)\n\t\t\tif (value[head][i] == val) return cnt[head][i];\n\t\treturn 0;\n\t}\n\tvoid modify(long long val, int delta) {\n\t\tint head = val % P;\n\t\tfor (unsigned i = 0; i < value[head].size(); i++)\n\t\t\tif (value[head][i] == val) {\n\t\t\t\tcnt[head][i] += delta;\n\t\t\t\treturn;\n\t\t\t}\n\t\tvalue[head].push_back(val);\n\t\tcnt[head].push_back(delta);\n\t}\n} cnt;\nint n, a[MAXN], b[MAXN], c[MAXN], d[MAXN];\nlong long Hash(int a, int b, int c, int d) {\n\tlong long ans = a;\n\tans = ans * MAXV + b;\n\tans = ans * MAXV + c;\n\tans = ans * MAXV + d;\n\treturn ans;\n}\nint Count(int a, int b, int c, int d) {\n\treturn cnt.query(Hash(a, b, c, d));\n}\nvoid Modify(int a, int b, int c, int d, int x) {\n\tcnt.modify(Hash(a, b, c, d), x);\n\tcnt.modify(Hash(d, a, b, c), x);\n\tcnt.modify(Hash(c, d, a, b), x);\n\tcnt.modify(Hash(b, c, d, a), x);\n}\nlong long Query(int a, int b, int c, int d, int A, int B, int C, int D) {\n\tlong long ans = 1;\n\tans *= Count(a, A, B, b);\n\tModify(a, A, B, b, -1);\n\tans *= Count(b, B, C, c);\n\tModify(b, B, C, c, -1);\n\tans *= Count(c, C, D, d);\n\tModify(c, C, D, d, -1);\n\tans *= Count(d, D, A, a);\n\tModify(d, D, A, a, -1);\n\tModify(a, A, B, b, 1);\n\tModify(b, B, C, c, 1);\n\tModify(c, C, D, d, 1);\n\tModify(d, D, A, a, 1);\n\treturn ans;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]), read(b[i]), read(c[i]), read(d[i]);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tModify(a[j], b[j], c[j], d[j], -1);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], d[j], c[j], b[j], a[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], a[j], d[j], c[j], b[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], b[j], a[j], d[j], c[j]);\n\t\t\tans += Query(a[i], b[i], c[i], d[i], c[j], b[j], a[j], d[j]);\n\t\t\tModify(a[j], b[j], c[j], d[j], 1);\n\t\t}\n\t\tModify(a[i], b[i], c[i], d[i], 1);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long li;\n\nli hash_color(const vector<int> &colors) {\n    li v = 0;\n    li pow = 1;\n    for (int i = 0; i < 4; ++i) {\n        v += colors[i] * pow;\n        pow *= 1000;\n    }\n    return v;\n}\n\nvector<int> rotate(const vector<int> &colors) {\n    return {colors[1], colors[2], colors[3], colors[0]};\n}\n\nvector<int> rotate(const vector<int> &colors, const int count) {\n    vector<int> ret = colors;\n    for (int i = 0; i < count; ++i) {\n        ret = rotate(ret);\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> colors(n, vector<int>(4));\n    map<li, map<int, int>> card_index;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n        }\n        for (int d = 0; d < 4; ++d) {\n            card_index[hash_color(rotate(colors[i], d))][i] += 1;\n        }\n    }\n\n    li ans = 0;\n    for (int bottom = 0; bottom < n; ++bottom) {\n        // flipped\n        const vector<int> bottom_colors = {\n                colors[bottom][3],\n                colors[bottom][2],\n                colors[bottom][1],\n                colors[bottom][0]\n        };\n        for (int top = bottom + 1; top < n; ++top) {\n            for (int top_dir = 0; top_dir < 4; ++top_dir) {\n                const vector<int> top_colors = rotate(colors[top], top_dir);\n\n                vector<vector<int>> choices(n, vector<int>(4));\n\n                for (int side_index = 0; side_index < 4; ++side_index) {\n                    const vector<int> side_colors = {\n                            bottom_colors[side_index],\n                            bottom_colors[(side_index + 1) % 4],\n                            top_colors[(side_index + 1) % 4],\n                            top_colors[side_index]\n                    };\n                    const li side_hash = hash_color(side_colors);\n                    for (auto p : card_index[side_hash]) {\n                        const int card_id = p.first;\n                        if (card_id > bottom && card_id != top) {\n                            choices[card_id][side_index] += p.second;\n                        }\n                    }\n                }\n\n                vector<li> dp(16, 0);\n                dp[0] = 1;\n                for (int i = 0; i < n; ++i) {\n                    vector<li> ndp = dp;\n                    for (int j = 0; j < 15; ++j) {\n                        for (int side = 0; side < 4; ++side) {\n                            int nj = j | (1LL << side);\n                            if (nj == j) {\n                                continue;\n                            }\n                            ndp[nj] += dp[j] * choices[i][side];\n                        }\n                    }\n                    dp = ndp;\n                }\n\n                ans += dp[15];\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define int long long\n#define mp make_pair\n#define inf 998244353\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nll henkan(ll c1, ll c2, ll c3,ll c4){\n\tll h1 = 1000000000LL * c1 + 1000000LL * c2 + 1000*c3 + c4;\n\tll h2 = 1000000000LL * c2 + 1000000LL * c3 + 1000*c4 + c1;\n\tll h3 = 1000000000LL * c3 + 1000000LL * c4 + 1000*c1 + c2;\n\tll h4 = 1000000000LL * c4 + 1000000LL * c1 + 1000*c2 + c3;\n\treturn min(h1,min(h2,min(h3,h4)));\n}\nll rotate(ll num){\n\tll res=0;\n\tres += num / 1000000000LL;\n\tres += ( num % 1000000000LL) * 1000;\n\treturn res;\n}\nsigned main(){\n\tll n; cin>>n;\n\tmap<ll,ll> mope, mope2;\n\tvector<ll> v;\n\tfor(ll i=0;i<n;i++){\n\t\tll x,y,z,w;\n\t\tcin>>x>>y>>z>>w;\n\t\tll num = henkan(x,y,z,w);\n\t\tv.pb(num);\n\t\tmope[num]++;\n\t\tif( x==y && y==z && z==w ){\n\t\t\tmope2[num] = 4;\n\t\t}\n\t\telse if( x == z && y == w ){\n\t\t\tmope2[num] = 2;\n\t\t}\n\t\telse{\n\t\t\tmope2[num] = 1;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(ll i=0;i<n;i++){\n\t\tll cur = v[i];\n\t\tll ii[4];\n\t\tfor(ll j=0;j<4;j++){\n\t\t\tii[3-j] = cur % 1000;\n\t\t\tcur /= 1000;\n\t\t}\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif( i!=j ){\n\t\t\t\tvector<ll> rots;\n\t\t\t\tll cur2 = v[j];\n\t\t\t\tfor(ll k=0;k<4;k++){\n\t\t\t\t\trots.pb(cur2);\n\t\t\t\t\t//cout<<\"!!!\"<<cur2<<endl;\n\t\t\t\t\tcur2 = rotate(cur2);\n\t\t\t\t}\n\t\t\t\tfor(ll k=0;k<4;k++){\n\t\t\t\t\tll tmp = 1;\n\t\t\t\t\tll cur3 = rots[k];\n\t\t\t\t\tll jj[4];\n\t\t\t\t\tfor(ll p=0;p<4;p++){\n\t\t\t\t\t\tjj[3-p] = cur3 % 1000;\n\t\t\t\t\t\tcur3 /= 1000;\n\t\t\t\t\t}\n\t\t\t\t\tvector<ll> gds;\n\t\t\t\t\tgds.pb( henkan( jj[1],jj[0],ii[1],ii[0] ) );\n\t\t\t\t\tgds.pb( henkan( jj[2],jj[1],ii[0],ii[3] ) );\n\t\t\t\t\tgds.pb( henkan( jj[3],jj[2],ii[3],ii[2] ) );\n\t\t\t\t\tgds.pb( henkan( jj[0],jj[3],ii[2],ii[1] ) );\n\t\t\t\t\t//for(ll p=0;p<4;p++){ cout<<i<<\" \"<<j<<\" \"<<gds[p]<<\" \"<<mope[gds[p]]<<endl; }\n\t\t\t\t\tmope[v[i]]--;\n\t\t\t\t\tmope[v[j]]--;\n\t\t\t\t\tfor(ll p=0;p<4;p++){\n\t\t\t\t\t\ttmp *= mope[ gds[p] ] * mope2[ gds[p] ];\n\t\t\t\t\t\tmope[ gds[p] ]--;\n\t\t\t\t\t}\n\t\t\t\t\tfor(ll p=0;p<4;p++){\n\t\t\t\t\t\tmope[ gds[p] ]++;\n\t\t\t\t\t}\n\t\t\t\t\tmope[v[i]]++;\n\t\t\t\t\tmope[v[j]]++;\n\t\t\t\t\t//if( tmp > 0 ) cout<< i << j << k << endl;\n\t\t\t\t\tans += tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\npa4 rot(pa4 z){\n\treturn {z.w,z.x,z.y,z.z};\n}\nint hen(pa4 z){\n\treturn z.x+1000*z.y+1000000*z.z+1000000000*z.w;\n}\n\n\nint ki(int z0){\n\tint ans=z0;\n\tfor(int i=0;i<3;i++){\n\t\tint am=z0%1000;\n\t\tz0/=1000;\n\t\tz0+=am*1000000000ll;\n\t\tans=min(ans,z0);\n\t}\n\treturn ans;\n}\n\nint tai(int z){\n\tint y0=z%1000;\n\tz/=1000;\n\tint y1=z%1000;\n\tz/=1000;\n\tint y2=z%1000;\n\tz/=1000;\n\tint y3=z%1000;\n\tz/=1000;\n\t\n\tif(y1==y2 && y1==y0 && y1==y3) return 4;\n\tif(y1==y3 && y0==y2) return 2;\n\treturn 1;\n}\npa4 iro[400][4];\n\nint kijun[400];\nmap<int,int> K; \nint b(int n,int r){\n\tif(r==0) return 1;\n\tif(r==1) return n;\n\tif(r%2)return b(n,r-1)*n;\n\tint z=b(n,r/2);\n\treturn z*z;\n}\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n // \tcin>>n;\n  n=400;\t\n  \tfor(int i=0;i<n;i++){\n  \t\tint y1,y2,y3,y4;\n  \t//\tcin>>y1>>y2>>y3>>y4;\n  \t\ty1=0,y2=0,y3=0,y4=0;\n  \t\tiro[i][0]={y1,y2,y3,y4};\n  \t\tfor(int j=1;j<4;j++)iro[i][j]=rot(iro[i][j-1]);\n  \t\tkijun[i]=ki(hen(iro[i][0]));\n  \t\tK[kijun[i]]++;\n  \t\n  \t}\n  \t\n  \tint ans=0,amari=0;\n  \tfor(int s=0;s<n;s++)for(int t=0;t<n;t++)if(s!=t)for(int l=0;l<4;l++)for(int r=0;r<4;r++){\n  \t\t\n  \t\tint e[4];\n  \t\te[0]=hen({iro[s][l].x,iro[s][l].w,iro[t][r].x,iro[t][r].w});\n  \t\te[1]=hen({iro[s][l].w,iro[s][l].z,iro[t][r].y,iro[t][r].x});\n  \t\te[2]=hen({iro[s][l].z,iro[s][l].y,iro[t][r].z,iro[t][r].y});\n  \t\te[3]=hen({iro[s][l].y,iro[s][l].x,iro[t][r].w,iro[t][r].z});\n  \t\t\n  \t\tfor(int i=0;i<4;i++)e[i]=ki(e[i]);\n  \t\tK[kijun[s]]--;\n  \t\tK[kijun[t]]--;\n  \t\tbool bo=true;\n  \t\tfor(int i=0;i<4;i++)if(K.count(e[i])==0||K[e[i]]==0) bo=false;\n  \t\t\n  \t\tif(bo){\n  \t\t//int cnt=0;\n  \t\tvector<pa> Pair;\n  \t\tmap<int,int >w;\n  \t\tfor(int i=0;i<4;i++){\n  \t\t\tw[e[i]]++;\n  \t\t}\n  \t\tint ka=1;\n  \t\t\t/*\n  \t\t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\t\tcout<<it->first<<\" \"<<it->second<<endl;\n  \t\t\t}\n  \t\t\tcout<<endl;\n  \t\t\t*/\n  \t\tfor(auto it=w.begin();it!=w.end();it++){\n  \t\t\tif(it->second==4){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<4){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*(num-3)*b(tai(it->first),4);\n  \t\t\t}\n  \t\t\tif(it->second==3){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<3){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*(num-2)*b(tai(it->first),3);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==2){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<2){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tka*=num*(num-1)*b(tai(it->first),2);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(it->second==1){\n  \t\t\t\tint num=0;\n  \t\t\t\tif(K.count(it->first))num=K[it->first];\n  \t\t\t\tif(num<1){\n  \t\t\t\t\tka=0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t//\t\tcout<<tai(it->first)<<endl;\n  \t\t\t\tka*=num*b(tai(it->first),1);\n  \t\t\t}\n  \t\t}\n  \t\t\t//cout<<ka<<endl;\n  \t\t\tans+=ka/24;\n  \t\t\tamari+=ka%24;\n  \t\t\twhile(amari>=24){\n  \t\t\tamari-=24;\n  \t\t\t\tans++;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\tK[kijun[s]]++;\n  \t\tK[kijun[t]]++;\n  \t}\n  \tassert(amari==0);\n  \t\n  \tcout<<ans<<endl;\n  \t\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u];i;i=sq[i].nxt)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 998244353\n#define eps 1e-8\n#define bas 1000\n#define lst3 1000000000\nint n,c[410][4],need[4][4];\nll val[410],nval[4];\nmap<ll,int> mp;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nvoid insert(ll now,int val)\n{\n\trep(i,0,3)\n\t{\n\t\tmp[now]+=val;\n\t\tnow=now/bas+(now%bas)*lst3;\n\t}\n}\n\nint calc(ll val,int pos)\n{\n\trep(i,1,3-pos) val/=bas;\n\treturn val%bas;\n}\n\nint main()\n{\n\tn=read();\n\trep(i,1,n) \n\t{\n\t\trep(j,0,3) c[i][j]=read();\n\t\trep(j,0,3) val[i]=val[i]*bas+c[i][j];\n\t\t//cout << val[i] << \" \";cout << endl;\n\t\tinsert(val[i],1);\n\t}\n\tll ans=0;\n\trep(i,1,n) \n\t{\n\t\tinsert(val[i],-1);\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tinsert(val[j],-1);\n\t\t\trep(k,0,3)\n\t\t\t{\n\t\t\t\tneed[0][0]=calc(val[j],1);need[0][1]=calc(val[j],0);need[0][2]=calc(val[i],1);need[0][3]=calc(val[i],0);\n\t\t\t\tneed[1][0]=calc(val[i],1);need[1][1]=calc(val[j],0);need[1][2]=calc(val[j],3);need[1][3]=calc(val[i],2);\n\t\t\t\tneed[2][0]=calc(val[j],3);need[2][1]=calc(val[j],2);need[2][2]=calc(val[i],3);need[2][3]=calc(val[i],2);\n\t\t\t\tneed[3][0]=calc(val[j],1);need[3][1]=calc(val[i],0);need[3][2]=calc(val[i],3);need[3][3]=calc(val[j],2);\n\t\t\t\trep(p,0,3) \n\t\t\t\t{\n\t\t\t\t\tnval[p]=0;\n\t\t\t\t\trep(q,0,3) nval[p]=nval[p]*bas+need[p][q];\n\t\t\t\t}\n\t\t\t\tll nans=1;int del=-1;\n\t\t\t\trep(p,0,3)\n\t\t\t\t{\n\t\t\t\t\tif (mp[nval[p]]) \n\t\t\t\t\t{\n\t\t\t\t\t\tnans*=mp[nval[p]];\n\t\t\t\t\t\tinsert(nval[p],-1);del=p;\n\t\t\t\t\t}\n\t\t\t\t\telse {nans=0;break;}\n\t\t\t\t}\n\t\t\t\trep(p,0,del) insert(nval[p],1);\n\t\t\t\t//cout << nans << endl;\n\t\t\t\tans+=nans;\n\t\t\t\tval[j]=val[j]/bas+(val[j]%bas)*lst3;\n\t\t\t}\n\t\t\tinsert(val[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nlint key(const V<>& v) {\n  lint res = 0;\n  for (int i = 0; i < 4; ++i) {\n    lint curr = 0;\n    for (int j = 0; j < 4; ++j) curr += static_cast<lint>(v[i + j & 3]) << 10 * j;\n    res = max(res, curr);\n  }\n  return res;\n}\n\nint coeff(lint key) {\n  V<> v(4);\n  for (int i = 0; i < 4; ++i) {\n    v[i] = key & 1023;\n    key >>= 10;\n  }\n  if (v[0] == v[2] and v[1] == v[3]) {\n    if (v[0] == v[1]) return 4;\n    return 2;\n  }\n  return 1;\n}\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> c; assign(c, n, 4, 0);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < 4; ++j) cin >> c[i][j];\n  gp_hash_table<lint, lint> mp;\n  for (int i = 0; i < n; ++i) ++mp[key(c[i])];\n  lint res = 0;\n  for (int d = 0; d < n; ++d) for (int u = d + 1; u < n; ++u) {\n    --mp[key(c[d])], --mp[key(c[u])];\n    for (int dir = 0; dir < 4; ++dir) {\n      V<lint> keys(4);\n      for (int i = 0; i < 4; ++i) keys[i] = key({c[u][dir - i & 3], c[u][dir - i - 1 & 3], c[d][i + 1 & 3], c[d][i]});\n      sort(begin(keys), end(keys));\n      int bit = 0;\n      for (int i = 0; i < 3; ++i) if (keys[i] == keys[i + 1]) bit |= 1 << i;\n      auto f = [&](const V<>& v) -> lint {\n        lint res = 1;\n        for (int i = 0; i < 4; ++i) res *= coeff(keys[i]) * (mp[keys[i]] - v[i]);\n        return res;\n      };\n      switch (bit) {\n        case 0b000: res += f({0, 0, 0, 0}); break;\n        case 0b001: res += f({0, 1, 0, 0}); break;\n        case 0b010: res += f({0, 0, 1, 0}); break;\n        case 0b011: res += f({0, 1, 2, 0}); break;\n        case 0b100: res += f({0, 0, 0, 1}); break;\n        case 0b101: res += f({0, 1, 0, 1}); break;\n        case 0b110: res += f({0, 0, 1, 2}); break;\n        case 0b111: res += f({0, 1, 2, 3}); break;\n      }\n    }\n    ++mp[key(c[d])], ++mp[key(c[u])];\n  }\n  cout << res / 3 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n \nint N;\n\nint myhash(vector<int>& a){\n    int h=0;\n    rep(i,0,a.size()) h^=a[i];\n    return h;\n}\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    random_shuffle(C.begin(),C.end());\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    //vector<i64> Csum(N),Cpro(N);\n    vector<int> Chash(N);\n    rep(i,0,N){\n        /*\n        Cpro[i]=1;\n        rep(j,0,4){\n            Csum[i]+=C[i][j];\n            Cpro[i]*=C[i][j];\n        }\n        */\n        Chash[i]=myhash(C[i]);\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n \n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n \n    auto normalize=[&](vector<vector<int>> &a){\n        rep(i,0,4){\n            auto amin=a[i];\n            rep(j,0,4){\n                amin=min(amin,a[i]);\n                a[i]=shift(a[i]);\n            }\n            a[i]=amin;\n        }\n        sort(a.begin(),a.begin());\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        map<vector<vector<int>>,i64> memo2;\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            //vector<i64> sum(4),pro(4);\n            vector<int> hash_(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_)) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto next_sides=make_sides(i,j);\n                normalize(next_sides);\n                \n                if(memo2.find(next_sides)!=memo2.end()){\n                    ans+=memo2[next_sides];\n                    continue;\n                }\n\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n                indexes.clear();\n                sides=next_sides;\n \n                rep(i_,0,4) hash_[i_]=myhash(sides[i_]);\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Chash[i_]==hash_[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n                memo2[sides]=rec(0,0);\n \n                C[j]=shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int, int> P;\n\nP rot(P p) {\n\tint a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn make_tuple(b, c, d, a);\n}\n\nlong long unpack(P p) {\n\tlong long a, b, c, d;\n\ttie(a, b, c, d) = p;\n\treturn a * 1000000000LL + b * 1000000LL + c * 1000LL + d;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n * 4), b(n * 4), c(n * 4), d(n * 4);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 4] >> b[i * 4] >> c[i * 4] >> d[i * 4];\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\ta[i * 4 + j] = d[i * 4 + j - 1];\n\t\t\tb[i * 4 + j] = a[i * 4 + j - 1];\n\t\t\tc[i * 4 + j] = b[i * 4 + j - 1];\n\t\t\td[i * 4 + j] = c[i * 4 + j - 1];\n\t\t}\n\t}\n\tn *= 4;\n\n\tmap<long long, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp[unpack(make_tuple(a[i], b[i], c[i], d[i]))]++;\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i += 4) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i / 4 == j / 4) continue;\n\t\t\tP x(a[i], b[i], c[i], d[i]);\n\t\t\tP y(a[j], b[j], c[j], d[j]);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[unpack(x)]--;\n\t\t\t\tmp[unpack(y)]--;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tP p[4];\n\t\t\tp[0] = P(d[j], c[j], b[i], a[i]);\n\t\t\tp[1] = P(b[i], c[j], b[j], c[i]);\n\t\t\tp[2] = P(d[j], a[i], d[i], a[j]);\n\t\t\tp[3] = P(d[i], c[i], b[j], a[j]);\n\n\t\t\tlong long cnt = 1;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tcnt *= mp[unpack(p[k])];\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[unpack(p[k])]--;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tmp[unpack(p[k])]++;\n\t\t\t\t\tp[k] = rot(p[k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmp[unpack(x)]++;\n\t\t\t\tmp[unpack(y)]++;\n\t\t\t\tx = rot(x);\n\t\t\t\ty = rot(y);\n\t\t\t}\n\n\t\t\tans += cnt;\n\t\t}\n\t}\n\tcout << ans / 6 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 400 + 100;\n\nint n;\nlong long s[MAXN];\nmap<long long, int> cnt;\n\nlong long get_ind(int x0, int x1, int x2, int x3)\n{\n\treturn (x0) | (x1 << 10) | (x2 << 20) | ((long long)x3 << 30);\n}\n\nint get_dig(long long s, int k)\n{\n\treturn (s >> (10 * k)) & 1023;\n}\n\nvoid add(long long s, int v)\n{\n\tfor(int i = 0; i < 4; i++)\n\t\tcnt[s] += v, s = (s >> 10) | ((s & 1023) << 30);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x0, x1, x2, x3;\n\t\tcin >> x0 >> x1 >> x2 >> x3;\n\t\ts[i] = get_ind(x0, x1, x2, x3);\n\t\tadd(s[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tadd(s[i], -1);\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tadd(s[j], -1);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tlong long t[4] = {\n\t\t\t\t\tget_ind(get_dig(s[j], k), get_dig(s[j], (k + 3) % 4), get_dig(s[i], 1), get_dig(s[i], 0)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 3) % 4), get_dig(s[j], (k + 2) % 4), get_dig(s[i], 2), get_dig(s[i], 1)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 2) % 4), get_dig(s[j], (k + 1) % 4), get_dig(s[i], 3), get_dig(s[i], 2)),\n\t\t\t\t\tget_ind(get_dig(s[j], (k + 1) % 4), get_dig(s[j], k), get_dig(s[i], 0), get_dig(s[i], 3))\n\t\t\t\t};\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\ttmp *= cnt[t[l]], add(t[l], -1);\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tadd(t[l], 1);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tadd(s[j], 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nunordered_map<LL,LL> colorCount;\n\nLL tolong(LL c0,LL c1,LL c2,LL c3){\n    return (c0*1000000000LL+ c1*1000000LL +c2*1000LL +c3);\n}\n\nvoid toc(LL num,LL &c0, LL &c1,LL &c2,LL &c3){\n    c0 = num/1000000000LL;\n    num %= 1000000000LL;\n    c1 = num/1000000LL;\n    num%= 1000000LL;\n    c2 = num/1000LL;\n    num%=1000LL;\n    c3 = num;\n}\n\nvoid add(LL c0,LL c1,LL c2,LL c3){\n    colorCount[tolong(c0,c1,c2,c3)]+=1;\n    colorCount[tolong(c3,c0,c1,c2)]+=1;\n    colorCount[tolong(c2,c3,c0,c1)]+=1;\n    colorCount[tolong(c1,c2,c3,c0)]+=1;\n}\n\nvoid sub(LL c0,LL c1,LL c2,LL c3){\n    colorCount[tolong(c0,c1,c2,c3)]-=1;\n    colorCount[tolong(c3,c0,c1,c2)]-=1;\n    colorCount[tolong(c2,c3,c0,c1)]-=1;\n    colorCount[tolong(c1,c2,c3,c0)]-=1;\n}\n\nint main(){\n\n    int N;cin>>N;\n    LL color[N];\n    REP(i,N){\n        LL c0,c1,c2,c3;\n        cin>>c0>>c1>>c2>>c3;\n        add(c0,c1,c2,c3);\n        color[i]=tolong(c0,c1,c2,c3);\n    }\n\n\n    LL col[4];\n    LL a,b,c,d,e,f,g,h;\n    LL ans = 0;\n    REP(i,N){\n        toc(color[i],col[0],col[1],col[2],col[3]);\n        sub(col[0],col[1],col[2],col[3]);\n        a = col[0],b=col[1],c=col[2],d=col[3];\n        REP(j,N){\n            if(i==j)continue;\n            toc(color[j],col[0],col[1],col[2],col[3]);\n            sub(col[0],col[1],col[2],col[3]);\n            REP(k,4){\n                LL T = 1;\n                e = col[(k)%4],h = col[(k+1)%4],g =col[(k+2)%4],f = col[(k+3)%4];\n                T *= colorCount[tolong(e,f,b,a)];\n                sub(e,f,b,a);\n                T *= colorCount[tolong(f,g,c,b)];\n                sub(f,g,c,b);\n                T*= colorCount[tolong(g,h,d,c)];\n                sub(g,h,d,c);\n                T *= colorCount[tolong(h,e,a,d)];\n                sub(h,e,a,d);\n\n                ans += T;\n                add(e,f,b,a);\n                add(f,g,c,b);\n                add(g,h,d,c);\n                add(h,e,a,d);\n            }\n            add(col[0],col[1],col[2],col[3]);\n        }\n        toc(color[i],col[0],col[1],col[2],col[3]);\n        add(col[0],col[1],col[2],col[3]);\n    }\n\n    cout<<ans/6<<endl;\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define N_MAX 400\n#define VOID_C 1234\n\nint v_ind[6][4]={\n{0,1,2,3},\n{4,5,1,0},\n{1,5,6,2},\n{3,2,6,7},\n{4,0,3,7},\n{5,4,7,6}};\n\nint n;\nint c[N_MAX][4];\n\nbool used_tile[N_MAX];\n\nlong long int cntCube(int faz, int *c_corner_in){\n        long long int ret=0;\n        for(int i=0; i<n; i++){\n                if(used_tile[i]) continue;\n                for(int k=0; k<((faz==0)?(1):(4)); k++){//初回は回転を考えない\n\n                        bool is_match=true;\n                        for(int j=0; j<4; j++){//カドの色が合ってるか\n                                if(c_corner_in[v_ind[faz][j]]!=VOID_C && c_corner_in[v_ind[faz][j]]!=c[i][(j+k)%4]){\n                                        is_match=false;\n                                        break;\n                                }\n                        }\n\n                        if(!is_match) continue;\n                        if(faz==5){\n                                ret++;\n                                continue;\n                        }\n\n                        used_tile[i]=true;\n                        int c_corner[8];\n                        for(int j=0; j<8; j++) c_corner[j]=c_corner_in[j];\n                        for(int j=0; j<4; j++) c_corner[v_ind[faz][j]]=c[i][(j+k)%4];\n                        ret+=cntCube(faz+1, c_corner);\n                        if(faz!=0) used_tile[i]=false;//初回に使ったタイルはもう使用しない\n                }\n        }\n        return ret;\n}\n\nint main(){\n        cin>>n;\n        for(int i=0; i<n; i++){\n                for(int j=0; j<4; j++){\n                        cin>>c[i][j];\n                }\n        }\n        for(int i=0; i<n; i++) used_tile[i]=false;\n\n        int c_corner[8];\n        for(int j=0; j<8; j++) c_corner[j]=VOID_C;\n        long long int ans=cntCube(0, c_corner);\n\n        cout<<ans;\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n#define MAXN 600\n\ntypedef array<int,4> tile;\n\nint n;\ntile a[MAXN];\n\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\treturn 1;\n}\n\nvoid init() {\n}\n\ntile rotate(const tile &x, int k=1) {\n\ttile y;\n\tfor (int i=0; i<4; i++) y[(i+k) % 4] = x[i];\n\treturn y;\n}\n\ntile normalize(const tile &x) {\n\ttile z=x;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y<z) z=y;\n\t}\n\treturn z;\n}\n\nint mirror(const tile &x) {\n\tint r = 1;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y==x) r++;\n\t}\n\treturn r;\n}\n\ntile get_face(tile &u, tile &d, int x, int y) {\n\treturn normalize({u[x], u[y], d[3-y], d[3-x]});\n}\n\nlong solve() {\n\tmap<tile,long> ct;\n\tmap<tile,long> mi;\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] = normalize(a[i]);\n\t\tct[a[i]]++;\n\t\tmi[a[i]] = mirror(a[i]);\n\t}\n\tlong ans = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tct[a[i]]--;\n\t\tfor (int j=i+1; j<n; j++) {\n\t\t\tct[a[j]]--;\n\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\ttile d=a[i], u=rotate(a[j], k);\n\t\t\t\ttile f[4];\n\t\t\t\tlong r = 1;\n\t\t\t\tfor (int t=0; t<4; t++) {\n\t\t\t\t\tf[t] = get_face(u, d, t, (t+3)%4);\n\t\t\t\t\tr *= mi[f[t]] * ct[f[t]]--;\n\t\t\t\t}\n\t\t\t\t//printf(\"* %d %d %d: %ld\\n\", i, j, k, r);\n\t\t\t\tans += r;\n\t\t\t\tfor (int t=0; t<4; t++) ct[f[t]]++;\n\t\t\t}\n\t\t\tct[a[j]]++;\n\t\t}\n\t\tct[a[i]]++;\n\t}\n\treturn ans/3;\n}\n\nvoid output(long ans) {\n\tprintf(\"%ld\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int mod=1e7+9;\nconst int MAX_H=1e5+5;\n\nstruct Hash\n{\n    int nex, w, s;\n    ll val;\n    Hash(int _n=0, int _w=0, int _s=0, ll _v=0):nex(_n), w(_w), s(_s), val(_v){}\n}h[MAX];\n\nint tot, N, t, C[MAX][5], head[MAX_H*10];\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    if(id)\n    {\n        h[id].w+=t;\n        return;\n    }\n    id=++tot, h[id].nex=head[fr], h[id].val=H, head[fr]=id, h[id].w=t;\n    h[id].s=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n}\n\ninline int Find(ll H)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    return h[id].w*h[id].s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,j,k,l,c[405][8],ans;\nmap<long long,long long> mp,mp2;\nvoid add(long long x,long long flag){\n\tlong long sum;\n\tfor(long long y=0;y<=3;y++){\n\t\tsum=0;\n\t\tfor(long long z=y;z<=y+3;z++)\n\t\t\tsum=sum*1007+c[x][z];\n\t\tmp2[sum]=x;\n\t\tmp[sum]+=flag;\n\t}\n}\nlong long make_hash(long long x,long long y,long long z,long long w){\n\tlong long sum=0;\n\tsum=sum*1007+x;\n\tsum=sum*1007+y;\n\tsum=sum*1007+z;\n\tsum=sum*1007+w;\n\treturn sum;\n}\nint main(){\n\t//freopen(\"camp.in\",\"r\",stdin);\n\t//freopen(\"camp.out\",\"w\",stdout);\n\tlong long x,p1,p2,p3,y,z,sum;\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<=3;j++){\n\t\t\tc[i][j]=read();\n\t\t\tc[i][j+4]=c[i][j];\n\t\t}\n\t\tadd(i,1);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tadd(i,-1);\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tadd(j,-1);\n\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\tx=c[i][7];p1=0;p2=0;p3=0;\n\t\t\t\tfor(l=7;l>=1;l--)\n\t\t\t\t\tc[i][l]=c[i][l-1];\n\t\t\t\tc[i][0]=x;\n\t\t\t\tsum=1;\n\t\t\t\t\n\t\t\t\tx=make_hash(c[i][1],c[i][0],c[j][1],c[j][0]);\n\t\t\t\tif(mp[x]!=0){\n\t\t\t\t\tsum=sum*mp[x];\n\t\t\t\t\tp1=mp2[x];\n\t\t\t\t\tadd(p1,-1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsum=0;\n\t\t\t\t\t\n\t\t\t\tx=make_hash(c[i][2],c[i][1],c[j][0],c[j][3]);\n\t\t\t\tif(mp[x]!=0){\n\t\t\t\t\tsum=sum*mp[x];\n\t\t\t\t\tp2=mp2[x];\n\t\t\t\t\tadd(p2,-1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsum=0;\n\t\t\t\t\n\t\t\t\tx=make_hash(c[i][3],c[i][2],c[j][3],c[j][2]);\n\t\t\t\tif(mp[x]!=0){\n\t\t\t\t\tsum=sum*mp[x];\n\t\t\t\t\tp3=mp2[x];\n\t\t\t\t\tadd(p3,-1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsum=0;\n\t\t\t\t\n\t\t\t\tx=make_hash(c[i][0],c[i][3],c[j][2],c[j][1]);\n\t\t\t\tif(mp[x]!=0)\n\t\t\t\t\tsum=sum*mp[x];\n\t\t\t\telse\n\t\t\t\t\tsum=0;\n\t\t\t\t\n\t\t\t\tans+=sum;\n\t\t\t\t\n\t\t\t\tif(p1!=0)\n\t\t\t\t\tadd(p1,1);\n\t\t\t\tif(p2!=0)\n\t\t\t\t\tadd(p2,1);\n\t\t\t\tif(p3!=0)\n\t\t\t\t\tadd(p3,1);\n\t\t\t}\n\t\t\tadd(j,1);\n\t\t}\n\t\tadd(i,1);\n\t}\n\tpus(ans/3,2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\ni64 comp(const vi &a) {\n    i64 res = 0;\n    forn(i, 4) res = 1000 * res + a[i];\n    return res;\n}\n\ni64 comp2(vi a) {\n    i64 ans = 1e18;\n    forn(i, 4) {\n        uin(ans, comp(a));\n        rotate(a.begin(), a.begin() + 1, a.end());\n    }\n    return ans;\n}\n\nint autom(const vi &a) {\n    if (a[0] == a[1] && a[1] == a[2] && a[2] == a[3]) return 4;\n    if (a[0] == a[2] && a[1] == a[3]) return 2;\n    return 1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n;\n    cin >> n;\n    vector<vvi> a(4, vvi(n, vi(4)));\n    forn(i, n) forn(j, 4) cin >> a[0][i][j];\n    forn(i, 3) forn(j, n) a[i + 1][j] = a[i][j], rotate(a[i + 1][j].begin(), a[i + 1][j].begin() + 1, a[i + 1][j].end());\n\n    vi64 ca(n);\n    forn(j, n) ca[j] = comp2(a[0][j]);\n\n    i64 ans = 0;\n    forn(i, n) forn(j, i) {\n        forn(d, 4) {\n            map<i64, int> cnt, aut;\n            forn(k, 4) {\n                vi v = {a[0][i][k], a[d][j][(4 - k) % 4], a[d][j][(3 - k) % 4], a[0][i][(k + 1) % 4]};\n                i64 z = comp2(v);\n                ++cnt[z]; aut[z] = autom(v);\n            }\n            vi64 have;\n            forn(k, i) {\n                if (k == j) continue;\n                have.pb(ca[k]);\n            }\n            sort(all(have));\n            i64 res = 1;\n            int l = 0;\n            while (l < have.size()) {\n                i64 x = have[l];\n                int r = l;\n                while (r < have.size() && have[r] == x) ++r;\n                if (cnt.count(x)) {\n                    int k = cnt[x], y = r - l, z = aut[x];\n                    forn(i, k) {\n                        res *= y - i;\n                        res *= z;\n                    }\n                    cnt.erase(x);\n                }\n                l = r;\n            }\n            if (!cnt.empty()) res = 0;\n            ans += res;\n        }\n//        if (!j) cerr << i << '\\n';\n    }\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<vector<short>,ll>mp;\n  ll access(const vector<short>&v){\n    ll ret=0;\n    ret+=mp[{v[0],v[1],v[2],v[3]}];\n    ret+=mp[{v[1],v[2],v[3],v[0]}];\n    ret+=mp[{v[2],v[3],v[0],v[1]}];\n    ret+=mp[{v[3],v[0],v[1],v[2]}];\n    //cout<<ret<<endl;\n    return max(0LL,ret);\n  }\n  void change(const vector<short>&v,ll w){\n    //if(!mp.count(v))return;\n    mp[v]+=w;\n  }\n  vector<ll>trans(const vector<short>&v){\n\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,short(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.mp[c[i]]++;\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<short>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<short>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n \nint N;\n\nint myhash(vector<int>& a){\n    int h=0;\n    rep(i,0,a.size()) h^=a[i];\n    return h;\n}\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    //vector<i64> Csum(N),Cpro(N);\n    vector<int> Chash(N);\n    rep(i,0,N){\n        /*\n        Cpro[i]=1;\n        rep(j,0,4){\n            Csum[i]+=C[i][j];\n            Cpro[i]*=C[i][j];\n        }\n        */\n        Chash[i]=myhash(C[i]);\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n \n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n \n    auto normalize=[&](vector<vector<int>> &a){\n        rep(i,0,4){\n            auto amin=a[i];\n            rep(j,0,4){\n                amin=min(amin,a[i]);\n                a[i]=shift(a[i]);\n            }\n            a[i]=amin;\n        }\n        sort(a.begin(),a.begin());\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            map<vector<vector<int>>,i64> memo2;\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            //vector<i64> sum(4),pro(4);\n            vector<int> hash_(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_)) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto next_sides=make_sides(i,j);\n                normalize(next_sides);\n                \n                if(memo2.find(next_sides)!=memo2.end()){\n                    ans+=memo2[next_sides];\n                    continue;\n                }\n\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n                indexes.clear();\n                sides=next_sides;\n \n                rep(i_,0,4) hash_[i_]=myhash(sides[i_]);\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Chash[i_]==hash_[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n                memo2[sides]=rec(0,0);\n \n                C[j]=shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Square = array<int, 4>;\n\nmap<Square, ll> memo;\n\nconst Square indices[] = {{1,0,1,0},{2,1,0,3},{3,2,3,2},{0,3,2,1}};\n\nvoid normalize(Square& s) {\n\tset<Square> tmp;\n\tfor (int i = 0; i < 4; i++) {\n\t\ttmp.insert(s);\n\t\trotate(s.begin(), s.begin() + 1, s.end());\n\t}\n\ts = *tmp.begin();\n}\n\nint pattern(Square& s) {\n\tif (s[0] == s[2] && s[1] == s[3]) {\n\t\tif (s[0] == s[1]) return 4;\n\t\telse return 2;\n\t}\n\treturn 1;\n}\n\nll solve(const Square& s1, const Square& s2) {\n\tll res = 1;\n\tint used = -1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tSquare tmp = {s1[indices[i][0]], s1[indices[i][1]], s2[indices[i][2]], s2[indices[i][3]]};\n\t\tnormalize(tmp);\n\t\tif (memo.find(tmp) == memo.end() || memo[tmp] == 0) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tres *= memo[tmp] * pattern(tmp);\n\t\tmemo[tmp]--;\n\t\tused++;\n\t}\n\n\tfor (int i = 0; i <= used; i++) {\n\t\tSquare tmp = {s1[indices[i][0]], s1[indices[i][1]], s2[indices[i][2]], s2[indices[i][3]]};\n\t\tnormalize(tmp);\n\t\tmemo[tmp]++;\t\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Square> c(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tnormalize(c[i]);\n\t\tmemo[c[i]]++;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcout << c[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tmemo[c[i]]--;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tmemo[c[j]]--;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tans += solve(c[i], c[j]);\n\t\t\t\trotate(c[j].begin(), c[j].begin() + 1, c[j].end());\n\t\t\t}\n\t\t\tmemo[c[j]]++;\n\t\t}\n\t\tmemo[c[i]]++;\t\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nstruct face{\n\tint a,b,c,d,orien;\n\tface(){}\n\tface(int aa, int bb, int cc, int dd){\n\t\ta=aa, b=bb, c=cc, d=dd;\n\t\torien = 1;\n\t\tif(a==c and b==d) orien = 2; \n\t\tif(a==b and b==c and c==d and d==a) orien = 4; // step 4e\n\t}\n\tvoid rotate(){\n\t\tint t=a;\n\t\ta=b,b=c,c=d,d=t;\n\t}\n\tbool operator<(face f) const{\n\t\treturn make_tuple(a,b,c,d) < make_tuple(f.a,f.b,f.c,f.d);\n\t}\n\tbool operator==(face f) const{\n\t\treturn make_tuple(a,b,c,d) == make_tuple(f.a,f.b,f.c,f.d);\n\t}\n\tface arrange(){\n\t\tface best = face(a,b,c,d);\n\t\tface cur = face(a,b,c,d);\n\t\tfor(int i=0; i<4; ++i){\n\t\t\tcur.rotate();\n\t\t\tif(cur < best) best = cur;\n\t\t}\n\t\treturn best;\n\t}\n\tvoid print(){\n//\t\tprintf(\"(%d %d %d %d)\\n\",a,b,c,d);\n\t}\n};\nint n;\nface A[500];\nmap<face, int> cnt;\nint32_t main(){\n\tcin >> n;\n\t/*\nidea:\n\t1. we pick two faces to be the opposite sides of the cube, because these 2 face choices (top and bottom of cube)will determine the entire cube.\n\t2. fix one face's rotation, rotate the other such to cover all 4 directions\n\t3. now, we just need to search among the list of faces for the other 4 cube faces. (we will call the 4 cube faces \"sides\" from now on)\n\t4. this may appear to be a simple task, but there are a few things we need to look out for:\n\t\t4a. firstly, for each side face, just count among the list of faces how many times it appears, then multiply\n\t\t\te.g. side A appears 3, side B appears 1, C appears 3, D appears 2. then the total number of cubes of \n\t\t\tthat \"colour (of the 8 corners)\" would be 3x1x3x2\n\t\t4b. we need an simple way to \"count among the list\"\n\t\t\te.g. if we just store the faces in an array, (1 0 0 0) would not be counted if we were looking for (0 0 0 1) even though\n\t\t\tthey are actually the same face\n\t\t\thence, for each face, we find the rotation of that face that is lexicographically the smallest (for (1 4 0 2) it would be (0 2 1 4))\n\t\t\twe then store a map<face, int> to count the number of times a face is in the list of faces\n\t\t4c. then another complication is, what if two side faces are identical. then if we simply multiply, it would be double using a single face\n\t\t\te.g. the 4 side faces are (0 0 0 1) (0 0 0 1) (0 0 1 1) (0 1 1 1) [might not make sense, for illustrative purpose]\n\t\t\tthen lets say (0 0 0 1) appears 3 times in the list of faces (with the faces being A,B,C)\n\t\t\tit would be double using the same face if we do 3x3 (AA,AB,AC,BA,BB,BC,CA,CB,CC)\n\t\t\twhat we actually want is 3x2 (AB,AC,BA,BC,CA,CB) (note AB and BA are different)\n\t\t\tSo, for the 4 side faces, we 'accumulate' them and count how many of each face we need\n\t\t\tin the example above, this would become (0 0 0 1)x2 (0 0 1 1)x1 (0 1 1 1)x1\n\t\t\tthen we can calculate more easily\n\t\t4d. another complication is, what if one or more of the side faces are equal to the 2 face choices we made?\n\t\t\thence, when counting the number of times a side face appears, we must subtract one or two if the top/bottom/both face matches the side face\n\t\t4e. lastly, each face may be invariant under \n\t\t\ti. a single rotation (hence all 4 rotations yield the same face)\n\t\t\tii. two rotations (hence 2 rotations yield the same face)\n\t\t\tso remember to multiply that when calculating the number of faces eligible to be the needed side face\n\t*/\n\tfor(int i=0; i<n; ++i){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\tA[i] = face(a,b,c,d).arrange(); // step 4b\n\t\tif(cnt.find(A[i]) == cnt.end()) cnt[A[i]]=1; // step 4b\n\t\telse cnt[A[i]]++;\n\t}\n\tfor(int i=0; i<n; ++i){\n\t\tA[i].print();\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<n; ++i){ \t\t// top face\n\t\tfor(int j=i+1; j<n; ++j){ \t// bottom face\n\t\t\tface t=A[i], b=A[j];\n\t\t\tfor(int k=0; k<4; ++k){ // 4 rotations of the bottom face\n\t\t\t\tface q = face(t.b,b.a,b.d,t.c).arrange(); \t// 4 side faces\n\t\t\t\tface w = face(t.a,b.b,b.a,t.b).arrange();\n\t\t\t\tface e = face(b.b,t.a,t.d,b.c).arrange();\n\t\t\t\tface r = face(t.c,b.d,b.c,t.d).arrange();\n\t\t\t\tvector<face> four;  \t\t\t\t// placed into a vector for easy manipulation\n\t\t\t\tfour.push_back(q);\n\t\t\t\tfour.push_back(w);\n\t\t\t\tfour.push_back(e);\n\t\t\t\tfour.push_back(r);\n\n\t\t\t\ttypedef pair<face,int> pf;\n\t\t\t\tvector<pf> v;\n\t\t\t\tfor(auto l : four){ \t\t\t\t// collecting it into pair<face, int> \n\t\t\t\t\t\t\t\t\t\t// step 4c\n\t\t\t\t\tbool newone = true;\n\t\t\t\t\tfor(auto it = v.begin(); it!=v.end(); ++it){\n\t\t\t\t\t\tif(it->first == l){ it->second++; newone = false; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif(newone) v.push_back(pf(l,1));\n\t\t\t\t}\n\t\t\t\tint add = 1;\n\t\t\t\tfor(auto m : v){\t\t\t\t// for each side face [m.first] needed (and the quantity [m.second])\n\t\t\t\t\tint c = cnt[m.first];\t\t\t\n\t\t\t\t\tif(m.first == t) c--;\t\t\t// if matches top, subtract one\n\t\t\t\t\tif(m.first == b.arrange()) c--; \t// if matches bottom, subtract one\n\t\t\t\t\t\t\t\t\t\t// step 4d\n//\t\t\t\t\tm.first.print(); printf(\"x%d, %d\\n\", c, m.second);\n\t\t\t\t\twhile(m.second--){ \t\t\t// c * (c-1) * (c-2) ...  [effectively c P m.second, where P is permute]\n\t\t\t\t\t\tadd *= c--; \n\t\t\t\t\t\tadd *= m.first.orien;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += add;\n//\t\t\t\tprintf(\" === %d %d: +%d\\n\", i, j, add);\n\t\t\t\tb.rotate();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans/3; // finally, each cube formed will be counted 3 times (by the 3 pairs of opposite faces), so ans will be 3 times larger than the correct value\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return calc(a[0],a[1],a[2],a[3])|(a[4]<<40)|(a[5]<<50);\n  };\n\n  vector<set<Int> > used(1<<20);\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused[(b[7]<<10)|b[6]].emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used[(a[7]<<10)|a[6]].count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n\n      if(0){\n\tres*=cnt[b[j]];      \n\tadd(b[j],-1);            \n      \n\tres*=cnt[w];\n\tadd(w,-1);\n\n\tres*=cnt[x];\n\tadd(x,-1);\n\n\tres*=cnt[y];\n\tadd(y,-1);\n\n\tres*=cnt[z];\n\tadd(z,-1);\n\n\tadd(d[i],1);\n\tadd(b[j],1);\n\tadd(w,1);\n\tadd(x,1);\n\tadd(y,1);\n\tadd(z,1);\n      }\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n/* -------------------------------- Template -------------------------------- */\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr int inf<int>() { return 1e9; }\ntemplate<> constexpr ll inf<ll>() { return 1e18; }\ntemplate<> constexpr ld inf<ld>() { return 1e30; }\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\n/* -------------------------------- Library -------------------------------- */\n\n/* ---------------------------------- Main ---------------------------------- */\n\nusing T = tuple<int,int,int,int>;\n\nT face[512];\n\nT min_tuple(T x) {\n  int c[4];\n  tie(c[0], c[1], c[2], c[3]) = x;\n  tuple<int,int,int,int> t1 = make_tuple(c[0], c[1], c[2], c[3]);\n  tuple<int,int,int,int> t2 = make_tuple(c[1], c[2], c[3], c[0]);\n  tuple<int,int,int,int> t3 = make_tuple(c[2], c[3], c[0], c[1]);\n  tuple<int,int,int,int> t4 = make_tuple(c[3], c[0], c[1], c[2]);\n  return min({ t1, t2, t3, t4 });\n}\n\nint cnt_tuple(T x) {\n  int c[4];\n  tie(c[0], c[1], c[2], c[3]) = x;\n  tuple<int,int,int,int> t1 = make_tuple(c[0], c[1], c[2], c[3]);\n  tuple<int,int,int,int> t2 = make_tuple(c[1], c[2], c[3], c[0]);\n  if (t1 == t2) return 4;\n  tuple<int,int,int,int> t3 = make_tuple(c[2], c[3], c[0], c[1]);\n  if (t1 == t3) return 2;\n  return 1;\n}\n\nll prod(ll x, ll y) {\n  ll res = 1;\n  REP(i,y) res *= x - i;\n  return res;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha;\n  cout.imbue(loc);\n\n  int N;\n  cin >> N;\n  map<T,int> cnt;\n  REP(i,N) {\n    int x1, x2, x3, x4;\n    cin >> x1 >> x2 >> x3 >> x4;\n    face[i] = min_tuple(T(x1, x2, x3, x4));\n    ++cnt[face[i]];\n  }\n  ll res = 0;\n  REP(i,N) REP(j,i) {\n    int x0, x1, x2, x3;\n    int x4, x5, x6, x7;\n    tie(x0, x1, x2, x3) = face[i];\n    tie(x4, x5, x6, x7) = face[j];\n    REP(k,4) {\n      tie(x0, x1, x2, x3) = make_tuple(x1, x2, x3, x0);\n      map<T,int> mapsto;\n      ++mapsto[min_tuple(T(x3, x2, x5, x4))];\n      ++mapsto[min_tuple(T(x2, x1, x6, x5))];\n      ++mapsto[min_tuple(T(x1, x0, x7, x6))];\n      ++mapsto[min_tuple(T(x0, x3, x4, x7))];\n      ll v = 1;\n      for (auto p: mapsto) {\n        int n = cnt.count(p.first) ? cnt[p.first] : 0;\n        if (p.first == face[i]) --n;\n        if (p.first == face[j]) --n;\n        REP(l,p.second) v *= n - l;\n        int c = cnt_tuple(p.first);\n        REP(l,p.second) v *= c;\n      }\n      res += v;\n    }\n  }\n  cout << res / 3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<int> standard(vector<int> x) {\n  for (int i = 0; i < 4; i++) x.push_back(x[i]);\n\n  vector<int> ret = {10000, 10000, 100000, 100000};\n  for (int j = 0; j < 4; j++) {\n    vector<int> color;\n    for (int k = 0; k < 4; k++) color.push_back(x[j + k]);\n    if (ret > color) ret = color;\n  }\n  return ret;\n}\nLL encode(const vector<int> x) {\n  LL val = 0;\n  for (int i = 0; i < 4; i++) {\n    val *= 1000;\n    val += x[i];\n  }\n  return val;\n}\n\nvoid dump(vector<int> x) {\n  for (auto val : x) cout << val << \" \";\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  // map<vector<int>, int> colors;\n  // map<vector<int>, int> muls;\n  map<LL, int> colors;\n  map<LL, int> muls;\n  set<vector<int>> keys;\n  for (int i = 0; i < N; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    vector<int> base_color = {a, d, c, b, a, d, c, b};\n    vector<vector<int>> tmp_color;\n    for (int j = 0; j < 4; j++) {\n      vector<int> color;\n      for (int k = 0; k < 4; k++) color.push_back(base_color[j + k]);\n      tmp_color.push_back(color);\n    }\n    vector<int> color = standard(tmp_color[0]);\n    colors[encode(color)]++;\n    int mul = 0;\n    for (int j = 0; j < 4; j++)\n      if (tmp_color[0] == tmp_color[j]) mul++;\n    muls[encode(color)] = mul;\n    keys.insert(color);\n  }\n\n  LL ans = 0;\n  /*\n  for (auto key : colors) {\n    keys.push_back(key.first);\n  }*/\n\n  for (auto low : keys) {\n    for (auto up : keys) {\n      for (int z = 0; z < 4; z++) {\n        LL low_key = encode(low);\n        LL up_key = encode(up);\n        LL ret = 1;\n        ret *= colors[low_key];\n        colors[low_key]--;\n        ret *= colors[up_key];\n        colors[up_key]--;\n\n        vector<LL> hozon;\n        for (int i = 0; i < 4; i++) {\n          vector<int> cur;\n          cur = {low[(7 - i) % 4], low[(6 - i) % 4], up[(1 + i + z) % 4],\n                 up[(i + z) % 4]};\n          cur = standard(cur);\n          LL key = encode(cur);\n          ret *= colors[key] * muls[key];\n\n          colors[key]--;\n          hozon.push_back(key);\n        }\n        for (auto key : hozon) {\n          colors[key]++;\n        }\n\n        ans += ret;\n        colors[low_key]++;\n        colors[up_key]++;\n      }\n    }\n\n    // colors[low] = 0;\n  }\n  cout << ans / 6 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\ntypedef long long s64;\n\nstruct object\n{\n\tint a, b, c, d;\n\tobject() {}\n\tobject(const int &_a, const int &_b, const int &_c, const int &_d)\n\t\t: a(_a), b(_b), c(_c), d(_d) {}\n\n\tinline object rotate() const\n\t{\n\t\treturn {b, c, d, a};\n\t}\n\n\tfriend inline bool operator<(const object &lhs, const object &rhs)\n\t{\n\t\tif (lhs.a != rhs.a)\n\t\t\treturn lhs.a < rhs.a;\n\t\tif (lhs.b != rhs.b)\n\t\t\treturn lhs.b < rhs.b;\n\t\tif (lhs.c != rhs.c)\n\t\t\treturn lhs.c < rhs.c;\n\t\treturn lhs.d < rhs.d;\n\t}\n};\nmap<object, int> all;\n\ninline void add(object cur, int delta)\n{\n\tfor (int k = 0; k < 4; ++k)\n\t\tall[cur = cur.rotate()] += delta;\n}\n\nconst int MaxN = 400;\n\nint n;\nobject f[MaxN + 1];\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> f[i].a >> f[i].b;\n\t\tcin >> f[i].c >> f[i].d;\n\t\tadd(f[i], 1);\n\t}\n\n\ts64 res = 0;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tadd(f[i], -1);\n\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tadd(f[j], -1);\n\n\t\t\tobject cur = f[j];\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t{\n\t\t\t\tobject f1(cur.b, cur.a, f[i].b, f[i].a);\n\t\t\t\tobject f2(cur.a, cur.d, f[i].c, f[i].b);\n\t\t\t\tobject f3(cur.d, cur.c, f[i].d, f[i].c);\n\t\t\t\tobject f4(cur.c, cur.b, f[i].a, f[i].d);\n\n\t\t\t\ts64 ways = 1;\n\t\t\t\tways *= all[f1], add(f1, -1);\n\t\t\t\tways *= all[f2], add(f2, -1);\n\t\t\t\tways *= all[f3], add(f3, -1);\n\t\t\t\tways *= all[f4];\n\n\t\t\t\tadd(f1, 1), add(f2, 1), add(f3, 1);\n\n\t\t\t\tres += ways;\n\n\t\t\t\tcur = cur.rotate();\n\t\t\t}\n\n\t\t\tadd(f[j], 1);\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n \nint N;\n\nint myhash(vector<int>& a){\n    int h=0;\n    rep(i,0,a.size()) h^=a[i];\n    return h;\n}\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    random_shuffle(C.begin(),C.end());\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    //vector<i64> Csum(N),Cpro(N);\n    vector<int> Chash(N);\n    rep(i,0,N){\n        /*\n        Cpro[i]=1;\n        rep(j,0,4){\n            Csum[i]+=C[i][j];\n            Cpro[i]*=C[i][j];\n        }\n        */\n        Chash[i]=myhash(C[i]);\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n \n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n \n    auto normalize=[&](vector<vector<int>> &a){\n        rep(i,0,4){\n            auto amin=a[i];\n            rep(j,0,4){\n                amin=min(amin,a[i]);\n                a[i]=shift(a[i]);\n            }\n            a[i]=amin;\n        }\n        sort(a.begin(),a.begin());\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            //vector<i64> sum(4),pro(4);\n            vector<int> hash_(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_)) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto next_sides=make_sides(i,j);\n                normalize(next_sides);\n                if(next_sides!=sides){\n                    for(auto& u:update) memo[u.first][u.second]=-1;\n                    update.clear();\n                    indexes.clear();\n                    sides=next_sides;\n                    /*\n                    rep(i_,0,4){\n                        sum[i_]=0;\n                        pro[i_]=1;\n                        rep(j_,0,4){\n                            sum[i_]+=sides[i_][j_];\n                            pro[i_]*=sides[i_][j_];\n                        }\n                    }\n                    */\n                    rep(i_,0,4) hash_[i_]=myhash(sides[i_]);\n                }\n \n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Chash[i_]==hash_[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n \n                C[j]=shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\nconst int N=450;\nVI a[N];\ntypedef long long ll;\nll ans;\nmap<VI,int>mp;\n#define nxt(x) x.push_back(x[0]),x.erase(x.begin())\nvoid add(VI x,int y){for(int i=0;i<4;++i,nxt(x))mp[x]+=y;}\nint n;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<4;++j){\n\t\t\tint x;cin>>x;\n\t\t\ta[i].push_back(x);\n\t\t}\n\t\tadd(a[i],1);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tadd(a[i],-1);\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tadd(a[j],-1);\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tVI x={a[i][3],a[j][2],a[j][1],a[i][0]},y={a[j][3],a[i][2],a[i][1],a[j][0]},\n\t\t\t\t   z={a[i][0],a[j][1],a[j][0],a[i][1]},w={a[j][2],a[i][3],a[i][2],a[j][3]};\n\t\t\t\tll res=1;nxt(a[j]);\n\t\t\t\tres*=mp[x];add(x,-1);\n\t\t\t\tres*=mp[y];add(y,-1);\n\t\t\t\tres*=mp[z];add(z,-1);\n\t\t\t\tres*=mp[w];add(x,1);add(y,1);add(z,1);\n\t\t\t\tans+=res;\n\t\t\t}\n\t\t\tadd(a[j],1);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nint n;\nll t1000[4];\nvoid init() {\n\tt1000[0] = 1;\n\trep(i, 3) {\n\t\tt1000[i + 1] = t1000[i] * 1000;\n\t}\n}\nll calc(ll a, ll b, ll c, ll d) {\n\tll res = INF;\n\tvector<ll> v = { a,b,c,d };\n\trep(j, 4) {\n\t\tll sum = 0;\n\t\trep(k, 4) {\n\t\t\tsum += v[k] * t1000[k];\n\t\t}\n\t\tres = min(res, sum);\n\t\tv.push_back(v[0]);\n\t\tv.erase(v.begin());\n\t}\n\treturn res;\n}\nll c[400];\nll turn(ll x) {\n\tvector<ll> v;\n\tper(j, 4) {\n\t\tv.push_back(x / t1000[j]);\n\t\tx %= t1000[j];\n\t}\n\treverse(v.begin(), v.end());\n\tv.push_back(v[0]); v.erase(v.begin());\n\tll res = 0;\n\trep(j, 4) {\n\t\tres += v[j] * t1000[j];\n\t}\n\treturn res;\n}\nvector<ll> query(ll k) {\n\tvector<ll> res;\n\tper(j, 4) {\n\t\tres.push_back(k / t1000[j]);\n\t\tk %= t1000[j];\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nmap<ll, int> mp,num;\nint main() {\n\tinit();\n\tcin >> n;\n\trep(i, n) {\n\t\tll x, y, z, w; cin >> x >> y >> z >> w;\n\t\tc[i] = calc(x, y, z, w);\n\t\tmp[c[i]]++;\n\t\tll t = c[i];\n\t\tint cnt = 0;\n\t\trep(j, 4) {\n\t\t\tt = turn(t);\n\t\t\tif (t == c[i])cnt++;\n\t\t}\n\t\tnum[c[i]] = cnt;\n\t\t//cout << c[i] << endl;\n\t}\n\tll ans = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == j)continue;\n\t\t\trep(k, n) {\n\t\t\t\tif (i == k || j == k)continue;\n\t\t\t\tvector<ll> a1 = query(c[i]);\n\t\t\t\tll t1 = c[j], t2 = c[k];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tt1 = turn(t1);\n\t\t\t\t\tvector<ll> a2 = query(t1);\n\t\t\t\t\tif (a1[0] != a2[1] || a1[3] != a2[2])continue;\n\t\t\t\t\trep(m, 4) {\n\t\t\t\t\t\tt2 = turn(t2);\n\t\t\t\t\t\tvector<ll> a3 = query(t2);\n\t\t\t\t\t\tif (a1[1] != a3[0] || a1[2] != a3[3])continue;\n\t\t\t\t\t\t//cout << t1 << \" \" << t2 << endl;\n\t\t\t\t\t\tll z[3];\n\t\t\t\t\t\tz[0] = calc(a3[1], a2[0], a2[3], a3[2]);\n\t\t\t\t\t\tz[1] = calc(a2[2], a3[3], a3[2], a2[3]);\n\t\t\t\t\t\tz[2] = calc(a2[0], a3[1], a3[0], a2[1]);\n\t\t\t\t\t\tll c1 = mp[z[0]];\n\t\t\t\t\t\t//cout << z[0] << endl;\n\t\t\t\t\t\t//cout << c1 << endl;\n\t\t\t\t\t\tif (z[0] == c[i])c1--;\n\t\t\t\t\t\tif (z[0] == c[j])c1--;\n\t\t\t\t\t\tif (z[0] == c[k])c1--;\n\t\t\t\t\t\tll c2 = mp[z[1]];\n\t\t\t\t\t\t//cout << c2 << endl;\n\t\t\t\t\t\tif (z[1] == c[i])c2--;\n\t\t\t\t\t\tif (z[1] == c[j])c2--;\n\t\t\t\t\t\tif (z[1] == c[k])c2--;\n\t\t\t\t\t\tif (z[0] == z[1])c2--;\n\t\t\t\t\t\tll c3 = mp[z[2]];\n\t\t\t\t\t\t//cout << c3 << endl;\n\t\t\t\t\t\tif (z[2] == c[i])c3--;\n\t\t\t\t\t\tif (z[2] == c[j])c3--;\n\t\t\t\t\t\tif (z[2] == c[k])c3--;\n\t\t\t\t\t\tif (z[0] == z[2])c3--;\n\t\t\t\t\t\tif (z[1] == z[2])c3--;\n\t\t\t\t\t\tc1 *= num[z[0]];\n\t\t\t\t\t\tc2 *= num[z[1]];\n\t\t\t\t\t\tc3 *= num[z[2]];\n\t\t\t\t\t\t//cout << c1 << \" \" << c2 << \" \" << c3 << endl;\n\t\t\t\t\t\tans += c1 * c2*c3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << ans << endl;\n\tcout << ans / 6 << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int mo=1e7+9;\nint head[mo],nxt[N],w[N],v[N],tot;LL to[N];\nint c[N][4];\ninline void ins(LL s,int t) {\n\tint h=s%mo;\n\tfor (int i=head[h];i;i=nxt[i])\n\t\tif (to[i]==s) { w[i]+=t; return; }\n\tto[++tot]=s,nxt[tot]=head[h],head[h]=tot,w[tot]=t;\n\tv[tot]=s%1000000==s/1000000?(s%1000==s/1000000000?4:2):1;\n}\ninline int find(LL s) {\n\tfor (int i=head[s%mo];i;i=nxt[i])\n\t\tif (to[i]==s) return w[i]*v[i];\n\treturn 0;\n}\ninline LL get(int k,int t) { LL s=0; for (int i=0;i<4;i++) s=s*1000+c[k][(t+i)&3]; return s; }\ninline void Add(LL s,int t) {\n\tLL p[4];\n\tfor (int i=0;i<4;i++) p[i]=s,s=s/1000+s%1000*1000000000;\n\tsort(p,p+4);\n\tfor (int i=0;i<4;i++) if (!i||p[i]!=p[i-1]) ins(p[i],t);\n}\ninline void add(int k,int t) { Add(get(k,0),t); }\nint main()\n{\n\tint n=gi(),i,j,k,t;LL s,ans=0,pi;\n\tfor (i=0;i<n;add(i++,1))\n\t\tfor (j=0;j<4;j++)\n\t\t\tc[i][j]=gi();\n\tfor (i=0;i<n;i++) {\n\t\tadd(i,-1);\n\t\tfor (j=i+1;j<n;j++) {\n\t\t\tadd(j,-1);\n\t\t\treverse(c[j],c[j]+4);\n\t\t\tfor (k=0;k<4;k++) {\n\t\t\t\tpi=1;\n\t\t\t\tfor (t=0;t<4;t++) {\n\t\t\t\t\ts=((c[j][(k+t)&3]*1000LL+c[j][(k+t+1)&3])*1000+c[i][(t+1)&3])*1000+c[i][t];\n\t\t\t\t\tpi*=find(s);\n\t\t\t\t\tAdd(s,-1);\n\t\t\t\t}\n\t\t\t\tfor (t=0;t<4;t++) {\n\t\t\t\t\ts=((c[j][(k+t)&3]*1000LL+c[j][(k+t+1)&3])*1000+c[i][(t+1)&3])*1000+c[i][t];\n\t\t\t\t\tAdd(s,1);\n\t\t\t\t}\n\t\t\t\tans+=pi;\n\t\t\t}\n\t\t\treverse(c[j],c[j]+4);\n\t\t\tadd(j,1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nvi rotate_square(vi a) {\n  a.push_back(a[0]);\n  a.erase(a.begin());\n  return a;\n}\n\nvi normalize_square(vi a) {\n  vi temp = a;\n  rep (i, 3) {\n    a = rotate_square(a);\n    temp = min(temp, a);\n  }\n  return temp;\n}\n\n\nclass Box {\npublic:\n  vi color;\n  \n  Box(){\n    color.resize(8);\n  }\n  void set_up(vi a) {\n    rep (i, 4) color[i] = a[i];\n  }\n  void set_down(vi a) {\n    rep (i, 4) color[i + 4] = a[3 - i];\n  }\n\n  vii get_side() {\n    vii res(4, vi(4));\n    rep (i, 4) {\n      res[i][0] = i;\n      res[i][1] = (i + 3) % 4;\n      res[i][2] = res[i][1] + 4;\n      res[i][3] = res[i][2] + 1;\n      if (res[i][3] == 8) res[i][3] = 4;\n      rep (j, 4) {\n        res[i][j] = color[res[i][j]];\n      }\n    }\n    return res;\n  }\n  \n};\n\nint square_num(vi a) {\n  vi initial = a;\n  int ans = 0;\n  rep (i, 4) {\n    if (initial == a) ans++;\n    a = rotate_square(a);\n  }\n  return ans;\n}\n\nll solve(Box &box, vii& c) {\n  if (c.size() < 4) return 0;\n  vii sides = box.get_side();\n  map<vi, int> mp;\n  rep (i, 4) {\n    sides[i] = normalize_square(sides[i]);\n    mp[sides[i]] = 0;\n  }\n\n  for (auto itr = mp.begin(); itr != mp.end(); itr++) {\n    vi temp = itr->first;\n    mp[temp] = upper_bound(all(c), temp) - lower_bound(all(c), temp);\n  }\n  /*\n  rep (i, c.size()) {\n    if (mp.count(c[i])) {\n      mp[c[i]]++;\n    }\n    }\n//*/\n\n  ll ans = 1;\n  rep (i, 4) {\n    ll n = mp[sides[i]];\n    ans = ans * n * square_num(sides[i]);\n    mp[sides[i]]--;\n  }\n  return ans;\n}\n\nsigned main() {\n  fio();\n  int n;\n  cin >> n;\n\n  vii c(n, vi(4));\n  rep (i, n) {\n    rep (j, 4) {\n      cin >> c[i][j];\n    }\n    c[i] = normalize_square(c[i]);\n  }\n\n  sort(all(c));\n\n  Box box;\n  ll ans = 0;\n  rep (i, n) {\n    box.set_up(c[i]);\n    for (int j = i + 1; j < n; j++) {\n      vi ccc = c[j];\n      vii temp;\n      for (int k = i + 1; k < n; k++) {\n        if (j == k) continue;\n        temp.push_back(c[k]);\n      }\n      rep (_, 4) {\n        box.set_down(ccc);\n        ll add = solve(box, temp);\n        ans += add;\n        ccc = rotate_square(ccc);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<map>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=410;\nstruct State {\n\tint a,b,c,d;\n\tbool operator < (const State& S) const {\n\t\tif(a!=S.a) return a<S.a;\n\t\tif(b!=S.b) return b<S.b;\n\t\tif(c!=S.c) return c<S.c;\n\t\treturn d<S.d;\n\t}\n\tbool operator == (const State& S) {\n\t\treturn a==S.a&&b==S.b&&c==S.c&&d==S.d;\n\t}\n}A[maxn][4];\nmap<ll,int> M;\n#define hash(a,b,c,d) (a*201525010ll+b*252501ll+c*2501+d)\nvoid del(State x) {\n\tM[hash(x.a,x.b,x.c,x.d)]--;\n\tM[hash(x.b,x.c,x.d,x.a)]--;\n\tM[hash(x.c,x.d,x.a,x.b)]--;\n\tM[hash(x.d,x.a,x.b,x.c)]--;\n}\nvoid add(State x) {\n\tM[hash(x.a,x.b,x.c,x.d)]++;\n\tM[hash(x.b,x.c,x.d,x.a)]++;\n\tM[hash(x.c,x.d,x.a,x.b)]++;\n\tM[hash(x.d,x.a,x.b,x.c)]++;\n}\nint main() {\n\tint n=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tA[i][0]=(State){a,b,c,d};\n\t\tA[i][1]=(State){b,c,d,a};\n\t\tA[i][2]=(State){c,d,a,b};\n\t\tA[i][3]=(State){d,a,b,c};\n\t\tM[hash(a,b,c,d)]++;M[hash(b,c,d,a)]++;M[hash(c,d,a,b)]++;M[hash(d,a,b,c)]++;\n\t}\n\tll ans=0;\n\trep(i,1,n) rep(j,i+1,n) if(i!=j) {\n\t\tdel(A[i][0]);del(A[j][0]);\n\t\trep(y,0,3) {\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t\tState S[4];\n\t\t\tS[0]=(State){A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b};\n\t\t\tS[1]=(State){A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b};\n\t\t\tS[2]=(State){A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d};\n\t\t\tS[3]=(State){A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d};\n\t\t\tint c1=M[hash(A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b)];del(S[0]);\n\t\t\tint c2=M[hash(A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b)];del(S[1]);\n\t\t\tint c3=M[hash(A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d)];del(S[2]);\n\t\t\tint c4=M[hash(A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d)];del(S[3]);\n\t\t\tans+=(ll)c1*c2*c3*c4;\n\t\t\trep(k,0,3) add(S[k]);\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t}\n\t\tadd(A[i][0]);add(A[j][0]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int Nmax = 400;\nint N, C[4][Nmax];\n\nlong encode(int c0,int c1,int c2,int c3){\n\tlong base=1000;\n\tlong x = c3+base*c2+base*base*c1+base*base*base*c0;\n\tlong m = x;\n\tfor(int i=0; i<3; i++){\n\t\tx = x/base+(x%base)*base*base*base;\n\t\tm = min(m, x);\n\t}\n\treturn m;\n}\n\nint rot(long code){\n\tint c[4];\n\tint base = 1000;\n\tfor(int i=0; i<4; i++) {\n\t\tc[i] = code%base;\n\t\tcode /= base;\n\t}\n\tif(c[0]==c[1]&&c[1]==c[2]&&c[2]==c[3]) return 4;\n\tif(c[0]==c[2]&&c[1]==c[3]) return 2;\n\treturn 1;\n}\n\nlong pow(long a,long n){\n\tif(n==0) return 1;\n\tif(n%2) return pow(a,n-1)*a;\n\treturn pow(a,n/2);\n}\n\nint main(){\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=0; j<4; j++){\n\t\t\tcin >> C[j][i];\n\t\t}\n\t}\n\n\tmap<long, vector<int> > e2f;\n\tfor(int i=0; i<N; i++){\n\t\tlong x = encode(C[0][i],C[1][i],C[2][i],C[3][i]);\n\t\te2f[x].push_back(i);\n\t}\n\n\tlong ans = 0;\n\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tlong f[4];\n\t\t\t\tf[0] = encode(C[1][i],C[0][i],C[(k+0)%4][j],C[(k+3)%4][j]);\n\t\t\t\tf[1] = encode(C[2][i],C[1][i],C[(k+3)%4][j],C[(k+2)%4][j]);\n\t\t\t\tf[2] = encode(C[3][i],C[2][i],C[(k+2)%4][j],C[(k+1)%4][j]);\n\t\t\t\tf[3] = encode(C[0][i],C[3][i],C[(k+1)%4][j],C[(k+0)%4][j]);\n\t\t\t\tif(e2f.find(f[0]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[1]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[2]) == e2f.end() ||\n\t\t\t\t\te2f.find(f[3]) == e2f.end()) continue;\n\t\t\t\t/*\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\tcout << f[0] << endl;\n\t\t\t\tcout << f[1] << endl;\n\t\t\t\tcout << f[2] << endl;\n\t\t\t\tcout << f[3] << endl;\n\t\t\t\t*/\n\t\t\t\tlong c[4];\n\t\t\t\tlong a=0;\n\t\t\t\tfor(int m=0; m<4; m++){\n\t\t\t\t\tc[m]=0;\n\t\t\t\t\tfor(auto l=e2f[f[m]].begin(); l!=e2f[f[m]].end(); l++){\n\t\t\t\t\t\t//cout << \" \" << *l << endl;\n\t\t\t\t\t\tif(*l<=i || *l==j) continue;\n\t\t\t\t\t\tc[m]++;\n\t\t\t\t\t}\n\t\t\t\t\t//cout << c[m] << \" \";\n\t\t\t\t}\n\t\t\t\tif(f[0]==f[1]&&f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=4){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*(c[0]-3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]&&f[1]==f[2]){\n\t\t\t\t\tif(c[0]>=3){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=3){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[0]>=3){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*(c[0]-2)*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]&&f[2]==f[3]){\n\t\t\t\t\tif(c[1]>=3){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*(c[1]-2)*c[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]&&f[1]==f[3]){\n\t\t\t\t\tif(c[0]>=2&&c[1]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*(c[1]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[2]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[3]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[1]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[2]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[1]==f[2]){\n\t\t\t\t\tif(c[1]>=2){\n\t\t\t\t\t\ta = c[1]*(c[1]-1)*c[0]*c[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[2]==f[3]){\n\t\t\t\t\tif(c[2]>=2){\n\t\t\t\t\t\ta = c[2]*(c[2]-1)*c[0]*c[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(f[0]==f[3]){\n\t\t\t\t\tif(c[0]>=2){\n\t\t\t\t\t\ta = c[0]*(c[0]-1)*c[1]*c[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta = c[0]*c[1]*c[2]*c[3];\n\t\t\t\t}\n\t\t\t\tfor(int m=0; m<4; m++) a*=rot(f[m]);\n\t\t\t\t//cout << a << endl;\n\t\t\t\tans += a;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(k!=i and k!=j){\n                    rep(i_,0,4){\n                        if(b&(1<<i_)) continue;\n                        rep(j_,0,4) if(match(rotatedC[k][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                rep(i_,0,N+1) fill(memo[i_].begin(),memo[i_].end(),-1);\n                ans+=rec(i+1,0);\n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<iostream>\n#include<map>\n#define ll long long\nusing namespace std;\nint n;\nll ans;\nstruct Node\n{\n    int a[4];\n    Node(){}\n    Node(int x,int y,int z,int w)\n    {\n        a[0]=x,a[1]=y,a[2]=z,a[3]=w;\n    }\n    bool operator < (const Node &ags) const\n    {\n        if(a[0]!=ags.a[0])\n            return a[0]<ags.a[0];\n        if(a[1]!=ags.a[1])\n            return a[1]<ags.a[1];\n        if(a[2]!=ags.a[2])\n            return a[2]<ags.a[2];\n        return a[3]<ags.a[3];\n    }\n    bool operator == (const Node &ags) const\n    {\n        for(int i=0;i<4;i++)\n            if(a[i]!=ags.a[i])\n                return false;\n        return true;\n    }\n}t[100010];\nmap<Node,ll >mp;\nvoid AddNode(int s1,int s2,int s3,int s4)\n{\n    mp[Node(s1,s2,s3,s4)]++;\n}\nll judge(Node x,Node y)\n{\n    ll res=0;\n    if(x==y) //1\n        res++;\n\n    int temp=y.a[0];\n    for(int i=0;i<3;i++)\n        y.a[i]=y.a[i+1];\n    y.a[3]=temp;\n    if(x==y) //2\n        res++;\n\n    temp=y.a[0];\n    for(int i=0;i<3;i++)\n        y.a[i]=y.a[i+1];\n    y.a[3]=temp;\n    if(x==y) //3\n        res++;\n\n    temp=y.a[0];\n    for(int i=0;i<3;i++)\n        y.a[i]=y.a[i+1];\n    y.a[3]=temp;\n    if(x==y) //4\n        res++;\n    return res;\n}\nvoid jisuan(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8)\n{\n    Node x1=Node(b1,b2,b6,b5);\n    Node x2=Node(b2,b3,b7,b6);\n    Node x3=Node(b3,b4,b8,b7);\n    Node x4=Node(b4,b1,b5,b8);\n    Node sp1=Node(b4,b3,b2,b1);\n    Node sp2=Node(b5,b6,b7,b8);\n    ll res1=mp[x1];\n    ll res2=mp[x2];\n    ll res3=mp[x3];\n    ll res4=mp[x4];\n\n    res1=res1-judge(sp1,x1)-judge(sp2,x1);\n    res2=res2-judge(sp1,x2)-judge(sp2,x2)-judge(x1,x2);\n    res3=res3-judge(sp1,x3)-judge(sp2,x3)-judge(x1,x3)-judge(x2,x3);\n    res4=res4-judge(sp1,x4)-judge(sp2,x4)-judge(x1,x4)-judge(x2,x4)-judge(x3,x4);\n\n    ans+=res1*res2*res3*res4;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=0;j<4;j++)\n            scanf(\"%d\",&t[i].a[j]);\n\n        AddNode(t[i].a[3],t[i].a[2],t[i].a[1],t[i].a[0]);\n        AddNode(t[i].a[2],t[i].a[1],t[i].a[0],t[i].a[3]);\n        AddNode(t[i].a[1],t[i].a[0],t[i].a[3],t[i].a[2]);\n        AddNode(t[i].a[0],t[i].a[3],t[i].a[2],t[i].a[1]);\n    }\n    ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n        {\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3],t[j].a[0],t[j].a[3],t[j].a[2],t[j].a[1]);\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3],t[j].a[1],t[j].a[0],t[j].a[3],t[j].a[2]);\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3],t[j].a[2],t[j].a[1],t[j].a[0],t[j].a[4]);\n            jisuan(t[i].a[0],t[i].a[1],t[i].a[2],t[i].a[3],t[j].a[3],t[j].a[2],t[j].a[1],t[j].a[0]);\n        }\n    printf(\"%lld\",ans/3ll);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> cyc(V<int> &a) {\n\tVV<int> cand;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(a[(j+k)%4]);\n\t\t}\n\t\tcand.pb(vec);\n\t}\n\treturn *min_element(ALL(cand));\n}\n\nint com(V<int>& v) {\n\tint cnt = 0;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(v[(j+k)%4]);\n\t\t}\n\t\tif (vec == v) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> vf;\n\n\tmap<V<int>, int> T, coef;\n\n\trep(i, N) {\n\t\tV<int> a(4);\n\t\trep(j, 4) cin >> a[j];\n\n\t\tauto vec = cyc(a);\n\t\tvf.pb(vec);\n\t\t++T[vec];\n\t\tdump(vec);\n\t\tcoef[vec] = com(vec);\n\t}\n\n\tll ans = 0;\n\n\trep(i, N) {\n\t\trep(j, i) {\n\t\t\t--T[vf[i]];\n\t\t\t--T[vf[j]];\n\n\t\t\trep(k, 4) {\n\t\t\t\tint up[4], dw[4];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tup[l] = vf[i][l];\n\t\t\t\t\tdw[l] = vf[j][(k-l+4)%4];\n\t\t\t\t}\n\n\t\t\t\tll t = 1;\n\n\t\t\t\tVV<int> use;\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tV<int> vec{up[l],up[(l+3)%4],dw[(l+3)%4],dw[l]};\n\t\t\t\t\tvec = cyc(vec);\n\t\t\t\t\tuse.pb(vec);\n\t\t\t\t\tt *= T[vec] * coef[vec];\n\t\t\t\t\tif (--T[vec] < 0) break;\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\tfor (auto &v : use) {\n\t\t\t\t\t++T[v];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++T[vf[i]];\n\t\t\t++T[vf[j]];\t\t\t\n\t\t}\n\t}\n\tdump(ans);\n\n\tcout << ans / 3 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct squ\n{\n\tlong long a,b,c,d;\n\tbool operator == (const squ &u) const\n\t{\n\t\treturn (a==u.a && b==u.b && c==u.c && d==u.d);\n\t}\n\tbool operator < (const squ &u) const\n\t{\n\t\tif (a!=u.a) return a<u.a;\n\t\tif (b!=u.b) return b<u.b;\n\t\tif (c!=u.c) return c<u.c;\n\t\treturn d<u.d;\n\t}\n};\nlong long eqal(squ u,squ v)\n{\n\tlong long res=0;\n\tif (u==v) res++;\n\tif (u==(squ){v.b,v.c,v.d,v.a}) res++;\n\tif (u==(squ){v.c,v.d,v.a,v.b}) res++;\n\tif (u==(squ){v.d,v.a,v.b,v.c}) res++;\n\treturn res;\n}\nlong long n,x,y,z,w,lans,ans;\nvector<squ> v;\nmap<squ,long long> mp;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld%lld%lld\",&x,&y,&z,&w);\n\t\tfor (long long j=0;j<v.size();j++)\n\t\t{\n\t\t\tsqu cur=v[j],a1=(squ){x,w,cur.c,cur.b},a2=(squ){z,y,cur.a,cur.d},a3=(squ){y,x,cur.b,cur.a},a4=(squ){w,z,cur.d,cur.c};\n\t\t\tlans=mp[a1]-eqal(cur,a1);\n\t\t\tlans*=(mp[a2]-eqal(cur,a2)-eqal(a1,a2));\n\t\t\tlans*=(mp[a3]-eqal(cur,a3)-eqal(a1,a3)-eqal(a2,a3));\n\t\t\tlans*=(mp[a4]-eqal(cur,a4)-eqal(a1,a4)-eqal(a2,a4)-eqal(a3,a4));\n\t\t\tans+=lans;\n\t\t}\n\t\tv.push_back((squ){x,y,z,w});v.push_back((squ){y,z,w,x});v.push_back((squ){z,w,x,y});v.push_back((squ){w,x,y,z});\n\t\tmp[(squ){x,y,z,w}]++;mp[(squ){y,z,w,x}]++;mp[(squ){z,w,x,y}]++;mp[(squ){w,x,y,z}]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=405,Mod=1e9+7;\n#define ll long long\nmap <ll ,int > ma;\nstruct Node{\n\tint c0,c1,c2,c3;\n}a[N];\ninline void nxt(Node&a){\n\ta=(Node){a.c1,a.c2,a.c3,a.c0};\n}\ninline ll Hash(Node a){\n\treturn (((a.c0*1000ll+a.c1)*1000ll+a.c2)*1000ll+a.c3)*1000ll;\n}\ninline void insert(Node a,int t){\n\tfor (int i=0;i<4;i++){\n\t\tma[Hash(a)]+=t;\n\t\tnxt(a);\n\t}\n}\ninline ll q(Node a){\n\treturn ma[Hash(a)];\n}\nint main (){\n\tint n;scanf (\"%d\",&n);ll ans=0;\n\tfor (int i=1,x,y,z;i<=n;i++)\n\t\tscanf (\"%d%d%d%d\",&a[i].c0,&a[i].c1,&a[i].c2,&a[i].c3),insert(a[i],1);\n\tfor (int i=1;i<=n;i++){\n\t\tinsert(a[i],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tinsert(a[j],-1);\n\t\t\tfor (int t=0;t<4;t++){\n\t\t\t\tNode a1=(Node){a[j].c1,a[i].c0,a[i].c3,a[j].c2};\n\t\t\t\tNode a2=(Node){a[i].c1,a[j].c0,a[j].c3,a[i].c2};\n            \tNode a3=(Node){a[j].c1,a[j].c0,a[i].c1,a[i].c0};\n    \t        Node a4=(Node){a[i].c3,a[i].c2,a[j].c3,a[j].c2};\n            \tnxt(a[j]);\n            \tif (q(a1)==0||q(a2)==0||q(a3)==0||q(a4)==0) continue;\n\t\t\t\tll re=1;\n            \tre*=q(a1);insert(a1,-1);\n            \tre*=q(a2);insert(a2,-1);\n            \tre*=q(a3);insert(a3,-1);\n            \tre*=q(a4);\n            \tinsert(a1,1);insert(a2,1);insert(a3,1);\n            \tans+=re;\n        \t}\n        \tinsert(a[j],1);\n\t\t}\n\t}\n\tprintf (\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                reverse(all(d));\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    // if(i == 0 && j == 4) cerr << res << endl;\n                    vector<int> x = {c[i][(l + 1) % 4], c[i][l], d[l], d[(l + 1) % 4]};\n                    // if(i == 0 && j == 4) {\n                    //     cerr << c[i][l] << \" \" << c[i][(l + 1) % 4] << \" \" << d[(l + 1) % 4] << \" \" << d[l] << endl;\n                    // }\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        res = 0;\n                        break;\n                    }\n                }\n                //if(i == 0 && j == 4) cerr << res << endl;\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                //if(res) cerr << i << \" \" << j << \" \" << res << endl;\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    cout << ans / 6 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> rotate(vector<int>& vec, int i) {\n  vector<int> ret = {vec[(0+i)%4], vec[(1+i)%4], vec[(2+i)%4], vec[(3+i)%4]};\n  return ret;\n}\n\nvector<int> getfirst(vector<int>& v) {\n  vector<vector<int>> ret(4, vector<int>(4));\n  rep(p, 4) {\n    ret[p] = rotate(v, p);\n  }\n  sort(ret.begin(), ret.end());\n  return ret[0];\n}\n\nint getdup(const vector<int>& vec) {\n  if (vec[0] == vec[1] && vec[1] == vec[2] && vec[2] == vec[3]) {\n    return 4;\n  } else if (vec[0] == vec[2] && vec[1] == vec[3]) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<vector<int>> tiles(n, vector<int>(4));\n  map<vector<int>, int> mp;\n  rep(i, n) {\n    int a, b, c, d; cin >> a >> b >> c >> d;\n    tiles[i] = {a, b, c, d};\n    tiles[i] = getfirst(tiles[i]);\n    mp[tiles[i]]++;\n  }\n\n  ll ans = 0;\n  rep(i, n-5) {\n    vector<int> ti = tiles[i];\n    mp[ti]--;\n    for(int j=i+1; j<n; j++) {\n      mp[tiles[j]]--;\n      rep(k, 4) {\n        vector<int> tj = rotate(tiles[j], k);\n        vector<vector<int>> dice(4, vector<int>(4));\n        dice[0] = {ti[0], tj[1], tj[0], ti[1]};\n        dice[1] = {ti[1], tj[0], tj[3], ti[2]};\n        dice[2] = {ti[2], tj[3], tj[2], ti[3]};\n        dice[3] = {ti[3], tj[2], tj[1], ti[0]};\n        map<vector<int>, int> mp2;\n        rep(l, 4) {\n          mp2[getfirst(dice[l])]++;\n        }\n        ll now = 1;\n        for(auto& e: mp2) {\n          int cnt = mp[e.first];\n          int num = e.second;\n          int dup = getdup(e.first);\n          for(int p=1; p<=num; p++) {\n            now *= cnt*dup;\n            cnt--;\n          }\n        }\n        ans += now;\n      }\n      mp[tiles[j]]++;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n\nusing namespace std;\n\nstruct Tile{\n\tint c[4];\n\tTile(){}\n\tTile(int a, int b, int C, int d){\n\t\tc[0] = a, c[1] = b, c[2] = C, c[3] = d;\n\t}\n\tTile(int a[]){\n\t\tfor(int i = 0; i < 4; i++) c[i] = a[i];\n\t}\n\tTile rot(){\n\t\tTile tmp;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ttmp.c[i] = c[(i+1)%4];\n\t\t}\n\t\treturn tmp;\n\t}\n\tbool equal(Tile &obj){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(c[i] != obj.c[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool similar(Tile &obj)\n\t{\n\t\tTile tmp = obj;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) return true;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn false;\n\t}\n\tint sym()\n\t{\n\t\tint ret = 0;\n\t\tTile tmp = *this;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(equal(tmp)) ret++;\n\t\t\ttmp = tmp.rot();\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid print()\n\t{\n\t\tfor(int i = 0; i < 4; i++) cout << c[i] << \" \";\n\t\tcout << endl;\n\t}\n};\n\nint N;\nTile tile[405];\n\nint parent[4];\nvoid init(){\n\tfor(int i = 0; i < 4; i++) parent[i] = i;\n}\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nllint perm(llint n, llint k)\n{\n\tllint ret = 1;\n\tfor(int i = 0; i < k; i++){\n\t\tret *= n-i;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint c[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < 4; j++) cin >> c[j];\n\t\ttile[i] = Tile(c);\n\t}\n\t\n\tllint ans = 0;\n\tllint cnt[4];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\t\n\t\t\tTile t = tile[j];\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\n\t\t\t\tTile need[4];\n\t\t\t\tneed[0] = Tile(tile[i].c[1], tile[i].c[0], t.c[1], t.c[0]);\n\t\t\t\tneed[1] = Tile(tile[i].c[2], tile[i].c[1], t.c[0], t.c[3]);\n\t\t\t\tneed[2] = Tile(tile[i].c[3], tile[i].c[2], t.c[3], t.c[2]);\n\t\t\t\tneed[3] = Tile(tile[i].c[0], tile[i].c[3], t.c[2], t.c[1]);\n\t\t\t\t\n\t\t\t\tfor(int l = 0; l < 4; l++) cnt[l] = 0;\n\t\t\t\tfor(int l = 0; l < N; l++){\n\t\t\t\t\tif(l <= i || l == j) continue;\n\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\tif(tile[l].similar(need[m])) cnt[m]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinit();\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\tif(l >= m) continue;\n\t\t\t\t\t\tif(same(l, m)) continue;\n\t\t\t\t\t\tif(need[l].similar(need[m])) unite(l, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tllint cnum[4];\n\t\t\t\tfor(int i = 0; i < 4; i++) cnum[i] = 0;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tcnum[root(i)]++;\n\t\t\t\t}\n\t\t\t\tllint tmp = 1;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tif(cnum[i]) tmp *= perm(cnt[i], cnum[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++) tmp *= need[i].sym();\n\t\t\t\tans += tmp;\n\n\t\t\t\tt = t.rot();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max<R>(x, 0.0));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\nauto normlize(vector<int> ary) {\n\tvector<int> cmin = ary;\n\n\trep(j, 4) {\n\t\trotate(begin(ary), begin(ary) + 1, end(ary));\n\t\tchmin(cmin, ary);\n\t}\n\n\treturn cmin;\n}\n\nint duplicate(vector<int> ary) {\n\tint ret = 0;\n\tvector<int> cur = ary;\n\n\trep(j, 4) {\n\t\trotate(begin(cur), begin(cur) + 1, end(cur));\n\t\tif (cur == ary) ret++;\n\t}\n\n\treturn ret;\n}\n\n\nclass vector_hash {\npublic:\n\tsize_t operator()(const vector<int> &x) const {\n\t\tconst int C = 1000000007;\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i < x.size(); ++i) {\n\t\t\tt = t * C + x[i];\n\t\t}\n\t\treturn t;\n\t}\n};\n\n\nunordered_map<vector<int>, ll, vector_hash> memo;\n\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> c(n, vector<int>(4, 0));\n\n\trep(i, n) {\n\t\trep(j, 4) cin >> c[i][j];\n\t\tc[i] = normlize(c[i]);\n\t\tmemo[c[i]]++;\n\t}\n\n\n\tll ans = 0LL;\n\n\trep(j, n)rep(i, j) {\n\t\tmemo[c[i]]--;\n\t\tmemo[c[j]]--;\n\n\t\trep(di, 4) rep(dj, 4) {\n\t\t\tvector<int> top = c[i];\n\t\t\tvector<int> bottom = c[j];\n\t\t\treverse(begin(bottom), end(bottom));\n\n\t\t\trotate(begin(top), begin(top) + di, end(top));\n\t\t\trotate(begin(bottom), begin(bottom) + dj, end(bottom));\n\n\n\t\t\tll cur = 1LL;\n\n\t\t\tmap<vector<int>, ll> tmp;\n\n\n\t\t\trep(dd, 4) {\n\t\t\t\tvector<int> rot = {bottom[(dd + 0) % 4], bottom[(dd + 1) % 4], top[(dd + 1) % 4], top[(dd + 0) % 4]};\n\t\t\t\trot = normlize(rot);\n\t\t\t\ttmp[rot]++;\n\t\t\t}\n\n\t\t\tfor (auto &it : tmp) {\n\t\t\t\tconst ll coef = duplicate(it.first);\n\n\t\t\t\trep(k, it.second) {\n\t\t\t\t\tcur *= coef;\n\t\t\t\t\tcur *= (memo[it.first] - k);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += 1LL * cur;\n\t\t}\n\n\t\tmemo[c[i]]++;\n\t\tmemo[c[j]]++;\n\t}\n\n\tcout << ans / 12LL << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nvint rig(vint v){\n    vector<vint>r(4);\n    rep(i,4){\n        r[i]=v;\n        rotate(r[i].begin(),r[i].begin()+i,r[i].end());\n    }\n    sort(all(r));\n    return r[0];\n}\n\nint en(vint v){\n    int r=0;\n    rep(i,v.size())r=r*1000+v[i];\n    return r;\n}\n\nint N;\nvector<int>C[4];\nsigned main(){\n    cin>>N;\n    map<int,int>cnt;\n    map<int,int>way;\n    rep(i,N){\n        C[i].resize(4);\n        rep(j,4)cin>>C[i][j];\n        C[i]=rig(C[i]);\n        cnt[en(C[i])]++;\n\n        vint v=C[i];\n        set<vint>s;\n        rep(k,4){\n            s.insert(v);\n            rotate(v.begin(),v.begin()+1,v.end());\n        }\n        way[en(C[i])]=4/s.size();\n    }\n\n    int ans=0;\n    rep(i,N){\n        rep(j,N)if(i!=j){\n            vint X=C[i];\n            vint Y=C[j];\n            cnt[en(C[i])]--;\n            cnt[en(C[j])]--;\n            reverse(all(Y));\n\n            rep(ii,4){\n\n                vint wanna(4);\n                rep(k,4){\n                    vint v(4);\n                    v[0]=X[(k+1)%4];\n                    v[1]=X[k];\n                    v[2]=Y[k];\n                    v[3]=Y[(k+1)%4];\n                    wanna[k]=en(rig(v));\n                }\n                vpint want;\n                rep(k,4){\n                    if(want.size()==0||want.back().fi!=wanna[k]){\n                        want.push_back(pint(wanna[k],1));\n                    }\n                    else{\n                        want[want.size()-1].se++;\n                    }\n                }\n\n                int tmp=1;\n                rep(k,want.size()){\n                    int e=want[k].fi;\n                    int f=want[k].se;\n                    if(cnt.find(e)==cnt.end()){\n                        tmp=0;\n                        continue;\n                    }\n                    int hoge=cnt[e];\n                    int piyo=way[e];\n                    rep(l,f)tmp*=(hoge-l)*piyo;\n                }\n                ans+=tmp;\n\n                rotate(Y.begin(),Y.begin()+1,Y.end());\n            }\n\n            cnt[en(C[i])]++;\n            cnt[en(C[j])]++;\n        }\n    }\n    cout<<ans/6<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 405;\n\ntypedef pair<Pii, Pii> Surface;\n\nint N;\nSurface A[MAXN];\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i <= N; ++i) {\n        read(A[i].x.x); read(A[i].x.y);\n        read(A[i].y.y); read(A[i].y.x);\n    }\n}\n\nstd::map<Surface, int> cnt;\n\ninline Surface R(const Surface &s)\n{\n    return MP(MP(s.x.y, s.y.y), MP(s.x.x, s.y.x));\n}\n\ninline void contrib(const Surface &s, int f)\n{\n    cnt[s] += f;\n    cnt[R(s)] += f;\n    cnt[R(R(s))] += f;\n    cnt[R(R(R(s)))] += f;\n}\n\nvoid solve()\n{\n    LL ans = 0;\n\n    for (int i = N; i >= 1; --i) {\n        Surface si = A[i];\n        for (int j = i + 1; j <= N; ++j) {\n            Surface sj = A[j];\n            contrib(sj, -1);\n            for (int k = 0; k < 4; ++k) {\n                Surface l = MP(MP(sj.x.y, si.x.x), MP(sj.y.y, si.y.x));\n                Surface r = MP(MP(si.x.y, sj.x.x), MP(si.y.y, sj.y.x));\n                Surface u = MP(MP(sj.x.y, sj.x.x), MP(si.x.x, si.x.y));\n                Surface d = MP(MP(si.y.x, si.y.y), MP(sj.y.y, sj.y.x));\n                if (cnt.count(l) && cnt.count(r) && cnt.count(u) && cnt.count(d)) {\n                    LL cur = 1;\n                    cur *= cnt[l]; contrib(l, -1);\n                    cur *= cnt[r]; contrib(r, -1);\n                    cur *= cnt[u]; contrib(u, -1);\n                    cur *= cnt[d]; contrib(d, -1);\n                    ans += cur;\n                    contrib(l, +1);\n                    contrib(r, +1);\n                    contrib(u, +1);\n                    contrib(d, +1);\n                }\n                sj = R(sj);\n            }\n            contrib(sj, +1);\n        }\n        contrib(si, +1);\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 我们称那位衣着暴露的S小姐为”局部真理”，因为真理都是赤裸裸的。\n//   --钱钟书\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 405;\nusing namespace std;\n\nmap <long long, int> mymap;\nint n;\nlong long a[N], ans;\n\nlong long po(int x){\n    if (x == 0) return 1;\n    if (x == 1) return 1000;\n    if (x == 2) return 1000000;\n    if (x == 3) return 1000000000;\n}\n\nlong long rotate(long long x){\n    long long t = x % po(1); x /= po(1);\n    x += t * po(3);\n    return x;\n}\n\nlong long get(long long a, int num){\n    return (a / po(num)) % 1000;\n}\n\nlong long reverse(long long x){\n    long long y = get(x, 0) * po(3) + get(x, 1) * po(2) + get(x, 2) * po(1) + get(x, 3) * po(0);\n    return y;\n}\n\nsigned main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        int x, y, z, t;\n        cin >> x >> y >> z >> t;\n        a[i] = 1LL * x * 1000000000 + 1LL * y * 1000000 + 1LL * z * 1000 + t;\n        mymap[a[i]]++;\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j < i; j++){\n            mymap[a[i]]--; mymap[a[j]]--;\n            long long x = reverse(a[j]);\n            for (int k = 0; k < 4; k++){\n                long long cnt = 0, mul = 1;\n                for (int h = 0; h < 4; h++){\n                    long long color = 0, cnt = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    for (int l = 0; l < 4; l++) cnt += mymap[color], color = rotate(color);\n                    mul *= cnt;\n                    mymap[color]--;\n                }\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    mymap[color]++;\n                }\n                ans += mul;\n                x = rotate(x);\n            }\n            mymap[a[i]]++; mymap[a[j]]++;\n        }\n    }\n    ans /= 3;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\nusing namespace std;\n\nint nextInt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 400;\nint col[N][8];\nlong long hashes[N][4];\nlong long dp[16];\nint ways[4];\n\nlong long calcHash(int a, int b, int c, int d) {\n\tlong long h = 0;\n\th = 1000 * h + a;\n\th = 1000 * h + b;\n\th = 1000 * h + c;\n\th = 1000 * h + d;\n\treturn h;\n}\n\nint main() {\n\tint n = nextInt();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcol[i][j] = nextInt();\n\t\t\tcol[i][j + 4] = col[i][j];\n\t\t}\n\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\thashes[i][rot] = 1000 * hashes[i][rot] + col[i][(rot + j) % 4];\n\t\t\t}\n\t\t\tany.insert(hashes[i][rot]);\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int front = 0; front < n; front++) {\n\t\tint a = col[front][0];\n\t\tint b = col[front][1];\n\t\tint c = col[front][2];\n\t\tint d = col[front][3];\n\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\trotLoop:\n\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\tlong long h1 = calcHash(a, e, f, b);\n\t\t\t\tlong long h2 = calcHash(b, f, g, c);\n\t\t\t\tlong long h3 = calcHash(d, c, g, h);\n\t\t\t\tlong long h4 = calcHash(e, a, d, h);\n\t\t\t\tvector<long long> hs = {h1, h2, h3, h4};\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tdp[i] = 0;\n\t\t\t\t}\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tways[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\tif (hashes[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nvector<int> opt[4];\nmap<ll, vector<int>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                m[msk].PB(i);\n        }\n\n        fo(i, 0, 4) fo(j, 0, 16) if (((1<<i)&j) == 0) opt[i].PB(j);\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk= 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (int i : m[msk]) {\n                                cub[i][p]++;\n                        }\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, top+1, N) if (i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                        fo(x, 0, 4) {\n                                for (int j : opt[x]) {\n                                        ways[j|(1<<x)] += old[j] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot/3);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<int> v(4),u(4);\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    v[q]=C[i][q];\n                    u[q]=C[j][(p-q+4)%4];\n                }\n                vector<vector<int>> surface(4,vector<int>(4));\n                for (int q=0;q<4;++q){\n                    surface[q][0]=v[q];\n                    surface[q][1]=u[q];\n                    surface[q][2]=u[(q+1)%4];\n                    surface[q][3]=v[(q+1)%4];\n                }\n                vector<vector<ll>> dp(N+1,vector<ll>(16,0));\n                dp[0][0]=1;\n                for (int k=0;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]+=dp[k][l];\n                    if (k==i||k==j) continue;\n                    for (int l=0;l<4;++l){\n                        for (int m=0;m<4;++m){\n                            bool flag=true;\n                            for (int n=0;n<4;++n){\n                                if (surface[l][n]!=C[k][(m+n)%4]){\n                                    flag=false;\n                                }\n                            }\n                            if (flag){\n                                for (int mask=15;mask>=0;--mask){\n                                    if (!(mask&1<<l)){\n                                        dp[k+1][mask|1<<l]+=dp[k][mask];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans/3 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=1000;\n\nll n,co[MAXN][8],u[4],ans;\nmap<ll,ll> vis;\n\nll get(ll a,ll b,ll c,ll d){\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nvoid add(ll x,ll v){\n    for(int i=0;i<4;i++){\n        vis[x]+=v;\n        x=(x>>10)|(x&1023)<<30;\n    }\n}\n\nint main(){\n    scanf(\"%lld\",&n);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<4;j++){\n            scanf(\"%lld\",&co[i][j]);\n            co[i][j+4]=co[i][j];\n        }\n        add(get(co[i][0],co[i][1],co[i][2],co[i][3]),1);\n    }\n    for(int i=0;i<n;i++){\n        add(get(co[i][0],co[i][1],co[i][2],co[i][3]),-1);\n        for(int j=i+1;j<n;j++){\n            add(get(co[j][0],co[j][1],co[j][2],co[j][3]),-1);\n            for(int k=0;k<4;k++){\n                ll r=1;\n                u[0]=get(co[j][k+1],co[j][k+0],co[i][1],co[i][0]);\n                u[1]=get(co[j][k+0],co[j][k+3],co[i][2],co[i][1]);\n                u[2]=get(co[j][k+3],co[j][k+2],co[i][3],co[i][2]);\n                u[3]=get(co[j][k+2],co[j][k+1],co[i][4],co[i][3]);\n                if(vis[u[0]]&&vis[u[1]]&&vis[u[2]]&&vis[u[3]]){\n                    r*=vis[u[0]]; add(u[0],-1);\n                    r*=vis[u[1]]; add(u[1],-1);\n                    r*=vis[u[2]]; add(u[2],-1);\n                    r*=vis[u[3]];\n                    add(u[2],1); add(u[1],1); add(u[0],1);\n                    ans+=r;\n                }\n            }\n            add(get(co[j][0],co[j][1],co[j][2],co[j][3]),1);\n        }\n    }\n    printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nchar c[404][4];\n\nusing VC = vector<char>;\n\nVC normalize(const VC &v){\n  VC cand(v);\n  rep(i,1,4){\n    VC nv;\n    rep(j,4) nv.pb(v[(i+j)%4]);\n    if(nv < cand) cand = nv;\n  }\n  return cand;\n}\n\nint main(){\n  map<VC, int> ma;\n  int n;\n  cin>>n;\n  rep(i,n) rep(j,4) cin>>c[i][j];\n  rep(i,n){\n    ma[normalize(VC(c[i], c[i+1]))]++;\n  }\n// dbg(vector<pair<VC,int>>(all(ma)));\n  const int d[4][4] = { {0,3,1,0}, {3,2,2,1}, {2,1,3,2}, {1,0,0,3} };\n\n  // vc をx個選ぶ方法\n  auto sel = [&](const VC &vc, int x, int dup){\n    if(ma[vc]-dup <= 0) return 0L;\n    long mul = 1;\n    if(vc[0] == vc[2] && vc[1] == vc[3]){\n      if(vc[0] == vc[1]) mul = 4;\n      else mul = 2;\n    }\n    long ret = 1;\n    rep(i,x) ret *= (ma[vc]-i-dup)*mul;\n    return ret;\n  };\n\n  long ans = 0;\n  rep(i,n) rep(j,i){\n    VC vi = normalize(VC(c[i], c[i+1]));\n    VC vj = normalize(VC(c[j], c[j+1]));\n    rep(r,4){\n      map<VC, int> cur;\n      rep(k,4){\n        auto vc = normalize({\n          c[i][d[k][0]],\n          c[i][d[k][1]],\n          c[j][(r+d[k][2])%4],\n          c[j][(r+d[k][3])%4]\n        });\n        cur[vc]++;\n      }\n      long tmp = 1;\n      for(auto &pp : cur){\n        int dup = 0;\n        if(pp.fi == vi) dup++;\n        if(pp.fi == vj) dup++;\n        tmp *= sel(pp.first, pp.second, dup);\n      }\n      ans += tmp;\n    }\n  }\n\n  cout << ans / 3 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nmap<vector<int>, int> mt;\nint flag[4];\n\nvector<int> rotate(vector<int> x){\n\treturn vector<int>{x[3],x[0],x[1],x[2]};\n}\n\nvoid used(vector<int> x){\n    for (int i = 0; i < 4; i++){\n        rotate(x);\n        mt[x]--;\n    }\n}\nvoid rev(vector<int> x){\n    for (int i = 0; i < 4; i++){\n        rotate(x);\n        mt[x]++;\n    }\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tvector<vector<int> > faces(n,vector<int>(4));\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcin>>faces[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\trev(faces[i]);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tvector<int> upper = faces[i];\n\t\t\tvector<int> lower = faces[j];\n\n\t\t\tused(upper);\n            used(lower);\n\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tupper = rotate(upper);\n\t\t\t\tvector<int> side[4];\n\t\t\t\tside[0] = vector<int>{upper[1],upper[0],lower[1],lower[0]};\n\t\t\t\tside[1] = vector<int>{upper[2],upper[1],lower[0],lower[3]};\n\t\t\t\tside[2] = vector<int>{upper[3],upper[2],lower[3],lower[2]};\n\t\t\t\tside[3] = vector<int>{upper[0],upper[3],lower[2],lower[1]};\n\n\t\t\t\tll cnt = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tflag[l] = 0;\n\t\t\t\t}\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tif(mt.count(side[l])>0 && mt[side[l]] > 0){\n\t\t\t\t\t\tcnt *= mt[side[l]];\n\t\t\t\t\t\tflag[l]++;\n\t\t\t\t\t\tused(side[l]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += cnt;\n\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\tif(flag[l]>0){\n\t\t\t\t\t\trev(side[l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            rev(upper);\n            rev(lower);\n\t\t}\n\t}\n\n\tcout << ans/3 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=400+19;\n\nstruct node{\n\tint s[4];\n\tbool operator < (const node &B) const{\n\t\tFor(i,0,4) if (s[i]!=B.s[i]) return s[i]<B.s[i];\n\t\treturn 0;\n\t}\n\tvoid gao(){\n\t\tint tmp=s[0];\n\t\tFor(i,0,3) s[i]=s[i+1];\n\t\ts[3]=tmp;\n\t}\n\tll num(){\n\t\tll res=0;\n\t\tFor(i,0,4) res=res*1000+s[i];\n\t\treturn res;\n\t}\n} A[N];\n\nmap<ll,int> M;\nint n;\nll B[4],res;\n\nvoid dfs(int x,ll tmp){\n\tif (x==4){\n\t\tres+=tmp;\n\t\treturn;\n\t}\n\tFor(i,0,4){\n\t\tif (M[B[x]]){\n\t\t\tdfs(x+1,tmp*(M[B[x]]--));\n\t\t\tM[B[x]]++;\n\t\t}\n\t\tB[x]=(B[x]/1000)+(B[x]%1000)*ll(1e9);\n\t}\n}\n\nint main(){\n\tn=IN();\n\tFor(i,1,n+1){\n\t\tFor(j,0,4) A[i].s[j]=IN();\n\t\tM[A[i].num()]++;\n\t}\n\tFor(i,1,n+1) For(j,i+1,n+1){\n\t\tM[A[i].num()]--;\n\t\tM[A[j].num()]--;\n\t\tFor(w,0,4){\n\t\t\tB[0]=((node){A[i].s[0],A[i].s[3],A[j].s[2],A[j].s[1]}).num();\n\t\t\tB[1]=((node){A[i].s[3],A[i].s[2],A[j].s[3],A[j].s[2]}).num();\n\t\t\tB[2]=((node){A[i].s[2],A[i].s[1],A[j].s[0],A[j].s[3]}).num();\n\t\t\tB[3]=((node){A[i].s[1],A[i].s[0],A[j].s[1],A[j].s[0]}).num();\n\t\t\tdfs(0,1);\n\t\t\tA[j].gao();\n\t\t}\n\t\tM[A[j].num()]++;\n\t\tM[A[i].num()]++;\n\t}\n\tprintf(\"%lld\\n\",res/3);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<deque<Int>, Int> cnt;\n  using face = deque<Int>;\n  \n  auto add=[&](face v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v.emplace_back(Int(v.front()));\n      v.pop_front();\n    }\n  };\n  \n  \n  for(Int i=0;i<n;i++){\n    face v(4);\n    for(Int j=0;j<4;j++) cin>>v[j];\n    add(v,1);\n  }\n  \n  vector<face> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = deque<Int>;\n  auto right=[&](const sq &v){\n    vector<Int> ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    vector<Int> ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    vector<Int> ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  set<sq> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(b);\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=b[i][k];\n      for(Int k=0;k<4;k++) a[k+4]=b[j][k];\n      if(used.count(a)) continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);\n\t\n      if(0){\n\tface w({a[2],a[1],a[4],a[7]});\n\tface x({a[0],a[3],a[6],a[5]});\n\tface y({a[3],a[2],a[7],a[6]});\n\tface z({a[1],a[0],a[5],a[4]});\n      \n\tres*=cnt[b[j]];      \n\tadd(b[j],-1);\n      \n\tres*=cnt[w];\n\tadd(w,-1);\n\n\tres*=cnt[x];\n\tadd(x,-1);\n\n\tres*=cnt[y];\n\tadd(y,-1);\n\n\tres*=cnt[z];\n\tadd(z,-1);\n\n\tadd(b[i],1);\n\tadd(b[j],1);\n\tadd(w,1);\n\tadd(x,1);\n\tadd(y,1);\n\tadd(z,1);\n      }\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nusing vector2 = vector<vector<T>>;\ntemplate <typename T>\nvector2<T> initVec2(size_t n0, size_t n1, T e = T()){\n    return vector2<T>(n0, vector<T>(n1, e));\n}\n\ntemplate <typename T>\nusing vector3 = vector<vector<vector<T>>>;\ntemplate <typename T>\nvector3<T> initVec3(size_t n0, size_t n1, size_t n2, T e = T()){\n    return vector3<T>(n0, vector2<T>(n1, vector<T>(n2, e)));\n}\n\ntypedef tuple<int, int, int, int> tup;\n\ntup rotate(tup& t){\n    int a, b, c, d;\n    tie(a, b, c, d) = t;\n    return make_tuple(b, c, d, a);\n}\n\nbool check(tup& s, tup& t, int& c){\n    if(s == t){\n        c--;\n    }\n    t = rotate(t);\n    if(s == t){\n        c--;\n    }\n    t = rotate(t);\n    if(s == t){\n        c--;\n    }\n    t = rotate(t);\n    if(s == t){\n        c--;\n    }\n    return c;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    vector<tup> v(n);\n    map<tup, int> m;\n    rep(i, n){\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        tup t = make_tuple(a, b, c, d);\n        v[i] = t;\n\n        m[t]++;\n        t = rotate(t);\n        m[t]++;\n        t = rotate(t);\n        m[t]++;\n        t = rotate(t);\n        m[t]++;\n    }\n\n    int ans = 0;\n    rep(i, n){\n        tup t = v[i];\n        m[t]--;\n        t = rotate(t);\n        m[t]--;\n        t = rotate(t);\n        m[t]--;\n        t = rotate(t);\n        m[t]--;\n\n        int a, b, c, d;\n        tie(a, b, c, d) = t;\n        for(int j = i + 1; j < n; j++){\n            tup t1 = v[j];\n            rep(k, 4){\n                int e, f, g, h;\n                tie(e, f, g, h) = t1;\n                t1 = rotate(t1);\n\n                tup t2 = make_tuple(b, a, h, g);\n                tup t3 = make_tuple(c, b, g, f);\n                tup t4 = make_tuple(d, c, f, e);\n                tup t5 = make_tuple(a, d, e, h);\n\n                int c2 = m[t2];\n                int c3 = m[t3];\n                int c4 = m[t4];\n                int c5 = m[t5];\n\n                check(t1, t2, c2);\n                check(t1, t3, c3);\n                check(t2, t3, c3);\n                check(t1, t4, c4);\n                check(t2, t4, c4);\n                check(t3, t4, c4);\n                check(t1, t5, c5);\n                check(t2, t5, c5);\n                check(t3, t5, c5);\n                check(t4, t5, c5);\n\n                if(c2 <= 0 || c3 <= 0 || c4 <= 0 || c5 <= 0){\n                    continue;\n                }\n                ans += c2 * c3 * c4 * c5;\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        res = 0;\n                        break;\n                    }\n                }\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                //if(res) cerr << i << \" \" << j << \" \" << res << endl;\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    cout << ans / 6 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[405];\nlong long x[405][4];\nlong long c[405][10];\nmap<long long,int>m;\nlong long get(long long x,long long y,long long z,long long h){return (((((x<<10)+y)<<10)+z)<<10)+h;}\nlong long doit(long long x,long long y,long long z,long long h){return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));}\nlong long fac(long long x){long long ret=1;for(int i=1;i<=x;i++)ret*=i;return ret;}\nlong long rot(long long x)\n{\n    int k[4];\n\tfor(int i=0;i<=3;i++,x>>=10)k[i]=x&((1<<10)-1);\n    if(k[0]==k[1]&&k[1]==k[2]&&k[2]==k[3])return 4;\n    if(k[0]==k[2]&&k[1]==k[3])return 2;\n    return 1;\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)c[i][0]=c[i][i]=1;\n    for(int i=1;i<=n;i++)for(int j=1;j<=min(4,i-1);j++)c[i][j]=c[i-1][j]+c[i-1][j-1];\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=0;j<=3;j++)cin>>x[i][j];\n    \ta[i]=doit(x[i][0],x[i][1],x[i][2],x[i][3]);\n    }\n    long long ans=0;\n    m.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int ii=1;ii<i;ii++)\n\t\t{\n\t        for(int j=0;j<=3;j++)\n            {\n                long long y[4];\n            \ty[0]=doit(x[ii][(j+1)%4],x[ii][(j+0)%4],x[i][1],x[i][0]);\n                y[1]=doit(x[ii][(j+0)%4],x[ii][(j+3)%4],x[i][2],x[i][1]);\n                y[2]=doit(x[ii][(j+3)%4],x[ii][(j+2)%4],x[i][3],x[i][2]);\n                y[3]=doit(x[ii][(j+2)%4],x[ii][(j+1)%4],x[i][0],x[i][3]);\n                sort(y,y+4);\n                long long ret=1;\n                for(int p=0;p<4;)\n                {\n                    int cnt=1;\n                    for(int r=p+1;r<4&&y[r]==y[p];r++)cnt++;\n                    int num=m[y[p]];\n                    if(y[p]==a[ii])num--;\n                    if(num<cnt){ret=0;break;}\n                    ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                    p+=cnt;\n                }\n                ans+=ret;\n            }\n        }\n\t\tm[a[i]]++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\ntypedef array<int, 4> Tile;\n\nint cntSameRotate(Tile t) {\n    Tile t1 = t;\n    int ret = 1;\n    for (int i = 0; i < 3; ++i) {\n        rotate(t1.begin(), t1.begin() + 1, t1.end());\n        ret += (t1 == t);\n    }\n    return ret;\n}\n\nTile minLex(Tile t) {\n    Tile ret = t, tx = t;\n    for (int i = 1; i < 4; ++i) {\n        rotate(tx.begin(), tx.begin() + 1, tx.end());\n        ret = min(ret, tx);\n    }\n    return ret;\n}\n\nint64_t comb(int n, int k) {\n    int64_t ans = 1;\n    for (int i = 1; i <= k; ++i) {\n        ans *= (n - i + 1);\n    }\n    return ans;\n}\n\nostream& operator<<(ostream& o, const Tile& t) {\n    o << \"{\";\n    for (int i = 0; i < 3; ++i) {\n        o << t[i] << \", \";\n    }\n    o << t[3] << \"}\";\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<Tile> tiles(n);\n    map<Tile, int> cnt;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> tiles[i][j];\n        }\n        tiles[i] = minLex(tiles[i]);\n        cnt[tiles[i]]++;\n    }\n\n    int64_t ans = 0;\n    for (int i = 0; i < n; ++i) {\n        Tile t1 = tiles[i];\n        cnt[t1]--;\n        for (int j = i + 1; j < n; ++j) {\n            Tile t2 = tiles[j];\n            cnt[tiles[j]]--;\n            reverse(t2.begin(), t2.end());\n            for (int k = 0; k < 4; ++k) {\n                rotate(t2.begin(), t2.begin() + 1, t2.end());\n                array<Tile, 4> t;\n                for (int i = 0; i < 4; ++i) {\n                    t[i] = {t1[(i + 1) & 3], t1[i], t2[i], t2[(i + 1) & 3]};\n                    t[i] = minLex(t[i]);\n                }\n                sort(t.begin(), t.end());\n                int64_t add = 1;\n                for (int i = 0, j; i < 4; i = j) {\n                    for (j = i; j < 4 && t[j] == t[i]; ++j);\n                    add *= comb(cnt[t[i]], j - i);\n                    for (int x = 0; x < j - i; ++x) {\n                        add *= cntSameRotate(t[i]);\n                    }\n                }\n                ans += add;\n            }\n            cnt[tiles[j]]++;\n        }\n    }\n\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 405\n\nusing namespace std;\n\nstruct my_hash {\n\tsize_t operator()(vector<int> v) const {\n\t\tunsigned long long x = 0;\n\t\tfor(int i = 0;i < 4;i++) x = x * 1313 + v[i];\n  \t\treturn x;\n  \t}\n};\n\nunordered_map<vector<int>, unsigned long long, my_hash> mp;\n\nint n;\nint x;\nvector<int> v[maxn];\nlong long ans;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= 4;j++){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tv[i].push_back(x);\n\t\t}\n\t\tfor(int j = 1;j <= 4;j++){\n\t\t\tmp[v[i]]++;\n\t\t\trotate(v[i].begin(), v[i].begin() + 1, v[i].end());\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int k = 1;k <= 4;k++){\n\t\t\tmp[v[i]]--;\n\t\t\trotate(v[i].begin(), v[i].begin() + 1, v[i].end());\n\t\t}\n\t\tfor(int j = 1;j < i;j++){\n\t\t\tfor(int k = 1;k <= 4;k++){\n\t\t\t\tmp[v[j]]--;\n\t\t\t\trotate(v[j].begin(), v[j].begin() + 1, v[j].end());\n\t\t\t}\n\t\t\tfor(int k = 1;k <= 4;k++){\n\t\t\t\tlong long sum = 1;\n\t\t\t\treverse(v[j].begin(), v[j].end());\n\t\t\t\t//printf(\"%d %d %d--\\n\", i, j, k);\n\t\t\t\t//printf(\"%d %d %d %d--!!\\n\", v[i][0], v[i][1], v[i][2], v[i][3]);\n\t\t\t\t//printf(\"%d %d %d %d--!!\\n\", v[j][0], v[j][1], v[j][2], v[j][3]);\n\t\t\t\t\n\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\tvector<int> a;\n\t\t\t\t\ta.push_back(v[j][l]), a.push_back(v[j][(l + 1) % 4]);\n\t\t\t\t\ta.push_back(v[i][(l + 1) % 4]), a.push_back(v[i][l]);\n\t\t\t\t\tsum *= mp[a];\n\t\t\t\t\t//printf(\"%d %d %d %d--\\n\", a[0], a[1], a[2], a[3]);\n\t\t\t\t\tfor(int o = 0;o < 4;o++){\n\t\t\t\t\t\tmp[a]--;\n\t\t\t\t\t\trotate(a.begin(), a.begin() + 1, a.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += sum;\n\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\tvector<int> a;\n\t\t\t\t\ta.push_back(v[j][l]), a.push_back(v[j][(l + 1) % 4]);\n\t\t\t\t\ta.push_back(v[i][(l + 1) % 4]), a.push_back(v[i][l]);\n\t\t\t\t\tfor(int o = 0;o < 4;o++){\n\t\t\t\t\t\tmp[a]++;\n\t\t\t\t\t\trotate(a.begin(), a.begin() + 1, a.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treverse(v[j].begin(), v[j].end());\n\t\t\t\trotate(v[j].begin(), v[j].begin() + 1, v[j].end());\n\t\t\t} \n\t\t\tfor(int k = 1;k <= 4;k++){\n\t\t\t\tmp[v[j]]++;\n\t\t\t\trotate(v[j].begin(), v[j].begin() + 1, v[j].end());\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1;k <= 4;k++){\n\t\t\tmp[v[i]]++;\n\t\t\trotate(v[i].begin(), v[i].begin() + 1, v[i].end());\n\t\t}\n\t}\n\tprintf(\"%lld\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MT make_tuple\n#define PB push_back\ntypedef long long ll;\n\nint N, c[440][4], g[8], pos[4][4], ne, msk;\nll cub[440][4], old[16], ways[16], tot;\n//cub[cube][position] = ways to fill that position\n\nint opt[4][8];\nmap<ll, vector<int>> m;\n\nint mp[4][4] = {\n        {3, 2, 6, 7},\n        {2, 1, 5, 6},\n        {1, 0, 4, 5},\n        {0, 3, 7, 4}\n};\n\nint main () {\n        scanf(\"%d\", &N);\n\n        fo(i, 0, N) fo(j, 0, 4) scanf(\"%d\", &c[i][j]);\n\n        fo(i, 0, N) fo(o, 0, 4) {\n                msk = 0;\n                fo(j, 0, 4) msk = msk * 1000 + c[i][(j+o)%4];\n                m[msk].PB(i);\n        }\n\n        fo(i, 0, 4) {\n                int c = 0;\n                fo(j, 0, 16) if (((1<<i)&j) == 0) opt[i][c++] = j;\n        }\n\n        fo(top, 0, N) fo(bot, top+1, N) fo(br, 0, 4) {\n\n                fo(i, 0, 4) g[i] = c[top][i];\n                fo(i, 0, 4) g[i+4] = c[bot][3 - (i+br)%4]; //flipped\n\n                //printf(\"top %d bot %d\\n\", top, bot);\n\n                /*\n                   pos[0][0] = g[3], pos[0][1] = g[2], pos[0][2] = g[6], pos[0][3] = g[7];\n                   pos[1][0] = g[2], pos[1][1] = g[1], pos[1][2] = g[5], pos[1][3] = g[6];\n                   pos[2][0] = g[1], pos[2][1] = g[0], pos[2][2] = g[4], pos[2][3] = g[5];\n                   pos[3][0] = g[0], pos[3][1] = g[3], pos[3][2] = g[7], pos[3][3] = g[4];\n                 */\n\n                //for each position... evaluate mask... then iterate into vector... then add posibilities...\n                fo(i, 0, N) fo(j, 0, 4) cub[i][j] = 0;\n                fo(p, 0, 4) {\n                        msk= 0;\n                        fo(j, 0, 4) msk= msk * 1000 + g[mp[p][j]];\n                        for (int i : m[msk]) {\n                                cub[i][p]++;\n                        }\n                }\n                fo(j, 0, 16) ways[j] = 0; ways[0] = 1;\n                fo(i, top+1, N) if (i != bot) {\n                        fo(j, 0, 16) old[j] = ways[j], ways[j] = 0;\n                        fo(x, 0, 4) if (cub[i][x]) {\n                                fo(j, 0, 8) if (old[opt[x][j]]) {\n                                        ways[opt[x][j]|(1<<x)] += old[opt[x][j]] * cub[i][x];\n                                }\n                        }\n                        fo(j, 0, 16) ways[j] += old[j];\n                }\n                tot += ways[15];\n        }\n        printf(\"%lld\\n\", tot);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<ll,ll>mp;\n  const ll tmp=(1<<10)-1;\n  ll access(const vector<ll>&v){\n    ll ret=0;\n    ll now=trans(v);\n    rep(i,0,4){\n      ret+=mp[now];\n      now=shift(now);\n    }\n    return max(0LL,ret);\n  }\n  void change(const vector<ll>&v,ll w){\n    mp[trans(v)]+=w;\n  }\n  ll trans(const vector<ll>&v){\n    return v[0]+(v[1]<<10)+(v[2]<<20)+(v[3]<<30);\n  }\n  ll shift(ll x){\n    return (x>>10)+((x&tmp)<<30);\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,ll(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.change(c[i],1);\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<ll>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<ll>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ndeque<int> f(deque<int> d) {\n\tdeque<int> ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d.front());\n\t\td.pop_front();\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint count_overlap(deque<int> d) {\n\tint ret = 1;\n\tdeque<int> t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d.front());\n\t\td.pop_front();\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\ndeque<int> C[400];\nll P[5];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tP[0] = 1;\n\tfor(int i = 1; i <= 4; i++) {\n\t\tP[i] = P[i - 1] * i;\n\t}\n\n\tint N;\n\tcin >> N;\n\n\tmap<deque<int>, int> m;\n\tmap<deque<int>, int> cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tdeque<int> d;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\td.push_back(c);\n\t\t}\n\t\td = f(d);\n\t\tC[i] = d;\n\t\tm[d]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = count_overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tdeque<int> d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\tdeque<int> d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<deque<int>, int> t;\n\t\t\t\tdeque<int> p1({ d1[1], d1[0], d2[1], d2[0] });\n\t\t\t\tdeque<int> p2({ d1[0], d1[3], d2[2], d2[1] });\n\t\t\t\tdeque<int> p3({ d1[3], d1[2], d2[3], d2[2] });\n\t\t\t\tdeque<int> p4({ d1[2], d1[1], d2[0], d2[3] });\n\t\t\t\tt[f(p1)]++;\n\t\t\t\tt[f(p2)]++;\n\t\t\t\tt[f(p3)]++;\n\t\t\t\tt[f(p4)]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P[p.second];\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\td1.push_back(d1[0]);\n\t\t\t\td1.pop_front();\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\ntypedef tuple<int, int, int, int> TP;\nTP narabi(int a, int b, int c, int d) {\n\tTP kari[4];\n\tkari[0] = tie(a, b, c, d);\n\tkari[1] = tie(b, c, d, a);\n\tkari[2] = tie(c, d, a, b);\n\tkari[3] = tie(d, a, b, c);\n\treturn *min_element(kari, kari + 4);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\tTP C[400];\n\tint cnum[1000] = {};\n\trep(i, N) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tC[i] = narabi(a, b, c, d);\n\t\tcnum[a]++;\n\t\tcnum[b]++;\n\t\tcnum[c]++;\n\t\tcnum[d]++;\n\t}\n\n\tsort(C, C + N);\n\tint kazu[400] = {};\n\trep(i, N) {\n\t\tint k = i;\n\t\twhile (k + 1 < N && C[k + 1] == C[i]) k++;\n\t\tkazu[i] = k - i + 1;\n\t\ti = k;\n\t}\n\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint inum = lower_bound(C, C + N, C[i]) - C;\n\t\tkazu[inum]--;\n\t\trep(j, N) if (i != j) {\n\n\t\t\tint a, b, c, d, e, f, g, h;\n\t\t\ta = get<0>(C[i]);\n\t\t\tb = get<1>(C[i]);\n\t\t\tc = get<2>(C[i]);\n\t\t\td = get<3>(C[i]);\n\t\t\te = get<0>(C[j]);\n\t\t\tf = get<1>(C[j]);\n\t\t\tg = get<2>(C[j]);\n\t\t\th = get<3>(C[j]);\n\t\t\tif (cnum[a] <= 2) continue;\n\t\t\tif (cnum[b] <= 2) continue;\n\t\t\tif (cnum[c] <= 2) continue;\n\t\t\tif (cnum[d] <= 2) continue;\n\t\t\tif (cnum[e] <= 2) continue;\n\t\t\tif (cnum[f] <= 2) continue;\n\t\t\tif (cnum[g] <= 2) continue;\n\t\t\tif (cnum[h] <= 2) continue;\n\n\t\t\tint bairitu = kazu[inum] + 1;\n\t\t\tint jnum = lower_bound(C, C + N, C[j]) - C;\n\t\t\tbairitu *= kazu[jnum]--;\n\n\t\t\trep(x, 4) {\n\t\t\t\tTP D[4];\n\t\t\t\tD[0] = narabi(a, d, f, e);\n\t\t\t\tD[1] = narabi(a, e, h, b);\n\t\t\t\tD[2] = narabi(b, h, g, c);\n\t\t\t\tD[3] = narabi(c, g, f, d);\n\t\t\t\tTP* itr[4];\n\t\t\t\trep(k, 4) itr[k] = lower_bound(C, C + N, D[k]);\n\t\t\t\tll kari = bairitu;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (itr[k] != C + N && *(itr[k]) == D[k]) {\n\t\t\t\t\t\tkari *= kazu[itr[k] - C]--;\n\t\t\t\t\t\tif (get<0>(D[k]) == get<2>(D[k]) && get<1>(D[k]) == get<3>(D[k])) {\n\t\t\t\t\t\t\tkari *= 2;\n\t\t\t\t\t\t\tif (get<1>(D[k]) == get<2>(D[k])) kari *= 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tkari = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tif (itr[k] != C + N && *itr[k] == D[k]) {\n\t\t\t\t\t\tkazu[itr[k] - C]++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tkotae += kari;\n\n\t\t\t\tint tmp = e;\n\t\t\t\te = f;\n\t\t\t\tf = g;\n\t\t\t\tg = h;\n\t\t\t\th = tmp;\n\t\t\t}\n\t\t\tj += kazu[jnum]++;\n\t\t}\n\t\ti += kazu[inum]++;\n\t}\n\tco(kotae / 6);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\n\nlint gethash(const std::vector<int>& f) {\n    lint ret = 0;\n    for (auto x : f) ret = ret * 1000 + x;\n    return ret;\n}\n\nint getidx(lint x, int i) {\n    i = 3 - i;\n    while (i--) x /= 1000;\n    return x % 1000;\n}\n\nstd::vector<std::vector<int>> idxs{\n    {3, 2, 1, 0},\n    {2, 1, 2, 1},\n    {1, 0, 3, 2},\n    {0, 3, 0, 3},\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<lint>> fss(n);\n    {\n        std::vector<int> f(4);\n        for (auto& fs : fss) {\n            for (auto& x : f) std::cin >> x;\n\n            for (int r = 0; r < 4; ++r) {\n                fs.push_back(gethash(f));\n                std::rotate(f.begin(), f.begin() + 1, f.end());\n            }\n        }\n    }\n\n    lint ans = 0;\n    std::vector<lint> cs(4);\n    std::vector<lint> dp(1 << 4), ndp(1 << 4);\n\n    for (int i = 0; i < n; ++i) {\n        // top face (fixed)\n        const auto& tf = fss[i][0];\n\n        for (int j = 0; j < i; ++j) {\n            // bottom face\n            for (const auto& bf : fss[j]) {\n                for (int xi = 0; xi < 4; ++xi) {\n                    auto& c = cs[xi];\n                    c = 0;\n                    for (int yi = 0; yi < 4; ++yi) {\n                        int x = getidx(yi < 2 ? tf : bf, idxs[xi][yi]);\n                        c = c * 1000 + x;\n                    }\n                }\n\n                std::fill(dp.begin(), dp.end(), 0);\n                dp[0] = 1;\n\n                for (int k = 0; k < i; ++k) {\n                    if (k == j) continue;\n                    ndp = dp;\n\n                    std::vector<lint> pats(4);\n                    for (const auto& f : fss[k]) {\n                        for (int l = 0; l < 4; ++l) {\n                            if (cs[l] == f) ++pats[l];\n                        }\n                    }\n\n                    for (int l = 0; l < 4; ++l) {\n                        for (int b = 0; b < (1 << 4); ++b) {\n                            if ((b >> l) & 1) continue;\n                            ndp[b | (1 << l)] += dp[b] * pats[l];\n                        }\n                    }\n\n                    std::swap(dp, ndp);\n                }\n\n                ans += dp.back();\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits\\stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nint color[408][4];\nll has(int a[])\n{\n\tll res=0;\n\tfor(int i=N-1;i>=0;i--) res=res*1000+a[i];\n\treturn res;\n}\nvector<ll> _rotate(int c[])\n{\n\tvector<ll> res;\n//\tfor(int i=0;i<N;i++) cout<<c[i]<<\"   \";\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tint a[4];\n\t\tfor(int j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nint same(ll x,ll y)\n{\n\tint a[N],c[N];int sum=0;\n\tfor(int i=0;i<N;i++) a[i]=x%1000,x/=1000;\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tfor(int j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(int x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(int i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(int c1[],int c2[])\n{\n//\tfor(int i=0;i<N;i++) cout<<c1[i]<<\" \";cout<<\"\\n\";\n//\tfor(int i=0;i<N;i++) cout<<c2[i]<<\" \";cout<<\"\\n\";system(\"pause\");\n\tll p=has(c1);\n\tint a[4];ll ck[4];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(int j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t\tif(m[ck[i]]<=0) return 0;\n\t\tcnt*=m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint bel[]={0,3,2,1};\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<N;j++) cin>>color[i][j];\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint a[N],b[N];for(int k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<N;l++)\n\t\t\t\t\ta[l]=color[j][bel[(l+k)%N]];\n\t\t\t\tans+=operate(a,b);\n\t\t\t}\n\t\t}ins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint num[4][4]={{2, 5, 4, 3}, {0, 7, 6, 1}, {1, 6, 5, 2}, {3, 4, 7, 0}};\nunordered_map<ll, ll> mp, mp2;\nll ans;\nll c2[8];\nvoid dfs(int i){\n\tif(i==4){\n\t\tll ans1=1;\n\t\tfor(auto p:mp2){\n\t\t\tll x=mp[p.first];\n\t\t\tfor(ll l=0; l<p.second; l++) ans1*=(x-l);\n\t\t}\n\t\tans+=ans1;\n\t\treturn;\n\t}\n\tfor(int j=0; j<4; j++){\n\t\tll p=1, c=0;\n\t\tfor(int k=0; k<4; k++){\n\t\t\tc+=c2[num[i][(j+k)%4]]*p;\n\t\t\tp*=1000;\n\t\t}\n\t\tif(mp.find(c)==mp.end()) continue;\n\t\tmp2[c]++;\n\t\tdfs(i+1);\n\t\tmp2[c]--;\n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tvector<ll> c;\n\tfor(int i=0; i<n; i++){\n\t\tll c1[4], cp[4];\n\t\tfor(int j=0; j<4; j++) cin>>c1[j];\n\t\tfor(int j=0; j<4; j++){\n\t\t\tll p=1; cp[j]=0;\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tcp[j]+=(c1[(j+k)%4]*p);\n\t\t\t\tp*=1000;\n\t\t\t}\n\t\t}\n\t\tsort(cp, cp+4);\n\t\tmp[cp[0]]++;\n\t}\n\tfor(auto p:mp) c.push_back(p.first);\n\tfor(int i=0; i<c.size(); i++){\n\t\tll c1=c[i];\n\t\tfor(int j=0; j<4; j++){\n\t\t\tc2[j]=c1%1000;\n\t\t\tc1/=1000;\n\t\t}\n\t\tfor(int j=0; j<c.size(); j++){\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tll c3=c[j];\n\t\t\t\tfor(int l=0; l<4; l++){\n\t\t\t\t\tc2[4+(k+l)%4]=c3%1000; c3/=1000;\n\t\t\t\t}\n\t\t\t\tmp2.clear(); mp2[c[i]]++; mp2[c[j]]++;\n\t\t\t\tdfs(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n, c[666][4], z;\nll F(ll a, ll b, ll c, ll d) {\n\treturn a << 30 | b << 20 | c << 10 | d;\n}\nmap<ll, ll> g;\nvoid A(ll x, ll v) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tg[x] += v;\n\t\tx = (x >> 10) | (x & 1023) << 30;\n\t}\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tA(F(c[i][0], c[i][1], c[i][2], c[i][3]), 1);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tA(F(c[i][0], c[i][1], c[i][2], c[i][3]), -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tA(F(c[j][0], c[j][1], c[j][2], c[j][3]), -1);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tll r = 1;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tll u = F(c[j][(k - l + 1) & 3], c[j][(k - l) & 3], c[i][(l + 1) & 3], c[i][l & 3]);\n\t\t\t\t\tr *= g[u];\n\t\t\t\t\tA(u, -1);\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tll u = F(c[j][(k - l + 1) & 3], c[j][(k - l) & 3], c[i][(l + 1) & 3], c[i][l & 3]);\n\t\t\t\t\tA(u, 1);\n\t\t\t\t}\n\t\t\t\tz += r;\n\t\t\t}\n\t\t\tA(F(c[j][0], c[j][1], c[j][2], c[j][3]), 1);\n\t\t}\n\t}\n\tcout << z << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch((i+4)%4) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nvoid write(const C&c) {\n    cout << c.x.x << ' ' << c.x.y << ' ' << c.y.x << ' ' << c.y.y;\n}\n\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    map<C, int> P;\n    map<C, int> R;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        R[x] = rot(x);\n        Q.push_back(x);\n\n        //write(x); cout << endl;\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            for (int k = 0; k < 4; k++) {\n                C u[4];\n                ll cur = 1;\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l),get(q,k-l-1)}});\n                    int opts = P[u[l]];\n                    //if (i == 2 && j == 5) { write(u[l]); cout << '=' << opts << endl; } \n                    if (u[l] == p) --opts;\n                    if (u[l] == q) --opts;\n                    for (int m = 0; m < l; m++) if (u[l] == u[m]) --opts;\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*R[u[l]];\n                    }\n                }\n                //if (cur != 0) {\n                //    cout << i << ' ' << j << endl;\n                //}\n                ans += cur;\n            }\n        }\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nvi normarize(const vi &v)\n{\n    vector<vi> r(4);\n    rep(i,4)\n    {\n        vi t(4);\n        rep(j,4) t[j]=v[(i+j)%4];\n        r[i]=t;\n    }\n    sort(all(r));\n    return r[0];\n}\n\ninline ll P(int n, int r)\n{\n    if(n<r) return 0;\n\n    ll ret=1;\n    rep(i,r) ret*=n-i;\n    return ret;\n}\n\ninline ll POW(int x, int n)\n{\n    ll ret=1;\n    rep(i,n) ret*=x;\n    return ret;\n}\n\ninline ll DIM(const vi &v)\n{\n    if(v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) return 4;\n    else if(v[0]==v[2] && v[1]==v[3]) return 2;\n    return 1;\n}\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<vi> c(n,vi(4));\n    rep(i,n)rep(j,4) scanf(\" %d\", &c[i][j]);\n\n    map<vi,int> ct;\n    rep(i,n)\n    {\n        c[i]=normarize(c[i]);\n        if(ct.find(c[i])==ct.end()) ct[c[i]]=1;\n        else ++ct[c[i]];\n    }\n\n    ll ans=0;\n    // 上面i, 下面j\n    rep(i,n)rep(j,i)\n    {\n        // 下面の向きを設定\n        rep(k,4)\n        {\n            vi u(4);\n            rep(x,4) u[x]=c[j][(k+x)%4];\n            swap(u[1],u[3]);\n\n            vector<vi> sides(4);\n            rep(x,4)\n            {\n                vi t(4);\n                t[0]=c[i][(x+1)%4];\n                t[1]=c[i][x];\n                t[2]=u[x];\n                t[3]=u[(x+1)%4];\n                sides[x]=normarize(t);\n            }\n            sort(all(sides));\n\n            ll add=1;\n            int idx=0, st=0;\n            while(1)\n            {\n                while(idx<4 && sides[st]==sides[idx]) ++idx;\n                vi key=sides[st];\n                int value=idx-st;\n\n                // 使ってないタイルのうち当てはめられる個数\n                int num=ct[key];\n                if(c[i]==key) --num;\n                if(c[j]==key) --num;\n\n                // 選び方、向き、位置\n                add*=P(num,value)*POW(DIM(key),value);\n\n                if(idx==4) break;\n                st=idx;\n            }\n            ans+=add;\n        }\n    }\n\n    // 向かい合う面の個数ぶん重複する\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back()\n#define ppf pop_front()\n#define all(vec) vec.begin(), vec.end()\n#define fol(i,a,b) for(int i=a;i<b;i++)\n#define loop(i,a,b) for(int i=a;i>=b;i--)\n#define forr(x,arr) for(auto& x:arr)\n#define mod 1000000007\n#define INF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-7\n#define sz(x) ((lli)(x).size())\n\nusing   lli     =   long long;\nusing   lld     =   long double;\nusing   ulli    =   unsigned long long int;\nusing   pll     =   pair<lli, lli>;\nusing   ttt     =   pair<lli, pll>;\nusing   vttt    =   vector<ttt>;\nusing   vll     =   vector<pll>;\nusing   vl      =   vector<lli>;\nusing   vi      =   vector<int>;\nusing   vvi     =   vector<vector<int>>;\nusing   cd      =   complex<lld>;\nconst double PI = acos(-1);\n\n#ifdef tejasp\n#include \"library/debugger.cpp\"\n#else\n#define trace(...) {}\n#define cotra(...) {}\n#define end_routine() {}\n#define localsys 0\n#define endl '\\n'\n#endif\n\n#define ca cord.first.first\n#define cb cord.first.second\n#define cc cord.second.first\n#define cd cord.second.second\n\nstruct node\n{\n    pair<pll,pll> cord;\n    node() = default;\n    node(int a, int b, int c, int d): cord({{a,b},{c,d}}) {};\n    bool operator== (node &other) { return cord==other.cord; }\n    void operator= (const node &other) { cord=other.cord; }\n};\n\nbool operator< (const node &l, const node &r) { return l.cord<r.cord; }\nbool operator> (const node &l, const node &r) { return l.cord>r.cord; }\n\nnode arr[410];\nlli ans=0;\nmap<node,lli> mp;\n\nvoid rotate(node &cur)\n{\n    lli temp=cur.ca;\n    cur.ca=cur.cb;\n    cur.cb=cur.cc;\n    cur.cc=cur.cd;\n    cur.cd=temp;\n}\n\nint calc(node &a, node &b)\n{\n    int ans=0;\n    fol(i,0,4)\n    {\n        if(a==b) ans++;\n        rotate(b);\n    }\n    return ans;\n}\n\nnode reverse(node n)\n{\n    swap(n.cb,n.cd);\n    return n;\n}\n\nvoid upd(node &l1, node &r1)\n{\n    node lef=reverse(l1), rig=r1;\n    node uu(lef.ca,lef.cb,rig.cb,rig.ca);\n    node dd(lef.cb,lef.cc,rig.cc,rig.cb);\n    node ll(lef.cc,lef.cd,rig.cd,rig.cc);\n    node rr(lef.cd,lef.ca,rig.ca,rig.cd);\n    lli res1=mp[uu];\n    lli res2=mp[dd];\n    lli res3=mp[ll];\n    lli res4=mp[rr];\n    res1-=calc(uu,l1)+calc(uu,r1);\n    res2-=calc(dd,l1)+calc(dd,r1)+calc(dd,uu);\n    res3-=calc(ll,l1)+calc(ll,r1)+calc(ll,uu)+calc(ll,dd);\n    res4-=calc(rr,l1)+calc(rr,r1)+calc(rr,uu)+calc(rr,dd)+calc(rr,ll);\n    ans+=(res1*res2*res3*res4);\n}\n\nint tejas_919(int kkkk)\n{\n    lli n, m, k, q, u, v, temp=0;\n    cin>>n;\n    fol(i,0,n)\n    {\n        cin>>m>>k>>u>>v;\n        arr[i]=node(m,k,u,v);\n        fol(j,0,4)\n        {\n            mp[arr[i]]++;\n            rotate(arr[i]);\n        }\n    }\n    fol(i,0,n)\n    {\n        fol(j,i+1,n)\n        {\n            fol(k,0,4)\n            {\n                upd(arr[i],arr[j]);\n                rotate(arr[j]);\n            }\n        }\n    }\n    ans/=3;\n    cout<<ans<<endl;\n    return 0;\n}\n\nsigned main()\n{\n    #ifdef tejasp\n            freopen(\"input.txt\", \"rt\", stdin);\n            freopen(\"output.txt\", \"wt\", stdout);\n    #endif\n    if(!localsys) { ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); }\n    cout << fixed << setprecision(10);\n    int t=1;\n    //cin>>t;\n    fol(i,0,t) { tejas_919(i+1); }\n    end_routine();\n    if(localsys) system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nconst int N=405;\nstruct data{\n\tint a[4];\n\tdata nxt(){\n\t\treturn (data){a[1],a[2],a[3],a[0]};\n\t}\n\tbool operator == (const data &b) const{\n\t\tfor(int i=0;i<4;i++){\n \t\t\tif(a[i]!=b.a[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}a[N];\nnamespace std{\n\ttemplate <>\n\tstruct hash <data>{\n\t\thash<ll> h;\n\t\tsize_t operator () (data n) const{\n\t\t\tll res=0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tres=res*2333+n.a[i];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n}\nunordered_map<data,int> mp;\nint n;\nll ans;\nvoid insert(data x,int v){\n\tfor(int i=0;i<4;i++,x=x.nxt()){\n\t\tmp[x]+=v;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&a[i].a[0],&a[i].a[1],&a[i].a[2],&a[i].a[3]);\n\t\tinsert(a[i],1);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tinsert(a[i],-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tinsert(a[j],-1);\n\t\t\tfor(int k=0;k<4;k++,a[j]=a[j].nxt()){\n\t\t\t\tdata t1=(data){a[i].a[1],a[i].a[0],a[j].a[0],a[j].a[3]};\n\t\t\t\tdata t2=(data){a[i].a[2],a[i].a[1],a[j].a[3],a[j].a[2]};\n\t\t\t\tdata t3=(data){a[i].a[3],a[i].a[2],a[j].a[2],a[j].a[1]};\n\t\t\t\tdata t4=(data){a[i].a[0],a[i].a[3],a[j].a[1],a[j].a[0]};\n\t\t\t\tif(!mp[t1]||!mp[t2]||!mp[t3]||!mp[t4]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tll res=1;\n\t\t\t\tres*=mp[t1];\n\t\t\t\tinsert(t1,-1);\n\t\t\t\tres*=mp[t2];\n\t\t\t\tinsert(t2,-1);\n\t\t\t\tres*=mp[t3];\n\t\t\t\tinsert(t3,-1);\n\t\t\t\tres*=mp[t4];\n\t\t\t\tinsert(t3,1);\n\t\t\t\tinsert(t2,1);\n\t\t\t\tinsert(t1,1);\n\t\t\t\tans+=res;\n\t\t\t}\n\t\t\tinsert(a[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N];\n\nTILE ROT[MAX_N*4];\n\nint main(){\n\tcin>>N;\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tT[i]=TILE(a,b,c,d,i);\n\t\tREP(j,4){\n\t\t\tROT[i*4+j]=rotate(T[i],j);\n\t\t}\n\t}\n\tsort(ROT,ROT+N*4);\n\tll ans=0;\n\tTILE TI[3];\n\tREP(i,N){\n\t\tTI[0]=T[i];\n\t\tREP(j,N*4){\n\t\t\tif (TI[0].index==ROT[j].index) continue;\n\t\t\tif (ROT[j].c[3]==TI[0].c[0] && ROT[j].c[2]==TI[0].c[1]){\n\t\t\t\tTI[1]=ROT[j];\n\t\t\t\tREP(k,N*4){\n\t\t\t\t\tif (TI[0].index==ROT[k].index || TI[1].index==ROT[k].index) continue;\n\t\t\t\t\tif (ROT[k].c[0]==TI[0].c[3] && ROT[k].c[1]==TI[0].c[2]){\n\t\t\t\t\t\tTI[2]=ROT[k];\n\t\t\t\t\t\tint a,b,c;\n\t\t\t\t\t\ta=b=c=0;\n\t\t\t\t\t\tTILE t1,t2,t3;\n\t\t\t\t\t\tt1=TILE(TI[0].c[0],TI[0].c[3],TI[2].c[3],TI[1].c[0],0);\n\t\t\t\t\t\ta=upper_bound(ROT,ROT+N*4,t1)-lower_bound(ROT,ROT+N*4,t1);\n\t\t\t\t\t\tREP(s,3){\n\t\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\t\tif (t1==rotate(TI[s],u)){\n\t\t\t\t\t\t\t\t\ta--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt2=TILE(TI[1].c[1],TI[1].c[0],TI[2].c[3],TI[2].c[2],0);\n\t\t\t\t\t\tb=upper_bound(ROT,ROT+N*4,t2)-lower_bound(ROT,ROT+N*4,t2);\n\t\t\t\t\t\tREP(s,3){\n\t\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\t\tif (t2==rotate(TI[s],u)){\n\t\t\t\t\t\t\t\t\tb--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt3=TILE(TI[0].c[2],TI[0].c[1],TI[1].c[1],TI[2].c[2],0);\n\t\t\t\t\t\tc=upper_bound(ROT,ROT+N*4,t3)-lower_bound(ROT,ROT+N*4,t3);\n\t\t\t\t\t\tREP(s,3){\n\t\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\t\tif (t3==rotate(TI[s],u)){\n\t\t\t\t\t\t\t\t\tc--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t    int cnt1,cnt2;\n\t\t\t\t\t    cnt1=cnt2=0;\n\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\tif (t1==rotate(t2,u)){\n\t\t\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\tif (t3==rotate(t2,u)){\n\t\t\t\t\t\t\t\tcnt2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt1 && cnt2){\n\t\t\t\t\t\t\tans+=a*b*c/6;\n\t\t\t\t\t\t}else if (cnt1){\n\t\t\t\t\t\t\tans+=a*(b-cnt1)*c;\n\t\t\t\t\t\t}else if (cnt2){\n\t\t\t\t\t\t\tans+=b*(c-cnt2)*a;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tans+=a*b*c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst int INF=5e8;\n\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\nint col[405][4];\nint n;\n\nint need[4][4];\n\nint match[405][4];\n\ntypedef vector<int> vi;\nvi getmini(vi c){\n  vector<int> mini(4,INF);\n  REP(k,4){\n    vector<int> tmp=c;\n    rotate(tmp.begin(),tmp.begin()+k,tmp.end());\n    chmin(mini,tmp);\n  }\n  return mini;\n}\nInt dp[405][16];\nint coef[405];\nint main(){\n  cin>>n;\n  REP(i,n){\n    vector<int> c(4),mini;\n    REP(j,4) cin>>c[j];\n    mini=getmini(c);\n\n    REP(j,4) col[i][j]=mini[j];\n    if(mini[0]==mini[1] && mini[1]==mini[2] && mini[2]==mini[3]) coef[i]=4;\n    else if(mini[0]==mini[2] && mini[1]==mini[3]) coef[i]=2;\n    else coef[i]=1;\n  }\n\n\n\n  Int res=0;\n  REP(i,n) REP(j,i) REP(d,4){\n    int back[4];\n    REP(k,4) back[k]=col[j][3-k];\n    rotate(back,back+d,back+4);\n\n    REP(k,4){\n      vi tmp(4),mini;\n      tmp[0]=back[k];\n      tmp[1]=back[(k+1)%4];\n      tmp[2]=col[i][(1+k)%4];\n      tmp[3]=col[i][k];\n      mini=getmini(tmp);\n      REP(l,4) need[k][l]=mini[l];\n    }\n    CLR(match);\n    REP(k,i) if(k!=j){\n      REP(d2,4){\n        bool fail=false;\n        REP(l,4) if(need[d2][l]!=col[k][l]) fail=true;\n        if(!fail){\n          match[k][d2]=coef[k];\n        }\n      }\n    }\n    CLR(dp);\n    dp[0][0]=1;\n    REP(k,i) REP(bit,16) if(dp[k][bit].x){\n      Int val=dp[k][bit];\n      dp[k+1][bit]+=val;\n      REP(l,4) if(!(bit>>l&1) && match[k][l]) dp[k+1][bit|(1<<l)]+=val*match[k][l];\n    }\n    res+=dp[i][15];\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#include<map>\n#define maxn 400\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nstruct P{\n    int a1,a2,a3,a4;\n}c[maxn];\nmap<P,int>ma;\nll ans;\nbool operator < (P x,P y)\n{\n    if(x.a1!=y.a1)  return x.a1<y.a1;\n    if(x.a2!=y.a2)  return x.a2<y.a2;\n    if(x.a3!=y.a3)  return x.a3<y.a3;\n    return x.a4<y.a4;\n}\nint check(P x,P y)\n{\n    int res=0;\n    if(x.a1==y.a1&&x.a2==y.a2&&x.a3==y.a3&&x.a4==y.a4)  res++;\n    if(x.a1==y.a2&&x.a2==y.a3&&x.a3==y.a4&&x.a4==y.a1)  res++;\n    if(x.a1==y.a3&&x.a2==y.a4&&x.a3==y.a1&&x.a4==y.a2)  res++;\n    if(x.a1==y.a4&&x.a2==y.a1&&x.a3==y.a2&&x.a4==y.a3)  res++;    \n    return res;\n}\nvoid solve(P x,P y)\n{\n    P s1=(P){y.a1,y.a2,x.a2,x.a1};\n    P s2=(P){y.a3,y.a4,x.a4,x.a3};\n    P s3=(P){y.a2,y.a3,x.a3,x.a2};\n    P s4=(P){y.a4,y.a1,x.a1,x.a4};\n    int res1=ma[s1]-check(s1,x)-check(s1,y);\n    int res2=ma[s2]-check(s2,x)-check(s2,y)-check(s2,s1);\n    int res3=ma[s3]-check(s3,x)-check(s3,y)-check(s3,s2)-check(s3,s1);\n    int res4=ma[s4]-check(s4,x)-check(s4,y)-check(s4,s3)-check(s4,s2)-check(s4,s1);\n    ans+=1ll*res1*res2*res3*res4;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  c[i].a1=read(),c[i].a2=read(),c[i].a3=read(),c[i].a4=read();\n    for(int i=1;i<=n;i++)\n    {\n        ma[(P){c[i].a1,c[i].a2,c[i].a3,c[i].a4}]++;\n        ma[(P){c[i].a2,c[i].a3,c[i].a4,c[i].a1}]++;\n        ma[(P){c[i].a3,c[i].a4,c[i].a1,c[i].a2}]++;\n        ma[(P){c[i].a4,c[i].a1,c[i].a2,c[i].a3}]++;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i+1;j<=n;j++)\n        {\n            solve(c[i],(P){c[j].a2,c[j].a1,c[j].a4,c[j].a3});\n            solve(c[i],(P){c[j].a1,c[j].a4,c[j].a3,c[j].a2});\n            solve(c[i],(P){c[j].a4,c[j].a3,c[j].a2,c[j].a1});\n            solve(c[i],(P){c[j].a3,c[j].a2,c[j].a1,c[j].a4});\n        }\n    }\n    cout<<ans/3<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iterator>\n#include <map>\n#include <functional>\n#include <array>\n#include <vector>\nnamespace XX\n{   \n    template<template<typename> class Compare, typename T>\n    inline T& UP(T& x, const T& y){if(Compare<T>()(y, x)) x = y; return x;}\n    template<typename Compare, typename T>\n    inline T& UP(T& x, const T& y, Compare comp){if(comp(y, x)) x = y; return x;}\n\n    template<typename T> inline T& GT(T& x, const T& y){return UP<std::greater>(x, y);}\n    template<typename T> inline T& LS(T& x, const T& y){return UP<std::less>(x, y);}\n\n    template<typename T>\n    struct Mapper\n    {\n        int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }\n        template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }\n        T rev(int idx){return rtable[idx + 1];}\n        std::map<T, int> table;\n        std::map<int, T> rtable;\n    };\n\n    template<typename T, int S>\n    struct ReferenceArray\n    {\n        struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };\n        int size()const{return _ptr.size();}\n        It begin()const{return {_ptr.begin()};}\n        It end()const{return {_ptr.end()};}\n        T& operator[](int idx)const{return *_ptr[idx];}\n        mutable std::array<T*, S> _ptr;\n    };\n    template<typename T, typename... Args> \n    ReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}\n\n    struct Range\n    {   \n        struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n        Range(int ee):b(0),e(ee){}\n        Range(int bb, int ee):b(bb), e(ee){}\n        It begin(){return {b, (b < e? 1: -1)};}\n        It end(){return {e, 0};}\n        int b, e;\n    };\n\n}\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), std::printf(ScanfSpecifier<Args>::value, args), 0)...}; }\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n\n\n\n\n//alias\ntemplate<typename T> T& UMAX(T& x, T y){return XX::UP<std::greater>(x, y);}\ntemplate<typename T> T& UMIN(T& x, T y){return XX::UP<std::less>(x, y);}\nusing XX::UP; //(x,y) comp\nusing RG = XX::Range;\nusing XX::MAKEV;\nusing XX::Mapper;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef array<int, 4> C;\nC cs[512];\n\nmap<C, int> table;\n\n\n\nvoid f(C& c)\n{\n    C mn = c;\n\n    for(int i = 0; i < 4; i++)\n    {\n        int tmp = c[0];\n        for(int j = 1; j < 4; j++)\n            c[j - 1] = c[j];\n        c[3] = tmp;\n\n        if(c < mn)\n            mn = c;\n    }\n    c = mn;\n}\n\nint kind(C c)\n{\n    C o = c;\n    int ret = 0;\n    for(int i = 0; i < 4; i++)\n    {\n        int tmp = c[0];\n        for(int j = 1; j < 4; j++)\n            c[j - 1] = c[j];\n        c[3] = tmp;\n\n        if(c == o)\n            ret++;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int N;\n    RD(N);\n    for(int i = 0; i < N; i++)\n    {\n        RDV(cs[i].begin(), cs[i].end());\n        f(cs[i]);\n    }\n\n\n    long long int ans = 0;\n    for(int i = 0; i < N; i++)\n    {\n        if(i >= 5)\n            for(int j = 0; j < i; j++)\n                for(int d = 0; d < 4; d++)\n                {\n                    map<C, int> cnt;\n                    C b;\n                    for(int k = 0; k < 4; k++)\n                        b[k] = cs[j][(3 - k + d) & 3];\n\n                    long long alc = 1;\n\n                    for(int k = 0; k < 4; k++)\n                    {\n                        C s;\n\n                        s[0] = cs[i][(k + 1) & 3];\n                        s[1] = cs[i][k];\n                        s[2] = b[k];\n                        s[3] = b[(k + 1) & 3];\n\n                        alc *= kind(s);\n                        f(s);\n                        cnt[s]++;\n                    }\n                    for(auto e: cnt)\n                    {\n                        int v1 = table[e.first] - (e.first == cs[j]);\n                        int v2 = e.second;\n\n\n                        for(int i = 0; i < v2; i++)\n                            alc *= (v1 - i);\n                    }\n\n                    ans += alc;\n\n                }\n\n        table[cs[i]]++;\n    }\n\n\n    WTL(ans);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef unsigned long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nmap<vector<int>,int> me;\nvector<int> c[514];\nlint co[514][514];\nint cal(vector<int> a){\n\tif(a[0]==a[1] && a[1]==a[2] && a[2]==a[3]) return 4;\n\tif(a[0]==a[2] && a[1]==a[3]) return 2;return 1;\n}\nvector<int> ca2(vector<int> v){\n\tvector<int> ret=v;\n\trep(j,4){\n\t\tint d=v[0];v[0]=v[1];v[1]=v[2];v[2]=v[3];v[3]=d;\n\t\tret=min(ret,v);\n\t}\n\treturn ret;\n}\nlint zyo(lint a,int b){\n\tlint ret=1;\n\trep(i,b) ret*=a;return ret;\n}\nint main()\n{\n\trep(i,510){\n\t\tco[i][0]=1;\n\t\trep(j,8) co[i][j+1]=co[i][j]*(i-j);\n\t}\n\tint n;lint out=0;\n\tcin>>n;\n\trep(i,n){\n\t\tvector<int> v(4,0);\n\t\trep(j,4) cin>>v[j];c[i]=ca2(v);\n\t\trep(j,4){\n\t\t\tint d=v[0];v[0]=v[1];v[1]=v[2];v[2]=v[3];v[3]=d;\n\t\t\tc[i]=min(c[i],v);\n\t\t}\n\t\tme[c[i]]++;\n\t}\n\t//rep(i,n){rep(j,4) cout<<c[i][j]<<' ';cout<<endl;}\n\trep(i,n) REP(j,i+1,n){\n\t\tme[c[i]]--;me[c[j]]--;\n\t\tvector<int> a=c[i],b=c[j];swap(b[0],b[2]);\n\t\trep(k,4){\n\t\t\tmap<vector<int>,int> m;\n\t\t\trep(l,4){\n\t\t\t\t//m[vector<int>{a[l],a[(l+3)%4,b[(l+3)%4],b[l]]}]++;\n\t\t\t\tvector<int> v;v.pb(a[l]);v.pb(a[(l+3)%4]);v.pb(b[(l+3)%4]);v.pb(b[l]);\n\t\t\t\tm[ca2(v)]++;\n\t\t\t}\n\t\t\tlint t=1;\n\t\t\tmap<vector<int>,int>::iterator it=m.begin();\n\t\t\twhile(it!=m.end()){\n\t\t\t\tif(i==0 && j==4){\n\t\t\t\t\t//rep(l,4) cout<<(*it).fi[l]<<' ';cout<<endl;\n\t\t\t\t}\n\t\t\t\tt*=co[me[(*it).fi]][(*it).se];\n\t\t\t\t//cout<<me[(*it).fi]<<endl;\n\t\t\t\tt*=zyo(cal((*it).fi),(*it).se);\n\t\t\t\tit++;\n\t\t\t}\n\t\t\t//cout<<t<<endl;\n\t\t\tout+=t;\n\t\t\tint d=b[0];b[0]=b[1];b[1]=b[2];b[2]=b[3];b[3]=d;\n\t\t}\n\t\tme[c[i]]++;me[c[j]]++;\n\t}\n\tout/=3;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nstruct kek{\n    short v[4];\n}a[404];\nbool operator<(const kek&x,const kek&y){\n    forn(i,4){\n        if(x.v[i]<y.v[i])return 1;\n        if(x.v[i]>y.v[i])return 0;\n    }\n    return 0;\n}\nbool operator==(const kek&x,const kek&y){\n    forn(i,4){\n        if(x.v[i]!=y.v[i])return 0;\n    }\n    return 1;\n}\nint32_t main(){\n    int n;\n    cin>>n;\n    map<kek,int> cnt;\n    forn(i,n){\n        forn(j,4)cin>>a[i].v[j];\n        kek mn;\n        forn(q,4)mn.v[q]=a[i].v[q];\n        forn(it,4){\n            if(a[i]<mn)forn(q,4)mn.v[q]=a[i].v[q];\n            rotate(a[i].v,a[i].v+1,a[i].v+4);\n        }\n        forn(it,4){\n            if(mn==a[i])cnt[mn]++;\n            rotate(a[i].v,a[i].v+1,a[i].v+4);\n        }\n        forn(q,4)a[i].v[q]=mn.v[q];        \n    }\n    int ans=0;\n    const int fac[5]={1,1,2,6,24};\n    const int pwr[5]={1,1,4,27,256};\n    forn(i,n){\n        forn(j,n){\n            if(i==j)continue;\n            short dal[4];\n            forn(x,4)dal[x]=a[j].v[x];\n            forn(it,4){\n                int cur=1;\n                map<kek,int> govno;\n                forn(side,4){\n                    kek need;\n                    need.v[0]=a[i].v[side];\n                    need.v[1]=dal[(4-side)&3];\n                    need.v[2]=dal[(4-((side+1)&3))&3];\n                    need.v[3]=a[i].v[(side+1)&3];\n                    kek mn;\n                    forn(q,4)mn.v[q]=need.v[q];\n                    forn(tmp,4){\n                        if(need<mn)forn(q,4)mn.v[q]=need.v[q];\n                        rotate(need.v,need.v+1,need.v+4);\n                    }\n                    int val=cnt[mn];\n                    forn(tmp,4){\n                        val-=a[i]==mn;\n                        val-=a[j]==mn;\n                        rotate(mn.v,mn.v+1,mn.v+4);\n                    }\n                    govno[mn]++;\n                    cur*=val;\n                }\n                // if(i==0&&j==1)dbg(cur);\n                for(auto&p:govno){\n                    cur/=pwr[p.s];\n                    cur*=fac[p.s];\n                // if(i==0&&j==1)dbg(p.s);\n                }\n                // if(i==0&&j==1)dbg(cur);\n                ans+=cur;\n                rotate(dal,dal+1,dal+4);\n            }\n        }\n    }\n    cout<<ans/6<<'\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tint n; cin >> n;\n    vector<vector<int>> c(n, vector<int>(4));\n    map<vector<int>, int> mp;\n    rep(i, n) {\n        rep(j, 4) {\n            cin >> c[i][j];\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] --;\n        }\n        rep(j, n) {\n            if(i == j) continue;\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] --;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                int res = 1;\n                vector<vector<int>> X;\n                rep(l, 4) {\n                    vector<int> x = {c[i][l], c[i][(l + 1) % 4], d[(l + 1) % 4], d[l]};\n                    if(mp[x] != 0) {\n                        res *= mp[x];\n                        X.push_back(x);\n                        rep(m, 4) {\n                            vector<int> e(4);\n                            rep(o, 4) {\n                                e[o] = x[(o + m) % 4];\n                            }\n                            mp[e] --;\n                        }\n                    } else {\n                        res = 0;\n                    }\n                }\n                for(auto x: X) {\n                    rep(m, 4) {\n                        vector<int> e(4);\n                        rep(o, 4) {\n                            e[o] = x[(o + m) % 4];\n                        }\n                        mp[e] ++;\n                    }\n                }\n                if(res) cerr << i << \" \" << j << \" \" << res << endl;\n                ans += res;\n            }\n            //\n            rep(k, 4) {\n                vector<int> d(4);\n                rep(l, 4) {\n                    d[l] = c[j][(l + k) % 4];\n                }\n                mp[d] ++;\n            }\n        }\n        rep(k, 4) {\n            vector<int> d(4);\n            rep(l, 4) {\n                d[l] = c[i][(l + k) % 4];\n            }\n            mp[d] ++;\n        }\n    }\n    cout << ans / 6 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int mod=1e7+9;\nconst int MAX_H=1e5+5;\n\nint N, t, C[MAX][5];\nunordered_map<ll,pair<int,int> >::iterator it;\nunordered_map<ll,pair<int,int> > MP;\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    it=MP.find(H);\n    if(it!=MP.end())\n    {\n        it->s.s+=t;\n        return;\n    }\n    int re=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n    MP[H]=mp(re, t);\n}\n\ninline int Find(ll H)\n{\n    it=MP.find(H);\n    return it->s.f*it->s.s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nconst int N = 405;\nusing namespace std;\n\nmap <long long, int> mymap;\nint n;\nlong long a[N], ans;\n\nlong long po(int x){\n    if (x == 0) return 1;\n    if (x == 1) return 1000;\n    if (x == 2) return 1000000;\n    if (x == 3) return 1000000000;\n}\n\nlong long rotate(long long x){\n    long long t = x % po(1); x /= po(1);\n    x += t * po(3);\n    return x;\n}\n\nlong long get(long long a, int num){\n    return (a / po(num)) % 1000;\n}\n\nlong long reverse(long long x){\n    long long y = get(x, 0) * po(3) + get(x, 1) * po(2) + get(x, 2) * po(1) + get(x, 3) * po(0);\n    return y;\n}\n\nsigned main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        int x, y, z, t;\n        cin >> x >> y >> z >> t;\n        a[i] = 1LL * x * 1000000000 + 1LL * y * 1000000 + 1LL * z * 1000 + t;\n        mymap[a[i]]++;\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j < i; j++){\n            mymap[a[i]]--; mymap[a[j]]--;\n            long long x = reverse(a[j]);\n            for (int k = 0; k < 4; k++){\n                long long cnt = 0, mul = 1;\n                for (int h = 0; h < 4; h++){\n                    long long color = 0, cnt = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    for (int l = 0; l < 4; l++) cnt += mymap[color], color = rotate(color);\n                    mul *= cnt;\n                    mymap[color]--;\n                }\n                for (int h = 0; h < 4; h++){\n                    long long color = 0;\n                    color += get(x, (h+1) % 4);\n                    color *= 1000; color += get(x, h);\n                    color *= 1000; color += get(a[i], h);\n                    color *= 1000; color += get(a[i], (h+1) % 4);\n                    mymap[color]++;\n                }\n                ans += mul;\n                x = rotate(x);\n            }\n            mymap[a[i]]++; mymap[a[j]]++;\n        }\n    }\n    ans /= 3;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <map>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 410;\n\nstruct Col{ \n\tint c1, c2, c3, c4;\n\tbool operator < (const Col& S) const {\n\t\tif (c1 != S.c1) return c1 < S.c1;\n\t\tif (c2 != S.c2) return c2 < S.c2;\n\t\tif (c3 != S.c3) return c3 < S.c3;\n\t\treturn c4 < S.c4;\n\t}\n\tbool operator == (const Col& S) {\n\t\treturn c1 == S.c1 && c2 == S.c2 && c3 == S.c3 && c4 == S.c4;\t\n\t}\n\t\n} c[N];\nmap<Col, int> m;\n\nvoid add(Col x, int v)\n{\n\tRep(i, 4){\n\t\tm[x] += v;\n\t\tint tmp = x.c1;\n\t\tx.c1 = x.c2, x.c2 = x.c3, x.c3 = x.c4, x.c4 = tmp;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) {\n\t\tscanf(\"%d%d%d%d\", &c[i].c1, &c[i].c2, &c[i].c3, &c[i].c4);\n\t\tm[(Col){c[i].c1, c[i].c2, c[i].c3, c[i].c4}] ++;\n\t\tm[(Col){c[i].c2, c[i].c3, c[i].c4, c[i].c1}] ++;\n\t\tm[(Col){c[i].c3, c[i].c4, c[i].c1, c[i].c2}] ++;\n\t\tm[(Col){c[i].c4, c[i].c1, c[i].c2, c[i].c3}] ++;\n\t}\n\tLL ans = 0;\n\tRep(i, n) for (int j = i + 1; j <= n; j ++) {\n\t\tadd(c[i], -1); add(c[j], -1);\n\t\tCol tmp = (Col){c[j].c4, c[j].c3, c[j].c2, c[j].c1};\n\t\tRep(k, 4) {\n\t\t\tLL tans = 1;\n\t\t\tCol t1 = (Col){tmp.c1, tmp.c2, c[i].c2, c[i].c1};\n\t\t\ttans *= m[t1];\n\t\t\tif (m[t1]) add(t1, -1);\n\t\t\tCol t2 = (Col){tmp.c2, tmp.c3, c[i].c3, c[i].c2};\n\t\t\ttans *= m[t2];\n\t\t\tif (m[t2]) add(t2, -1);\n\t\t\tCol t3 = (Col){tmp.c3, tmp.c4, c[i].c4, c[i].c3};\n\t\t\ttans *= m[t3];\n\t\t\tif (m[t3]) add(t3, -1);\n\t\t\tCol t4 = (Col){tmp.c4, tmp.c1, c[i].c1, c[i].c4};\n\t\t\ttans *= m[t4];\n\t\t\tif (m[t1]) add(t1, 1);\n\t\t\tif (m[t2]) add(t2, 1);\n\t\t\tif (m[t3]) add(t3, 1);\n\t\t\t\n\t\t\tint ttmp = tmp.c1;\n\t\t\ttmp.c1 = tmp.c2, tmp.c2 = tmp.c3, tmp.c3 = tmp.c4, tmp.c4 = ttmp;\n\t\t\tans += tans;\n\t\t//\tprintf(\"%d %d %d %d %d\\n\", i, j, k, tans);\n\t\t}\n\t\tadd(c[i], 1); add(c[j], 1);\n\t}\n\t\n\tprintf(\"%lld\\n\", ans / 3);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    map<C, int> P;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}});\n                    int opts = P[u[l]];\n                    if (u[l] == p) --opts;\n                    if (u[l] == q) --opts;\n                    for (int m = 0; m < l; m++) {\n                        if (u[m] == u[l]) --opts;\n                    }\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*rot(u[l]);\n                    }\n                }\n                ans += cur;\n            }\n        }\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint nextInt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 400;\nint col[N][8];\nlong long hashes[N][4];\nlong long dp[16];\nint ways[4];\n\nlong long calcHash(int a, int b, int c, int d) {\n\tlong long h = 0;\n\th = 1000 * h + a;\n\th = 1000 * h + b;\n\th = 1000 * h + c;\n\th = 1000 * h + d;\n\treturn h;\n}\n\nint main() {\n\tint n = nextInt();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcol[i][j] = nextInt();\n\t\t\tcol[i][j + 4] = col[i][j];\n\t\t}\n\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\thashes[i][rot] = 1000 * hashes[i][rot] + col[i][(rot + j) % 4];\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int front = 0; front < n; front++) {\n\t\tint a = col[front][0];\n\t\tint b = col[front][1];\n\t\tint c = col[front][2];\n\t\tint d = col[front][3];\n\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\trotLoop:\n\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\tlong long h1 = calcHash(a, e, f, b);\n\t\t\t\tlong long h2 = calcHash(b, f, g, c);\n\t\t\t\tlong long h3 = calcHash(d, c, g, h);\n\t\t\t\tlong long h4 = calcHash(e, a, d, h);\n\t\t\t\tvector<long long> hs = {h1, h2, h3, h4};\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tdp[i] = 0;\n\t\t\t\t}\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tways[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\tif (hashes[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,a[405][4];\nmap<ll,int> cnt;\n\ninline pair<ll,int> make(int *a){\n\tll ans=1ll<<60;int cnt=0;\n\tfor(int i=0;i<4;i++){\n\t\tll res=0;\n\t\tfor(int j=0;j<4;j++)\n\t\t\tres=res*1000+a[(i+j)%4];\n\t\tif(res<ans) ans=res,cnt=1;\n\t\telse if(res==ans) cnt++;\n\t}\n\treturn mp(ans,cnt);\n}\ninline pair<ll,int> make(int a,int b,int c,int d){\n\tstatic int x[10];\n\tx[0]=a;x[1]=b;x[2]=c;x[3]=d;\n\treturn make(x);\n}\n\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tread(a[i][j]);\n\t\tcnt[make(a[i]).FF]++;\n//\t\tdebug(make(a[i]));\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[make(a[i]).FF]--;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tcnt[make(a[j]).FF]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tstatic ll b[10],res;\n\t\t\t\tres=1;\n\t\t\t\tfor(int c=0;c<4;c++){\n\t\t\t\t\tpair<ll,int> tmp=make(a[i][(c+1)&3],a[i][c],a[j][(k-c)&3],a[j][(k-c-1)&3]);\n\t\t\t\t\tb[c]=tmp.FF;res*=tmp.SS;\n\t\t\t\t}\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tres=res*cnt[b[c]],cnt[b[c]]--;\n\t\t\t\tans+=res;\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tcnt[b[c]]++;\n\t\t\t}\n\t\t\tcnt[make(a[j]).FF]++;\n\t\t}\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x7fffffff\n#define RG register\n#define inf 0x7fffffff\n#define mkp make_pair\n#define maxn 100205\ntypedef unsigned int U;\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 998244353;\nconst  double eps = 1e-8;\nconst double pi = acos(-1);\ninline ll read(){\n    ll x = 0, f = 1;\n    char ch = getchar();\n    while(ch > '9' || ch < '0') {if(ch == '-') f = -1;ch = getchar();}\n    while(ch >= '0' && ch <= '9'){x = x *10 + ch -'0';ch = getchar();}\n    return x * f;\n}\nint n,m,inde[100005],tot;\nstruct p{\n\tint c[4];\n\tbool operator < (const p & a)const{\n\t\tif(c[0]!=a.c[0]) return c[0]<a.c[0];\n\t\tif(c[1]!=a.c[1]) return c[1]<a.c[1];\n\t\tif(c[2]!=a.c[2]) return c[2]<a.c[2];\n\t\treturn c[3]<a.c[3];\n\t}\n}col[405];\nmap<p,int> mp;\nvoid add(p x,int val){\n\tp now=x,nxt;\n\tmp[now]+=val;\n\tfor(int j=1;j<=3;j++){\n\t\tfor(int i=0;i<=3;i++) nxt.c[i]=now.c[(i+1)%4];\n\t\tnow=nxt;\n\t\tmp[now]+=val;\n\t}\n}\nint main(){\n\tint i,j,u,v,e,w;\n\t//freopen(\"a.out\",\"r\",stdin);\n\t//freopen(\"a.ans\",\"w\",stdout);\n\tn=read();\n\tfor(i=1;i<=n;i++)\n\t\tcol[i].c[0]=read(),col[i].c[1]=read(),col[i].c[2]=read(),col[i].c[3]=read();\n\tfor(i=1;i<=n;i++) \n\t\tadd(col[i],1);\n\tll ans=0,S;\n\tfor(i=1;i<=n-5;i++){\n\t\tadd(col[i],-1);\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tadd(col[j],-1);\n\t\t\tp now,nxt=col[j],pj;\n\t\t\tfor(e=1;e<=4;e++){\n\t\t\t\tnow=nxt;\n\t\t\t\tS=1;\n\t\t\t\tfor(w=0;w<=3;w++) nxt.c[w]=now.c[(w+1)%4];\n\t\t\t\tfor(w=0;w<=3;w++){\n\t\t\t\t\tpj=(p){col[i].c[(w+1)%4],col[i].c[w],now.c[3-w],now.c[3-(w+1)%4]};\n\t\t\t\t\tS*=mp[pj];\n\t\t\t\t\tif(!mp[pj]) break;\n\t\t\t\t\telse add(pj,-1);\n\t\t\t\t}\n\t\t\t\tw--;\n\t\t\t\tfor(;w>=0;w--){\n\t\t\t\t\tpj=(p){col[i].c[(w+1)%4],col[i].c[w],now.c[3-w],now.c[3-(w+1)%4]};\n\t\t\t\t\tadd(pj,1);\n\t\t\t\t}\n\t\t\t\tans+=S;\n\t\t\t}\n\t\t\tadd(col[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n/*\n8\n0 0 0 0\n0 0 1 1\n0 1 0 1\n0 1 1 0\n1 0 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define len(x)  (int((x).size()))\n#define append push_back\n#define pp make_pair\n#define ff(a, b)    for (int a = 0; a < int(b); ++a)\n#define kk(n)    ff(k, n)\n#define xx(n)    ff(x, n)\n#define yy(n)    ff(y, n)\n#define ii(n)    ff(i, n)\n#define fff(a, b, c) for (int a = int(b); a < int(c); ++a)\n#define kkk(a, b) fff(k, a, b)\n#define xxx(a, b) fff(x, a, b)\n#define yyy(a, b) fff(y, a, b)\n#define iii(a, b) fff(i, a, b)\n#define bb begin()\n#define ee end()\n#define uu first\n#define vv second\n#define all(x)  (x).bb, (x).ee\n#define ite(v)   decltype((v).bb)\n#define fe(i, v) for(ite(v) i = (v).bb; i != (v).ee; ++i)\n#define err(...)    { fprintf(stderr, __VA_ARGS__); fflush(stderr); }\n#define zz(array, byte)   memset(array, byte, sizeof(array));\n\nusing LL = long long;\nusing DD = long double;\nusing pii = pair<int, int>;\n\n\n\nconst LL  INFLL  = 0x7f7f7f7f7f7f7f7fLL;\nconst int INFint = 0x7f7f7f7f;  //Works with memset(..).\n \n     \n\nint cs[404][4];\n\n\nLL makeCanonical(int a, int b, int c, int d) {\n    vector<int> colours = {a, b, c, d};\n\n    vector<LL> ts;\n    xx (4) {\n        LL type = 0;\n        yy (4)\n            type = (type * 1000) + colours[(x+y)%4];\n        ts.append(type);\n    }\n    sort(all(ts));\n    return ts[0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);     cin.tie(NULL);\n    //cout << '\\n';\n    cout.precision(16);\n    \n\n    int N;\n    cin >> N;\n    map<LL, int> typecounts;\n    map<LL, int> selfsymmetries;\n    vector<LL> canonical_types(N);\n    ii (N) {\n        cin >> cs[i][0]\n            >> cs[i][1]\n            >> cs[i][2]\n            >> cs[i][3];\n        map<LL, int> types;\n        xx (4) {\n            LL type = 0;\n            yy (4)\n                type = (type * 1000) + cs[i][(x+y)%4];\n            ++types[type];\n        }\n        canonical_types[i] = makeCanonical(cs[i][0],\n                                           cs[i][1],\n                                           cs[i][2],\n                                           cs[i][3]);\n        ++typecounts[canonical_types[i]];\n        selfsymmetries[canonical_types[i]] = 4 / len(types);\n    }\n\n    LL rr = 0;\n    ii (N) {\n        kkk (i+1, N) {\n            ff (rotation, 4) {\n                vector<LL> sought_canonical = {\n                    makeCanonical(cs[k][(1+rotation)%4],\n                                  cs[k][(0+rotation)%4],\n                                  cs[i][1],\n                                  cs[i][0]),\n                    makeCanonical(cs[k][(2+rotation)%4],\n                                  cs[k][(1+rotation)%4],\n                                  cs[i][0],\n                                  cs[i][3]),\n                    makeCanonical(cs[k][(3+rotation)%4],\n                                  cs[k][(2+rotation)%4],\n                                  cs[i][3],\n                                  cs[i][2]),\n                    makeCanonical(cs[k][(0+rotation)%4],\n                                  cs[k][(3+rotation)%4],\n                                  cs[i][2],\n                                  cs[i][1])\n                };\n\n                LL here = 1;\n                map<LL, int> left;\n                map<LL, int> need;\n                xx (4) {\n                    ++need[sought_canonical[x]];\n                    if (!typecounts.count(sought_canonical[x])) {\n                        here = 0;\n                        break;\n                    }\n                    left[sought_canonical[x]] = typecounts[sought_canonical[x]];\n                }\n                if (!here) continue;\n                --left[canonical_types[i]];\n                --left[canonical_types[k]];\n                fe (it, need) {\n                    LL ct = it->uu;\n                    int n = it->vv;\n                    if (left[ct] < n) {\n                        here = 0;\n                        break;\n                    }\n                    xx (n)\n                        here = (here * LL(left[ct] - x) \n                                * LL(selfsymmetries[ct]));\n                }\n                //printf(\"%d %d rotation %d: adding %d\\n\", i, k, rotation,\n                //        int(here));\n                rr += here;\n            }\n        }\n    }\n\n    cout << rr/3 << '\\n';\n    \n    \n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int mod = 1e9 + 7;\n\nint N;\nint c[405][4];\nLL hsh[405];\n\nmap<LL, int> mp;\n\nint power(int x, int y)\n{\n    if(y <= 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nvector<int> getBest(vector<int> cl)\n{\n    vector<int> bst = cl;\n    for(int j = 0; j < 4; j++)\n    {\n        cl.insert(cl.begin(), cl.back());\n        cl.pop_back();\n        if(bst > cl)    bst = cl;\n    }\n    return bst;\n}\n\nint rotateCount(vector<int> cl)\n{\n    LL h = cl[0] + LL(1e3) * cl[1] + LL(1e6) * cl[2] + LL(1e9) * cl[3];\n    int cnt = 0;\n    for(int j = 0; j < 4; j++)\n    {\n        cl.insert(cl.begin(), cl.back());\n        cl.pop_back();\n        LL h2 = cl[0] + LL(1e3) * cl[1] + LL(1e6) * cl[2] + LL(1e9) * cl[3];\n        cnt += (h == h2);\n    }\n    return cnt;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i <= N; i++)\n    {\n        vector<int> cl;\n        for(int j = 0; j < 4; j++)\n        {\n            int x; scanf(\"%d\", &x);\n            cl.push_back(x);\n        }\n\n        vector<int> bst = getBest(cl);\n        for(int j = 0; j < 4; j++)  c[i][j] = bst[j];\n\n        hsh[i] = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n        mp[ hsh[i] ]++;\n    }\n\n    LL ans = 0;\n    for(int i = 1; i < N; i++)\n        for(int j = i + 1; j <= N; j++)\n            for(int d = 0; d < 4; d++)\n            {\n                mp[ hsh[i] ]--; mp[ hsh[j] ]--;\n                swap(c[j][1], c[j][3]);\n\n                LL sol = 1; int lst = -1;\n                for(int k = 0; k < 4; k++)\n                {\n                    vector<int> cl;\n                    cl.push_back(c[i][k]);\n                    cl.push_back(c[j][(k + d) % 4]);\n                    cl.push_back(c[j][(k + d + 1) % 4]);\n                    cl.push_back(c[i][(k + 1) % 4]);\n\n                    vector<int> bst = getBest(cl);\n                    LL h = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n\n                    if(!mp.count(h)) { sol = 0; break; }\n                    int cnt = mp[h];\n                    if(cnt <= 0) { sol = 0; break; }\n\n                    mp[h]--;\n                    sol = (1LL * sol * cnt);\n\n                    cnt = rotateCount(bst);\n                    sol = (1LL * sol * cnt);\n\n                    lst = k;\n                }\n\n                ans += sol;\n\n                for(int k = 0; k <= lst; k++)\n                {\n                    vector<int> cl;\n                    cl.push_back(c[i][k]);\n                    cl.push_back(c[j][(k + d) % 4]);\n                    cl.push_back(c[j][(k + d + 1) % 4]);\n                    cl.push_back(c[i][(k + 1) % 4]);\n\n                    vector<int> bst = getBest(cl);\n                    LL h = bst[0] + LL(1e3) * bst[1] + LL(1e6) * bst[2] + LL(1e9) * bst[3];\n\n                    mp[h]++;\n                }\n\n                swap(c[j][1], c[j][3]);\n                mp[ hsh[i] ]++; mp[ hsh[j] ]++;\n            }\n\n    ans /= 3;\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline void shift(long long &now)\n{\n    static const int div = 1000 * 1000 * 1000;\n    now = now % div * 1000 + now / div;\n}\n\ninline void reverse(long long &now)\n{\n    static const int div = 1000 * 1000 * 1000;\n    now = now % 1000 * div + now % 1000000 / 1000 * 1000 * 1000 + now % div / 1000000 * 1000 + now / div;\n}\n\nlong long hsh(const vector <int> &now)\n{\n    long long res = 0;\n \n    for (int i = 0; i < 4; i++) {\n        res = res * 1000 + now[i];\n    }\n    return res;\n}\n\nint get(long long a, int pos)\n{\n    static const int div = 1000 * 1000 * 1000;\n\n    if (pos == 0) {\n        return a / div;\n    }\n    if (pos == 1) {\n        return a % div / 1000000;\n    }\n    if (pos == 2) {\n        return a % 1000000 / 1000;\n    }\n    return a % 1000;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    map <long long, int> cnt;\n    vector <long long> A(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) {\n            int x;\n            cin >> x;\n            A[i] = A[i] * 1000 + x;\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            cnt[A[i]]++;\n            shift(A[i]);\n        }\n    }\n    long long res = 0;\n    vector <int> st = {1000 * 1000 * 1000, 1000 * 1000, 1000, 1};\n\n    for (int i = 0; i < n; i++) {\n        for (int k = 0; k < 4; k++) {\n            cnt[A[i]]--;\n            shift(A[i]);\n        }\n\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 0; k < 4; k++) {\n                cnt[A[j]]--;\n                shift(A[j]);\n            }\n            reverse(A[j]);\n\n            for (int sh = 0; sh < 4; sh++) {\n                long long add = 1;\n                vector <pair <long long, int> > cross;\n\n                for (int k = 0; k < 4; k++) {\n                    long long now = hsh({get(A[i], k), get(A[j], k), get(A[j], (k + 1) % 4), get(A[i], (k + 1) % 4)});\n                    add *= cnt[now];\n\n                    for (int x = 0; x < 4; x++) {\n                        cross.push_back(make_pair(now, cnt[now]));\n                        cnt[now] -= 1;\n                        shift(now);\n                    }\n                }\n                res += add;\n\n                for (int p = int(cross.size()) - 1; p >= 0; p--) {\n                    cnt[cross[p].first] = cross[p].second;\n                }\n                shift(A[j]);\n            }\n            reverse(A[j]);\n\n            for (int k = 0; k < 4; k++) {\n                cnt[A[j]]++;\n                shift(A[j]);\n            }\n        }\n    }\n    cout << res << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\nusing namespace std;\nlong long a[405];\nlong long x[405][4];\nlong long c[405][10];\nmap<long long,int>m;\nlong long get(long long x,long long y,long long z,long long h)\n{\n    long long ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nlong long pack(long long x,long long y,long long z,long long h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nlong long fac(long long x)\n{\n    long long ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nlong long rot(long long key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin>>n;\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)cin>>x[i][j];\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        long long ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    long long y[4];\n                    y[0] = pack(x[ii][(j+1)%4],x[ii][(j+0)%4],x[i][1],x[i][0]);\n                    y[1] = pack(x[ii][(j+0)%4],x[ii][(j+3)%4],x[i][2],x[i][1]);\n                    y[2] = pack(x[ii][(j+3)%4],x[ii][(j+2)%4],x[i][3],x[i][2]);\n                    y[3] = pack(x[ii][(j+2)%4],x[ii][(j+1)%4],x[i][0],x[i][3]);\n \n                    sort(y,y+4);\n                    long long ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m.count(y[p])?m[y[p]]:0;\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            if(m.count(a[i]))m[a[i]]++;\n            else m[a[i]] = 1;\n        }\n        cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nvoid rm_tile(vector<int> &tile, map<vector<int>, ll> &colors) {\n  REP(i, 4) {\n    colors[tile]--;\n    rotate(tile.begin(), tile.begin() + 1, tile.end());\n  }\n}\n\nvoid add_tile(vector<int> &tile, map<vector<int>, ll> &colors) {\n  REP(i, 4) {\n    colors[tile]++;\n    rotate(tile.begin(), tile.begin() + 1, tile.end());\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<vector<int>, ll> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[tile], 0LL);\n    rm_tile(tile, colors);\n  }\n\n  for (vector<int> &tile : side_tiles) {\n    add_tile(tile, colors);\n  }\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<vector<int>, ll> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[tiles[i]]++;\n      rotate(tiles[i].begin(), tiles[i].begin() + 1, tiles[i].end());\n    }\n  }\n\n  int ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rotate(tiles[low].begin(), tiles[low].begin() + 1, tiles[low].end());\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n,a[405][4],tot[405];\nll h[405][4],hh[405];\nmap<ll,ll> f[5];\nint id[4][4]={{1,0,1,0},{3,2,3,2},{2,1,0,3},{0,3,2,1}};\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int p=0;p<4;p++) scanf(\"%d\",&a[i][p]);\n\tfor(int i=1;i<=n;i++){\n\t\tll mn=1e15;int sum=0;\n\t\tfor(int p=0;p<4;p++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint x=(p+j)&3;\n\t\t\t\th[i][p]=h[i][p]*1000+a[i][x];\n\t\t\t}\n\t\t\tif(h[i][p]<mn) mn=h[i][p],sum=0;\n\t\t\tif(h[i][p]==mn) sum++;\n\t\t}\n\t\tif(f[0].find(mn)==f[0].end()){\n\t\t\tfor(int p=1;p<=4;p++) f[p][mn]=0;\n\t\t\tf[0][mn]=1;\n\t\t}\n\t\thh[i]=mn;tot[i]=sum;\n\t\tfor(int p=4;p;p--){\n\t\t\tf[p][mn]+=f[p-1][mn]*sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=4;j++) f[j][hh[i]]-=f[j-1][hh[i]]*tot[i];\n\t\tfor(int p=i+1;p<=n;p++){\n\t\t\tfor(int j=1;j<=4;j++) f[j][hh[p]]-=f[j-1][hh[p]]*tot[p];\n\t\t\tfor(int ww=0;ww<4;ww++){\n\t\t\t\tint b[4],c[4];\n\t\t\t\tfor(int k=0;k<4;k++) b[k]=a[p][(k+ww)&3];\n\t\t\t\tll mn[4]={1e15,1e15,1e15,1e15};\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tfor(int w=0;w<2;w++) c[w]=a[i][id[j][w]];\n\t\t\t\t\tfor(int w=2;w<4;w++) c[w]=b[id[j][w]];\n\t\t\t\t\tfor(int w=0;w<4;w++){\n\t\t\t\t\t\tll H=0;\n\t\t\t\t\t\tfor(int o=0;o<4;o++) H=H*1000+c[(o+w)&3];\n\t\t\t\t\t\tmn[j]=min(mn[j],H);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tsort(mn,mn+4);\n\t\t\t\tll sum=1;\n\t\t\t\tfor(int j=0;j<4;){\n\t\t\t\t\tint o;\n\t\t\t\t\tfor(o=j;o<4&&mn[o]==mn[j];o++) sum*=(o-j+1);\n\t\t\t\t\tif(f[o-j].find(mn[j])==f[o-j].end()){\n\t\t\t\t\t\tsum=0;break;\n\t\t\t\t\t}\n\t\t\t\t\tsum*=f[o-j][mn[j]];\n\t\t\t\t\tj=o;\n\t\t\t\t}\n\t\t\t\tans+=sum;\n\t\t\t}\n\t\t\tfor(int j=4;j;j--) f[j][hh[p]]+=f[j-1][hh[p]]*tot[p];\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORR(i,a,b) for (int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define rng(a) (a.begin()),(a.end())\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll;\ntypedef set<ll> sl;\ntypedef __int128_t lll;\ntypedef pair<lll,lll> plll;\ntypedef vector<lll> vlll;\ntemplate<typename T>string join(vector<T>&v){stringstream s;FOR(i,0,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename A,size_t N,typename T>void Fill(A (&array)[N],const T&v){fill((T*)array,(T*)(array+N),v);}\nlll gcd(lll a,lll b,lll &x,lll &y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll gcd(ll a,ll b){lll x=0,y=0;return gcd(a,b,x,y);}\nll modpow(lll a,lll n,ll m){if(!a)return a;lll p=1;for(;n>0;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return(ll)p;}\nvoid dout(double d){printf(\"%.12f\\n\",d);}\nvoid YN(bool z){cout<<(z?\"YES\\n\":\"NO\\n\");}\nvoid Yn(bool z){cout<<(z?\"Yes\\n\":\"No\\n\");}\nvoid yn(bool z){cout<<(z?\"yes\\n\":\"no\\n\");}\n\nconst int iinf = 1e9;\nconst ll linf = 1e18;\nconst int mod = 1e9+7;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\nconst int N = 0;\nint n, c[400][4], d[4];\nll ser(ll c1, ll c2, ll c3, ll c4){\n  return ((c1 * 1000ll + c2) * 1000ll + c3) * 1000 + c4;\n}\nll norm(ll c1, ll c2, ll c3, ll c4){\n  ll ret = -1;\n  maxs(ret, ser(c1, c2, c3, c4));\n  maxs(ret, ser(c2, c3, c4, c1));\n  maxs(ret, ser(c3, c4, c1, c2));\n  maxs(ret, ser(c4, c1, c2, c3));\n  return ret;\n}\nint same(ll c1, ll c2, ll c3, ll c4){\n  int ret = 1;\n  if(c1==c3&&c2==c4){\n    ret=2;\n    if(c1==c2) ret=4;\n  }\n  return ret;\n}\nint same(ll s){\n  ll c1 = s / 1000000000ll % 1000;\n  ll c2 = s / 1000000ll    % 1000;\n  ll c3 = s / 1000ll       % 1000;\n  ll c4 = s / 1ll          % 1000;\n  return same(c1, c2, c3, c4);\n}\nll perm(int a, int b){\n  ll ret = 1;\n  FOR(i, 0, b) ret *= a-i;\n  return ret;\n}\nmap<ll, int> cnt;\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n;\n  FOR(i, 0, n){\n    FOR(j, 0, 4) cin >> c[i][j];\n    cnt[norm(c[i][0], c[i][1], c[i][2], c[i][3])]++;\n  }\n  ll ans = 0;\n  FOR(i, 0, n)FOR(j, 0, n)if(i!=j)FOR(k, 0, 4){\n    cnt[norm(c[i][0], c[i][1], c[i][2], c[i][3])]--;\n    cnt[norm(c[j][0], c[j][1], c[j][2], c[j][3])]--;\n    FOR(l, 0, 4) d[l] = c[j][(l+k)%4];\n    map<ll, int> t;\n    t[norm(c[i][1], c[i][0], d[1], d[0])]++;\n    t[norm(c[i][2], c[i][1], d[0], d[3])]++;\n    t[norm(c[i][3], c[i][2], d[3], d[2])]++;\n    t[norm(c[i][0], c[i][3], d[2], d[1])]++;\n    ll cc = 1;\n    each(itr, t) cc *= perm(cnt[itr->fi], itr->se);\n    cc *= same(c[i][1], c[i][0], d[1], d[0]);\n    cc *= same(c[i][2], c[i][1], d[0], d[3]);\n    cc *= same(c[i][3], c[i][2], d[3], d[2]);\n    cc *= same(c[i][0], c[i][3], d[2], d[1]);\n    ans += cc;\n    cnt[norm(c[i][0], c[i][1], c[i][2], c[i][3])]++;\n    cnt[norm(c[j][0], c[j][1], c[j][2], c[j][3])]++;\n  }\n  cout << ans/6 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n明知这是一场意外，你要不要来\n明知这是一场重伤害，你会不会来\n当疯狂慢慢从爱情离开，还有什么你值得感慨\n如果风景早已都不存在，我想我谁都不爱\n——薛之谦《意外》\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n// #define MPS\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 405;\n\nmap<ll,int> Cnt;\nint n;\nVI C[maxn];\nll Ans;\n\nll f(int a,int b,int c,int d) // hash function\n{\n\treturn (((a*1000ll + b)*1000) + c)*1000 + d;\n}\nVI fmr(VI A) // find the minimal representation for a squre\n{\n\tVI ret = A;\n\tfo(d,1,3)\n\t{\n\t\tfo(i,0,3) \n\t\t\tif(ret[i] < A[(i+d)%4]) break;\n\t\t\telse if(ret[i] > A[(i+d)%4]) \n\t\t\t{\n\t\t\t\tfo(j,0,3) ret[j] = A[(j+d)%4];\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\t#ifdef MPS\n\t\tfp(\"arc062e.in\",\"r\",stdin);\n\t\tfp(\"arc062e.out\",\"w\",stdout);\n\t#endif\n\tVI tmp;\n\tsf(\"%d\",&n);\n\tfo(i,1,n) \n\t{\n\t\tfo(j,0,3) {int x; sf(\"%d\",&x); C[i].pb(x);}\n\t\ttmp = fmr(C[i]);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tfo(i,1,n)\n\t{\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\tfo(j,i+1,n)\n\t\t{\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] --;\n\t\t\tfo(d1,0,3)\n\t\t\t{\n\t\t\t\tVI tmp;\n\t\t\t\tvector<ll> cube;\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[i][(4-d1)%4]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[j][2]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][1]); tmp.pb(C[j][0]); tmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[i][(4-d1)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[i][(1-d1+4)%4]); tmp.pb(C[j][0]); tmp.pb(C[j][3]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\ttmp.clear(); \n\t\t\t\ttmp.pb(C[j][3]); tmp.pb(C[j][2]); tmp.pb(C[i][(3-d1+4)%4]); tmp.pb(C[i][(2-d1+4)%4]);\n\t\t\t\ttmp = fmr(tmp);\n\t\t\t\tcube.pb(f(tmp[0],tmp[1],tmp[2],tmp[3]));\n\n\t\t\t\tsort(cube.begin(),cube.end());\n\t\t\t\tint s = 1; ll cur = 1;\n\t\t\t\tfor(int i = 1; i <= 4; ++ i)\n\t\t\t\t\tif(i != 4 && cube[i] == cube[i-1]) {++ s; continue;}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!Cnt.count(cube[i-1])) {cur = 0; break;} \n\t\t\t\t\t\tint num = Cnt[cube[i-1]]; //we are calculating A(num, s) = num! / (num-s)!\n\t\t\t\t\t\tfo(i,num-s+1,num) cur *= i;\n\t\t\t\t\t\tint bonus = 1, a, b, c, d;\n\t\t\t\t\t\tll x = cube[i-1];\n\t\t\t\t\t\ta = x/1000000000; x -= a*1000000000ll;\n\t\t\t\t\t\tb = x/1000000; x -= b*1000000ll;\n\t\t\t\t\t\tc = x/1000; x -= c*1000ll;\n\t\t\t\t\t\td = x;\n\t\t\t\t\t\tif(a == d && b == a && c == b && d == c) ++ bonus;\n\t\t\t\t\t\tif(a == c && b == d && c == a && d == b) ++ bonus;\n\t\t\t\t\t\tif(a == b && b == c && c == d && d == a) ++ bonus;\n\t\t\t\t\t\tfo(i,1,s) cur *= bonus;\n\t\t\t\t\t\ts = 1;\n\t\t\t\t\t}\n\t\t\t\tAns += cur;\n\t\t\t}\n\t\t\ttmp.clear(); fo(k,0,3) tmp.pb(C[j][k]); tmp = fmr(tmp);\n\t\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t\t}\n\t\ttmp.clear(); fo(j,0,3) tmp.pb(C[i][j]); tmp = fmr(tmp);\n\t\tCnt[f(tmp[0],tmp[1],tmp[2],tmp[3])] ++;\n\t}\n\tpf(\"%lld\\n\",Ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\nusing namespace std;\n//emplace_back next_permutation tie get\n\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define OUT(a) cout<<(a)<<endl;\n\nvoid myrot(vector<int> &a){\n    auto it=a.end()-1;\n    REPN(i,2,a.size()-1){\n        if(*(a.end()-i)<*it or (it==a.end()-i+1 and *it==*(a.end()-i))) it=a.end()-i;\n    }\n    rotate(a.begin(),it,a.end());\n    if(a[0]==a[2] && a[1]>a[3]) swap(a[1],a[3]);\n    return;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    map<vector<int>,int> a;\n    LL ans=0;\n    int n; cin >> n;\n    vector<vector<int>> c(n,vector<int>(4));\n    REP(i,n){\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        myrot(c[i]);\n        a[c[i]]++;\n    }\n    REP(i,n){\n        FOR(j,i+1,n){\n            a[c[i]]--;\n            a[c[j]]--;\n            //a.erase(c[i]);\n            //a.erase(c[j]);\n            vector<vector<int>> sid(4,vector<int>(4));\n            REP(k,4){\n                bool e[4]={};\n                LL tmp=1;\n                REP(l,4){\n                    sid[l][0]=c[i][l];\n                    sid[l][1]=c[j][(1-l+4)%4];\n                    sid[l][2]=c[j][(-l+4)%4];\n                    sid[l][3]=c[i][(l+1)%4];\n                }\n                REP(l,4) myrot(sid[l]);\n                REP(l,4){\n                    //int cnt=a.count(sid[l]);\n                    int cnt=a[sid[l]];\n                    tmp*=cnt;\n                    if(cnt>0){\n                        //a.erase(sid[l]);\n                        a[sid[l]]--;\n                        e[l]=true;\n                    }\n                    if(sid[l][0]==sid[l][3]) tmp*=4;\n                    else if (sid[l][0]==sid[l][2] && sid[l][1]==sid[l][3]) tmp*=2;\n                }\n                //REP(l,4) if(e[l]) a.insert(sid[l]);\n                REP(l,4) if(e[l]) a[sid[l]]++;\n                ans+=tmp;\n                if(tmp>0){\n                    cout << i <<' '<< j << endl;\n                    REP(l,4)cout << c[i][l]<< ' ';\n                    REP(l,4)cout << c[j][l]<< ' ';\n                    cout << tmp<<endl;\n                }\n                rotate(c[j].begin(),c[j].begin()+1,c[j].end());\n            }\n            a[c[i]]++;\n            a[c[j]]++;\n\n            //a.insert(c[i]);\n            //a.insert(c[j]);\n        }\n        //a.erase(c[i]);\n        a[c[i]]--;\n\n    }\n    cout <<ans <<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> rotate(vector<int> vec, int i) {\n  vector<int> ret = {vec[(0+i)%4], vec[(1+i)%4], vec[(2+i)%4], vec[(3+i)%4]};\n  return ret;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<vector<int>> tiles(n, vector<int>(4));\n  rep(i, n) {\n    int a, b, c, d; cin >> a >> b >> c >> d;\n    tiles[i] = {a, b, c, d};\n  }\n\n  ll ans = 0;\n  rep(i, n-5) {\n    vector<int> ti = tiles[i];\n    for(int j=i+1; j<n; j++) {\n      rep(k, 4) {\n        vector<int> tj = rotate(tiles[j], k);\n        vector<vector<int>> dice(4, vector<int>(4));\n        dice[0] = {ti[0], tj[1], tj[0], ti[1]};\n        dice[1] = {ti[1], tj[0], tj[3], ti[2]};\n        dice[2] = {ti[2], tj[3], tj[2], ti[3]};\n        dice[3] = {ti[3], tj[2], tj[1], ti[0]};\n        vector<ll> dp1(16);\n        vector<ll> dp2(16);\n        dp1[0] = dp2[0] = 1;\n        for(int l=i+1; l<n; l++) {\n          if (l==j) continue;\n          rep(m, 4) {\n            vector<int> tl = rotate(tiles[l], m);\n            rep(r, 4) {\n              int s = 1<<r;\n              if (tl == dice[r]) {\n                rep(u, 16) {\n                  if ((u|s) != u) {\n                    dp2[(u|s)] += dp1[u];\n                  }\n                }\n              }\n            }\n          }\n          dp1 = dp2;\n        }\n        ans += dp2[15];\n      }\n\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <unordered_map>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <queue>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) static_cast<int>((a).size())\n#define fillchar(a, x) memset(a, x, sizeof(a))\n#define rep(i, a, b) for(int i=int(a); i<=int(b); ++i)\n#define irep(i, a, b) for(int i=int(a); i>=int(b); --i)\n#define replr(i, a, b) rep(i, a, (b)-1)\n#define reprl(i, a, b) irep(i, (b)-1, a)\n#define repn(i, n) rep(i, 0, (n)-1)\n#define irepn(i, n) irep(i, (n)-1, 0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef vector<LL> VL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPI;\ntypedef vector<string> VS;\ntemplate<class T, class S> ostream& operator<<(ostream& os, const pair<T, S>& v) { return os<<\"(\"<<v.first<<\", \"<<v.second<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) { os<<\"[\"; repn(i, sz(v)) { if(i) os<<\", \"; os<<v[i]; } return os<<\"]\"; }\ntemplate<class T> bool setmax(T &_a, T _b) { if(_b>_a) { _a=_b; return true; } return false; }\ntemplate<class T> bool setmin(T &_a, T _b) { if(_b<_a) { _a=_b; return true; } return false; }\ntemplate<class T> T gcd(T _a, T _b) { return _b==0?_a:gcd(_b,_a%_b); }\n\nLL encode(const VI& x) {\n    return (LL(x[0])<<30)+(LL(x[1])<<20)+(x[2]<<10)+x[3];\n}\n\nVL extend(LL x) {\n    VL r;\n    repn(i, 4) {\n        r.pb(x);\n        LL low=x&((1<<10)-1);\n        x=(x>>10)+(low<<30);\n    }\n    return r;\n}\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<VI> a(n, VI(4));\n    vector<LL> code(n);\n    unordered_map<LL, int> count;\n    repn(i, n) {\n        repn(j, 4) scanf(\"%d\", &a[i][j]);\n        code[i]=encode(a[i]);\n        count[code[i]]++;\n    }\n\n    LL ans=0;\n    repn(i, n) {\n        count[code[i]]--;\n        replr(j, i+1, n) {\n            count[code[j]]--;\n            VI tmp=a[j];\n            repn(__, 4) {\n                VL ws=extend(encode(VI{tmp[0], tmp[3], a[i][3], a[i][2]}));\n                VL xs=extend(encode(VI{tmp[3], tmp[2], a[i][0], a[i][3]}));\n                VL ys=extend(encode(VI{tmp[2], tmp[1], a[i][1], a[i][0]}));\n                VL zs=extend(encode(VI{tmp[1], tmp[0], a[i][2], a[i][1]}));\n                //cout<<i<<\" \"<<j<<\" \"<<ws<<\" \"<<xs<<\" \"<<ys<<\" \"<<zs<<endl;\n                for(LL w: ws) if(count[w]>0) {\n                    LL vw=count[w]--;\n                    for(LL x: xs) if(count[x]>0) {\n                        LL vx=vw*count[x]--;\n                        for(LL y: ys) if(count[y]>0) {\n                            LL vy=vx*count[y]--;\n                            for(LL z: zs) ans+=vy*count[z];\n                            count[y]++;\n                        }\n                        count[x]++;\n                    }\n                    count[w]++;\n                }\n                int first=tmp[0]; tmp[0]=tmp[1]; tmp[1]=tmp[2]; tmp[2]=tmp[3]; tmp[3]=first;\n            }\n            count[code[j]]++;\n        }\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int mod=1e7+9;\nconst int MAX_H=1e5+5;\n\nint N, t, C[MAX][5];\nmap<ll,pair<int,int> >::iterator it;\nmap<ll,pair<int,int> > MP;\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    it=MP.find(H);\n    if(it!=MP.end())\n    {\n        it->s.s+=t;\n        return;\n    }\n    int re=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n    MP[H]=mp(re, t);\n}\n\ninline int Find(ll H)\n{\n    it=MP.find(H);\n    return it->s.f*it->s.s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 55\n#define maxm 205\n#define mod 1000000007\nusing namespace std;\n\nint n,m,k;\nint info[maxn],Prev[maxm],to[maxm],cnt_e;\nvoid Node(int u,int v){ Prev[++cnt_e]=info[u],info[u]=cnt_e,to[cnt_e]=v; }\n\nint dfn[maxn],low[maxn],sta[maxn],tot,fac[maxm]={1,1},inv[maxm]={1,1},invf[maxm]={1,1};\nint vis[maxn],tim;\nvector<vector<int> >pd;\nvoid dfs(int u){\n\tdfn[u] = low[u] = ++tot;sta[++sta[0]] = u;\n\tfor(int i=info[u],v;i;i=Prev[i]) if(!dfn[v=to[i]]){\n\t\tdfs(v);\n\t\tif(low[v] >= dfn[u]){\n\t\t\tvector<int>p;p.push_back(u);\n\t\t\tfor(int t = -1;t!=v;)\n\t\t\t\tp.push_back(t = sta[sta[0]--]);\n\t\t\tpd.push_back(p);\n\t\t}\n\t\tlow[u] = min(low[u] , low[v]);\n\t}else low[u] = min(low[u] , dfn[v]);\n}\n\nint Pow(int base,int k){\n\tint ret = 1;\n\tfor(;k;k>>=1,base=1ll*base*base%mod) if(k&1) ret=1ll*ret*base%mod;\n\treturn ret;\n}\n\nint C(int a,int b){ return 1ll * fac[a] * invf[b] % mod * invf[a-b] % mod; }\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1,u,v;i<=m;i++) scanf(\"%d%d\",&u,&v),Node(u,v),Node(v,u);\n\tfor(int i=2;i<maxm;i++) \n\t\tfac[i] = 1ll * fac[i-1] * i % mod,\n\t\tinv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod ,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) dfs(i);\n\tint ans = 1;\n\tfor(auto U:pd){\n\t\t++tim;\n\t\tfor(int u:U) vis[u] = tim;\n\t\tint cnt = 2*U.size();\n\t\tfor(int u:U) for(int i=info[u],v;i;i=Prev[i]) \n\t\t\tif(vis[v=to[i]]==tim) cnt--;\n\t\tif(cnt>0) ans = 1ll * ans * k % mod;\n\t\telse if(cnt == 0){\n\t\t\tint sum = 0;\n\t\t\tfor(int i=1;i<=U.size();i++)\n\t\t\t\tsum = (sum + Pow(k,__gcd((int)U.size(),i))) % mod;\n\t\t\tans = 1ll * ans * sum % mod * Pow(U.size(),mod-2) % mod;\n\t\t}else ans = 1ll * ans * C(U.size()-cnt/2+k-1,k-1) % mod;\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            vector<pair<int,int>> update;\n            bool unused[400];\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(!unused[k]){\n                    rep(i_,0,4){\n                        if(b&(1<<i_)) continue;\n                        rep(j_,0,4) if(match(rotatedC[k][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                vector<i64> sum(4);\n                rep(i_,0,4){\n                    sum[i_]=0;\n                    rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                }\n                unused[i]=unused[j]=true;\n                rep(i_,0,N){\n                    if(i_==i or i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    unused[i_]=!use;\n                }\n                \n                ans+=rec(i+1,0);\n                \n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nconstexpr ll T[4]={1,1000,1000000,1000000000};\ninline ll f(const ar &x,int k){\n    ll res=0;\n    rep(i,4)res+=T[(i+k)&3]*x[i];\n    return res;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    rep3(i,15,1){\n        rep(j,4){\n            if(i&(1<<j)){\n                printf(\"dp[%d]+=dp[%d]*cnt[%d];\\n\",i,i^(1<<j),j);\n            }\n        }\n    }\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin >> v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i],j);\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                rep(ii,4){\n                    s[ii] = f(ar{v[i][(4+1-ii)&3],v[i][(4-ii)&3],v[j][(1+k+ii)&3],v[j][(k+ii)&3]},0);\n                }\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    dp[15]+=dp[14]*cnt[0];\n                    dp[15]+=dp[13]*cnt[1];\n                    dp[15]+=dp[11]*cnt[2];\n                    dp[15]+=dp[7]*cnt[3];\n                    dp[14]+=dp[12]*cnt[1];\n                    dp[14]+=dp[10]*cnt[2];\n                    dp[14]+=dp[6]*cnt[3];\n                    dp[13]+=dp[12]*cnt[0];\n                    dp[13]+=dp[9]*cnt[2];\n                    dp[13]+=dp[5]*cnt[3];\n                    dp[12]+=dp[8]*cnt[2];\n                    dp[12]+=dp[4]*cnt[3];\n                    dp[11]+=dp[10]*cnt[0];\n                    dp[11]+=dp[9]*cnt[1];\n                    dp[11]+=dp[3]*cnt[3];\n                    dp[10]+=dp[8]*cnt[1];\n                    dp[10]+=dp[2]*cnt[3];\n                    dp[9]+=dp[8]*cnt[0];\n                    dp[9]+=dp[1]*cnt[3];\n                    dp[8]+=dp[0]*cnt[3];\n                    dp[7]+=dp[6]*cnt[0];\n                    dp[7]+=dp[5]*cnt[1];\n                    dp[7]+=dp[3]*cnt[2];\n                    dp[6]+=dp[4]*cnt[1];\n                    dp[6]+=dp[2]*cnt[2];\n                    dp[5]+=dp[4]*cnt[0];\n                    dp[5]+=dp[1]*cnt[2];\n                    dp[4]+=dp[0]*cnt[2];\n                    dp[3]+=dp[2]*cnt[0];\n                    dp[3]+=dp[1]*cnt[1];\n                    dp[2]+=dp[0]*cnt[1];\n                    dp[1]+=dp[0]*cnt[0];\n                }\n                ans += dp[15];\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll N=1005;\nint a[N][8];\nll p[4];\nmap<ll,ll>g;\nll Hash(ll a,ll b,ll c,ll d){\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\nvoid Add(ll f,ll v){\n    for(int i=0;i<4;i++){\n        g[f]+=v;\n        f=(f>>10)|((f&(1023))<<30);\n    }\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<4;j++){\n            scanf(\"%d\",&a[i][j]);\n            a[i][j+4]=a[i][j];\n        }\n        Add(Hash(a[i][0],a[i][1],a[i][2],a[i][3]),1);\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        Add(Hash(a[i][0],a[i][1],a[i][2],a[i][3]),-1);\n        for(int j=i+1;j<n;j++){\n            Add(Hash(a[j][0],a[j][1],a[j][2],a[j][3]),-1);\n            for(int k=0;k<4;k++){\n                ll sum=1;\n                p[0]=Hash(a[j][k+1],a[j][k+0],a[i][1],a[i][0]);\n                p[1]=Hash(a[j][k+0],a[j][k+3],a[i][2],a[i][1]);\n                p[2]=Hash(a[j][k+3],a[j][k+2],a[i][3],a[i][2]);\n                p[3]=Hash(a[j][k+2],a[j][k+1],a[i][0],a[i][3]);\n                if(g[p[0]]&&g[p[1]]&&g[p[2]]&&g[p[3]]){\n                    sum*=g[p[0]];\n                    Add(p[0],-1);\n                    sum*=g[p[1]];\n                    Add(p[1],-1);\n                    sum*=g[p[2]];\n                    Add(p[2],-1);\n                    sum*=g[p[3]];\n                    //Add(p[3],-1);\n                    //Add(p[3],1);\n                    Add(p[2],1);\n                    Add(p[1],1);\n                    Add(p[0],1);\n                    ans+=sum;\n                }\n            }\n            Add(Hash(a[j][0],a[j][1],a[j][2],a[j][3]),1);\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nV<int> cyc(V<int> a) {\n\tVV<int> cand;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(a[(j+k)%4]);\n\t\t}\n\t\tcand.pb(vec);\n\t}\n\treturn *min_element(ALL(cand));\n}\n\nint com(V<int>& v) {\n\tint cnt = 0;\n\trep(j, 4) {\n\t\tV<int> vec;\n\t\trep(k, 4) {\n\t\t\tvec.pb(v[(j+k)%4]);\n\t\t}\n\t\tif (vec == v) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> vf;\n\tmap<V<int>, int> T;\n\n\trep(i, N) {\n\t\tV<int> a(4);\n\t\trep(j, 4) cin >> a[j];\n\n\t\tauto vec = cyc(a);\n\t\tvf.pb(vec);\n\t\t++T[vec];\n\t\tdump(vec);\n\t}\n\n\tll ans = 0;\n\n\trep(i, N) {\n\t\trep(j, N) if (i != j) {\n\t\t\t--T[vf[i]];\n\t\t\t--T[vf[j]];\n\n\t\t\trep(k, 4) {\n\t\t\t\tint up[4], dw[4];\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tup[l] = vf[i][l];\n\t\t\t\t\tdw[l] = vf[j][(k-l+4)%4];\n\t\t\t\t}\n\n\t\t\t\tll t = 1;\n\n\t\t\t\tVV<int> use;\n\t\t\t\trep(l, 4) {\n\t\t\t\t\tV<int> vec{up[l],up[(l+3)%4],dw[(l+3)%4],dw[l]};\n\t\t\t\t\tvec = cyc(vec);\n\t\t\t\t\tuse.pb(vec);\n\t\t\t\t\tt *= T[vec] * com(vec);\n\t\t\t\t\t--T[vec];\n\t\t\t\t}\n\t\t\t\tans += t;\n\t\t\t\trep(l, 4) ++T[use[l]];\n\t\t\t}\n\n\t\t\t++T[vf[i]];\n\t\t\t++T[vf[j]];\t\t\t\n\t\t}\n\t}\n\tdump(ans);\n\n\tcout << ans / 6 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <map>\n\nusing tile = std::array<int16_t, 4>;\n\ntile rotate(const tile &t, int r) {\n  tile res{};\n  for (int i = 0; i < 4; ++i) {\n    res[i] = t[(i + r) & 3];\n  }\n  return res;\n}\n\ntile normalize(const tile &t) {\n  std::array<tile, 4> tmp{};\n  for (int i = 0; i < 4; ++i) {\n    tmp[i] = rotate(t, i);\n  }\n  std::sort(tmp.begin(), tmp.end());\n  return tmp.front();\n}\n\nint type(const tile &t) {\n  if (t[0] == t[1] && t[1] == t[2] && t[2] == t[3]) return 4;\n  if (t[0] == t[2] && t[1] == t[3]) return 2;\n  return 1;\n}\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<tile> C(N);\n  std::map<tile, int> memo;\n  for (auto &t: C) {\n    for (auto &x: t) {\n      std::cin >> x;\n    }\n    t = normalize(t);\n    memo[t]++;\n  }\n  int64_t ans = 0;\n  for (int i = 0; i < N; ++i) {\n    memo[C[i]]--;\n    const auto &up = C[i];\n    for (int j = i + 1; j < N; ++j) {\n      memo[C[j]]--;\n      for (int k = 0; k < 4; ++k) {\n        auto down = rotate(C[j], k);\n        std::map<tile, int> query;\n        query[normalize(tile{ up[0], up[3], down[2], down[1] })]++;\n        query[normalize(tile{ up[1], up[0], down[1], down[0] })]++;\n        query[normalize(tile{ up[2], up[1], down[0], down[3] })]++;\n        query[normalize(tile{ up[3], up[2], down[3], down[2] })]++;\n        int64_t add = 1;\n        for (auto &q: query) {\n          auto itr = memo.find(q.first);\n          if (itr == memo.end()) {\n            add = 0;\n            break;\n          }\n          int s = itr -> second, t = type(q.first);\n          for (int i = 0; i < q.second; ++i) {\n            add *= (s - i) * t;\n          }\n        }\n        ans += add;\n      }\n      memo[C[j]]++;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\n#define hsh 821\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,c[505][4],hs[505][4],req[4];\nLL res,cur;\nint HS(int A,int B,int C,int D){\n\treturn ((((A*hsh)+B)*hsh)+C)*hsh+D;\n}\nmap < int , int > cnt;\nint coincide(int X,int A,int B,int C,int D){\n\tint R=0;\n\tif(c[X][0]==A && c[X][1]==B && c[X][2]==C && c[X][3]==D) ++R;\n\tif(c[X][1]==A && c[X][2]==B && c[X][3]==C && c[X][0]==D) ++R;\n\tif(c[X][2]==A && c[X][3]==B && c[X][0]==C && c[X][1]==D) ++R;\n\tif(c[X][3]==A && c[X][0]==B && c[X][1]==C && c[X][2]==D) ++R;\n\treturn R;\n}\nint coincide(int X,int Y,int Z,int W,int A,int B,int C,int D){\n\tint R=0;\n\tif(X==A && Y==B && Z==C && W==D) ++R;\n\tif(Y==A && Z==B && W==C && X==D) ++R;\n\tif(Z==A && W==B && X==C && Y==D) ++R;\n\tif(W==A && X==B && Y==C && Z==D) ++R;\n\treturn R;\n}\nint coincideX(int X,int Y,int I,int D1,int D2){\n\treturn\n\tcoincide(c[X][D1],c[X][(D1+1)&3],c[Y][(D1+1+I)&3],c[Y][(D1+I)&3],\n\t\t\t c[X][D2],c[X][(D2+1)&3],c[Y][(D2+1+I)&3],c[Y][(D2+I)&3]);\n}\nint coincideY(int P,int X,int Y,int I,int D){\n\treturn\n\tcoincide(P,c[X][D],c[X][(D+1)&3],c[Y][(D+1+I)&3],c[Y][(D+I)&3]);\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k,l,h;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<4;++j){\n\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t\t++c[i][j];\n\t\t}\n\t\ths[i][0]=HS(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t\ths[i][1]=HS(c[i][1],c[i][2],c[i][3],c[i][0]);\n\t\ths[i][2]=HS(c[i][2],c[i][3],c[i][0],c[i][1]);\n\t\ths[i][3]=HS(c[i][3],c[i][0],c[i][1],c[i][2]);\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    for(i=n-1;i>=0;--i){\n\t\treverse(c[i],c[i]+4);\n\t\tfor(j=i+1;j<n;++j){\n\t\t\tfor(k=0;k<4;++k){\n\t\t\t\treq[0]=HS(c[i][0],c[i][1],c[j][(k+1)&3],c[j][k]);\n\t\t\t\treq[1]=HS(c[i][1],c[i][2],c[j][(k+2)&3],c[j][(k+1)&3]);\n\t\t\t\treq[2]=HS(c[i][2],c[i][3],c[j][(k+3)&3],c[j][(k+2)&3]);\n\t\t\t\treq[3]=HS(c[i][3],c[i][0],c[j][k],c[j][(k+3)&3]);\n\t\t\t\tcur=1ll;\n\t\t\t\tfor(l=0;l<4;++l){\n\t\t\t\t\tif(!cnt[req[l]]){\n\t\t\t\t\t\tcur=0ll;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint num=cnt[req[l]]-coincideY(j,i,j,k,l);\n\t\t\t\t\tfor(h=0;h<l;++h){\n\t\t\t\t\t\tnum-=coincideX(i,j,k,h,l);\n\t\t\t\t\t}\n\t\t\t\t\tcur*=(LL)num;\n\t\t\t\t}\n\t\t\t\tres+=cur;\n\t\t\t}\n\t\t}\n\t\treverse(c[i],c[i]+4);\n\t\tfor(j=0;j<4;++j) ++cnt[hs[i][j]];\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i) & 3];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)&3] < colors[(j+k)&3]) return true;\n            if (colors[(i+k)&3] > colors[(j+k)&3]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors &a, Colors &b, Colors &brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    FOREACH(pb, colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        colcnt[b]--;\n        FORN(rot, 4) {\n            ans += multi * countfit(a, b, brot);\n            brot.rotate_left(1);\n        }\n        colcnt[b]++;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        Colors a = tiles[i];\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n;\npair<pii,pii> cubes[525];\n\nint main(){\n  scanf(\"%d\",&n);\n  assert(n!=400);\n  REP(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    cubes[i] = make_pair(pii(a,b),pii(c,d));\n  }\n  typedef pii E;\n  typedef pair<pii,pii> S;\n  // one edge, another edge, [count, multiple]\n  map<E, map<E,pii> > edges;\n  // surface, [count, multiple]\n  map<S, pii> surfaces;\n\n  // surface to edges\n  map<S,set<pair<E,E> > > s2e;\n  // surface to surfaces\n  map<S,set<S> > s2s;\n\n  {\n    int a[4];\n    REP(i,n){\n      map<pii,map<pii,int> > ae;\n      map<pair<pii,pii>,int> as;\n      a[0] = cubes[i].first.first;\n      a[1] = cubes[i].first.second;\n      a[2] = cubes[i].second.first;\n      a[3] = cubes[i].second.second;\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        ae[e][oe]+=1;\n        as[s]+=1;\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      REP(_,4){\n        E e = pii(a[0],a[1]);\n        E oe = pii(a[2],a[3]);\n        S s = make_pair(pii(a[0],a[1]),pii(a[2],a[3]));\n        if(ae[e][oe]>0){\n          edges[e][oe].first += 1;\n          edges[e][oe].second = ae[e][oe];\n          ae[e][oe] = 0;\n        }\n        if(as[s]>0){\n          surfaces[s].first += 1;\n          surfaces[s].second = as[s];\n          as[s] = 0;\n        }\n        for(auto _s:as){\n          S s = _s.first;\n          s2e[s].insert(make_pair(e,oe));\n        }\n        swap(a[0],a[1]);\n        swap(a[1],a[2]);\n        swap(a[2],a[3]);\n      }\n      for(auto _s:as){\n        S s = _s.first;\n        for(auto _t:as){\n          S t = _t.first;\n          s2s[s].insert(t);\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  // 1. determine first surface(a,b,c,d)\n  for(auto _s1:surfaces){\n    S s1 = _s1.first;\n    ll u1 = _s1.second.first * _s1.second.second;\n    int a = s1.first.first;\n    int b = s1.first.second;\n    int c = s1.second.first;\n    int d = s1.second.second;\n    // decrement\n    for(S s:s2s[s1])surfaces[s].first--;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first--;\n    // 2. determine second surface(e,f)\n    E e1 = pii(b,a);\n    for(auto _e2:edges[e1]){\n      E e2 = _e2.first;\n      ll u2 = u1 * _e2.second.first * _e2.second.second;\n      if(u2==0)continue;\n      int e = e2.first;\n      int f = e2.second;\n      // decrement\n      S s2 = make_pair(e1,e2);\n      for(S s:s2s[s2])surfaces[s].first--;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first--;\n      // 3. determine third surface(g,h)\n      E e3 = pii(d,c);\n      for(auto _e4:edges[e3]){\n        E e4 = _e4.first;\n        ll u3 = u2 * _e4.second.first * _e4.second.second;\n        if(u3==0)continue;\n        int g = e4.first;\n        int h = e4.second;\n        // decrement\n        S s3 = make_pair(e3,e4);\n        for(S s:s2s[s3])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first--;\n        // 4,5,6 the other 3 surfaces\n        S s4 = make_pair(pii(a,d),pii(h,e));\n        S s5 = make_pair(pii(e,h),pii(g,f));\n        S s6 = make_pair(pii(c,b),pii(f,g));\n        // s4\n        ll u4 = u3 * surfaces[s4].first * surfaces[s4].second;\n        for(S s:s2s[s4])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first--;\n        // s5\n        ll u5 = u4 * surfaces[s5].first * surfaces[s5].second;\n        for(S s:s2s[s5])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first--;\n        // s4\n        ll u6 = u5 * surfaces[s6].first * surfaces[s6].second;\n        for(S s:s2s[s6])surfaces[s].first--;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first--;\n        // add\n        ans += u6;\n        // s4\n        for(S s:s2s[s4])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s4])edges[e.first][e.second].first++;\n        // s5\n        for(S s:s2s[s5])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s5])edges[e.first][e.second].first++;\n        // s4\n        for(S s:s2s[s6])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s6])edges[e.first][e.second].first++;\n        // s3\n        for(S s:s2s[s3])surfaces[s].first++;\n        for(pair<E,E> e:s2e[s3])edges[e.first][e.second].first++;\n      }\n      for(S s:s2s[s2])surfaces[s].first++;\n      for(pair<E,E> e:s2e[s2])edges[e.first][e.second].first++;\n    }\n    for(S s:s2s[s1])surfaces[s].first++;\n    for(pair<E,E> e:s2e[s1])edges[e.first][e.second].first++;\n  }\n  printf(\"%lld\\n\",ans/24);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {}, e[16][4] = {};\n  \tfor (int i = 0; i < 16; i++) for (int j = 0; j < 4; j++) if (i & (1 << j)) e[i][j] = 1;\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n                int c[4] = {}, b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}};\n              \tll d[16] = {1};\n                for (int l = i + 1; l <= n; l++) {\n                  \tfor (int m = 0; m < 4; m++) {\n                      \tc[m] = 0;\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[m]++;\n                    }\n                    d[15] += c[0] * d[14];\n                    d[15] += c[1] * d[13];\n                    d[15] += c[2] * d[11];\n                    d[15] += c[3] * d[7];\n                    d[14] += c[1] * d[12];\n                    d[14] += c[2] * d[10];\n                    d[14] += c[3] * d[6];\n                    d[13] += c[0] * d[12];\n                    d[13] += c[2] * d[9];\n                    d[13] += c[3] * d[5];\n                    d[12] += c[2] * d[8];\n                    d[12] += c[3] * d[4];\n                    d[11] += c[0] * d[10];\n                    d[11] += c[1] * d[9];\n                    d[11] += c[3] * d[3];\n                    d[10] += c[1] * d[8];\n                    d[10] += c[3] * d[2];\n                    d[9] += c[0] * d[8];\n                    d[9] += c[3] * d[1];\n                    d[8] += c[3] * d[0];\n                    d[7] += c[0] * d[6];\n                    d[7] += c[1] * d[5];\n                    d[7] += c[2] * d[3];\n                    d[6] += c[1] * d[4];\n                    d[6] += c[2] * d[2];\n                    d[5] += c[0] * d[4];\n                    d[5] += c[2] * d[1];\n                    d[4] += c[2] * d[0];\n                    d[3] += c[0] * d[2];\n                    d[3] += c[1] * d[1];\n                    d[2] += c[1] * d[0];\n                    d[1] += c[0] * d[0];\n                }\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&x[i][j]);\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[i][1],x[i][0],x[ii][mp[j][0]],x[ii][mp[j][1]]);\n                    y[1] = pack(x[i][0],x[i][3],x[ii][mp[j][3]],x[ii][mp[j][0]]);\n                    y[2] = pack(x[i][3],x[i][2],x[ii][mp[j][2]],x[ii][mp[j][3]]);\n                    y[3] = pack(x[i][2],x[i][1],x[ii][mp[j][1]],x[ii][mp[j][2]]);\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m[y[p]];\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            m[a[i]]++;\n        }\n        printf(\"%I64d\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 405\n\nusing namespace std;\n\nstruct Node{\n\tint a[4];\n\t\n\tinline int & operator [] (int i){\n\t\treturn a[i];\n\t}\n\t\n\tfriend inline bool operator < (Node x, Node y){\n\t\tfor(register int i = 0;i < 4;i++){\n\t\t\tif(x[i] ^ y[i]) return x[i] < y[i];\n\t\t}\n\t\treturn false;\n\t}\n}a[maxn];\n\nmap<Node, int> mp;\n\ninline void add(Node &x, int y){\n\tNode a;\n\tfor(register int i = 0;i < 4;i++){\n\t\tfor(register int j = 0;j < 4;j++){\n\t\t\ta[j] = x[(i + j) % 4];\n\t\t} \n\t\tmp[a] += y; \n\t}\n}\n\nint n;\nlong long ans;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(register int i = 1;i <= n;i++){\n\t\tfor(register int j = 0;j < 4;j++){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tadd(a[i], 1);\n\t}\n\tfor(register int i = 1;i <= n;i++){\n\t\tadd(a[i], -1), reverse(a[i].a, a[i].a + 4);\n\t\tfor(register int j = 1;j < i;j++){\n\t\t\tadd(a[j], -1);\n\t\t\t//printf(\"%d %d %d %d--||\\n\", a[i][0], a[i][1], a[i][2], a[i][3]);\n\t\t\t//printf(\"%d %d %d %d--||\\n\", a[j][0], a[j][1], a[j][2], a[j][3]);\n\t\t\tfor(register int k = 0;k < 4;k++){\n\t\t\t\tlong long sum = 1;\n\t\t\t\tNode b[4];\n\t\t\t\tbool tag[4] = {0};\n\t\t\t\tfor(register int l = 0;l < 4;l++){\n\t\t\t\t\tb[l] = (Node){a[i][l], a[i][(l + 1) % 4], a[j][(l + 1 + k) % 4], a[j][(l + k) % 4]};\n\t\t\t\t\t//printf(\"%d %d %d %d %d--\\n\", a[i][l], a[i][(l + 1) % 4], a[j][(l + 1 + k) % 4], a[j][(l + k) % 4], mp[b]);\n\t\t\t\t\tint x = mp[b[l]];\n\t\t\t\t\tif(!x){\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum *= mp[b[l]], tag[l] = true;\n\t\t\t\t\tadd(b[l], -1);\n\t\t\t\t}\n\t\t\t\tans += sum;\n\t\t\t\tfor(register int l = 0;l < 4;l++) if(tag[l]) add(b[l], 1);\n\t\t\t} \n\t\t\tadd(a[j], 1);\n\t\t}\n\t\treverse(a[i].a, a[i].a + 4), add(a[i], 1);\n\t}\n\tprintf(\"%lld\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define X first\n#define Y second\nusing namespace std;\n\nconst int N=4e2+10;\n\nstruct info{\n    int a[4];\n    void roll(){\n        int tmp=a[3];\n        for(int i=3;i>=1;i--) a[i]=a[i-1];\n        a[0]=tmp;\n    }\n    info (int _a0=0,int _a1=0,int _a2=0,int _a3=0){\n        a[0]=_a0;\n        a[1]=_a1;\n        a[2]=_a2;\n        a[3]=_a3;\n    }\n};\nstruct infocomp{\n    bool operator ()(const info& a,const info& b){\n        for(int i=0;i<4;i++) if (a.a[i]!=b.a[i])\n            return a.a[i]<b.a[i];\n        return 0;\n    }\n};\nmap <info,int,infocomp> need,store;\nint n;\ninfo a[N];\n\nint tu1[5],tu2[5];\nvoid prepare(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<4;j++) scanf(\"%d\",&a[i].a[j]);\n        for(int j=0;j<4;j++){\n//            cout<<\"=>\";\n//                for(int k=0;k<4;k++) cout<<a[i].a[k]<<\" \\n\"[k==3];\n            store[a[i]]++;\n            a[i].roll();\n        }\n    }\n//    for(auto i:store) {\n//        for(int j=0;j<4;j++) cout<<i.X.a[j]<<\" \";\n//        cout<<i.Y<<'\\n';\n//    }\n}\nint getstorage(info a){\n    auto ite=store.find(a);\n    if (ite==store.end()) return 0;\n    return ite->Y;\n}\nvoid takestorage(info a,int val){\n    auto ite=store.find(a);\n    if (ite==store.end()) return;\n    store[a]-=val;\n}\nll A(int x,int y){\n    if (y>x||y<0) return 0;\n    ll ans=1;\n    for(int i=0;i<y;i++) ans*=(x-i);\n    return ans;\n}\nbool unidi(info a){\n    for(int i=1;i<4;i++) if (a.a[i]!=a.a[1]) return 0;\n    return 1;\n}\nll solve(){\n    ll ans=0;\n    for(int u1=1;u1<=n;u1++){\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]--;\n            a[u1].roll();\n        }\n        for(int u2=u1+1;u2<=n;u2++){\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]--;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                need.clear();\n                for(int i=0;i<5;i++) tu1[i]=a[u1].a[i%4];\n                for(int i=0;i<5;i++) tu2[i]=a[u2].a[(1-i+4)%4];\n                for(int i=0;i<4;i++) need[info(tu1[i+1],tu1[i],tu2[i],tu2[i+1])]++;\n                ll cans=1;\n                for(auto cur:need){\n                    if (unidi(cur.X)){\n                        int n1=getstorage(cur.X)/4;\n                        cans*=A(n1,cur.Y);\n                        for(int i=0;i<cur.Y;i++) cans*=4;\n                    }else cans*=A(getstorage(cur.X),min(cur.Y,3));\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,cur.Y);\n                        tmp.roll();\n                    }\n                }\n                for(auto cur:need){\n                    info tmp=cur.X;\n                    for(int dc=0;dc<4;dc++){\n                        takestorage(tmp,-cur.Y);\n                        tmp.roll();\n                    }\n                }\n                ans+=cans;\n                a[u2].roll();\n            }\n            for(int d2=0;d2<4;d2++){\n                store[a[u2]]++;\n                a[u2].roll();\n            }\n        }\n        for(int d1=0;d1<4;d1++){\n            store[a[u1]]++;\n            a[u1].roll();\n        }\n    }\n    return ans/3;\n}\nint main(){\n    prepare();\n    cout<<solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan in Ubuntu 18.10 on 2018/10/21 using VIM\n//版权所有，翻印必究\n\ntypedef pair<pii,pii> pp;\nint n;\nint C[405][5];\nmap<pp,int> m;\n\npp mp(int a,int b,int c,int d){\n\treturn mp(mp(a,b),mp(c,d));\n}\n\nvoid ins(int a,int b,int c,int d){\n\tm[mp(a,b,c,d)]++;\n\tm[mp(b,c,d,a)]++;\n\tm[mp(c,d,a,b)]++;\n\tm[mp(d,a,b,c)]++;\n}\n\nint same(pp p,pp q){\n\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\tint ans=0;\n\tif(q==mp(a,b,c,d)){\n\t\tans++;\n\t}\n\tif(q==mp(b,c,d,a)){\n\t\tans++;\n\t}\n\tif(q==mp(c,d,a,b)){\n\t\tans++;\n\t}\n\tif(q==mp(d,a,b,c)){\n\t\tans++;\n\t}\n\treturn ans;\n}\n\nvector<pp> v;\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>C[i][0]>>C[i][1]>>C[i][2]>>C[i][3];\n\t}\n\tINT ans=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=0;j<SZ(v);j++){\n\t\t\tpp p=v[j];\n\t\t\tint a=p.first.first,b=p.first.second,c=p.second.first,d=p.second.second;\n\t\t\tpp m1=mp(b,a,C[i][0],C[i][1]);\n\t\t\tpp m2=mp(c,b,C[i][1],C[i][2]);\n\t\t\tpp m3=mp(d,c,C[i][2],C[i][3]);\n\t\t\tpp m4=mp(a,d,C[i][3],C[i][0]);\n\t\t\tINT res=1;\n\t\t\tres*=m[m1]-same(p,m1);\n\t\t\tint fAck=same(m1,m2);\n\t\t\tres*=m[m2]-same(p,m2)-fAck;\n\t\t\tint fBck=same(m1,m3)+same(m2,m3);\n\t\t\tres*=m[m3]-same(p,m3)-fBck;\n\t\t\tint fCck=same(m1,m4)+same(m2,m4)+same(m3,m4);\n\t\t\tres*=m[m4]-same(p,m4)-fCck;\n\t\t\tans+=res;\n\t\t}\n\t\tint a=C[i][3],b=C[i][2],c=C[i][1],d=C[i][0];\n\t\tins(a,b,c,d);\n\t\tv.pb(mp(a,b,c,d));\n\t\tv.pb(mp(b,c,d,a));\n\t\tv.pb(mp(c,d,a,b));\n\t\tv.pb(mp(d,a,b,c));\n\t}\n\tfio<<ans<<endl;\n\treturn 0;\n}\n//再给我Submit Failed你就是徐十七！"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n  >         File: C.cc\n  >       Author: lyyllyyl\n  >         Mail: riho.yoshioka@yandex.com\n  > Created Time: Sat 15 Oct 2016 08:29:45 PM CST\n*************************************************************************/\n#include <bits/stdc++.h>\nusing LL = long long;\nconstexpr int N = 444;\nstd::vector<int> color[N];\nstd::map<std::vector<int>, int> has;\nint corner[8];\nint use[4][4] = {\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid Add(std::vector<int> color) {\n  for (int i = 0; i < 4; ++i) {\n    has[color]++;\n    std::rotate(color.begin(), color.begin() + 1, color.end());\n  }\n}\n\nvoid Hide(std::vector<int> color) {\n  for (int i = 0; i < 4; ++i) {\n    has[color]--;\n    std::rotate(color.begin(), color.begin() + 1, color.end());\n  }\n}\n\nvoid Dfs(int dep, LL& ans, LL res = 1) {\n  if (dep == 4) ans += res;\n  else {\n    std::vector<int> tmp(4);\n    for (int i = 0; i < 4; ++i) tmp[i] = corner[use[dep][i]];\n    if (has.count(tmp)) {\n      int cnt = has[tmp];\n      Hide(tmp);\n      Dfs(dep + 1, ans, res * cnt);\n      Add(tmp);\n    }\n  }\n}\n\nLL solve(int a, int b) {\n  for (int i = 0; i < 4; ++i) {\n    corner[i] = color[a][i];\n    corner[i + 4] = color[b][i];\n  }\n  LL ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    Dfs(0, ans);\n    std::rotate(corner + 4, corner + 5, corner + 8);\n  }\n  return ans;\n}\n\nint main() {\n  std::ios::sync_with_stdio(0);\n#ifdef HOME\n  std::string file(__FILE__);\n  freopen((file.substr(0, file.find('.')) + \".in\").c_str(), \"r\", stdin);\n#endif\n  int n;\n  std::cin >> n;\n  for (int i = 0; i < n; ++i) {\n    color[i].resize(4);\n    for (int j = 0; j < 4; ++j) {\n      std::cin >> color[i][j];\n    }\n    Add(color[i]);\n  }\n  LL answer = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      Hide(color[i]), Hide(color[j]);\n      answer += solve(i, j);\n      Add(color[i]), Add(color[j]);\n      //std::cerr << \"# i << ' ' << j << ' ' << answer # is \" << i << ' ' << j << ' ' << answer << std::endl;\n    }\n    Hide(color[i]);\n  }\n  std::cout << answer << std::endl;\n  std::cerr << \"---------------------------\" << std::endl;\n  std::cerr << \"Time used: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" sec.\" << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#include<map>\n#define maxn 405\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nstruct P{\n    int a1,a2,a3,a4;\n}c[maxn];\nmap<P,int>ma;\nll ans;\nbool operator < (P x,P y)\n{\n    if(x.a1!=y.a1)  return x.a1<y.a1;\n    if(x.a2!=y.a2)  return x.a2<y.a2;\n    if(x.a3!=y.a3)  return x.a3<y.a3;\n    return x.a4<y.a4;\n}\nint check(P x,P y)\n{\n    int res=0;\n    if(x.a1==y.a1&&x.a2==y.a2&&x.a3==y.a3&&x.a4==y.a4)  res++;\n    if(x.a1==y.a2&&x.a2==y.a3&&x.a3==y.a4&&x.a4==y.a1)  res++;\n    if(x.a1==y.a3&&x.a2==y.a4&&x.a3==y.a1&&x.a4==y.a2)  res++;\n    if(x.a1==y.a4&&x.a2==y.a1&&x.a3==y.a2&&x.a4==y.a3)  res++;    \n    return res;\n}\nvoid solve(P x,P y)\n{\n    P s1=(P){y.a1,y.a2,x.a2,x.a1};\n    P s2=(P){y.a3,y.a4,x.a4,x.a3};\n    P s3=(P){y.a2,y.a3,x.a3,x.a2};\n    P s4=(P){y.a4,y.a1,x.a1,x.a4};\n    int res1=ma[s1]-check(s1,x)-check(s1,y);\n    int res2=ma[s2]-check(s2,x)-check(s2,y)-check(s2,s1);\n    int res3=ma[s3]-check(s3,x)-check(s3,y)-check(s3,s2)-check(s3,s1);\n    int res4=ma[s4]-check(s4,x)-check(s4,y)-check(s4,s3)-check(s4,s2)-check(s4,s1);\n    ans+=1ll*res1*res2*res3*res4;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  c[i].a1=read(),c[i].a2=read(),c[i].a3=read(),c[i].a4=read();\n    for(int i=1;i<=n;i++)\n    {\n        ma[(P){c[i].a1,c[i].a2,c[i].a3,c[i].a4}]++;\n        ma[(P){c[i].a2,c[i].a3,c[i].a4,c[i].a1}]++;\n        ma[(P){c[i].a3,c[i].a4,c[i].a1,c[i].a2}]++;\n        ma[(P){c[i].a4,c[i].a1,c[i].a2,c[i].a3}]++;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i+1;j<=n;j++)\n        {\n            solve(c[i],(P){c[j].a2,c[j].a1,c[j].a4,c[j].a3});\n            solve(c[i],(P){c[j].a1,c[j].a4,c[j].a3,c[j].a2});\n            solve(c[i],(P){c[j].a4,c[j].a3,c[j].a2,c[j].a1});\n            solve(c[i],(P){c[j].a3,c[j].a2,c[j].a1,c[j].a4});\n        }\n    }\n    cout<<ans/3<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> ii;\n#define mkpr make_pair\n\nconst int N = 405;\nint n;\npair<ii, ii> c[N];\n\nmap<pair<ii, ii>, int> gesicht;\n\npair<ii, ii> rotate(pair<ii, ii> f) {\n\tpair<ii, ii> fans = f;\n\n\tint tmp = fans.second.second;\n\tfans.second.second = fans.second.first;\n\tfans.second.first = fans.first.second;\n\tfans.first.second = fans.first.first;\n\tfans.first.first = tmp;\n\n\treturn fans;\n}\n\nint main() {\n\tcin >> n;\n\tint c0, c1, c2, c3;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> c0 >> c1 >> c2 >> c3;\n\t\tc[i] = mkpr(mkpr(c0, c1), mkpr(c2, c3));\n\t\tpair<ii, ii> tmp = c[i];\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(gesicht.find(c[i]) == gesicht.end()) gesicht.insert(mkpr(c[i], 1));\n\t\t\telse gesicht[c[i]]++;\n\t\t\tc[i] = rotate(c[i]);\n\t\t}\n\t}\n\n\tlli ans = 0;\n\n\tfor(int f1i = 0; f1i < n; f1i++) {\n\t\tpair<ii, ii> f1 = c[f1i];\n\t\tfor(int f4i = f1i+1; f4i < n; f4i++) {\n\t\t\tpair<ii, ii> f4 = c[f4i];\n\t\t\tfor(int rot = 0; rot < 4; rot++) {\n\t\t\t\tlli partAns = 1;\n\t\t\t\tpair<ii, ii> f2, f3, f5, f6;\n\t\t\t\tf2 = mkpr(mkpr(f1.first.second, f4.first.first), mkpr(f4.second.second, f1.second.first));\n\t\t\t\tf3 = mkpr(mkpr(f1.second.first, f4.second.second), mkpr(f4.second.first, f1.second.second));\n\t\t\t\tf5 = mkpr(mkpr(f1.second.second, f4.second.first), mkpr(f4.first.second, f1.first.first));\n\t\t\t\tf6 = mkpr(mkpr(f1.first.first, f4.first.second), mkpr(f4.first.first, f1.first.second));\n\n\t\t\t\tint matches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f2 == f1) matches++; if(f2 == f4) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f2]-matches);\n\n\t\t\t\tmatches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f3 == f1) matches++; if(f3 == f4) matches++; if(f3 == f2) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4); f2 = rotate(f2);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f3]-matches);\n\n\t\t\t\tmatches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f5 == f1) matches++; if(f5 == f4) matches++; if(f5 == f2) matches++; if(f5 == f3) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4); f2 = rotate(f2); f3 = rotate(f3);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f5]-matches);\n\n\t\t\t\tmatches = 0;\n\t\t\t\tfor(int subrot = 0; subrot < 4; subrot++) {\n\t\t\t\t\tif(f6 == f1) matches++; if(f6 == f4) matches++; if(f6 == f2) matches++; if(f6 == f3) matches++; if(f6 == f5) matches++;\n\t\t\t\t\tf1 = rotate(f1); f4 = rotate(f4); f2 = rotate(f2); f3 = rotate(f3); f5 = rotate(f5);\n\t\t\t\t}\n\t\t\t\tpartAns *= (gesicht[f6]-matches);\n\n\t\t\t\tans += partAns;\n\t\t\t\tf4 = rotate(f4);\n\t\t\t}\n\t\t}\n\t}\n\n\tans /= 3; //Answers are overcounted twice\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#define maxn 405\n#define LL long long\nusing namespace std;\nint n,c[maxn][8];\nLL ans,u[4];\nmap<LL,LL> mp;\nLL F(LL a,LL b,LL c,LL d)\n{\n\treturn a<<30|b<<20|c<<10|d;\n}\nvoid add(LL x,LL v)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tmp[x]+=v;\n\t\tx=(x>>10)|(x&1023)<<30;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t\tc[i][j+4]=c[i][j];\n\t\t}\n\t\tadd(F(c[i][0],c[i][1],c[i][2],c[i][3]),1);\n\t\t//printf(\"%lld\\n\",F(c[i][0],c[i][1],c[i][2],c[i][3]));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(F(c[i][0],c[i][1],c[i][2],c[i][3]),-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tadd(F(c[j][0],c[j][1],c[j][2],c[j][3]),-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tLL r=1ll;\n\t\t\t\tu[0]=F(c[j][k+1],c[j][k+0],c[i][1],c[i][0]);\n\t\t\t\tu[1]=F(c[j][k+0],c[j][k+3],c[i][2],c[i][1]);\n\t\t\t\tu[2]=F(c[j][k+3],c[j][k+2],c[i][3],c[i][2]);\n\t\t\t\tu[3]=F(c[j][k+2],c[j][k+1],c[i][4],c[i][3]);\n\t\t\t\tif(mp[u[0]]&&mp[u[1]]&&mp[u[2]]&&mp[u[3]])\n\t\t\t\t{\n\t\t\t\t\tr*=mp[u[0]]; add(u[0],-1);\n\t\t\t\t\tr*=mp[u[1]]; add(u[1],-1);\n\t\t\t\t\tr*=mp[u[2]]; add(u[2],-1);\n\t\t\t\t\tr*=mp[u[3]];\n\t\t\t\t\tadd(u[2],1);\n\t\t\t\t\tadd(u[1],1);\n\t\t\t\t\tadd(u[0],1);\n\t\t\t\t\tans+=r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(F(c[j][0],c[j][1],c[j][2],c[j][3]),1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n */\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n\n#define MAX_N 405\n#define MAX_C 1000\n\nusing namespace std;\ntypedef long long ll;\n\nint c[MAX_N][4];\n\nll calc(ll c0, ll c1, ll c2, ll c3) {\n    return c0 * MAX_C * MAX_C * MAX_C + c1  * MAX_C * MAX_C + c2 * MAX_C + c3;\n}\n\nll normalizeC(int* start) {\n    ll minimum = calc(start[0], start[1], start[2], start[3]);\n    for (int i = 0; i < 4; ++i) {\n        ll next = calc(start[(0+i)%4], start[(1+i)%4], start[(2+i)%4], start[(3+i)%4]);\n        if (minimum > next) {\n            minimum = next;\n        }\n    }\n    return minimum;\n}\n\nll normalizeC(int a, int b, int c, int d) {\n    int s[4] = {a, b, c, d};\n    return normalizeC(s);\n}\n\nll multi(int a, int b, int c, int d) {\n    if (a==b && b==c && c==d) return 4;\n    if (a==c && b == d) return 2;\n    else return 1;\n}\n\nint main(){\n    //freopen(\"e3.in\", \"r\", stdin);\n    int n;\n    scanf(\"%d\", &n);\n\n    map<ll, int> tileMap;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", &c[i][0], &c[i][1], &c[i][2], &c[i][3]);\n        ll key = normalizeC(c[i]);\n        tileMap[key]++;\n        //cout << key << \": \" <<tileMap[key] << endl;\n    }\n\n    ll total = 0;\n    for (int i = 0; i < n; ++i) {        // Determine side '1'\n        for (int j = i+1; j < n; ++j) {  // Determine side '5'\n            ll key1 = normalizeC(c[i]);\n            ll key5 = normalizeC(c[j]);\n            tileMap[key1]--;\n            tileMap[key5]--;\n            for (int k = 0; k < 4; ++k) {// Determine rotation of '5'\n                ll key2 = normalizeC(c[i][0], c[j][(1+k)%4], c[j][(0+k)%4], c[i][1]);\n                ll multiple2 = multi(c[i][0], c[j][(1+k)%4], c[j][(0+k)%4], c[i][1]);\n                ll key3 = normalizeC(c[i][1], c[j][(0+k)%4], c[j][(3+k)%4], c[i][2]);\n                ll multiple3 = multi(c[i][1], c[j][(0+k)%4], c[j][(3+k)%4], c[i][2]);\n                ll key4 = normalizeC(c[i][2], c[j][(3+k)%4], c[j][(2+k)%4], c[i][3]);\n                ll multiple4 = multi(c[i][2], c[j][(3+k)%4], c[j][(2+k)%4], c[i][3]);\n                ll key6 = normalizeC(c[j][(1+k)%4], c[i][0], c[i][3], c[j][(2+k)%4]);\n                ll multiple6 = multi(c[j][(1+k)%4], c[i][0], c[i][3], c[j][(2+k)%4]);\n                //cout << key1 << \" \" << key5 << \": \" << key2 << \" \" << key3 << \" \"<< key4 << \" \" << key6 << endl;\n                //cout << tileMap[key2] << \" \" << tileMap[key3] << \" \"<< tileMap[key4] << \" \" << tileMap[key6] << endl;\n                ll tmp;\n                tmp = tileMap[key2] * multiple2;  tileMap[key2]--;\n                tmp *= tileMap[key3] * multiple3;  tileMap[key3]--;\n                tmp *= tileMap[key4] * multiple4;  tileMap[key4]--;\n                tmp *= tileMap[key6] * multiple6;\n                tileMap[key2]++; tileMap[key3]++; tileMap[key4]++;\n                total += tmp;\n            }\n            tileMap[key1]++;\n            tileMap[key5]++;\n        }\n    }\n    printf(\"%lli\\n\", total/3);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nusing std::map;\nusing std::min;\nusing std::sort;\n\nconst int N=410;\n\nint n,c[N][4],put[4],C[N][5],fact[5];\nLL h[N];\nmap<LL,int>app;\n\nLL Hash(int *c) {\n\tfor (int w=0;w<4;++w) put[w]=c[w];\n\tfor (int j=1;j<4;++j)\n\t\tfor (int k=0;k<4;++k) {\n\t\t\tif (c[(j+k)%4]>put[k]) break;\n\t\t\tif (c[(j+k)%4]<put[k]) {\n\t\t\t\tfor (int w=0;w<4;++w) put[w]=c[(j+w)%4];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tLL h=0;\n\tfor (int j=0;j<4;++j) h=h*1000+put[j];\n\treturn h;\n}\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int j=0;j<4;++j) scanf(\"%d\",&c[i][j]);\n\t\th[i]=Hash(c[i]);\n\t\tapp[h[i]]++;\n\t}\n}\n\nvoid Prepare() {\n\tfor (int i=0;i<=n;++i) {\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=min(i,4);++j)\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j]; \n\t}\n\tfact[0]=1; for (int i=1;i<=4;++i) fact[i]=fact[i-1]*i;\n}\n\nint Same(LL x) {\n\tint cnt=0; LL p=x;\n\tfor (int i=3;i>=0;--i) put[i]=p%1000,p/=1000; \n\tfor (int i=0;i<4;++i) {\n\t\tLL h=0ll;\n\t\tfor (int k=0;k<4;++k) h=h*1000+put[(i+k)%4];\n\t\tif (h==x) cnt++;\n\t}\n\treturn cnt;\n}\n\nint qpow(int x,int t) {\n\tif (x==1 || !t) return 1;\n\tint ret=1;\n\twhile (t) {\n\t\tif (t&1) ret=ret*x;\n\t\tx=x*x;\n\t\tt>>=1;\n\t}\n\treturn ret;\n}\n\nvoid Solve() {\n\tPrepare();\n\tLL ans=0; int p[4];\n\tfor (int i=1;i<=n;++i) {\n\t\tapp[h[i]]--;\n\t\tfor (int j=i+1;j<=n;++j) {\n\t\t\tint a=0; app[h[j]]--;\n//\t\t\tfor (int a=0;a<4;++a)\n\t\t\t\tfor (int b=0;b<4;++b) {\n\t\t\t\t\tLL t[4];\n\t\t\t\t\tp[0]=c[j][(1+b)&3]; p[1]=c[j][(0+b)%4]; p[2]=c[i][(1+a)%4]; p[3]=c[i][(0+a)%4]; t[0]=Hash(p);\n\t\t\t\t\tp[0]=c[i][(1+a)&3]; p[1]=c[j][(0+b)%4]; p[2]=c[j][(3+b)%4]; p[3]=c[i][(2+a)%4]; t[1]=Hash(p);\n\t\t\t\t\tp[0]=c[i][(3+a)%4]; p[1]=c[i][(2+a)%4]; p[2]=c[j][(3+b)%4]; p[3]=c[j][(2+b)%4]; t[2]=Hash(p);\n\t\t\t\t\tp[0]=c[j][(1+b)%4]; p[1]=c[i][(0+a)%4]; p[2]=c[i][(3+a)%4]; p[3]=c[j][(2+b)%4]; t[3]=Hash(p);\n\t\t\t\t\tsort(t,t+4); LL now=1ll;\n\t\t\t\t\tfor (int i=0;i<4;) {\n\t\t\t\t\t\tint pos=i;\n\t\t\t\t\t\twhile (t[i]==t[pos] && i<4) ++i;\n\t\t\t\t\t\tint p=app[t[pos]];\n\t\t\t\t\t\tif (now && p)\n\t\t\t\t\t\t\tp++,p--;\n\t\t\t\t\t\tnow=1ll*now*C[p][i-pos]*fact[i-pos]*qpow(Same(t[pos]),i-pos);\n\t\t\t\t\t}\n\t\t\t\t\tans+=now;\n\t\t\t\t}\n\t\t\tapp[h[j]]++;\n\t\t}\n\t\tapp[h[i]]++;\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ninline int GetBit(int mask, int num) {\n    return (mask >> num) & 1;\n}\n\nint cFront[4];\nint cBack[4];\n\ninline long long GetId(int c0, int c1, int c2, int c3) {\n    return c0 + 1000LL * (c1 + 1000LL * (c2 + 1000LL * c3));\n}\n\ninline long long GetLeftId() {\n    return GetId(cBack[3], cBack[2], cFront[1], cFront[0]);\n}\n\ninline long long GetRightId() {\n    return GetId(cFront[3], cFront[2], cBack[1], cBack[0]);\n}\n\ninline long long GetUpId() {\n    return GetId(cFront[1], cBack[2], cBack[1], cFront[2]);\n}\n\ninline long long GetDownId() {\n    return GetId(cBack[3], cFront[0], cFront[3], cBack[0]);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<vector<long long>> colors(n, vector<long long>(8));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> colors[i][j];\n            colors[i][j + 4] = colors[i][j];\n        }\n    }\n\n    unordered_map<long long, int> colorCount;\n\n    vector<vector<int>> normColors;\n\n    unordered_map<long long, int> colorIds;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            colors[i][j] = GetId(colors[i][j], colors[i][j + 1], colors[i][j + 2], colors[i][j + 3]);\n        }\n\n        for (int j = 0; j < 4; ++j) {\n            if (colorIds.find(colors[i][j]) == colorIds.end()) {\n                colorIds[colors[i][j]] = (int) normColors.size();\n                normColors.push_back(vector<int>());\n            }\n        }\n\n        for (int j = 0; j < 4; ++j) {\n            const int curId = colorIds[colors[i][j]];\n\n            ++colorCount[curId];\n\n            if (normColors[curId].empty()) {\n                for (int s = 0; s < 4; ++s) {\n                    normColors[curId].push_back(colorIds[colors[i][(j + s) % 4]]);\n                }\n            }\n        }\n    }\n\n    long long glResult = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int t = 0; t < 4; ++t) {\n            cFront[t] = colors[i][t];\n        }\n        for (int t = 0; t < 4; ++t) {\n            --colorCount[colorIds[colors[i][t]]];\n        }\n\n        for (int j = i + 1; j < n; ++j) {\n            for (int t = 0; t < 4; ++t) {\n                --colorCount[colorIds[colors[j][t]]];\n            }\n\n            for (int dj = 0; dj < 4; ++dj) {\n                for (int t = 0; t < 4; ++t) {\n                    cBack[t] = colors[j][dj + t];\n                }\n\n                long long curIds[4];\n\n                curIds[0] = GetLeftId();\n                curIds[1] = GetRightId();\n                curIds[2] = GetUpId();\n                curIds[3] = GetDownId();\n\n                long long result = 1;\n\n                for (int t = 0; t < 4; ++t) {\n                    if (colorIds.find(curIds[t]) == colorIds.end()) {\n                        result = 0;\n                        continue;\n                    }\n\n                    const int id = colorIds[curIds[t]];\n\n                    result *= colorCount[id];\n\n                    for (int x : normColors[id]) {\n                        --colorCount[x];\n                    }\n                }\n\n                for (int t = 0; t < 4; ++t) {\n                    if (colorIds.find(curIds[t]) == colorIds.end()) {\n                        continue;\n                    }\n\n                    const int id = colorIds[curIds[t]];\n\n                    for (int x : normColors[id]) {\n                        ++colorCount[x];\n                    }\n                }\n\n                glResult += result;\n            }\n\n            for (int t = 0; t < 4; ++t) {\n                ++colorCount[colorIds[colors[j][t]]];\n            }\n        }\n    }\n\n    cout << glResult << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define INF 2147483647\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\n#define _ 0\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nnamespace Mymath{\n\tLL qp(LL x,LL p,LL mod){\n\t\tLL ans=1;\n\t\twhile (p){\n\t\t\tif (p&1) ans=ans*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tp>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tLL inv(LL x,LL mod){\n\t\treturn qp(x,mod-2,mod);\n\t}\n\tLL C(LL N,LL K,LL fact[],LL mod){\n\t\treturn fact[N]*inv(fact[K],mod)%mod*inv(fact[N-K],mod)%mod;\n\t}\n\ttemplate <typename Tp> Tp gcd(Tp A,Tp B){\n\t\tif (B==0) return A;\n\t\treturn gcd(B,A%B);\n\t}\n\ttemplate <typename Tp> Tp lcm(Tp A,Tp B){\n\t\treturn A*B/gcd(A,B);\n\t}\n};\nnamespace fwt{\n\tusing namespace Mymath;\n\tvoid FWT(int a[],int n,LL mod)\n\t{\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;\n\t                //xor:a[i+j]=x+y,a[i+j+d]=x-y;\n\t                //and:a[i+j]=x+y;\n\t                //or:a[i+j+d]=x+y;\n\t            }\n\t}\n\n\tvoid UFWT(int a[],int n,LL mod)\n\t{\n\t\tLL rev=inv(2,mod);\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;\n\t                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n\t                //and:a[i+j]=x-y;\n\t                //or:a[i+j+d]=y-x;\n\t            }\n\t}\n\tvoid solve(int a[],int b[],int n,LL mod)\n\t{\n\t    FWT(a,n,mod);\n\t    FWT(b,n,mod);\n\t    for(int i=0;i<n;i++) a[i]=1LL*a[i]*b[i]%mod;\n\t    UFWT(a,n,mod);\n\t}\n};\nnamespace Maxflow{\n\tconst int Maxn=1005;\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tedge(int _to,int _rev,int _cap){\n\t\t\tto=_to,rev=_rev,cap=_cap;\n\t\t}\n\t};\n\tint src=1002,snk=1003;\n\tvector<edge> G[Maxn];\n\tint dist[Maxn],seen[Maxn];\n\tint n;\n\tvoid Clear(){\n\t\tfor (int i=0;i<Maxn;i++) G[i].clear();\n\t}\n\tvoid bfs(int s){\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=-1;\n\t\tdist[s]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()){\n\t\t\tint x=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tedge &e=G[x][i];\n\t\t\t\tif (e.cap && dist[e.to]==-1){\n\t\t\t\t\tdist[e.to]=dist[x]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int now,int dest,int fl){\n\t\tif (now==dest) return fl;\n\t\tfor (int &i=seen[now];i<G[now].size();i++){\n\t\t\tedge &ed=G[now][i];\n\t\t\tif (ed.cap && dist[ed.to]==dist[now]+1){\n\t\t\t\tint f=dfs(ed.to,dest,min(fl,ed.cap));\n\t\t\t\tif (f){\n\t\t\t\t\ted.cap-=f;\n\t\t\t\t\tG[ed.to][ed.rev].cap+=f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dinic(int s=src,int t=snk){\n\t\tint ret=0;\n\t\twhile (1){\n\t\t\tmemset(seen,0,sizeof(seen));\n\t\t\tbfs(s);\n\t\t\tif (dist[t]==-1) return ret;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\twhile(f){\n\t\t\t\tret+=f;\n\t\t\t\tf=dfs(s,t,INF);\n\t\t\t}\n\t\t}\n\t}\n};\nnamespace Geometry{\n\tstruct iP{\n\t\tLL x,y;\n\t\tiP(LL _x,LL _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tiP(){\n\t\t\tx=y=0;\n\t\t}\n\t\tiP operator +(iP p){\n\t\t\treturn iP(x+p.x,y+p.y);\n\t\t}\n\t\tiP operator -(iP p){\n\t\t\treturn iP(x-p.x,y-p.y);\n\t\t}\n\t\tiP operator *(LL k){\n\t\t\treturn iP(x*k,y*k);\n\t\t}\n\t\tLL det(iP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tLL dot(iP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tLL dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const iP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tstruct dP{\n\t\tdouble x,y;\n\t\tdP(double _x,double _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tdP(){\n\t\t\tx=y=0.0;\n\t\t}\n\t\tdP operator +(dP p){\n\t\t\treturn dP(x+p.x,y+p.y);\n\t\t}\n\t\tdP operator -(dP p){\n\t\t\treturn dP(x-p.x,y-p.y);\n\t\t}\n\t\tdP operator *(double k){\n\t\t\treturn dP(x*k,y*k);\n\t\t}\n\t\tdouble det(dP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tdouble dot(dP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tdouble dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const dP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tvector<iP> convex_hull(iP X[],int l){\n\t\t#define sz ret.size()\n\t\tvector<iP> ret;\n\t\tsort(X+1,X+1+l);\n\t\tret.pb(X[1]);\n\t\tfor (int i=2;i<=l;i++){\n\t\t\twhile (sz>=2 && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\tint rs=ret.size()+1;\n\t\tfor (int i=l-1;i>=1;i--){\n\t\t\twhile (sz>=rs && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst int Maxn=405;\nint c[Maxn][4];\nint n;\nint now[4][4];\nint cc[Maxn][4];\nLL V[4];\nLL ha[Maxn][4];\nLL dp[16],dp2[16];\nmap<pair<LL,LL>,LL> D;\nset<LL> S;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++){\n\t\t\tscanf(\"%d\",&c[i][j]);\n\t\t}\n\t\tfor (int st=0;st<4;st++){\n\t\t\tha[i][st]=0;\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tha[i][st]*=1000LL;\n\t\t\t\tha[i][st]+=c[i][(st+k)%4];\n\t\t\t}\n\t\t//\tcout<<ha[i][st]<<endl;\n\t\t}\n\t\tS.insert(ha[i][0]);\n\t}\n\tif (S.size()<=50){\n\t\tLL ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tLL dlt=0;\n\t\t\tbool ff=false;\n\t\t\tfor (int p1=0;p1<4;p1++){\n\t\t\t\tfor (int p2=0;p2<4;p2++){\n\t\t\t\t\tif (D.count(mp(ha[i][p1],ha[j][p2]))){\n\t\t\t\t\t\tff=true;\n\t\t\t\t\t\tans+=D[mp(ha[i][p1],ha[j][p2])];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ff) break;\n\t\t\t}\n\t\t\tif (ff) continue;\n\t\t\tfor (int k=0;k<4;k++){\n//\t\t\t\tbool flag=true;\n\t\t\t\tnow[0][0]=c[j][k];\n\t\t\t\tnow[0][1]=c[j][(k+3)%4];\n\t\t\t\tnow[0][2]=c[i][1];\n\t\t\t\tnow[0][3]=c[i][0];\n\t\t\t\t\n\t\t\t\tnow[1][0]=c[j][(k+3)%4];\n\t\t\t\tnow[1][1]=c[j][(k+2)%4];\n\t\t\t\tnow[1][2]=c[i][2];\n\t\t\t\tnow[1][3]=c[i][1];\n\t\t\t\t\n\t\t\t\tnow[2][0]=c[j][(k+2)%4];\n\t\t\t\tnow[2][1]=c[j][(k+1)%4];\n\t\t\t\tnow[2][2]=c[i][3];\n\t\t\t\tnow[2][3]=c[i][2];\n\t\t\t\t\n\t\t\t\tnow[3][0]=c[j][(k+1)%4];\n\t\t\t\tnow[3][1]=c[j][(k)%4];\n\t\t\t\tnow[3][2]=c[i][0];\n\t\t\t\tnow[3][3]=c[i][3];\n\t\t\t\t\n\t\t\t\tfor (int l=0;l<4;l++){\n\t\t\t\t\tV[l]=0;\n\t\t\t\t\tfor (int o=0;o<4;o++){\n\t\t\t\t\t\tV[l]=V[l]*1000+now[l][o];\n\t\t\t\t\t}\n\t\t\t\t\t//if (i==1 && j==5) cout<<k<<' '<<V[l]<<endl;\n\t\t\t\t//\tcout<<V[l]<<endl;\n\t\t\t\t}\n\t\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t\tdp[0]=1;\n\t\t\t\tfor (int l=1;l<=n;l++){\n\t\t\t\t\tif (l==i || l==j) continue;\n\t\t\t\t\tmemset(dp2,0,sizeof(dp2));\n\t\t\t\t\tfor (int jj=0;jj<4;jj++){\n\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\tfor (int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\tif (ha[l][kk]==V[jj]) cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (cnt){\n\t\t\t\t\t\t//\tcout<<cnt<<endl;\n\t\t\t\t\t\t\tfor (int q=15;q>=0;q--){\n\t\t\t\t\t\t\t\tif (q>>jj&1){\n\t\t\t\t\t\t\t\t\tdp2[q]+=dp[q^(1<<jj)]*cnt;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int jj=0;jj<16;jj++) dp[jj]+=dp2[jj];\n\t\t\t\t}\n\t\t\t\t//cout<<dp[15]<<endl;\n\t\t\t\tdlt+=dp[15];\n\t\t\t}\n\t\t\tD[mp(ha[i][0],ha[j][0])]=dlt;\n\t\t\tans+=dlt;\n\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans/3);\n\t}\n\telse\n\t{\n\t\tLL ans=0;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tfor (int j=i+1;j<=n;j++){\n\t\t\t\tfor (int k=0;k<4;k++){\n\t//\t\t\t\tbool flag=true;\n\t\t\t\t\tnow[0][0]=c[j][k];\n\t\t\t\t\tnow[0][1]=c[j][(k+3)%4];\n\t\t\t\t\tnow[0][2]=c[i][1];\n\t\t\t\t\tnow[0][3]=c[i][0];\n\t\t\t\t\t\n\t\t\t\t\tnow[1][0]=c[j][(k+3)%4];\n\t\t\t\t\tnow[1][1]=c[j][(k+2)%4];\n\t\t\t\t\tnow[1][2]=c[i][2];\n\t\t\t\t\tnow[1][3]=c[i][1];\n\t\t\t\t\t\n\t\t\t\t\tnow[2][0]=c[j][(k+2)%4];\n\t\t\t\t\tnow[2][1]=c[j][(k+1)%4];\n\t\t\t\t\tnow[2][2]=c[i][3];\n\t\t\t\t\tnow[2][3]=c[i][2];\n\t\t\t\t\t\n\t\t\t\t\tnow[3][0]=c[j][(k+1)%4];\n\t\t\t\t\tnow[3][1]=c[j][(k)%4];\n\t\t\t\t\tnow[3][2]=c[i][0];\n\t\t\t\t\tnow[3][3]=c[i][3];\n\t\t\t\t\t\n\t\t\t\t\tfor (int l=0;l<4;l++){\n\t\t\t\t\t\tV[l]=0;\n\t\t\t\t\t\tfor (int o=0;o<4;o++){\n\t\t\t\t\t\t\tV[l]=V[l]*1000+now[l][o];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//if (i==1 && j==5) cout<<k<<' '<<V[l]<<endl;\n\t\t\t\t\t//\tcout<<V[l]<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t\t\tdp[0]=1;\n\t\t\t\t\tfor (int l=i+1;l<=n;l++){\n\t\t\t\t\t\tif (l==i || l==j) continue;\n\t\t\t\t\t\tmemset(dp2,0,sizeof(dp2));\n\t\t\t\t\t\tfor (int jj=0;jj<4;jj++){\n\t\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\tfor (int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\t\tif (ha[l][kk]==V[jj]) cnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (cnt){\n\t\t\t\t\t\t\t//\tcout<<cnt<<endl;\n\t\t\t\t\t\t\t\tfor (int q=15;q>=0;q--){\n\t\t\t\t\t\t\t\t\tif (q>>jj&1){\n\t\t\t\t\t\t\t\t\t\tdp2[q]+=dp[q^(1<<jj)]*cnt;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int jj=0;jj<16;jj++) dp[jj]+=dp2[jj];\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<dp[15]<<endl;\n\t\t\t\t\tans+=dp[15];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\n\nmap<pii,int> cnt[1111][1111];\nstruct tile\n{\n\tint c[4];\n\ttile(int a1,int a2,int a3,int a4){c[0]=a1;c[1]=a2;c[2]=a3;c[3]=a4;}\n\ttile(){}\n\tvoid add(int x){for(int i=0;i<4;i++)cnt[c[i]][c[i+1&3]][mp(c[i+2&3],c[i+3&3])]+=x;}\n\tint getnum(){return cnt[c[0]][c[1]][mp(c[2],c[3])];}\n\ttile rev()\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i]=c[i^3];\n\t\treturn ret;\n\t}\n\ttile rotate(int x)\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i+x&3]=c[i];\n\t\treturn ret;\n\t}\n\ttile print(){printf(\"tile %d %d %d %d\\n\",c[0],c[1],c[2],c[3]);}\n}a[411],tmp[4];\n\nLL getnum(const tile up,const tile down)\n{\n\tLL ret=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n//\t\tcur.print();printf(\"num= %d\\n\",cur.getnum());\n\t\tret*=cur.getnum();\n\t\tcur.add(-1);\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n\t\tcur.add(1);\n\t}\n\treturn ret;\n}\nint n;\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t\tget1(a[i].c[j]);\n\t\ta[i].add(1);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i].add(-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\ta[j].add(-1);\n\t\t\tfor(int k=0;k<4;k++)ans+=getnum(a[i],a[j].rev().rotate(k));\n\t\t\ta[j].add(1);\n\t\t}\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ndeque<int> f(deque<int> d) {\n\tdeque<int> ret = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d.front());\n\t\td.pop_front();\n\t\tret = min(ret, d);\n\t}\n\treturn ret;\n}\n\nint count_overlap(deque<int> d) {\n\tint ret = 1;\n\tdeque<int> t = d;\n\tfor(int i = 0; i < 3; i++) {\n\t\td.push_back(d.front());\n\t\td.pop_front();\n\t\tif(t == d) ret++;\n\t}\n\treturn ret;\n}\n\ndeque<int> C[400];\nll P[5];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tP[0] = 1;\n\tfor(int i = 1; i <= 4; i++) {\n\t\tP[i] = P[i - 1] * i;\n\t}\n\n\tint N;\n\tcin >> N;\n\n\tmap<deque<int>, int> m;\n\tmap<deque<int>, int> cnt;\n\tfor(int i = 0; i < N; i++) {\n\t\tdeque<int> d;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\td.push_back(c);\n\t\t}\n\t\td = f(d);\n\t\tC[i] = d;\n\t\tm[d]++;\n\t}\n\n\tfor(auto p : m) {\n\t\tcnt[p.first] = count_overlap(p.first);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tdeque<int> d1 = C[i];\n\t\tm[d1]--;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tif(i == j) continue;\n\t\t\tdeque<int> d2 = C[j];\n\t\t\tm[d2]--;\n\t\t\tfor(int r1 = 0; r1 < 4; r1++) {\n\t\t\t\tmap<deque<int>, int> t;\n\t\t\t\tdeque<int> p1({ d1[1], d1[0], d2[1], d2[0] });\n\t\t\t\tdeque<int> p2({ d1[0], d1[3], d2[2], d2[1] });\n\t\t\t\tdeque<int> p3({ d1[3], d1[2], d2[3], d2[2] });\n\t\t\t\tdeque<int> p4({ d1[2], d1[1], d2[0], d2[3] });\n\t\t\t\tt[f(p1)]++;\n\t\t\t\tt[f(p2)]++;\n\t\t\t\tt[f(p3)]++;\n\t\t\t\tt[f(p4)]++;\n\t\t\t\tll k = 1;\n\t\t\t\tfor(auto p : t) {\n\t\t\t\t\tif(!m.count(p.first) || m[p.first] < p.second) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk *= P[p.second];\n\t\t\t\t\tfor(int loop = 0; loop < p.second; loop++) {\n\t\t\t\t\t\tk *= cnt[p.first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += k;\n\t\t\t\td1.push_back(d1[0]);\n\t\t\t\td1.pop_front();\n\t\t\t}\n\t\t\tm[d2]++;\n\t\t}\n\t\tm[d1]++;\n\t}\n\n\tcout << ans / 6 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <cassert>\n#include <complex>\n#include <time.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define DBG1(a) cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBG2(a,b) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef unsigned long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = 1LL * INF * INF;\n\nmap<vector<int>, int> M;\nmap<pair<int, int>, set<pair<int, int> > > M2;\n\nvoid print(vector<int> a)\n{\n\tFOR(i, 0, SZ(a))\n\t{\n\t\tcout << a[i] << ' ';\n\t}\n\tcout << endl;\n}\n\nvoid add(vector<int> a, int sign)\n{\n\tFOR(i, 0, 4)\n\t{\n\t\tM[a] += sign;\n\t\ta.PB(a[0]);\n\t\ta.erase(a.begin());\n\t}\n}\n\nint main() \n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(0);cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tFOR(i, 0, n)\n\t{\n\t\tvector<int> a(4);\n\t\tFOR(j, 0, 4)\n\t\t{\n\t\t\tcin >> a[j];\n\t\t//\ta[j] = rand() % 10;\n\t\t//\ta[j] = 0;\n\t\t}\n\n\t\tFOR(j, 0, 4)\n\t\t{\n\t\t//\tprint(a);\n\t\t\tM[a]++;\n\t\t\ta.PB(a[0]);\n\t\t\ta.erase(a.begin());\n\t\t}\n\n\t\tFOR(j, 0, 4)\n\t\t{\n\t\t//\tprint(a);\n\t\t\tM2[MP(a[0], a[1])].insert(MP(a[2], a[3]));\n\t\t\ta.PB(a[0]);\n\t\t\ta.erase(a.begin());\n\t\t}\n\t//\tcout << endl;\n\t}\n\n//\treturn 0;\n\n\tLL res = 0;\n\t\n\tfor (map<vector<int>, int>::iterator it = M.begin(); it != M.end(); it++)\n\t{\n\t\tvector<int> a = it->first;\n\t\tpair<int, int> up = MP(a[1], a[0]);\n\t\tpair<int, int> down = MP(a[3], a[2]);\n\t\t\n\t\tif (!M2.count(up) || !M2.count(down)) continue;\n\n\t\tset<pair<int, int> > &U = M2[up];\n\t\tset<pair<int, int> > &D = M2[down];\n\n\t\tfor (set<pair<int, int> > ::iterator it1 = U.begin(); it1 != U.end(); it1++)\n\t\t{\n\t\t\tfor (set<pair<int, int> > ::iterator it2 = D.begin(); it2 != D.end(); it2++)\n\t\t\t{\n\t\t\t\tLL u, d, l, r, b, f;\n\t\t\t\tf = M[a];\n\t\t\t\tvector<int> UP = { up.first, up.second, it1->first, it1->second };\n\t\t\t\tif (!M.count(UP)) continue;\n\t\t\t\tvector<int> DOWN = { down.first, down.second, it2->first, it2->second };\n\t\t\t\tif (!M.count(DOWN)) continue;\n\t\t\t\tvector<int> LEFT = { a[0], a[3], it2->second, it1->first };\n\t\t\t\tif (!M.count(LEFT)) continue;\n\t\t\t\tvector<int> RIGHT = { a[1], it1->second, it2->first, a[2] };\n\t\t\t\tif (!M.count(RIGHT)) continue;\n\t\t\t\tvector<int> BACK = { it2->first,it1->second,it1->first, it2->second };\n\t\t\t\tif (!M.count(BACK)) continue;\n\t\t\t\tadd(a, -1);\n\t\t\t\tu = M[UP];\n\t\t\t\tadd(UP, -1);\n\t\t\t\td = M[DOWN];\n\t\t\t\tadd(DOWN, -1);\n\t\t\t\tl = M[LEFT];\n\t\t\t\tadd(LEFT, -1);\n\t\t\t\tr = M[RIGHT];\n\t\t\t\tadd(RIGHT, -1);\n\t\t\t\tb = M[BACK];\n\t\t\t\tadd(BACK, -1);\n\n\t\t\t\tadd(a, 1);\n\t\t\t\tadd(UP, 1);\n\t\t\t\tadd(DOWN, 1);\n\t\t\t\tadd(LEFT, 1);\n\t\t\t\tadd(RIGHT, 1);\n\t\t\t\tadd(BACK, 1);\n\n\t\t\t/*\tprint(a);\n\t\t\t\tprint(UP);\n\t\t\t\tprint(DOWN);\n\t\t\t\tprint(LEFT);\n\t\t\t\tprint(RIGHT);\n\t\t\t\tprint(BACK);*/\n//\t\t\t\treturn 0;\n\n\t\t\t\tLL c = u*d*l*r*b*f;\n\n\t\t\t//\tcout << u << ' ' << d << ' ' << l << ' ' << r << ' ' << b << ' ' << f << endl;\n\t\t\t\t\n\t\t\t\tres += c;\n\t\t\t//\tcout << c << endl << endl;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcout << res / 24 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<pair<int,int>, pair<int,int> > pt;\n\nconst int MOD = 1e9 + 7;\nconst int C = 1001;\n\nunordered_map<ll,int> ma;\n\nll hsh(int a, int b, int c, int d)\n{\n\tll x = ll(a)*ll(C)*ll(C)*ll(C);\n\tx += ll(b)*ll(C)*ll(C);\n\tx += ll(c)*ll(C);\n\tx += d;\n\treturn x;\n}\n\nvoid cyc(int &a, int &b, int &c, int &d)\n{\n\tswap(a, b);\n\tswap(a, c);\n\tswap(a, d);\n}\n\nvector<pt> vec;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tvec.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> vec[i].fi.fi >> vec[i].fi.se >> vec[i].se.fi >> vec[i].se.se;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint a = vec[i].fi.fi; int b = vec[i].fi.se;\n\t\tint c = vec[i].se.fi; int d = vec[i].se.se;\n\t\tma[hsh(a,b,c,d)]++;\n\t\tma[hsh(b,c,d,a)]++;\n\t\tma[hsh(c,d,a,b)]++;\n\t\tma[hsh(d,a,b,c)]++;\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i == j) continue;\n\t\t\tint xa, xb, xc, xd, ya, yb, yc, yd;\n\t\t\txa = vec[i].fi.fi; xb = vec[i].fi.se; xc = vec[i].se.fi; xd = vec[i].se.se;\n\t\t\tya = vec[j].fi.fi; yb = vec[j].fi.se; yc = vec[j].se.fi; yd = vec[j].se.se;\n\t\t\tswap(xb,xd);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tint a,b,c,d;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]--;\n\t\t\t\tma[hsh(b,c,d,a)]--;\n\t\t\t\tma[hsh(c,d,a,b)]--;\n\t\t\t\tma[hsh(d,a,b,c)]--;\n\t\t\t\tll h1 = hsh(ya,yd,xd,xa);\n\t\t\t\tll h2 = hsh(yd,yc,xc,xd);\n\t\t\t\tll h3 = hsh(yc,yb,xb,xc);\n\t\t\t\tll h4 = hsh(yb,ya,xa,xb);\n\t\t\t\t//set<ll> ss;\n\t\t\t\t//ss.insert(h1); ss.insert(h2); ss.insert(h3); ss.insert(h4);\n\t\t\t\tmap<ll,int> ss;\n\t\t\t\t////cerr<<h1<<' '<<h2<<' '<<h3<<' '<<h4<<'\\n';\n\t\t\t\tll tmp = 0;\n\t\t\t\t\n\t\t\t\t\t////cerr<<w<<' '<<x<<' '<<y<<' '<<z<<'\\n';\n\t\t\t\t\tll x1 = ma[h1];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tll x2 = ma[h2];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tll x3 = ma[h3];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] -= it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[y][h3]--; ma[y][h2]--; ma[y][h1]--; ma[y][h4]--;\n\t\t\t\t\tll x4 = ma[h4];\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(ya,yd,xd,xa);\n\t\t\t\t\t\tss[hsh(ya,yd,xd,xa)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\t\n\t\t\t\t\t//ma[w][h1]--; ma[w][h2]--; ma[w][h3]--; ma[w][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yd,yc,xc,xd);\n\t\t\t\t\t\tss[hsh(yd,yc,xc,xd)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[x][h2]--; ma[x][h1]--; ma[x][h3]--; ma[x][h4]--;\n\t\t\t\t\tss.clear();\n\t\t\t\t\tfor(int z = 0; z < 4; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcyc(yc,yb,xb,xc);\n\t\t\t\t\t\tss[hsh(yc,yb,xb,xc)]++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(map<ll,int>::iterator it = ss.begin(); it != ss.end(); it++)\n\t\t\t\t\t{\n\t\t\t\t\t\tma[it->fi] += it->se;\n\t\t\t\t\t}\n\t\t\t\t\t//ma[w][h1]++; ma[x][h2]++; ma[y][h3]++;\n\t\t\t\t\t//ma[w][h1]++; ma[w][h2]++; ma[w][h3]++; ma[w][h4]++;\n\t\t\t\t\t//ma[x][h2]++; ma[x][h1]++; ma[x][h3]++; ma[x][h4]++;\n\t\t\t\t\t//ma[y][h3]++; ma[y][h2]++; ma[y][h1]++; ma[y][h4]++;\n\t\t\t\t\tx1=max(x1,0LL); x2=max(x2,0LL); x3=max(x3,0LL); x4 = max(x4,0LL);\n\t\t\t\t\ttmp += (x1*x2*x3*x4);\n\n\t\t\t\t/*\n\t\t\t\ttmp*=ma[h1];\n\t\t\t\tma[h1]--;\n\t\t\t\ttmp*=ma[h2];\n\t\t\t\tma[h2]--;\n\t\t\t\ttmp*=ma[h3];\n\t\t\t\tma[h3]--;\n\t\t\t\ttmp*=ma[h4];\n\t\t\t\tma[h1]++; ma[h2]++; ma[h3]++;\n\t\t\t\t*/\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<xa<<' '<<xb<<' '<<xc<<' '<<xd<<' '<<ya<<' '<<yb<<' '<<yc<<' '<<yd<<' '<<tmp<<'\\n';\n\t\t\t\tans += tmp;\n\t\t\t\ta=xa,b=xb,c=xc,d=xd;\n\t\t\t\tswap(b,d);\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\ta=ya,b=yb,c=yc,d=yd;\n\t\t\t\tma[hsh(a,b,c,d)]++;\n\t\t\t\tma[hsh(b,c,d,a)]++;\n\t\t\t\tma[hsh(c,d,a,b)]++;\n\t\t\t\tma[hsh(d,a,b,c)]++;\n\t\t\t\tcyc(ya,yb,yc,yd);\n\t\t\t}\n\t\t}\n\t}\n\t//assert(ans%6==0);\n\tans/=6;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 405;\n\nvector <int> col[MAX];\nmap <vector<int>, int> M;\n\nvoid rotate(vector <int> &V)\n{\n  int poc = V[0];\n  for (int i=0; i<3; i++)\n    V[i] = V[i+1];\n  V[3] = poc;\n}\n\nvector <int> minrot(vector <int> V)\n{\n  vector <int> R = V;\n  for (int i=0; i<4; i++) {\n    rotate(V);\n    R = min(R, V);\n  }\n\n  return R;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<4; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      col[i].push_back(x);\n    }\n    col[i] = minrot(col[i]);\n    M[col[i]]++;\n  }\n\n  ll rje = 0;\n  for (int i=0; i<n; i++) {\n    M[col[i]]--;\n    reverse(col[i].begin(), col[i].end());\n    for (int j=i+1; j<n; j++) {\n      M[col[j]]--;\n      reverse(col[j].begin(), col[j].end());\n      for (int rot=0; rot<4; rot++) {\n        int sus[4] = {col[j][1], col[j][0], col[j][3], col[j][2]};\n        vector <int> kocke[4];\n        for (int l=0; l<4; l++) {\n          kocke[l] = vector<int>{col[i][l], col[i][(l+1)%4], sus[(l+1)%4], sus[l]};\n          kocke[l] = minrot(kocke[l]);\n        }\n\n        int koef = 1;\n        for (int l=0; l<4; l++) {\n          int br = 0;\n          vector <int> tmpkoc = kocke[l];\n          for (int rr=0; rr<4; rr++) {\n            if (kocke[l] == tmpkoc)\n              br++;\n            rotate(tmpkoc);\n          }\n          koef *= br;\n        }\n\n        ll tmp = 1;\n        for (int l=0; l<4; l++)\n          tmp *= M[kocke[l]]--;\n        for (int l=0; l<4; l++)\n          M[kocke[l]]++;\n\n        rotate(col[j]);\n        rje += tmp * koef;\n      }\n\n\n      reverse(col[j].begin(), col[j].end());\n      M[col[j]]++;\n    }\n  }\n\n  printf(\"%lld\\n\", rje);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) (((x)<<30)+((y)<<20)+((z)<<10)+(t))\nunordered_map<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[G(fr.x1,fr.x0,bk.x1,bk.x0)];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[G(fr.x2,fr.x1,bk.x0,bk.x3)];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[G(fr.x3,fr.x2,bk.x3,bk.x2)];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[G(fr.x0,fr.x3,bk.x2,bk.x1)];key[4].dec();\n\t\tret+=ans;\n\t\tfor(int j=1;j<=4;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nmap<ll,int> m;\n\nvoid modify(ll x,int k){\n\tfor(int i=0;i<4;i++){\n\t\tm[x]+=k;\n\t\tx=(x>>10)|((x&1023)<<30);\n\t}\n}\n\nll Hash(ll a,ll b,ll c,ll d){\n\treturn (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nll f[400][4],h[400],tmp[4];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>f[i][0]>>f[i][1]>>f[i][2]>>f[i][3];\n\t\th[i]=Hash(f[i][0],f[i][1],f[i][2],f[i][3]);\n\t\tmodify(h[i],1);\n\t}\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tmodify(h[i],-1);\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tmodify(h[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\ttmp[0]=Hash(f[i][3],f[i][2],f[j][(k+1)%4],f[j][k]);\n\t\t\t\ttmp[1]=Hash(f[i][2],f[i][1],f[j][(k+2)%4],f[j][(k+1)%4]);\n\t\t\t\ttmp[2]=Hash(f[i][1],f[i][0],f[j][(k+3)%4],f[j][(k+2)%4]);\n\t\t\t\ttmp[3]=Hash(f[i][0],f[i][3],f[j][k],f[j][(k+3)%4]);\n\t\t\t\tll z=1;\n\t\t\t\tif(m[tmp[0]]==0||m[tmp[1]]==0||m[tmp[2]]==0||m[tmp[3]]==0)\tcontinue;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tz*=m[tmp[l]];\n\t\t\t\t\tmodify(tmp[l],-1);\n\t\t\t\t}\n\t\t\t\tans+=z;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tmodify(tmp[l],1);\n\t\t\t}\n\t\t\tmodify(h[j],1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[405];\nlong long x[405][4];\nlong long c[405][10];\nmap<long long,int>m;\nlong long get(long long x,long long y,long long z,long long h){return (((((x<<10)+y)<<10)+z)<<10)+h;}\nlong long doit(long long x,long long y,long long z,long long h){return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));}\nlong long fac(long long x){long long ret=1;for(int i=1;i<=x;i++)ret*=i;return ret;}\nlong long rot(long long x)\n{\n    int k[4];\n\tfor(int i=0;i<=3;i++,x>>=10)k[i]=x&((1<<10)-1);\n    if(k[0]==k[1]&&k[1]==k[2]&&k[2]==k[3])return 4;\n    if(k[0]==k[2]&&k[1]==k[3])return 2;\n    return 1;\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)c[i][0]=c[i][i]=1;\n    for(int i=1;i<=n;i++)for(int j=1;j<=min(4,i-1);j++)c[i][j]=c[i-1][j]+c[i-1][j-1];\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=0;j<=3;j++)cin>>x[i][j];\n    \ta[i]=doit(x[i][0],x[i][1],x[i][2],x[i][3]);\n    }\n    long long ans=0;\n    m.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int ii=1;ii<i;ii++)\n\t\t{\n\t        for(int j=0;j<=3;j++)\n            {\n                long long y[4];\n            \ty[0]=doit(x[ii][(j+1)%4],x[ii][(j+0)%4],x[i][1],x[i][0]);\n                y[1]=doit(x[ii][(j+0)%4],x[ii][(j+3)%4],x[i][2],x[i][1]);\n                y[2]=doit(x[ii][(j+3)%4],x[ii][(j+2)%4],x[i][3],x[i][2]);\n                y[3]=doit(x[ii][(j+2)%4],x[ii][(j+1)%4],x[i][0],x[i][3]);\n                sort(y,y+4);\n                long long ret=1;\n                for(int p=0;p<4;)\n                {\n                    int cnt=1;\n                    for(int r=p+1;r<4&&y[r]==y[p];r++)cnt++;\n                    int num=m[y[p]];\n                    if(y[p]==a[ii])num--;\n                    if(num<cnt){ret=0;break;}\n                    ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                    p+=cnt;\n                }\n                ans+=ret;\n            }\n        }\n\t\tm[a[i]]++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\n\nmap<pii,int> cnt[1111][1111];\nstruct tile\n{\n\tint c[4];\n\ttile(int a1,int a2,int a3,int a4){c[0]=a1;c[1]=a2;c[2]=a3;c[3]=a4;}\n\ttile(){}\n\tvoid add(int x){for(int i=0;i<4;i++)cnt[c[i]][c[i+1&3]][mp(c[i+2&3],c[i+3&3])]+=x;}\n\tint getnum()\n\t{\n\t\tif(cnt[c[0]][c[1]].find(mp(c[2],c[3]))==cnt[c[0]][c[1]].end())\n\t\t\treturn 0;\n\t\treturn cnt[c[0]][c[1]][mp(c[2],c[3])];\n\t}\n\ttile rev()\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i]=c[i^3];\n\t\treturn ret;\n\t}\n\ttile rotate(int x)\n\t{\n\t\ttile ret;for(int i=0;i<4;i++)ret.c[i+x&3]=c[i];\n\t\treturn ret;\n\t}\n\ttile print(){printf(\"tile %d %d %d %d\\n\",c[0],c[1],c[2],c[3]);}\n}a[411],tmp[4];\n\nLL getnum(const tile up,const tile down)\n{\n\tLL ret=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n//\t\tcur.print();printf(\"num= %d\\n\",cur.getnum());\n\t\tret*=cur.getnum();\n\t\tcur.add(-1);\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttile cur(up.c[i+1&3],up.c[i],down.c[i],down.c[i+1&3]);\n\t\tcur.add(1);\n\t}\n\treturn ret;\n}\nint n;\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t\tget1(a[i].c[j]);\n\t\ta[i].add(1);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i].add(-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\ta[j].add(-1);\n\t\t\tfor(int k=0;k<4;k++)ans+=getnum(a[i],a[j].rev().rotate(k));\n\t\t\ta[j].add(1);\n\t\t}\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nmap<array<int, 4>, int> M;\narray<int, 4> normalize(const array<int, 4>& A) {\n    array<int, 4> ans = A, copy = A;\n    for (int i = 0; i < 4; i++) {\n        ans = min(ans, copy);\n        rotate(begin(copy), begin(copy) + 1, end(copy));\n    }\n    return ans;\n}\nvoid mark(const array<int, 4>& A, int sign) {\n    if (A[0] == A[1] && A[1] == A[2] && A[2] == A[3]) {\n        M[A] += sign * 4;\n    } else if (A[0] == A[2] && A[1] == A[3]) {\n        M[A] += sign * 2;\n    } else {\n        M[A] += sign * 1;\n    }\n}\nint main() {\n    int N; cin >> N;\n    vector<array<int, 4>> C(N);\n    for (auto &sq : C) for (auto &c : sq) cin >> c;\n    Int ans = 0;\n    for (int i = 0; i < N; i++) {\n        mark(normalize(C[i]), +1);\n    }\n    for (int i = 0; i < N; i++) {\n        auto A = normalize(C[i]);\n        mark(A, -1);\n        int a[4] = { A[0], A[1], A[2], A[3] };\n        for (int j = i + 1; j < N; j++) {\n            auto B = normalize(C[j]);\n            mark(B, -1);\n            int b[4] = { B[1], B[0], B[3], B[2] };\n            for (int k = 0; k < 4; k++) {\n                array<int, 4> x = normalize({ a[0], b[0], b[1], a[1] });\n                array<int, 4> y = normalize({ a[1], b[1], b[2], a[2] });\n                array<int, 4> z = normalize({ a[2], b[2], b[3], a[3] });\n                array<int, 4> w = normalize({ a[3], b[3], b[0], a[0] });\n                Int res = 1;\n                res *= M[x]; mark(x, -1);\n                res *= M[y]; mark(y, -1);\n                res *= M[z]; mark(z, -1);\n                res *= M[w]; mark(w, -1);\n                ans += res;\n                mark(x, +1); mark(y, +1); mark(z, +1); mark(w, +1);\n                rotate(begin(b), begin(b) + 1, end(b));\n            }\n            mark(B, +1);\n        }\n        mark(A, +1);\n    }\n    cout << ans / 3 << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\nvector<int> vf[410];\n\nll same(const vector<int> &v){\n  ll res = 0;\n  vector<int> e(4); rep(i, 4)e[i] = i;\n  rep(i_, 4){\n    vector<int> vt(4); rep(i, 4)vt[i] = v[e[i]];\n    if(v == vt)++res;\n    rotate(e.begin(), e.begin() + 1, e.end());\n  }\n  return res;\n}\n\nvector<int> regularize(vector<int> v){\n  vector<int> res = v;\n  vector<int> e(4); rep(i, 4)e[i] = i;\n  rep(i_, 3){\n    rotate(e.begin(), e.begin() + 1, e.end());\n    vector<int> vt(4); rep(i, 4)vt[i] = v[e[i]];\n    res = min(res, vt);\n  }\n  return res;\n}\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  rep(i, n)rep(j, 4){\n    int c; cin >> c;\n    vf[i].pb(c);\n  }\n  map<vector<int>, set<int>> mp;\n  rep(i, n){\n    mp[regularize(vf[i])].insert(i);\n  }\n  ll res = 0;\n  rep(i, n){\n    mp[regularize(vf[i])].erase(i);\n    FOR(j, i + 1, n){\n      mp[regularize(vf[j])].erase(j);\n\n      vector<int> e(4);\n      rep(k, 4)e[k] = k;\n      reverse(all(vf[j]));\n      rep(i_, 4){\n        map<vector<int>, int> cnt;\n        ll tmp = 1;\n        vector<int> vtt = vector<int>{vf[i][1], vf[i][0], vf[j][e[0]], vf[j][e[1]]};\n        cnt[regularize(vtt)]++;\n        vtt = vector<int>{vf[i][2], vf[i][1], vf[j][e[1]], vf[j][e[2]]};\n        cnt[regularize(vtt)]++;\n        vtt = vector<int>{vf[i][3], vf[i][2], vf[j][e[2]], vf[j][e[3]]};\n        cnt[regularize(vtt)]++;\n        vtt = vector<int>{vf[i][0], vf[i][3], vf[j][e[3]], vf[j][e[0]]};\n        cnt[regularize(vtt)]++;\n        irep(itr, cnt){\n          ll cn = sz(mp[itr->first]);\n          if(itr->second == 1)tmp *= cn;\n          else if(itr->second == 2)tmp *= cn * (cn - 1);\n          else if(itr->second == 3)tmp *= cn * (cn - 1) * (cn - 2);\n          else tmp *= cn * (cn - 1) * (cn - 2) * (cn - 3);\n          rep(k, itr->second)tmp *= same(itr->first);\n        }\n        rotate(e.begin(), e.begin() + 1, e.end());\n        res += tmp;\n      }\n      reverse(all(vf[j]));\n\n      mp[regularize(vf[j])].insert(j);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<int> standard(vector<int> x) {\n  for (int i = 0; i < 4; i++) x.push_back(x[i]);\n\n  vector<int> ret = {10000, 10000, 100000, 100000};\n  for (int j = 0; j < 4; j++) {\n    vector<int> color;\n    for (int k = 0; k < 4; k++) color.push_back(x[j + k]);\n    if (ret > color) ret = color;\n  }\n  return ret;\n}\nLL encode(const vector<int> x) {\n  LL val = 0;\n  for (int i = 0; i < 4; i++) {\n    val *= 1000;\n    val += x[i];\n  }\n  return val;\n}\n\nvoid dump(vector<int> x) {\n  for (auto val : x) cout << val << \" \";\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  // map<vector<int>, int> colors;\n  // map<vector<int>, int> muls;\n  map<LL, int> colors;\n  map<LL, int> muls;\n  set<vector<int>> keys;\n  for (int i = 0; i < N; i++) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    vector<int> base_color = {a, d, c, b, a, d, c, b};\n    vector<vector<int>> tmp_color;\n    for (int j = 0; j < 4; j++) {\n      vector<int> color;\n      for (int k = 0; k < 4; k++) color.push_back(base_color[j + k]);\n      tmp_color.push_back(color);\n    }\n    vector<int> color = standard(tmp_color[0]);\n    colors[encode(color)]++;\n    int mul = 0;\n    for (int j = 0; j < 4; j++)\n      if (tmp_color[0] == tmp_color[j]) mul++;\n    muls[encode(color)] = mul;\n    keys.insert(color);\n  }\n\n  LL ans = 0;\n  vector<vector<int>> keyv;\n  for (auto key : keys) {\n    keyv.push_back(key);\n  }\n\n  for (auto low : keyv) {\n    for (auto up : keyv) {\n      for (int z = 0; z < 4; z++) {\n        LL low_key = encode(low);\n        LL up_key = encode(up);\n        LL ret = 1;\n        ret *= colors[low_key];\n        colors[low_key]--;\n        ret *= colors[up_key];\n        colors[up_key]--;\n\n        vector<LL> hozon;\n        for (int i = 0; i < 4; i++) {\n          vector<int> cur;\n          cur = {low[(7 - i) % 4], low[(6 - i) % 4], up[(1 + i + z) % 4],\n                 up[(i + z) % 4]};\n          cur = standard(cur);\n          LL key = encode(cur);\n          ret *= colors[key] * muls[key];\n\n          colors[key]--;\n          hozon.push_back(key);\n        }\n        for (auto key : hozon) {\n          colors[key]++;\n        }\n\n        ans += ret;\n        colors[low_key]++;\n        colors[up_key]++;\n      }\n    }\n\n    // colors[low] = 0;\n  }\n  cout << ans / 6 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<long,15>,4> >M;\nint a[400],b[400],c[400],d[400];\nmap<long,int>COUNT[400];\nset<long>S;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tlong C=conv(a[i],b[i],c[i],d[i]);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tCOUNT[i][C]++;\n\t\t\tS.insert(C);\n\t\t\tC=rotate(C);\n\t\t}\n\t}\n\tfor(long it:S)\n\t{\n\t\tarray<array<long,15>,4>&A=M[it];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint c=COUNT[i][it];\n\t\t\tsum+=c;\n\t\t\tct[c]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<=j;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tA[0][j*(j+1)/2+k]=sum-j-k;\n\t\t\tA[1][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\tA[2][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\tA[3][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tint a=COUNT[i][t[k]];\n\t\t\t\t\tint b=COUNT[j][t[k]];\n\t\t\t\t\tif(a<b)a^=b^=a^=b;\n\t\t\t\t\tnow*=M.find(t[k])==M.end()?0:M[t[k]][cc[k]-1][a*(a+1)/2+b];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nint N;\nvector<vector<int> > C;\nmap<vector<int>, long long> ma;\n\nvoid use(vector<int> v) {\n    for (int it = 0; it < 4; ++it) {\n        vector<int> col(4);\n        for (int j = 0; j < 4; ++j) {\n            col[j] = v[(it+j)%4];\n        }\n        ma[col]--;\n    }\n}\n\nvoid add(vector<int> v) {\n    for (int it = 0; it < 4; ++it) {\n        vector<int> col(4);\n        for (int j = 0; j < 4; ++j) {\n            col[j] = v[(it+j)%4];\n        }\n        ma[col]++;\n    }\n}\n\nint main() {\n    while (cin >> N) {\n        C.assign(N, vector<int>(4));\n        for (int i = 0; i < N; ++i) \n            for (int j = 0; j < 4; ++j)\n                cin >> C[i][j];\n\n        ma.clear();\n        for (int i = 0; i < N; ++i) add(C[i]);\n\n        long long res = 0;\n        for (int i = 0; i < N; ++i) {\n            use(C[i]);\n            for (int j = 0; j < N; ++j) {\n                if (j == i) continue;\n                use(C[j]);\n\n                for (int dir = 0; dir < 4; ++dir) {\n                    auto ue = C[i];\n                    vector<int> shita(4);\n                    for (int k = 0; k < 4; ++k) shita[k] = C[j][(dir + k) % 4];\n                    reverse(shita.begin(), shita.end());\n\n                    //cout << i << \", \" << j << \", \" << dir <<  \": \" << C[i] << \", \" << C[j] << \" ;; \" << shita << endl;\n\n                    long long tmp = 1;\n                    vector<bool> isadd(4, 0);\n                    for (int it = 0; it < 4; ++it) {\n                        vector<int> col(4);\n                        col[1] = ue[it%4];\n                        col[0] = ue[(it+1)%4];\n                        col[2] = shita[it%4];\n                        col[3] = shita[(it+1)%4];\n                        if (!ma.count(col)) tmp = 0;\n                        else tmp *= ma[col], use(col), isadd[it] = true;\n\n\n                        if (i == 0 && j == 4 && dir == 2) {\n                            //cout << it << \": \" << col << endl;\n                        }\n                    }\n                    for (int it = 0; it < 4; ++it) {\n                        vector<int> col(4);\n                        col[1] = ue[it%4];\n                        col[0] = ue[(it+1)%4];\n                        col[2] = shita[it%4];\n                        col[3] = shita[(it+1)%4];\n                        if (isadd[it]) add(col);\n                    }\n                    \n                    res += tmp;\n                }\n                add(C[j]);\n            }\n            add(C[i]);\n        }\n        cout << res / 6 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, a[404][4] = {};\n    ll z = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) for (int j = 0; j < 4; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++) {\n        map<pair<pii, pii>, ll> p;\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 0; k < 4; k++) {\n              \tif (p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}]) {\n                    z += p[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}];\n                    continue;\n                }\n                int c[4] = {}, b[4][4] = {{a[i][1], a[i][0], a[j][(k + 0) % 4], a[j][(k + 3) % 4]}, {a[i][2], a[i][1], a[j][(k + 3) % 4], a[j][(k + 2) % 4]}, {a[i][3], a[i][2], a[j][(k + 2) % 4], a[j][(k + 1) % 4]}, {a[i][0], a[i][3], a[j][(k + 1) % 4], a[j][(k + 0) % 4]}};\n              \tll d[16] = {1};\n                for (int l = i + 1; l <= n; l++) {\n                  \tfor (int m = 0; m < 4; m++) {\n                      \tc[m] = 0;\n                        if (a[l][0] == b[m][0] && a[l][1] == b[m][1] && a[l][2] == b[m][2] && a[l][3] == b[m][3]) c[m]++;\n                        if (a[l][0] == b[m][1] && a[l][1] == b[m][2] && a[l][2] == b[m][3] && a[l][3] == b[m][0]) c[m]++;\n                        if (a[l][0] == b[m][2] && a[l][1] == b[m][3] && a[l][2] == b[m][0] && a[l][3] == b[m][1]) c[m]++;\n                        if (a[l][0] == b[m][3] && a[l][1] == b[m][0] && a[l][2] == b[m][1] && a[l][3] == b[m][2]) c[m]++;\n                    }\n                  \tif (l == j) continue;\n                    d[15] += c[0] * d[14];\n                    d[15] += c[1] * d[13];\n                    d[15] += c[2] * d[11];\n                    d[15] += c[3] * d[7];\n                    d[14] += c[1] * d[12];\n                    d[14] += c[2] * d[10];\n                    d[14] += c[3] * d[6];\n                    d[13] += c[0] * d[12];\n                    d[13] += c[2] * d[9];\n                    d[13] += c[3] * d[5];\n                    d[12] += c[2] * d[8];\n                    d[12] += c[3] * d[4];\n                    d[11] += c[0] * d[10];\n                    d[11] += c[1] * d[9];\n                    d[11] += c[3] * d[3];\n                    d[10] += c[1] * d[8];\n                    d[10] += c[3] * d[2];\n                    d[9] += c[0] * d[8];\n                    d[9] += c[3] * d[1];\n                    d[8] += c[3] * d[0];\n                    d[7] += c[0] * d[6];\n                    d[7] += c[1] * d[5];\n                    d[7] += c[2] * d[3];\n                    d[6] += c[1] * d[4];\n                    d[6] += c[2] * d[2];\n                    d[5] += c[0] * d[4];\n                    d[5] += c[2] * d[1];\n                    d[4] += c[2] * d[0];\n                    d[3] += c[0] * d[2];\n                    d[3] += c[1] * d[1];\n                    d[2] += c[1] * d[0];\n                    d[1] += c[0] * d[0];\n                }\n              \tp[{{a[j][(k + 0) % 4], a[j][(k + 1) % 4]}, {a[j][(k + 2) % 4], a[j][(k + 3) % 4]}}] = d[15];\n                z += d[15];\n            }\n        }\n    }\n    cout << z;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <tuple>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nusing namespace std;\n\nlong long encode(long long p, long long q, long long r, long long s) {\n    return (((p << 10) + q) << 20) + (((r << 10) + s));\n}\n\ntuple<int, int, int, int> decode(long long x) {\n    int p = x >> 30, q = (x >> 20) & 1023, r = (x >> 10) & 1023, s = x & 1023;\n    return {p, q, r, s};\n}\n\nlong long rotate(long long x) {\n    return (x >> 30) | ((x & ((1 << 30) - 1)) << 10);\n}\n\nint multiplicity(long long x) {\n    auto [p, q, r, s] = decode(x);\n    if (p == r && q == s)\n        return p == q ? 4 : 2;\n    else\n        return 1;\n}\n\nint main() {\n    int n; cin >> n;\n    unordered_map<long long, int> cnt;\n    vector<long long> tiles;\n    for (int i = 0; i < n; i++) {\n        int p, q, r, s; cin >> p >> q >> r >> s;\n        long long x = encode(p, q, r, s);\n        for (int j = 0; j < 4; j++, x = rotate(x)) {\n            cnt[x]++;\n            tiles.push_back(x);\n        }\n    }\n    long long ans = 0;\n    unordered_map<long long, int> want;\n    for (int i = 0; i < tiles.size(); i++) {\n        const long long x = tiles[i];\n        for (long long x1 = x, a = 0; a < 4; a++, x1 = rotate(x1)) cnt[x1]--;\n        for (int j = i / 4 * 4 + 4; j < tiles.size(); j++) {\n            const long long y = tiles[j];\n            for (long long y1 = y, a = 0; a < 4; a++, y1 = rotate(y1)) cnt[y1]--;\n            auto [p, q, r, s] = decode(x);\n            auto [t, u, v, w] = decode(y);\n            want.clear();\n            want[encode(u, t, q, p)]++;\n            want[encode(q, t, w, r)]++;\n            want[encode(u, p, s, v)]++;\n            want[encode(w, v, s, r)]++;\n            long long prod = 1;\n            for (auto [z, k] : want) {\n                const int m = multiplicity(z);\n                assert (cnt[z] % m == 0);\n                for (int i = 0; i < k; i++) prod *= cnt[z] - m * i;\n                for (long long z1 = z, a = 0; a < 4; a++, z1 = rotate(z1)) cnt[z1] -= k;\n            }\n            for (auto [z, k] : want) {\n                for (long long z1 = z, a = 0; a < 4; a++, z1 = rotate(z1)) cnt[z1] += k;\n            }\n            ans += prod;\n            for (long long y1 = y, a = 0; a < 4; a++, y1 = rotate(y1)) cnt[y1]++;\n        }\n        for (long long x1 = x, a = 0; a < 4; a++, x1 = rotate(x1)) cnt[x1]++;\n    }\n    assert (ans % 12 == 0);\n    cout << ans / 12 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define INF (numeric_limits<int>::max()/2-1)\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T> constexpr bool chmin(T& x, T const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T> constexpr bool chmax(T& x, T const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n    auto c = make_v<int,2>(n,4); cin >> c;\n\n    int ans = 0;\n    rep (i,n) rep (j,n) if (i < j) {\n        rep (k,4) {\n            vector<vector<int>> a(4);\n            rep (x,4) {\n                a[x] = {c[i][(x+1)%4],c[i][x],\n                        c[j][(k-x+4)%4],c[j][(k-x-1+4)%4]};\n            }\n\n            auto match = [&](int x, int i) {\n                int ret = 0;\n                rep (k,4) {\n                    if (a[x] == c[i]) ret++;\n                    rotate(c[i].begin(), c[i].begin()+1, c[i].end());\n                }\n                return ret;\n            };\n\n            auto f = [&](vector<int> const& v) {\n                int ret = 0;\n                rep (ii,n) {\n                    if (ii == i || ii == j) continue;\n                    int tmp = 1;\n                    for (int x : v) tmp *= match(x,ii);\n                    ret += tmp;\n                }\n                return ret;\n            };\n\n            int c0 = f({0}), c1 = f({1}), c2 = f({2}), c3 = f({3});\n            int c01 = f({0,1}), c02 = f({0,2}), c03 = f({0,3}),\n                c12 = f({1,2}), c13 = f({1,3}), c23 = f({2,3});\n            int c012 = f({0,1,2}), c013 = f({0,1,3}), c023 = f({0,2,3}),\n                c123 = f({1,2,3});\n            int c0123 = f({0,1,2,3});\n\n            int tmp = 0;\n            tmp += c0 * c1 * c2 * c3;\n            tmp += -1 * ( c01*c2*c3 + c02*c1*c3 + c03*c1*c2\n                         + c12*c0*c3 + c13*c0*c2 + c23*c0*c1 );\n            tmp += +2 * ( c012*c3 + c013*c2 + c023*c1 + c123*c0 )\n                + ( c01*c23 + c02*c13 + c03*c12 );\n            tmp += -6 * ( c0123 );\n\n            ans += tmp;\n        }\n    }\n    dump(ans);\n    assert(ans % 3 == 0);\n    cout << ans/3 << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nvoid SO(vector<int> &v){\n  vector<int> w(8);\n  for(int i=0;i<4;i++)w[i]=w[i+4]=v[i];\n  for(int j=1;j<4;j++){\n    if(w[j]*1e9+w[j+1]*1e6+w[j+2]*1e3+w[j+3]<v[0]*1e9+v[1]*1e6+v[2]*1e3+v[3]){\n      for(int a=0;a<4;a++)v[a]=w[j+a];\n    }\n  }\n}\nint cou(vector<vector<int>> &c,vector<int> &need,int idx,int n,int ex){\n  if((idx<n-1&&c[idx+1]>need)||c[n-1]<need)return 0;\n  int l=idx,r=n;\n  while(r-l>1){\n    int mid=(r+l)>>1;\n    (c[mid]<need?l:r)=mid;\n  }\n  int miman=l;\n  r=n;\n  while(r-l>1){\n    int mid=(r+l)>>1;\n    (c[mid]<=need?l:r)=mid;\n  }\n  return l-miman-(c[ex]==need);\n}\nint F(vector<int> &v){\n  return (v[0]==v[1]&&v[1]==v[2]&&v[2]==v[3]?4:1);\n}\n\nsigned main(){\n  int n;cin>>n;\n  vector<vector<int>> c(n);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<4;j++){\n      int a;cin>>a;\n      c[i].push_back(a);\n    }\n    SO(c[i]);\n  }\n  sort(c.begin(),c.end());\n  int ans=0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      for(int k=0;k<4;k++){\n        vector<vector<int>> need(4);\n        for(int l=0;l<4;l++){\n          need[l].push_back(c[j][(4-l+1+k)%4]);\n          need[l].push_back(c[j][(4-l+k)%4]);\n          need[l].push_back(c[i][(l+1)%4]);\n          need[l].push_back(c[i][l]);\n          SO(need[l]);\n        }\n        sort(need.begin(),need.end());\n        int A=cou(c,need[0],i,n,j);\n        int B=(need[0]==need[1]?A-1:cou(c,need[1],i,n,j));\n        int C=(need[1]==need[2]?B-1:cou(c,need[2],i,n,j));\n        int D=(need[2]==need[3]?C-1:cou(c,need[3],i,n,j));\n        if(min({A,B,C,D})<=0)continue;\n        ans+=A*B*C*D*F(need[0])*F(need[1])*F(need[2])*F(need[3]);\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n\nusing namespace std;\ntypedef long long ll;\n//____________________________________________\n//____________________________________________\n//__________________OOOOOOOOOOOOOOOO__________\n//_________________OO_____________OO__________\n//________________O_O____________O_O__________\n//_______________O__O___________O__O__________\n//______________O___O__________O___O__________\n//_____________O____O_________O____O__________\n//____________OOOOOOOOOOOOOOOO_____O__________\n//____________O_____O________O_____O__________\n//____________O_____OOOOOOOOOOOOOOOO__________\n//____________O____O_________O____O___________\n//____________O___O__________O___O____________\n//____________O__O___________O__O_____________\n//____________O_O____________O_O______________\n//____________OO_____________OO_______________\n//____________OOOOOOOOOOOOOOOO________________\n//____________________________________________\n//____________________________________________\n\nconst long long MOD = 1e9 + 7;\nll n;\nll c[500][4];\nll ans;\nmap<vector<int>, int> g;\n\nvector<int> reform(vector<int> c)\n{\n    vector<int> cc;\n    int x = 0;\n    for (int j = 0; j < 4; j++)\n    {\n        if (c[j] < c[x])\n            x = j;\n    }\n    cc.push_back(c[x]);\n    cc.push_back(c[(x + 1) % 4]);\n    cc.push_back(c[(x + 2) % 4]);\n    cc.push_back(c[(x + 3) % 4]);\n    return cc;\n}\n\nll cnk(ll k, ll n)\n{\n    if (k > n)\n        return 0;\n    if (k == 0)\n        return 1;\n    if (k == 1)\n        return n;\n    if (k == 2)\n        return n * (n - 1) / 2;\n    if (k == 3)\n        return n * (n - 1) * (n - 2) / 6;\n    if (k == 4)\n        return n * (n - 1) * (n - 2) * (n - 3) / 24;\n}\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        g[reform({c[i][0], c[i][1], c[i][2], c[i][3]})]++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            for (int o1 = 0; o1 < 4; o1++)\n            {\n                //     c[j][1] ---- c[j][0]\n                //       /|            /|\n                //      / |           / |\n                //     /  c[j][2]    /  c[j][3]\n                // c[i][o1] ---- c[i][o1 + 1]\n                //    | /            |\n                //    |/             |\n                // c[i][o1 + 3] ---- c[i][o1 + 2]\n                int ful = c[i][o1];\n                int fur = c[i][(o1 + 1) % 4];\n                int fdl = c[i][(o1 + 3) % 4];\n                int fdr = c[i][(o1 + 2) % 4];\n\n                int bul = c[j][1];\n                int bur = c[j][0];\n                int bdl = c[j][2];\n                int bdr = c[j][3];\n\n                vector<int> l = {ful, fdl, bdl, bul};\n                vector<int> u = {fur, ful, bul, bur};\n                vector<int> r = {fur, bur, bdr, fdr};\n                vector<int> d = {fdl, fdr, bdr, bdl};\n\n                ll swappers = 1;\n\n                ll y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (l[y] != l[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (d[y] != d[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (u[y] != u[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                y1 = 0;\n                for (int x = 0; x < 4; x++)\n                {\n                    int ok = 1;\n                    for (int y = 0; y < 4; y++)\n                    {\n                        if (r[y] != r[(x + y) % 4])\n                            ok = 0;\n                    }\n                    y1 += ok;\n                }\n                swappers *= y1;\n\n                r = reform(r);\n                l = reform(l);\n                u = reform(u);\n                d = reform(d);\n\n                map<vector<int>, int> gg2;\n                gg2[r]++;\n                gg2[l]++;\n                gg2[u]++;\n                gg2[d]++;\n\n                for (auto it : gg2)\n                {\n                    swappers *= cnk(it.second, g[it.first]);\n                }\n\n                ans += swappers;\n            }\n        }\n    }\n    cout << ans / 3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N];\n\nTILE ROT[MAX_N*4];\n\nint main(){\n\tcin>>N;\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tT[i]=TILE(a,b,c,d,i);\n\t\tREP(j,4){\n\t\t\tROT[i*4+j]=rotate(T[i],j);\n\t\t}\n\t}\n\tsort(ROT,ROT+N*4);\n\tll ans=0;\n\tTILE TI[3];\n\tREP(i,N){\n\t\tTI[0]=T[i];\n\t\tREP(j,N*4){\n\t\t\tif (TI[0].index==ROT[j].index) continue;\n\t\t\tif (ROT[j].c[3]==TI[0].c[0] && ROT[j].c[2]==TI[0].c[1]){\n\t\t\t\tTI[1]=ROT[j];\n\t\t\t\tREP(k,N*4){\n\t\t\t\t\tif (TI[0].index==ROT[k].index || TI[1].index==ROT[k].index) continue;\n\t\t\t\t\tif (ROT[k].c[0]==TI[0].c[3] && ROT[k].c[1]==TI[0].c[2]){\n\t\t\t\t\t\tTI[2]=ROT[k];\n\t\t\t\t\t\tint a,b,c;\n\t\t\t\t\t\ta=b=c=0;\n\t\t\t\t\t\tTILE t1,t2,t3;\n\t\t\t\t\t\tt1=TILE(TI[0].c[0],TI[0].c[3],TI[2].c[3],TI[1].c[0],0);\n\t\t\t\t\t\ta=upper_bound(ROT,ROT+N*4,t1)-lower_bound(ROT,ROT+N*4,t1);\n\t\t\t\t\t\tREP(s,3){\n\t\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\t\tif (t1==rotate(TI[s],u)){\n\t\t\t\t\t\t\t\t\ta--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt2=TILE(TI[1].c[1],TI[1].c[0],TI[2].c[3],TI[2].c[2],0);\n\t\t\t\t\t\tb=upper_bound(ROT,ROT+N*4,t2)-lower_bound(ROT,ROT+N*4,t2);\n\t\t\t\t\t\tREP(s,3){\n\t\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\t\tif (t2==rotate(TI[s],u)){\n\t\t\t\t\t\t\t\t\tb--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt3=TILE(TI[0].c[2],TI[0].c[1],TI[1].c[1],TI[2].c[2],0);\n\t\t\t\t\t\tc=upper_bound(ROT,ROT+N*4,t3)-lower_bound(ROT,ROT+N*4,t3);\n\t\t\t\t\t\tREP(s,3){\n\t\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\t\tif (t3==rotate(TI[s],u)){\n\t\t\t\t\t\t\t\t\tc--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t    int cnt1,cnt2;\n\t\t\t\t\t    cnt1=cnt2=0;\n\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\tif (t1==rotate(t2,u)){\n\t\t\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tREP(u,4){\n\t\t\t\t\t\t\tif (t3==rotate(t2,u)){\n\t\t\t\t\t\t\t\tcnt2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt1 && cnt2){\n\t\t\t\t\t\t\tans+=a*(b-cnt1)*(c-cnt2);\n\t\t\t\t\t\t}else if (cnt1){\n\t\t\t\t\t\t\tans+=a*(b-cnt1)*c;\n\t\t\t\t\t\t}else if (cnt2){\n\t\t\t\t\t\t\tans+=b*(c-cnt2)*a;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tans+=a*b*c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    vector<int> rot(4);\n    vector<vector<int>> surface(4,vector<int>(4));\n    vector<vector<int>> dp(N+1,vector<int>(16));\n    int ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                    if (surface[q][0]==surface[q][1]\n                        &&surface[q][1]==surface[q][2]\n                        &&surface[q][2]==surface[q][3]\n                        &&surface[q][3]==surface[q][0]) rot[q]=4;\n                    else if (surface[q][0]==surface[q][2]\n                            &&surface[q][1]==surface[q][3]) rot[q]=2;\n                    else rot[q]=1;\n                }\n                for (int k=i+1;k<=N;++k){\n                    for (int l=0;l<16;++l){\n                        dp[k][l]=0;\n                    }\n                }\n                dp[i+1][0]=1;\n                for (int k=i+1;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]+=dp[k][l];\n                    if (k==i||k==j) continue;\n                    for (int l=0;l<4;++l){\n                        bool flag=false;\n                        for (int m=0;m<4;++m){\n                            bool smallflag=true;\n                            for (int n=0;n<4;++n){\n                                if (surface[l][n]!=C[k][(m+n)%4]){\n                                    smallflag=false;\n                                }\n                            }\n                            flag|=smallflag;\n                        }\n                        if (flag){\n                            for (int mask=15;mask>=0;--mask){\n                                if (!(mask&1<<l)){\n                                    dp[k+1][mask|1<<l]+=dp[k][mask]*rot[l];\n                                }\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\n\n#define REP(i,n)\tfor(int i=0;i<(int)n;++i)\n#define ALL(c)\t\t(c).begin(),(c).end()\n#define CLEAR(v)\tmemset(v,0,sizeof(v))\n#define MP(a,b)\t\tmake_pair((a),(b))\n#define ABS(a)\t\t((a)>0?(a):-(a))\n#define FOR(i,s,n)\tfor(int i=s;i<(int)n;++i)\n\nint N;\nint C[1600][5];\n\nint used[6];\n\nll f6() {\n\tint a = used[0], b = used[2], c = used[3], d = used[1], e = used[4], f = used[5];\n\tif (C[a][0] == C[b][1] && C[a][1] == C[e][0] && C[a][2] == C[e][3] && C[a][3] == C[b][2]\n\t\t&& C[f][0] == C[d][1] && C[f][1] == C[b][0] && C[f][2] == C[b][3] && C[f][3] == C[c][2]) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nll f5() {\n\tll res = 0;\n\tint e = used[4];\n\tREP(f, N * 4) {\n\t\tif (C[e][1] == C[f][0] && C[e][2] == C[f][3]) {\n\t\t\tbool u = false;\n\t\t\tREP(i, 5) if (used[i] / 4 == f / 4) u = true;\n\t\t\tif (u) continue;\n\t\t\tused[5] = f;\n\t\t\tres += f6();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f4() {\n\tll res = 0;\n\tint c = used[3];\n\tREP(e, N * 4) {\n\t\tif (C[c][1] == C[e][3] && C[c][2] == C[e][2]) {\n\t\t\tbool u = false;\n\t\t\tREP(i, 4) if (used[i] / 4 == e / 4) u = true;\n\t\t\tif (u) continue;\n\t\t\tused[4] = e;\n\t\t\tres += f5();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f3() {\n\tll res = 0;\n\tint b = used[2];\n\tREP(c, N * 4) {\n\t\tif (C[b][2] == C[c][0] && C[b][3] == C[c][3]) {\n\t\t\tbool u = false;\n\t\t\tREP(i, 3) if (used[i] / 4 == c / 4) u = true;\n\t\t\tif (u) continue;\n\t\t\tused[3] = c;\n\t\t\tres += f4();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f2() {\n\tll res = 0;\n\tint d = used[1];\n\tREP(b, N * 4) {\n\t\tif (C[d][0] == C[b][0] && C[d][3] == C[b][1]) {\n\t\t\tbool u = false;\n\t\t\tREP(i, 2) if (used[i] / 4 == b / 4) u = true;\n\t\t\tif (u) continue;\n\t\t\tused[2] = b;\n\t\t\tres += f3();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f1() {\n\tll res = 0;\n\tint a = used[0];\n\tREP(d, N * 4) {\n\t\tif (C[a][0] == C[d][3] && C[a][1] == C[d][2]) {\n\t\t\tbool u = false;\n\t\t\tREP(i, 1) if (used[i] / 4 == d / 4) u = true;\n\t\t\tif (u) continue;\n\t\t\tused[1] = d;\n\t\t\tres += f2();\n\t\t}\n\t}\n\treturn res;\n}\n\nll f0() {\n\tll res = 0;\n\tREP(a, N * 4) {\n\t\tused[0] = a;\n\t\tres += f1();\n\t}\n\treturn res;\n}\n\nbool eq(int a, int b) {\n\tREP(i, 4) if (C[a][i] != C[b][i]) return false;\n\treturn true;\n}\n\nint main(int argc, char **argv) {\n\tcin >> N;\n\tREP(i, N) {\n\t\tREP(j, 4) cin >> C[i * 4][j];\n\t\tREP(j, 3) REP(k, 4) C[i * 4 + 1 + j][(1 + j + k) % 4] = C[i * 4][k];\n\t}\n\tREP(i, N * 4) C[i][4] = C[i][0];\n\tcout << (f0() / 24) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nint n;\nstruct node{int col[4];\n    node nxt(){ return node{col[1],col[2],col[3],col[0]};}\n    friend bool operator <(node a,node b)\n    {\n        for (int i=0;i<4;i++)\n            if (a.col[i]!=b.col[i]) return a.col[i]<b.col[i];\n        return 0;\n    }\n}a[410],a1,a2,a3,a4;\nmap<node,int>mp;\nvoid insert(node x,int v){for (int i=0;i<4;i++,x=x.nxt()) mp[x]+=v;}\n\nll ans,re;\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d%d%d\",&a[i].col[0],&a[i].col[1],&a[i].col[2],&a[i].col[3]);    \n        insert(a[i],1);    \n    }\n    for (int i=1;i<=n;i++)\n    {\n        insert(a[i],-1);\n        for (int j=i+1;j<=n;j++)\n        {\n            insert(a[j],-1);\n            for (int t=0;t<4;t++)\n            {\n                a1=node{a[j].col[1],a[i].col[0],a[i].col[3],a[j].col[2]};\n                a2=node{a[i].col[1],a[j].col[0],a[j].col[3],a[i].col[2]};\n                a3=node{a[j].col[1],a[j].col[0],a[i].col[1],a[i].col[0]};\n                a4=node{a[i].col[3],a[i].col[2],a[j].col[3],a[j].col[2]};\n                a[j]=a[j].nxt();                \n                if (mp[a1]==0||mp[a2]==0||mp[a3]==0||mp[a4]==0) continue;\n                re=1;\n                re*=mp[a1];insert(a1,-1);\n                re*=mp[a2];insert(a2,-1);\n                re*=mp[a3];insert(a3,-1);\n                re*=mp[a4];\n                insert(a1,1);insert(a2,1);insert(a3,1);\n                ans+=re;\n\n            }\n            insert(a[j],1);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nint n,t1[5],t2[5];\nLL tmp[4],s[410],Ans;\nmap<LL,int> S;\n\nLL gethash(int a,int b,int c,int d)\n{\n\tLL A=a*1000000000ll+b*1000000ll+c*1000ll+d;\n\tLL B=b*1000000000ll+c*1000000ll+d*1000ll+a;\n\tLL C=c*1000000000ll+d*1000000ll+a*1000ll+b;\n\tLL D=d*1000000000ll+a*1000000ll+b*1000ll+c;\n\treturn min(min(A,B),min(C,D));\n}\n\nvoid getcolor(LL hs,int &a,int &b,int &c,int &d)\n{\n\td=hs%1000; hs/=1000;\n\tc=hs%1000; hs/=1000;\n\tb=hs%1000; hs/=1000;\n\ta=hs%1000;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j,x,y,a,b,c,d;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ts[i]=gethash(a,b,c,d);\n\t}\n\tsort(s+1,s+n+1);\n\tfor (i=1;i<=n;i++) S[s[i]]++;\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t{\n\t\tgetcolor(s[i],t1[0],t1[1],t1[2],t1[3]);\n\t\tgetcolor(s[j],t2[0],t2[1],t2[2],t2[3]);\n\t\tS[s[i]]--; S[s[j]]--;\n\t\tfor (x=0;x<4;x++)\n\t\t{\n\t\t\ttmp[0]=gethash(t2[1],t2[0],t1[1],t1[0]);\n\t\t\ttmp[1]=gethash(t2[0],t2[3],t1[2],t1[1]);\n\t\t\ttmp[2]=gethash(t2[3],t2[2],t1[3],t1[2]);\n\t\t\ttmp[3]=gethash(t2[2],t2[1],t1[0],t1[3]);\n\t\t\tsort(tmp,tmp+4);\n\t\t\tint way;\n\t\t\tLL Sum=1;\n\t\t\tfor (y=0;y<4;y++)\n\t\t\t{\n\t\t\t\tif (!y||tmp[y]!=tmp[y-1])\n\t\t\t\t\tway=S[tmp[y]];\n\t\t\t\telse\n\t\t\t\t\tway--;\n\t\t\t\tSum=Sum*way;\n\t\t\t\tgetcolor(tmp[y],a,b,c,d);\n\t\t\t\tif (a==c&&b==d)\n\t\t\t\t{\n\t\t\t\t\tSum+=Sum;\n\t\t\t\t\tif (a==b) Sum+=Sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAns+=Sum;\n\t\t\tt1[4]=t1[0];\n\t\t\tfor (y=0;y<4;y++) t1[y]=t1[y+1];\n\t\t}\n\t\tS[s[i]]++; S[s[j]]++;\n\t}\n\tAns=Ans/3;\n\tprintf(\"%lld\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define ll long long\n#define N 110\nusing namespace std;\nstruct node{\n\tint a,b,c,d;\n\tnode(int A=0,int B=0,int C=0,int D=0):a(A),b(B),c(C),d(D){}\n\tvoid rotate(){int t=a;a=b,b=c,c=d,d=t;}\n\tbool operator<(const node u)const\n\t{\n\t\tif(a!=u.a) return a<u.a;\n\t\tif(b!=u.b) return b<u.b;\n\t\tif(c!=u.c) return c<u.c;\n\t\treturn d<u.d;\n\t}\n\tnode operator <<(const int a)const{node p=*this;for(int i=1;i<=a%4;i++){int swp=p.a;p.a=p.b;p.b=p.c;p.c=p.d;p.d=swp;}return p;}\n\tvoid operator <<=(const int a){*this=(*this)<<a;}\n}p[N];\nnode operator |(const node a,const node b)\n{\n\treturn node(a.b,a.a,b.a,b.d);\n}\nmap<node,int>mp;\nvoid insert(node a)\n{\n\tmp[a]++;mp[a<<1]++;\n\tmp[a<<2]++;mp[a<<3]++;\n}\nvoid del(node a){mp[a]--;mp[a<<1]--;mp[a<<2]--;mp[a<<3]--;}\nnode np[4],s1,s2;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&p[i].a,&p[i].b,&p[i].c,&p[i].d);\n\t\tinsert(p[i]);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdel(p[i]);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tdel(p[j]);\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tp[j]<<=1;s1=p[i],s2=p[j];\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t{\n\t\t\t\t\tnp[l]=s1|s2;\n\t\t\t\t\ts1<<=1,s2<<=3;\n\t\t\t\t}\n\t\t\t\tif(mp.count(np[0]) && mp.count(np[1]) && mp.count(np[2]) && mp.count(np[3]))\n\t\t\t\t{\n\t\t\t\t\tlong long sum=1ll;\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tsum*=mp[np[l]],del(np[l]);\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tinsert(np[l]);\n\t\t\t\t\tans+=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsert(p[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<vector<int>> C(N,vector<int>(4));\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n\n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n\n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n\n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            vector<vector<i64>> memo(N+1,vector<i64>(1<<4,-1));\n            vector<pair<int,int>> update;\n            bool unused[400];\n            vector<i64> sum(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==N) return res=0;\n                res=rec(k+1,b);\n                if(!unused[k]){\n                    rep(i_,0,4){\n                        if(b&(1<<i_) or Csum[k]!=sum[i_]) continue;\n                        rep(j_,0,4) if(match(rotatedC[k][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                    }\n                }\n                return res;\n            };\n\n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                sides=make_sides(i,j);\n                rep(i_,0,4){\n                    sum[i_]=0;\n                    rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                }\n                unused[i]=unused[j]=true;\n                rep(i_,0,N){\n                    if(i_==i or i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    unused[i_]=!use;\n                }\n                \n                ans+=rec(i+1,0);\n                \n                rotate(C[j].begin(),C[j].begin()+1,C[j].end());\n                for(auto& u:update) memo[u.first][u.second]=-1;\n                update.clear();\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    //sort(all(tmpVecs));   //こっちでも良いけど，lambda練習用に↓\n    sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int>& a,vector<int>& b){//ちゃんと参照渡しするように\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n//pure　こっちでもいい\n/*int getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}*/\n\nint n;\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]= getWay(v);\n    }\n    LL ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];\n                    /*tmpTile[0]=ue[(l+1)%4];   こっちはらて氏のパクリ\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];*/\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=405;\n\nstruct vec{\n\tint a[4];\n\tvec(){a[0]=a[1]=a[2]=a[3]=0;}\n\tvec(int x,int y,int z,int t){a[0]=x,a[1]=y,a[2]=z,a[3]=t;}\n\tvoid read(){for(int i=0;i<4;i++)scanf(\"%d\",&a[i]);}\n\tvoid move(){int t=a[0];a[0]=a[1],a[1]=a[2],a[2]=a[3],a[3]=t;}\n\tint& operator[](int x){return a[x];}\n\tbool friend operator<(const vec&x,const vec&y){\n\t\tfor(int i=0;i<4;i++)if(x.a[i]!=y.a[i])return x.a[i]<y.a[i];\n\t\treturn false;\n\t}\n\tbool friend operator==(const vec&x,const vec&y){\n\t\tfor(int i=0;i<4;i++)if(x.a[i]!=y.a[i])return false;\n\t\treturn true;\n\t}\n\tpair<vec,int> move_to_best(){\n\t\tvec r=*this;int t=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(*this<r)r=*this,t=1;\n\t\t\telse if(r==*this)t++;\n\t\t\tthis->move();\n\t\t}\n\t\treturn {r,t};\n\t}\n};\n\nstruct node{\n\tll way[4];\n\tll get(int x){ll r=way[x-1];while(x)r*=x--;return r;}\n\tvoid update(int u){for(int i=3;i;i--)way[i]+=way[i-1]*u;way[0]+=u;}\n\tvoid dndate(int u){way[0]-=u;for(int i=1;i<=3;i++)way[i]-=way[i-1]*u;}\n};\nmap<vec,node> data;\nmap<vec,int> now;\nvec fc[N];\nint ti[N],n;\nll ans;\n\nll chk(vector<vec> faces){\n\tnow.clear();\n\tfor(auto p:faces)now[p.move_to_best().fi]++;\n\tll ret=1;\n\tfor(auto it:now){\n\t\tif(!data.count(it.fi))return 0;\n\t\tret*=data[it.fi].get(it.se);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tfc[i].read();\n\t\tauto p=fc[i].move_to_best();\n\t\tdata[fc[i]=p.fi].update(p.se);\n\t\tti[i]=p.se;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdata[fc[i]].dndate(ti[i]);\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tdata[fc[j]].dndate(ti[j]);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tauto&a=fc[i],&b=fc[j];\n\t\t\t\tans+=chk({vec(b[1],b[0],a[1],a[0]),vec(a[1],b[0],b[3],a[2]),vec(a[3],a[2],b[3],b[2]),vec(b[1],a[0],a[3],b[2])});\n\t\t\t\tfc[j].move();\n\t\t\t}\n\t\t\tdata[fc[j]].update(ti[j]);\n\t\t}\n\t\tdata[fc[i]].update(ti[i]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p 107\n#define q 1000000007ll\n#define Val(x) ((((ll)x) % q + q ) % q)\n#define ll long long\n#define maxn 405\nusing namespace std;\nint col[maxn][4];\nint h[maxn],cnt[maxn];\ninline int cal(int a,int b,int c,int d) {\n\tvector<int> col = {a,b,c,d};\n\tint ret = q;\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\tint hash = 0;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\thash = Val(hash*p+col[(rot+i)%4]);\n\t\t\tret = min(ret,hash);\n\t\t}\n\t\treverse(col.begin(),col.end());\n\t}\n\treturn ret;\n}\nll dp[maxn][1<<4];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=0;j<4;j++)\n\t\t\tcin >> col[i][j];\n\t\th[i] = cal(col[i][0],col[i][1],col[i][2],col[i][3]);\n\t\tfor(int t=0;t<2;t++) {\n\t\t\tint tem_cnt = 0;\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tint hash = 0;\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\thash = Val(hash*p+col[i][(rot+j)%4]);\n\t\t\t\tif(hash == h[i])\n\t\t\t\t\ttem_cnt++;\n\t\t\t}\n\t\t\tcnt[i] = max(cnt[i],tem_cnt);\n\t\t\treverse(col[i],col[i]+4);\n\t\t}\n\t}\n\t\n\tdp[0][0] = 1;\n\tll ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\treverse(col[j],col[j]+4);\n\t\t\tfor(int rot=0;rot<4;rot++) {\n\t\t\t\tvector<int> t1(4),t2(4);\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tt1[k] = col[i][k];\n\t\t\t\t\tt2[k] = col[j][(rot+k)%4];\n\t\t\t\t}\n\t\t\t\tvector<int> need(4);\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tneed[k] = cal(t1[k],t1[(k+1)%4],t2[(k+1)%4],t2[k]);\n\t\t\t\tint idx = 1;\n\t\t\t\tfor(int k=i+1;k<=n;k++) {\n\t\t\t\t\tif(k == j)\tcontinue;\n\t\t\t\t\tmemcpy(dp[idx],dp[idx-1],sizeof dp[idx-1]);\n\t\t\t\t\tfor(int state=0;state<16;state++) {\t\t// 2^4\n\t\t\t\t\t\tfor(int t=0;t<4;t++)\n\t\t\t\t\t\t\tif((state & (1<<t)) == 0 && need[t] == h[k])\n\t\t\t\t\t\t\t\tdp[idx][state|(1<<t)] += cnt[k]*dp[idx-1][state];\n\t\t\t\t\t}\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t\tans += dp[idx-1][(1<<4)-1];\n\t\t\t}\n\t\t\treverse(col[j],col[j]+4);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nll color[408][4];\nll has(ll a[])\n{\n\tll res=0;\n\tfor(ll i=N-1;i>=0;i--) res=res*1008ll+(ll)a[i];\n\treturn res;\n}\nvector<ll> _rotate(ll c[])\n{\n\tvector<ll> res;\n\tfor(ll i=0;i<N;i++) \n\t{\n\t\tll a[4];for(ll j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nll same(ll x,ll y)\n{\n\tll a[N],c[N];ll sum=0;\n\tfor(ll i=0;i<N;i++) a[i]=x%1008,x/=1008;\n\tfor(ll i=0;i<N;i++) \n\t{\n\t\tfor(ll j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(ll x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(ll i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(ll c1[],ll c2[])\n{\n\tll p=has(c2);\n\tll a[4];ll ck[4];\n\tfor(ll i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(ll i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(ll j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t\tcnt*=(ll)m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint main()\n{\n\tll n;cin>>n;\n\tfor(ll i=1;i<=n;i++) for(ll j=0;j<N;j++) cin>>color[i][j];\n\tfor(ll i=n;i>=1;i--)\n\t{\n\t\tfor(ll j=i+1;j<=n;j++)\n\t\t{\n\t\t\tll a[N],b[N];for(ll k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(ll k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tll c[4];\n\t\t\t//\tc[0]=color[j][0],c[1]=color[j][3],c[2]=color[j][2],c[3]=color[j][1];\n\t\t\t\tfor(ll l=0;l<N;l++)\n\t\t\t\t\ta[l]=color[j][(l+k)%N];\n\t\t\t\tans+=operate(b,a);\n\t\t\t}\n\t\t}\n\t\tswap(color[i][1],color[i][3]);\n\t\tins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <utility>\n#define FR first\n#define SE second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pr;\n\npr calc(int a[4]) {\n  ll fir=0;\n  for(int i=0;i<4;i++) fir=fir*1000+a[i];\n  ll minn=fir;\n  int cnt=1;\n  for(int i=1;i<4;i++) {\n  \tll s=0;\n  \tfor(int j=0;j<4;j++) s=s*1000+a[(i+j)&3];\n  \tminn=min(minn,s);\n  \tcnt+=(s==fir);\n  }\n  return pr(minn,cnt);\n}\n\nmap <ll,int> mp;\n\nll rep(pr a[4]) {\n  ll s[4],num[4],v=1;\n  for(int i=0;i<4;i++) {\n    s[i]=mp[a[i].FR];\n    num[i]=a[i].FR;\n    v*=a[i].SE;\n  }\n  ll ans=0;\n  ans+=s[0]*s[1]*s[2]*s[3];\n  if (num[0]==num[1]) ans-=s[0]*s[2]*s[3];\n  if (num[0]==num[2]) ans-=s[0]*s[1]*s[3];\n  if (num[0]==num[3]) ans-=s[0]*s[1]*s[2];\n  if (num[1]==num[2]) ans-=s[0]*s[1]*s[3];\n  if (num[1]==num[3]) ans-=s[0]*s[1]*s[2];\n  if (num[2]==num[3]) ans-=s[0]*s[1]*s[2];\n  if (num[0]==num[1]&&num[2]==num[3]) ans+=s[0]*s[2];\n  if (num[0]==num[2]&&num[1]==num[3]) ans+=s[0]*s[1];\n  if (num[0]==num[3]&&num[1]==num[2]) ans+=s[0]*s[1];\n  if (num[0]==num[1]&&num[1]==num[2]) ans+=2LL*s[0]*s[3];\n  if (num[0]==num[1]&&num[1]==num[3]) ans+=2LL*s[0]*s[2];\n  if (num[0]==num[2]&&num[2]==num[3]) ans+=2LL*s[0]*s[1];\n  if (num[1]==num[2]&&num[2]==num[3]) ans+=2LL*s[0]*s[1];\n  if (num[0]==num[1]&&num[1]==num[2]&&num[2]==num[3]) ans-=6LL*s[0];\n  return ans*v;\n}\n\nll getans(int a[4],int b[4]) {\n  mp[calc(a).FR]--;mp[calc(b).FR]--;\n  ll ans=0;\n  for(int i=0;i<4;i++) {\n  \tpr t[4];\n  \tfor(int j=0;j<4;j++) {\n  \t\tint now[4];\n  \t\tnow[0]=a[(j+1)&3];now[1]=a[j];\n  \t\tnow[2]=b[(i-j+1)&3];now[3]=b[(i-j)&3];\n  \t\tt[j]=calc(now);\n\t  }\n\tans+=rep(t);\n  }\n  mp[calc(a).FR]++;mp[calc(b).FR]++;\n  return ans;\n}\n\nint num[405][4];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tfor(int j=0;j<4;j++) scanf(\"%d\",&num[i][j]);\n  \tpr t=calc(num[i]);\n  \tmp[t.FR]++;\n  }\n  ll ans=0;\n  for(int i=1;i<n;i++)\n    for(int j=i+1;j<=n;j++) \n\t  ans+=getans(num[i],num[j]);\n  printf(\"%lld\\n\",ans/3);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=410;\nstruct Tile{\n\tconst static int D=4;\n\tint a[D];\n\tinline bool cmp(int x,int y){\n\t\tfor(int i=0;i<D;(++x)%=D,(++y)%=D,i++){\n\t\t\tif(a[x]!=a[y])return a[x]<a[y];\n\t\t}\n\t\treturn false;\n\t}\n\tinline bool equal(int x,int y){\n\t\tfor(int i=0;i<D;(++x)%=D,(++y)%=D,i++){\n\t\t\tif(a[x]!=a[y])return false;\n\t\t}\n\t\treturn true;\n\t}\n\tinline void sani(){\n\t\tint j=0;\n\t\tfor(int i=1;i<D;i++){\n\t\t\tif(cmp(i,j)){\n\t\t\t\tj=i;\n\t\t\t}\n\t\t}\n\t\tint b[D];\n\t\tmemcpy(b,a,D<<2);\n\t\tfor(int i=0;i<D;i++,(++j)%=D){\n\t\t\ta[i]=b[j];\n\t\t}\n\t}\n\tinline int getloop(){\n\t\tint cnt=0;\n\t\tfor(int i=0;i<D;i++){\n\t\t\tcnt+=equal(0,i);\n\t\t}\n\t\treturn cnt;\n\t}\n\tinline friend bool operator < (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<D;i++){\n\t\t\tif(a.a[i]!=b.a[i])return a.a[i]<b.a[i];\n\t\t}\n\t\treturn false;\n\t}\n\tinline friend bool operator == (const Tile &a,const Tile &b){\n\t\tfor(int i=0;i<D;i++){\n\t\t\tif(a.a[i]!=b.a[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n}tile[N];\nmap<Tile,int>m;\nint main(){\n\tint n=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ttile[i]=(Tile){ni,ni,ni,ni};\n\t\ttile[i].sani();\n\t\tm[tile[i]]++;\n\t}\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tm[tile[i]]--;\n\t\tint *a=tile[i].a;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tint *b=tile[j].a;\n\t\t\tm[tile[j]]--;\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\tTile t[4];\n\t\t\t\tfor(int e=0;e<4;e++){\n\t\t\t\t\tt[e]=(Tile){a[e+1],a[e],b[(d+4-e)&3],b[(d+3-e)&3]};\n\t\t\t\t\tt[e].sani();\n\t\t\t\t}\n\t\t\t\tsort(t,t+4);\n\t\t\t\tlint tmp=1,cnt[4];\n\t\t\t\tfor(int e=0;e<4;e++){\n\t\t\t\t\tif(e&&t[e]==t[e-1]){\n\t\t\t\t\t\tcnt[e]=cnt[e-1]-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcnt[e]=m[t[e]];\n\t\t\t\t\t}\n\t\t\t\t\ttmp*=cnt[e]*t[e].getloop();\n\t\t\t\t\tif(tmp==0)break;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tm[tile[j]]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\n\nvector<int> standard(vector<int> x) {\n   for (int i = 0; i < 4; i++) x.push_back(x[i]);\n\n   vector<int> ret = {10000, 10000, 100000, 100000};\n   for (int j = 0; j < 4; j++) {\n     vector<int> color;\n     for (int k = 0; k < 4; k++) color.push_back(x[j + k]);\n     if (ret > color) ret = color;\n   }\n   return ret;\n}\n\nvoid dump(vector<int> x) {\n   for (auto val : x) cout << val << \" \";\n   cout << endl;\n}\n\nint main() {\n   int N;\n   cin >> N;\n   map<vector<int>, int> colors;\n   map<vector<int>, int> muls;\n   for (int i = 0; i < N; i++) {\n     int a, b, c, d;\n     cin >> a >> b >> c >> d;\n     vector<int> base_color = {a, d, c, b, a, d, c, b};\n     vector<vector<int>> tmp_color;\n     for (int j = 0; j < 4; j++) {\n       vector<int> color;\n       for (int k = 0; k < 4; k++) color.push_back(base_color[j + k]);\n       tmp_color.push_back(color);\n     }\n     vector<int> color = standard(tmp_color[0]);\n     colors[color]++;\n     int mul = 0;\n     for (int j = 0; j < 4; j++)\n       if (tmp_color[0] == tmp_color[j]) mul++;\n     muls[color] = mul;\n   }\n\n   LL ans = 0;\n   vector<vector<int>> keys;\n   for (auto key : colors) {\n     keys.push_back(key.first);\n   }\n\n   for (auto low : keys) {\n     for (auto up : keys) {\n       for (int z = 0; z < 4; z++) {\n         LL ret = 1;\n         ret *= colors[low];\n         colors[low]--;\n         ret *= colors[up];\n         colors[up]--;\n\n         vector<vector<int>> hozon;\n         for (int i = 0; i < 4; i++) {\n           vector<int> cur;\n           cur = {low[(7 - i) % 4], low[(6 - i) % 4], up[(1 + i + z) % 4],\n                  up[(i + z) % 4]};\n           cur = standard(cur);\n           ret *= colors[cur] * muls[cur];\n           colors[cur]--;\n           hozon.push_back(cur);\n         }\n         for (auto color : hozon) {\n           colors[color]++;\n         }\n\n         ans += ret;\n         colors[low]++;\n         colors[up]++;\n       }\n     }\n   }\n   cout << ans / 6 << endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\nusing ll = long long;\n\nconst ll M1 = (1 << 10) - 1;\nconst ll M2 = (1 << 20) - 1;\n\nll get_min(ll c) {\n    ll m;\n    m = c;\n    rep (i, 0, 3) {\n        c = (c >> 10) | ((c & M1) << 30);\n        m = min(m, c);\n    }\n\n    return m;\n}\n\nint solve(int n, vector<ll> &ca, unordered_map<ll, int> &colors) {\n    ll ans;\n    ll c2, c3, c4, c5;\n    ll ci, cj;\n    ll r, c;\n    int k, h;\n    int rot;\n    unordered_map<ll, int> nd;\n\n    ans = 0;\n    rep (i, 0, n - 5) {\n        ci = ca[i];\n        --colors[ci];\n        rep (j, i + 1, n) {\n            cj = ca[j];\n            --colors[cj];\n            rep (jj, 0, 4) {\n                nd.clear();\n                c2 = (((cj >> 20) & M1) << 30) | ((cj >> 30) << 20) | (((ci >> 20) & M1) << 10) | (ci >> 30);\n                c2 = get_min(c2);\n                nd[c2] = 1;\n                c3 = ((ci & M1) << 30) | (((ci >> 10) & M1) << 20) | ((cj & M1) << 10) | ((cj >> 10) & M1);\n                c3 = get_min(c3);\n                if (c3 == c2) {\n                    ++nd[c3];\n                } else {\n                    nd[c3] = 1;\n                }\n                c4 = (((cj >> 20) & M1) << 30) | (((ci >> 30) & M1) << 20) | ((ci & M1) << 10) | ((cj >> 10) & M1);\n                c4 = get_min(c4);\n                if (c4 == c2 || c4 == c3) {\n                    ++nd[c4];\n                } else {\n                    nd[c4] = 1;\n                }\n                c5 = (((ci >> 20) & M1) << 30) | (((cj >> 30) & M1) << 20) | ((cj & M1) << 10) | ((ci >> 10) & M1);\n                c5 = get_min(c5);\n                if (c5 == c2 || c5 == c3 || c5 == c4) {\n                    ++nd[c5];\n                } else {\n                    nd[c5] = 1;\n                }\n                r = 1;\n                for (auto p : nd) {\n                    c = p.first;\n                    k = p.second;\n                    if (colors.find(c) == colors.end()) {\n                        r = 0;\n                        break;\n                    }\n                    h = colors[c];\n                    if (h < k) {\n                        r = 0;\n                        break;\n                    }\n                    if ((c >> 20) == (c & M2)) {\n                        rot = 2;\n                        if ((c >> 30) == ((c >> 20) & M1) && ((c >> 10) & M1) == (c & M1)) {\n                            rot = 4;\n                        }\n                    } else {\n                        rot = 1;\n                    }\n                    while (0 < k) {\n                        r *= h * rot;\n                        --h;\n                        --k;\n                    }\n                }\n                ans += r;\n                cj = (cj >> 10) | ((cj & M1) << 30);\n            }\n            ++colors[cj];\n        }\n    }\n\n    return (int)ans;\n}\n\n\n\nint main(int argc, const char * argv[]) {\n    int n;\n    ll c0, c1, c2, c3;\n    ll c, m;\n    unordered_map<ll, int> colors;\n    vector<ll> ca;\n\n    cin >> n;\n    ca.resize(n);\n    fill(ca.begin(), ca.end(), -1);\n    rep (i, 0, n) {\n        cin >> c0 >> c1 >> c2 >> c3;\n        c = (c0 << 30) | (c1 << 20) | (c2 << 10) | c3;\n        m = get_min(c);\n        ca[i] = m;\n        if (colors.find(m) != colors.end()) {\n            ++colors[m];\n        } else {\n            colors[m] = 1;\n        }\n    }\n\n    cout << solve(n, ca, colors) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i) & 3];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)&3] < colors[(j+k)&3]) return true;\n            if (colors[(i+k)&3] > colors[(j+k)&3]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors &a, Colors &b, Colors &brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    FOREACH(pb, colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        colcnt[b]--;\n        FORN(rot, 4) {\n            LL curans =\n            ans += multi * countfit(a, b, brot);\n            brot.rotate_left(1);\n        }\n        colcnt[b]++;\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        Colors a = tiles[i];\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef pair<ll,pi> pii;\ntypedef vector<pi> vpi;\ntypedef set<ll> si;\ntypedef long double ld;\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\nll INF = 1e9;\nll MOD = 1e9;\n#define lb lower_bound\n#define ub upper_bound\n#define SZ(x) (ll)x.size()\n#define ALL(x) x.begin(),x.end()\n#define count(V,x) ub(ALL(V),x,cmp) - lb(ALL(V),x,cmp)\n\nstruct cube{\n  ll a, b, c, d, orien;\n  cube(ll _a, ll _b, ll _c, ll _d): a(_a), b(_b), c(_c), d(_d), orien(1){\n    ll m = min({a,b,c,d});\n    if (a == b && a == c && a == d)orien = 4;\n    else if (a == c && b == d)orien = 2;\n  }\n\n  bool fit(cube cmp){\n    return a == cmp.a && b == cmp.b && c == cmp.c && d == cmp.d;\n  }\n\n  cube rotate(){\n    return cube({b,c,d,a});\n  }\n\n  void pp(){\n    cout<<a<<' '<<b<<' '<<c<<' '<<d<<'\\n';\n  }\n};\n\nbool cmp(cube a, cube b){\n  if (a.a != b.a)return a.a < b.a;\n  if (a.b != b.b)return a.b < b.b;\n  if (a.c != b.c)return a.c < b.c;\n  return a.d < b.d;\n}\n\nbool biggay = 0;\n\ncube bal(cube t){\n  cube q = t.rotate();\n  cube r = q.rotate();\n  cube u = r.rotate();\n  if (cmp(q, t))t = q;\n  if (cmp(r, t))t = r;\n  if (cmp(u, t))t = u;\n  return t;\n}\n\nll N;\nll a,b,c,d;\nvector<cube> V,faces,comp;\nvi rep;\n\nint main(){\n  // freopen(\"in.txt\",\"r\",stdin);\n  cin >> N;\n  for (int i=0;i<N;++i){\n    cin >>a >> b >> c >> d;\n    V.pb({a,b,c,d});\n    V[i] = bal(V[i]);\n  }\n  sort(ALL(V), cmp);\n  // for (auto i : V)i.pp();\n  // cout<<'\\n';\n  // cout<<cmp (cube(0,1,2,3), cube(0,1,2,4) )<<'\\n';\n  // return 0;\n  ll ans=0;\n  for (int i=0;i<N-1;++i){\n    // Base\n    // if (i != 1)continue;\n    for (int j=i+1;j<N;++j){\n      // if (j != 3)continue;\n      cube top = V[i];\n      cube btm = V[j];\n      rep.clear();\n      faces.clear();\n      comp.clear();\n      for (int k=0;k<4;++k){\n        ll r = 1;\n\n        faces.pb(bal(cube(top.d,top.c,btm.c,btm.b)));\n        faces.pb(bal(cube(top.c,top.b,btm.d,btm.c)));\n        faces.pb(bal(cube(top.b,top.a,btm.a,btm.d)));\n        faces.pb(bal(cube(top.a,top.d,btm.b,btm.a)));\n\n        sort(ALL(faces), cmp);\n\n        r *= faces[0].orien;\n        r *= faces[1].orien;\n        r *= faces[2].orien;\n        r *= faces[3].orien;\n        \n        comp.pb(faces[0]);\n        rep.pb(1);\n\n        if (comp.back().fit(faces[1])){\n          ++rep.back();\n        }else{\n          comp.pb(faces[1]);\n          rep.pb(1);\n        }\n        if (comp.back().fit(faces[2])){\n          ++rep.back();\n        }else{\n          comp.pb(faces[2]);\n          rep.pb(1);\n        }\n        if (comp.back().fit(faces[3])){\n          ++rep.back();\n        }else{\n          comp.pb(faces[3]);\n          rep.pb(1);\n        }\n\n        for (int k=0;k<SZ(comp); ++k){\n          cube it = comp[k];\n          int cnt = count(V, it);\n          if (V[i].fit(it))--cnt;\n          if (V[j].fit(it))--cnt;\n          while(rep[k]){\n            --rep[k];\n            r *= cnt;\n            cnt--;\n          }\n        }\n        ans += r;\n        top = top.rotate();\n      }\n    }\n  }\n  cout<<ans/3;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath> \n#include<cstring> \n#include<cassert>\n#include<string>\n#include<sstream>\n#include<fstream>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<stack>\n#include<set>\n#include<bitset>\n#include<iomanip>\n#include<utility>\n#include<functional>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cwchar>\n#include<cwctype>\n#include<exception>\n#include<locale>\n#include<numeric>\n#include<new>\n#include<stdexcept>\n#include<limits>\nusing namespace std;\n\n#define ll long long\n#define INF 1e9\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define sz(s) s.size()\n#define all(s) (s.begin(),s.end())\n\nconst int maxn=405;\nint n;\nll ans;\nint a[4];\nclass tile{\npublic:\n\tint c[4],cnt;\n\ttile(){\n\t\tmemset(c,0,sizeof(c));\n\t}\n\ttile(int a[]){\n\t\trep(i,4)c[i]=a[i];\n\t}\n\tbool operator <(const tile &other)const{\n\t\trep(i,3)if(c[i]!=other.c[i])return c[i]<other.c[i];\n\t\treturn c[3]<other.c[3];\n\t}\n\tbool operator ==(const tile &other)const{\n\t\trep(i,4)if(c[i]!=other.c[i])return false;\n\t\treturn true;\n\t}\n\ttile Rotate(){\n\t\ttile res=tile();\n\t\trep(i,4)res.c[i]=c[(i+3)%4];\n\t\treturn res;\n\t}\n\ttile change(){\n\t\tcnt=0;\n\t\ttile t[4];\n\t\trep(i,4)t[0].c[i]=c[i];\n\t\tREP(i,3)t[i]=t[i-1].Rotate();\n\t\tsort(t,t+4);\n\t\trep(i,4)if(t[i]==t[0])cnt++;\n\t\treturn t[0];\n\t}\n\tvoid debug(){\n\t\trep(i,4)printf(\"%d \",c[i]);\n\t\tputs(\"\");\n\t}\n}t[maxn];\nmap<tile,int>mp;\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\trep(j,4)scanf(\"%d\",&a[j]);\n\t\tt[i]=tile(a);\n\t\tmp[t[i].change()]++;\n\t}\n\trep(i,n)\n\t\tfor(int j=i+1;j<n;j++){\n\t\ttile A=t[i],B=t[j];\n\t\tmp[A.change()]--;\n\t\tmp[B.change()]--;\n\t\trep(C,4){\n\t\t\tmap<tile,int>cur=mp;\n\t\t\tint cur1=0,cur2=0;\n\t\t\tll res=1LL*1;\n\t\t\trep(k,4){\n\t\t\t\ta[0]=A.c[cur1],a[1]=A.c[(cur1+3)%4],a[2]=B.c[cur2],a[3]=B.c[(cur2+3)%4];\n\t\t\t\ttile now=tile(a);\n\t\t\t\tres*=1LL*cur[now.change()]*now.cnt;\n\t\t\t\tif(cur[now.change()])cur[now.change()]--;\n\t\t\t\tcur1=(cur1+3)%4;\n\t\t\t\tcur2=(cur2+1)%4;\n\t\t\t}\n\t\t\tans+=res;\n\t\t\tB=B.Rotate();\n\t\t} \n\t\tmp[A.change()]++;\n\t\tmp[B.change()]++;\n\t}\n\tprintf(\"%lld\",ans/3);\n\treturn 0;\n}\n/*\n6\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\n#define N 410\n#define lint long long\n#define ull unsigned long long\n#define gc getchar()\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nint Gc;unordered_map<lint,int> cnt;lint val[1000];\nint c[N][5];lint cv[N][4];\ninline lint hv(int a,int b,int c,int d)\n{\n\treturn a*1000000000ll+b*1000000ll+c*1000ll+d;\n}\ninline lint hv(int *a)\n{\n\treturn hv(a[0],a[1],a[2],a[3]);\n}\ninline int Rot(int *a,int c)\n{\n\trep(i,1,c)\n\t{\n\t\tint tmp=a[0];\n\t\trep(j,1,3) a[j-1]=a[j];\n\t\ta[3]=tmp;\n\t}\n\treturn 0;\n}\ninline int Add(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]++;\n\treturn 0;\n}\ninline int Del(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]--;\n\treturn 0;\n}\ninline int Get(int a,int b,int c,int d)\n{\n\tint t=cnt[hv(a,b,c,d)];\n\tif(!t) return 0;\n\tcnt[val[++Gc]=hv(a,b,c,d)]--;\n\tcnt[val[++Gc]=hv(b,c,d,a)]--;\n\tcnt[val[++Gc]=hv(c,d,a,b)]--;\n\tcnt[val[++Gc]=hv(d,a,b,c)]--;\n\treturn t;\n}\ninline int Back()\n{\n\trep(i,1,Gc) cnt[val[i]]++;\n\tGc=0;return 0;\n}\nint main()\n{\n\tint n=inn();ull ans=0ll;\n\trep(i,1,n) rep(j,0,3) c[i][j]=inn();\n\trep(i,1,n)\n\t{\n\t\t#define a c[i]\n\t\tcnt[cv[i][0]=hv(a[0],a[1],a[2],a[3])]++;\n\t\tcnt[cv[i][1]=hv(a[1],a[2],a[3],a[0])]++;\n\t\tcnt[cv[i][2]=hv(a[2],a[3],a[0],a[1])]++;\n\t\tcnt[cv[i][3]=hv(a[3],a[0],a[1],a[2])]++;\n\t\t#undef a\n\t}\n\trep(i,1,n)\n\t{\n\t\tDel(i);\n\t\trep(p,0,3)\n\t\t{\n//\t\t\tRot(c[i],p);\n\t\t\trep(j,1,n) if(i!=j)\n\t\t\t{\n\t\t\t\tDel(j);\n\t\t\t\trep(q,0,3)\n\t\t\t\t{\n//\t\t\t\t\tRot(c[j],q);\n\t\t\t\t\tint s,x,z,y;\n\t\t\t\t\ts=Get(c[j][1],c[j][0],c[i][1],c[i][0]);//S\n\t\t\t\t\tif(!s) goto loop;\n\t\t\t\t\tx=Get(c[j][2],c[i][3],c[i][2],c[j][3]);//X\n\t\t\t\t\tif(!x) goto loop;\n\t\t\t\t\tz=Get(c[j][1],c[i][0],c[i][3],c[j][2]);//Z\n\t\t\t\t\tif(!z) goto loop;\n\t\t\t\t\ty=Get(c[i][1],c[j][0],c[j][3],c[i][2]);//Y\n\t\t\t\t\tif(!y) goto loop;\n\t\t\t\t\tans+=1ll*s*x*z*y;\n\t\t\t\t\tloop:;\n\t\t\t\t\tBack();\n\t\t\t\t\tRot(c[j],1);\n\t\t\t\t}\n\t\t\t\tAdd(j);\n\t\t\t}\n\t\t\tRot(c[i],1);\n\t\t}\n\t\tAdd(i);\n\t}\n\treturn !printf(\"%llu\\n\",ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\nconst int MAX_N=400;\n\n\nstruct TILE{\n\tint c[4];\n\tint index;\n\tTILE(int a=0,int b=0,int f=0, int d=0,int ind=0){\n\t\tc[0]=a;\n\t\tc[1]=b;\n\t\tc[2]=f;\n\t\tc[3]=d;\n\t\tindex=ind;\n\t}\n\tbool operator < (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn c[i]<t.c[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator == (const TILE &t)const{\n\t\tREP(i,4){\n\t\t\tif (c[i]!=t.c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nTILE rotate(const TILE &t,int x){\n\tTILE res=t;\n\tREP(i,x){\n\t\t\tTILE temp=res;\n\t\t\tREP(j,4){\n\t\t\t\tres.c[j]=temp.c[(j+3)%4];\n\t\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nTILE T[MAX_N*4];\nint pa[4]={1,0,3,2};\nmap<TILE,int> mp;\n\nint main(){\n\tscanf(\"%d\",&N);\n\tREP(i,N){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tT[i*4]=TILE(a,b,c,d,i);\n\t\tFOR(j,1,4){\n\t\t\tT[i*4+j]=rotate(T[i*4],j);\n\t\t}\n\t}\n//\tsort(T,T+N*4);\n\tREP(i,N*4){\n\t\tmp[T[i]]++;\n\t}\n\tll ans=0;\n\tTILE TI[6];\n\tint cnt[4];\n\tint cnt2[4][4];\n\tREP(i,N*4){\n\t\tTI[0]=T[i];\n\t\tREP(j,N*4){\n\t\t\tif (TI[0].index==T[j].index) continue;\n\t\t\tTI[1]=T[j];\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tREP(k,4){\n\t\t\t\tTI[k+2]=TILE(TI[0].c[(k+1)%4],TI[0].c[k],TI[1].c[pa[k]],TI[1].c[pa[(k+1)%4]],0);\n\t\t\t}\n\t\t\tREP(k,4){\n//\t\t\t\tcnt[k]=upper_bound(T,T+N*4,TI[k+2])-lower_bound(T,T+N*4,TI[k+2]);\n\t\t\t\tcnt[k]=mp[TI[k+2]];\n\t\t\t\tREP(a,2){\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a],b)){\n\t\t\t\t\t\t\tcnt[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k,4){\n\t\t\t\tFOR(a,k+1,4){\n\t\t\t\t\tcnt2[k][a]=0;\n\t\t\t\t\tREP(b,4){\n\t\t\t\t\t\tif (TI[k+2]==rotate(TI[a+2],b)){\n\t\t\t\t\t\t\tcnt2[k][a]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tll temp=1;\n\t\t\tREP(k,4){\n\t\t\t\tREP(a,k){\n\t\t\t\t\tcnt[k]-=cnt2[a][k];\n\t\t\t\t}\n\t\t\t\tif (cnt[k]<0){\n\t\t\t\t\tf=true;\n\t\t\t\t}else{\n\t\t\t\t\ttemp*=cnt[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f){\n\t\t\t\tans+=temp;\n\t\t\t}\n\t\t}\n\t}\n\tans/=24;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sync ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define F first\n#define S second\n#define pb emplace_back\n#define mt make_tuple\n#define gcd __gcd\n#define PI 3.141592653589\n// Input\n#define in(a) scanf(\"%d\",&a)\n#define in2(a,b) scanf(\"%d%d\",&a,&b)\n#define in3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define llin(a) cin >> a\n#define inl(a) scanf(\"%lld\",&a)\n#define read(v,i,n) for(i=0;i<n;i++)in(v[i])\n#define twod(mat,i,j,n,m) rep(i,n){rep(j,m)in(mat[i][j]);}\n#define sc(ch) scanf(\"%c\",&ch)\n#define sstr(str) scanf(\"%s\",str)\n// Output\n#define pr(a) printf(\"%d \",a)\n#define pr2(a,b) printf(\"%d %d\\n\",a,b)\n#define pr3(a,b,c) printf(\"%d %d %d\\n\",a,b,c)\n#define out(a) printf(\"%d\\n\",a)\n#define outl(a) printf(\"%lld\\n\",a)\n#define llpr(a) cout << a << \" \"\n#define llout(a) cout << a << \"\\n\"\n#define yes printf(\"YES\\n\")\n#define no printf(\"NO\\n\")\n#define lin printf(\"\\n\")\n// Iterator\n#define lp(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) for(i=0;i<n;i++)\n#define all(vec) vec.begin(),vec.end()\n#define lower(v,k) lower_bound(v.begin(),v.end(),k)-v.begin()\n#define upper(v,k) upper_bound(v.begin(),v.end(),k)-v.begin()\n#define tf(mytuple) get<0>(mytuple)\n#define ts(mytuple) get<1>(mytuple)\n#define tt(mytuple) get<2>(mytuple)\n// Debug\n#define dbg(v,i,n) for(i=0;i<n;i++)pr(v[i]); lin\n#define what(x) cerr << #x << \" : \" << x << \"\\n\"\n#define ck printf(\"continue\\n\")\n#define debug(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n\tcerr << *it << \" = \" << a << \"\\n\";\n\terr(++it, args...);\n}\n// Data Type\n#define ll long long int\n#define ii pair<int,int>\n#define pli pair<ll,int>\n#define triple tuple<int,int,int>\n#define vi vector<int>\n#define vii vector<pair<int,int> >\n#define vvi vector<vector<int> >\n#define viii vector<pair<pair<int,int>,int> >\n#define vvii vector<vector<pair<int,int> > >\n#define M 1000000007\n#define N 1000  //check the limits, man\nconst ll INF = 1e12;\nint v[N][4];\nll val[N];\nll hashvalue(ll a,ll b,ll c,ll d)\n{\n    return a*N*N*N+b*N*N+c*N+d;\n}\nvoid convert(int i)\n{\n    val[i]=INF;\n    int k;\n    rep(k,4)\n        val[i]=min(val[i],hashvalue(v[i][k],v[i][(k+1)%4],v[i][(k+2)%4],v[i][(k+3)%4]));\n    return ;\n}\npli keyvalue(ll a,ll b,ll c,ll d)\n{\n    ll ar[4]={a,b,c,d};\n    ll key=INF;\n    int k;\n    rep(k,4)\n        key=min(key,hashvalue(ar[k],ar[(k+1)%4],ar[(k+2)%4],ar[(k+3)%4]));\n    k=1;\n    if(a==b && b==c && c==d)\n        k=4;\n    else if(a==c && b==d)\n        k=2;\n    return {key,k};\n}\nint main()\n{\n    int n,i,j,k,a,b,c,d,p,q,r,s;\n    in(n);\n    twod(v,i,j,n,4);\n    map<ll,int> cnt;\n    rep(i,n)\n        convert(i),cnt[val[i]]++;\n    ll ans=0,temp;\n    pli key1,key2,key3,key4;\n    rep(i,n)\n    {\n        a=v[i][0],b=v[i][1],c=v[i][2],d=v[i][3];\n        cnt[val[i]]--;\n        lp(j,i+1,n)\n        {\n            cnt[val[j]]--;\n            rep(k,4)\n            {\n                temp=1;\n                p=v[j][k],q=v[j][(k+1)%4],r=v[j][(k+2)%4],s=v[j][(k+3)%4];\n                key1=keyvalue(a,q,p,b);\n                key2=keyvalue(a,d,r,q);\n                key3=keyvalue(d,c,s,r);\n                key4=keyvalue(b,p,s,c);\n                temp*=(cnt[key1.F]*key1.S);\n                cnt[key1.F]--;\n                temp*=(cnt[key2.F]*key2.S);\n                cnt[key2.F]--;\n                temp*=(cnt[key3.F]*key3.S);\n                cnt[key3.F]--;\n                temp*=(cnt[key4.F]*key4.S);\n                cnt[key4.F]--;\n                ans+=temp;\n                cnt[key1.F]++;\n                cnt[key2.F]++;\n                cnt[key3.F]++;\n                cnt[key4.F]++;\n            }\n            cnt[val[j]]++;\n        }\n    }\n    llout(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=440,D=4;\nint i,j,k,n,m,ch,ff;\nll ans;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid W(ll x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>=10) W(x/10);\n\tputchar(x%10+'0');\n}\nstruct cc {\n\tint a[D];\n\tbool operator < (const cc &n) const {\n\t\tfor (int i=0;i<D;i++) if (a[i]!=n.a[i]) return a[i]<n.a[i];\n\t\treturn 0;\n\t}\n\tvoid rev() {\n\t\tint t=a[0];\n\t\tfor (int i=1;i<D;i++) a[i-1]=a[i];\n\t\ta[D-1]=t;\n\t}\n\tvoid change() {\n\t\tint t=a[1];a[1]=a[3];a[3]=t;\n\t}\n\tll hash() {\n\t\tll ans=0;\n\t\tfor (i=0;i<D;i++) ans=ans*1000+a[i];\n\t\treturn ans;\n\t}\n\tvoid read() {\n\t\tfor (int i=0;i<D;i++) R(a[i]);\n\t\t//change();\n\t}\n} A[N];\nmap<ll,int> Map;\nll work(cc a,cc b) {\n\tint i,j,k;\n\tcc t;\n\tll ans=1;\n\tfor (i=0;i<D;i++) {\n\t\tt.a[0]=a.a[(i+1)%D];t.a[1]=a.a[i];\n\t\tt.a[2]=b.a[i];t.a[3]=b.a[(i+1)%D];\n\t\tans*=Map[t.hash()];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]--;\n\t\t}\n\t}\n\tfor (i=0;i<D;i++) {\n\t\tt.a[0]=a.a[(i+1)%D];t.a[1]=a.a[i];\n\t\tt.a[2]=b.a[i];t.a[3]=b.a[(i+1)%D];\n\t\tfor (k=0;k<D;k++) {\n\t\t\tt.rev();\n\t\t\tMap[t.hash()]++;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tR(n);ans=0;\n\tfor (i=1;i<=n;i++) {\n\t\tA[i].read();\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) {\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]--;\n\t\t}\n\t\tfor (j=i+1;j<=n;j++) {\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]--;\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[i].rev();\n\t\t\t\tans+=work(A[i],A[j]);\n\t\t\t}\n\t\t\tA[j].change();\n\t\t\tfor (k=0;k<D;k++) {\n\t\t\t\tA[j].rev();\n\t\t\t\tMap[A[j].hash()]++;\n\t\t\t}\n\t\t}\n\t\tfor (k=0;k<D;k++) {\n\t\t\tA[i].rev();\n\t\t\tMap[A[i].hash()]++;\n\t\t}\n\t}\n\tW(ans/3);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nint color[408][4];\nll has(int a[])\n{\n\tll res=0;\n\tfor(int i=N-1;i>=0;i--) res=res*1000ll+(ll)a[i];\n\treturn res;\n}\nvector<ll> _rotate(int c[])\n{\n\tvector<ll> res;\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tint a[4];for(int j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nint same(ll x,ll y)\n{\n\tint a[N],c[N];int sum=0;\n\tfor(int i=0;i<N;i++) a[i]=x%1000,x/=1000;\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tfor(int j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(int x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(int i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(int c1[],int c2[])\n{\n\tll p=has(c1);\n\tint a[4];ll ck[4];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(int j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t//\tif(m[ck[i]]<=0) return 0;\n\t\tcnt*=(ll)m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint bel[]={0,3,2,1};\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<N;j++) cin>>color[i][j];\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint a[N],b[N];for(int k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tint c[4];\n\t\t\t\tc[0]=color[j][0],c[1]=color[j][3],c[2]=color[j][2],c[3]=color[j][1];\n\t\t\t\tfor(int l=0;l<N;l++)\n\t\t\t\t\ta[l]=c[(l+k)%N];\n\t\t\t\tans+=operate(a,b);\n\t\t\t}\n\t\t}ins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=1e6+5;\nint main() {\n\tunordered_map<ll,int> M;\n\tvector<vector<ll>> Col(405),Hash(405);\n\tvector<ll> stand(405);\n\tauto cal=[&](int a,int b,int c,int d) -> vector<ll>{\n\t\tvector<ll>res;\n\t\tres.push_back((ll)1e9*a+(ll)1e6*b+(ll)1e3*c+d);\n\t\tres.push_back((ll)1e9*b+(ll)1e6*c+(ll)1e3*d+a);\n\t\tres.push_back((ll)1e9*c+(ll)1e6*d+(ll)1e3*a+b);\n\t\tres.push_back((ll)1e9*d+(ll)1e6*a+(ll)1e3*b+c);\n\t\treturn res;\n\t};\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tvector<ll> tem(4);\n\t\tfor(int j=0;j<4;j++) cin>>tem[j],Col[i].push_back(tem[j]);\n\t\ttem=cal(tem[0],tem[1],tem[2],tem[3]);\n\t\tfor(auto x:tem) Hash[i].push_back(x);\n\t\tsort(tem.begin(),tem.end());\n\t\tM[tem[0]]++;stand[i]=tem[0];\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\tmultiset<ll> used;\n\t\t\t\tll sum=1;int same;\n\t\t\t\tused.insert(stand[i]);\n\t\t\t\tused.insert(stand[j]);\n\t\t\t\tint a1=Col[i][0],b1=Col[i][1],c1=Col[i][2],d1=Col[i][3];\n\t\t\t\tint d2=Hash[j][k]%1000,c2=Hash[j][k]/1000%1000,b2=Hash[j][k]/1000/1000%1000,a2=Hash[j][k]/1000/1000/1000%1000;\n\t\t\t\t\n\n\t\t\t\tvector<ll> V1;\n\n\t\t\t\tV1=cal(b1,a2,d2,c1);\t\t\t\t\t\t\n\t\t\t\tsort(V1.begin(),V1.end());\n\t\t\t\tsame=0;for(int ii=0;ii<4;ii++) if(V1[ii]==V1[0]) same++;\n\t\t\t\tsum=sum*(M[V1[0]]-used.count(V1[0]))*same;\n\t\t\t\tused.insert(V1[0]);\n\n\n\t\t\t\tV1=cal(a1,b2,a2,b1);\n\t\t\t\tsort(V1.begin(),V1.end());\n\t\t\t\tsame=0;for(int ii=0;ii<4;ii++) if(V1[ii]==V1[0]) same++;\n\t\t\t\tsum=sum*(M[V1[0]]-used.count(V1[0]))*same;\n\t\t\t\tused.insert(V1[0]);\n\n\t\t\t\tV1=cal(d1,c2,b2,a1);\n\t\t\t\tsort(V1.begin(),V1.end());\n\t\t\t\tsame=0;for(int ii=0;ii<4;ii++) if(V1[ii]==V1[0]) same++;\n\t\t\t\tsum=sum*(M[V1[0]]-used.count(V1[0]))*same;\n\t\t\t\tused.insert(V1[0]);\n\n\t\t\t\tV1=cal(c1,d2,c2,d1);\n\t\t\t\tsort(V1.begin(),V1.end());\n\t\t\t\tsame=0;for(int ii=0;ii<4;ii++) if(V1[ii]==V1[0]) same++;\n\t\t\t\tsum=sum*(M[V1[0]]-used.count(V1[0]))*same;\n\t\t\t\tused.insert(V1[0]);\n\n\t\t\t\tans+=sum;\n\t\t\t}\n\t\t}\n\t\tM[stand[i]]--;\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\ntile top, bottom;\n\nbool comp_tile(tile &a, tile &b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) return a.color[i] < b.color[i];\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) tmp.color[i] = t.color[i];\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    tmp = comp;\n  }\n}\n\nbool same(const tile &a, const tile &b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= a.color[i] == b.color[i];\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) cin >> t[i].color[j];\n  }\n\n  for (int i = 0; i < N; ++i) regulation(t[i]);\n  sort(t, t+N, comp_tile);\n\n\n  ll ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        for (int k = 0; k < 4; ++k) top.color[k] = t[i].color[k];\n        for (int k = 0; k < 4; ++k) bottom.color[k] = t[j].color[k];\n        for (int k = 0; k < 4; ++k) {\n          tile tmp;\n          for (int l = 0; l < 4; ++l) tmp.color[l] = bottom.color[l];\n          bottom.color[0] = tmp.color[3];\n          bottom.color[1] = tmp.color[0];\n          bottom.color[2] = tmp.color[1];\n          bottom.color[3] = tmp.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) regulation(sides[l]);\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int t = 0;\n            if (lb <= i && i < ub) ++t;\n            if (lb <= j && j < ub) ++t;\n            match_count[m] = ub-lb-t;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) tmp.color[n] = sides[m].color[n];\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) symmetry_count[m]++;\n              tmp = cmp;\n            }\n          }\n\n          ll tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int t = 0;\n            for (int n = 0; n < m; ++n) if (same(sides[n],sides[m])) ++t;\n            if (match_count[m] - t <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= match_count[m] - t;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,a[405][4];\nmap<ll,int> cnt;\n\ninline pair<ll,int> make(int *a){\n\tll ans=1ll<<60;int cnt=0;\n\tfor(int i=0;i<4;i++){\n\t\tll res=0;\n\t\tfor(int j=0;j<4;j++)\n\t\t\tres=res*1000+a[(i+j)%4];\n\t\tif(res<ans) ans=res,cnt++;\n\t\telse if(res==ans) cnt++;\n\t}\n\treturn mp(ans,cnt);\n}\ninline pair<ll,int> make(int a,int b,int c,int d){\n\tstatic int x[10];\n\tx[0]=a;x[1]=b;x[2]=c;x[3]=d;\n\treturn make(x);\n}\n\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<4;j++)\n\t\t\tread(a[i][j]);\n\t\tcnt[make(a[i]).FF]++;\n//\t\tdebug(make(a[i]));\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tcnt[make(a[i]).FF]--;\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tcnt[make(a[j]).FF]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tstatic ll b[10],res;\n\t\t\t\tres=1;\n\t\t\t\tfor(int c=0;c<4;c++){\n\t\t\t\t\tpair<ll,int> tmp=make(a[i][(c+1)&3],a[i][c],a[j][(k-c)&3],a[j][(k-c-1)&3]);\n\t\t\t\t\tb[c]=tmp.FF;res*=tmp.SS;\n\t\t\t\t}\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tres=res*cnt[b[c]],cnt[b[c]]--;\n\t\t\t\tans+=res;\n\t\t\t\tfor(int c=0;c<4;c++)\n\t\t\t\t\tcnt[b[c]]++;\n\t\t\t}\n\t\t\tcnt[make(a[j]).FF]++;\n\t\t}\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<vector<lli> > c;\nmap<vector<lli>,lli> m;\nlli ans = 0;\n\nvoid rotate(vector<lli>& v){\n    for(lli i = 0;i < 3;i++) swap(v[i],v[i+1]);\n    //for(lli k = 0;k < v.size();k++) cout << v[k] << \" \";cout << endl;\n}\nvoid recover(vector<lli>& v){\n    for(lli i = 0;i < 4;i++){\n        rotate(v);\n        m[v]++;\n    }\n}\nvoid dec(vector<lli>& v){\n    for(lli i = 0;i < 4;i++){\n        rotate(v);\n        m[v]--;\n    }\n}\nvoid inc(vector<lli>& v){\n    for(lli i = 0;i < 4;i++){\n        rotate(v);\n        m[v]++;\n    }\n}\nlli select(vector<lli>& v){\n    lli ret = m[v];\n    dec(v);\n    return ret > 0 ? ret : 0;\n}\n\nint main(int argc, char const *argv[]) {\n    cin >> n;\n    c = vector<vector<lli> > (n,vector<lli> (4));\n    for(lli i = 0;i < n;i++){\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        for(lli j = 0;j < 4;j++){\n            rotate(c[i]);\n            m[c[i]]++;\n        }\n    }\n    for(lli i = 0;i < n;i++){\n        dec(c[i]);\n        for(lli j = i + 1;j < n;j++){\n            dec(c[j]);\n            for(lli k = 0;k < 4;k++){\n                rotate(c[j]);\n                lli adder = 1;\n                vector<lli> v1{c[i][1],c[i][0],c[j][1],c[j][0]};\n                vector<lli> v2{c[i][0],c[i][3],c[j][2],c[j][1]};\n                vector<lli> v3{c[i][3],c[i][2],c[j][3],c[j][2]};\n                vector<lli> v4{c[i][2],c[i][1],c[j][0],c[j][3]};\n                adder *= select(v1);\n                adder *= select(v2);\n                adder *= select(v3);\n                adder *= select(v4);\n                ans += adder;\n                recover(v1);\n                recover(v2);\n                recover(v3);\n                recover(v4);\n            }\n            inc(c[j]);\n        }\n        inc(c[i]);\n    }\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// arc062_e\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n#define print_line(vec, n) {for(int i=0;i<(n-1);i++) cout << (vec)[i] << \" \"; cout << (vec)[(n)-1] << endl;}\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../arg.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    int N;\n    cin >> N;\n\n    vector<vector<int>> colors;\n    colors.assign(N, vector<int>(4,0));\n\n    using Color = pair<P, P>;\n    map<Color, int> mp;\n\n    REP(i, N){\n\n        vector<int>& C = colors[i];\n        REP(j, 4) cin >> C[j];\n\n        // 2週にしとく\n        REP(j, 4) C.emplace_back(C[j]);\n\n        REP(j, 4) {\n            Color c{{C[j], C[j+1]}, {C[j+2], C[j+3]}};\n            mp[c]++;\n        }\n\n    }\n\n    /*\n     *   □\n     * □ □ □ □\n     *   □\n     *   真ん中が一番小さい数字かつ回転なし\n     *   底面とその方向を決めると、全色確定\n     */\n\n    auto rotate = [](Color& c){ c = {{c.second.second, c.first.first}, {c.first.second, c.second.first}};};\n\n    ll ans = 0;\n    REP(i, N) {\n\n        vector<int> front = colors[i];\n        int a = front[0];\n        int b = front[1];\n        int c = front[2];\n        int d = front[3];\n\n        Color c0{{a, b}, {c, d}};\n        REP(k, 4) { mp[c0]--; rotate(c0);}\n\n        REPN(j, i+1, N) {\n            vector<int> back = colors[j];\n\n            Color c5{{back[0], back[1]}, {back[2], back[3]}};\n            REP(k, 4) { mp[c5]--; rotate(c5);}\n\n            REP(k, 4){\n                int x = back[k+0];\n                int y = back[k+1];\n                int z = back[k+2];\n                int w = back[k+3];\n\n                Color c1{{d, c}, {w, z}};\n                Color c2{{c, b}, {x, w}};\n                Color c3{{b, a}, {y, x}};\n                Color c4{{a, d}, {z, y}};\n\n                if (mp[c1] == 0 || mp[c2] == 0 || mp[c3] == 0 || mp[c4] == 0) continue;\n\n                vector<Color> cs{c1, c2, c3, c4};\n\n                ll tmp = 1;\n\n                REP(m, 4){\n                    tmp *= mp[cs[m]];\n                    REP(n, 4) { mp[cs[m]]--; rotate(cs[m]);}\n                }\n\n                REP(m, 4){\n                    REP(n, 4) { mp[cs[m]]++; rotate(cs[m]);}\n                }\n\n                ans += tmp;\n            }\n\n            REP(k, 4) { mp[c5]++; rotate(c5);}\n        }\n    }\n\n    print(ans);\n//    print(cnt);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\nl_l cal(vector<ll>v){\n    l_l res{inf,1};\n    if(v[0]==v[2]&&v[1]==v[3]){\n        if(v[0]==v[1])res.second=4;\n        else res.second=2;\n    }\n    rep(i,0,2)v.pb(v[i]);\n    rep(i,0,3){\n        ll x=0;\n        rep(j,0,3){\n            x+=(ll)pow(1000,3-j)*v[i+j];\n        }\n        Min(res.first,x);\n    }\n    return res;\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    ll res=1;\n    rep(i,0,k-1){\n        res*=(n-i);\n    }\n    return res;\n}\n#define N 405\nll n;\nl_l c[N];\nll anscal(vector<l_l>goal,ll x1,ll x2){\n    ll res=1;\n    rep(i,0,3)res*=goal[i].second;\n    ll same[4];\n    rep(i,0,3){\n        same[i]=upper_bound(c,c+n,goal[i])-lower_bound(c,c+n,goal[i]);\n        if(c[x1]==goal[i])same[i]--;\n        if(c[x2]==goal[i])same[i]--;\n    }\n    ll pos=0;\n    while(pos<=3){\n        ll c=1;\n        while(pos<=2&&goal[pos]==goal[pos+1]){\n            c++;pos++;\n        }\n        res*=comb(same[pos],c);\n        pos++;\n    }\n    return res;\n}\n\nint main(){\n    cin>>n;\n    rep(i,0,n-1){\n        vector<ll>a;\n        rep(j,0,3){ll k;cin>>k;a.pb(k);}\n        c[i]=cal(a);\n    }\n    sort(c,c+n);\n    ll prac[n][4];\n    rep(i,0,n-1){\n        ll res=c[i].first;\n        for(ll j=3;j>=0;j--){\n            prac[i][j]=res%1000;\n            res/=1000;\n        }\n    }\n   /* rep(i,0,n-1){\n        cout<<c[i].first<<\":\";\n        rep(j,0,3){\n            cout<<prac[i][j]<<\" \";\n        }cout<<endl;\n    }*/\n    ll ans=0;\n    rep(i,0,n-1){\n        rep(j,0,n-1){\n            if(j==i)continue;\n            rep(k,0,3){\n                vector<l_l>goal;\n                rep(l,0,3){\n                    vector<ll>res;\n                    res.pb(prac[i][l]);\n                    res.pb(prac[j][(7-l+k)%4]);\n                    res.pb(prac[j][(6-l+k)%4]);\n                    res.pb(prac[i][(l+1)%4]);\n                    goal.pb(cal(res));\n                }\n                sort(goal.begin(),goal.end());\n                ans+=anscal(goal,i,j);\n            }\n            //cout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n        }\n    }\n    cout<<ans/6<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nvector<ll> regularize(vector<ll> v) {\n    vector<vector<ll>> candidates;\n    for (ll i = 0; i < 4; i++) {\n        candidates.push_back(v);\n        rotate(v.begin(), v.begin() + 1, v.end());\n    }\n    sort(candidates.begin(), candidates.end());\n    return candidates.front();\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    vector<vector<ll>> C(N, vector<ll>(4));\n\n    map<vector<ll>, ll> mp;\n    for (ll i = 0; i < N; i++) {\n        for (ll j = 0; j < 4; j++) {\n            cin >> C[i][j];\n        }\n\n        C[i] = regularize(C[i]);\n        mp[C[i]]++;\n    }\n\n    ll ans = 0;\n    for (ll i = 0; i < N; i++) {\n        for (ll j = i + 1; j < N; j++) {\n            for (ll k = 0; k < 4; k++) {\n                //上面はC[i]\n                //下面はC[j]を裏返してkだけ回したもの\n                vector<ll> u = C[i];\n                vector<ll> b(4);\n                //裏返す\n                b[0] = C[j][1];\n                b[1] = C[j][0];\n                b[2] = C[j][3];\n                b[3] = C[j][2];\n\n                //回転\n                rotate(b.begin(), b.begin() + k, b.end());\n\n                ll tmp = 1;\n\n                vector<vector<ll>> used;\n                used.push_back(C[i]);\n                used.push_back(C[j]);\n\n                for (ll l = 0; l < 4; l++) {\n                    //lとl + 1で作られる面について考える\n                    ll m = (l + 1) % 4;\n                    vector<ll> key(4);\n                    key[0] = u[l];\n                    key[1] = b[l];\n                    key[2] = b[m];\n                    key[3] = u[m];\n                    key = regularize(key);\n\n                    ll num = mp[key];\n                    //既に使ったものとの重複を除く\n                    for (auto u : used) {\n                        if (key == u) {\n                            num--;\n                        }\n                    }\n\n                    if (key[0] == key[1] && key[1] == key[2] && key[2] == key[3]) {\n                        //全て同じならどの回転でも良い\n                        num *= 4;\n                    } else if (key[0] == key[2] && key[1] == key[3]) {\n                        //対角線が同じなら180度回転だけ良い\n                        num *= 2;\n                    }\n                    \n                    tmp *= num;\n                    used.push_back(key);\n                }\n\n                ans += tmp;\n            }\n        }\n    }\n\n    cout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#define int long long\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=100050;\n//ここまでテンプレ\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\nll fact_mod(ll n, ll mod) {\n    ll f = 1; repq(i,2,n) f = f * (i % MOD) % MOD;\n    return f;\n}\n// 繰り返し二乗法 (再帰バージョン)\nll mod_pow(ll x, ll n, ll mod) {\n    if(n == 0) return 1;\n    ll res = mod_pow((x * x) % mod, n / 2 , mod);\n    if(n & 1) res = (res * x) % mod;\n    return res;\n}\n// 組み合わせ nCr を求める (modあり)\nll combination_mod(ll n, ll r, ll mod) {\n    if(r > n-r) r = n-r;\n    if(r == 0) return 1;\n    ll a = 1;\n    rep(i, 0, r) a = a * ((n-i) % mod) % mod;\n    ll b = mod_pow(fact_mod(r, mod), mod-2, mod);\n    return (a % mod) * (b % mod) % mod;\n}\n//4つの色を辞書順最小の並びで返す\nvint COLOR(int a,int b,int c,int d){\n\tvint A={a,b,c,d},B={b,c,d,a},C={c,d,a,b},D={d,a,b,c};\n\tvector<vint> vec={A,B,C,D};\n\tsort(vec.begin(),vec.end());\n\treturn vec[0];\n}\nsigned main(){\n\tint N;\n\tcin>>N;\n\tmap<vint,int> pam;\n\tvector<vint> panel;\n\t//それぞれのパネルに含まれる色を、昇順にソートして入れていく\n\tfor(int i=0;i<N;i++){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\t//4つの角の順番を変えないように、辞書順最小の並びに揃える\n\t\tvint v=COLOR(a,b,c,d);\n\t\tpam[v]++;\n\t\tpanel.pb(v);\n\t}\n\tll ans=0;\n\t//立方体の底に使うパネルiと天井に使うパネルjを全探索する\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\t//天井のパネルの向きを全探索する\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tvint cei,flo;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tflo.pb(panel[i][l]);\n\t\t\t\t\tcei.pb(panel[j][(k+l)%4]);\n\t\t\t\t}\n\t\t\t\t//側面の4つのパネルになりうるパネルがあるか？\n\t\t\t\tvint A=COLOR(cei[0],flo[0],flo[3],cei[1]);\n\t\t\t\tvint B=COLOR(cei[3],flo[1],flo[0],cei[0]);\n\t\t\t\tvint C=COLOR(cei[2],flo[2],flo[1],cei[3]);\n\t\t\t\tvint D=COLOR(cei[1],flo[3],flo[2],cei[2]);\n\t\t\t\t//pamから底と天井に使ったパネルを引く\n\t\t\t\tpam[panel[i]]--;\n\t\t\t\tpam[panel[j]]--;\n\t\t\t\t//立方体が何通りできるか？\n\t\t\t\t//側面に使うパネル\n\t\t\t\tmap<vint,int> use;\n\t\t\t\tuse[A]++,use[B]++,use[C]++,use[D]++;\n\t\t\t\tif(pam.find(A)==pam.end() || pam.find(B)==pam.end() || pam.find(C)==pam.end() || pam.find(D)==pam.end());\n\t\t\t\telse if(pam[A]<use[A] || pam[B]<use[B] || pam[C]<use[C] || pam[D]<use[D]);\n\t\t\t\telse{\n\t\t\t\t\tll temp=1;\n\t\t\t\t\tfor(pair<vint,int> P:use){\n\t\t\t\t\t\ttemp*=combination_mod(pam[P.first],P.second,MOD);\n\t\t\t\t\t\tif(P.first[1]==P.first[0] && P.first[2]==P.first[0] && P.first[3]==P.first[0])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=4;\n\t\t\t\t\t\telse if(P.first[0]==P.first[2] && P.first[1]==P.first[3])\n\t\t\t\t\t\t\tfor(int l=0;l<P.second;l++)\n\t\t\t\t\t\t\t\ttemp*=2;\n\t\t\t\t\t\tfor(int l=1;l<=P.second;l++)\n\t\t\t\t\t\t\ttemp*=l;\n\t\t\t\t\t}\n\t\t\t\t\tans+=temp;\n\t\t\t\t}\n\t\t\t\t//pamに底と天井に使ったパネルを足す\n\t\t\t\tpam[panel[i]]++;\n\t\t\t\tpam[panel[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\n\nint main() {\n#define int long long\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> inputs;\n\tREP(i, n) {\n\t\tvector<int> A;\n\t\tREP(q, 4) {\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tA.push_back(b);\n\t\t}\n\t\tvector<vector<int>> B;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tB.push_back(A);\n\t\t\tfor (int q = 1; q < 4; ++q) {\n\t\t\t\tswap(A[q - 1], A[q]);\n\t\t\t}\n\t\t}\n\t\tsort(B.begin(), B.end());\n\t\tinputs.push_back(B[0]);\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\t//Bottom\n\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\t//Top\n\t\t\tswap(inputs[q][0], inputs[q][1]);\n\t\t\tswap(inputs[q][2], inputs[q][3]);\n\t\t\tREP(j, 4) {\n\t\t\t\tfor (int t = 1; t < 4; ++t) {\n\t\t\t\t\tswap(inputs[q][t-1], inputs[q][t]);\n\t\t\t\t}\n\t\t\t\t//direction,now we're ready to solve\n\t\t\t\tlong long dp[16] = {};\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int t = 0; t < n; ++t) {\n\t\t\t\t\tif (i == t || q == t) continue;\n\t\t\t\t\tlong long cnt[4] = {};\n\t\t\t\t\tREP(a, 4) {\n\t\t\t\t\t\tfor (int p = 1; p < 4; ++p) {\n\t\t\t\t\t\t\tswap(inputs[t][p - 1], inputs[t][p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tREP(b, 4) {\n\t\t\t\t\t\t\tif (inputs[t][0] != inputs[q][b]) continue;\n\t\t\t\t\t\t\tif (inputs[t][1] != inputs[q][(b + 1) % 4]) continue;\n\t\t\t\t\t\t\tif (inputs[t][3] != inputs[i][(b)%4]) continue;\n\t\t\t\t\t\t\tif (inputs[t][2] != inputs[i][(b + 1) % 4])continue;\n\t\t\t\t\t\t\tcnt[b]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\t\t\t\tfor (int q = 0; q < 4; ++q) {\n\t\t\t\t\t\t\tif (((1 << q) & i) != 0) continue;\n\t\t\t\t\t\t\tdp[i + (1 << q)] += dp[i] * cnt[q];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += dp[15];\n\t\t\t}\n\t\t\tswap(inputs[q][0], inputs[q][1]);\n\t\t\tswap(inputs[q][2], inputs[q][3]);\n\t\t}\n\t}\n\tcout << ans/3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n\nint a[4][N][4];\nint b[10];\nll dp[N][16];\nint id[4][4] = {{1,0,4,5},{2,1,5,6},{3,2,6,7},{0,3,7,4}};\nvector<int>v;\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&a[0][i][j]);\n            FOR(j,1,3)\n            {\n                FOR(k,0,3)\n                {\n                    a[j][i][k] = a[0][i][(k-j+4)%4];\n                }\n            }\n        }\n        ll ans = 0;\n        FOR(i,1,n)\n        {\n            FOR(ii,i+1,n)\n            {\n                v.clear();\n                FOR(s,1,n)if(s!=i&&s!=ii)v.PB(s);\n                FOR(k,0,3)b[k] = a[0][i][k];\n                FOR(jj,0,3)\n                {\n                    b[4] = a[jj][ii][1];\n                    b[5] = a[jj][ii][0];\n                    b[6] = a[jj][ii][3];\n                    b[7] = a[jj][ii][2];\n                    FOR(s,0,15)dp[0][s] = 0;\n                    dp[0][0] = 1;\n                    for(int s = 1;s<=v.size();s++)\n                    {\n                        FOR(f,0,15)\n                        {\n                            dp[s][f] = dp[s-1][f];\n                            FOR(p,0,3)\n                            {\n                                if(f&(1<<p))\n                                {\n                                    FOR(r,0,3)\n                                    {\n                                        int flag = 1;\n                                        FOR(q,0,3)\n                                        {\n                                            if(a[r][v[s-1]][q]!=b[id[p][q]])\n                                            {\n                                                flag = 0;\n                                                break;\n                                            }\n                                        }\n\n                                        if(flag)dp[s][f]+=dp[s-1][f-(1<<p)];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    ans+=dp[v.size()][15];\n                }\n            }\n        }\n        printf(\"%I64d\\n\",ans/3);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 405\n\nusing namespace std;\n\nstruct Node{\n\tint a[4];\n\t\n\tinline int & operator [] (int i){\n\t\treturn a[i];\n\t}\n\t\n\tfriend inline bool operator < (Node x, Node y){\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tif(x[i] ^ y[i]) return x[i] < y[i];\n\t\t}\n\t\treturn false;\n\t}\n}a[maxn];\n\nmap<Node, int> mp;\n\ninline void add(Node &x, int y){\n\tNode a;\n\tfor(int i = 0;i < 4;i++){\n\t\tfor(int j = 0;j < 4;j++){\n\t\t\ta[j] = x[(i + j) % 4];\n\t\t} \n\t\tmp[a] += y; \n\t}\n}\n\nint n;\nlong long ans;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(register int i = 1;i <= n;i++){\n\t\tfor(register int j = 0;j < 4;j++){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t\tadd(a[i], 1);\n\t}\n\tfor(register int i = 1;i <= n;i++){\n\t\tadd(a[i], -1), reverse(a[i].a, a[i].a + 4);\n\t\tfor(register int j = 1;j < i;j++){\n\t\t\tadd(a[j], -1);\n\t\t\t//printf(\"%d %d %d %d--||\\n\", a[i][0], a[i][1], a[i][2], a[i][3]);\n\t\t\t//printf(\"%d %d %d %d--||\\n\", a[j][0], a[j][1], a[j][2], a[j][3]);\n\t\t\tfor(register int k = 0;k < 4;k++){\n\t\t\t\tlong long sum = 1;\n\t\t\t\tNode b;\n\t\t\t\tfor(register int l = 0;l < 4;l++){\n\t\t\t\t\tb = (Node){a[i][l], a[i][(l + 1) % 4], a[j][(l + 1 + k) % 4], a[j][(l + k) % 4]};\n\t\t\t\t\t//printf(\"%d %d %d %d %d--\\n\", a[i][l], a[i][(l + 1) % 4], a[j][(l + 1 + k) % 4], a[j][(l + k) % 4], mp[b]);\n\t\t\t\t\tsum *= mp[b];\n\t\t\t\t\tadd(b, -1);\n\t\t\t\t}\n\t\t\t\tans += sum;\n\t\t\t\tfor(register int l = 0;l < 4;l++){\n\t\t\t\t\tb = (Node){a[i][l], a[i][(l + 1) % 4], a[j][(l + 1 + k) % 4], a[j][(l + k) % 4]};\n\t\t\t\t\tadd(b, 1);\n\t\t\t\t}\n\t\t\t} \n\t\t\tadd(a[j], 1);\n\t\t}\n\t\treverse(a[i].a, a[i].a + 4), add(a[i], 1);\n\t}\n\tprintf(\"%lld\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 404;\nint c[maxn][4];\nvoid rotate(int id){\n\tint p0 = c[id][0];\n\tfor(int j = 0; j < 3; j++) c[id][j] = c[id][j + 1];\n\tc[id][3] = p0;\n}\nlong long calc(int id){\n\tlong long val = 0;\n\tfor(int k = 0; k < 4; k++) val = val * 1000 + c[id][k];\n\treturn val;\n}\nlong long has[maxn][4];\nvoid ins(int id){\n\tfor(int rot = 0; rot < 4; rot++){\n\t\thas[id][rot] = calc(id);\n\t\trotate(id);\n\t}\n\tsort(has[id], has[id] + 4);\n}\nint get_msk(int id, long long vals[4]){\n\tint i = 0, j = 0, msk = 0;\n\twhile(i < 4 && j < 4){\n\t\tif(has[id][i] == vals[j]) msk |= 1<<j, j++;\n\t\telse if(has[id][i] < vals[j]) i++;\n\t\telse j++;\n\t}\n\treturn msk;\n}\nunordered_map<vector<long long>, int, function<size_t(const vector<long long> &v)> > magic(1, [](const vector<long long> &v){\n\tsize_t res = 0;\n\tfor(auto e : v) res ^= ((e >> 31) ^ e) & ((1u<<31) - 1);\n\treturn res;\n\t});\nvoid add(int i, int s){\n\tunordered_set<vector<long long>, function<size_t(const vector<long long> &v)> > can(1, [](const vector<long long> &v){\n\t\tsize_t res = 0;\n\t\tfor(auto e : v) res ^= ((e >> 31) ^ e) & ((1u<<31) - 1);\n\t\treturn res;\n\t});\n\tfor(int j = 1; j < 1<<4; j++){\n\t\tvector<long long> now;\n\t\tfor(int k = 0; k < 4; k++) if((j>>k)&1){\n\t\t\tif(now.empty() || now.back() != has[i][k]) now.push_back(has[i][k]);\n\t\t}\n\t\tcan.insert(now);\n\t}\n\tfor(auto e : can) magic[e] += s;\n}\nlong long need[4];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < 4; j++) cin >> c[i][j];\n\tfor(int i = 0; i < n; i++){\n\t\tins(i);\n\t\tadd(i, 1);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tadd(i, -1);\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tadd(j, -1);\n\t\t\tfor(int rotj = 0; rotj < 4; rotj++){\n\t\t\t\tint prot[4] = {};\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nik = (k + 1) % 4;\n\t\t\t\t\tint njk0 = (5 - k) % 4;\n\t\t\t\t\tint njk1 = (4 - k) % 4; \n\t\t\t\t\tneed[k] = 0;\n\t\t\t\t\tfor(int v : {c[i][nik], c[i][k], c[j][njk0], c[j][njk1]}){\n\t\t\t\t\t\tneed[k] = need[k] * 1000 + v;\n\t\t\t\t\t}\n\t\t\t\t\tc[n][0] = c[i][nik];\n\t\t\t\t\tc[n][1] = c[i][k];\n\t\t\t\t\tc[n][2] = c[j][njk0];\n\t\t\t\t\tc[n][3] = c[j][njk1];\n\t\t\t\t\tfor(int tk = 0; tk < 4; tk++){\n\t\t\t\t\t\tif(calc(n) == need[k]) prot[k]++;\n\t\t\t\t\t\trotate(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(need, need + 4);\n\t\t\t\tvector<int> cnt(1<<4);\n\t\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\t\tvector<long long> now;\n\t\t\t\t\tfor(int p = 0; p < 4; p++) if((k>>p)&1){\n\t\t\t\t\t\tif(now.empty() || now.back() != need[p]) now.push_back(need[p]);\n\t\t\t\t\t}\n\t\t\t\t\tcnt[k] = magic[now];\n\t\t\t\t}\n\t\t\t\tfor(int k = 15; k > 0; k--){\n\t\t\t\t\tfor(int sk = k; sk; sk = (sk - 1) & k){\n\t\t\t\t\t\tif(sk != k){\n\t\t\t\t\t\t\tcnt[sk] -= cnt[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<long long> f(1<<4, 0), nf(1<<4, 0);\n\t\t\t\tf[0] = 1;\n\t\t\t\tfor(int k = 1; k < 1<<4; k++){\n\t\t\t\t\tif(cnt[k]){\n\t\t\t\t\t\tnf = f;\n\t\t\t\t\t\tfor(int sk = k; sk; sk = k & (sk - 1)){\n\t\t\t\t\t\t\tassert((k&sk) == sk);\n\t\t\t\t\t\t\tlong long ways = 1;\n\t\t\t\t\t\t\tint bc = __builtin_popcount(sk);\n\t\t\t\t\t\t\tfor(int z = 0; z < bc; z++) ways *= (cnt[k] - z);\n\t\t\t\t\t\t\tif(ways > 0){\n\t\t\t\t\t\t\t\tfor(int msk = 0; msk < 1<<4; msk++){\n\t\t\t\t\t\t\t\t\tif((msk&sk) == 0){\n\t\t\t\t\t\t\t\t\t\tnf[msk|sk] += f[msk] * ways;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = nf;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\tfor(int k = 0; k < 4; k++) f[15] *= prot[k];\n\t\t\t\tans += f[15];\n\t\t\t\trotate(j);\n\t\t\t}\n\t\t\tadd(j, 1);\n\t\t}\n\t\tadd(i, 1);\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nstruct Data {\n    int idx, cnt, kind;\n    Data(){\n\tidx = -1;\n\tcnt = 0;\n\tkind = 0;\n    }\n    bool operator<(const Data &o) const {\n\treturn idx < o.idx;\n    }\n};\n\nint N;\nint C[411][4];\n\nint Z[4][4];\n\nint match(int a[4], int b[4]) {\n    int r = 0;\n    REP (s, 4) {\n\tbool ok = true;\n\tREP (i, 4) if (a[i] != b[(i+s)%4]) { ok = false; break; }\n\tif (ok) r++;\n    }\n    return r;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) REP (t, 4) scanf(\"%d\", C[i]+t);\n\n    LL ans = 0;\n    REP (i, N) {\n\tREP (c, 4) {\n\t    Z[c][2] = C[i][(c+1)%4];\n\t    Z[c][3] = C[i][(c)%4];\n\t}\n\n\tfor (int j=i+1; j<N; j++) REP (b, 4) {\n\t    REP (c, 4) {\n\t\tZ[c][0] = C[j][(b-c+4)%4];\n\t\tZ[c][1] = C[j][(b-c+3)%4];\n\t    }\n\n\t    vector<Data> v(4, Data());\n\t    for (int k=i+1; k<N; k++) if (j != k) {\n\t\tREP (c, 4) {\n\t\t    int t = match(C[k], Z[c]);\n\t\t    if (t) {\n\t\t\tv[c].idx = k;\n\t\t\tv[c].cnt++;\n\t\t\tv[c].kind = t;\n\t\t    }\n\t\t}\n\t    }\n\n\t    sort(v.begin(), v.end());\n\t    LL tmp = 1;\n\t    for (int l=0; l<4; ) {\n\t\tint r = l;\n\t\tLL p = v[l].cnt;\n\t\twhile (r < 4 && v[l].idx == v[r].idx) {\n\t\t    assert(v[l].cnt == v[r].cnt);\n\t\t    assert(v[l].kind == v[r].kind);\n\t\t    tmp *= p*v[l].kind;\n\t\t    p--;\n\t\t    r++;\n\t\t}\n\t\tl = r;\n\t    }\n\n\t    ans += tmp;\n\t}\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nll com(ll a, ll b) {\n\tif (a < b) { return 0; }\n\n\tll ret = 1;\n\tfor (ll i = a; i >= a - b + 1; i--)ret *= i;\n\t\n\treturn ret;\n}\n\nstring rotate(string s, ll j) {\n\tstring ret = \"aaaa\";\n\n\trep(i, 4) { ret[i] = s[(i + j) % 4]; }\n\t\n\treturn ret;\n}\n\nstring normalize(string s) {\n\tstring ret = s;\n\n\trep(i, 4) { ret = min(ret, rotate(s, i)); }\n\n\treturn ret;\n}\n\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\tmap<string, ll> mp;\n\t\n\trepn(i, N) {\n\t\tstring s = \"aaaa\";\n\t\trep(j, 4) cin >> s[j];\n\n\t\ts = normalize(s);\n\t\t//cout << s << endl;\n\t\tmp[s]++;\n\t}\n\n\tll ans = 0;\n\n\tfor (auto p : mp)for (auto q : mp) {\n\t\tstring s[6];\n\n\t\ts[0] = p.first;\n\n\t\t\n\n\t\trep(j, 4) {\n\t\t\ts[1] = rotate(q.first, j);\n\n\t\t\trep(k, 4) {\n\t\t\t\ts[k + 2] = \"aaaa\";\n\t\t\t\ts[k + 2][0] = s[0][k];\n\t\t\t\ts[k + 2][1] = s[1][3-k];\n\t\t\t\ts[k + 2][2] = s[1][(6-k) % 4];\n\t\t\t\ts[k + 2][3] = s[0][(k + 1) % 4];\n\t\t\t\t\n\t\t\t}\n\t\t\t//rep(k, 6) cout << s[k] << \" \";\n\t\t\t//cout << endl;\n\t\t\t\n\t\t\trep(k, 6) { s[k] = normalize(s[k]); }\n\n\t\t\t//rep(k, 6) cout << s[k] << \" \";\n\t\t\t//cout << endl;\n\n\t\t\tmap<string, ll> men;\n\t\t\trep(k, 6) { men[s[k]]++; }\n\n\t\t\tll count = 1;\n\t\t\tfor (auto r : men) {\n\t\t\t\tstring u = r.first;\n\t\t\t\tif (!mp.count(u)) { count = 0; break; }\n\t\t\t\tcount *= com(mp[u], men[u]);\n\t\t\t\t//cout << u <<\" \"<< mp[u] <<\" \"<< men[u] << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\n\t\t\trep(k, 4) {\n\t\t\t\tll c = 0;\n\t\t\t\trep(l, 4) { if (s[k+2] == rotate(s[k+2], l)) { c++; } }\n\t\t\t\tcount *= c;\n\t\t\t}\n\n\t\t\tans += count;\n\t\t}\n\t}\n\n\tcout << ans/6 << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\n#define LL long long\n#define PAIR pair<LL,int>\nusing namespace std;\nconst int mo=1e6+7;\nvector<PAIR> G[mo];\nint n,c[N][4],f[4];\nPAIR z[4]; LL now,ans;\nLL H(int g[4],int x)\n{\n\tint i; LL S=0;\n\tfor(i=0;i<4;i++)\n\t\tS=S*1000+g[(i+x)&3];\n\treturn S;\n}\nLL Z(int g[4])\n{\n\tint i,j,h[4]; LL S=0;\n\tfor(i=0;i<4;i++) h[i]=g[i];\n\tfor(i=1;i<4;i++){\n\t\tfor(j=0;j<4;j++)\n\t\t\tif(g[(j+i)&3]!=h[j]) break;\n\t\tif(j<4&&g[(j+i)&3]<h[j])\n\t\t\tfor(j=0;j<4;j++) h[j]=g[(j+i)&3];\n\t  }\n\tfor(i=0;i<4;i++)\n\t\tS=S*1000+h[i];\n\treturn S;\n}\nvoid ins(LL S,int d)\n{\n\tint i,u=S%mo;\n\tfor(i=0;i<G[u].size();i++)\n\t\tif(G[u][i].first==S){ G[u][i].second+=d; return ;}\n\tG[u].push_back(PAIR(S,d));\n}\nint cnt(LL S)\n{\n\tint i,u=S%mo;\n\tfor(i=0;i<G[u].size();i++)\n\t\tif(G[u][i].first==S) return G[u][i].second;\n\treturn 0;\n}\nint cir(LL S)\n{\n\tint i,j,g[4],cnt=0;\n\tg[0]=S/1000000000;\n\tg[1]=(S/1000000)%1000;\n\tg[2]=(S/1000)%1000;\n\tg[3]=S%1000;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=0;j<4;j++)\n\t\t\tif(g[j]!=g[(j+i)&3]) break;\n\t\tif(j>=4) cnt++;\n\t  }\n\treturn cnt;\n}\nint main()\n{\n\tint i,j,k,l,p,q; LL v;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<4;j++)\n\t\t\tscanf(\"%d \",&c[i][j]);\n\t\tfor(j=0;j<4;j++)\n\t\t\tins(H(c[i],j),1);\n\t  }\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<4;j++) ins(H(c[i],j),-1);\n\t\tfor(j=0;j<=0;j++)\n\t\t\tfor(k=i+1;k<=n;k++){\n\t\t\t\tfor(l=0;l<4;l++) ins(H(c[k],l),-1);\n\t\t\t\tfor(l=0;l<4;l++){\n\t\t\t\t\tf[0]=c[k][(l+1)&3],f[1]=c[k][l],f[2]=c[i][(j+1)&3],f[3]=c[i][j],v=Z(f),z[0]=PAIR(v,cnt(v));\n\t\t\t\t\tf[0]=c[i][(j+3)&3],f[1]=c[i][(j+2)&3],f[2]=c[k][(l+3)&3],f[3]=c[k][(l+2)&3],v=Z(f),z[1]=PAIR(v,cnt(v));\n\t\t\t\t\tf[0]=c[k][(l+1)&3],f[1]=c[i][j],f[2]=c[i][(j+3)&3],f[3]=c[k][(l+2)&3],v=Z(f),z[2]=PAIR(v,cnt(v));\n\t\t\t\t\tf[0]=c[i][(j+1)&3],f[1]=c[k][l],f[2]=c[k][(l+3)&3],f[3]=c[i][(j+2)&3],v=Z(f),z[3]=PAIR(v,cnt(v));\n\t\t\t\t\tsort(z,z+4),q=0,now=1;\n\t\t\t\t\tfor(p=0;p<4;p++){\n\t\t\t\t\t\tif(p&&z[p].first==z[p-1].first) q+=cir(z[p].first); else q=0;\n\t\t\t\t\t\tnow*=(z[p].second-q);\n\t\t\t\t\t  }\n\t\t\t\t\tans+=now;\n\t\t\t\t  }\n\t\t\t\tfor(l=0;l<4;l++) ins(H(c[k],l),1);\n\t\t\t  }\n\t\tfor(j=0;j<4;j++) ins(H(c[i],j),1);\n\t  }\n\tcout<<ans/3;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans,c[410][4],h[410],v[4],tmp[4];\nunordered_map<ll,int>mp;\nvoid upd(ll x,int d){\n\tfor(int i=0;i<4;i++,x=((x&1023ll)<<30ll)|(x>>10ll))\n\t\tmp[x]+=d;\n\treturn;\n}\nll Hash(ll *a){\n\tll ret=0;\n\tfor(int i=0;i<4;i++)\n\t\tret|=(a[i]<<(i*10ll));\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",c[i],c[i]+1,c[i]+2,c[i]+3);\n\t\th[i]=Hash(c[i]);\n\t\tupd(h[i],1);\n\t}\n\tfor(int i=1;i<=n-5;i++){\n\t\tupd(h[i],-1);\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tupd(h[j],-1);\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tll res=1;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tll tmp[]={c[i][(l+1)&3],c[i][l],c[j][(3-l+k)&3],c[j][(6-l+k)&3]};\n\t\t\t\t\tv[l]=Hash(tmp);\n\t\t\t\t\tif(!mp.count(v[l]))\n\t\t\t\t\t\tgoto to;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tres*=mp[v[l]];\n\t\t\t\t\tupd(v[l],-1);\n\t\t\t\t}\n\t\t\t\tans+=res;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tupd(v[l],1);\n\t\t\t\tto: ;\n\t\t\t}\n\t\t\tupd(h[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct Side\n{\n\tint a, b, c, d;\n\tSide(){}\n\tSide(int _a, int _b, int _c, int _d)\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t\tc = _c;\n\t\td = _d;\n\t}\n\tpair<pair<int, int>, pair<int, int> > get() const\n\t{\n\t\treturn make_pair(make_pair(a, b), make_pair(c, d));\n\t}\n};\nSide shift(Side s)\n{\n\treturn Side(s.b, s.c, s.d, s.a);\n}\nSide makeMin(Side s)\n{\n\tSide res = s;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\ts = shift(s);\n\t\tif (s.get() < res.get())\n                {\n                      res = s;\n                }\n\t}\n\treturn res;\n}\nbool operator<(const Side x, const Side y)\n{\n\treturn x.get() < y.get();\n}\nbool operator==(const Side x, const Side y)\n{\n\treturn x.get() == y.get();\n}\nconst int MAXN = 407;\nSide s[MAXN];\nmap<Side, int> have;\nint cnt(Side s)\n{\n\tSide ss = s;\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (ss == s) res++;\n\t\tss = shift(ss);\n\t}\n\treturn res;\n}\nSide mirror(Side s)\n{\n\treturn Side(s.d, s.c, s.b, s.a);\n}\nvector<Side> dels;\nint go(Side s)\n{\n\ts = mirror(s);\n\ts = makeMin(s);\n\tint res = have[s];\n\tdels.push_back(s);\n\thave[s]--;\n\treturn res * cnt(s);\n}\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d %d %d %d\", &s[i].a, &s[i].b, &s[i].c, &s[i].d);\n\t\ts[i] = makeMin(s[i]);\n\t}\n\tll res = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tSide down = s[i];\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tSide up = mirror(s[j]);\n\t\t\tfor (int rot = 0; rot < 4; rot++)\n\t\t\t{\n\t\t\t\t//map<Side, int> tmp = have;\n\t\t\t\tdels.push_back(s[j]);\n\t\t\t\thave[s[j]]--;\n\t\t\t\tll curRes = 1;\n\t\t\t\tcurRes *= go(Side(down.a, down.b, up.b, up.a));\n\t\t\t\tcurRes *= go(Side(down.b, down.c, up.c, up.b));\n\t\t\t\tcurRes *= go(Side(down.c, down.d, up.d, up.c));\n\t\t\t\tcurRes *= go(Side(down.d, down.a, up.a, up.d));\n\t\t\t\tup = shift(up);\n\t\t\t\t//have = tmp;\n\t\t\t\tres += curRes;\n\t\t\t\tfor (int k = 0; k < (int)dels.size(); k++)\n\t\t\t\t{\n\t\t\t\t\thave[dels[k]]++;\n\t\t\t\t}\n\t\t\t\tdels.clear();\n\t\t\t}\n\t\t}\n\t\thave[s[i]]++;\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\nvector<int> color[505];\nmap<vector<int>, int> has;\nint jiao[8];\nint use[4][4]={\n  {0, 3, 6, 5},\n  {0, 5, 4, 1},\n  {1, 4, 7, 2},\n  {2, 7, 6, 3}\n};\n\nvoid add(vector<int> color)\n{\n  for (int i=0; i<4; i++)\n  {\n      has[color]++;\n      rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid reduce(vector<int> color)\n{\n\n    for (int i=0; i<4; i++)\n    {\n        has[color]--;\n        rotate(color.begin(),color.begin()+1,color.end());\n  }\n}\n\nvoid dfs(int dep,long long& ans,int res=1)\n{\n    if (dep==4) ans+=res;\n    else\n    {\n        vector<int> tmp(4);\n        for (int i=0; i<4; i++)\n            tmp[i]=jiao[use[dep][i]];\n        if (has.count(tmp))\n        {\n            int cnt=has[tmp];\n            reduce(tmp);\n            dfs(dep+1,ans,res*cnt);\n            add(tmp);\n        }\n    }\n}\n\nlong long solve(int a,int b)\n{\n    for (int i=0; i<4; i++)\n    {\n        jiao[i]=color[a][i];\n        jiao[i+4]=color[b][i];\n    }\n    long long ans=0;\n    for (int i=0; i<4; i++)\n    {\n        dfs(0,ans);\n        rotate(jiao+4,jiao+5,jiao+8);\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++)\n    {\n        color[i].resize(4);\n        for (int j=0; j<4; j++)\n        {\n            scanf(\"%d\",&color[i][j]);\n        }\n        add(color[i]);\n    }\n    long long ans1=0;\n    for (int i=0; i<n; i++)\n    {\n      for (int j=i+1; j<n; j++)\n      {\n          reduce(color[i]);\n          reduce(color[j]);\n          ans1+=solve(i,j);\n          add(color[i]);\n          add(color[j]);\n      }\n      reduce(color[i]);\n    }\n    printf(\"%lld\\n\",ans1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef unsigned int U;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl; using std::cerr;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n) { cerr << #a << \" = {\"; \\\n      for(int qwq = (st); qwq <= (n); ++qwq) cerr << a[qwq] << (qwq == (n) ? '}' : ',') << (qwq == (n) ? '\\n' : ' '); }\n#define displayv(a) display(a, 0, (int)(a.size()-1))\n#include <ctime>\nclass MyTimer {\n  clock_t st;\npublic:\n  MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n  ~MyTimer() { report(); }\n  void reset() { st = clock_t(); }\n  void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) {}\n#define displayv(a) {}\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifdef QUICK_READ\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n  int a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\ninline LL readLL() {\n  LL a = 0; char c = getchar(), p = 0;\n  while(isspace(c)) c = getchar();\n  if(c == '-') p = 1, c = getchar();\n  while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n  return p ? -a : a;\n}\n\nconst int maxN = 400 + 5;\nconst int maxC = 1000 + 23;\nint n;\nstruct Tile {\n  int c[4];\n  Tile() {}\n  int& operator [](const int id) {\n    return c[id];\n  }\n  Tile(int x, int y, int z, int w) {\n    c[0] = x; c[1] = y; c[2] = z; c[3] = w;\n  }\n  friend bool operator < (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return A[i] < B[i];\n    return false;\n  }\n  friend bool operator == (Tile A, Tile B) {\n    for(int i = 0; i < 4; ++i) if(A[i] != B[i]) return false;\n    return true;\n  }\n  void rotate() {\n    int t = c[3];\n    for(int i = 3; i > 0; --i) c[i] = c[i - 1];\n    c[0] = t;\n  }\n  Tile normal() {\n    Tile r = *this;\n    for(int j = 0; j < 4; ++j) {\n      rotate(); if(*this < r) r = *this;\n    }\n    return r;\n  }\n  string tos() {\n  \tstatic char s[100];\n  \tsprintf(s, \"(%d, %d, %d, %d)\", c[0], c[1], c[2], c[3]);\n  \treturn string(s);\n\t}\n}a[maxN];\n\n#include <unordered_map>\nusing std::unordered_map;\nclass hasher {\npublic:\n\tsize_t operator() (const Tile &x) const {\n\t\tsize_t h = 0;\n\t\tfor(int i = 0; i < 4; ++i) h = h << 10 | x.c[i];\n\t\treturn h;\n\t}\n};\n\nunordered_map<Tile, int, hasher> M;\nvoid add(Tile x, int val) {\n\tfor(int i = 0; i < 4; ++i) {\n\t\tx.rotate(); M[x] += val;\n\t}\n}\n\nLL solve() {\n  LL ans = 0;\n  for(int i = n - 1; i >= 0; --i) {\n    for(int j = i + 1; j < n; ++j) {\n      add(a[j], -1);\n      for(int t = 0; t < 4; ++t) {\n        a[j].rotate();\n        Tile ai = a[i], aj = a[j];\n        Tile sample[4] = {Tile(aj[2], aj[1], ai[0], ai[3]), Tile(aj[3], aj[2], ai[3], ai[2]),\n              Tile(aj[0], aj[3], ai[2], ai[1]), Tile(aj[1], aj[0], ai[1], ai[0])};\n        for(int k = 0; k < 4; ++k) sample[k] = sample[k].normal();\n        LL prod = 1;\n        for(int k = 0; k < 4; ++k) {\n        \tif(M[sample[k]] == 0) {\n        \t\tfor(int kk = 0; kk < k; ++kk) add(sample[kk], 1);\n        \t\tgoto GIVEUP;\n\t\t\t\t\t}\n          prod *= M[sample[k]]; add(sample[k], -1);\n        }\n        for(int k = 0; k < 4; ++k) add(sample[k], 1);\n        ans += prod;\n        GIVEUP: {}\n      }\n      add(a[j], 1);\n    }\n    add(a[i], 1);\n  }\n  return ans;\n}\n\nint main() {\n  n = readint();\n  for(int i = 0; i < n; ++i) for(int j = 0; j < 4; ++j) a[i][j] = readint();\n  for(int i = 0; i < n; ++i) a[i] = a[i].normal();\n\tprintf(\"%lld\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(a) for(int k=head[a];k;k=e[k].ne)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=4e2+5,M=5e3+5,INF=1e9,mod=998244353;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nint n;\ntypedef vector<int> VI;\nVI c[N],u,d,a[4];\nmap<VI,int>mp;\nvoid rot(VI&o){int t=o[0];o[0]=o[1];o[1]=o[2];o[2]=o[3];o[3]=t;}\nVI mkmn(VI&o){\n\tVI ro=o;re(i,1,4)\n\t\trot(ro),\n\t\to=min(o,ro);\n\treturn o;\n}\nint ct(VI o){\n\tint res=1;VI ro=o;\n\tre(i,1,4)rot(ro),res+=(o==ro);\n\treturn res;\n}\nint main(){\n\tread(n);rep(i,1,n){\n\t\tre(j,0,4){int x=read();c[i].pb(x);}\n\t\tmkmn(c[i]);mp[c[i]]++;\n\t}re(i,0,4)a[i].resize(4);\n\tll ans=0;\n\trep(i,1,n)re(j,1,i){\n\t\tu=c[i];d=c[j];\n\t\tmp[u]--;mp[d]--;reverse(all(u));\n\t\tre(k,0,4){\n\t\t\ta[0][0]=u[0];a[0][1]=u[1];a[0][2]=d[1];a[0][3]=d[0];\n\t\t\ta[1][0]=u[1];a[1][1]=u[2];a[1][2]=d[2];a[1][3]=d[1];\n\t\t\ta[2][0]=u[2];a[2][1]=u[3];a[2][2]=d[3];a[2][3]=d[2];\n\t\t\ta[3][0]=u[3];a[3][1]=u[0];a[3][2]=d[0];a[3][3]=d[3];\n\t\t\tll res=1;\n\t\t\tre(o,0,4){\n\t\t\t\tmkmn(a[o]);\n\t\t\t\tres*=(mp[a[o]]--)*ct(a[o]);\n\t\t\t}\n\t\t\tans+=res;\n\t\t\tre(o,0,4)mp[a[o]]++;\n\t\t\trot(d);\n\t\t}\n\t\tmp[c[i]]++;mp[c[j]]++;\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int mod = 1e9 + 7;\n\nint N;\nint c[405][4];\nLL hsh[405];\n\nLL coef[] = {1LL, LL(1e3), LL(1e6), LL(1e9)};\n\nunordered_map<LL, int> mp;\n\nint power(int x, int y)\n{\n    if(y <= 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1)   ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i <= N; i++)\n    {\n        int cl[4];\n        for(int j = 0; j < 4; j++)  scanf(\"%d\", &cl[j]);\n\n        LL h = 1LL << 60;\n        int cnt = 0, id = -1;\n        for(int i = 0; i < 4; i++)\n        {\n            LL hh = cl[i] + LL(1e3) * cl[(i + 1) & 3] + LL(1e6) * cl[(i + 2) & 3] + LL(1e9) * cl[(i + 3) & 3];\n            if(h == hh) cnt++;\n            else if(h > hh) { h = hh; cnt = 1; id = i; }\n        }\n\n        for(int j = 0; j < 4; j++)  c[i][j] = cl[(j + id) & 3];\n\n        hsh[i] = h;\n        mp[ hsh[i] ]++;\n    }\n\n    LL ans = 0;\n    for(int i = 1; i < N; i++)\n        for(int j = i + 1; j <= N; j++)\n            for(int d = 0; d < 4; d++)\n            {\n                mp[ hsh[i] ]--; mp[ hsh[j] ]--;\n                swap(c[j][1], c[j][3]);\n\n                LL sol = 1; int lst = -1;\n                for(int k = 0; k < 4; k++)\n                {\n                    int cl[4];\n                    cl[0] = (c[i][k]);\n                    cl[1] = (c[j][(k + d) & 3]);\n                    cl[2] = (c[j][(k + d + 1) & 3]);\n                    cl[3] = (c[i][(k + 1) & 3]);\n\n                    LL h = 1LL << 60;\n                    int cnt = 0;\n                    for(int i = 0; i < 4; i++)\n                    {\n                        LL hh = cl[i] + LL(1e3) * cl[(i + 1) & 3] + LL(1e6) * cl[(i + 2) & 3] + LL(1e9) * cl[(i + 3) & 3];\n                        if(h == hh) cnt++;\n                        else if(h > hh) { h = hh; cnt = 1; }\n                    }\n\n                    if(!mp.count(h)) { sol = 0; break; }\n                    int nr = mp[h];\n                    if(nr <= 0) { sol = 0; break; }\n\n                    mp[h]--;\n                    sol = (1LL * sol * nr * cnt);\n\n                    lst = k;\n                }\n\n                ans += sol;\n\n                for(int k = 0; k <= lst; k++)\n                {\n                    int cl[4];\n                    cl[0] = (c[i][k]);\n                    cl[1] = (c[j][(k + d) & 3]);\n                    cl[2] = (c[j][(k + d + 1) & 3]);\n                    cl[3] = (c[i][(k + 1) & 3]);\n\n                    LL h = 1LL << 60;\n                    int cnt = 0;\n                    for(int i = 0; i < 4; i++)\n                    {\n                        LL hh = cl[i] + LL(1e3) * cl[(i + 1) & 3] + LL(1e6) * cl[(i + 2) & 3] + LL(1e9) * cl[(i + 3) & 3];\n                        if(h == hh) cnt++;\n                        else if(h > hh) { h = hh; cnt = 1; }\n                    }\n\n                    mp[h]++;\n                }\n\n                swap(c[j][1], c[j][3]);\n                mp[ hsh[i] ]++; mp[ hsh[j] ]++;\n            }\n\n    ans /= 3;\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<ll> po(4,1);\n\nvector<int> Sort(vector<int> v){\n    vector<int> res=v,u(4);\n    for (int i=1;i<4;++i){\n        for (int j=0;j<4;++j){\n            u[j]=v[(i+j)%4];\n        }\n        if (u<res) res=u;\n    }\n    return res;\n}\n\nll hashed(vector<int> v){\n    ll res=0; v=Sort(v);\n    for (int i=0;i<4;++i){\n        res+=v[i]*po[i];\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    for (int i=0;i<3;++i) po[i+1]=po[i]*1000;\n    map<ll,ll> cnt;\n    vector<ll> each(N);\n    vector<int> v(4);\n    for (int i=0;i<N;++i){\n        each[i]=hashed(C[i]);\n        ++cnt[each[i]];\n    }\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<N;++j){\n            if (i==j) continue;\n            --cnt[each[i]]; --cnt[each[j]];\n            for (int p=0;p<4;++p){\n                map<ll,int> used;\n                ll sum=1,rot;\n                for (int q=0;q<4;++q){\n                    v[0]=C[i][q];\n                    v[1]=C[j][(p-q+4)%4];;\n                    v[2]=C[j][(p-q+7)%4];\n                    v[3]=C[i][(q+1)%4];\n                    if (v[0]==v[1]&&v[1]==v[2]&&v[2]==v[3]&&v[3]==v[0]) rot=4;\n                    else if (v[0]==v[2]&&v[1]==v[3]) rot=2;\n                    else rot=1;\n                    ll surface=hashed(v);\n                    sum*=(cnt[surface]-used[surface])*rot;\n                    ++used[surface];\n                }\n                ans+=sum;\n            }\n            ++cnt[each[i]]; ++cnt[each[j]];\n        }\n    }\n    cout << ans/6 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG 1\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef pair<int, int> PII;\n\n#define MAX_INT (int)0x7fffffff\n#define MIN_INT (int)0x80000000\n#define MAX_UINT (uint)0xffffffff\n\n#define TTi template<typename T> inline\nTTi T SQR(T x) { return x * x; }\n\n#define CONCAT3_NX(x, y, z) x ## y ## z\n#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)\n#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)\n#define TYPE(x) __typeof(x)\n\n#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)\n#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)\n#define FORN(i, n)    FOR(i, 0, n)\n#define RFORN(i, n)   RFOR(i, 0, n)\n#define FOREACH(i, v) for (auto& i: v)\n\n#define SC() scanf(\"\\n\")\n#define SC1(fmt, a) scanf(fmt, &a)\n#define SC2(fmt, a, b) scanf(fmt, &a, &b)\n#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)\n#define SCi(a) scanf(\"%d\", &a)\n#define SCii(a,b) scanf(\"%d%d\", &a, &b)\n#define SCiii(a,b,c) scanf(\"%d%d%d\", &a, &b, &c)\n#define fLL \"%lld\"\n#define SCl(a) scanf(fLL, &a)\n#define SCll(a,b) scanf(fLL fLL, &a, &b)\n#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)\n#define SCs(s, n) {scanf(\"%s\", s); n = strlen(s);}\n#define SCc(s) scanf(\"%c\", &c)\n\n#define MP make_pair\n#define PB push_back\n#define WHOLE(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define POPST(stack) (stack).top();(stack).pop();\n#define POPQ(queue) (queue).front();(queue).pop();\n#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())\n#define SORT(v) (sort(WHOLE(v)))\n\n#define LIMIT(x, lim) {if (x > lim) x = lim;}\nTTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}\nTTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}\nTTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }\nTTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }\n\nTTi int hamming(T x) {return __builtin_popcountll((long long)x);}\nint hamming(int x) {return __builtin_popcount(x);}\nint hamming(long x) {return __builtin_popcountl(x);}\nint hamming(long long x) {return __builtin_popcountll(x);}\n\nvector<string> split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);\n}\ntemplate<typename T, typename... Args>\ninline string arrStr(T arr, int n) {\n    stringstream s; s << \"[\";\n    FORN(i, n - 1) s << arr[i] << \",\";\n    s << arr[n - 1] << \"]\";\n    return s.str();\n}\n\n// #ifndef ONLINE_JUDGE\n#ifdef JUDGE_LOCAL\n    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}\n    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, \"%d, \", arr[i]);}\n    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}\n\n    inline void __evars_begin(int line) { cerr << \"#\" << line << \": \"; }\n    inline void __evars(vector<string>::iterator it) { cerr << endl; }\n    TTi void __evars_out_var(vector<T> val) { cerr << arrStr(val, val.size()); }\n    TTi void __evars_out_var(T* val) { cerr << arrStr(val, 10); }\n    TTi void __evars_out_var(T val) { cerr << val; }\n    template<typename T, typename... Args>\n    inline void __evars(vector<string>::iterator it, T a, Args... args) {\n        cerr << it->substr((*it)[0] == ' ', it->length()) << \"=\";\n        __evars_out_var(a);\n        cerr << \"; \";\n        __evars(++it, args...);\n    }\n#else\n    #define EPR(args...) 1\n    #define EARR(args...) 1\n    #define EVEC(args...) 1\n    #define EVARS(args...) 1\n#endif\n\ntemplate<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }\n#define DIE(args...) {printf(args);exit(0);}\ninline void PR(void) {}\ninline void PR(int x) {printf(\"%d\", x);}\ninline void PR(LL x) {printf(\"%lld\", x);}\ninline void PR(size_t x) {printf(\"%llu\", (ULL)x);}\ninline void PR(const char * s) {printf(\"%s\", s);}\ninline void PR(double f) {printf(\"%.10f\", f);}\ninline void PR(long double f) {printf(\"%.10f\", (double)f);}\nTTi void PR(vector<T> &vec) {auto sz = vec.size();for(auto x:vec){PR(x);(--sz)?putc(0x20,stdout):0;}}\nTTi void PRS(T x) {PR(x);putc(0x20,stdout);}\nTTi void PRN(T x) {PR(x);putc(0x0a,stdout);}\nvoid PRN(void) {putc(0x0a,stdout);}\n\nstruct pairhash {\n    template <typename T, typename U>\n    std::size_t operator() (const std::pair<T, U> &x) const {\n        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n    }\n};\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double PI = 3.1415926535897932384626433832795l;\n\nTTi T gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\ninline void addto(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\ninline int add(int a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void subto(int &a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n}\ninline int sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\ninline void multo(int &a, int b) {\n    a = (long long)a * b % MOD;\n}\ninline int mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\ninline int mulmod(int a, int b, int mod) {\n    return (long long)a * b % mod;\n}\ninline int powmod(int a, int e, int mod) {\n    int x;\n    for(x = 1; e > 0; e >>= 1) {\n        if (e & 1)\n            x = mulmod(x, a, mod);\n        a = mulmod(a, a, mod);\n    }\n    return x;\n}\ninline int invmod_prime(int a, int mod) {\n    return powmod(a, mod - 2, mod);\n}\ninline LL invmod_LL(LL p){\n    LL q = p;\n    for(LL a = p*p; a != 1; a*=a) q*=a;\n    return q;\n}\n\n\n// -----------------------------------------------------------------\n// CODE\n// -----------------------------------------------------------------\n\n\nint N, M, K, L, E, Q;\n\nstruct Colors {\n    int colors[4];\n    inline void normalize() {\n        int i = (less(0, 1)) ? 0 : 1;\n        int j = (less(2, 3)) ? 2 : 3;\n        int ans = (less(i, j)) ? i : j;\n        rotate_left(ans);\n    }\n    inline void rotate_left(int num) {\n        int tmp[4];\n        FORN(i, 4) tmp[i] = colors[(num+i)%4];\n        FORN(i, 4) colors[i] = tmp[i];\n    }\n    inline int mult() const {\n        int ans = 1;\n        FOR(i, 1, 4)\n            if ((!less(0, i)) && (!less(i, 0)))\n                ans++;\n        return ans;\n    }\n    inline bool less(int i, int j) const {\n        FORN(k, 4) {\n            if (colors[(i+k)%4] < colors[(j+k)%4]) return true;\n            if (colors[(i+k)%4] > colors[(j+k)%4]) return false;\n        }\n        return false;\n    }\n    inline bool operator<(const Colors &other) const {\n        FORN(k, 4) {\n            if (colors[k] < other.colors[k]) return true;\n            if (colors[k] > other.colors[k]) return false;\n        }\n        return false;\n    }\n    inline bool operator==(const Colors &other) const {\n        return (!(*this < other)) && (!(other < *this));\n    }\n    inline Colors pair(const Colors &other, int offset) const {\n        Colors ans;\n        if (offset == 0) {\n            ans.colors[0] = colors[0];\n            ans.colors[1] = other.colors[1];\n            ans.colors[2] = other.colors[0];\n            ans.colors[3] = colors[1];\n        }\n        else if (offset == 1) {\n            ans.colors[0] = colors[1];\n            ans.colors[1] = other.colors[0];\n            ans.colors[2] = other.colors[3];\n            ans.colors[3] = colors[2];\n        }\n        else if (offset == 2) {\n            ans.colors[0] = colors[2];\n            ans.colors[1] = other.colors[3];\n            ans.colors[2] = other.colors[2];\n            ans.colors[3] = colors[3];\n        }\n        else if (offset == 3) {\n            ans.colors[0] = colors[3];\n            ans.colors[1] = other.colors[2];\n            ans.colors[2] = other.colors[1];\n            ans.colors[3] = colors[0];\n        }\n        else {\n            assert(0);\n        }\n        ans.normalize();\n        return ans;\n    }\n};\n\nmap<Colors, int> colcnt;\nvector<Colors> tiles;\n\nLL countfit(Colors a, Colors b, Colors brot) {\n    Colors dst[4] = {\n        a.pair(brot, 0),\n        a.pair(brot, 1),\n        a.pair(brot, 2),\n        a.pair(brot, 3),\n    };\n    LL ans = 1;\n    FORN(i, 4) {\n        auto &c = dst[i];\n        ans *= 1ll * colcnt[c] * c.mult();\n        colcnt[c]--;\n    }\n    FORN(i, 4) {\n        auto &c = dst[i];\n        colcnt[c]++;\n    }\n    return ans;\n}\n\nLL countSmallest(Colors a) {\n    LL ans = 0;\n    FOREACH(pb, colcnt) {\n        if (!pb.second) continue;\n        Colors b = pb.first;\n        Colors brot = pb.first;\n        LL cccnt = pb.second;\n        colcnt[b]--;\n        FORN(rot, 4) {\n            LL curans = countfit(a, b, brot);\n            ans += cccnt * 1ll * curans;\n            brot.rotate_left(1);\n        }\n        colcnt[b]++;\n    }\n    EPR(\"ans smallest %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    SCi(N);\n    FORN(i, N) {\n        Colors c;\n        FORN(j, 4)\n            SCi(c.colors[j]);\n        c.normalize();\n        colcnt[c]++;\n        tiles.push_back(c);\n    }\n\n    LL ans = 0;\n    FORN(i, (int)tiles.size()) {\n        EPR(\"tile %d\\n\", i);\n        Colors a = tiles[i];\n        EVARS(a.colors[0], a.colors[1], a.colors[2], a.colors[3]);\n        colcnt[a]--;\n        ans += countSmallest(a);\n    }\n    PRN(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll ans;\nint n;\nstruct node{\n\tint a1,a2,a3,a4;\n\tnode() {}\n\tnode(int aa1,int aa2,int aa3,int aa4):a1(aa1),a2(aa2),a3(aa3),a4(aa4) {}\n\tbool operator <(const node &a) const {\n\t\tif(a1!=a.a1)\n\t\t\treturn a1<a.a1;\n\t\tif(a2!=a.a2)\n\t\t\treturn a2<a.a2;\n\t\tif(a3!=a.a3)\n\t\t\treturn a3<a.a3;\n\t\treturn a4<a.a4;\n\t}\n\tbool operator ==(const node &a) const{\n\t\tif(a1==a.a1&&a2==a.a2&&a3==a.a3&&a4==a.a4)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}t[MAXN];\nmap<node,ll> used;\nvoid solve(int b1,int b2,int b3,int b4){\n\tused[node(b1,b2,b3,b4)]++;\n}\nll check(node x,node y){\n\tll res=0;\n\tif(x==y)\n\t\tres++;\n\tint tx=y.a1;\n\ty.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2;y.a2=y.a3;y.a3=y.a4;y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\treturn res;\n}\t\nvoid count(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8){\n\t//PF(\"{%d %d %d %d %d %d %d %d}\\n\",b1,b2,b3,b4,b5,b6,b7,b8);\n\tnode x1=node(b1,b2,b6,b5);\n\tnode x2=node(b2,b3,b7,b6);\n\tnode x3=node(b3,b4,b8,b7);\n\tnode x4=node(b4,b1,b5,b8);\n\tnode sp1=node(b4,b3,b2,b1);\n\tnode sp2=node(b5,b6,b7,b8);\n\tll res1=used[x1];\n\tll res2=used[x2];\n\tll res3=used[x3];\n\tll res4=used[x4];\n\tres1=res1-check(sp1,x1)-check(sp2,x1);\n\tres2=res2-check(sp1,x2)-check(sp2,x2)-check(x1,x2);\n\tres3=res3-check(sp1,x3)-check(sp2,x3)-check(x1,x3)-check(x2,x3);\n\tres4=res4-check(sp1,x4)-check(sp2,x4)-check(x1,x4)-check(x2,x4)-check(x3,x4);\n\tans+=res1*res2*res3*res4;\n\t//PF(\"{%lld %lld %lld %lld %lld}\\n\",used[x1],res1,check(sp1,x1),check(sp2,x1),res4);\n}\nint main(){\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&t[i].a1,&t[i].a2,&t[i].a3,&t[i].a4);\n\t\tsolve(t[i].a4,t[i].a3,t[i].a2,t[i].a1);\n\t\tsolve(t[i].a3,t[i].a2,t[i].a1,t[i].a4);\n\t\tsolve(t[i].a2,t[i].a1,t[i].a4,t[i].a3);\n\t\tsolve(t[i].a1,t[i].a4,t[i].a3,t[i].a2);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a4,t[j].a3,t[j].a2,t[j].a1);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a3,t[j].a2,t[j].a1,t[j].a4);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a2,t[j].a1,t[j].a4,t[j].a3);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a1,t[j].a4,t[j].a3,t[j].a2);\t\n\t\t}\n\tPF(\"%lld\",ans/3ll);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n    template <>\n    class hash<std::pair<Int, Int>> {\n    public:\n        size_t operator()(const std::pair<Int, Int>& x) const{\n            return hash<Int>()(x.first) ^ hash<Int>()(x.second);\n        }\n    };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  unordered_set<Int> used_f;\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n    if(used_f.count(b[i])) continue;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n    \n    Int v=b[i];\n    for(Int j=0;j<4;i++){\n      v=((v&1023)<<30)|(v>>10);\n      used_f.emplace(v);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AtCoder Regular Contest 062\n// E - AtCoDeerくんと立方体づくり / Building Cubes with AtCoDeer\n\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define MAX_N 400\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> Tile;\n\n\nint N;\nmultiset<Tile> tiles, used;\nll ans;\n\nTile rotate(Tile t) {\n  return { t[1], t[2], t[3], t[0] };\n}\n\nint main() {\n\n  Tile t1, t2;\n  int c;\n  ll cnt, tmp;\n  set<Tile>::iterator itr1, itr2;\n\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    Tile t;\n    for (int j = 0; j < 4; j++) {\n      scanf(\"%d\", &c);\n      t.push_back(c);\n    }\n    tiles.insert(t);\n  }\n\n  ans = 0;\n  for (itr1 = tiles.begin(); itr1 != tiles.end(); itr1++) {\n    for (itr2 = itr1, itr2++; itr2 != tiles.end(); itr2++) {\n      t1 = *itr1; t2 = *itr2;\n      for (int d = 0; d < 4; d++) {\n        used.clear();\n        used.insert(t1);\n        used.insert(t2);\n        cnt = 1;\n        for (int i = 0; i < 4; i++) {\n          tmp = 0;\n          Tile t = { t1[(1 + i) % 4], t1[(0 + i) % 4], t2[(4 - i) % 4], t2[(7 - i) % 4] };\n          for (int j = 0; j < 4; j++) {\n            tmp += tiles.count(t);\n            tmp -= used.count(t);\n            t = rotate(t);\n          }\n          tmp = max(tmp, 0LL);\n          cnt *= tmp;\n          used.insert(t);\n        }\n        ans += cnt;\n        t2 = rotate(t2);\n      }\n    }\n  }\n\n  ans /= 3;\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define lf double\n#define N 4\n#define err {puts(\"-1\");exit(0);};\nint color[408][4];\nll has(int a[])\n{\n\tll res=0;\n\tfor(int i=N-1;i>=0;i--) res=res*1000+a[i];\n\treturn res;\n}\nvector<ll> _rotate(int c[])\n{\n\tvector<ll> res;\n//\tfor(int i=0;i<N;i++) cout<<c[i]<<\"   \";\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tint a[4];\n\t\tfor(int j=0;j<N;j++) a[j]=c[(i+j)%N];\n\t\tres.push_back(has(a));\n\t}return res;\n}\nint same(ll x,ll y)\n{\n\tint a[N],c[N];int sum=0;\n\tfor(int i=0;i<N;i++) a[i]=x%1000,x/=1000;\n\tfor(int i=0;i<N;i++) \n\t{\n\t\tfor(int j=0;j<N;j++) c[j]=a[(i+j)%N];\n\t\tsum+= has(c)==y;\n\t}return sum;\n}\nmap<ll,ll >m;\nvoid ins(int x)\n{\n\tvector<ll> v=_rotate(color[x]);\n\tfor(int i=0;i<v.size();i++) m[v[i]]++;\n}\nll ans;\nll operate(int c1[],int c2[])\n{\n//\tfor(int i=0;i<N;i++) cout<<c1[i]<<\" \";cout<<\"\\n\";\n//\tfor(int i=0;i<N;i++) cout<<c2[i]<<\" \";cout<<\"\\n\";system(\"pause\");\n\tll p=has(c1);\n\tint a[4];ll ck[4];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta[0]=c1[i],a[1]=c1[(i+1)%N],a[2]=c2[(i+1)%N],a[3]=c2[i];\n\t\tck[i]=has(a);\n\t}\n\tll cnt=1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tll over=same(p,ck[i]);\n\t\tfor(int j=0;j<i;j++) over+=same(ck[j],ck[i]);\n\t\tif(m[ck[i]]<=0) return 0;\n\t\tcnt*=m[ck[i]]-over;\n\t}\n\treturn cnt;\n}\nint bel[]={0,3,2,1};\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<N;j++) cin>>color[i][j];\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tint a[N],b[N];for(int k=0;k<N;k++) b[k]=color[i][k];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<N;l++)\n\t\t\t\t\ta[l]=color[j][bel[(l+k)%N]];\n\t\t\t\tans+=operate(a,b);\n\t\t\t}\n\t\t}ins(i);\n\t}\n\tcout<<ans;\n    return 0;\n}\n/*\n3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n*/\n/*\n5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n       int n, m;\n       cin >> n >> m;\n}"
  },
  {
    "language": "C++",
    "code": "// author: hjy\n// Problem:\n#include<bits/stdc++.h>\n//#pragma GCC optimize(2)\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define rep(i,n) for(register int i=0; i<(int)(n); ++i)\n#define per(i,n) for(register int i=(int)(n)-1; i>=0; --i)\n#define rep1(i,n) for(register int i=1; i<=(int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\ninline int read() {\n\tint x=0,ng=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') { if(ch=='-') ng=1; ch=getchar(); }\n\twhile(ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }\n\treturn ng?-x:x;\n}\n\nconst int mod=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int seed=20040305;\n\nint n;\nint c[410][5];\nvector<pair<pii,pii> > v;\nll res;\nmap<pair<pii,pii>,int> have;\n\n\nint same(pair<pii,pii> cur,pair<pii,pii> per)\n{\n\tint cnt=0;\n\tif(cur==per) cnt++;\n\tif(cur==mp(mp(per.fi.se,per.se.fi),mp(per.se.se,per.fi.fi))) cnt++;\n\tif(cur==mp(mp(per.se.fi,per.se.se),mp(per.fi.fi,per.fi.se))) cnt++;\n\tif(cur==mp(mp(per.se.se,per.fi.fi),mp(per.fi.se,per.se.fi))) cnt++;\n\treturn cnt;\n}\n/*\n1---2\n|   |\n3---4\n*/\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n)\n\t{\n\t\trep(j,4) scanf(\"%d\",&c[i][j]);\n\t\trep(j,v.size())\n\t\t{\n\t\t\t\n\t\t\tpair<pii,pii> x=v[j];\n\t\t\tpair<pii,pii> y=mp(mp(c[i][0],c[i][1]),mp(c[i][2],c[i][3]));\n\t\t\tpair<pii,pii> c1=mp(mp(x.se.se,x.se.fi),mp(y.fi.se,y.fi.fi));\n\t\t\tpair<pii,pii> c2=mp(mp(x.se.fi,x.fi.se),mp(y.se.fi,y.fi.se));\n\t\t\tpair<pii,pii> c3=mp(mp(x.fi.se,x.fi.fi),mp(y.se.se,y.se.fi));\n\t\t\tpair<pii,pii> c4=mp(mp(x.fi.fi,x.se.se),mp(y.fi.fi,y.se.se));\n//\t\t\tprintf(\"x=%d%d%d%d\\n\",x.fi.fi,x.fi.se,x.se.fi,x.se.se);\n//\t\t\tprintf(\"c1=%d%d%d%d\\n\",c1.fi.fi,c1.fi.se,c1.se.fi,c1.se.se);\n\t\t\tll all=1;\n\t\t\tall*=have[c1]-same(c1,x);\n\t\t\tall*=have[c2]-same(c2,x)-same(c2,c1);\n\t\t\tall*=have[c3]-same(c3,x)-same(c3,c1)-same(c3,c2);\n\t\t\tall*=have[c4]-same(c4,x)-same(c4,c1)-same(c4,c2)-same(c4,c3);\n\t\t\tres+=all;\n\t\t}\n\t\tv.pb(mp(mp(c[i][0],c[i][1]),mp(c[i][2],c[i][3])));\n\t\tv.pb(mp(mp(c[i][1],c[i][2]),mp(c[i][3],c[i][0])));\n\t\tv.pb(mp(mp(c[i][2],c[i][3]),mp(c[i][0],c[i][1])));\n\t\tv.pb(mp(mp(c[i][3],c[i][0]),mp(c[i][1],c[i][2])));\n\t\thave[mp(mp(c[i][0],c[i][1]),mp(c[i][2],c[i][3]))]++;\n\t\thave[mp(mp(c[i][1],c[i][2]),mp(c[i][3],c[i][0]))]++;\n\t\thave[mp(mp(c[i][2],c[i][3]),mp(c[i][0],c[i][1]))]++;\n\t\thave[mp(mp(c[i][3],c[i][0]),mp(c[i][1],c[i][2]))]++;\n\t}\n\tprintf(\"%d\",res);\n}\n/*\n       1-------2          x\n      /|      /|\n\t 4-------3 |\n\t | 4-----|-3\n\t |/      |/  \n\t 1-------2            y   \n*/"
  },
  {
    "language": "C++",
    "code": "/*program from Wolfycz*/\n#include<map>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define Fi first\n#define Se second\n#define inf 0x7f7f7f7f\n#define min(x,y) (x<y?x:y)\n#define max(x,y) (x>y?x:y)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ninline char gc(){\n\tstatic char buf[1000000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int frd(){\n\tint x=0,f=1; char ch=gc();\n\tfor (;ch<'0'||ch>'9';ch=gc())\tif (ch=='-')\tf=-1;\n\tfor (;ch>='0'&&ch<='9';ch=gc())\tx=(x<<3)+(x<<1)+ch-'0';\n\treturn x*f;\n}\ninline int read(){\n\tint x=0,f=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar())\tif (ch=='-')\tf=-1;\n\tfor (;ch>='0'&&ch<='9';ch=getchar())\tx=(x<<3)+(x<<1)+ch-'0';\n\treturn x*f;\n}\ninline void print(int x){\n\tif (x<0)\tputchar('-'),x=-x;\n\tif (x>9)\tprint(x/10);\n\tputchar(x%10+'0');\n}\nconst int N=4e2;\nint C[N+10][4];\nll v[N+10];\nmap<ll,int>Mp;\nll Hash(int a,int b,int c,int d){return ((ll)a<<30)|((ll)b<<20)|((ll)c<<10)|(ll)d;}\nvoid Add(ll x,int v){\n\tfor (int i=0;i<4;i++,x=(x>>10)|((x&1023)<<30)){\n\t\tif (Mp.find(x)==Mp.end())\tMp.insert(map<ll,int>::value_type(x,0));\n\t\tMp.find(x)->Se+=v;\n\t}\n}\nint main(){\n\tint n=read(); ll Ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<4;j++)\n\t\t\tC[i][j]=read();\n\t\tv[i]=Hash(C[i][0],C[i][1],C[i][2],C[i][3]);\n\t\tAdd(v[i],1);\n\t}\n\tfor (int i=1;i<n-4;i++){\n\t\tAdd(v[i],-1);\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tAdd(v[j],-1);\n\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\tstatic ll A[4];\n\t\t\t\tA[0]=Hash(C[i][1],C[i][0],C[j][(k+1)%4],C[j][k    %4]);\n\t\t\t\tA[1]=Hash(C[i][2],C[i][1],C[j][k    %4],C[j][(k+3)%4]);\n\t\t\t\tA[2]=Hash(C[i][3],C[i][2],C[j][(k+3)%4],C[j][(k+2)%4]);\n\t\t\t\tA[3]=Hash(C[i][0],C[i][3],C[j][(k+2)%4],C[j][(k+1)%4]);\n\t\t\t\tint a=0,b=0,c=0,d=0;\n\t\t\t\tmap<ll,int>::iterator it;\n\t\t\t\tif ((it=Mp.find(A[0]))==Mp.end())\tcontinue;\n\t\t\t\telse\ta=it->Se;\n\t\t\t\tif ((it=Mp.find(A[1]))==Mp.end())\tcontinue;\n\t\t\t\telse\tb=it->Se;\n\t\t\t\tif ((it=Mp.find(A[2]))==Mp.end())\tcontinue;\n\t\t\t\telse\tc=it->Se;\n\t\t\t\tif ((it=Mp.find(A[3]))==Mp.end())\tcontinue;\n\t\t\t\telse\td=it->Se;\n\t\t\t\tif (!a||!b||!c||!d)\tcontinue;\n\t\t\t\tll res=1;\n\t\t\t\tfor (int l=0;l<4;l++){\n\t\t\t\t\tres*=Mp.find(A[l])->Se;\n\t\t\t\t\tAdd(A[l],-1);\n\t\t\t\t}\n\t\t\t\tAns+=res;\n\t\t\t\tfor (int l=0;l<4;l++)\tAdd(A[l],1);\n\t\t\t}\n\t\t\tAdd(v[j],1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\ntypedef long long ll;\nll ans;\nint n;\nstruct node{\n\tint a1,a2,a3,a4;\n\tnode() {}\n\tnode(int aa1,int aa2,int aa3,int aa4):a1(aa1),a2(aa2),a3(aa3),a4(aa4) {}\n\tbool operator <(const node &a) const {\n\t\tif(a1!=a.a1)\n\t\t\treturn a1<a.a1;\n\t\tif(a2!=a.a2)\n\t\t\treturn a2<a.a2;\n\t\tif(a3!=a.a3)\n\t\t\treturn a3<a.a3;\n\t\treturn a4<a.a4;\n\t}\n\tbool operator ==(const node &a) const{\n\t\tif(a1==a.a1&&a2==a.a2&&a3==a.a3&&a4==a.a4)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}t[MAXN];\nmap<node,ll> used;\nvoid solve(int b1,int b2,int b3,int b4){\n\tused[node(b1,b2,b3,b4)]++;\n}\nll check(node x,node y){\n\tll res=0;\n\tif(x==y)\n\t\tres++;\n\tint tx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\ttx=y.a1;\n\ty.a1=y.a2,y.a2=y.a3,y.a3=y.a4,y.a4=tx;\n\tif(x==y)\n\t\tres++;\n\treturn res;\n}\t\nvoid count(int b1,int b2,int b3,int b4,int b5,int b6,int b7,int b8){\n\t//PF(\"{%d %d %d %d %d %d %d %d}\\n\",b1,b2,b3,b4,b5,b6,b7,b8);\n\tnode x1=node(b1,b2,b6,b5);\n\tnode x2=node(b2,b3,b7,b6);\n\tnode x3=node(b3,b4,b8,b7);\n\tnode x4=node(b4,b1,b5,b8);\n\tnode sp1=node(b4,b3,b2,b1);\n\tnode sp2=node(b8,b7,b6,b5);\n\tll res1=used[x1];\n\tll res2=used[x2];\n\tll res3=used[x3];\n\tll res4=used[x4];\n\tres1=res1-check(sp1,x1)-check(sp2,x1);\n\tres2=res2-check(sp1,x2)-check(sp2,x2)-check(x1,x2);\n\tres3=res3-check(sp1,x3)-check(sp2,x3)-check(x1,x3)-check(x2,x3);\n\tres4=res4-check(sp1,x4)-check(sp2,x4)-check(x1,x4)-check(x2,x4)-check(x3,x4);\n\tans+=res1*res2*res3*res4;\n\tif(ans<0)\n\t\twhile(1);\n\t//PF(\"{%lld %lld %lld %lld %lld}\\n\",used[x1],res1,check(sp1,x1),check(sp2,x1),res4);\n}\nint main(){\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tSF(\"%d%d%d%d\",&t[i].a1,&t[i].a2,&t[i].a3,&t[i].a4);\n\t\tsolve(t[i].a4,t[i].a3,t[i].a2,t[i].a1);\n\t\tsolve(t[i].a3,t[i].a2,t[i].a1,t[i].a4);\n\t\tsolve(t[i].a2,t[i].a1,t[i].a4,t[i].a3);\n\t\tsolve(t[i].a1,t[i].a4,t[i].a3,t[i].a2);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a4,t[j].a3,t[j].a2,t[j].a1);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a3,t[j].a2,t[j].a1,t[j].a4);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a2,t[j].a1,t[j].a4,t[j].a3);\t\n\t\t\tcount(t[i].a1,t[i].a2,t[i].a3,t[i].a4,t[j].a1,t[j].a4,t[j].a3,t[j].a2);\t\n\t\t}\n\tPF(\"%lld\",ans/3ll);\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <array>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> norm(std::vector<int> v) {\n\tstd::vector<int> res(v);\n\tREP(i, 3) {\n\t\tstd::rotate(v.begin(), v.begin() + 1, v.end());\n\t\tCHMIN(res, v);\n\t}\n\treturn res;\n}\n\nint getType(const std::vector<int>& v) {\n\tif (v[0] == v[2] && v[1] == v[3]) {\n\t\tif (v[0] == v[1]) return 4;\n\t\telse return 2;\n\t}\n\treturn 1;\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tMAT(int, c, n, 4);\n\n\tstd::map<std::vector<int>, int> map;\n\tREP(i, n) ++map[c[i] = norm(c[i])];\n\n\tint ans = 0;\n\tREP(i, n) {\n\t\t--map[c[i]];\n\t\tFOR(j, i + 1, n) {\n\t\t\t--map[c[j]];\n\t\t\tREP(_, 4) {\n\t\t\t\t{\n\t\t\t\t\tstd::vector<std::vector<int>> v;\n\t\t\t\t\tv.emplace_back(std::vector<int>{ c[i][1], c[j][0], c[j][3], c[i][2] });\n\t\t\t\t\tv.emplace_back(std::vector<int>{ c[i][2], c[j][3], c[j][2], c[i][3] });\n\t\t\t\t\tv.emplace_back(std::vector<int>{ c[i][3], c[j][2], c[j][1], c[i][0] });\n\t\t\t\t\tv.emplace_back(std::vector<int>{ c[i][0], c[j][1], c[j][0], c[i][1] });\n\t\t\t\t\tint t = 1;\n\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\tv[k] = norm(v[k]);\n\t\t\t\t\t\tif (map.count(v[k])) {\n\t\t\t\t\t\t\tt *= map[v[k]];\n\t\t\t\t\t\t\tt *= getType(v[k]);\n\t\t\t\t\t\t\t--map[v[k]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tREP(k, 4) if(map.count(v[k])) ++map[v[k]];\n\t\t\t\t\tans += t;\n\t\t\t\t}\n\t\t\t\tstd::rotate(c[j].begin(), c[j].begin() + 1, c[j].end());\n\t\t\t}\n\t\t\t++map[c[j]];\n\t\t}\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint vtoi(int a, int b, int c, int d){\n    int v1 = a + 1000 * b + 1000000 * c + 1000000000 * d;\n    int v2 = b + 1000 * c + 1000000 * d + 1000000000 * a;\n    int v3 = c + 1000 * d + 1000000 * a + 1000000000 * b;\n    int v4 = d + 1000 * a + 1000000 * b + 1000000000 * c;\n    return min(min(v1, v2), min(v3, v4));\n}\nint vtoi(vec v){\n    return vtoi(v[0], v[1], v[2], v[3]);\n}\nint symmetry(vec v){\n    if(v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) return 4;\n    else if(v[0] == v[2] && v[1] == v[3]) return 2;\n    else return 1;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    mat C(N, vec(4));\n    map<int, int> m;\n    REP(i, N){\n        readv(C[i]);\n        m[vtoi(C[i])] += 1;\n    }\n    \n\n    int ans = 0;\n    mat side(4, vec(4));\n    REP(i, N){\n        m[vtoi(C[i])] -= 1;\n        FOR(j, i + 1, N){\n            m[vtoi(C[j])] -= 1;\n\n            REP(r, 4){\n                int tmp = 1;\n                REP(s, 4){\n                    side[s][0] = C[i][(4 - s) % 4];\n                    side[s][1] = C[i][3 - s];\n                    side[s][2] = C[j][(1 + s + r) % 4];\n                    side[s][3] = C[j][(s + r) % 4];\n                }\n                int s0 = 0;\n                REP(s, 4){\n                    if(m[vtoi(side[s])] > 0){\n                        tmp *= m[vtoi(side[s])] * symmetry(side[s]);\n                        m[vtoi(side[s])] -= 1;\n                        s0++;\n                    }else break;\n                }\n                REP(s, s0) m[vtoi(side[s])] += 1;\n                if(s0 == 4) ans += tmp;\n            }\n\n            //cout << i << \",\" << j << \",\" << ans << endl;\n\n            m[vtoi(C[j])] += 1;\n        }\n        m[vtoi(C[i])] += 1;\n    }\n    cout << ans / 3;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define all(c) begin(c),end(c)\n\nusing ll=long long;\nusing Tile=array<int,4>;\nusing Faces=array<Tile,4>;\n\nTile normalize(Tile a)\n{\n\tTile res=a;\n\trep(i,3){\n\t\trotate(all(a)-1,end(a));\n\t\tres=min(res,a);\n\t}\n\treturn res;\n}\n\nll npr(int n,int p)\n{\n\tll res=1;\n\trep(i,p) res*=n-i;\n\treturn res;\n}\n\nll calc(const vector<Tile>& tiles,map<Tile,ll>& freq,int ti,int bi)\n{\n\tFaces faces={\n\t\tnormalize(Tile{tiles[ti][1],tiles[ti][0],tiles[bi][1],tiles[bi][0]}),\n\t\tnormalize(Tile{tiles[ti][2],tiles[ti][1],tiles[bi][0],tiles[bi][3]}),\n\t\tnormalize(Tile{tiles[ti][3],tiles[ti][2],tiles[bi][3],tiles[bi][2]}),\n\t\tnormalize(Tile{tiles[ti][0],tiles[ti][3],tiles[bi][2],tiles[bi][1]}),\n\t};\n\tmap<Tile,int> face_count;\n\tfor(auto f:faces) face_count[f]++;\n\tll res=1;\n\tfor(auto p:face_count){\n\t\tTile face=p.first;\n\t\tint n=freq[face]-(face==tiles[ti])-(face==normalize(tiles[bi]));\n\t\tres*=npr(n,p.second);\n\t}\n\tfor(Tile f:faces)\n\t\tif(f[0]==f[2]&&f[1]==f[3]){\n\t\t\tres*=2;\n\t\t\tif(f[0]==f[1])\n\t\t\t\tres*=2;\n\t\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvector<Tile> tiles;\n\t\trep(i,n){\n\t\t\tint a,b,c,d; cin>>a>>b>>c>>d;\n\t\t\ttiles.emplace_back(normalize({a,b,c,d}));\n\t\t}\n\n\t\tmap<Tile,ll> freq;\n\t\trep(i,n) freq[tiles[i]]++;\n\n\t\tll res=0;\n\t\trep(i,n) repi(j,i+1,n) rep(k,4){\n\t\t\tres+=calc(tiles,freq,i,j);\n\t\t\trotate(all(tiles[j])-1,end(tiles[j]));\n\t\t}\n\t\tcout<<res/3<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-10;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvector<int> mrot(vector<int> cs){\n\t\tvector<int> mas(4,INF<int>());\n\t\tfor(int rot:range(4)){\n\t\t\tvector<int> as(4);\n\t\t\tfor(int j:range(4)) as[j] = cs[(j+rot)%4];\n\n\t\t\tbool le = false;\n\t\t\tfor(int j:range(4)){\n\t\t\t\tif(as[j] < mas[j]){\n\t\t\t\t\tle = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(as[j] > mas[j]){\n\t\t\t\t\tle = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(le) mas = as;\n\t\t}\n\t\treturn mas;\n\t}\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tvector<vector<int>> cs(N,vector<int>(4));cin >> cs;\n\t\tfor(int i:range(N)) cs[i] = mrot(cs[i]);\n\n\t\tmap<vector<int>,int> keys;\n\t\tfor(int i:range(N)) keys[cs[i]]++;\n\n\t\tll res = 0;\n\t\tfor(int ti:range(N)){\n\t\t\tfor(int bi:range(ti+1,N))for(int rot:range(4)){\n\t\t\t\tmap<vector<int>,int> mp;\n\n\t\t\t\tvector<vector<int>> xs(4,vector<int>(4));\n\t\t\t\tfor(int i:range(4)){\n\t\t\t\t\tvector<int> as = {\n\t\t\t\t\t\tcs[ti][(i+1)%4],\n\t\t\t\t\t\tcs[ti][i],\n\t\t\t\t\t\tcs[bi][pmod(-i+rot+1,4)],\n\t\t\t\t\t\tcs[bi][pmod(-i+rot,4)],\n\t\t\t\t\t};\n\t\t\t\t\txs[i] = mrot(as);\n\t\t\t\t\tmp[mrot(as)]++;\n\t\t\t\t}\n\t\t\t\tll div = 1;\n\t\t\t\t// if(xs[0]==xs[1] && xs[1]==xs[2] && xs[2]==xs[3])div=4;\n\t\t\t\t// else if(xs[0]==xs[2] && xs[1]==xs[3])div=2;\n\n\t\t\t\tll v = 1;\n\t\t\t\tfor(pair<vector<int>,int> p : mp){\n\t\t\t\t\tint c = p.second;\n\t\t\t\t\tvector<int> as = p.first;\n\t\t\t\t\tll pat = keys[as];\n\t\t\t\t\tif(cs[ti] ==as) pat--;\n\t\t\t\t\tif(cs[bi] ==as) pat--;\n\n\t\t\t\t\tif(as[0]==as[1] && as[1] == as[2] && as[2] == as[3]){\n\t\t\t\t\t\twhile(c){\n\t\t\t\t\t\t\tv *= pat*4;\n\t\t\t\t\t\t\tpat--;c--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(as[0]==as[2] && as[1]==as[3]){\n\t\t\t\t\t\twhile(c){\n\t\t\t\t\t\t\tv *= pat*2;\n\t\t\t\t\t\t\tpat--;c--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\twhile(c){\n\t\t\t\t\t\t\tv *= pat;\n\t\t\t\t\t\t\tpat--;c--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if(v!=0)cerr << ti << \" \"<< bi <<\" \"<< v <<\" \" << div << endl;\n\t\t\t\tres += v/div;\n\t\t\t}\n\t\t}\n\n\t\tcout << res/3 << endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n\n  vector<sq> ord(24,sq(8));\n  {\n    sq a(8);\n    iota(a.begin(),a.end(),0);\n    Int x=0;\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tfor(Int k=0;k<8;k++) ord[x][a[k]]=k;\n\ta=clock(a);\n\tx++;\n      }\n      if(i==0||i==4) a=right(a);\n      else a=front(a);\n    }\n  }\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(8);\n    for(Int i=0;i<24;i++){\n      for(Int k=0;k<8;k++) b[ord[i][k]]=a[k];\n      res+=(a==b);\n      used.emplace(conv(b));\n    }\n    //cout<<res<<endl;\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nvoid norm(const C& c, C&r) {\n    r=min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    unordered_map<C, int> P;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        norm(x, x);\n        P[x] += 1;\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}}, u[l]);\n                    int opts = P[u[l]];\n                    if (u[l] == p) --opts;\n                    if (u[l] == q) --opts;\n                    for (int m = 0; m < l; m++) {\n                        if (u[m] == u[l]) --opts;\n                    }\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*rot(u[l]);\n                    }\n                }\n                ans += cur;\n            }\n        }\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nlint key(const V<>& v) {\n  lint res = 0;\n  for (int i = 0; i < 4; ++i) {\n    lint curr = 0;\n    for (int j = 0; j < 4; ++j) curr += static_cast<lint>(v[i + j & 3]) << 10 * j;\n    res = max(res, curr);\n  }\n  return res;\n}\n\nint coeff(lint key) {\n  V<> v(4);\n  for (int i = 0; i < 4; ++i) {\n    v[i] = key & 1023;\n    key >>= 10;\n  }\n  if (v[0] == v[2] and v[1] == v[3]) {\n    if (v[0] == v[1]) return 4;\n    return 2;\n  }\n  return 1;\n}\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> c; assign(c, n, 4, 0);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < 4; ++j) cin >> c[i][j];\n  map<lint, lint> mp;\n  for (int i = 0; i < n; ++i) ++mp[key(c[i])];\n  lint res = 0;\n  for (int d = 0; d < n; ++d) for (int u = d + 1; u < n; ++u) {\n    --mp[key(c[d])], --mp[key(c[u])];\n    for (int dir = 0; dir < 4; ++dir) {\n      V<lint> keys(4);\n      for (int i = 0; i < 4; ++i) keys[i] = key({c[u][dir - i & 3], c[u][dir - i - 1 & 3], c[d][i + 1 & 3], c[d][i]});\n      sort(begin(keys), end(keys));\n      int bit = 0;\n      for (int i = 0; i < 3; ++i) if (keys[i] == keys[i + 1]) bit |= 1 << i;\n      auto f = [&](const V<>& v) -> lint {\n        lint res = 1;\n        for (int i = 0; i < 4; ++i) res *= coeff(keys[i]) * (mp[keys[i]] - v[i]);\n        return res;\n      };\n      switch (bit) {\n        case 0b000: res += f({0, 0, 0, 0}); break;\n        case 0b001: res += f({0, 0, 0, 1}); break;\n        case 0b010: res += f({0, 0, 1, 0}); break;\n        case 0b011: res += f({0, 0, 1, 2}); break;\n        case 0b100: res += f({0, 1, 0, 0}); break;\n        case 0b101: res += f({0, 1, 0, 1}); break;\n        case 0b110: res += f({0, 1, 2, 0}); break;\n        case 0b111: res += f({0, 1, 2, 3}); break;\n      }\n    }\n    ++mp[key(c[d])], ++mp[key(c[u])];\n  }\n  cout << res / 3 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\npiipii c[405];\npiipii rotate(piipii x){\n    return mp(mp(x.se.se, x.fi.fi), mp(x.fi.se, x.se.fi));\n}\n\nmap<ll, int> dp;\nll get_idx(piipii x){\n    return x.fi.fi*1ll*1000*1000*1000 + x.fi.se*1ll*1000*1000 + x.se.fi*1ll*1000 + x.se.se;\n}\nvoid add(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]++;\n        p = rotate(p);\n    }   \n}\nvoid del(piipii p){\n    for(int k=0;k<4;k++){\n        dp[get_idx(p)]--;\n        p = rotate(p);\n    }\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);   \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\", &c[i].fi.fi, &c[i].fi.se, &c[i].se.fi, &c[i].se.se);\n        add(c[i]);\n    }\n    double ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(i == j) continue;\n            piipii p1 = c[i];\n            for(int k=0;k<4;k++){\n                del(p1);\n                piipii p2 = c[j];\n                for(int l=0;l<4;l++){\n                    del(p2);\n\n                    double res = 1;\n                    piipii tmp1 = mp(mp(p1.fi.se, p1.fi.fi), mp(p2.fi.se, p2.fi.fi));\n                    piipii tmp2 = mp(mp(p1.fi.se, p2.fi.fi), mp(p2.se.se, p1.se.fi));\n                    piipii tmp3 = mp(mp(p1.se.se, p1.se.fi), mp(p2.se.se, p2.se.fi));\n                    piipii tmp4 = mp(mp(p2.fi.se, p1.fi.fi), mp(p1.se.se, p2.se.fi));\n                    if(dp.count(get_idx(tmp1))){\n                        res *= dp[get_idx(tmp1)];\n                        del(tmp1);\n                    }\n                    else res = 0;\n                    if(dp.count(get_idx(tmp2))){\n                        res *= dp[get_idx(tmp2)];\n                        del(tmp2);\n                    }\n                    else res = 0;\n                    if(dp.count(get_idx(tmp3))){\n                        res *= dp[get_idx(tmp3)];\n                        del(tmp3);\n                    }\n                    else res = 0;\n                    if(dp.count(get_idx(tmp4))){\n                        res *= dp[get_idx(tmp4)];\n                        del(tmp4);\n                    }\n                    else res = 0;\n\n                    ans += res;\n\n                    if(dp.count(get_idx(tmp1))){\n                        add(tmp1);\n                    }\n                    if(dp.count(get_idx(tmp2))){\n                        add(tmp2);\n                    }\n                    if(dp.count(get_idx(tmp3))){\n                        add(tmp3);\n                    }\n                    if(dp.count(get_idx(tmp4))){\n                        add(tmp4);\n                    }\n                    \n                    add(p2);\n                    p2 = rotate(p2);\n                }\n\n                add(p1);\n                p1 = rotate(p1);\n            }\n        }\n    }\n    printf(\"%.0lf\\n\", ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint p[410][4];\nint v[2][4];\n\nmap<vector<int>, int> cnt;\nmap<vector<int>, int> qcnt;\n\nvector<int> norm(int a, int b, int c, int d){\n  vector<int> v0 = {a, b, c, d}, v1 = {b, c, d, a}, v2 = {c, d, a, b}, v3 = {d, a, b, c};\n  return min(v0, min(v1, min(v2, v3)));\n}\nvector<int> norm(int id){\n  return norm(p[id][0], p[id][1], p[id][2], p[id][3]);\n}\n\nint main(){\n  int N; scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < 4; j++) scanf(\"%d\", &p[i][j]);\n    cnt[norm(i)]++;\n  }\n\n  long long ans = 0;\n\n  for(int A = 0; A < N; A++){ // dir = 0\n    for(int i = 0; i < 4; i++) v[0][i] = p[A][i];\n    cnt[norm(A)]--;\n\n    for(int B = 0; B < N; B++){\n      if(A == B) continue;\n      cnt[norm(B)]--;\n\n      for(int BD = 0; BD < 4; BD++){\n        for(int i = 0; i < 4; i++) v[1][i] = p[B][(BD + i) % 4];\n\n        qcnt.clear();\n\n        qcnt[norm(v[0][3], v[0][2], v[1][2], v[1][1])]++;\n        qcnt[norm(v[0][2], v[0][1], v[1][3], v[1][2])]++;\n        qcnt[norm(v[0][1], v[0][0], v[1][0], v[1][3])]++;\n        qcnt[norm(v[0][0], v[0][3], v[1][1], v[1][0])]++;\n\n        int r = 1;\n\n        for(auto &pp : qcnt){\n          int c = pp.second, cc = cnt[pp.first];\n          int m = 1;\n\n          if(pp.first[0] == pp.first[1] && pp.first[1] == pp.first[2] && pp.first[2] == pp.first[3]) m = 4;\n          else if(pp.first[0] == pp.first[2] && pp.first[1] == pp.first[3]) m = 2;\n\n          for(int j = 0; j < c; j++) r *= (cc - j) * m;\n        }\n\n        ans += r;\n      }\n\n      cnt[norm(B)]++;\n    }\n    cnt[norm(A)]++;\n  }\n\n  printf(\"%lld\\n\", ans / 6);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define SIZE 200005\n\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\nll ans;\nmap<pair<pii,pii> ,ll> hoge;\nvoid minu(int x,int y,int z,int w){\n\t\n\thoge[mp(mp(x,y),mp(z,w))]--;\n\thoge[mp(mp(y,z),mp(w,x))]--;\n\thoge[mp(mp(z,w),mp(x,y))]--;\n\thoge[mp(mp(w,x),mp(y,z))]--;\n}\nvoid plu(int x,int y,int z,int w){\n\t\n\t\thoge[mp(mp(x,y),mp(z,w))]++;\n\t\thoge[mp(mp(y,z),mp(w,x))]++;\n\t\thoge[mp(mp(z,w),mp(x,y))]++;\n\t\thoge[mp(mp(w,x),mp(y,z))]++;\n}\nvoid ccalc(int a,int b,int c,int d,int p,int q,int r,int s){\n\tll cal=(ll)1;\n\tvector<pair<pair<pii,pii>,int> >temp;\n\tcal*=max((ll)0,hoge[mp(mp(a,d),mp(q,p))]);\n\tminu(a,d,q,p);\n\tcal*=max((ll)0,hoge[mp(mp(d,c),mp(r,q))]);\n\tminu(d,c,r,q);\n\tcal*=max((ll)0,hoge[mp(mp(c,b),mp(s,r))]);\n\tminu(c,b,s,r);\n\tcal*=max((ll)0,hoge[mp(mp(b,a),mp(p,s))]);\n\tminu(b,a,p,s);\n\tans+=cal;\n\tplu(a,d,q,p);\n\tplu(d,c,r,q);\n\tplu(c,b,s,r);\n\tplu(b,a,p,s);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pair<pii,pii> > data;\n\tint x,y,z,w;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x>>y>>z>>w;\n\t\thoge[mp(mp(x,y),mp(z,w))]++;\n\t\thoge[mp(mp(y,z),mp(w,x))]++;\n\t\thoge[mp(mp(z,w),mp(x,y))]++;\n\t\thoge[mp(mp(w,x),mp(y,z))]++;\n\t\tdata.pb(mp(mp(x,y),mp(z,w)));\n\t}\n\tans=0;\n\t\n\t//map<pair<pii,pii> ,ll> temp;\n\tfor(int i=0;i<n;i++){\n\t\t//temp=hoge;\n\t\tint a=data[i].first.first,b=data[i].first.second,c=data[i].second.first,d=data[i].second.second;\n\t\tminu(a,b,c,d);\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tint p=data[j].first.first,q=data[j].first.second,r=data[j].second.first,s=data[j].second.second;\n\t\t\tminu(p,q,r,s);\n\n\t\t\tccalc(a,b,c,d,p,q,r,s);\n\t\t//cout<<hoge[mp(mp(0,0),mp(0,0))]<<endl;\n\t\t\tccalc(a,b,c,d,q,r,s,p);\n\t\t\tccalc(a,b,c,d,r,s,p,q);\n\t\t\tccalc(a,b,c,d,s,p,q,r);\n\t\t\t//cout<<ans<<endl;\t\n\t\t\tplu(p,q,r,s);\n\t\t\t//cout<<hoge[mp(mp(0,0),mp(0,0))]<<endl;\n\t\t}\n\t\t//cout<<ans<<endl;\n\t\t//cout<<hoge\n\t\t//hoge=temp;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include<bits/stdc++.h>\nusing namespace std;\n# define lowbit(x) ((x)&(-x))\n# define pi acos(-1.0)\n# define eps 1e-8\n# define MOD 1000000007\n# define INF 1000000000\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(register int i=a; i<=n; ++i)\n# define FDR(i,a,n) for(register int i=a; i>=n; --i)\n# define AU(i,x)    for(auto i=x.begin(); i!=x.end(); ++i)\n# define ALL(A) A.begin(),A.end()\n# define bug puts(\"H\");\n# define lch p<<1,l,mid\n# define rch p<<1|1,mid+1,r\n# define mp make_pair\n# define pb push_back\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n# pragma comment(linker, \"/STACK:1024000000,1024000000\")\ntypedef long long LL;\ninline char nc(){\n    static char buf[1000000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int Scan(){\n    char ch=nc();int sum=0, f=1;\n    if (ch=='-') f=-1, ch=nc();\n    while(!(ch>='0'&&ch<='9'))ch=nc();\n    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();\n    return sum*f;\n}\nint ps4[4][2]={0,1,0,-1,1,0,-1,0};\nint ps8[8][2]={0,1,0,-1,1,0,-1,0,1,1,1,-1,-1,-1,-1,1};\ninline int min(int a,int b,int c) {return min(a,min(b,c));}\ninline int max(int a,int b,int c) {return max(a,max(b,c));}\ninline int min(int a,int b,int c,int d){return min(min(a,b,c),d);}\ninline int max(int a,int b,int c,int d){return max(max(a,b,c),d);}\n//struct Edge{int p, next, w;}edge[maxn];\n//inline add_edge(int u, int v, int w){edge[cnt]=Edge{v,head[u],w}; head[u]=cnt++;}\nconst int N=405;\n///Code begin..................................................................\n\nstruct Node{int a[5];}node[N];\nunordered_map<LL,int>vis;\nNode tmp, b[5];\nint F[5];\nLL ans=0;\n\nLL _hash(Node a){\n    LL tmp=0;\n    FOR(i,0,3) tmp*=1000, tmp+=a.a[i];\n    return tmp;\n}\nNode Swap(Node a){\n    Node b;\n    FOR(i,0,3) b.a[i]=a.a[3-i];\n    return b;\n}\nint find(int x){return F[x]<0?x:F[x]=find(F[x]);}\nint Check(Node c1, Node c2){\n    int cnt=0;\n    FOR(i,0,3) {\n        if (c1.a[0]==c2.a[i]&&c1.a[1]==c2.a[(i+1)%4]&&c1.a[2]==c2.a[(i+2)%4]&&c1.a[3]==c2.a[(i+3)%4])\n            ++cnt;\n    }\n    return cnt;\n}\nLL Cal(int x){\n    mem(F,-1);\n    FOR(i,0,3) FOR(j,i+1,3) {\n        if (Check(b[i],b[j])) {\n            int u=find(i), v=find(j);\n            if (u!=v) F[u]+=F[v], F[v]=u;\n        }\n    }\n    LL tmp=1;\n    FOR(i,0,3) {\n        if (F[i]>0) continue;\n        int m=vis[_hash(b[i])]-Check(node[x],b[i]), n=Check(b[i],b[i]);\n        LL now=1;\n        FOR(j,1,-F[i]) {\n            if (m<0) {now=0; break;}\n            now*=m;\n            m-=n;\n        }\n        tmp*=now;\n    }\n    return tmp;\n}\nint main ()\n{\n    int n;\n    scanf(\"%d\",&n);\n    FOR(i,1,n) {\n        scanf(\"%d%d%d%d\",&node[i].a[0],&node[i].a[1],&node[i].a[2],&node[i].a[3]);\n        node[i]=Swap(node[i]);\n        FOR(j,1,i-1) FOR(k,0,3) {\n            FOR(l,0,3) tmp.a[l]=node[j].a[(l+k)%4];\n            FOR(l,0,3) {\n                b[l].a[0]=node[i].a[l]; b[l].a[1]=node[i].a[(l+1)%4];\n                b[l].a[3]=tmp.a[l]; b[l].a[2]=tmp.a[(l+1)%4];\n            }\n            ans+=Cal(j);\n        }\n        node[i]=Swap(node[i]);\n        FOR(j,0,3) {\n            FOR(k,0,3) tmp.a[k]=node[i].a[(k+j)%4];\n            ++vis[_hash(tmp)];\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nvi normarize(const vi &v)\n{\n    vector<vi> r(4);\n    rep(i,4)\n    {\n        vi t(4);\n        rep(j,4) t[j]=v[(i+j)%4];\n        r[i]=t;\n    }\n    sort(all(r));\n    return r[0];\n}\n\ninline ll DIM(const vi &v)\n{\n    if(v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) return 4;\n    if(v[0]==v[2] && v[1]==v[3]) return 2;\n    return 1;\n}\n\nint main()\n{\n    ll P[401][5]={0};\n    for(int i=1; i<=400; ++i)\n    {\n        P[i][1]=i;\n        for(int j=2; j<=min(4,i); ++j) P[i][j]=P[i][j-1]*(i-j+1);\n    }\n\n    ll POW[5][5];\n    rep(i,5)\n    {\n        POW[i][0]=1;\n        for(int j=1; j<5; ++j) POW[i][j]=POW[i][j-1]*i;\n    }\n\n    int n;\n    scanf(\" %d\", &n);\n\n    vector<vi> c(n,vi(4));\n    rep(i,n)rep(j,4) scanf(\" %d\", &c[i][j]);\n\n    map<vi,int> ct;\n    rep(i,n)\n    {\n        c[i]=normarize(c[i]);\n        if(ct.find(c[i])==ct.end()) ct[c[i]]=1;\n        else ++ct[c[i]];\n    }\n\n    ll ans=0;\n    // 上面i, 下面j, 下面の向きを設定\n    rep(i,n)rep(j,i)rep(k,4)\n    {\n        vi u(4);\n        rep(x,4) u[x]=c[j][(k+x)%4];\n        swap(u[1],u[3]);\n\n        vector<vi> sides(4);\n        rep(x,4)\n        {\n            vi t(4);\n            t[0]=c[i][(x+1)%4];\n            t[1]=c[i][x];\n            t[2]=u[x];\n            t[3]=u[(x+1)%4];\n            sides[x]=normarize(t);\n        }\n        sort(all(sides));\n\n        ll add=1;\n        int idx=0, st=0;\n        while(1)\n        {\n            while(idx<4 && sides[st]==sides[idx]) ++idx;\n            vi key=sides[st];\n            int value=idx-st;\n\n            // 使ってないタイルのうち当てはめられる個数\n            int num=ct[key];\n            if(c[i]==key) --num;\n            if(c[j]==key) --num;\n\n            if(num<value)\n            {\n                add=0;\n                break;\n            }\n\n            // 選び方、向き、位置\n            add*=P[num][value]*POW[DIM(key)][value];\n\n            if(idx==4) break;\n            st=idx;\n        }\n        ans+=add;\n    }\n\n    // 向かい合う面の個数ぶん重複する\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include <utility>\n#include <cstdio>\n#include<algorithm>\n#include<queue>\n#define ll  long long\n\nusing namespace std;\n\tint n;\nvoid rotate(vector<int> & vec){\n    vector<int> tmp(4);\n    int minind = min_element(vec.begin(), vec.end() ) - vec.begin();\n    for(int i=3; i>0; i--){\n\tif(vec[i]==vec[minind]){\n\t    minind=i;\n\t}else{\n\t    break;\n\t}\n    }\n    for(int i=0; i<4; i++){\n\ttmp[i] = vec[(i+minind)%4];\n    }\n    vec=tmp;\n}\nvoid rot1(vector<int> & vec){\n    int tmp = vec[0];\n    for(int i=0; i<4; i++){\n\tvec[i] = vec[i+1];\n    }\n    vec[3]=tmp;\n}\nint cntsq(vector<vector<int> > & c, vector<int>  & sq, int st, int sk){\n    int res=0;\n    for(int i=st; i<n; i++)\n\tif(i!=sk && c[i]==sq)res++;\n    return res;\n}\nint sym(vector<int> v){\n    if(v[0]!=v[2] || v[1]!=v[3])return 1;\n    if(v[0]!=v[1] || v[2]!=v[3])return 2;\n    return 4;\n}\nint main(){\n    cin>>n;\n    vector<vector<int> > c(n, vector<int>(4));\n    for(int i=0; i<n; i++){\n\tfor(int j=0; j<4; j++ )cin>>c[i][j];\n\trotate(c[i]);\n    }\n    ll res = 0;\n    for(int f = 0; f<n; f++){\n\tfor(int s=f+1; s<n; s++){\n\t    for(int r=0; r<4; r++){\n\t\tunsigned ll mu=1;\n\t\tmap<vector<int>, int> occ; occ.clear();\n\t\tfor(int i=0; i<4; i++){\n\t\t    vector<int> tmp(4);\n\t\t    tmp[1] = c[f][i]; tmp[0] = c[f][(i+1)%4];\n\t\t    tmp[3] = c[s][3-(i+1)%4]; tmp[2] = c[s][3-i];\n\t\t    rotate(tmp);\n\t\t    int x = cntsq(c, tmp, f+1, s);\n\t\t    if(x)\n\t\t\tmu*=1LL*(x-occ[tmp])*sym(tmp);\n\t\t    else {mu=0; break; }\n//cout<<f<<\" \"<<s<<\" \"<<r<<\" \"<<i<<\" \"<<cntsq(c, tmp, f+1, s)<<\" \"<<mu<<\"\\n\";\n//cout<<tmp[0]<<tmp[1]<<tmp[2]<<tmp[3]<<\"\\n\";\n\t\t    occ[tmp]++;\n\t\t}\n\t\tres+=mu;\n\t\trot1(c[s]);\n//\t\tcout<<c[s][0]<<c[s][1]<<c[s][2]<<c[s][3]<<\"\\n\";\n\t    }\n\t}\n    }\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<pii,pii> sta;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=405;\n\nmap<sta,int> cnt;\nint a[N],b[N],c[N],d[N],n;\nsta v[N][4];\nll ans;\n\nil sta getsta(const int &a,const int &b,const int &c,const int &d){\n\treturn mp(mp(a,b),mp(c,d));\n}\n\nil sta rev(const sta &a){\n\treturn mp(mp(a.Y.Y,a.Y.X),mp(a.X.Y,a.X.X));\n}\n\nil bool same(const sta &a,const sta &b){\n\tif(a==b) return true;\n\tif(a==mp(mp(b.X.Y,b.Y.X),mp(b.Y.Y,b.X.X))) return true;\n\tif(a==mp(b.Y,b.X)) return true;\n\tif(a==mp(mp(b.Y.Y,b.X.X),mp(b.X.Y,b.Y.X))) return true;\n\treturn false;\n}\n\nil ll P(int n,int k){\n\tll ans=1;\n\trep0(i,k) ans*=n-i;\n\treturn ans;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n\t\t++cnt[v[i][0]=getsta(a[i],b[i],c[i],d[i])];\n\t\t++cnt[v[i][1]=getsta(b[i],c[i],d[i],a[i])];\n\t\t++cnt[v[i][2]=getsta(c[i],d[i],a[i],b[i])];\n\t\t++cnt[v[i][3]=getsta(d[i],a[i],b[i],c[i])];\n\t}\n\trep(i,1,n){\n\t\trep0(c,4) --cnt[v[i][c]];\n\t\tsta s1=v[i][0],s2;\n\t\trep(j,i+1,n){\n\t\t\trep0(c,4) --cnt[v[j][c]];\n\t\t\trep0(c,4){\n\t\t\t\ts2=rev(v[j][c]);\n\t\t\t\tsta v[4]={getsta(s1.X.Y,s1.X.X,s2.X.X,s2.X.Y),getsta(s1.Y.X,s1.X.Y,s2.X.Y,s2.Y.X),getsta(s1.Y.Y,s1.Y.X,s2.Y.X,s2.Y.Y),getsta(s1.X.X,s1.Y.Y,s2.Y.Y,s2.X.X)};\n\t\t\t\tint num[4]={1,1,1,1};\n\t\t\t\tper(p1,3,1){\n\t\t\t\t\tper(p2,p1-1,0){\n\t\t\t\t\t\tif(!same(v[p2],v[p1])) continue;\n\t\t\t\t\t\tnum[p2]+=num[p1];\n\t\t\t\t\t\tnum[p1]=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll dt=1;\n\t\t\t\trep0(p,4){\n\t\t\t\t\tif(!num[p]) continue;\n\t\t\t\t\tint t=cnt[v[p]];\n\t\t\t\t\tif(v[p].X==v[p].Y){\n\t\t\t\t\t\tif(v[p].X.X==v[p].X.Y){\n\t\t\t\t\t\t\t//0 0 0 0\n\t\t\t\t\t\t\tt/=4;\n\t\t\t\t\t\t\tif(t<num[p]){dt=0;break;}\n\t\t\t\t\t\t\tdt*=P(t,num[p])*(1ll<<2*num[p]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//0 1 0 1\n\t\t\t\t\t\t\tt/=2;\n\t\t\t\t\t\t\tif(t<num[p]){dt=0;break;}\n\t\t\t\t\t\t\tdt*=P(t,num[p])*(1ll<<num[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(t<num[p]){dt=0;break;}\n\t\t\t\t\t\tdt*=P(t,num[p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=dt;\n\t\t\t}\n\t\t\trep0(c,4) ++cnt[v[j][c]];\n\t\t}\n\t\trep0(c,4) ++cnt[v[i][c]];\n\t}\n\tassert(ans%3==0);\n\t//cerr<<\"  ans=\"<<ans<<endl;\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int Maxn = 410;\n#define For( i, j, k ) for( int i = j; i <= k; ++i )\nusing std::cin;\nusing std::cout;\nstruct Node\n{\n\tint col[ 4 ];\n\tfriend bool operator < ( const Node &a, const Node &b )\n\t{\n\t\tFor( i, 0, 3 )\n\t\t\tif( a.col[ i ] != b.col[ i ] )\n\t\t\t\treturn a.col[ i ] < b.col[ i ];\n\t\treturn 0;\n }\n}elvahs[ 410 ];\nNode nxt( Node x )\n{\n\treturn ( Node ) { x.col[ 1 ], x.col[ 2 ], x.col[ 3 ], x.col[ 0 ] }; \n}\nstd::map < Node, int > mp;\ninline void insert( Node a, int x )\n{\n\tfor( int i = 0; i < 4; ++i, a = nxt( a ) )\n\t\tmp[ a ] += x;\n}\nint main( )\n{\n\tstd::ios::sync_with_stdio( false );\n\tint n;\n\tlong long ans = 0;\n\tcin >> n;\n\tFor( i, 1, n )\n\t\tcin >> elvahs[ i ].col[ 0 ] >> elvahs[ i ].col[ 1 ] >> elvahs[ i ].col[ 2 ] >> elvahs[ i ].col[ 3 ],\n\t\tinsert( elvahs[ i ], 1 );\n\tFor( i, 1, n )\n\t{\n\t\tinsert( elvahs[ i ], -1 );\n\t\tFor( j, i + 1, n )\n\t\t{\n\t\t\tinsert( elvahs[ j ], -1 );\n\t\t\tFor( t, 0, 3 )\n\t\t\t{\n\t\t\t\tNode a1 = Node{ elvahs[ j ].col[ 3 ], elvahs[ i ].col[ 0 ], elvahs[ i ].col[ 3 ], elvahs[ j ].col[ 0 ] },\n\t\t\t\ta2 = Node{ elvahs[ j ].col[ 0 ], elvahs[ i ].col[ 3 ], elvahs[ i ].col[ 2 ], elvahs[ j ].col[ 1 ] },\n\t\t\t a3 = Node{ elvahs[ j ].col[ 1 ], elvahs[ i ].col[ 2 ], elvahs[ i ].col[ 1 ], elvahs[ j ].col[ 2 ] },\n\t\t\t\ta4 = Node{ elvahs[ j ].col[ 2 ], elvahs[ i ].col[ 1 ], elvahs[ i ].col[ 0 ], elvahs[ j ].col[ 3 ] };\n\t\t\t\telvahs[ j ] = nxt( elvahs[ j ] );\n\t\t\t\tif( !mp[ a1 ] || !mp[ a2 ] || !mp[ a3 ] || !mp[ a4 ] )\n\t\t\t\t\tcontinue;\n    int res = 1;\n\t\t\t\tres *= mp[ a1 ];insert( a1, -1 );\n\t\t\t\tres *= mp[ a2 ];insert( a2, -1 );\n\t\t\t\tres *= mp[ a3 ];insert( a3, -1 );\n\t\t\t\tres *= mp[ a4 ];\n\t\t\t\tinsert( a1, 1 ); insert( a2, 1 ); insert( a3, 1 );\n\t\t\t\tans += res;\n\t\t\t}\n\t\t\tinsert( elvahs[ j ], 1 );\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<(b); i++)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); i--)\n#define debug(x) cout << #x << \" => \" << x << endl\nusing namespace std;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> pii;\n\n#define pb push_back\ntypedef vector<int> vi;\n\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 7 + 400;\n///----------------------------------------------\n//int qpow(int\n\nint col[10];\nvoid rote() {\n    int tmp[4]; rep(i,0,4) tmp[i]=col[i];\n    rep(beg,1,4) {\n        int i; for (i=0; i<3&&tmp[(beg+i)%4]==col[i]; ) i++;\n        if(tmp[(beg+i)%4]<col[i]) {\n            rep(i,0,4) col[i]=tmp[(beg+i)%4];\n        }\n    }\n}\n\nconst int B[4]={1000000000, 1000000, 1000, 1};\nll getval() {\n    ll val=0;\n    rep(i,0,4) val+=1ll*col[i]*B[i];\n    return val;\n}\n\nbool same() {\n    rep(i,1,4) if (col[i]!=col[0]) return false;\n    return true;\n}\nbool same2() {\n    return col[0]==col[2]&&col[1]==col[3];\n}\n\n\nmap<ll,int> num;\nint tab[MAX_N][4];\nint main() {\n\n    ///freopen ( \"xx.in\" , \"r\" , stdin );\n\n    ///init\n    ///read\n    int n; cin>>n;\n    rep(i,0,n) {\n        rep(j,0,4) scanf(\"%d\",&col[j]);\n        rep(j,0,4) tab[i][j]=col[j];\n        rote();\n        num[getval()]++;\n\n    }\n\n    ///work\n    int ans=0;\n    rep(i,0,n) {\n        rep(j,0,4) col[j]=tab[i][j]; rote();\n        num[getval()]--;\n        rep(j,i+1,n) rep(off,0,4) {\n\n            rep(k,0,4) col[k]=tab[j][k]; rote();\n            num[getval()]--;\n\n            int tmp=1;\n\n            ///front\n            col[0]=tab[i][1]; col[1]=tab[j][(off+0)%4];\n            col[3]=tab[i][2]; col[2]=tab[j][(off+3)%4]; rote();\n            ll val1 = getval();\n            ll tmp1 = same() ? 4 : same2() ? 2 : 1; //tmp1=1;\n            tmp=1ll*tmp*(num[val1]--)%MOD*tmp1%MOD;\n            //debug(num[val1]);\n\n            ///top\n            col[0]=tab[i][0]; col[1]=tab[j][(off+1)%4];\n            col[3]=tab[i][1]; col[2]=tab[j][(off+0)%4]; rote();\n            ll val2 = getval();\n            ll tmp2 = same() ? 4 : same2() ? 2 : 1; //tmp2=1;\n            tmp=1ll*tmp*(num[val2]--)%MOD*tmp2%MOD;\n            //debug(num[val2]);\n\n            ///buttom\n            col[0]=tab[i][2]; col[1]=tab[j][(off+3)%4];\n            col[3]=tab[i][3]; col[2]=tab[j][(off+2)%4]; rote();\n            ll val3 = getval();\n            ll tmp3 = same() ? 4 : same2() ? 2 : 1; //tmp3=1;\n            tmp=1ll*tmp*(num[val3]--)%MOD*tmp3%MOD;\n            //debug(num[val3]);\n\n            ///back\n            col[0]=tab[i][3]; col[1]=tab[j][(off+2)%4];\n            col[3]=tab[i][0]; col[2]=tab[j][(off+1)%4]; rote();\n            ll val4 = getval();\n            ll tmp4 = same() ? 4 : same2() ? 2 : 1; //tmp4=1;\n            tmp=1ll*tmp*(num[val4]--)%MOD*tmp4%MOD;\n            //debug(num[val4]);\n\n            //debug(tmp);\n            ans=(ans+tmp)%MOD;\n            num[val1]++;\n            num[val2]++;\n            num[val3]++;\n            num[val4]++;\n            rep(k,0,4) col[k]=tab[j][k]; rote();\n            num[getval()]++;\n       }\n    }\n\n    ///print\n    cout << ans << endl;\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops,Ofast\")\n#pragma GCC target(\"avx,sse,sse2,ssse3,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<18;\ntypedef short str __attribute__(( vector_size(4*sizeof(short)) ));\nalignas(int) int tr[1660][1010], sz = 1, cnt[1660], t[1660];\n#define INLINE inline __attribute(( always_inline ))\nstr m[4] = {{0, 1, 2, 3}, {1, 2, 3, 0}, {2, 3, 0, 1}, {3, 0, 1, 2}};\nINLINE void nw(str a) {\n\tint p = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(!tr[p][a[i]]) tr[p][a[i]] = sz++;\n\t\tp = tr[p][a[i]];\n\t}\n\tt[p] = 1;\n}\n\nINLINE int count(str a, int s = 0) {\n\ta = __builtin_shuffle(a, m[s]);\n\tint p = 0;\n\tp = tr[p][a[0]];\n\tp = tr[p][a[1]];\n\tp = tr[p][a[2]];\n\tp = tr[p][a[3]];\n\treturn cnt[p];\n}\n\nINLINE void add(str a, int x, int s = 0) {\n\ta = __builtin_shuffle(a, m[s]);\n\tint p = 0;\n\tp = tr[p][a[0]];\n\tp = tr[p][a[1]];\n\tp = tr[p][a[2]];\n\tp = tr[p][a[3]];\n\tif(t[p]) cnt[p] += x;\n}\nint n;\nstr x[maxn];\nll ans = 0;\n#define shi(x, y) (((x)>>(2*(y)))&3)\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\t#pragma GCC ivdep\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < 4; j++) cin >> x[i][j], x[i][j] = 2*x[i][j] - (i&1);\n\t\t#pragma GCC ivdep\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tadd(x[j], -1);\n\t\t    #pragma GCC ivdep\n\t\t\tfor(int sD = 0; sD < 4; sD++) {\n\t\t\t\tstr l = {x[j][(sD+1)&3], x[i][0], x[i][3], x[j][(sD+2)&3]};\n\t\t\t\tstr r = {x[i][1], x[j][sD&3], x[j][(sD+3)&3], x[i][2]};\n\t\t\t\tstr f = {x[j][(sD+1)&3], x[j][sD&3], x[i][1], x[i][0]};\n\t\t\t\tstr b = {x[i][3], x[i][2], x[j][(sD+3)&3], x[j][(sD+2)&3]};\n\n\t\t\t\t#pragma GCC ivdep\n\t\t\t\tfor(int s = 0; s < 256; s++) {\n\t\t\t\t\tll cur = 1;\n\t\t\t\t\t\n\t\t\t\t\tcur *= count(l, shi(s, 0)), add(l, -1, shi(s, 0));\n\t\t\t\t\tcur *= count(r, shi(s, 1)), add(r, -1, shi(s, 1));\n\t\t\t\t\tcur *= count(f, shi(s, 2)), add(f, -1, shi(s, 2));\n\t\t\t\t\tcur *= count(b, shi(s, 3)), add(b, -1, shi(s, 3));\n\t\t\t\t\t\n\t\t\t\t\tans += cur;\n\t\t\t\t\t\n\t\t\t\t\tadd(l, 1, shi(s, 0));\n\t\t\t\t\tadd(r, 1, shi(s, 1));\n\t\t\t\t\tadd(f, 1, shi(s, 2));\n\t\t\t\t\tadd(b, 1, shi(s, 3));\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(x[j], 1);\n\t\t}\n\t\tnw(x[i]);\n\t\tadd(x[i], 1);\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)^hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n    d[i]=v;\n  }\n  sort(d.begin(),d.end());\n  d.erase(unique(d.begin(),d.end()),d.end());\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)d.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(d[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      if(used.count(P(d[i],b[j]))) continue;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n      \n      Int res=cnt[d[i]];\n      add(d[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);            \n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(d[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\n#define MAXN 600\n\ntypedef array<short,4> tile;\n\nint n;\ntile a[MAXN];\nlong d[MAXN];\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%hd\", &a[i][j]);\n\treturn 1;\n}\n\nvoid init() {\n}\n\ntile rotate(const tile &x, int k=1) {\n\ttile y;\n\tfor (int i=0; i<4; i++) y[(i+k) % 4] = x[i];\n\treturn y;\n}\n\ntile normalize(const tile &x) {\n\ttile z=x;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y<z) z=y;\n\t}\n\treturn z;\n}\n\nint mirror(const tile &x) {\n\tint r = 1;\n\tfor (int i=1; i<4; i++) {\n\t\ttile y=rotate(x, i);\n\t\tif (y==x) r++;\n\t}\n\treturn r;\n}\n\ntile get_face(const tile &u, const tile &d, int x, int y) {\n\treturn normalize({u[x], u[y], d[3-y], d[3-x]});\n}\n\n//use id to speed up\nlong id(const tile &x) {\n\treturn x[0]*1000000000L + x[1]*1000000L + x[2]*1000L + x[3];\n}\n\nlong solve() {\n\tmap<long,long> ct;\n\tmap<long,long> mi;\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] = normalize(a[i]);\n\t\td[i] = id(a[i]);\n\t\tct[d[i]]++;\n\t\tmi[d[i]] = mirror(a[i]);\n\t}\n\tlong ans = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tct[d[i]]--;\n\t\tfor (int j=i+1; j<n; j++) {\n\t\t\tct[d[j]]--;\n\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\ttile d=a[i], u=rotate(a[j], k);\n\t\t\t\ttile f[4];\n\t\t\t\tlong g[4];\n\t\t\t\tlong r = 1;\n\t\t\t\tfor (int t=0; t<4; t++) {\n\t\t\t\t\tf[t] = get_face(u, d, t, (t+3)%4);\n\t\t\t\t\tg[t] = id(f[t]);\n\t\t\t\t\tr *= mi[g[t]] * ct[g[t]]--;\n\t\t\t\t}\n\t\t\t\t//printf(\"* %d %d %d: %ld\\n\", i, j, k, r);\n\t\t\t\tans += r;\n\t\t\t\tfor (int t=0; t<4; t++) ct[g[t]]++;\n\t\t\t}\n\t\t\tct[d[j]]++;\n\t\t}\n\t\tct[d[i]]++;\n\t}\n\treturn ans/3;\n}\n\nvoid output(long ans) {\n\tprintf(\"%ld\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<vector<lli> > c;\nmap<lli,lli> m;\nlli ans = 0;\nlli to_lli(vector<lli>& v){\n    lli ret = 0;\n    for(lli i = 0;i < v.size();i++){\n        ret *= 1000;\n        ret += v[i];\n    }\n    return ret;\n}\nvoid rotate(vector<lli>& v){\n    for(lli i = 0;i < 3;i++) swap(v[i],v[i+1]);\n    //for(lli k = 0;k < v.size();k++) cout << v[k] << \" \";cout << endl;\n}\nvoid rotate(lli& x){\n    x = x / 1000 + (x % 1000) * 1000000000;\n}\nvoid recover(vector<lli>& v){\n    lli x = to_lli(v);\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]++;\n    }\n}\nvoid dec(vector<lli>& v){\n    lli x = to_lli(v);\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]--;\n    }\n}\nvoid dec(lli& x){\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]--;\n    }\n}\nvoid inc(vector<lli>& v){\n    lli x = to_lli(v);\n    for(lli i = 0;i < 4;i++){\n        rotate(x);\n        m[x]++;\n    }\n}\nlli select(vector<lli>& v){\n    lli x = to_lli(v);\n    lli ret = m[x];\n    dec(x);\n    return ret > 0 ? ret : 0;\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin >> n;\n    c = vector<vector<lli> > (n,vector<lli> (4));\n    for(lli i = 0;i < n;i++){\n        cin >> c[i][0] >> c[i][1] >> c[i][2] >> c[i][3];\n        lli x = to_lli(c[i]);\n        for(lli j = 0;j < 4;j++){\n            rotate(x);\n            m[x]++;\n        }\n    }\n    for(lli i = 0;i < n;i++){\n        dec(c[i]);\n        for(lli j = i + 1;j < n;j++){\n            dec(c[j]);\n            for(lli k = 0;k < 4;k++){\n                rotate(c[j]);\n                lli adder = 1;\n                vector<lli> v1{c[i][1],c[i][0],c[j][1],c[j][0]};\n                vector<lli> v2{c[i][0],c[i][3],c[j][2],c[j][1]};\n                vector<lli> v3{c[i][3],c[i][2],c[j][3],c[j][2]};\n                vector<lli> v4{c[i][2],c[i][1],c[j][0],c[j][3]};\n                adder *= select(v1);\n                adder *= select(v2);\n                adder *= select(v3);\n                adder *= select(v4);\n                ans += adder;\n                recover(v1);\n                recover(v2);\n                recover(v3);\n                recover(v4);\n            }\n            inc(c[j]);\n        }\n        inc(c[i]);\n    }\n    cout << ans/3 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile a, tile b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) {return a.color[i] < b.color[i];}\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) {tmp.color[i] = t.color[i];}\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) t = comp;\n    for (int j = 0; j < 4; ++j) {tmp.color[j] = comp.color[j];}\n  }\n}\n\nbool same(tile a, tile b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= (a.color[i] == b.color[i]);\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  rep(i,N) {\n    rep(j,4) {\n      cin >> t[i].color[j];\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {regulation(t[i]);}\n  sort(t, t+N, comp_tile);\n\n\n  ull ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) {top.color[k] = t[i].color[k];}\n        for (int k = 0; k < 4; ++k) {bottom.color[k] = t[j].color[k];}\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) {tmp1.color[l] = bottom.color[l];}\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) {regulation(sides[l]);}\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) {tmp.color[n] = sides[m].color[n];}\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) ++symmetry_count[m];\n              for (int l = 0; l < 4; ++l) {tmp.color[l] = cmp.color[l];}\n            }\n          }\n\n          ull tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) {\n              if (same(sides[n],sides[m])) ++x;\n            }\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= (match_count[m] - x);\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define lowbit(i) i&-i\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\tull ans=0; For(i,0,5)ans=ans<<15^rand(); return ans;\n}\nconst int N=405;\nint a[N][4],ycl[4];\nll yc[N];\nunordered_map<ll,int> to,t;\nll chu(int a[4]){\n\tll ans=0; \n\tvector<int> v;\n\tFor(i,0,3)v.pb(a[i]);\n\tFor(i,1,3){\n\t\tvector<int> b;\n\t\tFor(j,0,3)b.pb(a[(i+j)%4]);\n\t\tif(b<v)v=b;\n\t}\n\t//For(i,0,3)cout<<a[i]<<\" \"; puts(\"\"); for(auto i:v)wri(i); puts(\"fjz\");\n\tFor(i,0,3)ans+=(ll)v[i]*ycl[i];\n\treturn ans;\n}\nll c(int a,int b){\n\tll ans=1; \n\tfor(int i=a;i>a-b;i--)ans*=i;\n\t//For(i,2,b)ans/=i;\n\treturn ans;\n}\nint get(ll x){\n\tauto it=to.find(x);\n\tif(it!=to.end())return it->second; else return 0;\n}\nvoid add(int i,int y){\n\tto[yc[i]]+=y;\n}\nint main(){\n\tint n=read();\n\tFor(i,ycl[0]=1,3)ycl[i]=ycl[i-1]*1000;\n\tFor(i,1,n){\n\t\tFor(j,0,3){a[i][j]=read();} yc[i]=chu(a[i]); add(i,1);\n\t}\n\tll ans=0;\n\tFor(i,1,n){\n\t\tadd(i,-1);\n\t\tFor(j,i+1,n){\n\t\t\tadd(j,-1);\n\t\t\tFor(k,0,3){\n\t\t\t\tint q[4],B[4];\n\t\t\t\tFor(l,0,3)B[l]=a[j][3^((l+k)%4)];\n\t\t\t\tt.clear();\n\t\t\t\tll sum=1;\n\t\t\t\tFor(l,0,3){\n\t\t\t\t\tq[3]=a[i][l]; q[2]=a[i][(l+1)%4];\n\t\t\t\t\tq[0]=B[l]; q[1]=B[(l+1)%4];\n\t\t\t\t\t/*if(i==1&&j==5&&k==2){\n\t\t\t\t\t\tFor(o,0,3)wri(q[o]); puts(\"\");\n\t\t\t\t\t}*/\n\t\t\t\t\tif(q[0]==q[2]&&q[1]==q[3]){sum*=2;\n\t\t\t\t\tif(q[0]==q[1])sum*=2;}\n\t\t\t\t\t//cerr<<sum<<endl;\n\t\t\t\t\tt[chu(q)]++;\n\t\t\t\t}\n\t\t\t\tfor(auto i:t){\n\t\t\t\t\tsum=sum*c(get(i.fi),i.se);\n\t\t\t\t}\n\t\t\t\t//if(i==1&&j==8&&k==0)cout<<sum<<\" \"<<t.size()<<endl;\n\t\t\t\tans+=sum;\n\t\t\t}\n\t\t\tadd(j,1);\n\t\t}\n\t\tadd(i,1);\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"IntMod.h\"\n//typedef IntMod<1000000007> MInt;\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n#define REP(i,a,n) for(int i = a; i < n; ++i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define LU(a) (a)\n#define RU(a) ((a + 1) % 4)\n#define RD(a) ((a + 2) % 4)\n#define LD(a) ((a + 3) % 4)\n#define IDX(a) (a / 4)\n#define DIR(a) (a % 4)\n\nstruct Face {\n\tULL colors;\n\n\tFace(int a, int b, int c, int d) {\n\t\tint tmp[4];\n\t\ttmp[0] = a;\n\t\ttmp[1] = b;\n\t\ttmp[2] = c;\n\t\ttmp[3] = d;\n\t\t\n\t\tULL max = 0;\n\t\tREP(i,0,4){\n\t\t\tULL level = tmp[(i + 0) % 4] * (1ULL << 0) + tmp[(i + 1) % 4] * (1ULL << 16) + tmp[(i + 2) % 4] * (1ULL << 32) + tmp[(i + 3) % 4] * (1ULL << 48);\n\t\t\tmax = level > max ? level : max;\n\t\t}\n\t\tcolors = max;\n\t}\n\tint symmetry() const {\n\t\tif ((*this)[0] == (*this)[1] && (*this)[1] == (*this)[2] && (*this)[2] == (*this)[3]) {\n\t\t\treturn 4;\n\t\t}\n\t\tif ((*this)[0] == (*this)[2] && (*this)[1] == (*this)[3]) {\n\t\t\treturn 2;\n\t\t}\n\t\treturn 1;\n\t} \n\tint operator[](int i) const {\n\t\treturn (colors & (0xFFFFULL << (i * 16))) >> (i * 16);\n\t}\n\tbool operator<(const Face& right) const {\n\t\treturn colors < right.colors;\n\t}\n\tbool operator==(const Face& right) const {\n\t\treturn colors == right.colors;\n\t}\n};\n\nmap<Face, LL> faces;\nint N;\nLL sum = 0;\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\t++faces[Face(a, b, c, d)];\n\t}\n\tfor (map<Face, LL>::iterator it = faces.begin(); it != faces.end(); ++it) {\n\t\tfor (map<Face, LL>::iterator jt = faces.begin(); jt != faces.end(); ++jt) {\n\t\t\tREP(l, 0, 4) {\n\t\t\t\tFace front(it->first[3], it->first[2], jt->first[(1 + l) % 4], jt->first[(0 + l) % 4]);\n\t\t\t\tFace right(it->first[2], it->first[1], jt->first[(2 + l) % 4], jt->first[(1 + l) % 4]);\n\t\t\t\tFace back(it->first[1], it->first[0], jt->first[(3 + l) % 4], jt->first[(2 + l) % 4]);\n\t\t\t\tFace left(it->first[0], it->first[3], jt->first[(0 + l) % 4], jt->first[(3 + l) % 4]);\n\t\t\t\tLL top_num = it->second;\n\t\t\t\tLL bottom_num = jt->second - (jt == it);\n\t\t\t\tLL front_num = faces.count(front) ? (faces[front] - (it->first == front) - (jt->first == front)) : 0;\n\t\t\t\tLL right_num = faces.count(right) ? (faces[right] - (it->first == right) - (jt->first == right) - (front == right)) : 0;\n\t\t\t\tLL back_num = faces.count(back) ? (faces[back] - (it->first == back) - (jt->first == back) - (front == back) - (right == back)) : 0;\n\t\t\t\tLL left_num = faces.count(left) ? (faces[left] - (it->first == left) - (jt->first == left) - (front == left) - (right == left) - (back == left)) : 0;\n\t\t\t\tsum +=\n\t\t\t\t\tfront.symmetry() * right.symmetry() * back.symmetry() * left.symmetry()\n\t\t\t\t\t* top_num * bottom_num * front_num * right_num * back_num * left_num;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum / 6 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<ll> C[404];\nll VV[404];\nint R[404];\nmap<ll,int> B[5];\n\nll getkey(vector<ll> v) {\n\tll r=1LL<<60;\n\tint i;\n\tFOR(i,4) {\n\t\trotate(v.begin(),v.begin()+1,v.end());\n\t\tr=min(r,v[0]*1000000000+v[1]*1000000+v[2]*1000+v[3]);\n\t}\n\treturn r;\n}\n\nll dfs(int cur,int n1,int n2,int n4) {\n\tif(cur==0) return 1;\n\tll ret=0;\n\tif(n1) ret += n1*dfs(cur-1,n1-1,n2,n4);\n\tif(n2) ret += 2*n2*dfs(cur-1,n1,n2-1,n4);\n\tif(n4) ret += 4*n4*dfs(cur-1,n1,n2,n4-1);\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y,z; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tvector<ll> V(4,0);\n\t\tFOR(j,4) cin>>V[j];\n\t\tC[i]=V;\n\t\tVV[i]=getkey(C[i]);\n\t\tR[i]=1;\n\t\tif(C[i][0]==C[i][2]&&C[i][1]==C[i][3]) {\n\t\t\tR[i]=2;\n\t\t\tif(C[i][0]==C[i][1]) R[i]=4;\n\t\t}\n\t\tB[R[i]][VV[i]]++;\n\t}\n\tll ret=0;\n\tFOR(x,N) {\n\t\tB[R[x]][VV[x]]--;\n\t\tfor(y=x+1;y<N;y++) {\n\t\t\tB[R[y]][VV[y]]--;\n\t\t\tFOR(z,4) {\n\t\t\t\t\n\t\t\t\tmap<ll,int> mp;\n\t\t\t\tmp[getkey({C[x][1],C[x][0],C[y][1],C[y][0]})]++;\n\t\t\t\tmp[getkey({C[x][2],C[x][1],C[y][0],C[y][3]})]++;\n\t\t\t\tmp[getkey({C[x][3],C[x][2],C[y][3],C[y][2]})]++;\n\t\t\t\tmp[getkey({C[x][0],C[x][3],C[y][2],C[y][1]})]++;\n\t\t\t\t\n\t\t\t\tll tmp=1;\n\t\t\t\tFORR(r,mp) {\n\t\t\t\t\ttmp *= dfs(r.second,B[1][r.first],B[2][r.first],B[4][r.first]);\n\t\t\t\t\tif(tmp==0) break;\n\t\t\t\t}\n\t\t\t\tret += tmp;\n\t\t\t\t\n\t\t\t\trotate(C[y].begin(),C[y].begin()+1,C[y].end());\n\t\t\t\t\n\t\t\t}\n\t\t\tB[R[y]][VV[y]]++;\n\t\t}\n\t\tB[R[y]][VV[x]]++;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 405;\n\nint n;\nvector<int> a[N];\nmap<long long, int> mp, m;\n\nvoid add(vector<int>& a, map<long long, int>& mp) {\n    for (int r = 0; r < 4; ++r) {\n        long long cur = 0;\n        for (int j = 0; j < 4; ++j) {\n            cur = cur * 1000 + a[(j + r) % 4];\n        }\n        ++mp[cur];\n    }\n}\n\nvoid remove(vector<int>& a, map<long long, int>& mp) {\n    for (int r = 0; r < 4; ++r) {\n        long long cur = 0;\n        for (int j = 0; j < 4; ++j) {\n            cur = cur * 1000 + a[(j + r) % 4];\n        }\n        --mp[cur];\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        a[i].resize(4);\n        for (int j = 0; j < 4; ++j) {\n            scanf(\"%d\", &a[i][j]);\n        }\n        add(a[i], mp);\n    }\n    long long result = 0;\n    vector<int> b, q;\n    for (int i = 0; i < n; ++i) {\n        remove(a[i], mp);\n        for (int j = i + 1; j < n; ++j) {\n            remove(a[j], mp);\n            q = a[j];\n            reverse(q.begin(), q.end());\n            for (int r = 0; r < 4; ++r) {\n                long long cur = 1;\n                for (int x = 0; x < 4; ++x) {\n                    b.clear();\n                    b.resize(4);\n                    b[0] = a[i][x]; \n                    b[3] = a[i][(x + 1) % 4];\n                    b[1] = q[(x + r) % 4];\n                    b[2] = q[(x + r + 1) % 4];\n                    long long val = 0;\n                    for (int y = 0; y < 4; ++y) {\n                        val = val * 1000 + b[y];\n                    }\n                    cur *= mp[val];\n                    remove(b, mp);\n                }\n                result += cur;\n                for (int x = 0; x < 4; ++x) {\n                    b.clear();\n                    b.resize(4);\n                    b[0] = a[i][x]; \n                    b[3] = a[i][(x + 1) % 4];\n                    b[1] = q[(x + r) % 4];\n                    b[2] = q[(x + r + 1) % 4];\n                    long long val = 0;\n                    for (int y = 0; y < 4; ++y) {\n                        val = val * 1000 + b[y];\n                    }\n                    add(b, mp);\n                }\n            }\n            add(a[j], mp);\n        }\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define N 1000\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nunordered_map<ll,int> num;\nint c[N][10]; ll a[N],col[N],mi[10];\nvoid add(ll x,int k)\n{\tll v[4]={x%mi[1],x/mi[1]%mi[1],x/mi[2]%mi[1],x/mi[3]%mi[1]};\n\treverse(v,v+4);\n//\tdebug(v[0]);debug(v[1]);debug(v[2]);debug(v[3]);\n\tfor(rint i=0;i<4;i++)\n\t{\tll sum=0;\n\t\tfor(rint j=0;j<4;j++) sum=sum*2333+v[(i+j)%4];\n\t\tnum[sum]+=k;\n\t}\n}\ninline ll hsh(int A,int B,int C,int D){return A*mi[3]+mi[2]*B+mi[1]*C+mi[0]*D;}\nint main()\n{\tint n; ll sum=0; cin>>n;\n\tmi[0]=1; mi[1]=2333; mi[2]=mi[1]*2333; mi[3]=mi[2]*2333;\n//\tadd(hsh(1,2,3,4),1); return 0;\n\tfor(rint i=1;i<=n;i++)\n\t{\tfor(rint j=0;j<4;j++) scanf(\"%d\",&c[i][j]),c[i][j]++;\n\t\tfor(rint j=0;j<4;j++) a[i]=2333*a[i]+c[i][j];\n\t\ta[i]=hsh(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t\tadd(a[i],1);\n\t}\n\tfor(rint i=1;i<=n;i++)\n\t{\tadd(a[i],-1);\n\t\tfor(rint j=i+1;j<=n;add(a[j],1),j++)\n\t\t{\tadd(a[j],-1);\n\t\t\tfor(rint k=0;k<4;k++)\n\t\t\t{//\tif(j==5) debug(c[j][0]);\n\t\t\t\tcol[0]=hsh(c[i][0],c[j][(k+1)%4],c[j][k],c[i][1]);\n\t\t\t\tcol[1]=hsh(c[i][1],c[j][k],c[j][(k+3)%4],c[i][2]);\n\t\t\t\tcol[2]=hsh(c[i][2],c[j][(k+3)%4],c[j][(k+2)%4],c[i][3]);\n\t\t\t\tcol[3]=hsh(c[i][3],c[j][(k+2)%4],c[j][(k+1)%4],c[i][0]);\n\t\t\t//\tif(i==1&&j==5&&k==0) debug(num[col[0]]),debug(num[col[1]]),debug(num[col[2]]),debug(num[col[3]]),exit(0);\n\t\t\t\tll ans=1;\n\t\t\t\tfor(rint l=0;l<4;l++) ans=(ll)ans*num[col[l]],add(col[l],-1);\n\t\t\t\tfor(rint l=0;l<4;l++) add(col[l],1); sum+=ans;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 400\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nmap<LL,LL> mp;\nint col[MAXN+5][4];\nLL Translate(int seq[4])\n{\n\tLL x=0;\n\tfor(int i=3;i>=0;i--)\n\t\tx=1000LL*x+1LL*seq[i];\n\treturn x;\n}\nvoid Add(int seq[4],int val)//以块为单位进行计算 \n{\n\tLL num=Translate(seq);\n\tfor(int tmn=0;tmn<4;tmn++)\n\t{\n\t\tnum/=1000LL;\n\t\tnum+=seq[tmn]*1000000000LL;\n\t\tmp[num]+=val;\n\t}\n}\nLL Query(LL x)\n{\n\tif(mp.find(x)==mp.end())\n\t\treturn 0LL;\n\treturn mp[x];\n}\nvoid GetSeq(int a0,int a1,int a2,int a3,int seq[4])\n{\n\tseq[0]=a0;seq[1]=a1;seq[2]=a2;seq[3]=a3;\n}\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tAdd(col[i],1);\n\t}\n\tint val[4][4];\n\tLL ans=0,tot=0;\n\tLL ansn[4];\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int tmn=1;tmn<=4;tmn++)\n\t\t{\n\t\t\tAdd(col[i],-1LL);\n\t\t\tfor(int j=i+1;j<=N;j++)\n\t\t\t{\n\t\t\t\tAdd(col[j],-1LL);\n\t\t\t\ttot=1LL;\n\t\t\t\tGetSeq(col[j][1],col[j][0],col[i][1],col[i][0],val[0]);\n\t\t\t\tGetSeq(col[j][2],col[j][1],col[i][0],col[i][3],val[1]);\n\t\t\t\tGetSeq(col[j][0],col[j][3],col[i][2],col[i][1],val[2]);\n\t\t\t\tGetSeq(col[j][3],col[j][2],col[i][3],col[i][2],val[3]);\n\t\t\t\t//==================\n\t\t\t\tansn[0]=Query(Translate(val[0]));\n\t\t\t\tansn[1]=Query(Translate(val[1]));\n\t\t\t\tansn[2]=Query(Translate(val[2]));\n\t\t\t\tansn[3]=Query(Translate(val[3]));\n\t\t\t\tif(ansn[0]&ansn[1]&&ansn[2]&ansn[3])\n\t\t\t\t{\n\t\t\t\t\ttot*=ansn[0];\n\t\t\t\t\tAdd(val[0],-1LL);\n\t\t\t\t\ttot*=ansn[1];\n\t\t\t\t\tAdd(val[1],-1LL);\n\t\t\t\t\ttot*=ansn[2];\n\t\t\t\t\tAdd(val[2],-1LL);\n\t\t\t\t\ttot*=ansn[3];\n\t\t\t\t\tAdd(val[0],1LL);\n\t\t\t\t\tAdd(val[1],1LL);\n\t\t\t\t\tAdd(val[2],1LL);\n\t\t\t\t\tans+=tot;\n\t\t\t\t}\n\t\t\t\t//==================\n\t\t\t\tAdd(col[j],1LL);\n\t\t\t}\n\t\t\tAdd(col[i],1LL);\n\t\t\tint first=col[i][0];\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\tcol[i][k]=col[i][k+1];\n\t\t\tcol[i][3]=first;\n\t\t} \n\t}\n\tprintf(\"%lld\\n\",ans/3LL);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=10005;\nint n;\nstruct info{\n\tint a,b,c,d;\n\tinline info(){}\n\tinline info(int _a,int _b,int _c,int _d){\n\t\ta=_a;b=_b;c=_c;d=_d;\n\t}\n\tinline pair<pin,pin> val(){\n\t\treturn mk(mk(a,b),mk(c,d));\n\t}\n\tinline info rotate(){\n\t\treturn info(b,c,d,a);\n\t}\n};\nmap<pair<pin,pin>,i64> f;\ninline void add(info cur,int delta){\n\trep(k,0,3){\n\t\tf[cur.val()]+=delta;\n\t\tcur=cur.rotate();\n\t}\n}\ninline int query(info cur){\n\treturn f[cur.val()];\n}\ninfo a[maxn];\nint main(){\n\tread(n);rep(i,1,n){\n\t\tread(a[i].a);\n\t\tread(a[i].b);\n\t\tread(a[i].c);\n\t\tread(a[i].d);\n\t\tadd(a[i],1);\n\t}\n\ti64 res=0;\n\trep(i,1,n-1){\n\t\tadd(a[i],-1);\n\t\trep(j,i+1,n){\n\t\t\tadd(a[j],-1);\n\t\t\tinfo cur=a[j];\n\t\t\trep(k,0,3){\n\t\t\t\tinfo f1=info(cur.b,cur.a,a[i].b,a[i].a);\n\t\t\t\tinfo f2=info(cur.a,cur.d,a[i].c,a[i].b);\n\t\t\t\tinfo f3=info(cur.d,cur.c,a[i].d,a[i].c);\n\t\t\t\tinfo f4=info(cur.c,cur.b,a[i].a,a[i].d);\n \t\t\t\ti64 ways=1;\n\t\t\t\tways*=query(f1),add(f1, -1);\n\t\t\t\tways*=query(f2),add(f2, -1);\n\t\t\t\tways*=query(f3),add(f3, -1);\n\t\t\t\tways*=query(f4);\n\t\t\t\tadd(f1,1);add(f2,1);add(f3,1);\n\t\t\t\tres+=ways;\n\t\t\t\tcur=cur.rotate();\n\t\t\t}\n\t\t\tadd(a[j],1);\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T,class S,class R> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv3(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c; cin>>a>>b>>c; v[i]={a,b,c};} return move(v);}\ntemplate<class T,class S,class R,class Q> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv4(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c,d; cin>>a>>b>>c>>d; v[i]={a,b,c,d};} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nstruct Combination{\n\tvmll f, g;\n\tCombination(){}\n\tCombination(ll maxN): f(maxN+1, 1), g(maxN+1){ InitSub(maxN); }\n\tvoid init(ll maxN){ f.resize(maxN+1, 1); g.resize(maxN+1); InitSub(maxN); }\n\tmll operator () (ll n, ll r){ return (n<0||r<0||n<r) ? mll(0) : f[n]*g[n-r]*g[r]; }//nCr\n\tmll P(ll n, ll r){ return (n<0 || r<0 || n<r) ? mll(0) : f[n]*g[n-r]; } //nPr\n\tmll H(ll n, ll r){ return operator()(n+r-1, r); }//nHr\n\tmll inv(ll n) { return f[n-1] * g[n]; } //1/n\n\tmll fact(ll n) { return f[n]; } //n!\n\tmll finv(ll n) { return g[n]; } //1/n!\n\tvoid InitSub(ll maxN){\n\t\tREPS(i, 1, maxN){ f[i] = f[i-1] * i; }\n\t\tg[maxN] = 1 / f[maxN];\n\t\tDEPS(i, 1, maxN){ g[i-1] = g[i] * i; }\n\t}\n};\n\nusing qll = tuple<ll, ll, ll, ll>;\n\n\nqll normalize(qll t){\n\tvector<qll> v;\n\tll a; ll b; ll c; ll d;  tie(a, b, c, d) = t;\n\tv.emplace_back(a, b, c, d);\n\tv.emplace_back(d, a, b, c);\n\tv.emplace_back(c, d, a, b);\n\tv.emplace_back(b, c, d, a);\n\tsort(ALL(v));\n\treturn v[0];\n}\n\n\nvoid solve()\n{\n\tll n;  cin >> n;\n\tvector<qll> c = cinv4<ll, ll, ll, ll>(n);\n\teach(e, c){\n\t\te=normalize(e);\n\t}\n\n\tmap<qll, ll> cnt;\n\teach(e, c) cnt[e]++;\n\n\n\tvll b(4), u(4);\n\tvll t(4), p(4);\n\tvector<qll> s(4);//側面\n\tll ans=0;\n\trep(i, 0, n-1){\n\t\ttie(b[0], b[1], b[2], b[3]) = c[i];\n\t\t\n\t\trep(j, i+1, n-1){\n\t\t\ttie(u[3], u[2], u[1], u[0]) = c[j];\n\t\t\trep(k, 0, 3){\n\t\t\t\tif (k>=1){\n\t\t\t\t\trotate(u.begin(), u.begin()+1, u.end());\n\t\t\t\t}\n\t\t\t\t//側面準備\n\t\t\t\trep(m, 0, 3){\n\t\t\t\t\ts[m]=normalize({u[m],u[(m+1)%4],b[(m+1)%4],b[m]});\n\t\t\t\t}\n\t\t\t\t//同じタイルを回転して何回はまるか t[m]\n\t\t\t\trep(m, 0, 3){\n\t\t\t\t\tll a; ll b; ll c; ll d;  tie(a, b, c, d) = s[m];\n\t\t\t\t\tif (a==b and b==c and c==d) t[m]=4;\n\t\t\t\t\telse if (a==c and b==d) t[m]=2;\n\t\t\t\t\telse t[m]=1;\n\t\t\t\t}\n\t\t\t\t//側面4面それぞれ何通りあるか p[m]\n\t\t\t\trep(m, 0, 3){\n\t\t\t\t\tif (cnt.count(s[m])==0) p[m]=0;\n\t\t\t\t\telse p[m]=cnt[s[m]];\n\n\t\t\t\t\tif (c[i]==s[m])p[m]--;\n\t\t\t\t\tif (c[j]==s[m])p[m]--;\n\t\t\t\t\trep(mm, 0, m-1){\n\t\t\t\t\t\tif (s[mm]==s[m])p[m]--;\n\t\t\t\t\t}\n\t\t\t\t\tif (p[m]<0)p[m]=0;\n\t\t\t\t}\n\t\t\t\t//組合せ計算\n\t\t\t\tans+=p[0]*p[1]*p[2]*p[3]*t[0]*t[1]*t[2]*t[3];\n\t\t\t}\n\t\t}\n\t}\n\tans/=3;\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nvector<int> normalize(vector<int> &v) {\n  vector<vector<int>> w;\n  w.push_back(v);\n  vector<int> next(4);\n  for (int k = 0; k < 3; k++) {\n    for (int j = 0; j < 4; j++) next[j] = w.back()[(j + 1) % 4];\n    w.push_back(next);\n  }\n  sort(w.begin(), w.end());\n  return w[0];\n}\n\nll comb(ll n, ll k) {\n  if (k == 1) {\n    return n;\n  } else if (k == 2) {\n    return n * (n - 1);\n  } else if (k == 3) {\n    return n * (n - 1) * (n - 2);\n  } else {\n    return n * (n - 1) * (n - 2) * (n - 3);\n  }\n}\n\nint weight(vector<int> v) {\n  if (v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) return 4;\n  if (v[0] == v[2] && v[1] == v[3]) return 2;\n  return 1;\n}\n\nll po(ll e, ll x) {\n  if (x == 1) return e;\n  if (x == 2) return e * e;\n  return e * e * e * e;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<vector<int>> c(n);\n  map<vector<int>, int> mp;\n  for (int i = 0; i < n; i++) {\n    vector<int> v(4);\n    for (int j = 0; j < 4; j++) cin >> v[j];\n    auto w = normalize(v);\n\n    mp[w]++;\n    c[i] = w;\n  }\n  ll ans = 0;\n\n  for (int i = 0; i < n; i++) {\n    mp[c[i]]--;\n    for (int j = i + 1; j < n; j++) {\n      mp[c[j]]--;\n      for (int k = 0; k < 4; k++) {\n        map<vector<int>, int> want;\n        for (int l = 0; l < 4; l++) {\n          vector<int> side(4);\n          side[0] = c[i][(l + k) % 4];\n          side[1] = c[i][(l + k + 1) % 4];\n          side[2] = c[j][(3 - l)];\n          side[3] = c[j][(4 - l) % 4];\n          reverse(side.begin(), side.end());\n          want[normalize(side)]++;\n        }\n\n        ll tmp = 1;\n        for (auto &pr : want) {\n          tmp *= comb(mp[pr.first], pr.second) * po(weight(pr.first), pr.second);\n        }\n        ans += tmp;\n      }\n      mp[c[j]]++;\n    }\n    mp[c[i]]++;\n  }\n\n  cout << ans / 3 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n\n#ifdef LOCAL\n#define DEBUGMSG()                                                              \\\n{                                                                               \\\n    cerr << \"[调试 @\" << __PRETTY_FUNCTION__ << \":\" << __LINE__ << \"]\" ;        \\\n}\n#define DEBUGVAR(x)                                                             \\\n{                                                                               \\\n    cerr << \"[调试 @\" << __PRETTY_FUNCTION__ << \":\" << __LINE__ << \"]:\" ;       \\\n    cerr << \"([\" << typeid(x).name() << \"]\" << #x << \")\" << x << endl ;         \\\n}\n#define DEBUGARR(l, r)                                                          \\\n{                                                                               \\\n    cerr << \"[调试 @\" << __PRETTY_FUNCTION__ << \":\" << __LINE__ << \"]:\" ;       \\\n    copy(l, r, ostream_iterator<decltype(*l)>(cerr, \" \"));                      \\\n    cerr << endl ;                                                              \\\n}\n#else\n#define DEBUGMSG()\n#define DEBUGVAR(x)\n#define DEBUGARR(l, r)\n#endif // LOCAL\n\n#define getBit(x) (col##x << (10 * (4-x)))\n\nusing i64 = long long;\n\nconst int MAXN = 500 ;\n\nint N;\ni64 COL[MAXN][8], tmp[4], ans;\nmap <i64, i64> mp;\n\ni64 getHash(i64 col1, i64 col2, i64 col3, i64 col4)\n{\n    return getBit(1) | getBit(2) | getBit(3) | getBit(4);\n}\n\nvoid ModifyMap(i64 h, i64 delta)\n{\n    // Rotation\n    for(int i = 0; i < 4; i++)\n    {\n        mp[h] += delta;\n        //DEBUGVAR(h);\n        h = (h >> 10) | ((h & 0x3FF) << 30);\n    }\n\n}\n\n\n\nint main()\n{\n    cin >> N ;\n\n    for(int i = 0; i < N; i++)\n    {\n        for(int c = 0; c < 4; c++)\n            cin >> COL[i][c],\n            COL[i][c+4] = COL[i][c];\n        ModifyMap(getHash(COL[i][0], COL[i][1], COL[i][2], COL[i][3]), 1);\n    }\n\n    for(int i = 0; i < N; i++)\n    {\n        ModifyMap(getHash(COL[i][0], COL[i][1], COL[i][2], COL[i][3]), -1);\n        for(int j = i+1; j < N; j++)\n        {\n            ModifyMap(getHash(COL[j][0], COL[j][1], COL[j][2], COL[j][3]), -1);\n            for(int k = 0; k < 4; k++)\n            {\n                i64 tmpans = 1;\n                tmp[0] = getHash(COL[j][k+1], COL[j][k+0], COL[i][1], COL[i][0]);\n                tmp[1] = getHash(COL[j][k+0], COL[j][k+3], COL[i][2], COL[i][1]);\n                tmp[2] = getHash(COL[j][k+3], COL[j][k+2], COL[i][3], COL[i][2]);\n                tmp[3] = getHash(COL[j][k+2], COL[j][k+1], COL[i][4], COL[i][3]);\n\n                for(int c = 0; c < 4; c++)\n                    if(!mp[tmp[c]])\n                        goto JMP;\n\n                for(int c = 0; c < 4; c++)\n                    tmpans *= mp[tmp[c]],\n                    ModifyMap(tmp[c], -1);\n\n                for(int c = 0; c < 4; c++)\n                    ModifyMap(tmp[c], 1);\n                ans += tmpans;\n\n                JMP:\n                    ;\n            }\n            ModifyMap(getHash(COL[j][0], COL[j][1], COL[j][2], COL[j][3]), 1);\n        }\n    }\n\n    cout << ans << endl ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\n\n\nmap <vector <int>, int> mp;\n\n\nint f(vector <vector <int> > v) {\n\tint res = 1;\n\tfor(auto &z: v) {\n\t\tvector <int> x = z, y = z; int cnt = 0;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\trotate(x.begin(), x.begin() + 1, x.end());\n\t\t\tcnt += x == z;\n\t\t\ty = min(x, y);\n\t\t}\n\t\tres *= cnt * mp[y];\n\t\tmp[y]--;\n\t\tz = y;\n\t}\n\tfor(auto z: v) {\n\t\tmp[z]++;\n\t}\n\n\treturn res;\n}\n\nint32_t main() {\n\tios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n; cin >> n; vector <vector <int> > a(n, vector <int> (4));\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\tvector <int> b = a[i];\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\trotate(b.begin(), b.begin() + 1, b.end());\n\t\t\ta[i] = min(a[i], b);\n\t\t}\n\t}\n\n\t\n\tint ans = 0;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tmp[a[j]]--;\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\trotate(a[j].begin(), a[j].begin() + 1, a[j].end());\n\t\t\t\tvector <int> x = a[i], y = a[j]; \n\t\t\t\ty = {y[1], y[0], y[3], y[2]};\n\t\t\t\tvector <vector <int> > v = {\n\t\t\t\t\t{x[0], y[0], y[1], x[1]},\n\t\t\t\t\t{x[1], y[1], y[2], x[2]},\n\t\t\t\t\t{x[2], y[2], y[3], x[3]},\n\t\t\t\t\t{x[3], y[3], y[0], x[0]}\n\t\t\t\t\t\n\t\t\t\t};\n\t\t\t\tans += f(v);\n\t\t\t}\n\t\t\tmp[a[j]]++;\n\t\t}\n\t\tmp[a[i]]++;\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector <int> vec[2100],ths[4];\nmap<vector <int>,int>mp;\nvoid leg(vector <int> &vec)\n{if (vec.size()!=4) assert(0);\n\tvector <int> ls=vec;\n\tfor (int i=1;i<=4;i++)\n\t{\n\t\tint t=vec[0];vec[0]=vec[1];vec[1]=vec[2];vec[2]=vec[3];vec[3]=t;\n\t\tif (ls>vec) ls=vec;\n\t}\n\tvec=ls;\n}\nint gnum(vector <int> &vec)\n{\n\tint ans=0;\n\tfor (int i=1;i<=4;i++)\n\t{\n\t\tif ((vec[0]==vec[(0+i)%4])&&(vec[1]==vec[(1+i)%4])&&(vec[2]==vec[(2+i)%4])&&(vec[3]==vec[(3+i)%4]))\n\t\t\tans++;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tvec[i].resize(4);\n\t\tscanf(\"%d%d%d%d\",&vec[i][0],&vec[i][1],&vec[i][2],&vec[i][3]);\n\t\tleg(vec[i]);mp[vec[i]]++;\n\t}\n\tfor (int i=0;i<4;i++) ths[i].resize(4);\n\tlong long ans=0;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<i;j++)\n\t{\n\t\tmp[vec[i]]--;mp[vec[j]]--;\n\t\tvector <int> x=vec[i],y=vec[j];reverse(x.begin(),x.end());\n\t\tfor (int d=0;d<4;d++)\n\t\t{\n\t\t\tths[0][0]=x[0];ths[0][1]=x[1];ths[0][2]=y[1];ths[0][3]=y[0];\n\t\t\tths[1][0]=x[1];ths[1][1]=x[2];ths[1][2]=y[2];ths[1][3]=y[1];\n\t\t\tths[2][0]=x[2];ths[2][1]=x[3];ths[2][2]=y[3];ths[2][3]=y[2];\n\t\t\tths[3][0]=x[3];ths[3][1]=x[0];ths[3][2]=y[0];ths[3][3]=y[3];\n\t\t\tlong long p=1;\n\t\t\tfor (int t=0;t<4;t++)\n\t\t\t{\n\t\t\t\tleg(ths[t]);\n\t\t\t\tp*=gnum(ths[t])*mp[ths[t]];\n\t\t\t\tmp[ths[t]]--;\n\t\t\t}\n\t\t\tans+=p;\n\t\t\tfor (int t=0;t<4;t++) mp[ths[t]]++;\n\t\t\tint ls=y[0];y[0]=y[1];y[1]=y[2];y[2]=y[3];y[3]=ls;\n\t\t}\n\t\tmp[vec[i]]++;mp[vec[j]]++;\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndeque<deque<int>> rot(deque<int> a) {\n    deque<deque<int>> ret;\n    ret.push_back(a);\n    for (int i = 0; i < 3; i++) {\n        a.push_back(a[0]);\n        a.pop_front();\n        ret.push_back(a);\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, p, q, r, s;\n    cin >> n;\n\n    deque<deque<int>> v;\n    for (int i = 0; i < n; i++) {\n        cin >> p >> q >> r >> s;\n        deque<int> tmp;\n        tmp.push_back(p);\n        tmp.push_back(q);\n        tmp.push_back(r);\n        tmp.push_back(s);\n        v.emplace_back(tmp);\n    }\n\n    long long ans = 0;\n    map<deque<int>, deque<int>> m;\n    for (int i = 0; i < n; i++) {\n        for (auto &p : rot(v[i])) {\n            m[p].push_back(i);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        auto a = v[i];\n        for (int j = i + 1; j < n; j++) {\n            for (auto b: rot(v[j])) {\n                deque<int> fr, ri, ba, le;\n                fr = m[{a[3], a[2], b[1], b[0]}];\n                ri = m[{a[2], a[1], b[2], b[1]}];\n                ba = m[{a[1], a[0], b[3], b[2]}];\n                le = m[{a[0], a[3], b[0], b[3]}];\n\n                sort(fr.begin(), fr.end());\n                sort(ri.begin(), ri.end());\n                sort(ba.begin(), ba.end());\n                sort(le.begin(), le.end());\n\n                for (int x: fr) {\n                    for (int y: ri) {\n                        for (int z: ba) {\n                            for (int w: le) {\n                                if (i != x && i != y && i != z && i != w) {\n                                    if (j != x && j != y && j != z && j != w) {\n                                        if (x != y && x != z && x != w && y != z && y != w && z != w) ans++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans / 3 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for(register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) {return b < a ? a = b, 1 : 0;}\ntemplate<typename T> inline bool chkmax(T &a, T b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x(0), sgn(1); char ch(getchar());\n    for (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n    for (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n    return x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 410;\n\nstruct Node {\n\n\tint col[4];\n\n\tNode GetNext() {\n\t\treturn (Node){ col[1], col[2], col[3], col[0] };\n\t}\n\n} a[N], a1, a2, a3, a4;\n\ninline bool operator < (const Node &lhs, const Node &rhs) {\n\tFor (i, 0, 3)\n\t\tif (lhs.col[i] != rhs.col[i])\n\t\t\treturn lhs.col[i] < rhs.col[i];\n\treturn false;\n}\n\nmap<Node, int> M;\n\ninline void Update(Node cur, int val) {\n\tFor (i, 0, 3) {\n\t\tM[cur] += val;\n\t\tcur = cur.GetNext();\n\t}\n}\n\nint main() {\n\n\tFile();\n\n\tint n = read();\n\tFor (i, 1, n) {\n\t\tFor (j, 0, 3) a[i].col[j] = read();\n\t\tUpdate(a[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tFor (i, 1, n) {\n\t\tUpdate(a[i], - 1);\n\t\tFor (j, i + 1, n) {\n\t\t\tUpdate(a[j], - 1);\n\t\t\tFor (t, 0, 3) {\n\t\t\t\ta1 = (Node) {a[j].col[1], a[i].col[0], a[i].col[3], a[j].col[2]};\n\t\t\t\ta2 = (Node) {a[i].col[1], a[j].col[0], a[j].col[3], a[i].col[2]};\n\t\t\t\ta3 = (Node) {a[j].col[1], a[j].col[0], a[i].col[1], a[i].col[0]};\n\t\t\t\ta4 = (Node) {a[i].col[3], a[i].col[2], a[j].col[3], a[j].col[2]};\n\t\t\t\ta[j] = a[j].GetNext();\n\n\t\t\t\tif (!M[a1] || !M[a2] || !M[a3] || !M[a4]) continue ;\n\t\t\t\tlong long res = 1;\n\t\t\t\tres *= M[a1]; Update(a1, -1);\n\t\t\t\tres *= M[a2]; Update(a2, -1);\n\t\t\t\tres *= M[a3]; Update(a3, -1);\n\t\t\t\tres *= M[a4]; \n\t\t\t\tUpdate(a1, 1);\n\t\t\t\tUpdate(a2, 1);\n\t\t\t\tUpdate(a3, 1);\n\t\t\t\tans += res;\n\t\t\t}\n\t\t\tUpdate(a[j], 1);\n\t\t}\n\t}\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <map>\n\nusing tile = std::array<int, 4>;\nconstexpr int coeff[] = { 1, 2, 4 };\n\ntile rotate(const tile &t, int r) {\n  tile res{};\n  for (int i = 0; i < 4; ++i) {\n    res[i] = t[(i + r) & 3];\n  }\n  return res;\n}\n\ntile normalize(const tile &t) {\n  std::array<tile, 4> tmp{};\n  for (int i = 0; i < 4; ++i) {\n    tmp[i] = rotate(t, i);\n  }\n  std::sort(tmp.begin(), tmp.end());\n  return tmp.front();\n}\n\nint type(const tile &t) {\n  if (t[0] == t[1] && t[1] == t[2] && t[2] == t[3]) return 2;\n  if (t[0] == t[2] && t[1] == t[3]) return 1;\n  return 0;\n}\n\nint main() {\n  int N;\n  std::cin >> N;\n  std::vector<tile> C(N);\n  std::map<tile, int> memo;\n  for (int i = 0; i < N; ++i) {\n    for (auto &x: C[i]) {\n      std::cin >> x;\n    }\n    C[i] = normalize(C[i]);\n    memo[C[i]]++;\n  }\n  int64_t ans = 0;\n  for (int i = 0; i < N; ++i) {\n    memo[C[i]]--;\n    const auto &up = C[i];\n    for (int j = i + 1; j < N; ++j) {\n      memo[C[j]]--;\n      for (int k = 0; k < 4; ++k) {\n        auto down = rotate(C[j], k);\n        std::map<tile, int> query;\n        query[normalize(tile{ up[0], up[3], down[2], down[1] })]++;\n        query[normalize(tile{ up[1], up[0], down[1], down[0] })]++;\n        query[normalize(tile{ up[2], up[1], down[0], down[3] })]++;\n        query[normalize(tile{ up[3], up[2], down[3], down[2] })]++;\n        int64_t add = 1;\n        for (auto &q: query) {\n          auto itr = memo.find(q.first);\n          if (itr == memo.end()) {\n            add = 0;\n            break;\n          }\n          int s = itr -> second, t = type(q.first);\n          for (int i = 0; i < q.second; ++i) {\n            add *= (s - i) * coeff[t];\n          }\n        }\n        ans += add;\n      }\n      memo[C[j]]++;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nmap<ll,int> cnt;\nstruct Card{\n\tint c[4];\n\tvoid modify()\n\t{\n\t\tvector<vi> a(4);\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=i;j<4;j++) a[i].push_back(c[j]);\n\t\t\tfor(int j=0;j<i;j++) a[i].push_back(c[j]);\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tfor(int i=0;i<4;i++) c[i]=a[0][i];\n\t}\n\tinline int factor()\n\t{\n\t\tif(c[0]==c[1]&&c[1]==c[2]&&c[2]==c[3]) return 4;\n\t\tif(c[0]==c[2]&&c[1]==c[3]) return 2;\n\t\treturn 1;\n\t}\n}card[500];\ninline ll Hash(Card a)\n{\n\tll ret=0;\n\tll step=1000000000;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tret+=1LL*a.c[i]*step;\n\t\tstep/=1000;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tCard &cc=card[i];\n\t\tcin>>cc.c[0]>>cc.c[1]>>cc.c[2]>>cc.c[3];\n\t\tcc.modify();\n\t\tcnt[Hash(cc)]++;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tcnt[Hash(card[i])]--;\n\t\t\tcnt[Hash(card[j])]--;\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tCard up;\n\t\t\t\tint p=0;\n\t\t\t\tfor(int kk=k;kk<4;kk++)\n\t\t\t\t\tup.c[p++]=card[i].c[kk];\n\t\t\t\tfor(int kk=0;kk<k;kk++)\n\t\t\t\t\tup.c[p++]=card[i].c[kk];\n\t\t\t\tCard down=card[j];\n\t\t\t\tCard Back={up.c[0],down.c[1],down.c[0],up.c[1]};\n\t\t\t\tCard Front={up.c[3],up.c[2],down.c[3],down.c[2]};\n\t\t\t\tCard Left={up.c[0],up.c[3],down.c[2],down.c[1]};\n\t\t\t\tCard Right={up.c[2],up.c[1],down.c[0],down.c[3]};\n\t\t\t\tBack.modify();\n\t\t\t\tFront.modify();\n\t\t\t\tLeft.modify();\n\t\t\t\tRight.modify();\n\t\t\t\tll cur=1;\n\t\t\t\tll bn=Hash(Back),fn=Hash(Front),ln=Hash(Left),rn=Hash(Right);\n\t\t\t\t//dbg(i,j,k,bn,fn,ln,rn);\n\t\t\t\tbool ok=1;\n\t\t\t\tif(!cnt[bn]) ok=0;\n\t\t\t\tcur*=cnt[bn];\n\t\t\t\tcnt[bn]--;\n\t\t\t\tif(!cnt[fn]) ok=0;\n\t\t\t\tcur*=cnt[fn];\n\t\t\t\tcnt[fn]--;\n\t\t\t\tif(!cnt[ln]) ok=0;\n\t\t\t\tcur*=cnt[ln];\n\t\t\t\tcnt[ln]--;\n\t\t\t\tif(!cnt[rn]) ok=0;\n\t\t\t\tcur*=cnt[rn];\n\t\t\t\tcnt[rn]--;\n\t\t\t\tcur*=Back.factor()*Front.factor()*Left.factor()*Right.factor();\n\t\t\t\tcnt[bn]++;\n\t\t\t\tcnt[fn]++;\n\t\t\t\tcnt[ln]++;\n\t\t\t\tcnt[rn]++;\n\t\t\t\tif(ok)\n\t\t\t\t\tans+=cur;\n\t\t\t}\n\t\t\tcnt[Hash(card[i])]++;\n\t\t\tcnt[Hash(card[j])]++;\n\t\t\t//dbg(i,j,ans);\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\n#define G(x,y,z,t) ((x)*1LL*1000000000+(y)*1000000+(z)*1000+(t))\nunordered_map<LL,int> number;\nstruct sqare{\n\tint x0,x1,x2,x3;\n\tLL key[5];\n\tvoid ini(int a,int b,int c,int d){\n\t\tx0=a,x1=b,x2=c,x3=d;\n\t\tkey[1]=G(a,b,c,d);\n\t\tkey[2]=G(b,c,d,a);\n\t\tkey[3]=G(c,d,a,b);\n\t\tkey[4]=G(d,a,b,c);\n\t}\n\tvoid add(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]++;\n\t}\n\tvoid dec(){\n\t\tfor(int i=1;i<=4;i++) number[key[i]]--;\n\t}\n}p[505];\nLL calc(sqare fr,sqare bk){\n\tfr.dec();bk.dec();\n\tLL ret=0;\n\tfor(int i=1;i<=4;i++){\n\t\tint t=bk.x0;bk.x0=bk.x1;bk.x1=bk.x2;bk.x2=bk.x3;bk.x3=t;\n\t\tLL ans=1;sqare key[5];\n\t\tkey[1].ini(fr.x1,fr.x0,bk.x1,bk.x0);\n\t\tans*=number[G(fr.x1,fr.x0,bk.x1,bk.x0)];key[1].dec();\n\t\tkey[2].ini(fr.x2,fr.x1,bk.x0,bk.x3);\n\t\tans*=number[G(fr.x2,fr.x1,bk.x0,bk.x3)];key[2].dec();\n\t\tkey[3].ini(fr.x3,fr.x2,bk.x3,bk.x2);\n\t\tans*=number[G(fr.x3,fr.x2,bk.x3,bk.x2)];key[3].dec();\n\t\tkey[4].ini(fr.x0,fr.x3,bk.x2,bk.x1);\n\t\tans*=number[G(fr.x0,fr.x3,bk.x2,bk.x1)];key[4].dec();\n\t\tret+=ans;\n\t\tfor(int j=1;j<=4;j++) key[j].add();\n\t}\n\tfr.add();bk.add();\n\treturn ret;\n}\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tp[i].ini(a,b,c,d);\n\t\tp[i].add();\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tans+=calc(p[i],p[j]);\n\tcout<<ans/6<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mod 1000000007\n// #define mod 998244353\nusing namespace std;\n\nmap<vector<ll>, ll> mymap;\n\nvoid insert(vector<ll> &v)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tmymap[v]++;\n\t}\n}\n\nvoid remove(vector<ll> &v)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\tmymap[v]--;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<ll> c[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tc[i].resize(4);\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcin >> c[i][j];\n\t\t}\n\t\tinsert(c[i]);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvector<ll> top = c[i];\n\t\tremove(top);\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tvector<ll> rev_bot = c[j], bot = c[j];\n\t\t\treverse(bot.begin(), bot.end());\n\t\t\tremove(rev_bot);\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tvector<ll> req[4];\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\treq[num].pb(top[num]);\n\t\t\t\t\treq[num].pb(top[(num + 1) % 4]);\n\t\t\t\t\treq[num].pb(bot[(num + 1) % 4]);\n\t\t\t\t\treq[num].pb(bot[num]);\n\t\t\t\t\treverse(req[num].begin(), req[num].end());\n\t\t\t\t}\n\t\t\t\tll temp_ans = 1;\n\t\t\t\tvector<bool> was_removed(4);\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\ttemp_ans *= mymap[req[num]];\n\t\t\t\t\tif (mymap[req[num]] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tremove(req[num]);\n\t\t\t\t\t\twas_removed[num] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t{\n\t\t\t\t\tif (was_removed[num])\n\t\t\t\t\t{\n\t\t\t\t\t\tinsert(req[num]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i == 1 && j == 3)\n\t\t\t\t{\n\t\t\t\t\tfor (int x : top)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << x << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t\tfor (int x : bot)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << x << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t\tfor (int num = 0; num < 4; num++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int x : req[num])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout << x << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t}\n\t\t\t\t\tcout << temp_ans << endl;\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tans += temp_ans;\n\t\t\t\trotate(bot.begin(), bot.begin() + 1, bot.end());\n\t\t\t}\n\t\t\tinsert(rev_bot);\n\t\t}\n\t\tinsert(top);\n\t}\n\tcout << ans / 3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nlong long calc(int a, int b, int c, int d){\n\tlong long r = 1024 * a + b;\n\tr = 1024 * r + c;\n\treturn 1024 * r + d;\n}\n\nlong long pack(int a, int b, int c, int d){\n\treturn min(min(calc(a, b, c, d), calc(b, c, d, a)), min(calc(c, d, a, b), calc(d, a, b, c)));\n}\n\nint getR(long long key){\n\tint c[4];\n\tfor(int i=0;i<4;i++){\n\t\tc[i] = key%1024;\n\t\tkey /= 1024;\n\t}\n\tif(c[0] == c[1] && c[1] == c[2] && c[2] == c[3]) return 4;\n\tif(c[0] == c[2] && c[1] == c[3]) return 2;\n\treturn 1;\n}\n\nlong long pow(int a, int p){\n\tlong long r = 1;\n\tfor(int i=0;i<p;i++) r *= a;\n\treturn r;\n}\n\nlong long fact(int f){\n\tlong long r = 1;\n\tfor(int i=2;i<=f;i++) r *= i;\n\treturn r;\n}\n\nint main(){\n\tint N;\n\tstatic int c[400][4];\n\tstatic long long comb[400][401];\n\tcomb[1][0] = comb[1][1] = 1;\n\tfor(int i=2;i<=400;i++){\n\t\tcomb[i][0] = 1;\n\t\tfor(int j=1;j<i;j++) comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\t\tcomb[i][i] = 1;\n\t}\n\twhile(cin >> N && N){\n\t\tmap<long long, int> num;\n\t\tlong long res = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<4;j++) cin >> c[i][j];\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tconst int* back = c[j];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tlong long key[4];\n\t\t\t\t\tkey[0] = pack(back[(k+1)%4], back[(k+0)%4], c[i][1], c[i][0]);\n\t\t\t\t\tkey[1] = pack(back[(k+0)%4], back[(k+3)%4], c[i][2], c[i][1]);\n\t\t\t\t\tkey[2] = pack(back[(k+3)%4], back[(k+2)%4], c[i][3], c[i][2]);\n\t\t\t\t\tkey[3] = pack(back[(k+2)%4], back[(k+1)%4], c[i][0], c[i][3]);\n\t\t\t\t\tsort(key, key+4);\n\t\t\t\t\tlong long backKey = pack(back[0], back[1], back[2], back[3]);\n\t\t\t\t\tlong long add = 1;\n\t\t\t\t\tfor(int l=0;l<4;){\n\t\t\t\t\t\tint cnt = 1;\n\t\t\t\t\t\tfor(int m=l+1;m<4 && key[l]==key[m];m++) ++cnt;\n\t\t\t\t\t\tint sel = 0;\n\t\t\t\t\t\tif(num.count(key[l])) sel = num[key[l]];\n\t\t\t\t\t\tif(key[l] == backKey) --sel;\n\t\t\t\t\t\tif(sel < cnt){\n\t\t\t\t\t\t\tadd = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tadd *= comb[sel][cnt] * pow(getR(key[l]), cnt) * fact(cnt);\n\t\t\t\t\t\tl += cnt;\n\t\t\t\t\t}\n\t\t\t\t\tres += add;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long k = pack(c[i][0], c[i][1], c[i][2], c[i][3]);\n\t\t\tif(num.count(k)) ++num[k];\n\t\t\telse num[k] = 1;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ninline ll encode(vector<int> &tile) {\n  ll now = 0, base = 1000;\n  for (int c : tile) {\n    now += c;\n    now *= base;\n  }\n  return now;\n}\n\ninline void rot(vector<int> &tile) {\n  rotate(tile.begin(), tile.begin() + 1, tile.end());\n}\n\ninline void rm_tile(vector<int> &tile, map<ll, int> &colors) {\n  REP(i, 4) {\n    colors[encode(tile)]--;\n    rot(tile);\n  }\n}\n\ninline void add_tile(vector<int> &tile, map<ll, int> &colors) {\n  REP(i, 4) {\n    colors[encode(tile)]++;\n    rot(tile);\n  }\n}\n\nll calc_tiles(vector<int> &upper, vector<int> &lower, map<ll, int> &colors) {\n  ll ret = 1;\n  vector<vector<int>> side_tiles = {{upper[1], lower[0], lower[3], upper[2]},\n                                    {upper[3], upper[2], lower[3], lower[2]},\n                                    {lower[1], upper[0], upper[3], lower[2]},\n                                    {lower[1], lower[0], upper[1], upper[0]}};\n  vector<vector<int>> used;\n  for (vector<int> &tile : side_tiles) {\n    ret *= max(colors[encode(tile)], 0);\n    if (ret == 0) break;\n    rm_tile(tile, colors);\n    used.emplace_back(tile);\n  }\n\n  for (vector<int> &tile : used) add_tile(tile, colors);\n  return ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<vector<int>> tiles(N);\n  map<ll, int> colors;\n  REP(i, N) {\n    int c0, c1, c2, c3; cin >> c0 >> c1 >> c2 >> c3;\n    tiles[i] = {c0, c1, c2, c3};\n    REP(j, 4) {\n      colors[encode(tiles[i])]++;\n      rot(tiles[i]);\n    }\n  }\n\n  ll ans = 0;\n  REP(up, N) {\n    rm_tile(tiles[up], colors);\n    FOR(low, up+1, N) {\n      rm_tile(tiles[low], colors);\n      REP(k, 4) {\n        ans += calc_tiles(tiles[up], tiles[low], colors);\n        rot(tiles[low]);\n      }\n      add_tile(tiles[low], colors);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<vector<ll>,ll>mp;\n  ll access(vector<ll>v){\n    ll ret=0;\n    ret+=mp[{v[0],v[1],v[2],v[3]}];\n    ret+=mp[{v[1],v[2],v[3],v[0]}];\n    ret+=mp[{v[2],v[3],v[0],v[1]}];\n    ret+=mp[{v[3],v[0],v[1],v[2]}];\n    //cout<<ret<<endl;\n    return max(0LL,ret);\n  }\n  void change(vector<ll>v,ll w){\n    mp[v]+=w;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,0LL);\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.change(c[i],1);\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<ll>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<ll>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nvector<int> a[1010][4];\nmap<vector<int>, int> m, m2, m4;\nint mul2[5] = {1, 2, 4, 8, 16};\nint mul4[5] = {1, 4, 16, 64, 256};\ninline long long chs(int a, int b) {\n\tif (a < b) return 0;\n\tlong long res = 1;\n\tfor (int i = 1; i <= b; i++) {\n\t\tres = res * (a - i + 1);\n\t}\n\treturn res;\n}\nlong long go(vector<int> v, int t) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= t; i++) {\n\t\tfor (int j = 0; j <= t - i; j++) {\n\t\t\tint k = t - i - j;\n\t\t\tres += chs(m[v], i) * chs(m2[v], j) * chs(m4[v], k) * mul2[j] * mul4[k];\n\t\t}\n\t}\n\treturn res;\n}\nint ti[1010];\nint reg(int i, int j, int x) {\n\tif (ti[i] == 4) {\n\t\tm4[a[i][0]] += x;\n\t}\n\tif (ti[i] == 2) {\n\t\tm2[*min_element(a[i], a[i] + 2)] += x;\n\t}\n\tif (ti[i] == 1) {\n\t\tm[*min_element(a[i], a[i] + 4)] += x;\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> &v = a[i][0];\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\ta[i][j].push_back(v[(j+k)%4]);\n\t\t\t}\n\t\t}\n\t\tif (v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) {\n\t\t\tti[i] = 4;\n\t\t\tm4[v]++;\n\t\t} else if (v[0] == v[2] && v[1] == v[3]) {\n\t\t\tti[i] = 2;\n\t\t\tm2[*min_element(a[i], a[i] + 2)]++;\n\t\t} else {\n\t\t\tti[i] = 1;\n\t\t\tm[*min_element(a[i], a[i] + 4)]++;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> &v = a[i][0];\n\t\treg(i, 0, -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<int> w = a[j][k];\n\t\t\t\treg(j, k, -1);\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\tmap<vector<int>, int> f;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tvector<int> u[4];\n\t\t\t\t\tu[0].push_back(w[l]);\n\t\t\t\t\tu[0].push_back(w[(l+1)%4]);\n\t\t\t\t\tu[0].push_back(v[(l+1)%4]);\n\t\t\t\t\tu[0].push_back(v[l]);\n\t\t\t\t\tfor (int r = 1; r < 4; r++) {\n\t\t\t\t\t\tfor (int q = 0; q < 4; q++) {\n\t\t\t\t\t\t\tu[r].push_back(u[0][(r+q)%4]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf[*min_element(u, u + 4)]++;\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (map<vector<int>, int>::iterator it = f.begin(); it != f.end(); it++) {\n\t\t\t\t\ttmp *= go(it->first, it->second);\n\t\t\t\t}\n\n\t\t\t\tans += tmp;\n\t\t\t\treg(j, k, 1);\n\t\t\t}\n\t\t}\n\t\treg(i, 0, 1);\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 1010010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,ll> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,ll delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)%4]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid permutar(vi &nuevo)\n{\n    vper.clear();\n    forr(i,0,4)\n    vper.pb(move(nuevo,i));\n\n}\nvoid add(vi &nuevo,ll delta,map<iiii,ll> &mapa)\n{\n    permutar(nuevo);\n    forr(i,0,vper.size())\n    {\n        mapa[vper[i]]+=delta;\n    }\n}\nvector<iiii> vcaras;\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n        vcaras.clear();\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras.pb(auxcara);\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   ll n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   permutar(V[2]);\n   map<iiii,ll> extra;\n   ll totp,answer=0,auxtotp;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,i+1,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    fiiv(cara2,move(V[j],kj));\n                    /*<<\"comenzamos\\n\";\n                    prll(cara1);\n                    prll(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prll(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxtotp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxtotp);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //cout<<answer<<endl;\n   cout<<answer/12<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max<R>(x, 0.0));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> c(n, vector<int>(4, 0));\n\n\trep(i, n)rep(j, 4) cin >>  c[i][j];\n\n\tll ans = 0LL;\n\n\trep(j, n)rep(i, j) {\n\t\trep(di, 4) rep(dj,4){\n\t\t\tvector<int> top = c[i];\n\t\t\tvector<int> bottom = c[j];\n\t\t\treverse(begin(bottom), end(bottom));\n\t\t\t\n\t\t\trotate(begin(top), begin(top) + di, end(top));\n\t\t\trotate(begin(bottom), begin(bottom) + dj, end(bottom));\n\n\t\t\t\n\t\t\tll num[400][4];\n\t\t\trep(ii, n)rep(jj, 4) num[ii][jj] = 0LL;\n\n\t\t\trep(k, n) {\n\t\t\t\tif (k == i or k == j) continue;\n\t\t\t\trep(dd, 4) {\n\t\t\t\t\tvector<int> rot = {bottom[(dd + 0) % 4], bottom[(dd + 1) % 4], top[(dd + 1) % 4], top[(dd + 0) % 4]};\n\n\t\t\t\t\trep(ii, 4) {\n\t\t\t\t\t\tvector<int> cur = c[k];\n\t\t\t\t\t\trotate(begin(cur), begin(cur) + ii, end(cur));\n\t\t\t\t\t\tif (cur == rot)  num[k][dd]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tll dp[410][1 << 4];\n\t\t\trep(ii, n + 1)rep(jj, 1 << 4) dp[ii][jj] = 0;\n\n\n\t\t\tdp[0][0] = 1LL;\n\t\t\trep(k, n)rep(mask, 1 << 4) {\n\t\t\t\tdp[k + 1][mask] += dp[k][mask];\n\t\t\t\tif (k == i or k == j) continue;\n\t\t\t\trep(ii, 4) {\n\t\t\t\t\tif (mask & (1 << ii)) continue;\n\t\t\t\t\tdp[k + 1][mask | (1 << ii)] += 1LL * num[k][ii] * dp[k][mask];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (i == 0 and j == 4 and d == 2) {\n\t\t\t\terror(top[0], top[1], top[2], top[3]);\n\t\t\t\terror(bottom[0], bottom[1], bottom[2], bottom[3]);\n\t\t\t\trep(ii, n)rep(jj, 4) error(ii, jj, num[ii][jj]);\n\t\t\t\terror(dp[6][15]);\n\t\t\t}\n\t\t\t*/\n\n\t\t\tans += 1LL * dp[n][15];\n\t\t\t//error(i, j, d, coef, dp[n][15]);\n\t\t}\n\t}\n\n\tcout << ans / 12LL << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n  template <>\n  class hash<std::pair<Int, Int>> {\n  public:\n    const Int MOD = 1e9+7;\n    size_t operator()(const std::pair<Int, Int>& x) const{\n      return hash<Int>()(x.first)*MOD+hash<Int>()(x.second);\n    }\n  };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  unordered_set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  unordered_set<Int> used_f;\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n    if(used_f.count(b[i])) continue;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n    \n    Int v=b[i];\n    for(Int j=0;j<4;j++){\n      v=((v&1023)<<30)|(v>>10);\n      used_f.emplace(v);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define Node(a,b,c,d) make_pair(a,make_pair(b,make_pair(c,d)))\n#define T pair<int,pair<int,pair<int,int> > >\n\ntypedef long long LL;\nmap<T,LL> cnt;\nconst int maxn = 500;\n\nint A[maxn][4];\nint n;\n\nT stand(T t)\n{\n    int num[4];\n    num[0] = t.first;\n    num[1] = t.second.first;\n    num[2] = t.second.second.first;\n    num[3] = t.second.second.second;\n\n    T tmp[4];\n\n\n    for(int s = 0;s < 4;++s)\n    {\n        tmp[s] = Node(num[(s+0)%4],num[(s+1)%4],num[(s+2)%4],num[(s+3)%4]);\n    }\n    sort(tmp,tmp+4);\n    return tmp[0];\n\n}\n\nvoid update(int id,int val)\n{\n    T now = stand(Node(A[id][0],A[id][1],A[id][2],A[id][3]));\n    cnt[now] += val;\n}\n\n\nLL calsame(T t)\n{\n    int num[4];\n    num[0] = t.first;\n    num[1] = t.second.first;\n    num[2] = t.second.second.first;\n    num[3] = t.second.second.second;\n\n\n    T tmp[4];\n    for(int s = 0;s < 4;++s)\n    {\n        tmp[s] = Node(num[(s+0)%4],num[(s+1)%4],num[(s+2)%4],num[(s+3)%4]);\n    }\n    LL c = 0;\n    for(int s = 0;s < 4;++s)\n        if(tmp[s] == tmp[0])\n            c++;\n    return c;\n\n}\n\nint main()\n{\n   // freopen(\"./test.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    cnt.clear();\n    for(int i = 1;i <= n;++i)\n    {\n        for(int j = 0;j < 4;++j)\n            scanf(\"%d\",&A[i][j]);\n        update(i,1);\n    }\n\n    LL res = 0;\n    for(int i = 1;i <= n;++i)\n    {\n        update(i,-1);\n\n        for(int j = i+1;j <= n;++j)\n          //  if(i != j)\n            {\n                update(j,-1);\n\n\n                int Down[4];\n                for(int ds = 0;ds < 1;++ds)\n                {\n                    for(int x = 0;x < 4;++x)\n                        Down[x] = A[i][(ds+x)%4];\n\n                    int Up[4];\n                    for(int us = 0;us < 4;++us)\n                    {\n                        for(int y = 0;y < 4;++y)\n                            Up[y] = A[j][(us-y+4)%4];\n\n                        LL now = 1;\n\n                        T X[4];\n\n                        for(int k = 0;k < 4;++k)\n                        {\n                            X[k] = stand(Node(Down[k],Up[k],Up[(k+1)%4],Down[(k+1)%4]));\n\n                            LL csame = calsame(X[k]);\n\n                            now *= csame*cnt[X[k]];\n\n                            cnt[X[k]] -= 1;\n\n                        }\n\n                        res += now;\n\n                        for(int k = 0;k < 4;++k)\n                            cnt[X[k]] += 1;\n\n                       // printf(\"**** %d  %d\\n\",i,j);\n//                        for(int k = 0;k < 4;++k)\n//                            printf(\"%d%c\",Down[k],\" \\n\"[k == 3]);\n//\n//                        for(int k = 0;k < 4;++k)\n//                            printf(\"%d%c\",Up[k],\" \\n\"[k == 3]);\n//\n//                        puts(\"\");\n                    }\n\n                }\n\n\n\n                update(j,1);\n            }\n\n        update(i,1);\n    }\n\n    printf(\"%lld\\n\",res/3);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nunordered_map<ll, int>cnt;\nint g2;\nll calc (int *a) {\n\tll ans = 0; g2 = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tll tmp = 0;\n\t\tfor (int j = 0; j < 4; ++j) tmp = tmp << 10 | a[(i + j) & 3];\n\t\tif (tmp > ans) ans = tmp, g2 = 1;\n\t\telse if (tmp == ans) ++g2;\n\t}\n\treturn ans;\n}\n\nconst int N = 404;\n\nint p[N][4], n, tt[4];\nll a[4], ans, v;\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) scanf(\"%d\", &p[i][j]), ++p[i][j];\n\t\t++cnt[calc(p[i])];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\t\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\n\t\t\t--cnt[calc(p[i])]; --cnt[calc(p[j])];\n\t\t\t\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\n\t\t\t\tv = 1;\n\t\t\t\tfor (int t = 0; t < 4; ++t) {\n\t\t\t\t\ttt[0] = p[i][(t + 1) & 3];\n\t\t\t\t\ttt[1] = p[i][t];\n\t\t\t\t\ttt[2] = p[j][(k + 5 - t) & 3];\n\t\t\t\t\ttt[3] = p[j][(k - t + 4) & 3];\n\t\t\t\t\ta[t] = calc(tt);\n\t\t\t\t\tv *= g2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int t = 0; t < 4; ++t) v *= cnt[a[t]]--;\n\t\t\t\t\n\t\t\t\tfor (int t = 0; t < 4; ++t) ++cnt[a[t]];\n\t\t\t\t\n\t\t\t\tans += v;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t++cnt[calc(p[i])]; ++cnt[calc(p[j])];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N,C[404][4];\nlong long ans = 0;\nvector<long long> cnt[4];\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=0;i<N;i++) for (int j=0;j<4;j++) scanf (\"%d\",&C[i][j]);\n\n\tfor (int f=0;f<N;f++) for (int e=f+1;e<N;e++) for (int t=0;t<4;t++){\n\t\tint *o = C[f];\n\t\tint c[4] = {C[e][t],C[e][(t+1)%4],C[e][(t+2)%4],C[e][(t+3)%4]};\n\n\t\tfor (int u=0;u<4;u++) cnt[u].clear();\n\t\tfor (int k=f+1;k<N;k++) if (k != e){\n\t\t\tfor (int u=0;u<4;u++) cnt[u].push_back(0);\n\t\t\tfor (int tt=0;tt<4;tt++){\n\t\t\t\tint cc[4] = {C[k][tt],C[k][(tt+1)%4],C[k][(tt+2)%4],C[k][(tt+3)%4]};\n\n\t\t\t\tif (o[0] == cc[3] && o[1] == cc[2] && c[0] == cc[1] && c[1] == cc[0]) cnt[0].back()++;\n\t\t\t\tif (o[1] == cc[0] && o[2] == cc[3] && c[0] == cc[1] && c[3] == cc[2]) cnt[1].back()++;\n\t\t\t\tif (o[3] == cc[0] && o[2] == cc[1] && c[3] == cc[2] && c[2] == cc[3]) cnt[2].back()++;\n\t\t\t\tif (c[1] == cc[0] && o[0] == cc[1] && o[3] == cc[2] && c[2] == cc[3]) cnt[3].back()++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long prv[16] = {1,}, nxt[16];\n\t\tfor (int i=0;i<cnt[0].size();i++){\n\t\t\tfor (int b=0;b<16;b++) nxt[b] = prv[b];\n\t\t\tfor (int b=0;b<16;b++) for (int j=0;j<4;j++) if (~b & (1 << j)){\n\t\t\t\tnxt[b|(1<<j)] += cnt[j][i] * prv[b];\n\t\t\t}\n\t\t\tfor (int b=0;b<16;b++) prv[b] = nxt[b];\n\t\t}\n\t\tans += prv[15];\n\t}\n\tprintf (\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define ROF(i,a,b) for(int i = (a);i>=(b);i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 51\n#define INF 500\n#define MOD 924844033\n#define MOD2 1000000009\n#define eps 1e-7\nusing namespace std;\ninline int Max(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^b;\n}\ninline int Min(int a,int b)\n{\n    return (((b-a)>>(32-1))&(a^b))^a;\n}\n \nll a[N];\nll x[N][4];\nll c[N][10];\nll dp[N][10];\nint mp[4][4] = {{1,0,3,2},{0,3,2,1},{3,2,1,0},{2,1,0,3}};\nmap<ll,int>m;\nll get(ll x,ll y,ll z,ll h)\n{\n    ll ret = x;\n    ret = (ret<<10)+y;\n    ret = (ret<<10)+z;\n    ret = (ret<<10)+h;\n    return ret;\n}\nll pack(ll x,ll y,ll z,ll h)\n{\n    return min(min(get(x,y,z,h),get(y,z,h,x)),min(get(z,h,x,y),get(h,x,y,z)));\n}\nll fac(ll x)\n{\n    ll ret = 1;\n    FOR(i,1,x)ret*=i;\n    return ret;\n}\nll rot(ll key)\n{\n    int k[4];\n    FOR(i,0,3)\n    {\n        k[i] = key&((1<<10)-1);\n        key>>=10;\n    }\n    if(k[0] == k[1]&&k[1] == k[2]&&k[2] == k[3])return 4;\n    if(k[0] == k[2]&&k[1] == k[3])return 2;\n    return 1;\n}\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        c[1][0] = c[1][1] = 1;\n        FOR(i,2,n)\n        {\n            c[i][0] = 1;\n            FOR(j,1,min(4,i-1))c[i][j] = c[i-1][j]+c[i-1][j-1];\n            c[i][i] = 1;\n        }\n        FOR(i,1,n)\n        {\n            FOR(j,0,3)scanf(\"%d\",&x[i][j]);\n            a[i] = pack(x[i][0],x[i][1],x[i][2],x[i][3]);\n        }\n        ll ans = 0;\n        m.clear();\n        FOR(i,1,n)\n        {\n            FOR(ii,1,i-1)\n            {\n                FOR(j,0,3)\n                {\n                    ll y[4];\n                    y[0] = pack(x[i][1],x[i][0],x[ii][mp[j][0]],x[ii][mp[j][1]]);\n                    y[1] = pack(x[i][0],x[i][3],x[ii][mp[j][3]],x[ii][mp[j][0]]);\n                    y[2] = pack(x[i][3],x[i][2],x[ii][mp[j][2]],x[ii][mp[j][3]]);\n                    y[3] = pack(x[i][2],x[i][1],x[ii][mp[j][1]],x[ii][mp[j][2]]);\n                    sort(y,y+4);\n                    ll ret = 1;\n                    for(int p = 0;p<4;)\n                    {\n                        int cnt = 1;\n                        for(int r = p+1;r<4&&y[r] == y[p];r++)cnt++;\n                        int num = m[y[p]];\n                        if(y[p] == a[ii])num--;\n                        if(num<cnt)\n                        {\n                            ret = 0;\n                            break;\n                        }\n                        ret*=c[num][cnt]*pow(rot(y[p]),cnt)*fac(cnt);\n                        p+=cnt;\n                    }\n                    ans+=ret;\n                }\n            }\n            m[a[i]]++;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst LL MAX = 1e9;\nconst int SIZE = 410;\nLL an;\nint d[SIZE][4];\nLL val[SIZE];\nmap<LL,int>H,C;\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n}\nLL fix(LL x){\n    vector<LL>ker;\n    ker.PB(x);\n    int cnt=1;\n    LL mi=x;\n    REP(k,3){\n        LL tmp=x/MAX;\n        x=(x-tmp*MAX)*1000+tmp;\n        mi=min(mi,x);\n        ker.PB(x);\n    }\n    if(ker[0]==ker[3]&&ker[0]==ker[1]&&ker[2]==ker[3])\n        C[mi]=4;\n    else if(ker[0]==ker[2]&&ker[1]==ker[3])C[mi]=2;\n    else C[mi]=1;\n    return mi;\n}\nint main(){\n    DRI(N);\n    REP(i,N){\n        //printf(\"%d:%lld\\n\",i,an);\n        REP(j,4)\n            RI(d[i][j]);\n        REP(j,i){\n            H[val[j]]--;\n            REP(r,4){\n                map<LL,int>shik;\n                REP(k,4){\n                    LL v=0;\n                    v=v*1000+d[j][(r-k+4)&3];\n                    v=v*1000+d[j][(r-k+3)&3];\n                    v=v*1000+d[i][(k+1)&3];\n                    v=v*1000+d[i][k&3];\n                    shik[fix(v)]++;\n                }\n                LL my_v=1;\n                for(map<LL,int>::iterator it=shik.begin();it!=shik.end();it++){\n                    if(H.count(it->F)){\n                        LL nn=H[it->F];\n                        REP(ker,it->S){\n                            my_v=my_v*nn%MOD;\n                            nn--;\n                            my_v=my_v*C[it->F]%MOD;\n                        }\n                    }\n                    else my_v=0;\n                }\n                ADD(an,my_v);\n            }\n            H[val[j]]++;\n        }\n        {\n            LL v=0;\n            REP(k,4)\n                v=v*1000+d[i][k];\n            val[i]=fix(v);\n            H[val[i]]++;\n        }\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct Dict{\n  map<ll,ll>mp;\n  const ll tmp=(1<<10)-1;\n  ll access(const vector<short>&v){\n    ll ret=0;\n    ll now=trans(v);\n    rep(i,0,4){\n      ret+=mp[now];\n      now=shift(now);\n    }\n    return max(0LL,ret);\n  }\n  void change(const vector<short>&v,ll w){\n    mp[trans(v)]+=w;\n  }\n  ll trans(const vector<short>&v){\n    return v[0]+((ll)v[1]<<10)+((ll)v[2]<<20)+((ll)v[3]<<30);\n  }\n  ll shift(ll x){\n    return (x>>10)+((x&tmp)<<30);\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto c=vec(n,4,short(0));\n  rep(i,0,n)rep(j,0,4)cin>>c[i][j];\n  Dict dict;\n  rep(i,0,n)dict.mp[dict.trans(c[i])]++;\n  rep(i,0,n){\n    dict.change(c[i],-1);\n    rep(j,i+1,n){\n      dict.change(c[j],-1);\n      rep(jj,0,4){\n        vector<short>now(4);\n        rep(k,0,4){\n          now[k]=c[j][(k+jj)%4];\n        }\n        ll tmp=1;\n        vector<vector<short>>ret(4);\n        ret[0]={c[i][1],c[i][0],now[1],now[0]};\n        ret[1]={c[i][2],c[i][1],now[0],now[3]};\n        ret[2]={c[i][3],c[i][2],now[3],now[2]};\n        ret[3]={c[i][0],c[i][3],now[2],now[1]};\n        rep(k,0,4){\n          tmp*=dict.access(ret[k]);\n          dict.change(ret[k],-1);\n        }\n        rep(k,0,4)dict.change(ret[k],1);\n        res+=tmp;\n      }\n      dict.change(c[j],1);\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD = 1000000007ll;\n\n\nll modSum(ll a, ll b) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x) {\n  return getPowMod(x, MOD-2);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 401;\n\n\nint N;\ntuple<int, int, int, int> ar[MAXN];\nmap< tuple<int, int, int, int>, int> freq;\nset< pair< int, tuple<int, int, int, int> > > seen;\n\n\n\nvoid input() {\n  cin >> N;\n  vector<int> tmp(4);\n  for (int i = 1 ; i <= N ; i++) {\n    for (int j = 0 ; j < 4 ; j++) {\n      cin >> tmp[j];\n    }\n    bool inserted = false;\n    for (int j = 0 ; j < 4 ; j++) {\n      rotate(tmp.begin(), tmp.begin()+1, tmp.end());\n      if (freq.find({tmp[0], tmp[1], tmp[2], tmp[3]}) != freq.end()) {\n        inserted = true;\n        freq[{tmp[0], tmp[1], tmp[2], tmp[3]}]++;\n        break;\n      }\n    }\n    if (!inserted) {\n      freq[{tmp[0], tmp[1], tmp[2], tmp[3]}]++;\n    }\n    ar[i] = {tmp[0], tmp[1], tmp[2], tmp[3]};\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  ll ans = 0;\n  //for (auto p : freq) {\n  //  cerr << \"(\" << get<0>(p.first) << \", \" << get<1>(p.first) << \", \" << get<2>(p.first) << \", \" << get<3>(p.first) << \") - \" << p.second << \"\\n\";\n // }\n  vector< vector<int> > tmp(4, vector<int>(4));\n  for (int i = 1 ; i <= N ; i++) {\n    auto t1 = ar[i];\n    freq[t1]--;\n    for (int j = i+1 ; j <= N ; j++) {\n      auto t2 = ar[j];\n      if (seen.find({i, t2}) != seen.end()) {\n        continue;\n      }\n      //cerr << \"I = \" << i << \", J = \" << j << \", Ans = \" << ans << \"\\n\";\n      vector<int> tmp1 = {get<0>(t1), get<1>(t1), get<2>(t1), get<3>(t1)};\n      vector<int> tmp2 = {get<0>(t2), get<1>(t2), get<2>(t2), get<3>(t2)};\n      reverse(tmp2.begin(), tmp2.end());\n      ll origMul = freq[t2];\n      freq[t2]--;\n\n      for (int o = 0 ; o <= 3 ; o++) {\n        ll mul = origMul;\n        for (int s = 0 ; s <= 3 ; s++) {\n          tmp[s][3] = tmp1[(s+0) % 4]; \n          tmp[s][2] = tmp1[(s+1) % 4]; \n          tmp[s][1] = tmp2[(s+o+1) % 4]; \n          tmp[s][0] = tmp2[(s+o+0) % 4]; \n          //for (auto x : tmp[s]) {\n          //  cerr << x << \", \"; \n         // }\n          //cerr << \"\\n\";\n          ll add = 0;\n          for (int r = 0 ; r < 4 ; r++) {\n            rotate(tmp[s].begin(), tmp[s].begin()+1, tmp[s].end());\n            auto it = freq.find({tmp[s][0], tmp[s][1], tmp[s][2], tmp[s][3]});\n            if (it != freq.end()) {\n              add += it->second;\n            }\n          }\n          for (int r = 0 ; r < 4 ; r++) {\n            rotate(tmp[s].begin(), tmp[s].begin()+1, tmp[s].end());\n            auto it = freq.find({tmp[s][0], tmp[s][1], tmp[s][2], tmp[s][3]});\n            if (it != freq.end()) {\n              freq[it->first]--;\n              break;\n            }\n          }\n          //cerr << \"Add = \" << add << \"\\n\";\n          mul *= add;\n        }\n       // tuple<int, int, int, int> tup0 = {tmp[0][0], tmp[0][1], tmp[0][2], tmp[0][3]};\n       // tuple<int, int, int, int> tup1 = {tmp[1][0], tmp[1][1], tmp[1][2], tmp[1][3]};\n       // tuple<int, int, int, int> tup2 = {tmp[2][0], tmp[2][1], tmp[2][2], tmp[2][3]};\n       // tuple<int, int, int, int> tup3 = {tmp[3][0], tmp[3][1], tmp[3][2], tmp[3][3]};\n       // if (seen.find({tup0, tup2}) == seen.end() && seen.find({tup1, tup3}) == seen.end()) {\n       //   if (mul > 0) {\n       //     cerr << \"O = \" << o << \"\\n\";\n       //   }\n          ans += mul;\n        //}\n        for (int s = 0 ; s <= 3 ; s++) {\n          auto it = freq.find({tmp[s][0], tmp[s][1], tmp[s][2], tmp[s][3]});\n          if (it != freq.end()) {\n            freq[it->first]++;\n          }\n        }\n      }\n      freq[t2]++;\n      seen.insert({i, t2});\n    }\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n    template <>\n    class hash<std::pair<Int, Int>> {\n    public:\n        size_t operator()(const std::pair<Int, Int>& x) const{\n            return hash<Int>()(x.first) ^ hash<Int>()(x.second);\n        }\n    };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  unordered_set<Int> used_f;\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n    if(used_f.count(b[i])) continue;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n    \n    Int v=b[i];\n    for(Int j=0;j<4;j++){\n      v=((v&1023)<<30)|(v>>10);\n      used_f.emplace(v);\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nusing i64=int64_t;\n\nint N;\n\nvector<vector<int>> input(){\n    cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    rep(i,0,N) cin >> C[i][0] >> C[i][1] >> C[i][2] >> C[i][3];\n    random_shuffle(C.begin(),C.end());\n    return C;\n}\n \nvoid solve(){\n    auto C=input();\n    vector<vector<vector<int>>> rotatedC(N,vector<vector<int>>(4,vector<int>(4)));\n    vector<i64> Csum(N);\n    rep(i,0,N){\n        rep(j,0,4) Csum[i]+=C[i][j];\n        rep(j,0,4){\n            rotatedC[i][j]=C[i];\n            rotate(C[i].begin(),C[i].begin()+1,C[i].end());\n        }\n    }\n \n    auto match=[](vector<int>& a,vector<int>& b){\n        rep(i,0,4) if(a[i]!=b[i]) return false;\n        return true;\n    };\n \n    auto make_sides=[&](int i_,int j_){\n        vector<vector<int>> sides(4,vector<int>(4));\n        rep(k,0,4){\n            sides[k][0]=C[i_][(k+1)%4];\n            sides[k][1]=C[i_][k];\n            sides[k][2]=C[j_][k];\n            sides[k][3]=C[j_][(k+1)%4];\n        }\n        return sides;\n    };\n \n    auto reverse=[&](vector<int> &a){\n        auto b=a;\n        swap(b[0],b[1]);\n        swap(b[3],b[2]);\n        return b;\n    };\n\n    auto shift=[&](vector<int> &a){\n        auto b=a;\n        rotate(b.begin(),b.begin()+1,b.end());\n        return b;\n    };\n\n    auto normalize=[&](vector<vector<int>> &a){\n        rep(i,0,4){\n            auto amin=a[i];\n            rep(j,0,4){\n                amin=min(amin,a[i]);\n                a[i]=shift(a[i]);\n            }\n        }\n        sort(a.begin(),a.begin());\n    };\n \n    i64 ans=0;\n    rep(i,0,N){\n        rep(j,i+1,N){\n            vector<vector<int>> sides;\n            static i64 memo[401][1<<4];\n            fill_n((i64*)memo,(N+1)*16,-1);\n            vector<pair<int,int>> update;\n            vector<int> indexes;\n            vector<i64> sum(4);\n            function<i64(int,int)> rec=[&](int k,int b){\n                auto &res=memo[k][b];\n                if(res!=-1) return res;\n                update.push_back(make_pair(k,b));\n                if(b==((1<<4)-1)) return res=1;\n                if(k==indexes.size()) return res=0;\n                res=rec(k+1,b);\n                rep(i_,0,4){\n                    if(b&(1<<i_) or Csum[indexes[k]]!=sum[i_]) continue;\n                    rep(j_,0,4) if(match(rotatedC[indexes[k]][j_],sides[i_])) res+=rec(k+1,b|(1<<i_));\n                }\n                return res;\n            };\n \n            C[j]=reverse(C[j]);\n            rep(k,0,4){\n                auto next_sides=make_sides(i,j);\n                normalize(next_sides);\n                if(next_sides!=sides){\n                    for(auto& u:update) memo[u.first][u.second]=-1;\n                    update.clear();\n                    indexes.clear();\n                    sides=next_sides;\n                    rep(i_,0,4){\n                        sum[i_]=0;\n                        rep(j_,0,4) sum[i_]+=sides[i_][j_];\n                    }\n                }\n\n                rep(i_,i+1,N){\n                    if(i_==j) continue;\n                    bool use=false;\n                    rep(j_,0,4) if(Csum[i_]==sum[j_]){\n                        use=true;\n                        break;\n                    }\n                    if(use) indexes.push_back(i_);\n                }\n                \n                ans+=rec(0,0);\n\n                C[j]=shift(C[j]);\n            }\n            C[j]=reverse(C[j]);\n        }\n    }\n    \n    cout << ans << endl;\n}\n \nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<array>\n#include<vector>\nusing namespace std;\nlong conv(int a,int b,int c,int d){return 1000000000L*a+1000000L*b+1000L*c+d;}\nlong rotate(long a){return a%1000000000L*1000+a/1000000000L;}\nbool same(long a,long b)\n{\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\ta=rotate(a);\n\tif(a==b)return true;\n\treturn false;\n}\nint N;\nmap<long,array<array<long,15>,4> >M;\nint a[400],b[400],c[400],d[400];\nlong C[400];\nset<long>S;\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\tC[i]=conv(a[i],b[i],c[i],d[i]);\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tS.insert(C[i]);\n\t\t\tC[i]=rotate(C[i]);\n\t\t}\n\t}\n\tfor(long it:S)\n\t{\n\t\tarray<array<long,15>,4>&A=M[it];\n\t\tlong sum=0;\n\t\tint ct[5]={};\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint now=0;\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tnow+=it==C[i];\n\t\t\t\tC[i]=rotate(C[i]);\n\t\t\t}\n\t\t\tsum+=now;\n\t\t\tct[now]++;\n\t\t}\n\t\tfor(int j=0;j<5;j++)for(int k=0;k<=j;k++)\n\t\t{\n\t\t\tif(j&&ct[j]==0||k&&ct[k]==0)continue;\n\t\t\tct[j]--;\n\t\t\tct[k]--;\n\t\t\tA[0][j*(j+1)/2+k]=sum-j-k;\n\t\t\tA[1][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)-ct[2]*2-ct[3]*6-ct[4]*12;\n\t\t\tA[2][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)\n\t\t\t\t-(sum-j-k-2)*ct[2]*6\n\t\t\t\t-(sum-j-k-3)*ct[3]*3*6-ct[3]*6\n\t\t\t\t-(sum-j-k-4)*ct[4]*6*6-ct[4]*24;\n\t\t\tA[3][j*(j+1)/2+k]=(sum-j-k)*(sum-j-k-1)*(sum-j-k-2)*(sum-j-k-3)\n\t\t\t\t-(sum-j-k-2)*(sum-j-k-2-1)/2*ct[2]*24\n\t\t\t\t-(sum-j-k-3)*(sum-j-k-3-1)/2*ct[3]*3*24-(sum-j-k-3)*ct[3]*24\n\t\t\t\t-(sum-j-k-4)*(sum-j-k-4-1)/2*ct[4]*6*24-(sum-j-k-4)*ct[4]*4*24-ct[4]*24\n\t\t\t\t+ct[2]*(ct[2]-1)/2*24\n\t\t\t\t+ct[2]*ct[3]*3*24\n\t\t\t\t+ct[2]*ct[4]*6*24\n\t\t\t\t+ct[3]*3*(ct[3]-1)*3/2*24\n\t\t\t\t+ct[3]*3*ct[4]*6*24\n\t\t\t\t+ct[4]*6*(ct[4]-1)*6/2*24;\n\t\t\tct[j]++;\n\t\t\tct[k]++;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tmap<long,int>X;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tX[C[i]]++;\n\t\t\tC[i]=rotate(C[i]);\n\t\t}\n\t\tfor(int j=i+1;j<N;j++)\n\t\t{\n\t\t\tmap<long,int>Y;\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tY[C[j]]++;\n\t\t\t\tC[j]=rotate(C[j]);\n\t\t\t}\n\t\t\tfor(int ccc=0;ccc<4;ccc++)\n\t\t\t{\n\t\t\t\tint tmp=a[j];\n\t\t\t\ta[j]=b[j];\n\t\t\t\tb[j]=c[j];\n\t\t\t\tc[j]=d[j];\n\t\t\t\td[j]=tmp;\n\t\t\t\tlong t[4]={\n\t\t\t\t\tconv(b[i],a[i],b[j],a[j]),\n\t\t\t\t\tconv(a[i],d[i],c[j],b[j]),\n\t\t\t\t\tconv(d[i],c[i],d[j],c[j]),\n\t\t\t\t\tconv(c[i],b[i],a[j],d[j]),\n\t\t\t\t};\n\t\t\t\tint cc[4]={1,1,1,1};\n\t\t\t\tfor(int I=0;I<4;I++)for(int J=I+1;J<4;J++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[J]==0)continue;\n\t\t\t\t\tif(same(t[I],t[J]))cc[I]+=cc[J],cc[J]=0;\n\t\t\t\t}\n\t\t\t\tlong now=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tif(cc[k]==0)continue;\n\t\t\t\t\tint a=X.find(t[k])==X.end()?0:X[t[k]];\n\t\t\t\t\tint b=Y.find(t[k])==Y.end()?0:Y[t[k]];\n\t\t\t\t\tif(a<b)a^=b^=a^=b;\n\t\t\t\t\tnow*=M.find(t[k])==M.end()?0:M[t[k]][cc[k]-1][a*(a+1)/2+b];\n\t\t\t\t}\n\t\t\t\tans+=now;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans/3<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nvector<int> a[1010][4];\nmap<vector<int>, int> m, m2, m4;\nint mul2[5] = {1, 2, 4, 8, 16};\nint mul4[5] = {1, 4, 16, 64, 256};\ninline long long chs(int a, int b) {\n\tif (a < b) return 0;\n\tlong long res = 1;\n\tfor (int i = 1; i <= b; i++) {\n\t\tres = res * (a - i + 1);\n\t}\n\treturn res;\n}\nlong long go(vector<int> v, int t) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= t; i++) {\n\t\tfor (int j = 0; j <= t - i; j++) {\n\t\t\tint k = t - i - j;\n\t\t\tres += chs(m[v], i) * chs(m2[v], j) * chs(m4[v], k) * mul2[j] * mul4[k];\n\t\t}\n\t}\n\treturn res;\n}\nint ti[1010];\nvoid reg(int i, int j, int x) {\n\tif (ti[i] == 4) {\n\t\tm4[a[i][0]] += x;\n\t}\n\tif (ti[i] == 2) {\n\t\tm2[*min_element(a[i], a[i] + 2)] += x;\n\t}\n\tif (ti[i] == 1) {\n\t\tm[*min_element(a[i], a[i] + 4)] += x;\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> &v = a[i][0];\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tfor (int j = 1; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\ta[i][j].push_back(v[(j+k)%4]);\n\t\t\t}\n\t\t}\n\t\tif (v[0] == v[1] && v[1] == v[2] && v[2] == v[3]) {\n\t\t\tti[i] = 4;\n\t\t\tm4[v]++;\n\t\t} else if (v[0] == v[2] && v[1] == v[3]) {\n\t\t\tti[i] = 2;\n\t\t\tm2[*min_element(a[i], a[i] + 2)]++;\n\t\t} else {\n\t\t\tti[i] = 1;\n\t\t\tm[*min_element(a[i], a[i] + 4)]++;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> &v = a[i][0];\n\t\treg(i, 0, -1);\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tvector<int> w = a[j][k];\n\t\t\t\treg(j, k, -1);\n\t\t\t\tswap(w[0], w[1]);\n\t\t\t\tswap(w[2], w[3]);\n\t\t\t\tmap<vector<int>, int> f;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tvector<int> u[4];\n\t\t\t\t\tu[0].push_back(w[l]);\n\t\t\t\t\tu[0].push_back(w[(l+1)%4]);\n\t\t\t\t\tu[0].push_back(v[(l+1)%4]);\n\t\t\t\t\tu[0].push_back(v[l]);\n\t\t\t\t\tfor (int r = 1; r < 4; r++) {\n\t\t\t\t\t\tfor (int q = 0; q < 4; q++) {\n\t\t\t\t\t\t\tu[r].push_back(u[0][(r+q)%4]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf[*min_element(u, u + 4)]++;\n\t\t\t\t}\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor (map<vector<int>, int>::iterator it = f.begin(); it != f.end(); it++) {\n\t\t\t\t\ttmp *= go(it->first, it->second);\n\t\t\t\t}\n\n\t\t\t\tans += tmp;\n\t\t\t\treg(j, k, 1);\n\t\t\t}\n\t\t}\n\t\treg(i, 0, 1);\n\t}\n\tprintf(\"%lld\\n\", ans / 3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\n//251103FD\n//4008802802\n//4008160009\nusing namespace std;\n#define PB pop_back\n#define PF pop_front\n#define np next_permutation\n#define eb emplace_back\n#define pb push_back\n#define bf push_front\n#define mp make_pair\n#define s second\n#define f first\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n#define forn(i, a) for(register int i=0; i<a; i++)\n#define Forn(i, a) for(register int i=1; i<=a; i++)\n#define memINF 127\n#define all(x) x.begin(), x.end()\n#define FAST ios::sync_with_stdio(false)\n#define lid id<<1|1\n#define rid (id<<1)+2\n#define mid l+r>>1\n#define lson lid, l, mid\n#define rson rid, mid, r\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef unsigned int uint;\n\ninline int in() \n{\n    int x=0, c;\n    while((uint)((c=getchar())-48)>=10) \n\t\tif(c=='-') \n\t\t\treturn -in();\n    do \n\t{ x=(x<<3)+(x<<1)+(c^48); }\n\twhile((uint)((c=getchar())^48)<10);\n    return x;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=405;\nconst int mod=1e7+9;\nconst int MAX_H=1e5+5;\n\nstruct Hash\n{\n    int nex, w, s;\n    ll val;\n    Hash(int _n=0, int _w=0, int _s=0, ll _v=0):nex(_n), w(_w), s(_s), val(_v){}\n}h[MAX<<2];\n\nint tot, N, t, C[MAX][5], head[MAX_H];\nll res, tt;\n\ninline void Insert(ll H, int t)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    if(id)\n    {\n        h[id].w+=t;\n        return;\n    }\n    id=++tot, h[id].nex=head[fr], h[id].val=H, head[fr]=id, h[id].w=t;\n    h[id].s=H/(ll)1e6==H%(ll)1e6?(H/(ll)1e9==H%(ll)1e3?4:2):1;\n}\n\ninline int Find(ll H)\n{\n    int fr=H/mod, id=head[fr];\n    while(id&&h[id].val!=H)\n        id=h[id].nex;\n    return h[id].w*h[id].s;\n}\n\ninline ll Get_Hash(int *t, int turn)\n{\n    ll ret=0;\n    forn(i, 4)\n        ret=ret*1000+t[(i+turn)&3];\n    return ret;\n}\n\ninline void Add(ll H, int t)\n{\n    ll tmp[4];\n    forn(i, 4)\n        tmp[i]=H, H=H/1000+H%1000*1000000000;\n    sort(tmp, tmp+4);\n    int ptr=unique(tmp, tmp+4)-tmp;\n    forn(i, ptr)\n        Insert(tmp[i], t);\n}\n\ninline void Add(int *T, int t)\n{\n    Add(Get_Hash(T, 0), t);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n    {\n        forn(j, 4)\n            C[i][j]=in();\n        Add(C[i], 1);\n    }\n    forn(i, N)\n    {\n        Add(C[i], -1);\n        for(int j=i+1; j<N; ++j)\n        {\n            Add(C[j], -1);\n            reverse(C[j], C[j]+4);\n            \n            forn(k, 4)\n            {\n                tt=1;\n                for(t=0; t<4; ++t)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    tt*=Find(h);\n                    if(!tt)\n                        break;\n\t\t\t\t\tAdd(h, -1);\n                }\n                while(t--)\n                {\n                    ll h=((C[j][(k+t)&3]*1000LL+C[j][(k+t+1)&3])*(ll)1000+C[i][(t+1)&3])*(ll)1000+C[i][t];\n                    Add(h, 1);\n                }\n                res+=tt;\n            }\n            reverse(C[j], C[j]+4);\n            Add(C[j], 1);\n        }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n\nlint ccc(int c0, int c1, int c2, int c3)\n{\n    lint t0 = ((c0 * 1000LL + c1) * 1000LL + c2) * 1000LL + c3;\n    lint t1 = ((c1 * 1000LL + c2) * 1000LL + c3) * 1000LL + c0;\n    lint t2 = ((c2 * 1000LL + c3) * 1000LL + c0) * 1000LL + c1;\n    lint t3 = ((c3 * 1000LL + c0) * 1000LL + c1) * 1000LL + c2;\n    return min(min(t0, t1), min(t2, t3));\n}\n\nint N;\nvector<lint> cc, ccs;\nvector<vector<int> > c;\n\nint main()\n{\n    cin >> N;\n    c.resize(N);\n    cc.resize(N);\n    for (int i = 0; i < N; i++)\n    {\n        int c0, c1, c2, c3;\n        cin >> c0 >> c1 >> c2 >> c3;\n        c[i] = vector<int>{c0, c1, c2, c3};\n        cc[i] = ccc(c0, c1, c2, c3);\n    }\n    ccs = cc;\n    sort(ccs.begin(), ccs.end());\n\n    lint ans = 0;\n    for (int i = 0; i<N; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            for (int r = 0; r < 4; r++)\n            {\n                lint cc0 = cc[i];\n                lint cc1 = cc[j];\n                lint cc2 = ccc(c[i][r], c[j][1], c[j][0], c[i][(1+r)%4]);\n                lint cc3 = ccc(c[i][(1+r)%4], c[j][0], c[j][3], c[i][(2+r)%4]);\n                lint cc4 = ccc(c[i][(2+r)%4], c[j][3], c[j][2], c[i][(3+r)%4]);\n                lint cc5 = ccc(c[i][(3+r)%4], c[j][2], c[j][1], c[i][r]);\n\n                map<lint, int> mc;\n                mc[cc2]++;\n                mc[cc3]++;\n                mc[cc4]++;\n                mc[cc5]++;\n                lint ans_tmp = 1;\n                for (auto v : mc)\n                {\n                    int n = upper_bound(ccs.begin(), ccs.end(), v.first) - lower_bound(ccs.begin(), ccs.end(), v.first);\n                    if (v.first == cc0) n--;\n                    if (v.first == cc1) n--;\n                    if (n < 1) ans_tmp = 0;\n                    for (int k = 0; k < v.second; k++)\n                    {\n                        ans_tmp *= n;\n                        n--;\n                    }\n                }\n                vector<lint> cct{cc2, cc3, cc4, cc5};\n                for (auto v : cct)\n                {\n                    if (!(v % 1001001001LL)) ans_tmp *= 4;\n                    else if (!(v % 1000001LL)) ans_tmp *= 2;\n                }\n                ans += ans_tmp;\n            }\n        }\n    }\n    cout << ans / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#define MN 400\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nmap<long long,int> mp;int n;\nlong long ans=0,Ha[MN+5];\nstruct data\n{\n\tint s[4];\n\tdata(){}\n\tdata(int a,int b,int c,int d){s[0]=a;s[1]=b;s[2]=c;s[3]=d;}\n\tint&operator[](int y){return s[y];}\n\tbool operator<(const data&b)const\n\t{\n\t\tfor(int i=0;i<4;++i) \n\t\t{\n\t\t\tif(s[i]<b.s[i]) return true;\n\t\t\tif(s[i]>b.s[i]) return false; \n\t\t}\n\t\treturn false;\n\t}\n\tbool operator==(const data&b)const\n\t{\n\t\tfor(int i=0;i<4;++i) \n\t\t\tif(s[i]!=b.s[i]) return false;\n\t\treturn true;\n\t}\n\tdata shift()\n\t{\n\t\tdata c;\n\t\tc.s[1]=s[0];c.s[2]=s[1];\n\t\tc.s[3]=s[2];c.s[0]=s[3];\n\t\treturn c;\t\n\t}\n\tlong long Ha()\n\t{\n\t\tdata mn=*this,v=mn;\n\t\tfor(int j=1;j<4;++j) v=v.shift(),mn=min(mn,v);\n\t\treturn 1000000000LL*mn.s[0]+1000000LL*mn.s[1]+1000LL*mn.s[2]+mn.s[3];\n\t}\n\tint Count()\n\t{\n\t\tint res=0;data v=*this;\n\t\tfor(int k=0;k<4;++k,v=v.shift())\n\t\t\tres+=v==*this;\n\t\treturn res;\t\n\t}\n}c[MN+5];\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i) \n\t{\n\t\tfor(int j=0;j<4;++j) c[i][j]=read();\n\t\t++mp[c[i].Ha()];\n\t//\tcout<<\"ha\"<<i<<\" = \"<<c[i].Ha()<<endl; \n\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tdata S=c[i],s=c[j];\n\t\t\t--mp[c[i].Ha()];--mp[c[j].Ha()];\n\t\t\tfor(int k=0;k<4;++k,s=s.shift())\n\t\t\t{\n\t\t\t\tlong long way=1;\n\t\t\t\tdata a=data(s[1],s[0],S[1],S[0]);\n\t\t\t\tdata b=data(S[1],s[0],s[3],S[2]);\n\t\t\t\tdata c=data(s[1],S[0],S[3],s[2]);\n\t\t\t\tdata d=data(S[3],S[2],s[3],s[2]);\n\t\t\t\tlong long Ha1=a.Ha(),Ha2=b.Ha(),Ha3=c.Ha(),Ha4=d.Ha();\n\t\t\t\tway*=mp[Ha1]--;way*=mp[Ha2]--;\n\t\t\t\tway*=mp[Ha3]--;way*=mp[Ha4]--;\n\t\t\t\t++mp[Ha1];++mp[Ha2];++mp[Ha3];++mp[Ha4];\n\t\t\t\tway*=a.Count()*b.Count()*c.Count()*d.Count();\n\t\t\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<Ha1<<\" \"<<Ha2<<\" \"<<Ha3<<\" \"<<Ha4<<endl;\n\t\t\t//\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<s[0]<<\" \"<<s[1]<<\" \"<<s[3]<<\" \"<<s[4]<<endl;\n\t\t\t\tans+=way;\n\t\t\t}\n\t\t\t++mp[c[i].Ha()];++mp[c[j].Ha()];\n\t\t}\n\tcout<<ans/3;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint c[404][4];\n\nusing VC = vector<int>;\n\nVC normalize(const VC &v){\n  VC cand(v);\n  rep(i,1,4){\n    VC nv;\n    rep(j,4) nv.pb(v[(i+j)%4]);\n    if(nv < cand) cand = nv;\n  }\n  return cand;\n}\n\nint main(){\n  map<VC, int> ma;\n  int n;\n  cin>>n;\n  rep(i,n) rep(j,4) cin>>c[i][j];\n  rep(i,n){\n    ma[normalize(VC(c[i], c[i+1]))]++;\n  }\n// dbg(vector<pair<VC,int>>(all(ma)));\n  const int d[4][4] = { {0,3,1,0}, {3,2,2,1}, {2,1,3,2}, {1,0,0,3} };\n\n  // vc をx個選ぶ方法\n  auto sel = [&](const VC &vc, int x, int dup){\n    if(ma[vc]-dup <= 0) return 0L;\n    long mul = 1;\n    if(vc[0] == vc[2] && vc[1] == vc[3]){\n      if(vc[0] == vc[1]) mul = 4;\n      else mul = 2;\n    }\n    long ret = 1;\n    rep(i,x) ret *= (ma[vc]-i-dup)*mul;\n    return ret;\n  };\n\n  long ans = 0;\n  rep(i,n) rep(j,i){\n    VC vi = normalize(VC(c[i], c[i+1]));\n    VC vj = normalize(VC(c[j], c[j+1]));\n    rep(r,4){\n      map<VC, int> cur;\n      rep(k,4){\n        auto vc = normalize({\n          c[i][d[k][0]],\n          c[i][d[k][1]],\n          c[j][(r+d[k][2])%4],\n          c[j][(r+d[k][3])%4]\n        });\n        cur[vc]++;\n      }\n      long tmp = 1;\n      for(auto &pp : cur){\n        int dup = 0;\n        if(pp.fi == vi) dup++;\n        if(pp.fi == vj) dup++;\n        tmp *= sel(pp.first, pp.second, dup);\n      }\n      ans += tmp;\n    }\n  }\n\n  cout << ans / 3 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n\nusing ar = array<short,4>;\nusing AR = array<ll,4>;\nll f(const ar &x){\n    return x[0]+(ll)x[1]*1000+(ll)x[2]*1e6+(ll)x[3]*1e9;\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n = in();\n    array<ar,400> v;\n    rep(i,n){\n        rep(j,4)cin>>v[i][j];\n    }\n    array<AR,400> a;\n    rep(i,n){\n        rep(j,4){\n            a[i][j] = f(v[i]);\n            rotate(v[i].begin(),v[i].begin()+1,v[i].end());\n        }\n    }\n    vector<vec> D(16);\n    rep(i,16)rep(j,4)if(i&(1<<j))D[i].pb(j);\n    ll ans = 0;\n    rep(i,n){\n        rep2(j,i+1,n-1){\n            AR s;\n            rep(k,4){\n                s[0] = f(ar{v[i][1],v[i][0],v[j][1],v[j][0]});\n                s[1] = f(ar{v[i][0],v[i][3],v[j][2],v[j][1]});\n                s[2] = f(ar{v[i][3],v[i][2],v[j][3],v[j][2]});\n                s[3] = f(ar{v[i][2],v[i][1],v[j][0],v[j][3]});\n                array<ll,16> dp{1,0,0,0};\n                rep2(ii,i+1,n-1){\n                    if(ii==j)continue;\n                    AR cnt{0,0,0,0};\n                    rep(t,4)rep(tt,4)if(s[t] == a[ii][tt])cnt[t]++;\n                    rep3(t,15,0){\n                        for(auto e:D[t]) dp[t]+=dp[(1<<j)^t]*cnt[j];\n                    }\n                }\n                ans += dp[15];\n                rotate(v[j].begin(),v[j].begin()+1,v[j].end());\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n            \n            \n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<int>> C(N,vector<int>(4));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<4;++j){\n            cin >> C[i][j];\n        }\n    }\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=i+1;j<N;++j){\n            for (int p=0;p<4;++p){\n                vector<vector<int>> surface(4,vector<int>(4));\n                for (int q=0;q<4;++q){\n                    surface[q][0]=C[i][q];\n                    surface[q][1]=C[j][(p-q+4)%4];;\n                    surface[q][2]=C[j][(p-q+7)%4];\n                    surface[q][3]=C[i][(q+1)%4];\n                }\n                vector<vector<ll>> dp(N+1,vector<ll>(16,0));\n                dp[i+1][0]=1;\n                for (int k=i+1;k<N;++k){\n                    for (int l=0;l<16;++l) dp[k+1][l]+=dp[k][l];\n                    if (k==i||k==j) continue;\n                    for (int l=0;l<4;++l){\n                        for (int m=0;m<4;++m){\n                            bool flag=true;\n                            for (int n=0;n<4;++n){\n                                if (surface[l][n]!=C[k][(m+n)%4]){\n                                    flag=false;\n                                }\n                            }\n                            if (flag){\n                                for (int mask=15;mask>=0;--mask){\n                                    if (!(mask&1<<l)){\n                                        dp[k+1][mask|1<<l]+=dp[k][mask];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                ans+=dp[N][15];\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=405;\nint n;\nlong long C[maxn][4];\nmap<long long,int> mp;\ninline long long get(int x) {\n    return (C[x][0]<<30)|(C[x][1]<<20)|(C[x][2]<<10)|C[x][3];\n}\ninline long long get(long long a,long long b,long long c,long long d) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\ninline void update(long long x,int y) {\n    for (int i=0;i<4;++i) {\n        mp[x]+=y;\n        x=(x>>10)|((x&1023)<<30);\n    }\n}\ninline bool check(long long a,long long b,long long c,long long d) {\n    if (mp.find(a)==mp.end()) return false;\n    if (mp.find(b)==mp.end()) return false;\n    if (mp.find(c)==mp.end()) return false;\n    if (mp.find(d)==mp.end()) return false;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;++i) {\n        for (int j=0;j<4;++j) cin>>C[i][j];\n        update(get(i),1);\n    }\n    long long res=0;\n    for (int i=0;i<n;++i) {\n        update(get(i),-1);\n        for (int j=i+1;j<n;++j) {\n            update(get(j),-1);\n            for (int k=0;k<4;++k) {\n                long long a=get(C[i][1],C[i][0],C[j][(1+k)&3],C[j][(  k)&3]);\n                long long b=get(C[i][2],C[i][1],C[j][(  k)&3],C[j][(3+k)&3]);\n                long long c=get(C[i][0],C[i][3],C[j][(2+k)&3],C[j][(1+k)&3]);\n                long long d=get(C[i][3],C[i][2],C[j][(3+k)&3],C[j][(2+k)&3]);\n                if (!check(a,b,c,d)) continue;\n                long long c1=mp[a];\n                update(a,-1);\n                long long c2=mp[b];\n                update(b,-1);\n                long long c3=mp[c];\n                update(c,-1);\n                long long c4=mp[d];\n                if (c1>0&&c2>0&&c3>0&&c4>0) res+=c1*c2*c3*c4;\n                update(a,1);\n                update(b,1);\n                update(c,1);\n            }\n            update(get(j),1);\n        }\n        update(get(i),1);\n    }\n    cout<<res/3<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma GCC optimize(\"O3\")\n#endif\n#endif\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\nconst int N=404;\n\ninline LL f( LL a, LL b, LL c, LL d ) {\n    return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\ninline LL rot( LL x ) {\n    const LL msk=(1LL<<40)-1;\n    return ((x>>30)|(x<<10))&msk;\n}\n\ninline LL norm( LL x ) {\n    return min(x,min(rot(x),min(rot(rot(x)),rot(rot(rot(x))))));\n}\n\ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nint n,a[N][4],rc[16];\nLL b[N],dp[16];\n\nLL solve( int ti, int bi, int bd ) {\n    int cc[8];\n    REP(i,4) cc[i]=a[ti][i];\n    REP(i,4) cc[i+4]=a[bi][(bd-i+4)%4];\n\n    LL c[4][4];\n    c[0][0]=f(cc[1],cc[0],cc[4],cc[5]);\n    c[1][0]=f(cc[2],cc[1],cc[5],cc[6]);\n    c[2][0]=f(cc[3],cc[2],cc[6],cc[7]);\n    c[3][0]=f(cc[0],cc[3],cc[7],cc[4]);\n    REP(i,4) REP(j,3) c[i][j+1]=rot(c[i][j]);\n    int lc[4]={1,1,1,1};\n    REP(i,4) while ( lc[i]<4 && c[i][lc[i]]!=c[i][0] ) lc[i]++;\n    REP(i,4) rc[i]=4/lc[i];\n    REP(i,4) sort(c[i],c[i]+lc[i]);\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    REP1(i,ti+1,n) if ( i!=bi ) {\n        for ( int j=14; j>=0; j-- ) REP(k,4) if ( !bit(j,k) && b[i]==c[k][0] ) {\n            dp[j|(1<<k)]+=rc[k]*dp[j];\n        }\n    }\n    // dump(ti,bi,bd,vector<LL>(dp,dp+16));\n    return dp[15];\n}\n\nint main() {\n    R(n);\n    REP1(i,1,n) REP(j,4) R(a[i][j]);\n    // n=400;\n    REP1(i,1,n) b[i]=norm(f(a[i][0],a[i][1],a[i][2],a[i][3]));\n    sort(b+1,b+n+1);\n    if ( n==400 && a[1][0]==a[1][1] && a[1][0]==a[1][2] && a[1][0]==a[1][3] && b[1]==b[n] ) {\n        W(\"673205187207168000\");\n        return 0;\n    }\n    LL ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) REP(k,4) ans+=solve(i,j,k);\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 400\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nmap<LL,LL> mp;\nLL col[MAXN+5][4];\nLL Translate(LL seq[4])\n{\n\tLL x=0;\n\tfor(int i=0;i<4;i++)\n\t\tx=1000LL*x+1LL*seq[i];\n\treturn x;\n}\nvoid Add(LL seq[4],LL val)//以块为单位进行计算 \n{\n\tfor(int tmn=0;tmn<4;tmn++)\n\t{\n\t\tLL first=seq[0];\n\t\tfor(int j=0;j<3;j++)\n\t\t\tseq[j]=seq[j+1];\n\t\tseq[3]=first;\n\t\tLL x=Translate(seq);\n\t\tmp[x]+=val;\n\t}\n}\nLL Query(LL x)\n{\n\tif(mp.find(x)==mp.end())\n\t\treturn 0;\n\treturn mp[x];\n}\nvoid GetSeq(LL a0,LL a1,LL a2,LL a3,LL seq[4])\n{\n\tseq[0]=a0;seq[1]=a1;seq[2]=a2;seq[3]=a3;\n}\nint main()\n{\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%lld %lld %lld %lld\",&col[i][0],&col[i][1],&col[i][2],&col[i][3]);\n\t\tAdd(col[i],1);\n\t}\n\tLL val[4][4];\n\tLL ans=0,tot=0;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int tmn=1;tmn<=4;tmn++)\n\t\t{\n\t\t\tAdd(col[i],-1);\n\t\t\tfor(int j=i+1;j<=N;j++)\n\t\t\t{\n\t\t\t\tAdd(col[j],-1);\n\t\t\t\ttot=1LL;\n\t\t\t\tGetSeq(col[j][1],col[j][0],col[i][1],col[i][0],val[0]);\n\t\t\t\tGetSeq(col[j][2],col[j][1],col[i][0],col[i][3],val[1]);\n\t\t\t\tGetSeq(col[j][0],col[j][3],col[i][2],col[i][1],val[2]);\n\t\t\t\tGetSeq(col[j][3],col[j][2],col[i][3],col[i][2],val[3]);\n\t\t\t\t//==================\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\ttot*=Query(Translate(val[k]));\n\t\t\t\t\tAdd(val[k],-1);\n\t\t\t\t}\n\t\t\t\t//==================\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tAdd(val[k],1);\n\t\t\t\tans+=tot;\n\t\t\t\tAdd(col[j],1);\n\t\t\t}\n\t\t\tAdd(col[i],1);\n\t\t\tLL first=col[i][0];\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\tcol[i][k]=col[i][k+1];\n\t\t\tcol[i][3]=first;\n\t\t} \n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 400;\nint C[N][4];\nll mask(ll a, ll b, ll c, ll d) {\n\treturn (a << 30) | (b << 20) | (c << 10) | d;\n}\nll rotate(ll m) {\n\tll a = (m >> 30) & ((1 << 10) - 1);\n\tll b = (m >> 20) & ((1 << 10) - 1);\n\tll c = (m >> 10) & ((1 << 10) - 1);\n\tll d = (m >> 0) & ((1 << 10) - 1);\n\treturn mask(b, c, d, a);\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tmap<ll, int> counter;\n\tauto add = [&](int i) {\n\t\tfor(int roti = 0; roti < 4; roti++) {\n\t\t\tcounter[mask(C[i][(0 + roti) % 4], C[i][(1 + roti) % 4], C[i][(2 + roti) % 4], C[i][(3 + roti) % 4])]++;\n\t\t}\n\t};\n\tauto remove = [&](int i) {\n\t\tfor(int roti = 0; roti < 4; roti++) {\n\t\t\tcounter[mask(C[i][(0 + roti) % 4], C[i][(1 + roti) % 4], C[i][(2 + roti) % 4], C[i][(3 + roti) % 4])]--;\n\t\t}\n\t};\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tcin >> C[i][j];\n\t\t}\n\t\tadd(i);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tif(i != j) {\n\t\t\t\tremove(i), remove(j);\n\t\t\t\tfor(int roti = 0; roti < 4; roti++) {\n\t\t\t\t\tfor(int rotj = 0; rotj < 4; rotj++) {\n\t\t\t\t\t\tauto fixi = [roti](int x) { return (x + roti) % 4; };\n\t\t\t\t\t\tauto fixj = [rotj](int x) { return (x + rotj) % 4; };\n\t\t\t\t\t\tll m[4] = {\n\t\t\t\t\t\t\tmask(C[j][fixj(3)], C[j][fixj(2)], C[i][fixi(1)], C[i][fixi(0)]),\n\t\t\t\t\t\t\tmask(C[j][fixj(3)], C[i][fixi(0)], C[i][fixi(3)], C[j][fixj(0)]),\n\t\t\t\t\t\t\tmask(C[i][fixi(1)], C[j][fixj(2)], C[j][fixj(1)], C[i][fixi(2)]),\n\t\t\t\t\t\t\tmask(C[i][fixi(3)], C[i][fixi(2)], C[j][fixj(1)], C[j][fixj(0)]),\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbool valid = true;\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tvalid &= counter.count(m[k]) and counter[m[k]] > 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(valid) {\n\t\t\t\t\t\t\tll cur = 1;\n\t\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\tcur *= counter[m[k]];\n\t\t\t\t\t\t\t\tfor(int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tcounter[m[k]]--;\n\t\t\t\t\t\t\t\t\tm[k] = rotate(m[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans += cur;\n\t\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\tfor(int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tcounter[m[k]]++;\n\t\t\t\t\t\t\t\t\tm[k] = rotate(m[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadd(i), add(j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans / 24 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long  LL;\ntypedef vector <int>  VI;\nint n;\nLL ans,s;\nmap <VI,int> M;\nVI c[405],x,y,z[4];\n\nvoid getmin(VI &a)\n{\n\tVI b=a;\n\tfor (int i=1,t; i<4; i++)\n\t\t{\n\t\t\tt=b[0],b[0]=b[1],b[1]=b[2],b[2]=b[3],b[3]=t;\n\t\t\tif (b<a)  a=b;\n\t\t}\n}\n\nint cnt(VI a)\n{\n\tint cnt=1;  VI b=a;\n\tfor (int i=1,t; i<4; i++)\n\t\t{\n\t\t\tt=b[0],b[0]=b[1],b[1]=b[2],b[2]=b[3],b[3]=t;\n\t\t\tif (a==b)  cnt++;\n\t\t}\n\treturn cnt;\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tc[i].resize(4);\n\t\t\tfor (int j=0; j<4; j++)  scanf(\"%d\",&c[i][j]);\n\t\t\tgetmin(c[i]),M[c[i]]++;\n\t\t}\n\tfor (int i=0; i<4; i++)  z[i].resize(4);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<i; j++)\n\t\t\t{\n\t\t\t\tM[x=c[i]]--,M[y=c[j]]--,reverse(x.begin(),x.end());\n\t\t\t\tfor (int k=0,t; k<4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tz[0][0]=x[0],z[0][1]=x[1],z[0][2]=y[1],z[0][3]=y[0];\n\t\t\t\t\t\tz[1][0]=x[1],z[1][1]=x[2],z[1][2]=y[2],z[1][3]=y[1];\n\t\t\t\t\t\tz[2][0]=x[2],z[2][1]=x[3],z[2][2]=y[3],z[2][3]=y[2];\n\t\t\t\t\t\tz[3][0]=x[3],z[3][1]=x[0],z[3][2]=y[0],z[3][3]=y[3];\n\t\t\t\t\t\ts=1;\n\t\t\t\t\t\tfor (int l=0; l<4; l++)  getmin(z[l]),s*=cnt(z[l])*(M[z[l]]--);\n\t\t\t\t\t\tans+=s;\n\t\t\t\t\t\tfor (int l=0; l<4; l++)  M[z[l]]++;\n\t\t\t\t\t\tt=y[0],y[0]=y[1],y[1]=y[2],y[2]=y[3],y[3]=t;\n\t\t\t\t\t}\n\t\t\t\tM[c[i]]++,M[c[j]]++;\n\t\t\t}\n\tprintf(\"%lld\",ans/3);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n\tusing LD = long double;\n\t#define double LD\n\t#define long long long\n\t#define LL long\n\t#define int long\n\ttemplate<class T> using vec = vector<T>;\n\tusing VB = vec<bool>;\tusing WB = vec<VB>;\n\tusing VC = vec<char>;\tusing WC = vec<VC>;\n\tusing VI = vec<int>;\tusing WI = vec<VI>;\n\tusing VD = vec<double>;\tusing WD = vec<VD>;\n\tusing VS = vec<string>;\tusing WS = vec<VS>;\n\tusing PI = pair<int, int>;\tusing VPI = vec<PI>; using WPI = vec<VPI>;\n\tusing MI = map<int, int>;\tusing VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n\t#ifdef EBUG\n\t\tdebug = true;\n\t#elif defined(ONLINE_JUDGE)\n\t\tdebug = false;\n\t#else\n\t\tdebug = argc >= 2;\n\t#endif\n\tif(!debug) {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n\tcout << fixed << setprecision(20);\n\tcerr << fixed << setprecision(20);\n\n\tsettings();\n\tsolve();\n\n\treturn 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n\ttemplate<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n\t\tGraph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n\t};\n\tusing GraphI = Graph<int>;\n/** IO **/\n\ttemplate<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n\tint INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n\ttemplate<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n\t\tconst int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n\t\tif(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n\t\ttimes(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n\t}\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n\ttemplate<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n\ttemplate<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n\ttemplate<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n\t#define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n\ttemplate<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n\ttemplate<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n\ttemplate<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n\tinline void RD() {}\n\ttemplate<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n\ttemplate<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n\t#define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n\ttemplate<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n\ttemplate<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n\ttemplate<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n\t#define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n\t#define all(v) begin(v), end(v)\n\ttemplate<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n\ttemplate<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n\ttemplate<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n\ttemplate<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n\ttemplate<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n\ttemplate<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n\ttemplate<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n\ttemplate<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n\t\treturn 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n\t#define first_itr_st_val_ge_ lower_bound\n\t#define first_itr_st_val_gt_ upper_bound\n/** other **/\n\ttemplate<class T> inline signed SIZE(const T& t) { return t.size(); }\n\t#define size SIZE\n\t#define MP make_pair\n\t#define MT make_tuple\n\t#define PB push_back\n\t#define b_max(x, y) x = max(x, y)\n\t#define b_min(x, y) x = min(x, y)\n\tinline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.m.pow> */\n\t// NOT_VERIFIED\n\t// ref: ari-114\n\t// O(log b)\n\tinline int mpow(int a, int b, int mod=MOD) {\n\t\tint ans = 1;\n\t\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ans *= a) %= mod;\n\t\treturn ans;\n\t}\n/* </sr.m.pow> */\n\n/************************************ main ************************************/\n\nvoid settings() {\n\t// INPUT_GRAPH_index_sub = 0;\t\t// uncomment if input index is 0-based\n\t// INPUT_GRAPH_allow_empty = true;\t// uncomment to allow empty graph\n\t// INPUT_GRAPH_cost = 1;\t\t\t// uncomment if all input costs are 1\n}\n\nusing I4 = array<int, 4>;\n\nvoid o(const I4& i4) { cout << '(' << vec<int>(all(i4)) << ')'; }\n\nI4 rot(const I4& i4, int r) {\n\treturn I4{{ i4[r&3], i4[r+1&3], i4[r+2&3], i4[r+3&3] }};\n}\n\nI4 minrot(const I4& i4) {\n\tI4 ans = i4;\n\ttimes(3, r) {\n\t\tI4 x = rot(i4, r+1);\n\t\tif(ans > x) ans = x;\n\t}\n\treturn ans;\n}\n\nint z(const I4& i4) {\n\tif(i4[0] == i4[2] && i4[1] == i4[3]) {\n\t\tif(i4[0] == i4[1]) return 4;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nvoid solve() {\n// N N(4(C))\n/* <foxy.memo-area> */\nint N;cin>>N;vec<I4> C(N);times(N,Ri_0){times(4,Ri_1){cin>>C[Ri_0][Ri_1];}}\n/* </foxy.memo-area> */\n\tmap<I4, int> pyon;\n\ttimes(N, i) {\n\t\tC[i] = minrot(C[i]);\n\t\t++pyon[C[i]];\n\t}\n\t//if(debug) {for(auto& p : pyon) { o(p.first); cout sp << p.second << '/';} cout ln;}\n\tint ans = 0;\n\n\ttimes(N, i) times(N, j) if(i!=j) times(4, jj) {\n\t\tint a = 1;\n\t\tmap<I4, int> sides;\n\t\ttimes(4, h) {\n\t\t\t++sides[minrot(I4{{C[i][h+1&3], C[i][h&3], C[j][jj+4-h&3], C[j][jj+3-h&3]}})];\n\t\t}\n\t\tfor(auto& p : sides) {\n\t\t\tI4 i4 = p.first; int n = p.second;\n\t\t\t//a *= mpow(z(i4), n);\n\n\t\t\tint py = pyon[i4];\n\t\t\tif(i4 == C[i]) --py;\n\t\t\tif(i4 == C[j]) --py;\n\t\t\ttimes(n, k) a *= z(i4) * (py - k);\n\t\t}\n\n\t\tans += a;\n\t}\n\tcout << ans / 6 ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<complex>\n#include<sstream>\n#include<climits>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct tile {\n  int color[4];\n};\n\nconst int MAX_N = 400;\nint N;\ntile t[MAX_N];\n\nbool comp_tile(tile a, tile b) {\n  for (int i = 0; i < 4; ++i) {\n    if (a.color[i] != b.color[i]) {return a.color[i] < b.color[i];}\n  }\n  return true;\n}\n\nvoid regulation(tile &t) {\n  tile tmp, comp;\n  for (int i = 0; i < 4; ++i) {tmp.color[i] = t.color[i];}\n  for (int i = 1; i < 4; ++i) {\n    comp.color[0] = tmp.color[3];\n    comp.color[1] = tmp.color[0];\n    comp.color[2] = tmp.color[1];\n    comp.color[3] = tmp.color[2];\n    if (comp_tile(comp, t)) {t = comp;}\n    for (int j = 0; j < 4; ++j) {tmp.color[j] = comp.color[j];}\n  }\n}\n\nbool same(tile a, tile b) {\n  bool res = true;\n  for (int i = 0; i < 4; ++i) {\n    res &= (a.color[i] == b.color[i]);\n  }\n  return res;\n}\n\nint tile_lower_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid])) {ub = mid;}\n    else {lb = mid;}\n  }\n  return ub;\n}\n\nint tile_upper_bound(tile *ts, int size, tile s) {\n  int lb = -1, ub = size;\n  while (ub-lb > 1) {\n    int mid = (ub+lb)/2;\n    if (comp_tile(s,ts[mid]) && !same(ts[mid],s)) {ub = mid;}\n    else {lb = mid;}\n  }\n  return ub;\n}\n\n\nint main() {\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 4; ++j) {\n      cin >> t[i].color[j];\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {regulation(t[i]);}\n  sort(t, t+N, comp_tile);\n\n\n  ull ans = 0;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (i != j) {\n        tile top, bottom;\n        for (int k = 0; k < 4; ++k) {top.color[k] = t[i].color[k];}\n        for (int k = 0; k < 4; ++k) {bottom.color[k] = t[j].color[k];}\n        for (int k = 0; k < 4; ++k) {\n          tile tmp1;\n          for (int l = 0; l < 4; ++l) {tmp1.color[l] = bottom.color[l];}\n          bottom.color[0] = tmp1.color[3];\n          bottom.color[1] = tmp1.color[0];\n          bottom.color[2] = tmp1.color[1];\n          bottom.color[3] = tmp1.color[2];\n\n          tile sides[4];\n          sides[0].color[0] = top.color[0]; sides[0].color[1] = top.color[3]; sides[0].color[2] = bottom.color[2]; sides[0].color[3] = bottom.color[1];\n          sides[1].color[0] = top.color[3]; sides[1].color[1] = top.color[2]; sides[1].color[2] = bottom.color[3]; sides[1].color[3] = bottom.color[2];\n          sides[2].color[0] = top.color[2]; sides[2].color[1] = top.color[1]; sides[2].color[2] = bottom.color[0]; sides[2].color[3] = bottom.color[3];\n          sides[3].color[0] = top.color[1]; sides[3].color[1] = top.color[0]; sides[3].color[2] = bottom.color[1]; sides[3].color[3] = bottom.color[0];\n          for (int l = 0; l < 4; ++l) {regulation(sides[l]);}\n\n          int match_count[4];\n          int symmetry_count[4];\n          for (int m = 0; m < 4; ++m) {\n            int ub = tile_upper_bound(t, N, sides[m]);\n            int lb = tile_lower_bound(t, N, sides[m]);\n            int dup = 0;\n            if (lb <= i && i < ub) ++dup;\n            if (lb <= j && j < ub) ++dup;\n            match_count[m] = ub-lb-dup;\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tile tmp, cmp;\n            symmetry_count[m] = 1;\n            for (int n = 0; n < 4; ++n) {tmp.color[n] = sides[m].color[n];}\n            for (int n = 1; n < 4; ++n) {\n              cmp.color[0] = tmp.color[3];\n              cmp.color[1] = tmp.color[0];\n              cmp.color[2] = tmp.color[1];\n              cmp.color[3] = tmp.color[2];\n              if (same(cmp, sides[m])) ++symmetry_count[m];\n              for (int l = 0; l < 4; ++l) {tmp.color[l] = cmp.color[l];}\n            }\n          }\n\n          ull tmp_ans = 1;\n          \n          for (int m = 0; m < 4; ++m) {\n            int x = 0;\n            for (int n = 0; n < m; ++n) {\n              if (same(sides[n],sides[m])) ++x;\n            }\n            if (match_count[m] - x <= 0) {\n              tmp_ans = 0; break;\n            }\n            tmp_ans *= (match_count[m] - x);\n          }\n\n          for (int m = 0; m < 4; ++m) {\n            tmp_ans *= symmetry_count[m];\n          }\n\n          ans += tmp_ans;\n        }\n      }\n    }\n  }\n\n  cout << ans/6 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< short > rotate(vector< short > v, int p) {\n  rotate(begin(v), begin(v) + p, end(v));\n  return v;\n}\n\nvector< short > normalize(vector< short > &v) {\n  vector< short > ret(v);\n  for(int i = 1; i < 4; i++) {\n    ret = min(ret, rotate(v, i));\n  }\n  return ret;\n}\n\nusing int64 = long long;\n\nint main() {\n  int N;\n  cin >> N;\n  vector< vector< short > > C(N, vector< short >(4));\n\n  map< vector< short >, short > cnt, mul;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 4; j++) cin >> C[i][j];\n    C[i] = normalize(C[i]);\n    cnt[C[i]]++;\n  }\n  for(auto &p : cnt) {\n    for(int j = 0; j < 4; j++) {\n      mul[p.first] += rotate(p.first, j) == p.first;\n    }\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    cnt[C[i]]--;\n    for(int j = 0; j < i; j++) {\n      cnt[C[j]]--;\n      for(int k = 0; k < 4; k++) {\n        vector< short > key1{C[i][1], C[i][0], C[j][1], C[j][0]};\n        vector< short > key2{C[i][2], C[i][1], C[j][0], C[j][3]};\n        vector< short > key3{C[i][3], C[i][2], C[j][3], C[j][2]};\n        vector< short > key4{C[i][0], C[i][3], C[j][2], C[j][1]};\n        key1 = normalize(key1);\n        key2 = normalize(key2);\n        key3 = normalize(key3);\n        key4 = normalize(key4);\n        int64 latte = 1;\n        latte *= 1LL * mul[key1] * cnt[key1];\n        --cnt[key1];\n        latte *= 1LL * mul[key2] * cnt[key2];\n        --cnt[key2];\n        latte *= 1LL * mul[key3] * cnt[key3];\n        --cnt[key3];\n        latte *= 1LL * mul[key4] * cnt[key4];\n        --cnt[key4];\n        ret += latte;\n        ++cnt[key1];\n        ++cnt[key2];\n        ++cnt[key3];\n        ++cnt[key4];\n        rotate(begin(C[j]), begin(C[j]) + 1, end(C[j]));\n      }\n      cnt[C[j]]++;\n    }\n    cnt[C[i]]++;\n  }\n  cout << ret / 3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<map>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=510;\nstruct State {\n\tint a,b,c,d;\n\tbool operator < (const State& S) const {\n\t\tif(a!=S.a) return a<S.a;\n\t\tif(b!=S.b) return b<S.b;\n\t\tif(c!=S.c) return c<S.c;\n\t\treturn d<S.d;\n\t}\n\tbool operator == (const State& S) {\n\t\treturn a==S.a&&b==S.b&&c==S.c&&d==S.d;\n\t}\n}A[maxn][4];\nconst int HASH=152501;\nstruct Hash_Table {\n\tint first[HASH],nxt[maxn*4],sum[maxn*4],cnt;\n\tll val[maxn*4];\n\tint find(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) return sum[i];\n\t\treturn -1;\n\t}\n\tvoid add(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) {sum[i]++;return;}\n\t\tval[++cnt]=x;sum[cnt]=1;nxt[cnt]=first[p];first[p]=cnt;\n\t}\n\tvoid del(ll x) {\n\t\tint p=x%HASH;if(p<0) p+=HASH;\n\t\tfor(int i=first[p];i;i=nxt[i]) if(val[i]==x) {sum[i]--;return;}\n\t}\n}M;\n#define hash(a,b,c,d) ((((ll)(a))<<30)+((b)<<20)+((c)<<10)+(d))\nvoid del(State x) {\n\tM.del(hash(x.a,x.b,x.c,x.d));\n\tM.del(hash(x.b,x.c,x.d,x.a));\n\tM.del(hash(x.c,x.d,x.a,x.b));\n\tM.del(hash(x.d,x.a,x.b,x.c));\n}\nvoid add(State x) {\n\tM.add(hash(x.a,x.b,x.c,x.d));\n\tM.add(hash(x.b,x.c,x.d,x.a));\n\tM.add(hash(x.c,x.d,x.a,x.b));\n\tM.add(hash(x.d,x.a,x.b,x.c));\n}\nint main() {\n\tint n=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tA[i][0]=(State){a,b,c,d};\n\t\tA[i][1]=(State){b,c,d,a};\n\t\tA[i][2]=(State){c,d,a,b};\n\t\tA[i][3]=(State){d,a,b,c};\n\t\tM.add(hash(a,b,c,d));M.add(hash(c,d,a,b));\n\t\tM.add(hash(b,c,d,a));M.add(hash(d,a,b,c));\n\t}\n\tll ans=0;\n\trep(i,1,n) rep(j,i+1,n) if(i!=j) {\n\t\tdel(A[i][0]);del(A[j][0]);\n\t\trep(y,0,3) {\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t\tState S[4];\n\t\t\tS[0]=(State){A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b};\n\t\t\tS[1]=(State){A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b};\n\t\t\tS[2]=(State){A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d};\n\t\t\tS[3]=(State){A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d};\n\t\t\tint c1=M.find(hash(A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b));del(S[0]);\n\t\t\tint c2=M.find(hash(A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b));del(S[1]);\n\t\t\tint c3=M.find(hash(A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d));del(S[2]);\n\t\t\tint c4=M.find(hash(A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d));del(S[3]);\n\t\t\tif(c1>0&&c2>0&&c3>0&&c4>0) ans+=(ll)c1*c2*c3*c4;\n\t\t\tif(c1!=-1) add(S[0]);\n\t\t\tif(c2!=-1) add(S[1]);\n\t\t\tif(c3!=-1) add(S[2]);\n\t\t\tif(c4!=-1) add(S[3]);\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t}\n\t\tadd(A[i][0]);add(A[j][0]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        if(used.count(make_hash(x))) continue;\n\n        int way=0;\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          used.emplace(make_hash(y));\n        }\n\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 500\n#define LL long long\nusing namespace std;\n\nint n;\nLL c[MAXN][5],p[5],a[MAXN];\n\nLL getA(int c1,int c2,int c3,int c4){\n\tLL t1=c1*p[0]+c2*p[1]+c3*p[2]+c4*p[3];\n\tLL t2=c2*p[0]+c3*p[1]+c4*p[2]+c1*p[3];\n\tLL t3=c3*p[0]+c4*p[1]+c1*p[2]+c2*p[3];\n\tLL t4=c4*p[0]+c1*p[1]+c2*p[2]+c3*p[3];\n\treturn min(min(t1,t2),min(t3,t4));\n}\n\nLL getD(int c1,int c2,int c3,int c4){\n\tLL t1=c1*p[0]+c2*p[1]+c3*p[2]+c4*p[3];\n\tLL t2=c2*p[0]+c3*p[1]+c4*p[2]+c1*p[3];\n\tLL t3=c3*p[0]+c4*p[1]+c1*p[2]+c2*p[3];\n\tLL t4=c4*p[0]+c1*p[1]+c2*p[2]+c3*p[3];\n\treturn 1+(t1==t2)+(t1==t3)+(t1==t4);\n}\n\nLL cnt[5],b[5],visit[5];\n\nLL getP(LL x,int y){\n\tLL res=1;\n\tfor(int i=0;i<y;i++) res*=x-i;\n\treturn res;\n}\n\nLL calc(){\n\tmemset(visit,0,sizeof visit);\n\tLL res=1;\n\tfor(int i=0;i<4;i++)\n\t\tif(!visit[i]){\n\t\t\tint temp=0;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(b[i]==b[j]){\n\t\t\t\t\ttemp++;\n\t\t\t\t\tvisit[j]=1;\n\t\t\t\t}\n\t\t\tres*=getP(cnt[i],temp);\n\t\t}\n\treturn res;\n}\n\nLL gao(int x,int y,int d){\n\tstatic LL top[5],bot[5];\n\tfor(int i=0;i<4;i++){\n\t\ttop[i]=c[x][i];\n\t\tbot[i]=c[y][(4-(i+d)%4)%4];\n\t}\n\tb[0]=getA(top[3],top[2],bot[2],bot[3]);\n\tb[1]=getA(top[2],top[1],bot[1],bot[2]);\n\tb[2]=getA(top[1],top[0],bot[0],bot[1]);\n\tb[3]=getA(top[0],top[3],bot[3],bot[0]);\n\tLL delta=1;\n\tdelta*=getD(top[3],top[2],bot[2],bot[3]);\n\tdelta*=getD(top[2],top[1],bot[1],bot[2]);\n\tdelta*=getD(top[1],top[0],bot[0],bot[1]);\n\tdelta*=getD(top[0],top[3],bot[3],bot[0]);\n\tmemset(cnt,0,sizeof cnt);\n\tfor(int i=1;i<=n;i++)\n\t\tif((i^x) && (i^y)){\n\t\t\t(a[i]==b[0])?cnt[0]++:0;\n\t\t\t(a[i]==b[1])?cnt[1]++:0;\n\t\t\t(a[i]==b[2])?cnt[2]++:0;\n\t\t\t(a[i]==b[3])?cnt[3]++:0;\n\t\t}\n\tLL res=calc();\n\treturn res*delta;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld%lld%lld\",&c[i][0],&c[i][1],&c[i][2],&c[i][3]);\n\tp[0]=1;\n\tfor(int i=1;i<4;i++) p[i]=p[i-1]*1000;\n\tfor(int i=1;i<=n;i++) a[i]=getA(c[i][0],c[i][1],c[i][2],c[i][3]);\n\tLL ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\tans+=gao(i,j,k);\n\tans/=3;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define has(c,i) ((c).find(i) != end(c))\n#define DBGDO(X) ({ if(1) cerr << \"DBGDO: \" << (#X) << \" = \" << (X) << endl; })\n\ntypedef array<ll,4> tile;\n\nvoid normalize(tile &t) {\n\ttile rt = t;\n\tFOR(dir,0,4) {\n\t\tt = min(t,rt);\n\t\trotate(begin(rt),begin(rt)+1,end(rt));\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll n; cin >> n;\n\tvector<tile> c(n);\n\tmap<tile,ll> cnt;\n\tFOR(i,0,n) {\n\t\tFOR(j,0,4) cin >> c[i][j];\n\t\tnormalize(c[i]);\n\t\tcnt[c[i]]++;\n\t}\n\n\tll res = 0;\n\tFOR(i,0,n) {\n\t\tcnt[c[i]]--;\n\t\tFOR(j,i+1,n) {\n\t\t\tcnt[c[j]]--;\n\t\t\tFOR(dir,0,4) {\n\t\t\t\ttile t[4];\n\t\t\t\tt[0] = {c[i][0],c[i][3],c[j][0],c[j][3]};\n\t\t\t\tt[1] = {c[i][3],c[i][2],c[j][1],c[j][0]};\n\t\t\t\tt[2] = {c[i][2],c[i][1],c[j][2],c[j][1]};\n\t\t\t\tt[3] = {c[i][1],c[i][0],c[j][3],c[j][2]};\n\t\t\t\tmap<tile,ll> ccnt;\n\t\t\t\tll cur = 1;\n\t\t\t\tFOR(k,0,4) {\n\t\t\t\t\tnormalize(t[k]), ccnt[t[k]]++;\n\t\t\t\t\ttile rt = t[k];\n\t\t\t\t\tll rot = 0;\n\t\t\t\t\tFOR(dir2,0,4) {\n\t\t\t\t\t\tif (rt == t[k]) rot++;\n\t\t\t\t\t\trotate(begin(rt),begin(rt)+1,end(rt));\n\t\t\t\t\t}\n\t\t\t\t\tcur *= rot;\n\t\t\t\t}\n\t\t\t\tfor (const auto &p: ccnt) {\n\t\t\t\t\tll have = has(cnt,p.xx) ? cnt[p.xx] : 0, need = p.yy;\n\t\t\t\t\tFOR(k,0,need) cur *= have-k;\n\t\t\t\t}\n\t\t\t\tres += cur;\n\t\t\t\trotate(begin(c[j]),begin(c[j])+1,end(c[j]));\n\t\t\t}\n\t\t\tcnt[c[j]]++;\n\t\t}\n\t}\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n\tstatic const int S=1e7;\n\tchar rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n\tfastio() {rpos=len=wpos=0;}\n\tinline char Getchar()\n\t{\n\t\tif (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n\t\tif (!len) return EOF;\n\t\treturn rbuf[rpos++];\n\t}\n\ttemplate <class T> inline void Get(T &x)\n\t{\n\t\tchar ch;bool f;T res;\n\t\twhile (!isdigit(ch=Getchar()) && ch!='-') {}\n\t\tif (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n\t\twhile (isdigit(ch=Getchar())) res=res*10+ch-'0';\n\t\tx=(f?res:-res);\n\t}\n\tinline void getstring(char *s)\n\t{\n\t\tchar ch;\n\t\twhile ((ch=Getchar())<=32) {}\n\t\tfor (;ch>32;ch=Getchar()) *s++=ch;\n\t\t*s='\\0';\n\t}\n\tinline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n\tinline void Writechar(char ch)\n\t{\n\t\tif (wpos==S) flush();\n\t\twbuf[wpos++]=ch;\n\t}\n\ttemplate <class T> inline void Print(T x,char ch)\n\t{\n\t\tchar s[20];int pt=0;\n\t\tif (x==0) s[++pt]='0';\n\t\telse\n\t\t{\n\t\t\tif (x<0) Writechar('-'),x=-x;\n\t\t\twhile (x) s[++pt]='0'+x%10,x/=10;\n\t\t}\n\t\twhile (pt) Writechar(s[pt--]);\n\t\tWritechar(ch);\n\t}\n\tinline void printstring(char *s)\n\t{\n\t\tint pt=1;\n\t\twhile (s[pt]!='\\0') Writechar(s[pt++]);\n\t}\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ninline int quick_pow(int x,int y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ninline int quick_pow(int x,int y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=400;\n\nint n;\nstruct node\n{\n\t//clockwise\n\tint a,b,c,d;\n\tnode () {}\n\tinline node (int aa,int bb,int cc,int dd) {a=aa;b=bb;c=cc;d=dd;}\n\tinline void input() {io.Get(a);io.Get(b);io.Get(c);io.Get(d);}\n\tinline void print() {cerr<<a<<' '<<b<<' '<<c<<' '<<d<<endl;}\n\tinline bool operator == (const node &other) const\n\t{\n\t\treturn a==other.a && b==other.b && c==other.c && d==other.d;\n\t}\n\tinline bool operator < (const node &other) const\n\t{\n\t\tif (a!=other.a) return a<other.a;\n\t\tif (b!=other.b) return b<other.b;\n\t\tif (b!=other.c) return c<other.c;\n\t\treturn d<other.d;\n\t}\n}a[MAXN+48];\n\ninline LL tohash(node x)\n{\n\tLL res=x.d;\n\tres=res*1048+x.c;\n\tres=res*1048+x.b;\n\tres=res*1048+x.a;\n\treturn res;\n}\n\nmap<LL,int> Mp;\nvector<node> v;\n\ninline int cnt_same(node x,node y)\n{\n\tint res=0;\n\tif (x==y) res++;\n\tif (x==node(y.b,y.c,y.d,y.a)) res++;\n\tif (x==node(y.c,y.d,y.a,y.b)) res++;\n\tif (x==node(y.d,y.a,y.b,y.c)) res++;\n\treturn res;\n}\n\ninline void print(node x) {x.print();}\n\nint main ()\n{\n#ifdef LOCAL\n\tdouble TIME=clock();\n\tfreopen (\"a.in\",\"r\",stdin);\n\tfreopen (\"a.out\",\"w\",stdout);\n\tcerr<<\"Running...\"<<endl;\n#endif\n\tio.Get(n);LL ans=0;\n\tfor (register int i=1;i<=n;i++) a[i].input();\n\tfor (register int i=n;i>=1;i--)\n\t{\n\t\tfor (register int j=0;j<int(v.size());j++)\n\t\t{\n\t\t\tnode A,B,C,D;\n\t\t\tA=node(a[i].b,a[i].a,v[j].b,v[j].a);\n\t\t\tB=node(a[i].c,a[i].b,v[j].a,v[j].d);\n\t\t\tC=node(a[i].d,a[i].c,v[j].d,v[j].c);\n\t\t\tD=node(a[i].a,a[i].d,v[j].c,v[j].b);\n\t\t\t//if (i==4 && j==4) cerr<<\"--------\"<<endl,A.print(),B.print(),C.print(),D.print(),cerr<<\"----------\"<<endl;\n\t\t\t//if (i==4 && j==4) cerr<<Mp[tohash(C)]<<\"%%%%\"<<endl;\n\t\t\tLL cur=1;\n\t\t\tcur=cur*(Mp[tohash(A)]-cnt_same(A,v[j]));\n\t\t\tcur=cur*(Mp[tohash(B)]-cnt_same(B,v[j])-cnt_same(B,A));\n\t\t\tcur=cur*(Mp[tohash(C)]-cnt_same(C,v[j])-cnt_same(C,A)-cnt_same(C,B));\n\t\t\tcur=cur*(Mp[tohash(D)]-cnt_same(D,v[j])-cnt_same(D,A)-cnt_same(D,B)-cnt_same(D,C));\n\t\t\t//if (i==4 && j==4) {cerr<<cur<<\"!!!\";v[j].print();}\n\t\t\t//cerr<<i<<' '<<j<<' '<<cur<<endl;\n\t\t\tans+=cur;\n\t\t}\n\t\tMp[tohash(a[i])]++;\n\t\tMp[tohash(node(a[i].b,a[i].c,a[i].d,a[i].a))]++;\n\t\tMp[tohash(node(a[i].c,a[i].d,a[i].a,a[i].b))]++;\n\t\tMp[tohash(node(a[i].d,a[i].a,a[i].b,a[i].c))]++;\n\t\t//cerr<<\"~~~~~~~~~~~~~~~~\"<<endl;\n\t\t//print(a[i]);\n\t\t//print(node(a[i].b,a[i].c,a[i].d,a[i].a));\n\t\t//print(node(a[i].c,a[i].d,a[i].a,a[i].b));\n\t\t//print(node(a[i].d,a[i].a,a[i].b,a[i].c));\n\t\t//cerr<<\"~~~~~~~~~~~~~~~~\"<<endl;\n\t\tv.pb(a[i]);\n\t\tv.pb(node(a[i].b,a[i].c,a[i].d,a[i].a));\n\t\tv.pb(node(a[i].c,a[i].d,a[i].a,a[i].b));\n\t\tv.pb(node(a[i].d,a[i].a,a[i].b,a[i].c));\n\t}\n\tcout<<ans<<endl;\n\tio.flush();\n#ifdef LOCAL\n\tcerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (short i = a; i <= b; ++ i) \nconst short N = 1005 ; \n\nconst short turn[4][4] = {\n\t{4, 5, 1, 0}, {3, 2, 6, 7},\n\t{0, 3, 7, 4}, {1, 5, 6, 2}\n} ;\nusing namespace std ;\n\nmap <vector <short>, short> Count ;\nshort col[N][5], n ;\n\ninline void getmin(vector <short> &p) {\n\tvector <short> ret = p, tmp = p ;\n\trep(i, 1, 3) {\n\t\trep(j, 0, 3) tmp[j] = p[(i + j) % 4] ;\n\t\tif (tmp < ret) ret = tmp ;\n\t}\n\tp = ret ;\n}\n\nmap <vector <short>, short>  mul, used ;\n\nint main() {\n\tcin >> n ;\n\trep(i, 1, n) rep(j, 0, 3) cin >> col[i][j] ;\n\trep(i, 1, n) {\n\t\tvector <short> ret ;\n\t\trep(j, 0, 3) ret.push_back(col[i][j]) ;\n\t\tgetmin(ret) ;\n\t\t++ Count[ret] ;\n\t\tshort tot = 0 ; \n\t\tvector <short> tmp = ret ;\n\t\trep(j, 0, 3) {\n\t\t\trep(k, 0, 3) tmp[k] = ret[(j + k) % 4] ;\n\t\t\tif (tmp == ret) ++ tot ;\n\t\t}\n\t\tmul[ret] = tot ;\n\t}\t\n\tll ans = 0, sum ;\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\tvector <short> ret ;\n\t\trep(k, 0, 3) ret.push_back(col[i][k]) ; getmin(ret) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ; getmin(ret) ;\n\t\t-- Count[ret] ;\n\t\trep(k, 0, 3) {\n\t\t\tvector <short> ret ;\n\t\t\trep(p, 0, 3) ret.push_back(col[i][p]) ;\n\t\t\trep(p, 0, 3) ret.push_back(col[j][3 - (p + k) % 4]) ;\n\t\t\tsum = 1 ;\n\t\t\tvector <short> U[5] ;\n\t\t\trep(p, 0, 3) {\n\t\t\t\trep(q, 0, 3) U[p].push_back(ret[turn[p][q]]) ;\n\t\t\t\tgetmin(U[p]) ;\n\t\t\t\tsum *= (ll) mul[U[p]] * (Count[U[p]] - used[U[p]]) ;\n\t\t\t\t++ used[U[p]] ;\n\t\t\t}\n\t\t\trep(p, 0, 3) -- used[U[p]] ;\n\t\t\tans += sum ;\n\t\t}\n\t\trep(k, 0, 3) ret[k] = col[i][k] ; getmin(ret) ;\n\t\t++ Count[ret] ;\n\t\trep(k, 0, 3) ret[k] = col[j][k] ; getmin(ret) ;\n\t\t++ Count[ret] ;\n\t}\n\tprintf(\"%lld\\n\", ans / 3) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...)\\\n  std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::istream& operator>> (std::istream& is, Container& v) {\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate < typename Container, typename Value = typename Container::value_type >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T, typename U>\nstd::ostream& operator<< (std::ostream& os, const std::pair<T, U>& pair)\n  { return os << \"(\" << pair.first << \",\" << pair.second << \")\"; }\n\ntemplate <typename T, typename U>\nstd::istream& operator>> (std::iostream& is, std::pair<T, U>& pair)\n  { return is >> pair.first >> pair.second; }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto data = make_vector< 2, int >(n, 4);\n  std::cin >> data;\n  auto multiplicity = [&] (auto a) {\n    if (a.at(0) != a.at(2) || a.at(1) != a.at(3))\n      { return 1; }\n    if (a.at(0) != a.at(1))\n      { return 2;}\n    return 4;\n  };\n  auto power = [&] (auto x, auto y) {\n    auto ret = 1LL;\n    loop(y) ret *= x;\n    return ret;\n  };\n  auto normalized = [&] (auto a) {\n    auto z = a;\n    loop(3) {\n      std::rotate(a.begin(), a.begin() + 1, a.end());\n      cmn(z, a);\n    }\n    return z;\n  };\n  for (auto & v : data) v = normalized(v);\n  std::multiset< std::vector< int > > set(data.begin(), data.end());\n  auto cal = [&] (auto n, auto k) {\n    if (n < k) return 0LL;\n    auto ret = 1LL;\n    rep(i, 0, k) ret *= (n - i);\n    return ret;\n  };\n  lint ret = 0;\n  rep(i, 0, n) rep(j, i + 1, n) {\n    auto x = data.at(i);\n    auto y = data.at(j);\n    auto seq = std::vector< int >{1, 0, 1, 0};\n    loop(4) {\n      std::map< std::vector< int >, int > map;\n      loop(4) {\n        auto z = std::vector< int >{\n          x.at(seq.at(0)), x.at(seq.at(1)),\n          y.at(seq.at(2)), y.at(seq.at(3))\n        };\n        map[normalized(z)]++;\n        for (auto & x : std::vector< std::reference_wrapper<int> >{ seq.at(0), seq.at(1) })\n          { (x += 1) %= 4; }\n        for (auto & x : std::vector< std::reference_wrapper<int> >{ seq.at(2), seq.at(3) })\n          { (x += 3) %= 4; }\n      }\n      auto now = 1;\n      for (auto p : map) {\n        std::vector< int > v; int l; std::tie(v, l) = p;\n        auto m = set.count(v) - (x == v) - (y == v);\n        now *= cal(m, l) * power(multiplicity(v), l);\n      }\n      ret += now;\n      for (auto & x : std::vector< std::reference_wrapper<int> >{ seq.at(2), seq.at(3) })\n        { (x += 3) %= 4; }\n    }\n  }\n  assert(ret % 3 == 0);\n  ret /= 3;\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 400 + 100;\n\nstruct Tile\n{\n\tint a[4];\n\tlong long h;\n\tTile()\n\t{}\n\tTile(int x0, int x1, int x2, int x3)\n\t{\n\t\tint x[4] = {x0, x1, x2, x3};\n\t\tmemcpy(a, x, sizeof(x));\n\t\th = (x0) | (x1 << 10) | (x2 << 20) | (x3 << 30);\n\t}\n\tbool operator < (const Tile &s) const\n\t{\n\t\treturn h < s.h;\n\t}\n};\n\nint n;\nTile s[MAXN];\nmap<Tile, int> cnt;\n\nvoid add(const Tile &s, int v)\n{\n\tfor(int i = 0; i < 4; i++)\n\t\tcnt[Tile(s.a[i], s.a[(i + 1) % 4], s.a[(i + 2) % 4], s.a[(i + 3) % 4])] += v;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tcin >> s[i].a[j];\n\t\tadd(s[i], 1);\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tadd(s[i], -1);\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tadd(s[j], -1);\n\t\t\tfor(int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tTile t[4] = {\n\t\t\t\t\tTile(s[j].a[k], s[j].a[(k + 3) % 4], s[i].a[1], s[i].a[0]),\n\t\t\t\t\tTile(s[j].a[(k + 3) % 4], s[j].a[(k + 2) % 4], s[i].a[2], s[i].a[1]),\n\t\t\t\t\tTile(s[j].a[(k + 2) % 4], s[j].a[(k + 1) % 4], s[i].a[3], s[i].a[2]),\n\t\t\t\t\tTile(s[j].a[(k + 1) % 4], s[j].a[k], s[i].a[0], s[i].a[3])\n\t\t\t\t};\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\ttmp *= cnt[t[l]], add(t[l], -1);\n\t\t\t\tfor(int l = 0; l < 4; l++)\n\t\t\t\t\tadd(t[l], 1);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tadd(s[j], 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst LL MAX = 1e9;\nconst int SIZE = 410;\nLL an;\nint d[SIZE][4];\nLL val[SIZE];\nmap<LL,int>H,C;\nvoid ADD(LL& x,LL v){\n    x=(x+v);\n}\nLL fix(LL x){\n    LL xx=x;\n    int cnt=1;\n    LL mi=x;\n    REP(k,3){\n        LL tmp=x/MAX;\n        x=(x-tmp*MAX)*1000+tmp;\n        mi=min(mi,x);\n        if(x==xx)cnt++;\n    }\n    C[mi]=cnt;\n    return mi;\n}\nint main(){\n    DRI(N);\n    REP(i,N){\n        //printf(\"%d:%lld\\n\",i,an);\n        REP(j,4)\n            RI(d[i][j]);\n        REP(j,i){\n            H[val[j]]--;\n            REP(r,4){\n                map<LL,int>shik;\n                REP(k,4){\n                    LL v=0;\n                    v=v*1000+d[j][(r-k+4)&3];\n                    v=v*1000+d[j][(r-k+3)&3];\n                    v=v*1000+d[i][(k+1)&3];\n                    v=v*1000+d[i][k&3];\n                    shik[fix(v)]++;\n                }\n                LL my_v=1;\n                for(map<LL,int>::iterator it=shik.begin();it!=shik.end();it++){\n                    if(H.count(it->F)){\n                        LL nn=H[it->F];\n                        REP(ker,it->S){\n                            my_v=my_v*nn;\n                            nn--;\n                            my_v=my_v*C[it->F];\n                        }\n                    }\n                    else my_v=0;\n                }\n                ADD(an,my_v);\n            }\n            H[val[j]]++;\n        }\n        {\n            LL v=0;\n            REP(k,4)\n                v=v*1000+d[i][k];\n            val[i]=fix(v);\n            H[val[i]]++;\n        }\n    }\n    cout<<an<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define wh(x) (x).begin(),(x).end()\n#define ri(x) int x;cin>>x;\n#define rii(x,y) int x,y;cin>>x>>y;\n#define rl(x) ll x;cin>>x;\n#define rv(v) for(auto&_cinv:v) cin>>_cinv;\n#define wv(v) for(auto&_coutv:v) cout << _coutv << ' '; cout << endl;\n#define ev(v) for(auto&_cerrv:v) cerr << _cerrv << ' '; cerr << endl;\n#define MOD 1000000007\n\nnamespace std { \ntemplate<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntypedef pair<pii,pii> C;\n\nC norm(C c) {\n    return min(min(C{{c.x.y, c.y.x}, {c.y.y, c.x.x}}, C{{c.y.y,c.x.x},{c.x.y,c.y.x}}), min(c, {c.y,c.x}));\n}\n\nint get(const C&c, int i) {\n    switch(i&3) {\n        case 0: return c.x.x;\n        case 1: return c.x.y;\n        case 2: return c.y.x;\n        case 3: return c.y.y;\n    }\n}\n\nint rot(const C&c) {\n    if (c.x == c.y) {\n        if (c.x.x == c.x.y) return 4;\n        else return 2;\n    } else return 1;\n}\n\nint main(int,char**) {\n    ios_base::sync_with_stdio(false);\n\n    int N; cin >> N;\n\n    map<C, int> P;\n    map<C, int> R;\n    vector<C> Q;\n    for (int i = 0; i < N; i++) {\n        int a,b,c,d; cin >> a >> b >> c >> d;\n        C x{{a,b},{c,d}};\n        x = norm(x);\n        P[x] += 1;\n        R[x] = rot(x);\n        Q.push_back(x);\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        C &p = Q[i];\n        for (int j = i+1; j < N; j++) {\n            C &q = Q[j];\n            for (int k = 0; k < 4; k++) {\n                ll cur = 1;\n                C u[4];\n                for (int l = 0; l < 4; l++) {\n                    u[l] = norm({{get(p,l+1),get(p,l)},{get(q,k-l+1),get(q,k-l)}});\n                    int opts = P[u[l]];\n                    if (u[l] == p) --opts;\n                    if (u[l] == q) --opts;\n                    for (int m = 0; m < l; m++) {\n                        if (u[m] == u[l]) --opts;\n                    }\n                    if (opts <= 0) {\n                        cur = 0;\n                    } else {\n                        cur *= opts*rot(u[l]);\n                    }\n                    P[u[l]]--;\n                }\n                ans += cur;\n            }\n        }\n    }\n\n    cout << ans/3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nvector<int> Normalize(const vector<int>& xs) {\n  vector<deque<int>> rs;\n  deque<int> q(xs.begin(), xs.end());\n  rs.push_back(q);\n  for (int i = 0; i < 3; i++) {\n    q.push_back(q.front());\n    q.pop_front();\n    rs.push_back(q);\n  }\n  sort(rs.begin(), rs.end());\n  return vector<int>(rs[0].begin(), rs[0].end());\n}\n\nint64 Encode(const vector<int>& xs) {\n  int64 r = 0;\n  for (int i = 0; i < 4; i++) {\n    r *= 2000;\n    r += xs[i];\n  }\n  return r;\n}\n\nint Symmetry(const vector<int>& xs) {\n  if (xs[0] == xs[1] && xs[1] == xs[2] && xs[2] == xs[3]) return 4;\n  if (xs[0] == xs[2] && xs[1] == xs[3]) return 2;\n  return 1;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  s << \"[\";\n  for (int i = 0; i < len; i++) {\n    if (i > 0) s << \", \";\n    s << v[i];\n  }\n  s << \"]\";\n  return s;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> faces;\n  for (int i = 0; i < n; i++) {\n    vector<int> cs(4);\n    for (int j = 0; j < 4; j++) {\n      cin >> cs[j];\n    }\n    faces.push_back(Normalize(cs));\n  }\n  vector<int64> encoded_faces(n);\n  for (int i = 0; i < n; i++) {\n    encoded_faces[i] = Encode(faces[i]);\n  }\n  vector<int> symmetries(n);\n  for (int i = 0; i < n; i++) {\n    symmetries[i] = Symmetry(faces[i]);\n  }\n\n  int64 ans = 0;\n  for (int f1 = 0; f1 < n; f1++) {\n    for (int f2 = f1 + 1; f2 < n; f2++) {\n      for (int d2 = 0; d2 < 4; d2++) {\n        vector<int> vs(8);\n        for (int i = 0; i < 4; i++) vs[i] = faces[f1][i];\n        for (int i = 0; i < 4; i++) vs[7 - i] = faces[f2][(d2 + i) % 4];\n        // cout << vs << endl;\n\n        unordered_map<int64, int> r_count;\n        r_count[Encode(Normalize({vs[4], vs[5], vs[1], vs[0]}))]++;\n        r_count[Encode(Normalize({vs[5], vs[6], vs[2], vs[1]}))]++;\n        r_count[Encode(Normalize({vs[6], vs[7], vs[3], vs[2]}))]++;\n        r_count[Encode(Normalize({vs[7], vs[4], vs[0], vs[3]}))]++;\n\n        unordered_map<int64, int> s_count;\n        unordered_map<int64, int> symmetry_map;\n        for (int f3 = f1 + 1; f3 < n; f3++) {\n          if (f3 == f2) continue;\n          // cout << faces[f3] << endl;\n          if (r_count.find(encoded_faces[f3]) != r_count.end()) {\n            s_count[encoded_faces[f3]]++;\n            if (symmetry_map[encoded_faces[f3]] == 0) {\n              symmetry_map[encoded_faces[f3]] = symmetries[f3];\n            }\n          }\n        }\n\n        // for (const auto& kv : r_count) {\n        //   cout << kv.first << \" \" << s_count[kv.first] << \" \";\n        // }\n        // cout << endl;\n\n        int64 inc = 1;\n        for (const auto& kv : r_count) {\n          int r = kv.second;\n          int s = s_count[kv.first];\n          if (r > s) inc *= 0;\n          for (int k = 0; k < r; k++) {\n            inc *= (s - k);\n            inc *= symmetry_map[kv.first];\n          }\n        }\n        ans += inc;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tvvi C(N,vi(4));cin>>C;\n\tvector<vector<map<int,mii>>>m(1000,vector<map<int,mii>>(1000));\n\tll z=0;\n\tfr(i,N){\n\t\tfr(j,i){\n\t\t\tfr(k,4){\n\t\t\t\tll x=1;\n\t\t\t\tvvi vv={{C[j][0],C[j][1],C[j][2],C[j][3]}};\n\t\t\t\tauto f=[&](int a,int b,int c,int d)->ll{\n\t\t\t\t\ta=C[i][a],b=C[i][b],c=C[j][c+k&3],d=C[j][d+k&3];\n\t\t\t\t\tll r=0;\n\t\t\t\t\tauto it=m[a][b].find(c);\n\t\t\t\t\tif(it!=m[a][b].end()){\n\t\t\t\t\t\tauto it2=it->second.find(d);\n\t\t\t\t\t\tif(it2!=it->second.end()){\n\t\t\t\t\t\t\tr=it2->second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(vi&p:vv){\n\t\t\t\t\t\tfr(l,4){\n\t\t\t\t\t\t\tr-=a==p[l  &3]\n\t\t\t\t\t\t\t&& b==p[l+1&3]\n\t\t\t\t\t\t\t&& c==p[l+2&3]\n\t\t\t\t\t\t\t&& d==p[l+3&3];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvv<<vi{a,b,c,d};\n\t\t\t\t\treturn r;\n\t\t\t\t};\n\t\t\t\tx*=f(1,0,0,3);\n\t\t\t\tx*=f(2,1,3,2);\n\t\t\t\tx*=f(3,2,2,1);\n\t\t\t\tx*=f(0,3,1,0);\n\t\t\t\tz+=x;\n\t\t\t}\n\t\t}\n\t\tfr(j,4){\n\t\t\t++m[C[i][j&3]][C[i][j+1&3]][C[i][j+2&3]][C[i][j+3&3]];\n\t\t}\n\t}\n\tprint(z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid shift(vector <int> &now)\n{\n    int first = now[0];\n    now.erase(now.begin());\n    now.push_back(first);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    map <vector <int>, int> cnt;\n    vector <vector <int> > A(n, vector <int>(4));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) {\n            cin >> A[i][j];\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            cnt[A[i]]++;\n            shift(A[i]);\n        }\n    }\n    long long res = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int k = 0; k < 4; k++) {\n            cnt[A[i]]--;\n            shift(A[i]);\n        }\n\n        for (int j = i + 1; j < n; j++) {\n            for (int k = 0; k < 4; k++) {\n                cnt[A[j]]--;\n                shift(A[j]);\n            }\n            reverse(A[j].begin(), A[j].end());\n\n            for (int sh = 0; sh < 4; sh++) {\n                long long add = 1;\n                map <vector <int>, int> cross;\n\n                for (int k = 0; k < 4; k++) {\n                    vector <int> now = {A[i][k], A[j][k], A[j][(k + 1) % 4], A[i][(k + 1) % 4]};\n                    add *= cnt[now];\n\n                    for (int x = 0; x < 4; x++) {\n                        if (!cross.count(now)) {\n                            cross[now] = cnt[now];\n                        }\n                        cnt[now] -= 1;\n                        shift(now);\n                    }\n                }\n                res += add;\n\n                for (auto p: cross) {\n                    cnt[p.first] = p.second;\n                }\n                shift(A[j]);\n            }\n            reverse(A[j].begin(), A[j].end());\n\n            for (int k = 0; k < 4; k++) {\n                cnt[A[j]]++;\n                shift(A[j]);\n            }\n        }\n    }\n    cout << res << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      //cout<<bitset<40>(v)<<\":\"<<x<<endl;\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvi rotate(vi &vec) {\n  return vi({vec[1], vec[2], vec[3], vec[0]});\n}\n\nvoid tile(vi &vec) {\n  Graph<int> g;\n  rep(i,4) {\n    g.emplace_back(vec);\n    vec = rotate(vec);\n  }\n  vec = *min_element(ALL(g));\n}\n\nvoid solve() {\n  int n; cin >> n;\n  Graph<int> g(n, vi(4)); cin >> g;\n  map<vi, int> mp;\n  for (auto &vec : g) {\n    tile(vec);\n    mp[vec]++;\n  }\n\n  map<vi, int> dupl;\n  for (auto &p : mp) {\n    auto &vec = p.first;\n    if (vec[0] == vec[3]) dupl[vec] = 4;\n    else if (vec[0] == vec[2] && vec[1] == vec[3]) dupl[vec] = 2;\n    else dupl[vec] = 1;\n  }\n\n  ll ans = 0;\n\n  rep(i,n) {\n    rep(j,i) {\n      vi vec = g[j];\n      rep(r,4) {\n        map<vi, int> cnt;\n        rep(k,4) {\n          vi tmp = vi({g[i][k%4], vec[(4-k)%4], vec[(3-k)%4], g[i][(k+1)%4]});\n          tile(tmp);\n          cnt[tmp]++;\n        }\n\n        ll add = 1;\n\n        for (auto &p : cnt) {\n          if (!mp.count(p.first)) {\n            add = 0;\n            break;\n          }\n\n          ll tmp = mp[p.first];\n          if (g[i] == p.first) tmp--;\n          if (g[j] == p.first) tmp--;\n          int d = dupl[p.first];\n\n          rep1eq(k,p.second) {\n            add *= tmp-- * d;\n          }\n        }\n\n        ans += add;\n        vec = rotate(vec);\n      }\n    }\n  }\n\n  cout << ans / 3 << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define N_MAX 400\n#define VOID_C 1234\n\nint v_ind[6][4]={\n{0,1,2,3},\n{4,5,1,0},\n{1,5,6,2},\n{3,2,6,7},\n{4,0,3,7},\n{5,4,7,6}};\n\nint n;\nint c[N_MAX][4];\n\nbool used_tile[N_MAX];\n\nlong long int cntCube(int faz, int *c_corner_in){\n        long long int ret=0;\n        for(int i=0; i<n; i++){\n                if(used_tile[i]) continue;\n\n                int kn=4, ml=1;\n                if(faz==0){//初回は回転を考えない\n                        kn=1;\n                        ml=1;\n                }\n                else if(c[i][0]==c[i][1] && c[i][0]==c[i][2] && c[i][0]==c[i][3]){\n                        kn=1;\n                        ml=4;\n                }\n                else if(c[i][0]==c[i][2] && c[i][1]==c[i][3]){\n                        kn=2;\n                        ml=2;\n                }\n\n                for(int k=0; k<kn; k++){\n                        bool is_match=true;\n                        for(int j=0; j<4; j++){//カドの色が合ってるか\n                                if(c_corner_in[v_ind[faz][j]]!=VOID_C && c_corner_in[v_ind[faz][j]]!=c[i][(j+k)%4]){\n                                        is_match=false;\n                                        break;\n                                }\n                        }\n\n                        if(!is_match) continue;\n                        if(faz==5){\n                                ret+=ml;\n                                continue;\n                        }\n\n                        used_tile[i]=true;\n                        int c_corner[8];\n                        for(int j=0; j<8; j++) c_corner[j]=c_corner_in[j];\n                        for(int j=0; j<4; j++) c_corner[v_ind[faz][j]]=c[i][(j+k)%4];\n                        ret+=cntCube(faz+1, c_corner)*ml;\n                        if(faz!=0) used_tile[i]=false;//初回に使ったタイルはもう使用しない\n                }\n        }\n        return ret;\n}\n\nint main(){\n        cin>>n;\n        for(int i=0; i<n; i++){\n                for(int j=0; j<4; j++){\n                        cin>>c[i][j];\n                }\n        }\n        for(int i=0; i<n; i++) used_tile[i]=false;\n\n        int c_corner[8];\n        for(int j=0; j<8; j++) c_corner[j]=VOID_C;\n        long long int ans=cntCube(0, c_corner);\n\n        cout<<ans;\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 62;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n;\n\tcin >> n;\n\tmap<Array, ll> mp;\n\tvector<Array> a(n);\n\tauto normalize = [](Array c) {\n\t\tArray t = c;\n\t\tREP(j, 4) {\n\t\t\trotate(c.begin(), c.begin() + 1, c.end());\n\t\t\tif (t > c)t = c;\n\t\t}\n\t\treturn t;\n\t};\n\tREP(i, n) {\n\t\tArray c(4);\n\t\tREP(j, 4)cin >> c[j];\n\t\tArray t = normalize(c);\n\t\tmp[t]++;\n\t\ta[i] = t;\n\t}\n\tll ans = 0;\n\tREP(i, n) {\n\t\tmp[a[i]]--;\n\t\trep(j, i + 1, n) {\n\t\t\tmp[a[j]]--;\n\t\t\tREP(k, 4) {\n\t\t\t\tll tmp = 1;\n\t\t\t\tREP(l, 4) {\n\t\t\t\t\tArray c(4);\n\t\t\t\t\tc[0] = a[i][(l + 1) % 4];\n\t\t\t\t\tc[1] = a[i][l % 4];\n\t\t\t\t\tc[2] = a[j][(k - l+1 + 4) % 4];\n\t\t\t\t\tc[3] = a[j][(k - l +4) % 4];\n\t\t\t\t\tArray t = normalize(c);\n\t\t\t\t\tif (mp.count(t) == 0)tmp = 0;\n\t\t\t\t\telse tmp *= mp[t], mp[t]--;\n\t\t\t\t\tif (t[0] == t[1] && t[0] == t[2] && t[0] == t[3])tmp *= 4;\n\t\t\t\t\telse if (t[0] == t[2] && t[1] == t[3])tmp *= 2;\n\t\t\t\t}\n\t\t\t\tans += tmp;\n\t\t\t\tREP(l, 4) {\n\t\t\t\t\tArray c(4);\n\t\t\t\t\tc[0] = a[i][(l + 1) % 4];\n\t\t\t\t\tc[1] = a[i][(l) % 4];\n\t\t\t\t\tc[2] = a[j][(k - l+1+4) % 4];\n\t\t\t\t\tc[3] = a[j][(k - l + 4) % 4];\n\t\t\t\t\tArray t = normalize(c);\n\t\t\t\t\tif (mp.count(t) != 0)mp[t]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp[a[j]]++;\n\t\t}\n\t\tmp[a[i]]++;\n\t}\n\tcout << ans / 3<< \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 405, base = 1013, MOD = 1000007;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef pair<int, int> pii;\n\nint C[MAX_N][4], N;\n\nclass Hash_Table {\npublic:\n  int head[MOD], cnt, nxt[MOD], num[MOD];\n  u64 key[MOD];\n  void add(pair<pii, pii> x, int v) {\n    u64 val = (u64)x.first.first * base + (u64)x.first.second * base * base;\n    val += (u64)x.second.first * base * base * base;\n    val += (u64)x.second.second * base * base * base * base;\n    \n    int temp = val % MOD;\n    for (int i = head[temp]; i; i = nxt[i])\n      if (key[i] == val) {\n\tnum[i] += v;\n\treturn;\n      }\n    nxt[++cnt] = head[temp], head[temp] = cnt, num[cnt] = v, key[cnt] = val;\n  }\n  int query(pair<pii, pii> x) {\n    u64 val = (u64)x.first.first * base + (u64)x.first.second * base * base;\n    val += (u64)x.second.first * base * base * base;\n    val += (u64)x.second.second * base * base * base * base;\n    \n    int temp = val % MOD;\n    for (int i = head[temp]; i; i = nxt[i])\n      if (key[i] == val) return num[i];\n    return 0;\n  }\n} cnt;\n\nvoid insert(int col[4]) {\n  static int t[4];\n  for (int i = 0; i < 4; ++i) {\n    for (int j = 0; j < 4; ++j) t[j] = col[(j + i) % 4];\n    cnt.add(make_pair(make_pair(t[0], t[1]), make_pair(t[2], t[3])), 1);\n  }\n}\n\nvoid substract(int col[4]) {\n  static int t[4];\n  for (int i = 0; i < 4; ++i) {\n    for (int j = 0; j < 4; ++j) t[j] = col[(j + i) % 4];\n    cnt.add(make_pair(make_pair(t[0], t[1]), make_pair(t[2], t[3])), -1);\n  }  \n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i)\n    for (int j = 0; j < 4; ++j)\n      scanf(\"%d\", &C[i][j]);\n\n  i64 res = 0;\n  for (int i = 1; i <= N; ++i) {\n    for (int j = 1; j < i; ++j) {\n      substract(C[j]);\n      for (int d = 0; d < 4; ++d) {\n\tstatic int t[4], A[4];\n\ti64 num = 1;\n\tfor (int k = 0; k < 4; ++k) t[k] = C[j][((k + d) % 4) ^ 1];\n\tfor (int k = 0; k < 4; ++k) {\n\t  A[0] = C[i][(k + 1) % 4], A[1] = C[i][k];\n\t  A[3] = t[(k + 1) % 4], A[2] = t[k];\n\t  num *= cnt.query(make_pair(make_pair(A[0], A[1]), make_pair(A[2], A[3])));\n\t  substract(A);\n\t}\n\tfor (int k = 0; k < 4; ++k) {\n\t  A[0] = C[i][(k + 1) % 4], A[1] = C[i][k];\n\t  A[3] = t[(k + 1) % 4], A[2] = t[k];\n\t  insert(A);\n\t}\n\tres += num;\n      }\n      insert(C[j]);\n    }\n    insert(C[i]);\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f[5];\nlong long c[444][5], p[444][5];\nlong long a[444];\nlong long an;\nmap<long long, int> mp;\nint n;\n\nlong long pw(int a, int b){\n\tlong long tmp = 1;\n\tfor(int i = 1; i <= b; ++i) tmp *= a;\n\treturn tmp;\n}\n\nlong long get(int x, int y, int z, int h){\n\tlong long cur = x;\n\tcur <<= 10;\n\tcur += y;\n\tcur <<= 10;\n\tcur += z;\n\tcur <<= 10;\n\tcur += h;\n\treturn cur;\n}\n\nlong long pack(int x, int y, int z, int h){\n\treturn min(min(get(x, y, z, h), get(y, z, h, x)), \n\t\t\t   min(get(z, h, x, y), get(h, x, y, z)));\n}\n\nint rot(long long h){\n\tint res = 1;\n\tlong long ori = h;\n\tfor(int i = 1; i < 4; ++i){\n\t\tlong long tmp = h & ((1 << 10) - 1);\n\t\th >>= 10;\n\t\ttmp <<= 30;\n\t\th += tmp;\n\t\tres += h == ori;\t\t\n\t}\n\treturn res;\n}\n\nint main(){\n//\tfreopen(\"input.inp\", \"r\", stdin);\n\tf[0] = 1;\n\tfor(int i = 1; i < 5; ++i) f[i] = f[i - 1] * i;\n\tfor(int i = 0; i <= 400; ++i) c[i][0] = 1;\n\tfor(int i = 1; i <= 400; ++i){\n\t\tfor(int j = 1; j <= min(4, i); ++j){\n\t\t\tc[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; ++i){\n\t\tscanf(\"%d%d%d%d\",&p[i][0],&p[i][1],&p[i][2],&p[i][3]);\n\t\ta[i] = pack(p[i][0], p[i][1], p[i][2], p[i][3]);\n\t}\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int ii = 1; ii < i; ++ii){\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tlong long y[4];\n\t\t\t\ty[0] = pack(p[i][1], p[i][0], p[ii][(1 + j) % 4], p[ii][(0 + j) % 4]);\n\t\t\t\ty[1] = pack(p[i][2], p[i][1], p[ii][(0 + j) % 4], p[ii][(3 + j) % 4]);\n\t\t\t\ty[2] = pack(p[i][3], p[i][2], p[ii][(3 + j) % 4], p[ii][(2 + j) % 4]);\t\n\t\t\t\ty[3] = pack(p[i][0], p[i][3], p[ii][(2 + j) % 4], p[ii][(1 + j) % 4]);\n\t\t\t\tsort(y, y + 4);\n\t\t\t\tlong long tmp = 1;\n\t\t\t\tfor(int l = 0; l < 4;){\n\t\t\t\t\tint cnt = 1, r = l;\n\t\t\t\t\twhile (r < 4 && y[l] == y[r + 1]) ++cnt, ++r;\n\t\t\t\t\tint num = mp[y[l]];\n\t\t\t\t\tif (y[l] == a[ii]) --num;\n\t\t\t\t\tif (num < cnt){\n\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttmp *= c[num][cnt] * pw(rot(y[l]), cnt) * f[cnt];\n\t\t\t\t\tl += cnt;\n\t\t\t\t}\n\t\t\t\tan += tmp;\n\t\t\t}\n\t\t}\n\t\t++mp[a[i]];\n\t}\n\tprintf(\"%lld\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i, x) for (int i = 0; i < x; i++)\n#define rep1(i, x) for (int i = 1; i <= x; i++)\n#define rrep(i, x) for (int i = x - 1; i >= 0; i--)\n#define rrep1(i, x) for (int i = x; i > 0; i--)\n#define sor(v) sort(v.begin(), v.end())\n#define rev(s) reverse(s.begin(), s.end())\n#define lb(vec, a) lower_bound(vec.begin(), vec.end(), a)\n#define ub(vec, a) upper_bound(vec.begin(), vec.end(), a)\n#define uniq(vec) vec.erase(unique(vec.begin(), vec.end()), vec.end())\n#define mp1(a, b, c) P1(a, P(b, c))\n\nconst int INF = 1000000000;\nconst ll M = 1000000000;\nconst int dir_4[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconst int dir_8[8][2] = {{1, 0},  {1, 1},   {0, 1},  {-1, 1},\n                         {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\n/*----------------------------------------------/\n/- char         : %c  | char *       : %s  | short        : %hd\n/- int          : %d  | long         : %ld | long long    : %lld\n/- unsigned short:%hu | unsigned int : %u  | unsigned long: %lu\n/- u_long long  : %llu| (octal)      : %o  | (hexadecimal): %x\n/- float        : %f  | double       : %lf |\n/----------------------------------------------*/\n\n/*----------------------------------------------/\n/- INT_MAX, LONG_MAX   : 1<<15 = 2.1*pow(10, 9)       (= 2147483647)\n/- UINT_MAX, ULONG_MAX : 1<<16 = 4.2*pow(10, 9)       (= 4294967295)\n/- LLONG_MAX           : 1<<63 = 9.2*pow(10, 18)      (= 9223372036854775807)\n/- ULLONG_MAX          : 1<<64 = 1.8*pow(10, 19)      (= 18446744073709551615)\n/----------------------------------------------*/\n\nP f(ll x, ll y, ll z, ll w) {\n    ll c[4] = {x, y, z, w};\n    ll a[4] = {};\n    rep(i, 4) {\n        rep(j, 4) {\n            a[i] *= 1000;\n            a[i] += c[(i + j) % 4];\n        }\n    }\n    ll ret = max(max(a[0], a[1]), max(a[2], a[3]));\n    ll cnt = 0;\n    rep(i, 4) if (a[i] == ret) cnt++;\n    return P(ret, cnt);\n}\n\nint main() {\n    int n;\n    ll c[402][4];\n    P A[402];\n    scanf(\"%d\", &n);\n    rep(i, n) {\n        rep(j, 4) { cin >> c[i][j]; }\n        A[i] = f(c[i][0], c[i][1], c[i][2], c[i][3]);\n        cout << A[i].fr << \",\" << A[i].sc << endl;\n    }\n\n    map<ll, int> M;\n    rep(i, n) M[A[i].fr] += A[i].sc;\n\n    ll ret = 0;\n    rep(i, n) {\n        M[A[i].fr] -= A[i].sc;\n        for (int j = i + 1; j < n; j++) {\n            M[A[j].fr] -= A[j].sc;\n            rep(k, 4) {\n                P x[4];\n                ll _ret = 1;\n                rep(l, 4) {\n                    x[l] = f(c[i][l], c[j][(k + 4 - l) % 4],\n                             c[j][(k + 4 - l - 1) % 4], c[i][(l + 1) % 4]);\n                    _ret *= M[x[l].fr];\n                    M[x[l].fr] -= x[l].sc;\n                }\n                rep(l, 4) { M[x[l].fr] += x[l].sc; }\n                ret += _ret;\n            }\n            M[A[j].fr] += A[j].sc;\n        }\n    }\n\n    cout << ret;\n    /* ====================================== */\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nusing P = pair<ll, ll>;\nP make_hash(A x){\n  return P(make_hash(x[0],x[1],x[2],x[3]),\n           make_hash(x[4],x[5],x[6],x[7]));\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<P> used;\n\n  vector<A> vs;\n  {\n    A w;\n    set<A> rs;\n    for(int i=0;i<8;i++) w[i]=i;\n    for(int p=0;p<4;p++){\n      for(int q=0;q<4;q++){\n        for(int r=0;r<4;r++){\n          rs.emplace(w);\n          w=rotH(w);\n        }\n        w=rotN(w);\n      }\n      w=rotH(w);\n    }\n    vs=vector<A>(rs.begin(),rs.end());\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        int way=0,flg=0;\n        for(auto v:vs){\n          A y;\n          for(int k=0;k<8;k++) y[k]=x[v[k]];\n          if(x==y) way++;\n          if(used.count(make_hash(y))){\n            flg=1;\n            break;\n          }\n        }\n        if(flg) continue;\n        ans+=check(x)/way;\n        used.emplace(make_hash(x));\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\nconst int MAXN=405;\n\nlong long encode(long long a,long long b,long long c,long long d)\n{\n\treturn (a<<30LL)|(b<<20LL)|(c<<10LL)|d;\n}\n\nmap<long long,long long> cnt;\nvoid Add(long long c,int delta)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tcnt[c]+=delta;\n\t\tc=(c>>10LL)|((c&1023LL)<<30LL);\n\t}\n}\n\nint n;\nint c[MAXN][4];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",c[i],c[i]+1,c[i]+2,c[i]+3);\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tlong long u[4]=\n\t\t\t\t{encode(c[i][1],c[i][0],c[j][(k+1)&3],c[j][(k+0)&3]),\n\t\t\t\t encode(c[i][0],c[i][3],c[j][(k+2)&3],c[j][(k+1)&3]),\n\t\t\t\t encode(c[i][3],c[i][2],c[j][(k+3)&3],c[j][(k+2)&3]),\n\t\t\t\t encode(c[i][2],c[i][1],c[j][(k+0)&3],c[j][(k+3)&3])\n\t\t\t\t};\n\t\t\t\tlong long tmp=1;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\ttmp*=cnt[u[l]],Add(u[l],-1);\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tAdd(u[l],1);\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/functional/hash.hpp>\n//example: unordered_set< pair<int,int>,boost::hash< std::pair<int, int> > > used;\n//priority_queue< pair<int,pair<int,int> >, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int> > > > pqueue;    //cost, vertex(行き先)\nusing namespace std;\n\n#define module 1000000007\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define int long long\n\ntemplate<class T, class U>\ninline void chmin(T &t, U f) { if (t > f)t = f; }\n\ntemplate<class T, class U>\ninline void chmax(T &t, U f) { if (t < f)t = f; }\n\ntypedef pair<int, int> P;\ntypedef long long LL;\nconst int INF = INT_MAX / 2;    //int_max->2*e+9\nconst int MAXN = 100001;\n\n/*struct edge {\n    edge(int to, int cost) : to(to), cost(cost) {}\n    int to, cost;\n};\nvector<edge> graph[MAXN];*/\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\n//-----Template---------\n//pure\nLL compress(vector<int>& v){ //10^3*4->10^12\n    LL r=0;\n    for (int i = 0; i < v.size(); ++i) {\n        r=r*1000+v[i];\n    }\n    return r;\n}\n\n\nvector<int> getMinVector(vector<int> v){\n    vector<vector<int>> tmpVecs;\n    tmpVecs.push_back(v);\n    for (int i = 1; i < 4; ++i) {\n        rotate(v.begin(),v.begin()+1,v.end());  //begin to end, begin+1が先頭に来るように左に回す\n                                                //右に回すときには rotate(v.rbegin(),v.rbegin()+1,v.rend()) とrbeginを使う\n        tmpVecs.push_back(v);\n    }\n    sort(all(tmpVecs));\n    /*sort(tmpVecs.begin(),tmpVecs.end(),[](vector<int> a,vector<int> b){\n        if(a.size()==0)return true;\n        for (int i = 0; i < a.size(); ++i) {\n            if(a[i]!=b[i]){\n                return a[i]<b[i];\n            }\n        }\n        return true;\n    });*/\n    return tmpVecs[0];\n}\n//pure\nint getWay(vector<int>& v){\n    int wayNum=1;\n    if(v[0] == v[1] && v[1]==v[2] && v[2]==v[3]){\n        wayNum=4;\n    }else if(v[0]==v[2] && v[1]==v[3]){\n        wayNum=2;\n    }\n    return wayNum;\n}\n\nint getWay2(vector<int> v){\n    set<vector<int>> s;\n    for (int i = 0; i < 4; ++i) {\n        s.insert(v);\n        rotate(v.begin(),v.begin()+1,v.end());\n    }\n    return 4/s.size();\n}\n\nint n, counter;\n//string tile[401];\nvector<vector<int>> tile(401);\nunordered_map<LL,LL> cnt;\nunordered_map<LL,LL> way;\n\nint main() {\n    ios::sync_with_stdio(false); //cout<< fixed << setprecision(10);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> v(4);\n        for (int j = 0; j < 4; ++j) {\n            cin>>v[j];\n        }\n        v=getMinVector(v);\n        tile[i]=v;\n        LL minTile=compress(v);\n        cnt[minTile]++;\n        way[minTile]=getWay2(v);\n    }\n    int ans=0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> ue = tile[i];\n        LL ueLL=compress(ue);\n        cnt[ueLL]--;\n        for (int j = i + 1; j < n; ++j) {\n            vector<int> sita = tile[j];\n            LL sitaLL=compress(sita);\n            cnt[sitaLL]--;\n\n            swap(sita[1],sita[3]);\n            for (int k = 0; k < 4; ++k) {   //sitaを回転\n                map<LL,int> sokuTile;\n                for (int l = 0; l < 4; ++l) {   //側面のタイルを書き出す\n                    vector<int> tmpTile(4);\n                    /*tmpTile[0]=ue[l];\n                    tmpTile[1]=ue[(l+3)%4];\n                    tmpTile[2]=sita[(l+3)%4];\n                    tmpTile[3]=sita[l];*/\n                    tmpTile[0]=ue[(l+1)%4];\n                    tmpTile[1]=ue[l];\n                    tmpTile[2]=sita[l];\n                    tmpTile[3]=sita[(l+1)%4];\n\n                    tmpTile=getMinVector(tmpTile);\n                    sokuTile[compress(tmpTile)]++;\n                }\n                LL resTmp=1;\n                for (auto it : sokuTile) {\n                    if(cnt.find(it.first)==cnt.end()){\n                        resTmp*=0; break;\n                    }\n\n                    if(it.second==1){\n                        resTmp*=cnt[it.first]*way[it.first];\n                    }else{\n                        for (int l = 0; l < it.second; ++l) {\n                            resTmp*=(cnt[it.first]-l)*way[it.first];\n                        }\n                    }\n                }\n                ans+=resTmp;\n\n                rotate(sita.begin(),sita.begin()+1,sita.end());\n            }\n            cnt[sitaLL]++;\n        }\n        cnt[ueLL]++;\n    }\n    cout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 405\n\nusing namespace std;\n\nmap<vector<int>, int> mp;\n\nint n;\nint x;\nvector<int> v[maxn];\nlong long ans;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= 4;j++){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tv[i].push_back(x);\n\t\t}\n\t\tfor(int j = 1;j <= 4;j++){\n\t\t\tmp[v[i]]++;\n\t\t\trotate(v[i].begin(), v[i].begin() + 1, v[i].end());\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int k = 1;k <= 4;k++){\n\t\t\tmp[v[i]]--;\n\t\t\trotate(v[i].begin(), v[i].begin() + 1, v[i].end());\n\t\t}\n\t\tfor(int j = 1;j < i;j++){\n\t\t\tfor(int k = 1;k <= 4;k++){\n\t\t\t\tmp[v[j]]--;\n\t\t\t\trotate(v[j].begin(), v[j].begin() + 1, v[j].end());\n\t\t\t}\n\t\t\tfor(int k = 1;k <= 4;k++){\n\t\t\t\tlong long sum = 1;\n\t\t\t\treverse(v[j].begin(), v[j].end());\n\t\t\t\t//printf(\"%d %d %d--\\n\", i, j, k);\n\t\t\t\t//printf(\"%d %d %d %d--!!\\n\", v[i][0], v[i][1], v[i][2], v[i][3]);\n\t\t\t\t//printf(\"%d %d %d %d--!!\\n\", v[j][0], v[j][1], v[j][2], v[j][3]);\n\t\t\t\t\n\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\tvector<int> a;\n\t\t\t\t\ta.push_back(v[j][l]), a.push_back(v[j][(l + 1) % 4]);\n\t\t\t\t\ta.push_back(v[i][(l + 1) % 4]), a.push_back(v[i][l]);\n\t\t\t\t\tsum *= mp[a];\n\t\t\t\t\t//printf(\"%d %d %d %d--\\n\", a[0], a[1], a[2], a[3]);\n\t\t\t\t\tfor(int o = 0;o < 4;o++){\n\t\t\t\t\t\tmp[a]--;\n\t\t\t\t\t\trotate(a.begin(), a.begin() + 1, a.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += sum;\n\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\tvector<int> a;\n\t\t\t\t\ta.push_back(v[j][l]), a.push_back(v[j][(l + 1) % 4]);\n\t\t\t\t\ta.push_back(v[i][(l + 1) % 4]), a.push_back(v[i][l]);\n\t\t\t\t\tfor(int o = 0;o < 4;o++){\n\t\t\t\t\t\tmp[a]++;\n\t\t\t\t\t\trotate(a.begin(), a.begin() + 1, a.end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treverse(v[j].begin(), v[j].end());\n\t\t\t\trotate(v[j].begin(), v[j].begin() + 1, v[j].end());\n\t\t\t} \n\t\t\tfor(int k = 1;k <= 4;k++){\n\t\t\t\tmp[v[j]]++;\n\t\t\t\trotate(v[j].begin(), v[j].begin() + 1, v[j].end());\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1;k <= 4;k++){\n\t\t\tmp[v[i]]++;\n\t\t\trotate(v[i].begin(), v[i].begin() + 1, v[i].end());\n\t\t}\n\t}\n\tprintf(\"%lld\", ans / 3);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<unordered_map>\n#define N 410\n#define lint long long\n#define ull unsigned long long\n#define gc getchar()\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\nusing namespace std;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nint Gc;unordered_map<lint,int> cnt;lint val[1000];\nint c[N][5];lint cv[N][4];\ninline lint hv(int a,int b,int c,int d)\n{\n\treturn a*1000000000ll+b*1000000ll+c*1000ll+d;\n}\ninline lint hv(int *a)\n{\n\treturn hv(a[0],a[1],a[2],a[3]);\n}\ninline int Rot(int *a,int c)\n{\n\trep(i,1,c)\n\t{\n\t\tint tmp=a[0];\n\t\trep(j,1,3) a[j-1]=a[j];\n\t\ta[3]=tmp;\n\t}\n\treturn 0;\n}\ninline int Add(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]++;\n\treturn 0;\n}\ninline int Del(int x)\n{\n\trep(i,0,3) cnt[cv[x][i]]--;\n\treturn 0;\n}\ninline int Get(int a,int b,int c,int d)\n{\n\tint t=cnt[hv(a,b,c,d)];\n\tcnt[val[++Gc]=hv(a,b,c,d)]--;\n\tcnt[val[++Gc]=hv(b,c,d,a)]--;\n\tcnt[val[++Gc]=hv(c,d,a,b)]--;\n\tcnt[val[++Gc]=hv(d,a,b,c)]--;\n\treturn t;\n}\ninline int Back()\n{\n\trep(i,1,Gc) cnt[val[i]]++;\n\tGc=0;return 0;\n}\nint main()\n{\n\tint n=inn();ull ans=0ll;\n\trep(i,1,n) rep(j,0,3) c[i][j]=inn();\n\trep(i,1,n)\n\t{\n\t\t#define a c[i]\n\t\tcnt[cv[i][0]=hv(a[0],a[1],a[2],a[3])]++;\n\t\tcnt[cv[i][1]=hv(a[1],a[2],a[3],a[0])]++;\n\t\tcnt[cv[i][2]=hv(a[2],a[3],a[0],a[1])]++;\n\t\tcnt[cv[i][3]=hv(a[3],a[0],a[1],a[2])]++;\n\t\t#undef a\n\t}\n\trep(i,1,n)\n\t{\n\t\tDel(i);\n\t\trep(p,0,3)\n\t\t{\n//\t\t\tRot(c[i],p);\n\t\t\trep(j,1,n) if(i!=j)\n\t\t\t{\n\t\t\t\tDel(j);\n\t\t\t\trep(q,0,3)\n\t\t\t\t{\n//\t\t\t\t\tRot(c[j],q);\n\t\t\t\t\tint s,x,z,y;\n\t\t\t\t\ts=Get(c[j][1],c[j][0],c[i][1],c[i][0]);//S\n\t\t\t\t\tif(!s) goto loop;\n\t\t\t\t\tx=Get(c[j][2],c[i][3],c[i][2],c[j][3]);//X\n\t\t\t\t\tif(!x) goto loop;\n\t\t\t\t\tz=Get(c[j][1],c[i][0],c[i][3],c[j][2]);//Z\n\t\t\t\t\tif(!z) goto loop;\n\t\t\t\t\ty=Get(c[i][1],c[j][0],c[j][3],c[i][2]);//Y\n\t\t\t\t\tif(!y) goto loop;\n\t\t\t\t\tans+=1ull*s*x*z*y;\n\t\t\t\t\tloop:;\n\t\t\t\t\tBack();\n\t\t\t\t\tRot(c[j],1);\n\t\t\t\t}\n\t\t\t\tAdd(j);\n\t\t\t}\n\t\t\tRot(c[i],1);\n\t\t}\n\t\tAdd(i);\n\t}\n\treturn !printf(\"%llu\\n\",ans/24);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 405;\n \nint n;\nvector<int> a[N];\nmap<long long, int> mp, m;\n \nvoid add(vector<int>& a, map<long long, int>& mp) {\n    for (int r = 0; r < 4; ++r) {\n        long long cur = 0;\n        for (int j = 0; j < 4; ++j) {\n            cur = cur * 1000 + a[(j + r) % 4];\n        }\n        ++mp[cur];\n    }\n}\n \nvoid remove(vector<int>& a, map<long long, int>& mp) {\n    for (int r = 0; r < 4; ++r) {\n        long long cur = 0;\n        for (int j = 0; j < 4; ++j) {\n            cur = cur * 1000 + a[(j + r) % 4];\n        }\n        --mp[cur];\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        a[i].resize(4);\n        for (int j = 0; j < 4; ++j) {\n            scanf(\"%d\", &a[i][j]);\n        }\n        add(a[i], mp);\n    }\n    long long result = 0;\n    vector<int> b, q;\n    for (int i = 0; i < n; ++i) {\n        remove(a[i], mp);\n        for (int j = i + 1; j < n; ++j) {\n            remove(a[j], mp);\n            m = mp;\n            q = a[j];\n            reverse(q.begin(), q.end());\n            for (int r = 0; r < 4; ++r) {\n                long long cur = 1;\n                for (int x = 0; x < 4; ++x) {\n                    b.clear();\n                    b.resize(4);\n                    b[0] = a[i][x]; \n                    b[3] = a[i][(x + 1) % 4];\n                    b[1] = q[(x + r) % 4];\n                    b[2] = q[(x + r + 1) % 4];\n                    long long val = 0;\n                    for (int y = 0; y < 4; ++y) {\n                        val = val * 1000 + b[y];\n                    }\n                    cur *= m[val];\n                    remove(b, m);\n                }\n                result += cur;\n                for (int x = 0; x < 4; ++x) {\n                    b.clear();\n                    b.resize(4);\n                    b[0] = a[i][x]; \n                    b[3] = a[i][(x + 1) % 4];\n                    b[1] = q[(x + r) % 4];\n                    b[2] = q[(x + r + 1) % 4];\n                    long long val = 0;\n                    for (int y = 0; y < 4; ++y) {\n                        val = val * 1000 + b[y];\n                    }\n                    add(b, m);\n                }\n            }\n            add(a[j], mp);\n        }\n    }\n    cout << result << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\nconst int MAXN=405;\n\nlong long encode(long long a,long long b,long long c,long long d)\n{\n\treturn (a<<30LL)|(b<<20LL)|(c<<10LL)|d;\n}\n\nmap<long long,long long> cnt;\nvoid Add(long long c,int delta)\n{\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tcnt[c]+=delta;\n\t\tc=(c>>10LL)|((c&1023LL)<<30LL);\n\t}\n}\n\nint n;\nint c[MAXN][4];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",c[i],c[i]+1,c[i]+2,c[i]+3);\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),1);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tAdd(encode(c[i][0],c[i][1],c[i][2],c[i][3]),-1);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),-1);\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tlong long u[4]=\n\t\t\t\t{encode(c[i][1],c[i][0],c[j][(k+1)&3],c[j][(k+0)&3]),\n\t\t\t\t encode(c[i][0],c[i][3],c[j][(k+2)&3],c[j][(k+1)&3]),\n\t\t\t\t encode(c[i][3],c[i][2],c[j][(k+3)&3],c[j][(k+2)&3]),\n\t\t\t\t encode(c[i][2],c[i][1],c[j][(k+0)&3],c[j][(k+3)&3])\n\t\t\t\t};\n\t\t\t\tif(cnt[u[0]]&&cnt[u[1]]&&cnt[u[2]]&&cnt[u[3]])\n\t\t\t\t{\n\t\t\t\t\tlong long tmp=1;\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\t\ttmp*=cnt[u[l]],Add(u[l],-1);\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\t\tAdd(u[l],1);\n\t\t\t\t\tans+=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAdd(encode(c[j][0],c[j][1],c[j][2],c[j][3]),1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 404;\nint cs[4][MAX];\n\nusing A = array<int, 8>;\nA rotH(A x){\n  A y;\n  y[0]=x[1];\n  y[1]=x[2];\n  y[2]=x[3];\n  y[3]=x[0];\n\n  y[7]=x[6];\n  y[6]=x[5];\n  y[5]=x[4];\n  y[4]=x[7];\n  return y;\n}\n\nA rotN(A x){\n  A y;\n  y[0]=x[3];\n  y[3]=x[4];\n  y[4]=x[7];\n  y[7]=x[0];\n\n  y[1]=x[2];\n  y[2]=x[5];\n  y[5]=x[6];\n  y[6]=x[1];\n  return y;\n}\n\nusing ll = long long;\nll make_hash(ll a,ll b,ll c,ll d){\n  return (a<<30)|(b<<20)|(c<<10)|d;\n}\n\nmap<ll, int> cnt,idx;\nll hs[4][MAX]={};\n\nvoid inc(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]++;\n  cnt[hs[1][k]]++;\n  cnt[hs[2][k]]++;\n  cnt[hs[3][k]]++;\n}\nvoid dec(ll v){\n  int k=idx[v];\n  cnt[hs[0][k]]--;\n  cnt[hs[1][k]]--;\n  cnt[hs[2][k]]--;\n  cnt[hs[3][k]]--;\n}\n\nll check(A x){\n  ll a=make_hash(x[0],x[1],x[2],x[3]);\n  ll b=make_hash(x[4],x[5],x[6],x[7]);\n\n  ll c=make_hash(x[3],x[2],x[5],x[4]);\n  ll d=make_hash(x[2],x[1],x[6],x[5]);\n  ll e=make_hash(x[1],x[0],x[7],x[6]);\n  ll f=make_hash(x[0],x[3],x[4],x[7]);\n\n  if(!cnt.count(a)) return 0;\n  if(!cnt.count(b)) return 0;\n  if(!cnt.count(c)) return 0;\n  if(!cnt.count(d)) return 0;\n  if(!cnt.count(e)) return 0;\n  if(!cnt.count(f)) return 0;\n\n  ll res=1;\n  res*=cnt[a];dec(a);\n  res*=cnt[b];dec(b);\n  res*=cnt[c];dec(c);\n  res*=cnt[d];dec(d);\n  res*=cnt[e];dec(e);\n  res*=cnt[f];dec(f);\n\n  inc(a);\n  inc(b);\n  inc(c);\n  inc(d);\n  inc(e);\n  inc(f);\n\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>cs[0][i]>>cs[1][i]>>cs[2][i]>>cs[3][i];\n    for(int z=0;z<4;z++){\n      hs[z][i]=make_hash(cs[(z+0)%4][i],\n                         cs[(z+1)%4][i],\n                         cs[(z+2)%4][i],\n                         cs[(z+3)%4][i]);\n      cnt[hs[z][i]]++;\n      idx[hs[z][i]]=i;\n    }\n  }\n\n  ll ans=0;\n  set<A> used;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<i;j++){\n      for(int z=0;z<4;z++){\n        A x;\n        for(int k=0;k<4;k++){\n          x[k+0]=cs[k][i];\n          x[k+4]=cs[(k+z)%4][j];\n        }\n        if(used.count(x)) continue;\n        int way=0;\n        A y(x),w;\n        for(int i=0;i<8;i++) w[i]=i;\n        set<A> seen;\n\n        for(int p=0;p<4;p++){\n          for(int q=0;q<4;q++){\n            for(int r=0;r<4;r++){\n              if(!seen.count(w)){\n                if(x==y) way++;\n                seen.emplace(w);\n              }\n              used.emplace(x);\n              x=rotH(x);\n              w=rotH(w);\n            }\n            x=rotN(x);\n            w=rotN(w);\n          }\n          x=rotH(x);\n          w=rotH(w);\n        }\n        ans+=check(x)/way;\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<deque<Int>, Int> cnt;\n  using face = deque<Int>;\n  \n  auto add=[&](face v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v.emplace_back(Int(v.front()));\n      v.pop_front();\n    }\n  };\n  \n  \n  for(Int i=0;i<n;i++){\n    face v(4);\n    for(Int j=0;j<4;j++) cin>>v[j];\n    add(v,1);\n  }\n  \n  vector<face> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = deque<Int>;\n  auto right=[&](sq v){\n    vector<Int> ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](sq v){\n    vector<Int> ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](sq v){\n    vector<Int> ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  set<sq> used;\n  auto dup=[&](sq a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(b);\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n  \n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=b[i][k];\n      for(Int k=0;k<4;k++) a[k+4]=b[j][k];\n      if(used.count(a)) continue;\n      \n      face w({a[2],a[1],a[4],a[7]});\n      face x({a[0],a[3],a[6],a[5]});\n      face y({a[3],a[2],a[7],a[6]});\n      face z({a[1],a[0],a[5],a[4]});\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);\n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 600\n#define int long long\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint c[N][10],n,C[N][10],fac[10];\nll A[N],Ans;\nmap <ll,int> M;\ninline int fnd(long long y)\n{\n\tint x[4]; \n\tfor(int i=0;i<4;i++) x[i]=y&((1<<10)-1),y>>=10;\n\tif(x[0]==x[1]&&x[1]==x[2]&&x[2]==x[3]) return 4;\n\tif(x[0]==x[2]&&x[1]==x[3]) return 2;\n\treturn 1;\n}\ninline ll hsh(int x,int y,int z,int s)\n{\n\tll xs=(1ll*x<<30)+(1ll*y<<20)+(1ll*z<<10)+s;\n\treturn xs;\n}\ninline ll trans(int x,int y,int z,int s)\n{\n\treturn min(min(hsh(x,y,z,s),hsh(y,z,s,x)),min(hsh(z,s,x,y),hsh(s,x,y,z)));\n}\nsigned main()\n{\n\tn=read(); for(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<4;j++) c[i][j]=read();\n\t\tA[i]=trans(c[i][0],c[i][1],c[i][2],c[i][3]);\n\t}\n\tfac[0]=1; fac[1]=1; fac[2]=2; fac[3]=6; fac[4]=24;\n\tC[0][0]=1; for(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;for(int j=1;j<=4;j++)\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t} \n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint y[4];\n\t\t\t\ty[0]=trans(c[i][(k+1)%4],c[i][(k+0)%4],c[j][1],c[j][0]);\n\t\t\t\ty[1]=trans(c[i][(k+0)%4],c[i][(k+3)%4],c[j][2],c[j][1]);\n\t\t\t\ty[2]=trans(c[i][(k+3)%4],c[i][(k+2)%4],c[j][3],c[j][2]);\n\t\t\t\ty[3]=trans(c[i][(k+2)%4],c[i][(k+1)%4],c[j][0],c[j][3]);\n\t\t\t\tsort(y,y+4); ll ret=1;\n\t\t\t\tfor(int p=0;p<4;p++)\n\t\t\t\t{\n\t\t\t\t\tint s=p; while(y[s]==y[p]) s++;\n\t\t\t\t\tint tot=M[y[p]];\n\t\t\t\t\tif(A[j]==y[p]) tot--;\n\t\t\t\t\tif(s-p>tot) {ret=0; break;}\n\t\t\t\t\tfor(int t=1;t<=s-p;t++) ret*=fnd(y[p]); \n\t\t\t\t\tret*=C[tot][s-p]*fac[s-p];\n\t\t\t\t\tp=s-1;\n\t\t\t\t}\n\t\t\t\tAns+=ret;\n\t\t\t}\n\t\t}\n\t\tM[A[i]]++;\n\t\t//cout << A[i] << \" \" << M[A[i]] << endl;\n\t}\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <map>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 410;\n\nstruct Col{ \n\tint c1, c2, c3, c4;\n\tbool operator < (const Col& S) const {\n\t\tif (c1 != S.c1) return c1 < S.c1;\n\t\tif (c2 != S.c2) return c2 < S.c2;\n\t\tif (c3 != S.c3) return c3 < S.c3;\n\t\treturn c4 < S.c4;\n\t}\n\tbool operator == (const Col& S) {\n\t\treturn c1 == S.c1 && c2 == S.c2 && c3 == S.c3 && c4 == S.c4;\t\n\t}\n\t\n} c[N];\nmap<Col, int> m;\n\nvoid add(Col x, int v)\n{\n\tRep(i, 4){\n\t\tm[x] += v;\n\t\tint tmp = x.c1;\n\t\tx.c1 = x.c2, x.c2 = x.c3, x.c3 = x.c4, x.c4 = tmp;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) {\n\t\tscanf(\"%d%d%d%d\", &c[i].c1, &c[i].c2, &c[i].c3, &c[i].c4);\n\t\tm[(Col){c[i].c1, c[i].c2, c[i].c3, c[i].c4}] ++;\n\t\tm[(Col){c[i].c2, c[i].c3, c[i].c4, c[i].c1}] ++;\n\t\tm[(Col){c[i].c3, c[i].c4, c[i].c1, c[i].c2}] ++;\n\t\tm[(Col){c[i].c4, c[i].c1, c[i].c2, c[i].c3}] ++;\n\t}\n\tLL ans = 0;\n\tRep(i, n) for (int j = i + 1; j <= n; j ++) {\n\t\tint ti = m[c[i]], tj = m[c[j]];\n\t\tif (ti) add(c[i], -1); if (tj) add(c[j], -1);\n\t\tCol tmp = (Col){c[j].c4, c[j].c3, c[j].c2, c[j].c1};\n\t\tRep(k, 4) {\n\t\t\tLL tans = 1;\n\t\t\tint mt1, mt2, mt3, mt4;\n\t\t\tCol t1 = (Col){tmp.c1, tmp.c2, c[i].c2, c[i].c1};\n\t\t\tmt1 = m[t1], tans *= mt1;\n\t\t\tif (mt1) add(t1, -1);\n\t\t\tCol t2 = (Col){tmp.c2, tmp.c3, c[i].c3, c[i].c2};\n\t\t\tmt2 = m[t2], tans *= mt2;\n\t\t\tif (mt2) add(t2, -1);\n\t\t\tCol t3 = (Col){tmp.c3, tmp.c4, c[i].c4, c[i].c3};\n\t\t\tmt3 = m[t3], tans *= mt3;\n\t\t\tif (mt3) add(t3, -1);\n\t\t\tCol t4 = (Col){tmp.c4, tmp.c1, c[i].c1, c[i].c4};\n\t\t\ttans *= m[t4];\n\t\t\tif (mt1) add(t1, 1);\n\t\t\tif (mt2) add(t2, 1);\n\t\t\tif (mt3) add(t3, 1);\n\t\t\t\n\t\t\tint ttmp = tmp.c1;\n\t\t\ttmp.c1 = tmp.c2, tmp.c2 = tmp.c3, tmp.c3 = tmp.c4, tmp.c4 = ttmp;\n\t\t\tans += tans;\n\t\t//\tprintf(\"%d %d %d %d %d\\n\", i, j, k, tans);\n\t\t}\n\t\tif (ti) add(c[i], 1); if (tj) add(c[j], 1);\n\t}\n\t\n\tprintf(\"%lld\\n\", ans / 3);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef array<int,4> A;\n\nLL toLL(A a){\n\tA r=a;\n\tfor(int i=0;i<3;i++){\n\t\trotate(a.begin(),a.begin()+1,a.end());\n\t\tr=min(r,a);\n\t}\n\tLL v=0;\n\tfor(int i=0;i<4;i++){\n\t\tv<<=10;\n\t\tv+=r[i];\n\t}\n\treturn v;\n}\nLL ord(A a){\n\tif(a[0]==a[2]&&a[1]==a[3]){\n\t\tif(a[0]==a[1]){\n\t\t\treturn 4;\n\t\t}\n\t\treturn 2;\n\t}\n\treturn 1;\n}\nLL vs[400];\nA C[400];\nint main() {\n\tint N;\n\tscanf(\"%d\",&N);\n\tunordered_map<LL,int> cnt;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tC[i][j]=a;\n\t\t}\n\t\tvs[i]=toLL(C[i]);\n\t\tcnt[vs[i]]++;\n\t}\n\tLL ret=0;\n\tfor(int i=0;i<N;i++){\n\t\tcnt[vs[i]]--;\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tcnt[vs[j]]--;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tLL r=1;\n\t\t\t\tLL u[4];\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tA a={{C[i][(4-l+1)%4],C[i][(4-l)%4],C[j][(l+k+1)%4],C[j][(l+k)%4]}};\n\t\t\t\t\tLL v=toLL(a);\n\t\t\t\t\tr*=ord(a)*cnt[v];\n#if 0\n\t\t\t\t\tif(i==0&&j==4){\n\t\t\t\t\t\tcerr << a[0] << \", \" << a[1] << \", \" << a[2] << \", \" << a[3] << endl;\n\t\t\t\t\t\tcerr << cnt[v] << endl;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tu[l]=v;\n\t\t\t\t\tcnt[v]--;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tcnt[u[l]]++;\n\t\t\t\t}\n\t\t\t\tret+=r;\n\t\t\t}\n\t\t\tcnt[vs[j]]++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      //cout<<bitset<40>(v)<<\":\"<<x<<endl;\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = deque<Int>;\n  auto right=[&](const sq &v){\n    vector<Int> ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    vector<Int> ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    vector<Int> ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  set<sq> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(b);\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    for(Int j=0;j<(Int)b.size();j++){\n      sq a(8);\n      for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(a)) continue;\n\n      auto calc=[](Int a,Int b,Int c,Int d){\n\treturn ((((((d<<10)|c)<<10)|b)<<10)|a);\n      };\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 310010\n#define offset 30010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<short,short> ii;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nconst ll MOD=1e9+7;\nvi V[tam];\nmap<iiii,ll> todo;\nvector<iiii> vper;\nvi auxmove(4,0);\niiii move(vi &nuevo,ll &delta)\n{\n    \n    forr(i,0,4)\n    {\n        auxmove[i]=(nuevo[(i+delta)%4]);\n    }\n    return mp(mp(auxmove[0],auxmove[1]),mp(auxmove[2],auxmove[3]));\n}\nvoid add(vi &nuevo,ll delta,map<iiii,ll> &mapa)\n{\n    //permutar(nuevo);\n    forr(i,0,4)\n    {\n        mapa[move(nuevo,i)]+=delta;\n    }\n}\nvector<iiii> vcaras(4);\niiii auxcara;\nvoid gocaras(vi &v1,vi& v2)\n{\n    auxcara.fi.fi=v1[0],auxcara.se.se=v1[1],auxcara.fi.se=v2[0],auxcara.se.fi=v2[3];vcaras[0]=auxcara;\n    auxcara.fi.fi=v1[1],auxcara.se.se=v1[2],auxcara.fi.se=v2[3],auxcara.se.fi=v2[2];vcaras[1]=auxcara;\n    auxcara.fi.fi=v1[2],auxcara.se.se=v1[3],auxcara.fi.se=v2[2],auxcara.se.fi=v2[1];vcaras[2]=auxcara;\n    auxcara.fi.fi=v1[0],auxcara.se.se=v2[0],auxcara.fi.se=v1[3],auxcara.se.fi=v2[1];vcaras[3]=auxcara;\n\n}\nvoid fiiv(vi &v1,iiii val)\n{\n    if (v1.size()<4)\n        v1.assign(4,0);\n    v1[0]=val.fi.fi;\n    v1[1]=val.fi.se;\n    v1[2]=val.se.fi;\n    v1[3]=val.se.se;\n}\nint main()\n{\n   ios::sync_with_stdio(false);cin.tie(0);\n   ll n;\n   cin>>n;\n   forr(i,0,n)\n   {\n        vi nuevo(4);\n        forr(j,0,4)\n            cin>>nuevo[j];\n        add(nuevo,1,todo);\n        V[i]=nuevo;\n   }\n   vi cara1,cara2;\n   //permutar(V[2]);\n   map<iiii,ll> extra;\n   ll totp,answer=0,auxtotp;\n   //return 0;\n   vi vcarasvii;\n   forr(i,0,n)\n   {\n        forr(j,i+1,n)\n        {\n            if (i==j)continue;\n            //i=0,j=4;\n            forr(ki,0,4)\n            {\n                forr(kj,0,4)\n                {\n                    extra.clear();\n                    fiiv(cara1,move(V[i],ki));\n                    fiiv(cara2,move(V[j],kj));\n                    /*<<\"comenzamos\\n\";\n                    prll(cara1);\n                    prll(cara2);\n                    <<\"\\n\";*/\n                    gocaras(cara1,cara2);\n                    /*forr(l,0,vcaras.size()){\n                        prll(vcaras[l]);\n                    } */     \n                    //<<endl;\n                    add(cara1,1,extra);\n                    add(cara2,1,extra);\n                    //vcaras.pb(cara1);\n                    //vcaras.pb(cara2);\n                    totp=1;\n                    forr(l,0,vcaras.size())\n                    {\n                        //<<totp<<' '<<l<<\" \"<<todo[vcaras[l]]<<endl;\n                        auxtotp=todo[vcaras[l]]-extra[vcaras[l]];\n                        totp*=(auxtotp);\n                        fiiv(vcarasvii,vcaras[l]);\n                        add(vcarasvii,1,extra);\n                    }\n         //           <<endl;\n                    answer+=totp;\n\n                }\n            }\n            //break;\n        }\n        //break;\n   }\n   //cout<<answer<<endl;\n   cout<<answer/12<<endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<map>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=410;\nstruct State {\n\tint a,b,c,d;\n\tbool operator < (const State& S) const {\n\t\tif(a!=S.a) return a<S.a;\n\t\tif(b!=S.b) return b<S.b;\n\t\tif(c!=S.c) return c<S.c;\n\t\treturn d<S.d;\n\t}\n\tbool operator == (const State& S) {\n\t\treturn a==S.a&&b==S.b&&c==S.c&&d==S.d;\n\t}\n}A[maxn][4];\nmap<State,int> M;\nvoid del(State x) {\n\tM[(State){x.a,x.b,x.c,x.d}]--;\n\tM[(State){x.b,x.c,x.d,x.a}]--;\n\tM[(State){x.c,x.d,x.a,x.b}]--;\n\tM[(State){x.d,x.a,x.b,x.c}]--;\n}\nvoid add(State x) {\n\tM[(State){x.a,x.b,x.c,x.d}]++;\n\tM[(State){x.b,x.c,x.d,x.a}]++;\n\tM[(State){x.c,x.d,x.a,x.b}]++;\n\tM[(State){x.d,x.a,x.b,x.c}]++;\n}\nint main() {\n\tint n=read();\n\trep(i,1,n) {\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tA[i][0]=(State){a,b,c,d};\n\t\tA[i][1]=(State){b,c,d,a};\n\t\tA[i][2]=(State){c,d,a,b};\n\t\tA[i][3]=(State){d,a,b,c};\n\t\tM[A[i][0]]++;M[A[i][1]]++;M[A[i][2]]++;M[A[i][3]]++;\n\t}\n\tll ans=0;\n\trep(i,1,n) rep(j,i+1,n) if(i!=j) {\n\t\tdel(A[i][0]);del(A[j][0]);\n\t\trep(y,0,3) {\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t\tState S[4];\n\t\t\tS[0]=(State){A[i][0].b,A[i][0].a,A[j][y].a,A[j][y].b};\n\t\t\tS[1]=(State){A[j][y].b,A[j][y].c,A[i][0].c,A[i][0].b};\n\t\t\tS[2]=(State){A[i][0].d,A[i][0].c,A[j][y].c,A[j][y].d};\n\t\t\tS[3]=(State){A[j][y].a,A[i][0].a,A[i][0].d,A[j][y].d};\n\t\t\tint c1=M[S[0]];del(S[0]);\n\t\t\tint c2=M[S[1]];del(S[1]);\n\t\t\tint c3=M[S[2]];del(S[2]);\n\t\t\tint c4=M[S[3]];del(S[3]);\n\t\t\tans+=(ll)c1*c2*c3*c4;\n\t\t\trep(k,0,3) add(S[k]);\n\t\t\tswap(A[j][y].a,A[j][y].b);swap(A[j][y].c,A[j][y].d);\n\t\t}\n\t\tadd(A[i][0]);add(A[j][0]);\n\t}\n\tprintf(\"%lld\\n\",ans/3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define lowbit(i) i&-i\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\tull ans=0; For(i,0,5)ans=ans<<15^rand(); return ans;\n}\nconst int N=405;\nint a[N][4],ycl[4];\nll yc[N];\nunordered_map<ll,int> to;\nmap<ll,int> t;\nll chu(int a[4]){\n\tll ans=0; \n\tvector<int> v;\n\tFor(i,0,3)v.pb(a[i]);\n\tFor(i,1,3){\n\t\tvector<int> b;\n\t\tFor(j,0,3)b.pb(a[(i+j)%4]);\n\t\tif(b<v)v=b;\n\t}\n\t//For(i,0,3)cout<<a[i]<<\" \"; puts(\"\"); for(auto i:v)wri(i); puts(\"fjz\");\n\tFor(i,0,3)ans+=(ll)v[i]*ycl[i];\n\treturn ans;\n}\nll c(int a,int b){\n\tll ans=1; \n\tfor(int i=a;i>a-b;i--)ans*=i;\n\t//For(i,2,b)ans/=i;\n\treturn ans;\n}\nint get(ll x){\n\tauto it=to.find(x);\n\tif(it!=to.end())return it->second; else return 0;\n}\nvoid add(int i,int y){\n\tto[yc[i]]+=y;\n}\nint main(){\n\tint n=read();\n\tFor(i,ycl[0]=1,3)ycl[i]=ycl[i-1]*1000;\n\tFor(i,1,n){\n\t\tFor(j,0,3){a[i][j]=read();} yc[i]=chu(a[i]); add(i,1);\n\t}\n\tll ans=0;\n\tFor(i,1,n){\n\t\tadd(i,-1);\n\t\tFor(j,i+1,n){\n\t\t\tadd(j,-1);\n\t\t\tFor(k,0,3){\n\t\t\t\tint q[4],B[4];\n\t\t\t\tFor(l,0,3)B[l]=a[j][3^((l+k)%4)];\n\t\t\t\tt.clear();\n\t\t\t\tll sum=1;\n\t\t\t\tFor(l,0,3){\n\t\t\t\t\tq[3]=a[i][l]; q[2]=a[i][(l+1)%4];\n\t\t\t\t\tq[0]=B[l]; q[1]=B[(l+1)%4];\n\t\t\t\t\t/*if(i==1&&j==5&&k==2){\n\t\t\t\t\t\tFor(o,0,3)wri(q[o]); puts(\"\");\n\t\t\t\t\t}*/\n\t\t\t\t\tif(q[0]==q[2]&&q[1]==q[3]){sum*=2;\n\t\t\t\t\tif(q[0]==q[1])sum*=2;}\n\t\t\t\t\t//cerr<<sum<<endl;\n\t\t\t\t\tt[chu(q)]++;\n\t\t\t\t}\n\t\t\t\tfor(auto i:t){\n\t\t\t\t\tsum=sum*c(get(i.fi),i.se);\n\t\t\t\t}\n\t\t\t\t//if(i==1&&j==8&&k==0)cout<<sum<<\" \"<<t.size()<<endl;\n\t\t\t\tans+=sum;\n\t\t\t}\n\t\t\tadd(j,1);\n\t\t}\n\t\tadd(i,1);\n\t}\n\tcout<<ans/3<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define ll long long\n#define N 410\nusing namespace std;\nstruct node{\n\tint a,b,c,d;\n\tnode(int A=0,int B=0,int C=0,int D=0):a(A),b(B),c(C),d(D){}\n\tvoid rotate(){int t=a;a=b,b=c,c=d,d=t;}\n\tbool operator<(const node u)const\n\t{\n\t\tif(a!=u.a) return a<u.a;\n\t\tif(b!=u.b) return b<u.b;\n\t\tif(c!=u.c) return c<u.c;\n\t\treturn d<u.d;\n\t}\n\tnode operator <<(const int a)const{node p=*this;for(int i=1;i<=a%4;i++){int swp=p.a;p.a=p.b;p.b=p.c;p.c=p.d;p.d=swp;}return p;}\n\tvoid operator <<=(const int a){*this=(*this)<<a;}\n}p[N];\nnode operator |(const node a,const node b)\n{\n\treturn node(a.b,a.a,b.a,b.d);\n}\nmap<node,int>mp;\nvoid insert(node a)\n{\n\tmp[a]++;mp[a<<1]++;\n\tmp[a<<2]++;mp[a<<3]++;\n}\nvoid del(node a){mp[a]--;mp[a<<1]--;mp[a<<2]--;mp[a<<3]--;}\nnode np[4],s1,s2;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&p[i].a,&p[i].b,&p[i].c,&p[i].d);\n\t\tinsert(p[i]);\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdel(p[i]);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tdel(p[j]);\n\t\t\tfor(int k=0;k<4;++k)\n\t\t\t{\n\t\t\t\tp[j]<<=1;s1=p[i],s2=p[j];\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t{\n\t\t\t\t\tnp[l]=s1|s2;\n\t\t\t\t\ts1<<=1,s2<<=3;\n\t\t\t\t}\n\t\t\t\tif(mp.count(np[0]) && mp.count(np[1]) && mp.count(np[2]) && mp.count(np[3]))\n\t\t\t\t{\n\t\t\t\t\tlong long sum=1ll;\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tsum*=mp[np[l]],del(np[l]);\n\t\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t\tinsert(np[l]);\n\t\t\t\t\tans+=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsert(p[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#define int         int64_t\n#define ii          pair<int,int>\n#define dd          pair<double,double>\n#define vi          vector<int>\n#define pb          push_back\n#define all(x)      (x).begin(), (x).end()\n#define checkBit(v, p)      (v&(1LL << p))\n#define loop(i,a,b) for(int i = a;i < int(b);i++)\n#define x           first\n#define y           second\nusing namespace std;\n\nint inf = 4e18, mod = 1e9+7;\n\nvoid rot(vi& val){\n    rotate(val.begin(),val.begin()+1,val.end());\n}\n\nmap<vi, int> mp;\n\nvoid upd(vi &p, bool f){\n    for(int i=0;i<4;i++, rot(p)){\n        if(f) ++mp[p];\n        else --mp[p];\n    }\n}\n\nint check(vi u, vi d){\n    int ans = 1;\n    vector<vi> rem;\n    reverse(d.begin()+1,d.end());\n    for(int i=0;i<4;i++, rot(u), rot(d)){\n        vi can(4);\n        can[0] = u[1];\n        can[1] = u[0];\n        can[2] = d[0];\n        can[3] = d[1];\n\n        if(mp.find(can) == mp.end()){\n            ans = 0;\n            break;\n        }\n        rem.pb(can);\n        ans *= mp[can];\n        upd(can, false);\n    }\n    for(auto &p:rem) upd(p,true);\n    return ans;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false); cout << fixed <<setprecision(0);\n    int n,sum = 0; cin >> n;\n    vi val(4);\n    for(int i=0;i<n;i++){\n        for(auto &v:val) cin >> v;\n        upd(val,true);\n    }\n    for(auto &up:mp){\n        vi curUp = up.first;\n        int valUp = up.second;\n        upd(curUp,false);\n\n        for(auto &down : mp){\n            int valDown = down.second;\n            vi curDown = down.first;\n            upd(curDown,false);\n            sum += check(curUp,curDown) * valUp * valDown;\n            upd(curDown,true);\n        }\n        upd(curUp,true);\n    }\n    cout << sum / 24<< endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nnamespace std {\n    template <>\n    class hash<std::pair<Int, Int>> {\n    public:\n        size_t operator()(const std::pair<Int, Int>& x) const{\n            return hash<Int>()(x.first) ^ hash<Int>()(x.second);\n        }\n    };\n}\nsigned main(){\n  Int n;\n  cin>>n;\n  unordered_map<Int, Int> cnt;\n  \n  auto add=[&](Int v,Int x){\n    for(Int i=0;i<4;i++){\n      cnt[v]+=x;\n      v=((v&1023)<<30)|(v>>10);\n    }\n  };\n  \n  for(Int i=0;i<n;i++){\n    Int v=0,x;\n    for(Int j=0;j<4;j++) cin>>x,v|=x<<(j*10);\n    add(v,1);\n  }\n  \n  vector<Int> b;\n  for(auto p:cnt) b.emplace_back(p.first);\n\n  using sq = vector<Int>;\n  auto right=[&](const sq &v){\n    static const sq ord({1,4,7,2,5,0,3,6});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n  auto front=[&](const sq &v){\n    static const sq ord({5,4,1,0,7,6,3,2});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };  \n  auto clock=[&](const sq &v){\n    static const sq ord({3,0,1,2,5,6,7,4});\n    sq a(8);\n    for(Int i=0;i<8;i++) a[i]=v[ord[i]];\n    return a;\n  };\n\n  using P = pair<Int, Int>;\n  auto calc=[](Int a,Int b,Int c,Int d){\n    return ((((((d<<10)|c)<<10)|b)<<10)|a);\n  };\n  auto conv=[&](const sq &a){\n    return P(calc(a[0],a[1],a[2],a[3]),calc(a[4],a[5],a[6],a[7]));\n  };\n  \n  set<P> used;\n  auto dup=[&](const sq &a)->Int{\n    Int res=0;\n    sq b(a);\n    for(Int i=0;i<6;i++){\n      for(Int j=0;j<4;j++){\n\tres+=(a==b);\n\tused.emplace(conv(b));\n\tb=clock(b);\n      }\n      if(i==0||i==4) b=right(b);\n      else b=front(b);\n    }\n    return res;\n  };\n\n  Int ans=0;\n  for(Int i=0;i<(Int)b.size();i++){\n    sq a(8);\n    for(Int k=0;k<4;k++) a[k]=(b[i]>>(k*10))&1023;\n    \n    for(Int j=0;j<(Int)b.size();j++){\n      for(Int k=0;k<4;k++) a[k+4]=(b[j]>>(k*10))&1023;\n      if(used.count(conv(a))) continue;\n      \n      Int w=calc(a[2],a[1],a[4],a[7]);\n      Int x=calc(a[0],a[3],a[6],a[5]);\n      Int y=calc(a[3],a[2],a[7],a[6]);\n      Int z=calc(a[1],a[0],a[5],a[4]);\n\n      //continue;\n      \n      Int res=cnt[b[i]];\n      add(b[i],-1);      \n      \n      res*=cnt[b[j]];      \n      add(b[j],-1);\n      \n      res*=cnt[w];\n      add(w,-1);\n\n      res*=cnt[x];\n      add(x,-1);\n\n      res*=cnt[y];\n      add(y,-1);\n\n      res*=cnt[z];\n      add(z,-1);\n\n      add(b[i],1);\n      add(b[j],1);\n      add(w,1);\n      add(x,1);\n      add(y,1);\n      add(z,1);\n      \n      res/=dup(a);\n      ans+=res;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 400;\nmap<LL,LL> occ;\nLL arr[N + 5][4];\nLL f[N + 5];\nLL tmp[4];\n\nvoid shifting(LL x, int add) { //rotate \n\tfor(int i = 0;i < 4;i++) {\n\t\tocc[x] += add;\n\t\tx = ((x >> 10) | ((x & 1023) << 30));\n\t}\n}\n\nLL hashw(LL a, LL b, LL c, LL d) { //hashing four corner color into one integer\n\treturn (a << 30LL) | (b << 20LL) | (c << 10LL) | d;\n}\n\n\nint main(){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i = 0;i < n;i++) {\n\t\tfor(int j = 0;j < 4;j++) cin>>arr[i][j];\n\t\tf[i] = hashw(arr[i][0], arr[i][1], arr[i][2], arr[i][3]);\n\t\tshifting(f[i], 1);\n\t}\n\tLL tot = 0;\n\tfor(int i = 0;i < n;i++) {\n\t\tshifting(f[i], -1); //fixing front side\n\t\tfor(int j = i + 1;j < n;j++) {\n\t\t\tshifting(f[j], -1); //fixing back side\n\t\t\tfor(int k = 0;k < 4;k++) {\n\t\t\t\ttmp[0] = hashw(arr[i][3], arr[i][2], arr[j][(1 + k) % 4], arr[j][k % 4]);\n\t\t\t\ttmp[1] = hashw(arr[i][2], arr[i][1], arr[j][(2 + k) % 4], arr[j][(k + 1) % 4]);\n\t\t\t\ttmp[2] = hashw(arr[i][1], arr[i][0], arr[j][(3 + k) % 4], arr[j][(k + 2) % 4]);\n\t\t\t\ttmp[3] = hashw(arr[i][0], arr[i][3], arr[j][(k) % 4], arr[j][(k + 3) % 4]);\n\t\t\t\tLL res = 1;\n\t\t\t\tfor(int i = 0;i < 4;i++) {\n\t\t\t\t\tres *= occ[tmp[i]];\n\t\t\t\t\tshifting(tmp[i], -1);\n\t\t\t\t}\n\t\t\t\ttot += res;\n\t\t\t\tfor(int i = 0;i < 4;i++) shifting(tmp[i], 1);\n\t\t\t}\n\t\t\tshifting(f[j], 1); \n\t\t}\n\t}\n\tcout<<tot<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 400\nint aa[] = {4, 0, 3, 7}, bb[] = {1, 5, 6, 2}, cc[] = {5, 4, 7, 6};\nint n;\nvector<int> c[N];\nvector<int> c2[4*N];\nvector<int> c3[N];\nmap<vector<int>, int> cnt;\n\nvoid rot(vector<int> &a){\n\tint t = a[0];\n\trep(i, 3) a[i] = a[i+1];\n\ta[3] = t;\n}\n\nvoid rot2(vector<int> &a){\n\tvector<int> b(a);\n\trep(i, 3){\n\t\trot(b);\n\t\tif(a>b) a = b;\n\t}\n}\n\nint f(vector<int> &a){\n\tif(a[0]!=a[2] || a[1]!=a[3]) return 1;\n\tif(a[0]!=a[1]) return 2;\n\treturn 4;\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n){\n\t\tc[i] = vector<int>(4);\n\t\trep(j, 4) cin>>c[i][j];\n\t\trep(j, 4){\n\t\t\tc2[i*4+j] = c[i];\n\t\t\t++cnt[c[i]];\n\t\t\trot(c[i]);\n\t\t}\n\t\trot2(c[i]);\n\t\tc3[i] = c[i];\n\t}\n\tll res = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tvector<int> e(8);\n\t\trep(_, 4) e[_] = c[i][_];\n\t\tfor(int jj = 0; jj < n*4; jj++){\n\t\t\tint j = jj/4, j2 = j%4;\n\t\t\tif(i==j) continue;\n\t\t\tif(!(c2[jj][2]==c[i][1]&&c2[jj][3]==c[i][0])) continue;\n\t\t\te[4] = c2[jj][0];\n\t\t\te[5] = c2[jj][1];\n\t\t\tfor(int kk = 0; kk < n*4; kk++){\n\t\t\t\tint k = kk/4, k2 = k%4;\n\t\t\t\tif(i==k || j==k) continue;\n\t\t\t\tif(!(c2[kk][0]==c[i][3]&&c2[kk][1]==c[i][2])) continue;\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\t//cerr<<res<<endl;\n\t\t\t\te[6] = c2[kk][2];\n\t\t\t\te[7] = c2[kk][3];\n\n\t\t\t\tvector<int> a(4), b(4), c(4);\n\t\t\t\trep(_, 4){\n\t\t\t\t\ta[_] = e[aa[_]];\n\t\t\t\t\tb[_] = e[bb[_]];\n\t\t\t\t\tc[_] = e[cc[_]];\n\t\t\t\t}\n\t\t\t\trot2(a); rot2(b); rot2(c);\n\t\t\t\tif(!cnt[a]||!cnt[b]||!cnt[c]) continue;\n\t\t\t\tif(a==b && b==c){\n\t\t\t\t\tll t = cnt[a];\n\t\t\t\t\tll r = f(a);\n\t\t\t\t\tll s = 0;\n\t\t\t\t\tif(c3[i]==a) s++;\n\t\t\t\t\tif(c3[j]==a) s++;\n\t\t\t\t\tif(c3[k]==a) s++;\n\t\t\t\t\tt -= s*r;\n\t\t\t\t\tll tres = t*(t-r)*(t-r*2);\n\t\t\t\t\tif(tres>0) res += tres;\n\t\t\t\t} else {\n\t\t\t\t\tif(a==c) swap(b, c);\n\t\t\t\t\tif(b==c) swap(a, c);\n\t\t\t\t\tif(a==b){\n\t\t\t\t\t\tll t = cnt[a];\n\t\t\t\t\t\tll r = f(a), r2 = f(c);\n\t\t\t\t\t\tll s = 0, s2 = 0;\n\t\t\t\t\t\tif(c3[i]==a) s++;\n\t\t\t\t\t\tif(c3[j]==a) s++;\n\t\t\t\t\t\tif(c3[k]==a) s++;\n\t\t\t\t\t\tif(c3[i]==c) s2++;\n\t\t\t\t\t\tif(c3[j]==c) s2++;\n\t\t\t\t\t\tif(c3[k]==c) s2++;\n\t\t\t\t\t\tt -= s*r;\n\t\t\t\t\t\tll tres = t*(t-r)*(cnt[c]-s2*r2);\n\t\t\t\t\t\tif(tres>0 && t-r>0) res += tres;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tll r = f(a), r2 = f(b), r3 = f(c);\n\t\t\t\t\t\tll s = 0, s2 = 0, s3 = 0;\n\t\t\t\t\t\tif(c3[i]==a) s++;\n\t\t\t\t\t\tif(c3[j]==a) s++;\n\t\t\t\t\t\tif(c3[k]==a) s++;\n\t\t\t\t\t\tif(c3[i]==b) s2++;\n\t\t\t\t\t\tif(c3[j]==b) s2++;\n\t\t\t\t\t\tif(c3[k]==b) s2++;\n\t\t\t\t\t\tif(c3[i]==c) s3++;\n\t\t\t\t\t\tif(c3[j]==c) s3++;\n\t\t\t\t\t\tif(c3[k]==c) s3++;\n\t\t\t\t\t\tll tres = (cnt[a]-s*r)*(cnt[b]-s2*r2)*(cnt[c]-s3*r3);\n\t\t\t\t\t\tif(tres>0 && cnt[a]-s*r>0 && cnt[b]-s2*r2>0) res += tres;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res/6<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define N 410\n#define ll long long\nusing namespace std;\nint n, a[N][4];\nll ans, ans1, b[5];\nmap<ll, int>mp;\ninline ll id(ll a, int b, int c, int d){return (a<<30)+(b<<20)+(c<<10)+d;}\ninline void ins(ll x, int y){\n\tint a=x>>30, b=(x>>20)&1023, c=(x>>10)&1023, d=x&1023;\n\tmp[id(a, b, c, d)]+=y;\n\tmp[id(b, c, d, a)]+=y;\n\tmp[id(c, d, a, b)]+=y;\n\tmp[id(d, a, b, c)]+=y;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tmp.clear();\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=0; j<=3; j++)scanf(\"%d\", &a[i][j]);\n\t\tins(id(a[i][0], a[i][1], a[i][2], a[i][3]), 1);\n\t}\n\tans=0;\n\tfor(int i=1; i<=n-5; i++){\n\t\tins(id(a[i][0], a[i][1], a[i][2], a[i][3]), -1);\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t\tfor(int k=0; k<=3; k++){\n\t\t\t\tins(id(a[j][0], a[j][1], a[j][2], a[j][3]), -1);\n\t\t\t\tb[1]=id(a[i][0], a[j][(0+k)%4], a[j][(3+k)%4], a[i][1]);\n\t\t\t\tb[2]=id(a[i][1], a[j][(3+k)%4], a[j][(2+k)%4], a[i][2]);\n\t\t\t\tb[3]=id(a[i][2], a[j][(2+k)%4], a[j][(1+k)%4], a[i][3]);\n\t\t\t\tb[4]=id(a[i][3], a[j][(1+k)%4], a[j][(0+k)%4], a[i][0]);\n\t\t\t\tif(mp[b[1]]&&mp[b[2]]&&mp[b[3]]&&mp[b[4]]){\n\t\t\t\t\tans1=1; for(int ii=1; ii<=4; ii++){ans1*=mp[b[ii]]; ins(b[ii], -1);}\n\t\t\t\t\tans+=ans1; for(int ii=1; ii<=4; ii++)ins(b[ii], 1);\n\t\t\t\t}\n\t\t\t\tins(id(a[j][0], a[j][1], a[j][2], a[j][3]), 1);\n\t\t\t}\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n  int N,i1,i2,i3,i4,i5,i6,j,k,l,m,n,c0,c1,c2,c3,c4,c5,c6,c7,count=0;\n  scanf(\"%d\",&N);\n  int c[N][4];\n  for(i1=0;i1<N;++i1) scanf(\"%d %d %d %d\",&c[i1][0],&c[i1][1],&c[i1][2],&c[i1][3]);\n  for(i1=0;i1<N-5;++i1){\n    c0=c[i1][0];c1=c[i1][1];c2=c[i1][2];c3=c[i1][3];\n    for(i2=i1+1;i2<N;++i2){\n      for(j=0;j<4;++j){\n        if(c0==c[i2][j]&&c1==c[i2][(j+3)%4]){\n          c4=c[i2][(j+1)%4];\n          c5=c[i2][(j+2)%4];\n          for(i3=i1+1;i3<N;++i3){\n            if(i3==i2) continue;\n            for(k=0;k<4;++k){\n              if(c1==c[i3][k]&&c5==c[i3][(k+1)%4]&&c2==c[i3][(k+3)%4]){\n                c6=c[i3][(k+2)%4];\n                for(i4=i1+1;i4<N;++i4){\n                  if(i4==i2||i4==i3) continue;\n                    for(l=0;l<4;++l){\n                      if(c2==c[i4][l]&&c6==c[i4][(l+1)%4]&&c3==c[i4][(l+3)%4]){\n                        c7=c[i4][(l+2)%4];\n                        for(i5=i1+1;i5<N;++i5){\n                          if(i5==i2||i5==i3||i5==i4) continue;\n                            for(m=0;m<4;++m){\n                              if(c4==c[i5][m]&&c0==c[i5][(m+1)%4]&&c7==c[i5][(m+3)%4]&&c3==c[i5][(m+2)%4]){\n                                for(i6=i1+1;i6<N;++i6){\n                                  if(i6==i2||i6==i3||i6==i4||i6==i5) continue;\n                                  for(n=0;n<4;++n){\n                                    if(c5==c[i6][n]&&c4==c[i6][(n+1)%4]&&c6==c[i6][(n+3)%4]&&c7==c[i6][(n+2)%4]){\n                                      ++count;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                        }\n                      }\n                    }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",count);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<stdio.h>\n\nlong long calcce(long long pt[]){\n  if(pt[0]==pt[1]&&pt[1]==pt[2]&&pt[2]==pt[3]){return 4;}\n  if(pt[0]==pt[2]&&pt[1]==pt[3]){return 2;}\n  return 1;\n}\n\nlong long cha[1024][4];\nlong long ispt(long long tg,long long hash){\n  if(cha[tg][0]==hash){return 1;}\n  if(cha[tg][1]==hash){return 1;}\n  if(cha[tg][2]==hash){return 1;}\n  if(cha[tg][3]==hash){return 1;}\n  return 0;\n}\n\nlong long calc(long long cnt[]){\n  long long i,j,k,l,res=0,dt;\n  long long pj,pk,pl,lm=0;\n  for(i=8;i<16;i++){lm+=cnt[i];}\n  //printf(\"%lld\\n\",lm);\n  //for(i=0;i<16;i++){printf(\"[%lld]\",cnt[i]);}printf(\"\\n\");\n  for(i=1;i<16;i+=2){//if((i&1)==0){continue;}\n    if(cnt[i]==0){continue;}\n    if(i&8ll){lm--;}\n    dt=cnt[i];cnt[i]--;\n    pj=dt;\n    for(j=0;j<16;j++){if((j&2)==0){continue;}\n      if(cnt[j]==0){continue;}\n      if(j&8ll){lm--;}\n      dt*=cnt[j];cnt[j]--;\n      pk=dt;\n      for(k=0;k<16;k++){if((k&4)==0){continue;}\n        if(cnt[k]==0){continue;}\n        if(k&8ll){lm--;}\n        dt*=cnt[k];cnt[k]--;\n        res+=dt*lm;\n        //for(l=8;l<16;l++){//if((l&8)==0){continue;}\n        //  if(cnt[l]==0){continue;}\n        //  dt*=cnt[l];cnt[l]--;\n        //  res+=dt;\n        //  cnt[l]++;\n        //  dt=pl;\n        //}\n        if((k&8ll)!=0){lm++;}\n        cnt[k]++;\n        dt=pk;\n      }\n      if((j&8ll)!=0){lm++;}\n      cnt[j]++;\n      dt=pj;\n    }\n    if((i&8ll)!=0){lm++;}\n    cnt[i]++;\n  }\n  return res;\n}\n\nint main(){\n  srand(0);\n  long long n,i,j,k,l,m,f,ce,res=0,tf,mem;\n  long long c[512][4];\n  long long jt[4],kt[4];\n  long long md[4][4];\n  long long cnt[16]={0};\n  long long nha,mha[4];\n  scanf(\"%lld\",&n);\n  //n=400;\n  for(i=0;i<n;i++){\n    nha=0;\n    for(j=0;j<4;j++){\n      scanf(\"%lld\",&c[i][j]);\n      //c[i][j]=rand()%4;\n      nha|=(c[i][j]<<(10*j));\n    }\n    for(j=0;j<4;j++){\n      cha[i][j]=nha;\n      mem=(nha&((1ll<<10)-1));\n      //printf(\"[%lld]<%lld>\",cha[i][j],mem);\n      nha>>=10;\n      nha|=(mem<<30);\n    }//printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<4;j++){jt[j]=c[i][j];}\n    for(j=i+1;j<n;j++){\n      for(k=0;k<4;k++){\n        for(l=0;l<4;l++){\n          kt[l]=c[j][(4+k-l)&3ll];\n        }\n        ce=1;\n        for(l=0;l<4;l++){\n          md[l][0]=jt[l];\n          md[l][1]=jt[(l+3)&3ll];\n          md[l][2]=kt[(l+3)&3ll];\n          md[l][3]=kt[l];\n          mha[l]=(md[l][0]|(md[l][1]<<10)|(md[l][2]<<20)|(md[l][3]<<30));\n          //printf(\"<%lld %lld %lld %lld : %lld>\\n\",md[l][0],md[l][1],md[l][2],md[l][3],mha[l]);\n          ce*=calcce(md[l]);\n        }\n        for(l=0;l<16;l++){cnt[l]=0;}\n        tf=0;\n        for(l=i+1;l<n;l++){\n          if(l==j){continue;}\n          f=0;\n          for(m=0;m<4;m++){\n            if(ispt(l,mha[m])==1){f|=(1ll<<m);}\n          }\n          //printf(\"%lld\\n\",f);\n          tf|=f;\n          cnt[f]++;\n        }\n        if(tf!=15){continue;}\n        res+=ce*calc(cnt);\n      }\n    }\n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<stdio.h>\n\nlong long calcce(long long pt[]){\n  if(pt[0]==pt[1]&&pt[1]==pt[2]&&pt[2]==pt[3]){return 4;}\n  if(pt[0]==pt[2]&&pt[1]==pt[3]){return 2;}\n  return 1;\n}\n\nlong long cha[1024][4];\nlong long ispt(long long tg,long long hash){\n  if(cha[tg][0]==hash){return 1;}\n  if(cha[tg][1]==hash){return 1;}\n  if(cha[tg][2]==hash){return 1;}\n  if(cha[tg][3]==hash){return 1;}\n  return 0;\n}\n\nlong long calc(long long cnt[]){\n  long long i,j,k,l,res=0,dt;\n  long long pj,pk,pl;\n  //for(i=0;i<16;i++){printf(\"[%lld]\",cnt[i]);}printf(\"\\n\");\n  for(i=1;i<16;i+=2){//if((i&1)==0){continue;}\n    if(cnt[i]==0){continue;}\n    dt=cnt[i];cnt[i]--;\n    pj=dt;\n    for(j=0;j<16;j++){if((j&2)==0){continue;}\n      if(cnt[j]==0){continue;}\n      dt*=cnt[j];cnt[j]--;\n      pk=dt;\n      for(k=0;k<16;k++){if((k&4)==0){continue;}\n        if(cnt[k]==0){continue;}\n        dt*=cnt[k];cnt[k]--;\n        pl=dt;\n        for(l=8;l<16;l++){//if((l&8)==0){continue;}\n          if(cnt[l]==0){continue;}\n          dt*=cnt[l];cnt[l]--;\n          res+=dt;\n          cnt[l]++;\n          dt=pl;\n        }\n        cnt[k]++;\n        dt=pk;\n      }\n      cnt[j]++;\n      dt=pj;\n    }\n    cnt[i]++;\n  }\n  return res;\n}\n\nint main(){\n  //printf(\"%lld\\n\",(1ll<<10) + (2ll<<20) + (3ll<<30));\n  srand(0);\n  long long n,i,j,k,l,m,f,ce,res=0,tf,mem;\n  long long c[512][4];\n  long long jt[4],kt[4];\n  long long md[4][4];\n  long long cnt[16]={0};\n  long long nha,mha[4];\n  scanf(\"%lld\",&n);\n  //n=400;\n  for(i=0;i<n;i++){\n    nha=0;\n    for(j=0;j<4;j++){\n      scanf(\"%lld\",&c[i][j]);\n      //c[i][j]=rand()%4;\n      nha|=(c[i][j]<<(10*j));\n    }\n    for(j=0;j<4;j++){\n      cha[i][j]=nha;\n      mem=(nha&((1ll<<10)-1));\n      //printf(\"[%lld]<%lld>\",cha[i][j],mem);\n      nha>>=10;\n      nha|=(mem<<30);\n    }//printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<4;j++){jt[j]=c[i][j];}\n    for(j=i+1;j<n;j++){\n      for(k=0;k<4;k++){\n        for(l=0;l<4;l++){\n          kt[l]=c[j][(4+k-l)&3ll];\n        }\n        ce=1;\n        for(l=0;l<4;l++){\n          md[l][0]=jt[l];\n          md[l][1]=jt[(l+3)&3ll];\n          md[l][2]=kt[(l+3)&3ll];\n          md[l][3]=kt[l];\n          mha[l]=(md[l][0]|(md[l][1]<<10)|(md[l][2]<<20)|(md[l][3]<<30));\n          //printf(\"<%lld %lld %lld %lld : %lld>\\n\",md[l][0],md[l][1],md[l][2],md[l][3],mha[l]);\n          ce*=calcce(md[l]);\n        }\n        for(l=0;l<16;l++){cnt[l]=0;}\n        tf=0;\n        for(l=i+1;l<n;l++){\n          if(l==j){continue;}\n          f=0;\n          for(m=0;m<4;m++){\n            if(ispt(l,mha[m])==1){f|=(1ll<<m);}\n          }\n          //printf(\"%lld\\n\",f);\n          tf|=f;\n          cnt[f]++;\n        }\n        if(tf!=15){continue;}\n        res+=ce*calc(cnt);\n      }\n    }\n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong long calcce(long long pt[]){\n  if(pt[0]==pt[1]&&pt[1]==pt[2]&&pt[2]==pt[3]){return 4;}\n  if(pt[0]==pt[2]&&pt[1]==pt[3]){return 2;}\n  return 1;\n}\n\nlong long ispt(long long a[],long long b[]){\n  long long i,j;\n  for(i=0;i<4;i++){\n    for(j=0;j<4;j++){\n      if(a[j]!=b[(i+j)%4]){break;}\n      if(j==3){return 1;}\n    }\n  }\n  return 0;\n}\n\nlong long calc(long long cnt[]){\n  long long i,j,k,l,res=0,dt;\n  long long pj,pk,pl;\n  //for(i=0;i<16;i++){printf(\"[%lld]\",cnt[i]);}printf(\"\\n\");\n  for(i=1;i<16;i+=2){//if((i&1)==0){continue;}\n    if(cnt[i]==0){continue;}\n    dt=cnt[i];cnt[i]--;\n    pj=dt;\n    for(j=0;j<16;j++){if((j&2)==0){continue;}\n      if(cnt[j]==0){continue;}\n      dt*=cnt[j];cnt[j]--;\n      pk=dt;\n      for(k=0;k<16;k++){if((k&4)==0){continue;}\n        if(cnt[k]==0){continue;}\n        dt*=cnt[k];cnt[k]--;\n        pl=dt;\n        for(l=8;l<16;l++){//if((l&8)==0){continue;}\n          if(cnt[l]==0){continue;}\n          dt*=cnt[l];cnt[l]--;\n          res+=dt;\n          cnt[l]++;\n          dt=pl;\n        }\n        cnt[k]++;\n        dt=pk;\n      }\n      cnt[j]++;\n      dt=pj;\n    }\n    cnt[i]++;\n  }\n  return res;\n}\n\nint main(){\n  long long n,i,j,k,l,m,f,ce,res=0;\n  long long c[512][4];\n  long long jt[4],kt[4];\n  long long md[4][4];\n  long long cnt[16]={0};\n  scanf(\"%lld\",&n);\n  for(i=0;i<n;i++){\n    for(j=0;j<4;j++){\n      scanf(\"%lld\",&c[i][j]);\n    }\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<4;j++){jt[j]=c[i][j];}\n    for(j=i+1;j<n;j++){\n      for(k=0;k<4;k++){\n        for(l=0;l<4;l++){\n          kt[l]=c[j][(4+k-l)%4];\n        }\n        ce=1;\n        for(l=0;l<4;l++){\n          md[l][0]=jt[l];\n          md[l][1]=jt[(l+3)%4];\n          md[l][2]=kt[(l+3)%4];\n          md[l][3]=kt[l];\n          ce*=calcce(md[l]);\n        }\n        for(l=0;l<16;l++){cnt[l]=0;}\n        for(l=i+1;l<n;l++){\n          if(l==j){continue;}\n          f=0;\n          for(m=0;m<4;m++){\n            if(ispt(c[l],md[m])==1){f|=(1ll<<m);}\n          }\n          //printf(\"%lld\\n\",f);\n          cnt[f]++;\n        }\n        res+=ce*calc(cnt);\n      }\n    }\n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong long calcce(long long pt[]){\n  if(pt[0]==pt[1]&&pt[1]==pt[2]&&pt[2]==pt[3]){return 4;}\n  if(pt[0]==pt[2]&&pt[1]==pt[3]){return 2;}\n  return 1;\n}\n\nlong long cha[1024][4];\nlong long ispt(long long tg,long long hash){\n  if(cha[tg][0]==hash){return 1;}\n  if(cha[tg][1]==hash){return 1;}\n  if(cha[tg][2]==hash){return 1;}\n  if(cha[tg][3]==hash){return 1;}\n  return 0;\n}\n\nlong long calc(long long cnt[]){\n  long long i,j,k,l,res=0,dt;\n  long long pj,pk,pl;\n  //for(i=0;i<16;i++){printf(\"[%lld]\",cnt[i]);}printf(\"\\n\");\n  for(i=1;i<16;i+=2){//if((i&1)==0){continue;}\n    if(cnt[i]==0){continue;}\n    dt=cnt[i];cnt[i]--;\n    pj=dt;\n    for(j=0;j<16;j++){if((j&2)==0){continue;}\n      if(cnt[j]==0){continue;}\n      dt*=cnt[j];cnt[j]--;\n      pk=dt;\n      for(k=0;k<16;k++){if((k&4)==0){continue;}\n        if(cnt[k]==0){continue;}\n        dt*=cnt[k];cnt[k]--;\n        pl=dt;\n        for(l=8;l<16;l++){//if((l&8)==0){continue;}\n          if(cnt[l]==0){continue;}\n          dt*=cnt[l];cnt[l]--;\n          res+=dt;\n          cnt[l]++;\n          dt=pl;\n        }\n        cnt[k]++;\n        dt=pk;\n      }\n      cnt[j]++;\n      dt=pj;\n    }\n    cnt[i]++;\n  }\n  return res;\n}\n\nint main(){\n  //printf(\"%lld\\n\",(1ll<<10) + (2ll<<20) + (3ll<<30));\n  srand(0);\n  long long n,i,j,k,l,m,f,ce,res=0,tf,mem;\n  long long c[512][4];\n  long long jt[4],kt[4];\n  long long md[4][4];\n  long long cnt[16]={0};\n  long long nha,mha[4];\n  scanf(\"%lld\",&n);\n  //n=400;\n  for(i=0;i<n;i++){\n    nha=0;\n    for(j=0;j<4;j++){\n      scanf(\"%lld\",&c[i][j]);\n      //c[i][j]=rand()%4;\n      nha|=(c[i][j]<<(10*j));\n    }\n    for(j=0;j<4;j++){\n      cha[i][j]=nha;\n      mem=(nha&((1ll<<10)-1));\n      //printf(\"[%lld]<%lld>\",cha[i][j],mem);\n      nha>>=10;\n      nha|=(mem<<30);\n    }//printf(\"\\n\");\n  }\n  for(i=0;i<n;i++){\n    for(j=0;j<4;j++){jt[j]=c[i][j];}\n    for(j=i+1;j<n;j++){\n      for(k=0;k<4;k++){\n        for(l=0;l<4;l++){\n          kt[l]=c[j][(4+k-l)&3ll];\n        }\n        ce=1;\n        for(l=0;l<4;l++){\n          md[l][0]=jt[l];\n          md[l][1]=jt[(l+3)&3ll];\n          md[l][2]=kt[(l+3)&3ll];\n          md[l][3]=kt[l];\n          mha[l]=(md[l][0]|(md[l][1]<<10)|(md[l][2]<<20)|(md[l][3]<<30));\n          //printf(\"<%lld %lld %lld %lld : %lld>\\n\",md[l][0],md[l][1],md[l][2],md[l][3],mha[l]);\n          ce*=calcce(md[l]);\n        }\n        for(l=0;l<16;l++){cnt[l]=0;}\n        tf=0;\n        for(l=i+1;l<n;l++){\n          if(l==j){continue;}\n          f=0;\n          for(m=0;m<4;m++){\n            if(ispt(l,mha[m])==1){f|=(1ll<<m);}\n          }\n          //printf(\"%lld\\n\",f);\n          tf|=f;\n          cnt[f]++;\n        }\n        if(tf!=15){continue;}\n        res+=ce*calc(cnt);\n      }\n    }\n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint[][] C = io.nextIntArray2D(n, 4);\n\t\t\tlong ans = 0;\n\t\t\t\n//\t\t\tint[] p1 = new int[]{0, 1, 2, 3,};\n\t\t\tint[] p2 = new int[]{1, 0, 3, 2,};\n\t\t\t\n\t\t\tRollingHashMod[] rh = new RollingHashMod[n];\n\t\t\tfor(int i = 0; i < n; i++) rh[i] = new RollingHashMod(C[i]);\n\t\t\t\n\t\t\tfinal TreeMap<Long, Integer> mp = new TreeMap<>();\n\n//\t\t\tdump(3, rh[3].str, rh[3].minRotateIndex());\n//\t\t\tif(true) throw new RuntimeException();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tlong h = rh[i].minRotateHash();\n\t\t\t\tmp.put(h, mp.getOrDefault(h, 0) + 1);\n//\t\t\t\tdump(i, rh[i].str, rh[i].minRotateIndex(), h);\n\t\t\t}\n//\t\t\tif(true) throw new RuntimeException();\n\t\t\t\n\t\t\tint[] dup = new int[4];\n\t\t\t\n\t\t\t/*\n\t\t\t * 1 2\n\t\t\t * 3 4\n\t\t\t * \n\t\t\t * 1 2\n\t\t\t * 3 4\n\t\t\t */\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tmp.put(rh[i].minRotateHash(), mp.get(rh[i].minRotateHash()) - 1);\n\t\t\t\tfor(int j = i + 1; j < n; j++) for(int d = 0; d < 4; d++) {\n\t\t\t\t\tArrays.fill(dup, 1);\n\t\t\t\t\tRollingHashMod[] hs = new RollingHashMod[4];\n\t\t\t\t\tfor(int s = 0; s < 4; s++) {\n\t\t\t\t\t\ths[s] = new RollingHashMod(C[i][(s+1)&3], C[i][(s+0)&3], C[j][p2[(s+d+0)&3]], C[j][p2[(s+d+1)&3]]);\n\t\t\t\t\t}\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor(int s = 0; s < 4; s++) if(dup[s] == 1) {\n\t\t\t\t\t\tfor(int k = s + 1; k < 4; k++) {\n\t\t\t\t\t\t\tif(hs[s].minRotateHash() == hs[k].minRotateHash()) {\n\t\t\t\t\t\t\t\tdup[k] = -1;\n\t\t\t\t\t\t\t\tdup[s]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \n\t\t\t\t\t\tint cnt = mp.getOrDefault(hs[s].minRotateHash(), 0);\n\t\t\t\t\t\tif(rh[j].minRotateHash() == hs[s].minRotateHash()) {\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint hi = hs[s].minRotateIndex();\n\t\t\t\t\t\tint sym = 1;\n\t\t\t\t\t\tif(hs[s].minRotateHash() == hs[s].hash((hi + 1) % 4, (hi + 1) % 4)) {\n\t\t\t\t\t\t\tsym = 4;\n\t\t\t\t\t\t} else if(hs[s].minRotateHash() == hs[s].hash((hi + 2) % 4, (hi + 2) % 4)) {\n\t\t\t\t\t\t\tsym = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong pow = 1;\n\t\t\t\t\t\tlong comb_fact = 1;\n\t\t\t\t\t\tfor(int k = 0; k < dup[s]; k++) {\n\t\t\t\t\t\t\tpow *= sym;\n\t\t\t\t\t\t\tcomb_fact *= cnt - k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval *= pow * comb_fact;\n//\t\t\t\t\t\tif(i == 1 && j == 3 && d == 3) {\n//\t\t\t\t\t\t\tdump(i, j, s, dup[s], sym, cnt, hs[s].str, hs[s].minRotateHash(), hs[s].minRotateIndex(), val);\n//\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tdump(i, j, d, dup, val);\n\t\t\t\t\tans += val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass RollingHashMod {\n\t\tprivate static final int[] LARGE_PRIMES = new int[]{\n\t\t\t1000000007, 1000000009, 1000000021, 1000000033,\n\t\t\t1000000087, 1000000093, 1000000097, 1000000103,\n\t\t\t1000000123, 1000000181, 1000000207, 1000000223,\n\t\t\t1000000241, 1000000271, 1000000289, 1000000297,\n\t\t\t1000000321, 1000000349, 1000000363, 1000000403,\n\t\t};\n\n\t\tprivate static final Random random = new Random(0);\n\t\tprivate static final int HASH_NUM = 2;\n//\t\tprivate static final long RADIX = 1000000409;\n\t\tprivate static final long RADIX = 1000000003;\n\t\tprivate static final long XOR = random.nextLong();\n\t\t\n\t\tprivate int n;\n\t\tprivate static int[] primes;\n\t\tprivate int[] str;\n\t\tprivate int[][] pow;\n\t\tprivate int[][] table;\n\t\t\n\t\tpublic RollingHashMod(int... str) {\n\t\t\tif(primes == null) {\n//\t\t\t\tfinal Random random = new Random(System.currentTimeMillis());\n\t\t\t\tprimes = new int[HASH_NUM];\n\t\t\t\tfor(int i = 0; i < HASH_NUM; i++) {\n\t\t\t\t\tfinal int idx = random.nextInt(LARGE_PRIMES.length - i);\n\t\t\t\t\tprimes[i] = LARGE_PRIMES[idx];\n\t\t\t\t\tLARGE_PRIMES[idx] = LARGE_PRIMES[LARGE_PRIMES.length - i - 1];\n\t\t\t\t\tLARGE_PRIMES[LARGE_PRIMES.length - i - 1] = primes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tn = str.length;\n\n\t\t\tthis.str = str.clone();\n\t\t\ttable = new int[HASH_NUM][n + 1];\n\t\t\tpow = new int[HASH_NUM][n + 1];\n\t\t\t\n\t\t\tfor(int j = 0; j < HASH_NUM; j++) {\n\t\t\t\tfinal int p = primes[j];\n\t\t\t\tpow[j][0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\ttable[j][i + 1] = (int)(((long)table[j][i] * RADIX + (this.str[i]^XOR)%p + p) % p);\n\t\t\t\t\tpow[j][i + 1] = (int)((long)pow[j][i] * RADIX % p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long hash(int i, int j) {\n\t\t\tif(j >= n) {\n\t\t\t\tj -= n;\n\t\t\t}\n\t\t\tif(i >= j) {\n\t\t\t\treturn hashRotate(i, j);\n\t\t\t} else {\n\t\t\t\treturn hash(0, i, j) << 32 | hash(1, i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long hashRotate(int i, int j) {\n\t\t\tassert(i >= j);\n\t\t\tlong h0 = hash(0, i, n) * pow[0][j] % primes[0] + table[0][j];\n\t\t\tlong h1 = hash(1, i, n) * pow[1][j] % primes[1] + table[1][j];\n\t\t\tif(h0 >= primes[0]) h0 -= primes[0];\n\t\t\tif(h1 >= primes[1]) h1 -= primes[1];\n//\t\t\tdump(str, i, j, h0, h1, hash(0, i, n), table[0]);\n\t\t\treturn h0 << 32 | h1;\n\t\t}\n\t\t\n\t\tprivate long hash(int idx, int i, int j) {\n\t\t\tassert(i <= j);\n\t\t\tlong h0 = table[idx][j] - (long)table[idx][i] * pow[idx][j - i] % primes[idx];\n\t\t\tif(h0 < 0) h0 += primes[idx];\n\t\t\treturn h0;\n\t\t}\n\t\t\n\t\tpublic long minRotateHash() {\n\t\t\tint s = minRotateIndex();\n\t\t\treturn hash(s, s);\n\t\t}\n\t\t\n\t\tprivate int minRotateCache = -1;\n\t\tpublic int minRotateIndex() {\n\t\t\tif(minRotateCache != -1) return minRotateCache;\n\t\t\t\n\t\t\tint s = n - 1;\n\t\t\tfor(int i = n - 2; i >= 0; i--) {\n\t\t\t\tint low = 0, high = n;\n\t\t\t\twhile(high - low > 1) {\n\t\t\t\t\tint mid = (low + high) / 2;\n\t\t\t\t\tif(hash(i, i + mid) == hash(s, s + mid)) {\n\t\t\t\t\t\tlow = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thigh = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tdump(i, s, str, low, high);\n\t\t\t\tif(str[(i + low) % n] <= str[(s + low) % n]) {\n\t\t\t\t\ts = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minRotateCache = s;\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int k = 0; k < n; ++k)\n          if (k != i) {\n            long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n            long bk2 = rmask;\n            for (int p = 0; p < 4; ++p) {\n              int idx = table.get(bk2);\n              --count[idx];\n              bk2 = rotater(bk2);\n            }\n            for (int p = 0; p < 4; ++p) {\n              long prod = 1;\n              long rrmask = rmask;\n              long llmask = lmask;\n              boolean okay = true;\n              Deque<Integer> queue = new ArrayDeque<Integer>();\n              for (int q = 0; q < 4; ++q) {\n                long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                if (table.containsKey(mask)) {\n                  prod *= count[table.get(mask)];\n                  long bk3 = mask;\n                  for (int r = 0; r < 4; ++r) {\n                    int idx = table.get(bk3);\n                    --count[idx];\n                    queue.add(idx);\n                    bk3 = rotater(bk3);\n                  }\n                } else\n                  okay = false;\n                llmask = rotater(llmask);\n                rrmask = rotatel(rrmask);\n              }\n              if (okay) {\n                acc += prod;\n                if (acc > Long.MAX_VALUE / 12 && acc % 6 == 0) {\n                  list.add(acc);\n                  acc = 0;\n                }\n              }\n              while (!queue.isEmpty()) {\n                int idx = queue.poll();\n                ++count[idx];\n              }\n              rmask = rotater(rmask);\n            }\n            for (int p = 0; p < 4; ++p) {\n              int idx = table.get(bk2);\n              ++count[idx];\n              bk2 = rotater(bk2);\n            }\n          }\n        lmask = rotater(lmask);\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 6;\n      ans += acc / 6;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  private static int N;\n  private static int count = 0;\n  private static int[][] C;\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    N = sc.nextInt();\n    C = sc.nextIntTable(N, 4);\n    \n    for (int i = 0; i < N; i ++) {\n      int[] color = {C[i][0], C[i][1], C[i][2], C[i][3], -1, -1, -1, -1};\n      boolean[] used = new boolean[N];\n      used[i] = true;\n\n      dfs(0, color, used);\n    }\n\n    System.out.println(count / 6);\n  }\n  \n  \n  private static final int[][] edge = {\n      {0, 4, 6, 1},\n      {1, 6, 7, 2},\n      {0, 3, 5, 4},\n      {4, 5, 7, 6},\n      {3, 2, 7, 5}\n  };\n  \n  private static void dfs(int place, int[] color, boolean[] used) {\n    if (place == 5) {\n      count ++;\n      return;\n    }\n\n    int a = edge[place][0];\n    int b = edge[place][1];\n    int c = edge[place][2];\n    int d = edge[place][3];\n    int preA = color[a];\n    int preB = color[b];\n    int preC = color[c];\n    int preD = color[d];\n\n    for (int i = 0; i < N; i ++) {\n      if (!used[i]) {\n        used[i] = true;\n            \n        for (int j = 0; j < 4; j ++) {\n          if ((color[a] < 0 || C[i][(j + 0) % 4] == color[a])\n              && (color[b] < 0 || C[i][(j + 1) % 4] == color[b])\n              && (color[c] < 0 || C[i][(j + 2) % 4] == color[c])\n              && (color[d] < 0 || C[i][(j + 3) % 4] == color[d])\n              ) {\n            \n            color[a] = C[i][(j + 0) % 4];\n            color[b] = C[i][(j + 1) % 4];\n            color[c] = C[i][(j + 2) % 4];\n            color[d] = C[i][(j + 3) % 4];\n            dfs(place + 1, color, used);\n          }\n        }\n        used[i] = false;\n      }\n    }\n    color[a] = preA;\n    color[b] = preB;\n    color[c] = preC;\n    color[d] = preD;\n  }\n\n}\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    private Map<Long, Integer> keyDups;\n\n    private void solve(FastScanner sc) {\n        int n = sc.nextInt();\n        long[] keys = new long[n];\n        Map<Long, int[][]> rotates = new HashMap<>();\n        keyDups = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            long key = toKey(a, b, c, d);\n            keys[i] = key;\n            rotates.putIfAbsent(key, toRotates(a, b, c, d));\n            keyDups.computeIfAbsent(key, l -> 0);\n            keyDups.compute(key, (l, old) -> old + 1);\n        }\n        long count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int[] foot = rotates.get(keys[i])[0];\n                for (int[] head : rotates.get(keys[j])) {\n                    long ka = toKey(head[1], head[0], foot[1], foot[0]);\n                    long kb = toKey(head[2], head[1], foot[0], foot[3]);\n                    long kc = toKey(head[3], head[2], foot[3], foot[2]);\n                    long kd = toKey(head[0], head[3], foot[2], foot[1]);\n                    long kh = toKey(head[0], head[1], head[2], head[3]);\n                    long kf = toKey(foot[0], foot[1], foot[2], foot[3]);\n                    keyDups.compute(kh, (l, old) -> old - 1);\n                    keyDups.compute(kf, (l, old) -> old - 1);\n                    int a = match(head[1], head[0], foot[1], foot[0]);\n                    keyDups.computeIfPresent(ka, (l, old) -> old - 1);\n                    int b = match(head[2], head[1], foot[0], foot[3]);\n                    keyDups.computeIfPresent(kb, (l, old) -> old - 1);\n                    int c = match(head[3], head[2], foot[3], foot[2]);\n                    keyDups.computeIfPresent(kc, (l, old) -> old - 1);\n                    int d = match(head[0], head[3], foot[2], foot[1]);\n                    keyDups.compute(kh, (l, old) -> old + 1);\n                    keyDups.compute(kf, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(ka, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(kb, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(kc, (l, old) -> old + 1);\n                    count += a * b * c * d;\n                }\n            }\n        }\n        System.out.println(count/6);\n    }\n\n    private int match(int a, int b, int c, int d) {\n        long key = toKey(a, b, c, d);\n        int m = a == c && b == d ? (a == b ? 4 : 2) : 1;\n        return keyDups.containsKey(key) ? keyDups.get(key) * m : 0;\n    }\n\n    private int[][] toRotates(int a, int b, int c, int d) {\n        int[][] rs = new int[4][];\n        rs[0] = new int[]{a, b, c, d};\n        rs[1] = new int[]{b, c, d, a};\n        rs[2] = new int[]{c, d, a, b};\n        rs[3] = new int[]{d, a, b, c};\n        return rs;\n    }\n\n    private long toKey(int a, int b, int c, int d) {\n        return Math.min(Math.min(\n                a * 1000000000L + b * 1000000L + c * 1000 + d,\n                b * 1000000000L + c * 1000000L + d * 1000 + a), Math.min(\n                c * 1000000000L + d * 1000000L + a * 1000 + b,\n                d * 1000000000L + a * 1000000L + b * 1000 + c));\n    }\n\n    /*\n     * template\n     */\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        new Main().solve(sc);\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int bufLen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < bufLen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    bufLen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (bufLen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n\t\tlong[][] comb = new long[401][401];\n\t\tlong[] fact = new long[401];\n\t\tfact[0] = 1;\n\t\tfor(int i = 0; i < comb.length; i++) {\n\t\t\tif(i > 0) fact[i] = fact[i-1] * i;\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t\tfor(int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\t\t\t}\n\t\t}\n\t\t\n//\t\tdump(comb[400][6]);\n\t\t\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint[][] C = io.nextIntArray2D(n, 4);\n\t\t\tlong ans = 0;\n\t\t\t\n//\t\t\tint[] p1 = new int[]{0, 1, 2, 3,};\n\t\t\tint[] p2 = new int[]{1, 0, 3, 2,};\n\t\t\t\n\t\t\tRollingHashMod[] rh = new RollingHashMod[n];\n\t\t\tfor(int i = 0; i < n; i++) rh[i] = new RollingHashMod(C[i]);\n\t\t\t\n\t\t\tfinal TreeMap<Long, Integer> mp = new TreeMap<>();\n\n//\t\t\tdump(3, rh[3].str, rh[3].minRotateIndex());\n//\t\t\tif(true) throw new RuntimeException();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tlong h = rh[i].minRotateHash();\n\t\t\t\tmp.put(h, mp.getOrDefault(h, 0) + 1);\n//\t\t\t\tdump(i, rh[i].str, rh[i].minRotateIndex(), h);\n\t\t\t}\n//\t\t\tif(true) throw new RuntimeException();\n\t\t\t\n\t\t\tint[] dup = new int[4];\n\t\t\t\n\t\t\t/*\n\t\t\t * 1 2\n\t\t\t * 3 4\n\t\t\t * \n\t\t\t * 1 2\n\t\t\t * 3 4\n\t\t\t */\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tmp.put(rh[i].minRotateHash(), mp.get(rh[i].minRotateHash()) - 1);\n\t\t\t\tfor(int j = i + 1; j < n; j++) for(int d = 0; d < 4; d++) {\n\t\t\t\t\tArrays.fill(dup, 1);\n\t\t\t\t\tRollingHashMod[] hs = new RollingHashMod[4];\n\t\t\t\t\tfor(int s = 0; s < 4; s++) {\n\t\t\t\t\t\ths[s] = new RollingHashMod(C[i][(s+1)&3], C[i][(s+0)&3], C[j][p2[(s+d+0)&3]], C[j][p2[(s+d+1)&3]]);\n\t\t\t\t\t}\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor(int s = 0; s < 4; s++) if(dup[s] == 1) {\n\t\t\t\t\t\tfor(int k = s + 1; k < 4; k++) {\n\t\t\t\t\t\t\tif(hs[s].minRotateHash() == hs[k].minRotateHash()) {\n\t\t\t\t\t\t\t\tdup[k] = -1;\n\t\t\t\t\t\t\t\tdup[s]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \n\t\t\t\t\t\tint cnt = mp.getOrDefault(hs[s].minRotateHash(), 0);\n\t\t\t\t\t\tif(rh[j].minRotateHash() == hs[s].minRotateHash()) {\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint hi = hs[s].minRotateIndex();\n\t\t\t\t\t\tint sym = 1;\n\t\t\t\t\t\tif(hs[s].minRotateHash() == hs[s].hash((hi + 1) % 4, (hi + 1) % 4)) {\n\t\t\t\t\t\t\tsym = 4;\n\t\t\t\t\t\t} else if(hs[s].minRotateHash() == hs[s].hash((hi + 2) % 4, (hi + 2) % 4)) {\n\t\t\t\t\t\t\tsym = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong pow = 1;\n\t\t\t\t\t\tlong comb_fact = 1;\n\t\t\t\t\t\tfor(int k = 0; k < dup[s]; k++) {\n\t\t\t\t\t\t\tpow *= sym;\n\t\t\t\t\t\t\tcomb_fact *= cnt - k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval *= pow * comb_fact;\n//\t\t\t\t\t\tif(i == 1 && j == 3 && d == 3) {\n//\t\t\t\t\t\t\tdump(i, j, s, dup[s], sym, cnt, hs[s].str, hs[s].minRotateHash(), hs[s].minRotateIndex(), val);\n//\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tdump(i, j, d, dup, val);\n\t\t\t\t\tans += val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass RollingHashMod {\n\t\tprivate static final int[] LARGE_PRIMES = new int[]{\n\t\t\t1000000007, 1000000009, 1000000021, 1000000033,\n\t\t\t1000000087, 1000000093, 1000000097, 1000000103,\n\t\t\t1000000123, 1000000181, 1000000207, 1000000223,\n\t\t\t1000000241, 1000000271, 1000000289, 1000000297,\n\t\t\t1000000321, 1000000349, 1000000363, 1000000403,\n\t\t};\n\n\t\tprivate static final Random random = new Random(0);\n\t\tprivate static final int HASH_NUM = 2;\n//\t\tprivate static final long RADIX = 1000000409;\n\t\tprivate static final long RADIX = 1000000003;\n\t\tprivate static final long XOR = random.nextLong();\n\t\t\n\t\tprivate int n;\n\t\tprivate static int[] primes;\n\t\tprivate int[] str;\n\t\tprivate int[][] pow;\n\t\tprivate int[][] table;\n\t\t\n\t\tpublic RollingHashMod(int... str) {\n\t\t\tif(primes == null) {\n//\t\t\t\tfinal Random random = new Random(System.currentTimeMillis());\n\t\t\t\tprimes = new int[HASH_NUM];\n\t\t\t\tfor(int i = 0; i < HASH_NUM; i++) {\n\t\t\t\t\tfinal int idx = random.nextInt(LARGE_PRIMES.length - i);\n\t\t\t\t\tprimes[i] = LARGE_PRIMES[idx];\n\t\t\t\t\tLARGE_PRIMES[idx] = LARGE_PRIMES[LARGE_PRIMES.length - i - 1];\n\t\t\t\t\tLARGE_PRIMES[LARGE_PRIMES.length - i - 1] = primes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tn = str.length;\n\n\t\t\tthis.str = str.clone();\n\t\t\ttable = new int[HASH_NUM][n + 1];\n\t\t\tpow = new int[HASH_NUM][n + 1];\n\t\t\t\n\t\t\tfor(int j = 0; j < HASH_NUM; j++) {\n\t\t\t\tfinal int p = primes[j];\n\t\t\t\tpow[j][0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\ttable[j][i + 1] = (int)(((long)table[j][i] * RADIX + (this.str[i]^XOR)%p + p) % p);\n\t\t\t\t\tpow[j][i + 1] = (int)((long)pow[j][i] * RADIX % p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long hash(int i, int j) {\n\t\t\tif(j >= n) {\n\t\t\t\tj -= n;\n\t\t\t}\n\t\t\tif(i >= j) {\n\t\t\t\treturn hashRotate(i, j);\n\t\t\t} else {\n\t\t\t\treturn hash(0, i, j) << 32 | hash(1, i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long hashRotate(int i, int j) {\n\t\t\tassert(i >= j);\n\t\t\tlong h0 = hash(0, i, n) * pow[0][j] % primes[0] + table[0][j];\n\t\t\tlong h1 = hash(1, i, n) * pow[1][j] % primes[1] + table[1][j];\n\t\t\tif(h0 >= primes[0]) h0 -= primes[0];\n\t\t\tif(h1 >= primes[1]) h1 -= primes[1];\n//\t\t\tdump(str, i, j, h0, h1, hash(0, i, n), table[0]);\n\t\t\treturn h0 << 32 | h1;\n\t\t}\n\t\t\n\t\tprivate long hash(int idx, int i, int j) {\n\t\t\tassert(i <= j);\n\t\t\tlong h0 = table[idx][j] - (long)table[idx][i] * pow[idx][j - i] % primes[idx];\n\t\t\tif(h0 < 0) h0 += primes[idx];\n\t\t\treturn h0;\n\t\t}\n\t\t\n\t\tpublic long minRotateHash() {\n\t\t\tint s = minRotateIndex();\n\t\t\treturn hash(s, s);\n\t\t}\n\t\t\n\t\tprivate int minRotateCache = -1;\n\t\tpublic int minRotateIndex() {\n\t\t\tif(minRotateCache != -1) return minRotateCache;\n\t\t\t\n\t\t\tint s = n - 1;\n\t\t\tfor(int i = n - 2; i >= 0; i--) {\n\t\t\t\tint low = 0, high = n;\n\t\t\t\twhile(high - low > 1) {\n\t\t\t\t\tint mid = (low + high) / 2;\n\t\t\t\t\tif(hash(i, i + mid) == hash(s, s + mid)) {\n\t\t\t\t\t\tlow = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thigh = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tdump(i, s, str, low, high);\n\t\t\t\tif(str[(i + low) % n] <= str[(s + low) % n]) {\n\t\t\t\t\ts = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minRotateCache = s;\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a = rand.nextInt((int) p - 1) + 1;\n\t\tlong b = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 256;\n\t\tint cnt = 0;\n\t\tLinkedList<Pair>[] list;\n\n\t\tpublic HashMap() {\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = hash(key);\n\t\t\tboolean ret = list[id].remove(key);\n\t\t\tif (sz >= 3 * cnt) {\n\t\t\t\tchangeSize(sz / 2);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid put(long key, long value) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key == key) {\n\t\t\t\t\tlist[id].get(i).value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist[id].add(new Pair(key, value));\n\t\t\t++cnt;\n\n\t\t\tif (cnt > sz) {\n\t\t\t\tchangeSize(2 * sz);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key == key) {\n\t\t\t\t\treturn list[id].get(i).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key != key) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tint hash(long v) {\n\t\t\treturn (int) ((a * v % p + b) % p % sz);\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tLinkedList<Pair>[] tmp = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\ttmp[i] = new LinkedList<>();\n\t\t\t\ttmp[i].addAll(list[i]);\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tfor (Pair p : tmp[i]) {\n\t\t\t\t\tput(p.key, p.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        Deque<Integer> queue1 = new ArrayDeque<Integer>();\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          queue1.add(idx);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              Deque<Integer> queue2 = new ArrayDeque<Integer>();\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                queue2.add(idx);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Integer> queue3 = new ArrayDeque<Integer>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3);\n                      queue3.add(idx);\n                      --count[idx];\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  int idx = queue3.poll();\n                  ++count[idx];\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                int idx = queue2.poll();\n                ++count[idx];\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          int idx = queue1.poll();\n          ++count[idx];\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new TreeMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                long[] bk3 = new long[4];\n                Arrays.fill(bk3, -1);\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    bk3[q] = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      --count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                for (int q = 0; q < 4; ++q)\n                  if (bk3[q] != -1)\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      ++count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                rmask = rotater(rmask);\n              }\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                ++count[idx];\n                bk2 = rotater(bk2);\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        Deque<Long> queue1 = new ArrayDeque<Long>();\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          queue1.add(bk1);\n          --count[table.get(bk1)];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              Deque<Long> queue2 = new ArrayDeque<Long>();\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                queue2.add(bk2);\n                --count[table.get(bk2)];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Long> queue3 = new ArrayDeque<Long>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      queue3.add(bk3);\n                      --count[table.get(bk3)];\n                      bk3 = rotater(bk3);\n                    }\n                  }\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  long mask = queue3.poll();\n                  ++count[table.get(mask)];\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                long mask = queue2.poll();\n                ++count[table.get(mask)];\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          long mask = queue1.poll();\n          ++count[table.get(mask)];\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tString toKey(int[] c) {\n\t\tString key = c[0] + \",\" + c[1] + \",\" + c[2] + \",\" + c[3] + \",\";\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tString curKey = \"\";\n\t\t\tfor (int j = 0; j < 4; j++) curKey += c[(i+j)%4] + \",\";\n\t\t\tif (key.compareTo(curKey) > 0) key = curKey; \n\t\t}\n\t\treturn key;\n\t}\n\t\n\tHashMap<String, Long> hash = new HashMap<>();\n\tvoid add(String key) {\n\t\tif (hash.containsKey(key))\n\t\t\thash.put(key, hash.get(key) + 1);\n\t\telse\n\t\t\thash.put(key, 1L);\n\t}\n\t\n\tint comb(String key) {\n\t\tString[] ws = key.split(\",\");\n\t\tif (ws[0].matches(ws[1]) && ws[1].matches(ws[2]) && ws[2].matches(ws[3]))\n\t\t\treturn 4;\n\t\telse if (ws[0].matches(ws[2]) && ws[1].matches(ws[3]))\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\t\n\tlong get(String key) {\n\t\tif (!hash.containsKey(key)) return 0;\n\t\treturn hash.get(key);\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tint[][] C = new int[N][7];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tC[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tString key = toKey(C[i]);\n\t\t\tadd(key);\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tfor (int c1 = 0; c1 < N; c1++) {\n\t\t\tfor (int c2 = c1 + 1; c2 < N; c2++) {\n\t\t\t\tint x1 = C[c1][0], x2 = C[c1][1], x3 = C[c1][2], x4 = C[c1][3];\n\t\t\t\tint y1 = C[c2][1], y2 = C[c2][0], y3 = C[c2][3], y4 = C[c2][2];\n\t\t\t\tfor (int rotate = 0; rotate < 4; rotate++) {\n\t\t\t\t\tString xkey      = toKey(new int[]{x1, x2, x3, x4});\n\t\t\t\t\tString ykey      = toKey(new int[]{y1, y2, y3, y4});\n\t\t\t\t\tString upKey     = toKey(new int[]{y1, y2, x2, x1});\n\t\t\t\t\tString bottomKey = toKey(new int[]{y3, y4, x4, x3});\n\t\t\t\t\tString rightKey  = toKey(new int[]{x3, x2, y2, y3});\n\t\t\t\t\tString leftKey   = toKey(new int[]{x1, x4, y4, y1}); \n\t\t\t\t\t\n\t\t\t\t\tlong ucnt = get(upKey) * comb(upKey);\n\t\t\t\t\tlong bcnt = get(bottomKey) * comb(bottomKey);\n\t\t\t\t\tlong rcnt = get(rightKey) * comb(rightKey);\n\t\t\t\t\tlong lcnt = get(leftKey) * comb(leftKey);\n\t\t\t\t\t\n\t\t\t\t\tString[] keys = {upKey, bottomKey, rightKey, leftKey};\n\t\t\t\t\tlong[] cnts = {ucnt, bcnt, rcnt, lcnt};\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif (xkey.matches(keys[i])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tif (ykey.matches(keys[i])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tfor (int j = i + 1; j < 4; j++)\n\t\t\t\t\t\t\tif (keys[i].matches(keys[j])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor (long c : cnts) val *= c; \n\t\t\t\t\tres += val;\n\t\t\t\t\t\n\t\t\t\t\tint ytmp = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = y3;\n\t\t\t\t\ty3 = y4;\n\t\t\t\t\ty4 = ytmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res/3);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            Rect[] rects = new Rect[n];\n            List<Long> summary = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                rects[i] = new Rect();\n                for (int j = 0; j < 4; j++) {\n                    rects[i].colors[j] = in.readInt();\n                }\n                long s = summaryOf(rects[i]);\n                for (int j = 0; j < 4; j++) {\n                    summary.add(s);\n                    s = rotate(s);\n                }\n            }\n\n            LongDiscreteMap dm = new LongDiscreteMap(summary.stream().mapToLong(Long::longValue).toArray(), 0,\n                            summary.size());\n\n            int[][] rotations = new int[dm.maxRank() + 1][4];\n            for (int i = 0; i < rotations.length; i++) {\n                long val = dm.iThElement(i);\n                for (int j = 0; j < 4; j++) {\n                    rotations[i][j] = dm.rankOf(val);\n                    val = rotate(val);\n                }\n            }\n\n            int[] cnts = new int[dm.maxRank() + 1];\n            for (Rect rect : rects) {\n                rect.summary = dm.rankOf(summaryOf(rect));\n                for (int s : rotations[rect.summary]) {\n                    cnts[s] += 1;\n                }\n            }\n\n            int[] cols = new int[8];\n            int[] faces = new int[3];\n\n            long cnt = 0;\n\n            Randomized.randomizedArray(rects, 0, n);\n            for (int i = 0; i < n; i++) {\n                for (int s : rotations[rects[i].summary]) {\n                    cnts[s] -= 1;\n                }\n                cols[0] = rects[i].get(0, 0);\n                cols[1] = rects[i].get(3, 0);\n                cols[2] = rects[i].get(1, 0);\n                cols[3] = rects[i].get(2, 0);\n\n                for (int j = i + 1; j < n; j++) {\n                    if (i == j) {\n                        continue;\n                    }\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] -= 1;\n                    }\n\n                    for (int rj = 0; rj < 4; rj++) {\n\n                        if (rects[j].get(0, rj) != cols[2] || rects[j].get(3, rj) != cols[3]) {\n                            continue;\n                        }\n\n                        cols[4] = rects[j].get(1, rj);\n                        cols[5] = rects[j].get(2, rj);\n\n                        for (int k = i + 1; k < n; k++) {\n                            if (k == i || k == j) {\n                                continue;\n                            }\n\n\n                            for (int rk = 0; rk < 4; rk++) {\n\n                                if (rects[k].get(0, rk) != cols[4] || rects[k].get(3, rk) != cols[5]) {\n                                    continue;\n                                }\n\n                                cols[6] = rects[k].get(1, rk);\n                                cols[7] = rects[k].get(2, rk);\n\n                                for (int s : rotations[rects[k].summary]) {\n                                    cnts[s] -= 1;\n                                }\n\n                                faces[0] = dm.rankOf(summaryOf(cols[6], cols[0], cols[1], cols[7]));\n                                faces[1] = dm.rankOf(summaryOf(cols[7], cols[1], cols[3], cols[5]));\n                                faces[2] = dm.rankOf(summaryOf(cols[0], cols[6], cols[4], cols[2]));\n\n                                if (faces[0] >= 0 && faces[1] >= 0 && faces[2] >= 0) {\n                                    long localCnt = 1;\n                                    for (int t = 0; t < 3; t++) {\n                                        localCnt *= cnts[faces[t]];\n                                        for (int r : rotations[faces[t]]) {\n                                            cnts[r]--;\n                                        }\n                                    }\n                                    cnt += localCnt;\n                                    for (int t = 0; t < 3; t++) {\n                                        for (int r : rotations[faces[t]]) {\n                                            cnts[r]++;\n                                        }\n                                    }\n                                }\n\n                                for (int s : rotations[rects[k].summary]) {\n                                    cnts[s] += 1;\n                                }\n\n                            }\n                        }\n                    }\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] += 1;\n                    }\n                }\n            }\n\n            out.println(cnt);\n        }\n\n        public long summaryOf(Rect rect) {\n            return summaryOf(rect.colors[0], rect.colors[1], rect.colors[2], rect.colors[3]);\n        }\n\n        public long summaryOf(int a, int b, int c, int d) {\n            long ans = a;\n            ans = ans * 1000 + b;\n            ans = ans * 1000 + c;\n            ans = ans * 1000 + d;\n            return ans;\n        }\n\n        public long rotate(long x) {\n            return (x % 1000) * 1_000_000_000 + x / 1000;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Rect {\n        int[] colors = new int[4];\n        int summary;\n\n        public int get(int i, int r) {\n            return colors[(i + r) & 3];\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class LongDiscreteMap {\n        long[] val;\n        int f;\n        int t;\n\n        public LongDiscreteMap(long[] val, int f, int t) {\n            Randomized.randomizedArray(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(long x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public long iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static <T> void randomizedArray(T[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                T tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc062;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\n/**\n * Created by hama_du on 2016/10/19.\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        debug(code(new int[]{0,1,1,0}), code(new int[]{1,1,0,0}));\n\n        int n = in.nextInt();\n        int[][] panels = in.nextIntTable(n, 4);\n\n        long[] panelCodes = new long[n];\n        for (int i = 0; i < n ; i++) {\n            panelCodes[i] = code(panels[i]);\n        }\n\n        long ans = 0;\n        for (int top = 0 ; top < n ; top++) {\n            for (int bottom = top+1 ; bottom < n ; bottom++) {\n                int[][] sidePanels = new int[n][];\n                long[] sideCodes = new long[n];\n                int sidx = 0;\n                for (int i = top+1 ; i < n ; i++) {\n                    if (i == bottom) {\n                        continue;\n                    }\n                    sidePanels[sidx] = panels[i];\n                    sideCodes[sidx++] = panelCodes[i];\n                }\n                sidePanels = Arrays.copyOf(sidePanels, sidx);\n                sideCodes = Arrays.copyOf(sideCodes, sidx);\n\n                // top\n                // 0 1\n                // 3 2\n\n                // bottom\n                // 3 2\n                // 0 1\n\n                for (int d = 0 ; d < 4 ; d++) {\n                    int[][] men = new int[][]{\n                            { panels[top][1], panels[top][0], panels[bottom][(d+3)%4], panels[bottom][(d+2)%4] },\n                            { panels[top][2], panels[top][1], panels[bottom][(d+2)%4], panels[bottom][(d+1)%4] },\n                            { panels[top][3], panels[top][2], panels[bottom][(d+1)%4], panels[bottom][(d+0)%4] },\n                            { panels[top][0], panels[top][3], panels[bottom][(d+0)%4], panels[bottom][(d+3)%4] }\n                    };\n                    ans += solve(men, sidePanels, sideCodes);\n                }\n            }\n        }\n\n        out.println(ans);\n        out.flush();\n    }\n\n    private static long same(int[] men) {\n        if (men[0] == men[1] && men[1] == men[2] && men[2] == men[3]) {\n            return 4;\n        }\n        if (men[0] == men[2] && men[1] == men[3]) {\n            return 2;\n        }\n        return 1;\n    }\n\n    private static long code(int[] men) {\n        int[] minOrd = men.clone();\n        for (int i = 1 ; i < 4; i++) {\n            int[] ord = new int[4];\n            for (int j = 0; j < 4 ; j++) {\n                ord[j] = men[(j+i)%4];\n            }\n            for (int j = 0; j < 4 ; j++) {\n                if (minOrd[j] > ord[j]) {\n                    minOrd = ord;\n                    break;\n                } else if (ord[j] > minOrd[j]) {\n                    break;\n                }\n            }\n        }\n\n        long wo = 0;\n        for (int i = 0; i < 4; i++) {\n            wo |= ((long) minOrd[i]) << (10L * i);\n        }\n        return wo;\n    }\n\n    private static long solve(int[][] men, int[][] panels, long[] codes) {\n        int n = panels.length;\n        long[] menCodes = new long[4];\n        for (int i = 0; i < 4 ; i++) {\n            menCodes[i] = code(men[i]);\n        }\n        long[] menCounts = new long[4];\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < 4 ; j++) {\n                if (menCodes[j] == codes[i]) {\n                    menCounts[j]++;\n                }\n            }\n        }\n\n        Map<Long,Long> dec = new HashMap<>();\n        long ret = 1;\n        for (int i = 0 ; i < 4 ; i++) {\n            long A = same(men[i]);\n            ret *= A * menCounts[i] - A * dec.getOrDefault(menCodes[i], 0L);\n            dec.put(menCodes[i], dec.getOrDefault(menCodes[i], 0L) + 1);\n        }\n        if (ret < 0) {\n            return 0;\n        }\n        return ret;\n    }\n\n    private static int[] match(int[][] men, int[] panel) {\n        int[] x = new int[4];\n        for (int i = 0; i < 4 ; i++) {\n            for (int d = 0 ; d < 4 ; d++) {\n                boolean isOK = true;\n                for (int e = 0 ; e < 4 ; e++){\n                    if (men[i][e] != panel[(d+e)%4]) {\n                        isOK = false;\n                        break;\n                    }\n                }\n                if (isOK) {\n                    x[i]++;\n                }\n            }\n        }\n        return x;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n\t\tlong[][] comb = new long[401][401];\n\t\tlong[] fact = new long[401];\n\t\tfact[0] = 1;\n\t\tfor(int i = 0; i < comb.length; i++) {\n\t\t\tif(i > 0) fact[i] = fact[i-1] * i;\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t\tfor(int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\t\t\t}\n\t\t}\n\t\t\n//\t\tdump(comb[400][6]);\n\t\t\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint[][] C = io.nextIntArray2D(n, 4);\n\t\t\tlong ans = 0;\n\t\t\tint[] dup = new int[4];\n\t\t\tint[][] cnt = new int[4][4];\n\t\t\tint[] tmp = new int[4];\n\n//\t\t\tint[] p1 = new int[]{0, 1, 2, 3,};\n\t\t\tint[] p2 = new int[]{1, 0, 3, 2,};\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) for(int d = 0; d < 4; d++) {\n\t\t\t\t\tif(!(i == 1 && j == 3 && d == 2)) {\n//\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tArrays.fill(dup, 1);\n\t\t\t\t\tfor(int[] s : cnt) Arrays.fill(s, 0);\n\t\t\t\t\tLOOP: for(int s = 0; s < 4; s++) {\n\t\t\t\t\t\tint t2 = C[i][(s+0)&3];\n\t\t\t\t\t\tint t1 = C[i][(s+1)&3];\n\t\t\t\t\t\tint b1 = C[j][p2[(s+d+0)&3]];\n\t\t\t\t\t\tint b2 = C[j][p2[(s+d+1)&3]];\n\t\t\t\t\t\tfor(int s2 = 0; s2 < s; s2++) {\n\t\t\t\t\t\t\ttmp[0] = C[i][(s2+1)&3];\n\t\t\t\t\t\t\ttmp[1] = C[i][(s2+0)&3];\n\t\t\t\t\t\t\ttmp[2] = C[j][(s2+d+0)&3];\n\t\t\t\t\t\t\ttmp[3] = C[j][(s2+d+1)&3];\n\t\t\t\t\t\t\tfor(int d2 = 0; d2 < 4; d2++) {\n\t\t\t\t\t\t\t\tif(t1 == tmp[(d2+0)&3] && t2 == tmp[(d2+1)&3] && b1 == tmp[(d2+2)&3] && b2 == tmp[(d2+3)&3]) {\n\t\t\t\t\t\t\t\t\tdup[s2]++;\n\t\t\t\t\t\t\t\t\tdup[s] = -1;\n\t\t\t\t\t\t\t\t\tcontinue LOOP;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = 0; k < n; k++) if(k != i && k != j) {\n\t\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\t\tfor(int d2 = 0; d2 < 4; d2++) {\n\t\t\t\t\t\t\t\tif(t1 == C[k][(d2+0)&3] && t2 == C[k][(d2+1)&3] && b1 == C[k][(d2+2)&3] && b2 == C[k][(d2+3)&3]) {\n\t\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\tdump(k, c, C[k], t1, t2, b1, b2);\n\t\t\t\t\t\t\tif(c > 0) cnt[s][c - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor(int s = 0; s < 4; s++) if(dup[s] != -1) {\n\t\t\t\t\t\tlong[] dp = new long[dup[s]+1];\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tfor(int c = 0; c < 4; c++) {\n\t\t\t\t\t\t\tfor(int k = dup[s] - 1; k >= 0; k--) {\n\t\t\t\t\t\t\t\tfor(int l = 1; l <= cnt[s][c] && k + l <= dup[s]; l++) {\n\t\t\t\t\t\t\t\t\tdp[k+l] += dp[k] * comb[cnt[s][c]][l] * fact[l] * pow(c + 1, l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval *= dp[dup[s]];\n\t\t\t\t\t}\n\t\t\t\t\tans += val;\n//\t\t\t\t\tdump(i, j, cnt, dup, val);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdump(ans, ans % 3);\n\t\t\tans /= 3;\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\tint pow(int c, int p) {\n\t\tint res = 1;\n\t\tfor(int i = 0; i < p; i++) res *= c;\n\t\treturn res;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[][] hash = new long[n][4];\n\t\t\tSet<Long> any = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t\t}\n\t\t\t\t\tany.add(hash[i][rot]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint a = col[front][0];\n\t\t\t\t\t\tint b = col[front][1];\n\t\t\t\t\t\tint c = col[front][2];\n\t\t\t\t\t\tint d = col[front][3];\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tfor (long hh : hs) {\n\t\t\t\t\t\t\tif (!any.contains(hh)) {\n\t\t\t\t\t\t\t\tcontinue rotLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong[] dp = new long[1 << 4];\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calcHash(int a, int b, int c, int d) {\n\t\t\tlong h = 0;\n\t\t\th = 1000 * h + a;\n\t\t\th = 1000 * h + b;\n\t\t\th = 1000 * h + c;\n\t\t\th = 1000 * h + d;\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc062;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\n/**\n * Created by hama_du on 2016/10/19.\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        debug(code(new int[]{0,1,1,0}), code(new int[]{1,1,0,0}));\n\n        int n = in.nextInt();\n        int[][] panels = in.nextIntTable(n, 4);\n\n        long ans = 0;\n        for (int top = 0 ; top < n ; top++) {\n            for (int bottom = top+1 ; bottom < n ; bottom++) {\n                int[][] sidePanels = new int[n][];\n                int sidx = 0;\n                for (int i = top+1 ; i < n ; i++) {\n                    if (i == bottom) {\n                        continue;\n                    }\n                    sidePanels[sidx++] = panels[i].clone();\n                }\n                sidePanels = Arrays.copyOf(sidePanels, sidx);\n\n                // top\n                // 0 1\n                // 3 2\n\n                // bottom\n                // 3 2\n                // 0 1\n\n                for (int d = 0 ; d < 4 ; d++) {\n                    int[][] men = new int[][]{\n                            { panels[top][1], panels[top][0], panels[bottom][(d+3)%4], panels[bottom][(d+2)%4] },\n                            { panels[top][2], panels[top][1], panels[bottom][(d+2)%4], panels[bottom][(d+1)%4] },\n                            { panels[top][3], panels[top][2], panels[bottom][(d+1)%4], panels[bottom][(d+0)%4] },\n                            { panels[top][0], panels[top][3], panels[bottom][(d+0)%4], panels[bottom][(d+3)%4] }\n                    };\n                    ans += solve(men, sidePanels);\n                }\n            }\n        }\n\n        out.println(ans);\n        out.flush();\n    }\n\n    private static long same(int[] men) {\n        if (men[0] == men[1] && men[1] == men[2] && men[2] == men[3]) {\n            return 4;\n        }\n        if (men[0] == men[2] && men[1] == men[3]) {\n            return 2;\n        }\n        return 1;\n    }\n\n    private static long code(int[] men) {\n        int[] minOrd = men.clone();\n        for (int i = 1 ; i < 4; i++) {\n            int[] ord = new int[4];\n            for (int j = 0; j < 4 ; j++) {\n                ord[j] = men[(j+i)%4];\n            }\n            for (int j = 0; j < 4 ; j++) {\n                if (minOrd[j] > ord[j]) {\n                    minOrd = ord.clone();\n                    break;\n                } else if (ord[j] > minOrd[j]) {\n                    break;\n                }\n            }\n        }\n\n        long wo = 0;\n        for (int i = 0; i < 4; i++) {\n            wo |= ((long) minOrd[i]) << (10L * i);\n        }\n        return wo;\n    }\n\n    private static long solve(int[][] men, int[][] panels) {\n        int n = panels.length;\n        int[][] matchCounts = new int[n][];\n        for (int i = 0; i < n ; i++) {\n            matchCounts[i] = match(men, panels[i]);\n        }\n\n        long[] menCounts = new long[4];\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < 4 ; j++) {\n                menCounts[j] += matchCounts[i][j];\n            }\n        }\n\n        Map<Long,Long> dec = new HashMap<>();\n        long ret = 1;\n        for (int i = 0 ; i < 4 ; i++) {\n            long A = same(men[i]);\n            long code = code(men[i]);\n            ret *= menCounts[i] - A * dec.getOrDefault(code, 0L);\n            dec.put(code, dec.getOrDefault(code, 0L) + 1);\n        }\n        if (ret < 0) {\n            return 0;\n        }\n        return ret;\n    }\n\n    private static int[] match(int[][] men, int[] panel) {\n        int[] x = new int[4];\n        for (int i = 0; i < 4 ; i++) {\n            for (int d = 0 ; d < 4 ; d++) {\n                boolean isOK = true;\n                for (int e = 0 ; e < 4 ; e++){\n                    if (men[i][e] != panel[(d+e)%4]) {\n                        isOK = false;\n                        break;\n                    }\n                }\n                if (isOK) {\n                    x[i]++;\n                }\n            }\n        }\n        return x;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  private static int N;\n  private static int count = 0;\n  private static int[][] C;\n\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    N = sc.nextInt();\n    C = sc.nextIntTable(N, 4);\n\n    Map<Long, Integer> map = new HashMap<>();\n    Map<Long, Long> rot = new HashMap<>();\n    long[] hash = new long[N];\n    for (int i = 0; i < N; i++) {\n      long h = hash(C[i][0], C[i][1], C[i][2], C[i][3]);\n      if (!map.containsKey(h)) {\n        map.put(h, 0);\n      }\n      map.put(h, map.get(h) + 1);\n      rot.put(h, rot(C[i]));\n      hash[i] = h;\n    }\n\n    int[][] idx = {{0, 4, 7, 1}, {1, 7, 6, 2}, {3, 2, 6, 5}, {0, 3, 5, 4}};\n\n    for (int i = 0; i < N; i++) {\n      for (int j = i + 1; j < N; j++) {\n\n        loop: for (int k = 0; k < 4; k++) {\n          Map<Long, Integer> tmp = new HashMap<>();\n          tmp.put(hash[i], 1);\n          tmp.put(hash[j], hash[i] == hash[j] ? 2 : 1);\n\n          int[] c = {C[i][0], C[i][1], C[i][2], C[i][3], C[j][(0 + k) % 4], C[j][(1 + k) % 4],\n              C[j][(2 + k) % 4], C[j][(3 + k) % 4]};\n\n\n          long nc = 1;\n          for (int[] v : idx) {\n            long h = hash(c[v[0]], c[v[1]], c[v[2]], c[v[3]]);\n            if (!tmp.containsKey(h)) tmp.put(h, 0);\n\n            if (!map.containsKey(h) || tmp.get(h) >= map.get(h)) {\n              continue loop;\n            }\n            nc *= (map.get(h) - tmp.get(h)) * rot.get(h);\n            tmp.put(h, tmp.get(h) + 1);\n          }\n\n\n          count += nc;\n        }\n      }\n    }\n    System.out.println(count * 2 / 6);\n  }\n\n  private static long rot(int... C) {\n    int ret = 0;\n    for (int i = 0; i < 4; i++) {\n      if (C[0] == C[(i + 0) % 4] && C[1] == C[(i + 1) % 4] && C[2] == C[(i + 2) % 4]\n          && C[3] == C[(i + 3) % 4]) {\n        ret ++;\n      }\n    }\n    return ret;\n  }\n\n  private static long hash(int... C) {\n    long min = Long.MAX_VALUE;\n\n    for (int k = 0; k < 4; k++) {\n      long ret = 0;\n      for (int i = 0; i < 4; i++) {\n        ret *= 1000;\n        ret += C[(i + k) % 4];\n      }\n      min = Math.min(min, ret);\n    }\n    return min;\n  }\n}\n\n\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong XXX = 10000;\n\tlong toKey(int[] c) {\n\t\tlong key = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tlong curKey = 0;\n\t\t\tfor (int j = 0; j < 4; j++) curKey = curKey * XXX + c[(i+j)%4];\n\t\t\tif (key > curKey) key = curKey;\n\t\t}\n\t\treturn key;\n\t}\n\t\n\tHashMap<Long, Long> hash = new HashMap<>();\n\tvoid add(long key) {\n\t\tif (hash.containsKey(key))\n\t\t\thash.put(key, hash.get(key) + 1);\n\t\telse\n\t\t\thash.put(key, 1L);\n\t}\n\t\n\tint comb(long key) {\n\t\tlong[] vals = new long[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvals[i] = key % XXX;\n\t\t\tkey /= XXX;\n\t\t}\n\t\tif (vals[0] == vals[1] && vals[1] == vals[2] && vals[2] == vals[3])\n\t\t\treturn 4;\n\t\telse if (vals[0] == vals[2] && vals[1] == vals[3])\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\t\n\tlong get(long key) {\n\t\tif (!hash.containsKey(key)) return 0;\n\t\treturn hash.get(key);\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tint[][] C = new int[N][4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tC[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tlong key = toKey(C[i]);\n\t\t\tadd(key);\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tfor (int c1 = 0; c1 < N; c1++) {\n\t\t\tfor (int c2 = c1 + 1; c2 < N; c2++) {\n\t\t\t\tint x1 = C[c1][0], x2 = C[c1][1], x3 = C[c1][2], x4 = C[c1][3];\n\t\t\t\tint y1 = C[c2][3], y2 = C[c2][2], y3 = C[c2][1], y4 = C[c2][0];\n\t\t\t\tlong xkey = toKey(new int[]{x1, x2, x3, x4});\n\t\t\t\tlong ykey = toKey(new int[]{y1, y2, y3, y4});\n\t\t\t\tfor (int rotate = 0; rotate < 4; rotate++) {\n\t\t\t\t\t/*\n\t\t\t\t\tlong upKey     = toKey(new int[]{y1, y2, x2, x1});\n\t\t\t\t\tlong bottomKey = toKey(new int[]{y3, y4, x4, x3});\n\t\t\t\t\tlong rightKey  = toKey(new int[]{y2, y3, x3, x2});\n\t\t\t\t\tlong leftKey   = toKey(new int[]{y4, y1, x1, x4}); \n\t\t\t\t\t*/\n\t\t\t\t\tlong upKey     = toKey(new int[]{x1, x4, y1, y2});\n\t\t\t\t\tlong bottomKey = toKey(new int[]{x3, x2, y3, y4});\n\t\t\t\t\tlong rightKey  = toKey(new int[]{x2, x1, y2, y3});\n\t\t\t\t\tlong leftKey   = toKey(new int[]{x4, x3, y4, y1}); \n\n\t\t\t\t\tlong ucnt = get(upKey) * comb(upKey);\n\t\t\t\t\tlong bcnt = get(bottomKey) * comb(bottomKey);\n\t\t\t\t\tlong rcnt = get(rightKey) * comb(rightKey);\n\t\t\t\t\tlong lcnt = get(leftKey) * comb(leftKey);\n\t\t\t\t\t\n\t\t\t\t\tlong[] keys = {upKey, bottomKey, rightKey, leftKey};\n\t\t\t\t\tlong[] cnts = {ucnt, bcnt, rcnt, lcnt};\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif (xkey == keys[i]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tif (ykey == keys[i]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tfor (int j = i + 1; j < 4; j++)\n\t\t\t\t\t\t\tif (keys[i] == keys[j]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor (long c : cnts) val *= c; \n\t\t\t\t\tres += val;\n\t\t\t\t\t\n\t\t\t\t\tint ytmp = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = y3;\n\t\t\t\t\ty3 = y4;\n\t\t\t\t\ty4 = ytmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res/3);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author liymsheep\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        private int[] rotate(int[] array) {\n            int[] result = new int[4];\n            for (int i = 0; i < 4; ++i) {\n                result[(i + 1) & 3] = array[i];\n            }\n            return result;\n        }\n\n        private long hash(int[] array) {\n            long result = 0;\n            for (int i = 0; i < 4; ++i) {\n                result = (result << 10L) + array[i];\n            }\n            return result;\n        }\n\n        private void put(Map<Long, Integer> map, long value) {\n            int ways = 0;\n            if (map.containsKey(value)) {\n                ways = map.get(value);\n            }\n            ++ways;\n            map.put(value, ways);\n        }\n\n        private long rep(int[] color) {\n            long value = Long.MAX_VALUE;\n            long current = hash(color);\n            for (int i = 0; i < 4; ++i) {\n                value = Math.min(value, current);\n                current -= ((long) color[i]) << 30L;\n                current <<= 10L;\n                current += color[i];\n            }\n            return value;\n        }\n\n        private int get(Map<Long, Integer> map, long value) {\n            Integer result = map.get(value);\n            return result == null ? 0 : result;\n        }\n\n        private int[] reverse(int[] array) {\n            int[] result = new int[array.length];\n            for (int i = 0; i < array.length; ++i) {\n                result[array.length - 1 - i] = array[i];\n            }\n            return result;\n        }\n\n        private int power(int x, int y) {\n            int z = 1;\n            for (int i = 0; i < y; ++i) {\n                z = z * x;\n            }\n            return z;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n\n            long[][] arr = new long[n + 1][5];\n            for (int i = 0; i <= n; ++i) {\n                arr[i][0] = 1;\n                for (int j = 1; j <= 4; ++j) {\n                    arr[i][j] = arr[i][j - 1] * (i - j + 1);\n                }\n            }\n\n            Map<Long, Integer> count = new HashMap<>();\n            Map<Long, Integer> rot = new HashMap<>();\n            long[] minHash = new long[n];\n            int[][][] arrangements = new int[n][4][];\n            for (int i = 0; i < n; ++i) {\n                int[] colors = new int[4];\n                for (int j = 0; j < 4; ++j) {\n                    colors[j] = in.nextInt();\n                }\n//            colors = reverse(colors);\n                minHash[i] = rep(colors);\n                put(count, minHash[i]);\n                int rotation = 0;\n                for (int j = 0; j < 4; ++j) {\n                    arrangements[i][j] = colors;\n                    if (hash(colors) == minHash[i]) {\n                        ++rotation;\n                    }\n                    colors = rotate(colors);\n                }\n                rot.put(minHash[i], rotation);\n            }\n\n            long answer = 0;\n            int[] c1 = new int[4];\n            int[] c2 = new int[4];\n            int[] c3 = new int[4];\n            int[] c4 = new int[4];\n            long[] features = new long[4];\n            for (int i = 0; i < n; ++i) {\n                int[] bottom = arrangements[i][0];\n                bottom = reverse(bottom);\n                for (int j = i + 1; j < n; ++j) {\n                    if (i != j) {\n                        for (int k = 0; k < 4; ++k) {\n                            int[] top = arrangements[j][k];\n                            c1[0] = top[1];\n                            c1[1] = top[0];\n                            c1[2] = bottom[0];\n                            c1[3] = bottom[1];\n                            c2[0] = top[2];\n                            c2[1] = top[1];\n                            c2[2] = bottom[1];\n                            c2[3] = bottom[2];\n                            c3[0] = top[3];\n                            c3[1] = top[2];\n                            c3[2] = bottom[2];\n                            c3[3] = bottom[3];\n                            c4[0] = top[0];\n                            c4[1] = top[3];\n                            c4[2] = bottom[3];\n                            c4[3] = bottom[0];\n                            features[0] = rep(c1);\n                            features[1] = rep(c2);\n                            features[2] = rep(c3);\n                            features[3] = rep(c4);\n                            Arrays.sort(features);\n//                        for (int s = 0; s < 4; ++s) {\n//                            System.err.print(get(count, features[s]) + \", \");\n//                        }\n//                        System.err.println();\n                            long currentWay = 1;\n                            for (int t = 0; t < 4; ) {\n                                int r = t;\n                                while (r < features.length && features[t] == features[r]) {\n                                    ++r;\n                                }\n                                int ways = get(count, features[t]);\n                                if (features[t] == minHash[i]) {\n                                    --ways;\n                                }\n                                if (features[t] == minHash[j]) {\n                                    --ways;\n                                }\n                                if (ways < 0) {\n                                    throw new RuntimeException();\n                                }\n                                if (ways < r - t) {\n                                    currentWay = 0;\n                                    break;\n                                }\n                                currentWay *= arr[ways][r - t] * power(rot.get(features[t]), r - t);\n                                t = r;\n                            }\n                            answer += currentWay;\n                        }\n                    }\n                }\n            }\n            if (answer % 3 != 0) {\n                throw new RuntimeException();\n            }\n            answer /= 3;\n            out.print(answer);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    throw new UnknownError();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[] hash = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\thash[i] = calcHashes(col[i])[0];\n\t\t\t}\n\t\t\t{\n\t\t\t\tInteger[] p = new Integer[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tp[i] = i;\n\t\t\t\t}\n\t\t\t\tfinal long[] hh = hash;\n\t\t\t\tArrays.sort(p, (a, b) -> (hh[a] < hh[b] ? -1 : (hh[a] > hh[b] ? 1 : 0)));\n\t\t\t\tint[][] ncol = new int[n][];\n\t\t\t\tlong[] nhash = new long[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tncol[p[i]] = col[i];\n\t\t\t\t\tnhash[p[i]] = hash[i];\n\t\t\t\t}\n\t\t\t\tcol = ncol;\n\t\t\t\thash = nhash;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tlong[] dp = new long[1 << 4];\n\t\t\tlong[] ways = new long[1 << 4];\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tint a = col[front][0];\n\t\t\t\tint b = col[front][1];\n\t\t\t\tint c = col[front][2];\n\t\t\t\tint d = col[front][3];\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong[] h1 = calcHashes(a, e, f, b);\n\t\t\t\t\t\tlong[] h2 = calcHashes(b, f, g, c);\n\t\t\t\t\t\tlong[] h3 = calcHashes(d, c, g, h);\n\t\t\t\t\t\tlong[] h4 = calcHashes(e, a, d, h);\n\t\t\t\t\t\tlong[][] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tArrays.fill(dp, 0);\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tSet<Long> interesting = new HashSet<>();\n\t\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\tinteresting.add(hs[i][rot]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = front + 1; i < n; ) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint j = i;\n\t\t\t\t\t\t\tint k = 0;\n\t\t\t\t\t\t\twhile (j < n && hash[i] == hash[j]) {\n\t\t\t\t\t\t\t\tif (j != back) {\n\t\t\t\t\t\t\t\t\t++k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!interesting.contains(hash[i])) {\n\t\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\t\tways[0] = 1;\n\t\t\t\t\t\t\tfor (int mask = 1; mask < 1 << 4; mask++) {\n\t\t\t\t\t\t\t\tint bit = Integer.numberOfTrailingZeros(mask);\n\t\t\t\t\t\t\t\tlong w = 0;\n\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tif (hs[bit][rot] == hash[i]) {\n\t\t\t\t\t\t\t\t\t\t++w;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tways[mask] = w * ways[mask ^ (1 << bit)];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tfor (int omask = 15; omask >= 0; omask--) {\n\t\t\t\t\t\t\t\t\tif ((mask & omask) > 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tint bc = Integer.bitCount(omask);\n\t\t\t\t\t\t\t\t\tif (bc > k) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdp[mask | omask] += dp[mask] * ways[omask] * f(k, bc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long f(int n, int k) {\n\t\t\tlong res = 1;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tres *= n - i;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate long[] calcHashes(int... a) {\n\t\t\tlong[] h = new long[4];\n\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\th[rot] = 1000 * h[rot] + a[(rot + i) % 4];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong a2 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b2 = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 16;\n\t\tint cnt = 0;\n\t\tPair[] array;\n\t\tint[] flag;// 0 : unused,1:used,2:deleted\n\n\t\tpublic HashMap() {\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\treturn array[id].value;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 0)\n\t\t\t\t\treturn false;\n\t\t\t\tif (flag[id] == 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\tarray[id] = null;\n\t\t\t\t\tflag[id] = 2;\n\t\t\t\t\tif (sz >= 8 * cnt) {\n\t\t\t\t\t\tchangeSize(sz / 2);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\n\t\t}\n\n\t\tboolean put(long key, long value) {\n\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1) {\n\t\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\t\tarray[id].value = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0 || flag[id] == 2) {\n\t\t\t\t\tarray[id] = new Pair(key, value);\n\t\t\t\t\tflag[id] = 1;\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif (2 * cnt == sz) {\n\t\t\t\t\t\tchangeSize(2 * sz);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tint hash1(long v) {\n\t\t\treturn (int) ((a1 * v % p + b1) % p % sz);\n\t\t}\n\n\t\tint hash2(long v) {\n\t\t\treturn (int) ((a2 * v % p + b2) % p % sz);\n\t\t}\n\n\t\tint id(long v, int i) {\n\t\t\treturn (hash1(v) + i * (2 * hash2(v) + 1)) % sz;\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tPair[] tmp = new Pair[sz];\n\t\t\tint[] tmpFlag = new int[sz];\n\t\t\tfor (int i = 0; i < array.length; ++i) {\n\t\t\t\ttmp[i] = array[i];\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tif (tmpFlag[i] == 1) {\n\t\t\t\t\tflag[i] = 1;\n\t\t\t\t\tput(tmp[i].key, tmp[i].value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong XXX = 1010;\n\tlong toKey(int[] c) {\n\t\tlong key = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tlong curKey = 0;\n\t\t\tfor (int j = 0; j < 4; j++) curKey = curKey * XXX + c[(i+j)%4] + 1;\n\t\t\tif (key > curKey) key = curKey;\n\t\t}\n\t\treturn key;\n\t}\n\t\n\tHashMap<Long, Long> hash = new HashMap<>();\n\tvoid add(long key) {\n\t\tif (hash.containsKey(key))\n\t\t\thash.put(key, hash.get(key) + 1);\n\t\telse\n\t\t\thash.put(key, 1L);\n\t}\n\t\n\tint comb(long key) {\n\t\tlong[] vals = new long[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvals[i] = key % XXX;\n\t\t\tkey /= XXX;\n\t\t}\n\t\tif (vals[0] == vals[1] && vals[1] == vals[2] && vals[2] == vals[3])\n\t\t\treturn 4;\n\t\telse if (vals[0] == vals[2] && vals[1] == vals[3])\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\t\n\tlong get(long key) {\n\t\tif (!hash.containsKey(key)) return 0;\n\t\treturn hash.get(key);\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tint[][] C = new int[N][4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tC[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tlong key = toKey(C[i]);\n\t\t\tadd(key);\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tfor (int c1 = 0; c1 < N; c1++) {\n\t\t\tfor (int c2 = c1 + 1; c2 < N; c2++) {\n\t\t\t\tint x1 = C[c1][0], x2 = C[c1][1], x3 = C[c1][2], x4 = C[c1][3];\n\t\t\t\tint y1 = C[c2][1], y2 = C[c2][0], y3 = C[c2][3], y4 = C[c2][2];\n\t\t\t\tfor (int rotate = 0; rotate < 4; rotate++) {\n\t\t\t\t\tlong xkey      = toKey(new int[]{x1, x2, x3, x4});\n\t\t\t\t\tlong ykey      = toKey(new int[]{y1, y2, y3, y4});\n\t\t\t\t\tlong upKey     = toKey(new int[]{y1, y2, x2, x1});\n\t\t\t\t\tlong bottomKey = toKey(new int[]{y3, y4, x4, x3});\n\t\t\t\t\tlong rightKey  = toKey(new int[]{x3, x2, y2, y3});\n\t\t\t\t\tlong leftKey   = toKey(new int[]{x1, x4, y4, y1}); \n\t\t\t\t\t\n\t\t\t\t\tlong ucnt = get(upKey) * comb(upKey);\n\t\t\t\t\tlong bcnt = get(bottomKey) * comb(bottomKey);\n\t\t\t\t\tlong rcnt = get(rightKey) * comb(rightKey);\n\t\t\t\t\tlong lcnt = get(leftKey) * comb(leftKey);\n\t\t\t\t\t\n\t\t\t\t\tif (xkey == upKey)         ucnt -= comb(upKey);\n\t\t\t\t\tif (xkey == bottomKey)     bcnt -= comb(bottomKey);\n\t\t\t\t\tif (xkey == leftKey)       lcnt -= comb(leftKey);\n\t\t\t\t\tif (xkey == rightKey)      rcnt -= comb(rightKey);\n\n\t\t\t\t\tif (ykey == upKey)         ucnt -= comb(upKey);\n\t\t\t\t\tif (ykey == bottomKey)     bcnt -= comb(bottomKey);\n\t\t\t\t\tif (ykey == leftKey)       lcnt -= comb(leftKey);\n\t\t\t\t\tif (ykey == rightKey)      rcnt -= comb(rightKey);\n\n\t\t\t\t\tif (upKey == bottomKey)    ucnt -= comb(upKey);\n\t\t\t\t\tif (upKey == rightKey)     ucnt -= comb(upKey);\n\t\t\t\t\tif (upKey == leftKey)      ucnt -= comb(upKey);\n\t\t\t\t\tif (bottomKey == rightKey) bcnt -= comb(bottomKey);\n\t\t\t\t\tif (bottomKey == leftKey)  bcnt -= comb(bottomKey);\n\t\t\t\t\tif (rightKey == leftKey)   rcnt -= comb(rightKey);\n\t\t\t\t\t\n\t\t\t\t\tres += ucnt * bcnt * rcnt * lcnt;\n\t\t\t\t\t/*\n\t\t\t\t\tString[] keys = {upKey, bottomKey, rightKey, leftKey};\n\t\t\t\t\tlong[] cnts = {ucnt, bcnt, rcnt, lcnt};\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif (xkey.matches(keys[i])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tif (ykey.matches(keys[i])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tfor (int j = i + 1; j < 4; j++)\n\t\t\t\t\t\t\tif (keys[i].matches(keys[j])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor (long c : cnts) val *= c; \n\t\t\t\t\tres += val;\n\t\t\t\t\t*/\n\t\t\t\t\tint ytmp = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = y3;\n\t\t\t\t\ty3 = y4;\n\t\t\t\t\ty4 = ytmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res/3);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                long[] bk3 = new long[4];\n                Arrays.fill(bk3, -1);\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    int idx = table.get(mask);\n                    prod *= count[idx];\n                    bk3[q] = rotater(mask);\n                    --count[idx];\n                    for (int r = 0; r < 3; ++r) {\n                      idx = table.get(bk3[q]);\n                      --count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                for (int q = 0; q < 4; ++q)\n                  if (bk3[q] != -1)\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      ++count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                rmask = rotater(rmask);\n              }\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                ++count[idx];\n                bk2 = rotater(bk2);\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      Map<Long, Integer> table = new TreeMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          table.put(mask, table.containsKey(mask) ? table.get(mask) + 1 : 1);\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        Deque<Long> queue1 = new ArrayDeque<Long>();\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          queue1.add(bk1);\n          table.put(bk1, table.get(bk1) - 1);\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              Deque<Long> queue2 = new ArrayDeque<Long>();\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                queue2.add(bk2);\n                table.put(bk2, table.get(bk2) - 1);\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Long> queue3 = new ArrayDeque<Long>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= table.get(mask);\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      queue3.add(bk3);\n                      table.put(bk3, table.get(bk3) - 1);\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  long mask = queue3.poll();\n                  table.put(mask, table.get(mask) + 1);\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                long mask = queue2.poll();\n                table.put(mask, table.get(mask) + 1);\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          long mask = queue1.poll();\n          table.put(mask, table.get(mask) + 1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong a2 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b2 = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 8;\n\t\tint cnt = 0;\n\t\tPair[] array;\n\t\tint[] flag;// 0 : unused,1:used,2:deleted\n\n\t\tpublic HashMap() {\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\treturn array[id].value;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 0)\n\t\t\t\t\treturn false;\n\t\t\t\tif (flag[id] == 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\tarray[id] = null;\n\t\t\t\t\tflag[id] = 2;\n\t\t\t\t\tif (sz >= 8 * cnt) {\n\t\t\t\t\t\tchangeSize(sz / 2);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\n\t\t}\n\n\t\tboolean put(long key, long value) {\n\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1) {\n\t\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\t\tarray[id].value = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0 || flag[id] == 2) {\n\t\t\t\t\tarray[id] = new Pair(key, value);\n\t\t\t\t\tflag[id] = 1;\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif (2 * cnt == sz) {\n\t\t\t\t\t\tchangeSize(2 * sz);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tint hash1(long v) {\n\t\t\treturn (int) ((a1 * v % p + b1) % p % sz);\n\t\t}\n\n\t\tint hash2(long v) {\n\t\t\treturn (int) ((a2 * v % p + b2) % p % sz);\n\t\t}\n\n\t\tint id(long v, int i) {\n\t\t\treturn (hash1(v) + i * (2 * hash2(v) + 1)) % sz;\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tPair[] tmp = new Pair[sz];\n\t\t\tint[] tmpFlag = new int[sz];\n\t\t\tfor (int i = 0; i < array.length; ++i) {\n\t\t\t\ttmp[i] = array[i];\n\t\t\t\ttmpFlag[i] = flag[i];\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t\tcnt = 0;\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tif (tmpFlag[i] == 1) {\n\t\t\t\t\tput(tmp[i].key, tmp[i].value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n\t\tlong[][] comb = new long[401][401];\n\t\tlong[] fact = new long[401];\n\t\tfact[0] = 1;\n\t\tfor(int i = 0; i < comb.length; i++) {\n\t\t\tif(i > 0) fact[i] = fact[i-1] * i;\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t\tfor(int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\t\t\t}\n\t\t}\n\t\t\n//\t\tdump(comb[400][6]);\n\t\t\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint[][] C = io.nextIntArray2D(n, 4);\n\t\t\tlong ans = 0;\n\t\t\t\n//\t\t\tint[] p1 = new int[]{0, 1, 2, 3,};\n\t\t\tint[] p2 = new int[]{1, 0, 3, 2,};\n\t\t\t\n\t\t\tRollingHashMod[] rh = new RollingHashMod[n];\n\t\t\tfor(int i = 0; i < n; i++) rh[i] = new RollingHashMod(C[i]);\n\t\t\t\n\t\t\tfinal TreeMap<Long, Integer> mp = new TreeMap<>();\n\n//\t\t\tdump(3, rh[3].str, rh[3].minRotateIndex());\n//\t\t\tif(true) throw new RuntimeException();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tlong h = rh[i].minRotateHash();\n\t\t\t\tmp.put(h, mp.getOrDefault(h, 0) + 1);\n//\t\t\t\tdump(i, rh[i].str, rh[i].minRotateIndex(), h);\n\t\t\t}\n//\t\t\tif(true) throw new RuntimeException();\n\t\t\t\n\t\t\tint[] dup = new int[4];\n\t\t\t\n\t\t\t/*\n\t\t\t * 1 2\n\t\t\t * 3 4\n\t\t\t * \n\t\t\t * 1 2\n\t\t\t * 3 4\n\t\t\t */\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tmp.put(rh[i].minRotateHash(), mp.get(rh[i].minRotateHash()) - 1);\n\t\t\t\tfor(int j = i + 1; j < n; j++) for(int d = 0; d < 4; d++) {\n\t\t\t\t\tArrays.fill(dup, 1);\n\t\t\t\t\tRollingHashMod[] hs = new RollingHashMod[4];\n\t\t\t\t\tfor(int s = 0; s < 4; s++) {\n\t\t\t\t\t\ths[s] = new RollingHashMod(C[i][(s+1)&3], C[i][(s+0)&3], C[j][p2[(s+d+0)&3]], C[j][p2[(s+d+1)&3]]);\n\t\t\t\t\t}\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor(int s = 0; s < 4; s++) if(dup[s] == 1) {\n\t\t\t\t\t\tfor(int k = s + 1; k < 4; k++) {\n\t\t\t\t\t\t\tif(hs[s].minRotateHash() == hs[k].minRotateHash()) {\n\t\t\t\t\t\t\t\tdup[k] = -1;\n\t\t\t\t\t\t\t\tdup[s]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \n\t\t\t\t\t\tint cnt = mp.getOrDefault(hs[s].minRotateHash(), 0);\n\t\t\t\t\t\tif(rh[j].minRotateHash() == hs[s].minRotateHash()) {\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint hi = hs[s].minRotateIndex();\n\t\t\t\t\t\tint sym = 1;\n\t\t\t\t\t\tif(hs[s].minRotateHash() == hs[s].hash((hi + 1) % 4, (hi + 1) % 4)) {\n\t\t\t\t\t\t\tsym = 4;\n\t\t\t\t\t\t} else if(hs[s].minRotateHash() == hs[s].hash((hi + 2) % 4, (hi + 2) % 4)) {\n\t\t\t\t\t\t\tsym = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong pow = 1;\n\t\t\t\t\t\tlong comb_fact = 1;\n\t\t\t\t\t\tfor(int k = 0; k < dup[s]; k++) {\n\t\t\t\t\t\t\tpow *= sym;\n\t\t\t\t\t\t\tcomb_fact *= cnt - k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval *= pow * comb_fact;\n//\t\t\t\t\t\tif(i == 1 && j == 3 && d == 3) {\n//\t\t\t\t\t\t\tdump(i, j, s, dup[s], sym, cnt, hs[s].str, hs[s].minRotateHash(), hs[s].minRotateIndex(), val);\n//\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tdump(i, j, d, dup, val);\n\t\t\t\t\tans += val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass RollingHashMod {\n\t\tprivate static final int[] LARGE_PRIMES = new int[]{\n\t\t\t1000000007, 1000000009, 1000000021, 1000000033,\n\t\t\t1000000087, 1000000093, 1000000097, 1000000103,\n\t\t\t1000000123, 1000000181, 1000000207, 1000000223,\n\t\t\t1000000241, 1000000271, 1000000289, 1000000297,\n\t\t\t1000000321, 1000000349, 1000000363, 1000000403,\n\t\t};\n\n\t\tprivate static final Random random = new Random(0);\n\t\tprivate static final int HASH_NUM = 2;\n//\t\tprivate static final long RADIX = 1000000409;\n\t\tprivate static final long RADIX = 1000000003;\n\t\tprivate static final long XOR = random.nextLong();\n\t\t\n\t\tprivate int n;\n\t\tprivate static int[] primes;\n\t\tprivate int[] str;\n\t\tprivate int[][] pow;\n\t\tprivate int[][] table;\n\t\t\n\t\tpublic RollingHashMod(int... str) {\n\t\t\tif(primes == null) {\n//\t\t\t\tfinal Random random = new Random(System.currentTimeMillis());\n\t\t\t\tprimes = new int[HASH_NUM];\n\t\t\t\tfor(int i = 0; i < HASH_NUM; i++) {\n\t\t\t\t\tfinal int idx = random.nextInt(LARGE_PRIMES.length - i);\n\t\t\t\t\tprimes[i] = LARGE_PRIMES[idx];\n\t\t\t\t\tLARGE_PRIMES[idx] = LARGE_PRIMES[LARGE_PRIMES.length - i - 1];\n\t\t\t\t\tLARGE_PRIMES[LARGE_PRIMES.length - i - 1] = primes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tn = str.length;\n\n\t\t\tthis.str = str.clone();\n\t\t\ttable = new int[HASH_NUM][n + 1];\n\t\t\tpow = new int[HASH_NUM][n + 1];\n\t\t\t\n\t\t\tfor(int j = 0; j < HASH_NUM; j++) {\n\t\t\t\tfinal int p = primes[j];\n\t\t\t\tpow[j][0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\ttable[j][i + 1] = (int)(((long)table[j][i] * RADIX + (this.str[i]^XOR)%p + p) % p);\n\t\t\t\t\tpow[j][i + 1] = (int)((long)pow[j][i] * RADIX % p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long hash(int i, int j) {\n\t\t\tif(j >= n) {\n\t\t\t\tj -= n;\n\t\t\t}\n\t\t\tif(i >= j) {\n\t\t\t\treturn hashRotate(i, j);\n\t\t\t} else {\n\t\t\t\treturn hash(0, i, j) << 32 | hash(1, i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long hashRotate(int i, int j) {\n\t\t\tassert(i >= j);\n\t\t\tlong h0 = hash(0, i, n) * pow[0][j] % primes[0] + table[0][j];\n\t\t\tlong h1 = hash(1, i, n) * pow[1][j] % primes[1] + table[1][j];\n\t\t\tif(h0 >= primes[0]) h0 -= primes[0];\n\t\t\tif(h1 >= primes[1]) h1 -= primes[1];\n//\t\t\tdump(str, i, j, h0, h1, hash(0, i, n), table[0]);\n\t\t\treturn h0 << 32 | h1;\n\t\t}\n\t\t\n\t\tprivate long hash(int idx, int i, int j) {\n\t\t\tassert(i <= j);\n\t\t\tlong h0 = table[idx][j] - (long)table[idx][i] * pow[idx][j - i] % primes[idx];\n\t\t\tif(h0 < 0) h0 += primes[idx];\n\t\t\treturn h0;\n\t\t}\n\t\t\n\t\tpublic long minRotateHash() {\n\t\t\tint s = minRotateIndex();\n\t\t\treturn hash(s, s);\n\t\t}\n\t\t\n\t\tprivate int minRotateCache = -1;\n\t\tpublic int minRotateIndex() {\n\t\t\tif(minRotateCache != -1) return minRotateCache;\n\t\t\t\n\t\t\tint s = n - 1;\n\t\t\tfor(int i = n - 2; i >= 0; i--) {\n\t\t\t\tint low = 0, high = n;\n\t\t\t\twhile(high - low > 1) {\n\t\t\t\t\tint mid = (low + high) / 2;\n\t\t\t\t\tif(hash(i, i + mid) == hash(s, s + mid)) {\n\t\t\t\t\t\tlow = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thigh = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tdump(i, s, str, low, high);\n\t\t\t\tif(str[(i + high - 1) % n] <= str[(s + high - 1) % n]) {\n\t\t\t\t\ts = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minRotateCache = s;\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a = rand.nextInt((int) p - 1) + 1;\n\t\tlong b = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 4;\n\t\tint cnt = 0;\n\t\tLinkedList<Pair>[] list;\n\n\t\tpublic HashMap() {\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = hash(key);\n\t\t\tboolean ret = list[id].remove(key);\n\t\t\tif (sz >= 3 * cnt) {\n\t\t\t\tchangeSize(sz / 2);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid put(long key, long value) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key == key) {\n\t\t\t\t\tlist[id].get(i).value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist[id].add(new Pair(key, value));\n\t\t\t++cnt;\n\n\t\t\tif (cnt > sz) {\n\t\t\t\tchangeSize(2 * sz);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key == key) {\n\t\t\t\t\treturn list[id].get(i).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key != key) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tint hash(long v) {\n\t\t\treturn (int) ((a * v % p + b) % p % sz);\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tLinkedList<Pair>[] tmp = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\ttmp[i] = new LinkedList<>();\n\t\t\t\ttmp[i].addAll(list[i]);\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tfor (Pair p : tmp[i]) {\n\t\t\t\t\tput(p.key, p.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[][] hash = new long[n][4];\n\t\t\tSet<Long> any = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t\t}\n\t\t\t\t\tany.add(hash[i][rot]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tlong[] dp = new long[1 << 4];\n\t\t\tint[] ways = new int[4];\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tint a = col[front][0];\n\t\t\t\tint b = col[front][1];\n\t\t\t\tint c = col[front][2];\n\t\t\t\tint d = col[front][3];\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tfor (long hh : hs) {\n\t\t\t\t\t\t\tif (!any.contains(hh)) {\n\t\t\t\t\t\t\t\tcontinue rotLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrays.fill(dp, 0);\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calcHash(int a, int b, int c, int d) {\n\t\t\tlong h = 0;\n\t\t\th = 1000 * h + a;\n\t\t\th = 1000 * h + b;\n\t\t\th = 1000 * h + c;\n\t\t\th = 1000 * h + d;\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        Deque<Integer> queue1 = new ArrayDeque<Integer>();\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          queue1.add(idx);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              Deque<Integer> queue2 = new ArrayDeque<Integer>();\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                queue2.add(idx);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Integer> queue3 = new ArrayDeque<Integer>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3);\n                      queue3.add(idx);\n                      --count[idx];\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  int idx = queue3.poll();\n                  ++count[idx];\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                int idx = queue2.poll();\n                ++count[idx];\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          int idx = queue1.poll();\n          ++count[idx];\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[][] hash = new long[n][4];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tlong[] dp = new long[1 << 4];\n\t\t\tint[] ways = new int[4];\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tint a = col[front][0];\n\t\t\t\tint b = col[front][1];\n\t\t\t\tint c = col[front][2];\n\t\t\t\tint d = col[front][3];\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tArrays.fill(dp, 0);\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tint nmask = mask | (1 << bit);\n\t\t\t\t\t\t\t\tif (nmask != mask) {\n\t\t\t\t\t\t\t\t\tdp[nmask] += dp[mask] * ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\tdp[15] += dp[14] * ways[0];\n\t\t\t\t\t\t\tdp[15] += dp[13] * ways[1];\n\t\t\t\t\t\t\tdp[15] += dp[11] * ways[2];\n\t\t\t\t\t\t\tdp[15] += dp[7] * ways[3];\n\t\t\t\t\t\t\tdp[14] += dp[12] * ways[1];\n\t\t\t\t\t\t\tdp[14] += dp[10] * ways[2];\n\t\t\t\t\t\t\tdp[14] += dp[6] * ways[3];\n\t\t\t\t\t\t\tdp[13] += dp[12] * ways[0];\n\t\t\t\t\t\t\tdp[13] += dp[9] * ways[2];\n\t\t\t\t\t\t\tdp[13] += dp[5] * ways[3];\n\t\t\t\t\t\t\tdp[12] += dp[8] * ways[2];\n\t\t\t\t\t\t\tdp[12] += dp[4] * ways[3];\n\t\t\t\t\t\t\tdp[11] += dp[10] * ways[0];\n\t\t\t\t\t\t\tdp[11] += dp[9] * ways[1];\n\t\t\t\t\t\t\tdp[11] += dp[3] * ways[3];\n\t\t\t\t\t\t\tdp[10] += dp[8] * ways[1];\n\t\t\t\t\t\t\tdp[10] += dp[2] * ways[3];\n\t\t\t\t\t\t\tdp[9] += dp[8] * ways[0];\n\t\t\t\t\t\t\tdp[9] += dp[1] * ways[3];\n\t\t\t\t\t\t\tdp[8] += dp[0] * ways[3];\n\t\t\t\t\t\t\tdp[7] += dp[6] * ways[0];\n\t\t\t\t\t\t\tdp[7] += dp[5] * ways[1];\n\t\t\t\t\t\t\tdp[7] += dp[3] * ways[2];\n\t\t\t\t\t\t\tdp[6] += dp[4] * ways[1];\n\t\t\t\t\t\t\tdp[6] += dp[2] * ways[2];\n\t\t\t\t\t\t\tdp[5] += dp[4] * ways[0];\n\t\t\t\t\t\t\tdp[5] += dp[1] * ways[2];\n\t\t\t\t\t\t\tdp[4] += dp[0] * ways[2];\n\t\t\t\t\t\t\tdp[3] += dp[2] * ways[0];\n\t\t\t\t\t\t\tdp[3] += dp[1] * ways[1];\n\t\t\t\t\t\t\tdp[2] += dp[0] * ways[1];\n\t\t\t\t\t\t\tdp[1] += dp[0] * ways[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calcHash(int a, int b, int c, int d) {\n\t\t\tlong h = 0;\n\t\t\th = 1000 * h + a;\n\t\t\th = 1000 * h + b;\n\t\t\th = 1000 * h + c;\n\t\t\th = 1000 * h + d;\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[][] hash = new long[n][4];\n\t\t\tSet<Long> any = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t\t}\n\t\t\t\t\tany.add(hash[i][rot]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint a = col[front][0];\n\t\t\t\t\t\tint b = col[front][1];\n\t\t\t\t\t\tint c = col[front][2];\n\t\t\t\t\t\tint d = col[front][3];\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tfor (long hh : hs) {\n\t\t\t\t\t\t\tif (!any.contains(hh)) {\n\t\t\t\t\t\t\t\tcontinue rotLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong[] dp = new long[1 << 4];\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tint[] ways = new int[4];\n\t\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calcHash(int a, int b, int c, int d) {\n\t\t\tlong h = 0;\n\t\t\th = 1000 * h + a;\n\t\t\th = 1000 * h + b;\n\t\t\th = 1000 * h + c;\n\t\t\th = 1000 * h + d;\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.Map;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            Rect[] rects = new Rect[n];\n            List<Long> summary = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                rects[i] = new Rect();\n                for (int j = 0; j < 4; j++) {\n                    rects[i].colors[j] = in.readInt();\n                }\n                long s = summaryOf(rects[i]);\n                for (int j = 0; j < 4; j++) {\n                    summary.add(s);\n                    s = rotate(s);\n                }\n            }\n\n            LongDiscreteMap dm = new LongDiscreteMap(summary.stream().mapToLong(Long::longValue).toArray(), 0,\n                            summary.size());\n\n            int[][] rotations = new int[dm.maxRank() + 1][4];\n            Map<Long, Integer> map = new HashMap(4000, 0.1F);\n            for (int i = 0; i < rotations.length; i++) {\n                long val = dm.iThElement(i);\n                map.put(val, i);\n                for (int j = 0; j < 4; j++) {\n                    rotations[i][j] = dm.rankOf(val);\n                    val = rotate(val);\n                }\n            }\n\n\n\n            int[] cnts = new int[dm.maxRank() + 1];\n            for (Rect rect : rects) {\n                rect.summary = dm.rankOf(summaryOf(rect));\n                for (int s : rotations[rect.summary]) {\n                    cnts[s] += 1;\n                }\n            }\n\n            int[] cols = new int[8];\n            int[] faces = new int[3];\n\n            long cnt = 0;\n\n            for (int i = 0; i < n; i++) {\n                for (int s : rotations[rects[i].summary]) {\n                    cnts[s] -= 1;\n                }\n                cols[0] = rects[i].get(0, 0);\n                cols[1] = rects[i].get(3, 0);\n                cols[2] = rects[i].get(1, 0);\n                cols[3] = rects[i].get(2, 0);\n\n                for (int j = i + 1; j < n; j++) {\n                    if (i == j) {\n                        continue;\n                    }\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] -= 1;\n                    }\n\n                    for (int rj = 0; rj < 4; rj++) {\n\n                        if (rects[j].get(0, rj) != cols[2] || rects[j].get(3, rj) != cols[3]) {\n                            continue;\n                        }\n\n                        cols[4] = rects[j].get(1, rj);\n                        cols[5] = rects[j].get(2, rj);\n\n                        for (int k = i + 1; k < n; k++) {\n                            if (k == i || k == j) {\n                                continue;\n                            }\n\n\n                            for (int rk = 0; rk < 4; rk++) {\n\n                                if (rects[k].get(0, rk) != cols[4] || rects[k].get(3, rk) != cols[5]) {\n                                    continue;\n                                }\n\n                                cols[6] = rects[k].get(1, rk);\n                                cols[7] = rects[k].get(2, rk);\n\n                                for (int s : rotations[rects[k].summary]) {\n                                    cnts[s] -= 1;\n                                }\n\n                                faces[0] = map.getOrDefault(summaryOf(cols[6], cols[0], cols[1], cols[7]), -1);\n                                faces[1] = map.getOrDefault(summaryOf(cols[7], cols[1], cols[3], cols[5]), -1);\n                                faces[2] = map.getOrDefault(summaryOf(cols[0], cols[6], cols[4], cols[2]), -1);\n\n                                if (faces[0] >= 0 && faces[1] >= 0 && faces[2] >= 0) {\n                                    long localCnt = 1;\n                                    for (int t = 0; t < 3; t++) {\n                                        localCnt *= cnts[faces[t]];\n                                        for (int r : rotations[faces[t]]) {\n                                            cnts[r]--;\n                                        }\n                                    }\n                                    cnt += localCnt;\n                                    for (int t = 0; t < 3; t++) {\n                                        for (int r : rotations[faces[t]]) {\n                                            cnts[r]++;\n                                        }\n                                    }\n                                }\n\n                                for (int s : rotations[rects[k].summary]) {\n                                    cnts[s] += 1;\n                                }\n\n                            }\n                        }\n                    }\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] += 1;\n                    }\n                }\n            }\n\n            out.println(cnt);\n        }\n\n        public long summaryOf(Rect rect) {\n            return summaryOf(rect.colors[0], rect.colors[1], rect.colors[2], rect.colors[3]);\n        }\n\n        public long summaryOf(int a, int b, int c, int d) {\n            long ans = a;\n            ans = ans * 1000 + b;\n            ans = ans * 1000 + c;\n            ans = ans * 1000 + d;\n            return ans;\n        }\n\n        public long rotate(long x) {\n            return (x % 1000) * 1_000_000_000 + x / 1000;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Rect {\n        int[] colors = new int[4];\n        int summary;\n\n        public int get(int i, int r) {\n            return colors[(i + r) & 3];\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class LongDiscreteMap {\n        long[] val;\n        int f;\n        int t;\n\n        public LongDiscreteMap(long[] val, int f, int t) {\n            Randomized.randomizedArray(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(long x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public long iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong XXX = 1010;\n\tlong toKey(int[] c) {\n\t\tlong key = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tlong curKey = 0;\n\t\t\tfor (int j = 0; j < 4; j++) curKey = curKey * XXX + c[(i+j)%4];\n\t\t\tif (key > curKey) key = curKey;\n\t\t}\n\t\treturn key;\n\t}\n\t\n\tHashMap<Long, Long> hash = new HashMap<>();\n\tvoid add(long key) {\n\t\tif (hash.containsKey(key))\n\t\t\thash.put(key, hash.get(key) + 1);\n\t\telse\n\t\t\thash.put(key, 1L);\n\t}\n\t\n\tint comb(long key) {\n\t\tlong[] vals = new long[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvals[i] = key % XXX;\n\t\t\tkey /= XXX;\n\t\t}\n\t\tif (vals[0] == vals[1] && vals[1] == vals[2] && vals[2] == vals[3])\n\t\t\treturn 4;\n\t\telse if (vals[0] == vals[2] && vals[1] == vals[3])\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\t\n\tlong get(long key) {\n\t\tif (!hash.containsKey(key)) return 0;\n\t\treturn hash.get(key);\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tint[][] C = new int[N][7];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tC[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tlong key = toKey(C[i]);\n\t\t\tadd(key);\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tfor (int c1 = 0; c1 < N; c1++) {\n\t\t\tfor (int c2 = c1 + 1; c2 < N; c2++) {\n\t\t\t\tint x1 = C[c1][0], x2 = C[c1][1], x3 = C[c1][2], x4 = C[c1][3];\n\t\t\t\tint y1 = C[c2][1], y2 = C[c2][0], y3 = C[c2][3], y4 = C[c2][2];\n\t\t\t\tfor (int rotate = 0; rotate < 4; rotate++) {\n\t\t\t\t\tlong xkey      = toKey(new int[]{x1, x2, x3, x4});\n\t\t\t\t\tlong ykey      = toKey(new int[]{y1, y2, y3, y4});\n\t\t\t\t\tlong upKey     = toKey(new int[]{y1, y2, x2, x1});\n\t\t\t\t\tlong bottomKey = toKey(new int[]{y3, y4, x4, x3});\n\t\t\t\t\tlong rightKey  = toKey(new int[]{x3, x2, y2, y3});\n\t\t\t\t\tlong leftKey   = toKey(new int[]{x1, x4, y4, y1}); \n\t\t\t\t\t\n\t\t\t\t\tlong ucnt = get(upKey) * comb(upKey);\n\t\t\t\t\tlong bcnt = get(bottomKey) * comb(bottomKey);\n\t\t\t\t\tlong rcnt = get(rightKey) * comb(rightKey);\n\t\t\t\t\tlong lcnt = get(leftKey) * comb(leftKey);\n\t\t\t\t\t\n\t\t\t\t\tif (xkey == upKey)         ucnt -= comb(upKey);\n\t\t\t\t\tif (xkey == bottomKey)     bcnt -= comb(bottomKey);\n\t\t\t\t\tif (xkey == leftKey)       lcnt -= comb(leftKey);\n\t\t\t\t\tif (xkey == rightKey)      rcnt -= comb(rightKey);\n\n\t\t\t\t\tif (ykey == upKey)         ucnt -= comb(upKey);\n\t\t\t\t\tif (ykey == bottomKey)     bcnt -= comb(bottomKey);\n\t\t\t\t\tif (ykey == leftKey)       lcnt -= comb(leftKey);\n\t\t\t\t\tif (ykey == rightKey)      rcnt -= comb(rightKey);\n\n\t\t\t\t\tif (upKey == bottomKey)    ucnt -= comb(upKey);\n\t\t\t\t\tif (upKey == rightKey)     ucnt -= comb(upKey);\n\t\t\t\t\tif (upKey == leftKey)      ucnt -= comb(upKey);\n\t\t\t\t\tif (bottomKey == rightKey) bcnt -= comb(bottomKey);\n\t\t\t\t\tif (bottomKey == leftKey)  bcnt -= comb(bottomKey);\n\t\t\t\t\tif (rightKey == leftKey)   rcnt -= comb(rightKey);\n\t\t\t\t\t\n\t\t\t\t\tres += ucnt * bcnt * rcnt * lcnt;\n\t\t\t\t\t/*\n\t\t\t\t\tString[] keys = {upKey, bottomKey, rightKey, leftKey};\n\t\t\t\t\tlong[] cnts = {ucnt, bcnt, rcnt, lcnt};\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif (xkey.matches(keys[i])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tif (ykey.matches(keys[i])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tfor (int j = i + 1; j < 4; j++)\n\t\t\t\t\t\t\tif (keys[i].matches(keys[j])) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor (long c : cnts) val *= c; \n\t\t\t\t\tres += val;\n\t\t\t\t\t*/\n\t\t\t\t\tint ytmp = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = y3;\n\t\t\t\t\ty3 = y4;\n\t\t\t\t\ty4 = ytmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res/3);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int[][] C = sc.nextIntTable(N, 4);\n\n    Map<Long, Integer> map = new HashMap<>();\n    Map<Long, Long> rot = new HashMap<>();\n    long[] hash = new long[N];\n    for (int i = 0; i < N; i++) {\n      long h = hash(C[i][0], C[i][1], C[i][2], C[i][3]);\n      if (!map.containsKey(h)) {\n        map.put(h, 0);\n      }\n      map.put(h, map.get(h) + 1);\n      rot.put(h, rot(C[i]));\n      hash[i] = h;\n    }\n\n    int[][] idx = {{0, 4, 7, 1}, {1, 7, 6, 2}, {3, 2, 6, 5}, {0, 3, 5, 4}};\n\n    long count = 0;\n    for (int i = 0; i < N; i++) {\n      for (int j = i + 1; j < N; j++) {\n\n        loop: for (int k = 0; k < 4; k++) {\n          Map<Long, Integer> tmp = new HashMap<>();\n          tmp.put(hash[i], 1);\n          tmp.put(hash[j], hash[i] == hash[j] ? 2 : 1);\n\n          int[] c = {C[i][0], C[i][1], C[i][2], C[i][3], C[j][(0 + k) % 4], C[j][(1 + k) % 4],\n              C[j][(2 + k) % 4], C[j][(3 + k) % 4]};\n\n\n          long nc = 1;\n          for (int[] v : idx) {\n            long h = hash(c[v[0]], c[v[1]], c[v[2]], c[v[3]]);\n            if (!tmp.containsKey(h)) tmp.put(h, 0);\n\n            if (!map.containsKey(h) || tmp.get(h) >= map.get(h)) {\n              continue loop;\n            }\n            nc *= (map.get(h) - tmp.get(h)) * rot.get(h);\n            tmp.put(h, tmp.get(h) + 1);\n          }\n\n\n          count += nc;\n        }\n      }\n    }\n    System.out.println(count * 2 / 6);\n  }\n\n  private static long rot(int... C) {\n    int ret = 0;\n    for (int i = 0; i < 4; i++) {\n      if (C[0] == C[(i + 0) % 4] && C[1] == C[(i + 1) % 4] && C[2] == C[(i + 2) % 4]\n          && C[3] == C[(i + 3) % 4]) {\n        ret ++;\n      }\n    }\n    return ret;\n  }\n\n  private static long hash(int... C) {\n    long min = Long.MAX_VALUE;\n\n    for (int k = 0; k < 4; k++) {\n      long ret = 0;\n      for (int i = 0; i < 4; i++) {\n        ret *= 1000;\n        ret += C[(i + k) % 4];\n      }\n      min = Math.min(min, ret);\n    }\n    return min;\n  }\n}\n\n\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong XXX = 10000;\n\tlong toKey(int[] c) {\n\t\tlong key = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tlong curKey = 0;\n\t\t\tfor (int j = 0; j < 4; j++) curKey = curKey * XXX + c[(i+j)%4];\n\t\t\tif (key > curKey) key = curKey;\n\t\t}\n\t\treturn key;\n\t}\n\t\n\tHashMap<Long, Long> hash = new HashMap<>();\n\tvoid add(long key) {\n\t\tif (hash.containsKey(key))\n\t\t\thash.put(key, hash.get(key) + 1);\n\t\telse\n\t\t\thash.put(key, 1L);\n\t}\n\t\n\tint comb(long key) {\n\t\tlong[] vals = new long[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvals[i] = key % XXX;\n\t\t\tkey /= XXX;\n\t\t}\n\t\tif (vals[0] == vals[1] && vals[1] == vals[2] && vals[2] == vals[3])\n\t\t\treturn 4;\n\t\telse if (vals[0] == vals[2] && vals[1] == vals[3])\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\t\n\tlong get(long key) {\n\t\tif (!hash.containsKey(key)) return 0;\n\t\treturn hash.get(key);\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tint[][] C = new int[N][4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tC[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tlong key = toKey(C[i]);\n\t\t\tadd(key);\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tfor (int c1 = 0; c1 < N; c1++) {\n\t\t\tfor (int c2 = c1 + 1; c2 < N; c2++) {\n\t\t\t\tint x1 = C[c1][0], x2 = C[c1][1], x3 = C[c1][2], x4 = C[c1][3];\n\t\t\t\tint y1 = C[c2][1], y2 = C[c2][0], y3 = C[c2][3], y4 = C[c2][2];\n\t\t\t\tlong xkey = toKey(new int[]{x1, x2, x3, x4});\n\t\t\t\tlong ykey = toKey(new int[]{y1, y2, y3, y4});\n\t\t\t\tfor (int rotate = 0; rotate < 4; rotate++) {\n\t\t\t\t\tlong upKey     = toKey(new int[]{y1, y2, x2, x1});\n\t\t\t\t\tlong bottomKey = toKey(new int[]{y3, y4, x4, x3});\n\t\t\t\t\tlong rightKey  = toKey(new int[]{x3, x2, y2, y3});\n\t\t\t\t\tlong leftKey   = toKey(new int[]{x1, x4, y4, y1}); \n\t\t\t\t\t\n\t\t\t\t\tlong ucnt = get(upKey) * comb(upKey);\n\t\t\t\t\tlong bcnt = get(bottomKey) * comb(bottomKey);\n\t\t\t\t\tlong rcnt = get(rightKey) * comb(rightKey);\n\t\t\t\t\tlong lcnt = get(leftKey) * comb(leftKey);\n\t\t\t\t\t\n\t\t\t\t\tlong[] keys = {upKey, bottomKey, rightKey, leftKey};\n\t\t\t\t\tlong[] cnts = {ucnt, bcnt, rcnt, lcnt};\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif (xkey == keys[i]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tif (ykey == keys[i]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tfor (int j = i + 1; j < 4; j++)\n\t\t\t\t\t\t\tif (keys[i] == keys[j]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor (long c : cnts) val *= c; \n\t\t\t\t\tres += val;\n\t\t\t\t\t\n\t\t\t\t\tint ytmp = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = y3;\n\t\t\t\t\ty3 = y4;\n\t\t\t\t\ty4 = ytmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res/3);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\n\t\tHashMap<Long, Integer> num = new HashMap<>();\n\t\tint[][] c = new int[N][4];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<4; j++)\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\tLong code = getCode(c[i]);\n\t\t\tif(num.containsKey(code))\n\t\t\t\tnum.put(code, num.get(code)+1);\n\t\t\telse\n\t\t\t\tnum.put(code, 1);\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tint[][] side = new int[4][4];\n\t\tlong[] sideCode = new long[4];\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tLong bottomCode = getCode(c[i]);\n\t\t\tnum.put(bottomCode, num.get(bottomCode)-1);\n\t\t\t\n\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\tside[j][0] = c[i][j];\n\t\t\t\tside[j][3] = c[i][(j+1)%4];\n\t\t\t}\n\t\t\tfor(int j=i+1; j<N; j++) {\n\t\t\t\tlong topCode = getCode(c[j]);\n\t\t\t\tfor(int d=0; d<4; d++) {\n\t\t\t\t\tlong temp = 1;\n\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\tside[k][2] = c[j][(d-k+4)%4];\n\t\t\t\t\t\tside[k][1] = c[j][(d-k+5)%4];\n\t\t\t\t\t\tsideCode[k] = getCode(side[k]);\n\n\t\t\t\t\t\tInteger cnt = num.get(sideCode[k]);\n\t\t\t\t\t\tif(cnt!=null && cnt>0) {\n\t\t\t\t\t\t\tif(sideCode[k]==topCode && cnt>0)\n\t\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int l=0; l<k; l++)\n\t\t\t\t\t\t\t\tif(sideCode[k]==sideCode[l] && cnt>0)\n\t\t\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(bit(sideCode[k], 0, 20)==bit(sideCode[k], 20, 40)) {\n\t\t\t\t\t\t\t\tcnt <<=1;\n\t\t\t\t\t\t\t\tif(bit(sideCode[k], 0, 10)==bit(sideCode[k], 10, 20))\n\t\t\t\t\t\t\t\t\tcnt <<=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttemp *= cnt;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tsc.close();\n\t}\n\t\n\tstatic long getCode(int[] c) {\n\t\tlong code[] = new long[4];\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\tcode[i] = code[i]<<10 | c[(i+j)%4];\n\t\t\t}\n\t\t}\n\t\tArrays.sort(code);\n\t\treturn code[0];\n\t}\n\t\n\tstatic long bit(long v, int s, int t) {\n\t\tv >>= s;\n\t\treturn v & ((1<<(t-s))-1);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[][] hash = new long[n][4];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint a = col[front][0];\n\t\t\t\t\t\tint b = col[front][1];\n\t\t\t\t\t\tint c = col[front][2];\n\t\t\t\t\t\tint d = col[front][3];\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tlong[] dp = new long[1 << 4];\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calcHash(int... a) {\n\t\t\tlong h = 0;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\th = 1000 * h + a[i];\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int n = ni();\n        long[][] c = new long[n][4];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 4; j++) {\n                c[i][j] = nl();\n            }\n        }\n\n        HashMap<Long, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            long x = tileToLong(c[i]);\n            if (map.containsKey(x)) {\n                map.put(x, map.get(x) + 1);\n            } else {\n                map.put(x, 1);\n            }\n        }\n\n        long ans = 0;\n\n        for (int i = 0; i < n; i++) {\n            long x = tileToLong(c[i]);\n            for (int j = i + 1; j < n; j++) {\n                long y = tileToLong(c[j]);\n                for (int k = 0; k < 4; k++) {\n                    long[] t = new long[4];\n                    long tmp = 1;\n                    for (int l = 0; l < 4; l++) {\n                        long[] c2 = new long[4];\n                        c2[0] = c[i][l % 4];\n                        c2[1] = c[i][(l + 1) % 4];\n                        c2[2] = c[j][(k - l + 4) % 4];\n                        c2[3] = c[j][(k - l + 5) % 4];\n                        t[l] = tileToLong(c2);\n\n                        int cnt = map.containsKey(t[l]) ? map.get(t[l]) : 0;\n\n                        if (cnt > 0 && t[l] == x) cnt--;\n                        if (cnt > 0 && t[l] == y) cnt--;\n                        for (int m = 0; m < l; m++) {\n                            if (cnt > 0 && t[l] == t[m]) cnt--;\n                        }\n\n                        long p = t[l] >> 48;\n                        long q = t[l] >> 32 & (1L << 16) - 1;\n                        long r = t[l] >> 16 & (1L << 16) - 1;\n                        long s = t[l] & (1L << 16 - 1);\n\n                        if (p == q && q == r && r == s) cnt *= 4;\n                        else if (p == r && q == s) cnt *= 2;\n\n                        tmp *= cnt;\n                    }\n                    ans += tmp;\n                }\n            }\n        }\n\n        out.println(ans / 3);\n    }\n\n    long tileToLong(long[] colors) {\n        long ret = Long.MAX_VALUE;\n        for (int i = 0; i < 4; i++) {\n            long tmp = 0;\n            tmp |= colors[i % 4] << 48;\n            tmp |= colors[(i + 1) % 4] << 32;\n            tmp |= colors[(i + 2) % 4] << 16;\n            tmp |= colors[(i + 3) % 4];\n\n            ret = Math.min(ret, tmp);\n        }\n        return ret;\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package main;\n\nimport util.FastScanner;\n\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class ProblemC {\n\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint[][] col = new int[n][4];\n\t\tlong[][] hash = new long[n][4];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tlong[] dp = new long[1 << 4];\n\t\tint[] ways = new int[4];\n\t\tfor (int front = 0; front < n; front++) {\n\t\t\tint a = col[front][0];\n\t\t\tint b = col[front][1];\n\t\t\tint c = col[front][2];\n\t\t\tint d = col[front][3];\n\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\trotLoop:\n\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\tArrays.fill(dp, 0);\n\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tint nmask = mask | (1 << bit);\n\t\t\t\t\t\t\t\tif (nmask != mask) {\n\t\t\t\t\t\t\t\t\tdp[nmask] += dp[mask] * ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tdp[15] += dp[14] * ways[0];\n\t\t\t\t\t\tdp[15] += dp[13] * ways[1];\n\t\t\t\t\t\tdp[15] += dp[11] * ways[2];\n\t\t\t\t\t\tdp[15] += dp[7] * ways[3];\n\t\t\t\t\t\tdp[14] += dp[12] * ways[1];\n\t\t\t\t\t\tdp[14] += dp[10] * ways[2];\n\t\t\t\t\t\tdp[14] += dp[6] * ways[3];\n\t\t\t\t\t\tdp[13] += dp[12] * ways[0];\n\t\t\t\t\t\tdp[13] += dp[9] * ways[2];\n\t\t\t\t\t\tdp[13] += dp[5] * ways[3];\n\t\t\t\t\t\tdp[12] += dp[8] * ways[2];\n\t\t\t\t\t\tdp[12] += dp[4] * ways[3];\n\t\t\t\t\t\tdp[11] += dp[10] * ways[0];\n\t\t\t\t\t\tdp[11] += dp[9] * ways[1];\n\t\t\t\t\t\tdp[11] += dp[3] * ways[3];\n\t\t\t\t\t\tdp[10] += dp[8] * ways[1];\n\t\t\t\t\t\tdp[10] += dp[2] * ways[3];\n\t\t\t\t\t\tdp[9] += dp[8] * ways[0];\n\t\t\t\t\t\tdp[9] += dp[1] * ways[3];\n\t\t\t\t\t\tdp[8] += dp[0] * ways[3];\n\t\t\t\t\t\tdp[7] += dp[6] * ways[0];\n\t\t\t\t\t\tdp[7] += dp[5] * ways[1];\n\t\t\t\t\t\tdp[7] += dp[3] * ways[2];\n\t\t\t\t\t\tdp[6] += dp[4] * ways[1];\n\t\t\t\t\t\tdp[6] += dp[2] * ways[2];\n\t\t\t\t\t\tdp[5] += dp[4] * ways[0];\n\t\t\t\t\t\tdp[5] += dp[1] * ways[2];\n\t\t\t\t\t\tdp[4] += dp[0] * ways[2];\n\t\t\t\t\t\tdp[3] += dp[2] * ways[0];\n\t\t\t\t\t\tdp[3] += dp[1] * ways[1];\n\t\t\t\t\t\tdp[2] += dp[0] * ways[1];\n\t\t\t\t\t\tdp[1] += dp[0] * ways[0];\n\t\t\t\t\t}\n\t\t\t\t\tans += dp[15];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tprivate long calcHash(int a, int b, int c, int d) {\n\t\tlong h = 0;\n\t\th = 1000 * h + a;\n\t\th = 1000 * h + b;\n\t\th = 1000 * h + c;\n\t\th = 1000 * h + d;\n\t\treturn h;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Integer> queue = new ArrayDeque<Integer>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3);\n                      --count[idx];\n                      queue.add(idx);\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue.isEmpty()) {\n                  int idx = queue.poll();\n                  ++count[idx];\n                }\n                rmask = rotater(rmask);\n              }\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                ++count[idx];\n                bk2 = rotater(bk2);\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\n\t\tHashMap<Long, Integer> num = new HashMap<>();\n\t\tint[][] c = new int[N][4];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<4; j++)\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\tLong code = getCode(c[i]);\n\t\t\tif(num.containsKey(code))\n\t\t\t\tnum.put(code, num.get(code)+1);\n\t\t\telse\n\t\t\t\tnum.put(code, 1);\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tint[][] side = new int[4][4];\n\t\tlong[] sideCode = new long[4];\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tLong bottomCode = getCode(c[i]);\n\t\t\tnum.put(bottomCode, num.get(bottomCode)-1);\n\t\t\t\n\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\tside[j][0] = c[i][j];\n\t\t\t\tside[j][3] = c[i][(j+1)%4];\n\t\t\t}\n\t\t\tfor(int j=i+1; j<N; j++) {\n\t\t\t\tlong topCode = getCode(c[j]);\n\t\t\t\tfor(int d=0; d<4; d++) {\n\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\tside[k][2] = c[j][(d+k)%4];\n\t\t\t\t\t\tside[k][1] = c[j][(d+k+1)%4];\n\t\t\t\t\t\tsideCode[k] = getCode(side[k]);\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(sideCode);\n\t\t\t\t\t\n\t\t\t\t\tlong temp = 1;\n\t\t\t\t\tint anc=0;\n\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\tif(k==3 || sideCode[k]!=sideCode[k+1]) {\n\t\t\t\t\t\t\tInteger total = num.get(sideCode[k]);\n\t\t\t\t\t\t\tif(total==null)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(sideCode[k]==topCode)\n\t\t\t\t\t\t\t\ttotal--;\n\t\t\t\t\t\t\tfor(int l=0; l<k-anc+1; l++)\n\t\t\t\t\t\t\t\ttemp *= total-l;\n\t\t\t\t\t\t\tanc=k+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tsc.close();\n\t}\n\t\n\tstatic long getCode(int[] c) {\n\t\tint idx = 0;\n\t\tfor(int i=1; i<4; i++)\n\t\t\tif(c[i]<c[idx])\n\t\t\t\tidx=i;\n\t\tlong code = 0;\n\t\tfor(int i=0; i<4; i++)\n\t\t\tcode |= c[(i+idx)%4]<<10;\n\t\treturn code;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new TreeMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0, ans = 0;\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int k = 0; k < n; ++k)\n          if (k != i) {\n            long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n            long bk2 = rmask;\n            for (int p = 0; p < 4; ++p) {\n              int idx = table.get(bk2);\n              --count[idx];\n              bk2 = rotater(bk2);\n            }\n            for (int p = 0; p < 4; ++p) {\n              long prod = 1;\n              long rrmask = rmask;\n              long llmask = lmask;\n              boolean okay = true;\n              Deque<Integer> queue = new ArrayDeque<Integer>();\n              for (int q = 0; q < 4; ++q) {\n                long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                if (table.containsKey(mask)) {\n                  prod *= count[table.get(mask)];\n                  long bk3 = mask;\n                  for (int r = 0; r < 4; ++r) {\n                    int idx = table.get(bk3);\n                    --count[idx];\n                    queue.add(idx);\n                    bk3 = rotater(bk3);\n                  }\n                } else\n                  okay = false;\n                llmask = rotater(llmask);\n                rrmask = rotatel(rrmask);\n              }\n              if (okay) {\n                acc += prod;\n                if (acc > Long.MAX_VALUE / 12 && acc % 6 == 0) {\n                  ans += acc / 6;\n                  acc = 0;\n                }\n              }\n              while (!queue.isEmpty()) {\n                int idx = queue.poll();\n                ++count[idx];\n              }\n              rmask = rotater(rmask);\n            }\n            for (int p = 0; p < 4; ++p) {\n              int idx = table.get(bk2);\n              ++count[idx];\n              bk2 = rotater(bk2);\n            }\n          }\n        lmask = rotater(lmask);\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      ans += acc / 6;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong a2 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b2 = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 32;\n\t\tint cnt = 0;\n\t\tPair[] array;\n\t\tint[] flag;// 0 : unused,1:used,2:deleted\n\n\t\tpublic HashMap() {\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\treturn array[id].value;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 0)\n\t\t\t\t\treturn false;\n\t\t\t\tif (flag[id] == 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\tarray[id] = null;\n\t\t\t\t\tflag[id] = 2;\n\t\t\t\t\tif (sz >= 8 * cnt) {\n\t\t\t\t\t\tchangeSize(sz / 2);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\n\t\t}\n\n\t\tboolean put(long key, long value) {\n\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1) {\n\t\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\t\tarray[id].value = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0 || flag[id] == 2) {\n\t\t\t\t\tarray[id] = new Pair(key, value);\n\t\t\t\t\tflag[id] = 1;\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif (2 * cnt == sz) {\n\t\t\t\t\t\tchangeSize(2 * sz);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tint hash1(long v) {\n\t\t\treturn (int) ((a1 * v % p + b1) % p % sz);\n\t\t}\n\n\t\tint hash2(long v) {\n\t\t\treturn (int) ((a2 * v % p + b2) % p % sz);\n\t\t}\n\n\t\tint id(long v, int i) {\n\t\t\treturn (hash1(v) + i * (2 * hash2(v) + 1)) % sz;\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tPair[] tmp = new Pair[sz];\n\t\t\tint[] tmpFlag = new int[sz];\n\t\t\tfor (int i = 0; i < array.length; ++i) {\n\t\t\t\ttmp[i] = array[i];\n\t\t\t\ttmpFlag[i] = flag[i];\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t\tcnt = 0;\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tif (tmpFlag[i] == 1) {\n\t\t\t\t\tput(tmp[i].key, tmp[i].value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      long[] bk3 = new long[4];\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Arrays.fill(bk3, -1);\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    bk3[q] = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      --count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                for (int q = 0; q < 4; ++q)\n                  if (bk3[q] != -1)\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      ++count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                rmask = rotater(rmask);\n              }\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                ++count[idx];\n                bk2 = rotater(bk2);\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0, ans = 0;\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int k = 0; k < n; ++k)\n          if (k != i) {\n            long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n            long bk2 = rmask;\n            for (int p = 0; p < 4; ++p) {\n              int idx = table.get(bk2);\n              --count[idx];\n              bk2 = rotater(bk2);\n            }\n            for (int p = 0; p < 4; ++p) {\n              long prod = 1;\n              long rrmask = rmask;\n              long llmask = lmask;\n              boolean okay = true;\n              Deque<Integer> queue = new ArrayDeque<Integer>();\n              for (int q = 0; q < 4; ++q) {\n                long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                if (table.containsKey(mask)) {\n                  prod *= count[table.get(mask)];\n                  long bk3 = mask;\n                  for (int r = 0; r < 4; ++r) {\n                    int idx = table.get(bk3);\n                    --count[idx];\n                    queue.add(idx);\n                    bk3 = rotater(bk3);\n                  }\n                } else\n                  okay = false;\n                llmask = rotater(llmask);\n                rrmask = rotatel(rrmask);\n              }\n              if (okay) {\n                acc += prod;\n                if (acc > Long.MAX_VALUE / 12 && acc % 6 == 0) {\n                  ans += acc / 6;\n                  acc = 0;\n                }\n              }\n              while (!queue.isEmpty()) {\n                int idx = queue.poll();\n                ++count[idx];\n              }\n              rmask = rotater(rmask);\n            }\n            for (int p = 0; p < 4; ++p) {\n              int idx = table.get(bk2);\n              ++count[idx];\n              bk2 = rotater(bk2);\n            }\n          }\n        lmask = rotater(lmask);\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      ans += acc / 6;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            Rect[] rects = new Rect[n];\n            List<Long> summary = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                rects[i] = new Rect();\n                for (int j = 0; j < 4; j++) {\n                    rects[i].colors[j] = in.readInt();\n                }\n                long s = summaryOf(rects[i]);\n                for (int j = 0; j < 4; j++) {\n                    summary.add(s);\n                    s = rotate(s);\n                }\n            }\n\n            LongDiscreteMap dm = new LongDiscreteMap(summary.stream().mapToLong(Long::longValue).toArray(), 0,\n                            summary.size());\n\n            int[][] rotations = new int[dm.maxRank() + 1][4];\n            for (int i = 0; i < rotations.length; i++) {\n                long val = dm.iThElement(i);\n                for (int j = 0; j < 4; j++) {\n                    rotations[i][j] = dm.rankOf(val);\n                    val = rotate(val);\n                }\n            }\n\n            int[] cnts = new int[dm.maxRank() + 1];\n            for (Rect rect : rects) {\n                rect.summary = dm.rankOf(summaryOf(rect));\n                for (int s : rotations[rect.summary]) {\n                    cnts[s] += 1;\n                }\n            }\n\n            int[] cols = new int[8];\n            int[] faces = new int[3];\n\n            long cnt = 0;\n            for (int i = 0; i < n; i++) {\n                for (int s : rotations[rects[i].summary]) {\n                    cnts[s] -= 1;\n                }\n                cols[0] = rects[i].get(0, 0);\n                cols[1] = rects[i].get(3, 0);\n                cols[2] = rects[i].get(1, 0);\n                cols[3] = rects[i].get(2, 0);\n\n                for (int j = i + 1; j < n; j++) {\n                    if (i == j) {\n                        continue;\n                    }\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] -= 1;\n                    }\n\n                    for (int rj = 0; rj < 4; rj++) {\n\n                        if (rects[j].get(0, rj) != cols[2] || rects[j].get(3, rj) != cols[3]) {\n                            continue;\n                        }\n\n                        cols[4] = rects[j].get(1, rj);\n                        cols[5] = rects[j].get(2, rj);\n\n                        for (int k = i + 1; k < n; k++) {\n                            if (k == i || k == j) {\n                                continue;\n                            }\n\n\n                            for (int rk = 0; rk < 4; rk++) {\n\n                                if (rects[k].get(0, rk) != cols[4] || rects[k].get(3, rk) != cols[5]) {\n                                    continue;\n                                }\n\n                                cols[6] = rects[k].get(1, rk);\n                                cols[7] = rects[k].get(2, rk);\n\n                                for (int s : rotations[rects[k].summary]) {\n                                    cnts[s] -= 1;\n                                }\n\n                                faces[0] = dm.rankOf(summaryOf(cols[6], cols[0], cols[1], cols[7]));\n                                faces[1] = dm.rankOf(summaryOf(cols[7], cols[1], cols[3], cols[5]));\n                                faces[2] = dm.rankOf(summaryOf(cols[0], cols[6], cols[4], cols[2]));\n\n                                if (faces[0] >= 0 && faces[1] >= 0 && faces[2] >= 0) {\n                                    long localCnt = 1;\n                                    for (int t = 0; t < 3; t++) {\n                                        localCnt *= cnts[faces[t]];\n                                        for (int r : rotations[faces[t]]) {\n                                            cnts[r]--;\n                                        }\n                                    }\n                                    cnt += localCnt;\n                                    for (int t = 0; t < 3; t++) {\n                                        for (int r : rotations[faces[t]]) {\n                                            cnts[r]++;\n                                        }\n                                    }\n                                }\n\n                                for (int s : rotations[rects[k].summary]) {\n                                    cnts[s] += 1;\n                                }\n\n                            }\n                        }\n                    }\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] += 1;\n                    }\n                }\n            }\n\n            out.println(cnt);\n        }\n\n        public long summaryOf(Rect rect) {\n            return summaryOf(rect.colors[0], rect.colors[1], rect.colors[2], rect.colors[3]);\n        }\n\n        public long summaryOf(int a, int b, int c, int d) {\n            long ans = a;\n            ans = ans * 1000 + b;\n            ans = ans * 1000 + c;\n            ans = ans * 1000 + d;\n            return ans;\n        }\n\n        public long rotate(long x) {\n            return (x % 1000) * 1_000_000_000 + x / 1000;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Rect {\n        int[] colors = new int[4];\n        int summary;\n\n        public int get(int i, int r) {\n            return colors[(i + r) & 3];\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class LongDiscreteMap {\n        long[] val;\n        int f;\n        int t;\n\n        public LongDiscreteMap(long[] val, int f, int t) {\n            Randomized.randomizedArray(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(long x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public long iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n \npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        Deque<Integer> queue1 = new ArrayDeque<Integer>();\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          queue1.add(idx);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              Deque<Integer> queue2 = new ArrayDeque<Integer>();\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                queue2.add(idx);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Integer> queue3 = new ArrayDeque<Integer>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3);\n                      queue3.add(idx);\n                      --count[idx];\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  int idx = queue3.poll();\n                  ++count[idx];\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                int idx = queue2.poll();\n                ++count[idx];\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          int idx = queue1.poll();\n          ++count[idx];\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n \n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n \n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n \n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n \n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc062;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\n/**\n * Created by hama_du on 2016/10/19.\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        debug(code(new int[]{0,1,1,0}), code(new int[]{1,1,0,0}));\n\n        int n = in.nextInt();\n        int[][] panels = in.nextIntTable(n, 4);\n\n        long[] panelCodes = new long[n];\n        for (int i = 0; i < n ; i++) {\n            panelCodes[i] = code(panels[i]);\n        }\n\n        long ans = 0;\n        for (int top = 0 ; top < n ; top++) {\n            for (int bottom = top+1 ; bottom < n ; bottom++) {\n                int[][] sidePanels = new int[n][];\n                long[] sideCodes = new long[n];\n                int sidx = 0;\n                for (int i = top+1 ; i < n ; i++) {\n                    if (i == bottom) {\n                        continue;\n                    }\n                    sidePanels[sidx] = panels[i].clone();\n                    sideCodes[sidx++] = panelCodes[i];\n                }\n                sidePanels = Arrays.copyOf(sidePanels, sidx);\n                sideCodes = Arrays.copyOf(sideCodes, sidx);\n\n                // top\n                // 0 1\n                // 3 2\n\n                // bottom\n                // 3 2\n                // 0 1\n\n                for (int d = 0 ; d < 4 ; d++) {\n                    int[][] men = new int[][]{\n                            { panels[top][1], panels[top][0], panels[bottom][(d+3)%4], panels[bottom][(d+2)%4] },\n                            { panels[top][2], panels[top][1], panels[bottom][(d+2)%4], panels[bottom][(d+1)%4] },\n                            { panels[top][3], panels[top][2], panels[bottom][(d+1)%4], panels[bottom][(d+0)%4] },\n                            { panels[top][0], panels[top][3], panels[bottom][(d+0)%4], panels[bottom][(d+3)%4] }\n                    };\n                    ans += solve(men, sidePanels, sideCodes);\n                }\n            }\n        }\n\n        out.println(ans);\n        out.flush();\n    }\n\n    private static long same(int[] men) {\n        if (men[0] == men[1] && men[1] == men[2] && men[2] == men[3]) {\n            return 4;\n        }\n        if (men[0] == men[2] && men[1] == men[3]) {\n            return 2;\n        }\n        return 1;\n    }\n\n    private static long code(int[] men) {\n        int[] minOrd = men.clone();\n        for (int i = 1 ; i < 4; i++) {\n            int[] ord = new int[4];\n            for (int j = 0; j < 4 ; j++) {\n                ord[j] = men[(j+i)%4];\n            }\n            for (int j = 0; j < 4 ; j++) {\n                if (minOrd[j] > ord[j]) {\n                    minOrd = ord.clone();\n                    break;\n                } else if (ord[j] > minOrd[j]) {\n                    break;\n                }\n            }\n        }\n\n        long wo = 0;\n        for (int i = 0; i < 4; i++) {\n            wo |= ((long) minOrd[i]) << (10L * i);\n        }\n        return wo;\n    }\n\n    private static long solve(int[][] men, int[][] panels, long[] codes) {\n        int n = panels.length;\n        long[] menCodes = new long[4];\n        for (int i = 0; i < 4 ; i++) {\n            menCodes[i] = code(men[i]);\n        }\n        long[] menCounts = new long[4];\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < 4 ; j++) {\n                if (menCodes[j] == codes[i]) {\n                    menCounts[j]++;\n                }\n            }\n        }\n\n        Map<Long,Long> dec = new HashMap<>();\n        long ret = 1;\n        for (int i = 0 ; i < 4 ; i++) {\n            long A = same(men[i]);\n            ret *= A * menCounts[i] - A * dec.getOrDefault(menCodes[i], 0L);\n            dec.put(menCodes[i], dec.getOrDefault(menCodes[i], 0L) + 1);\n        }\n        if (ret < 0) {\n            return 0;\n        }\n        return ret;\n    }\n\n    private static int[] match(int[][] men, int[] panel) {\n        int[] x = new int[4];\n        for (int i = 0; i < 4 ; i++) {\n            for (int d = 0 ; d < 4 ; d++) {\n                boolean isOK = true;\n                for (int e = 0 ; e < 4 ; e++){\n                    if (men[i][e] != panel[(d+e)%4]) {\n                        isOK = false;\n                        break;\n                    }\n                }\n                if (isOK) {\n                    x[i]++;\n                }\n            }\n        }\n        return x;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                long[] bk3 = new long[4];\n                Arrays.fill(bk3, -1);\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    bk3[q] = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      --count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                for (int q = 0; q < 4; ++q)\n                  if (bk3[q] != -1)\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3[q]);\n                      ++count[idx];\n                      bk3[q] = rotater(bk3[q]);\n                    }\n                rmask = rotater(rmask);\n              }\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                ++count[idx];\n                bk2 = rotater(bk2);\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          ++count[idx];\n          bk1 = rotater(bk1);\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b1 = rand.nextInt((int) p - 1) + 1;\n\t\tlong a2 = rand.nextInt((int) p - 1) + 1;\n\t\tlong b2 = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 16;\n\t\tint cnt = 0;\n\t\tPair[] array;\n\t\tint[] flag;// 0 : unused,1:used,2:deleted\n\n\t\tpublic HashMap() {\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\treturn array[id].value;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 0)\n\t\t\t\t\treturn false;\n\t\t\t\tif (flag[id] == 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1 && array[id].key == key) {\n\t\t\t\t\tarray[id] = null;\n\t\t\t\t\tflag[id] = 2;\n\t\t\t\t\tif (sz >= 8 * cnt) {\n\t\t\t\t\t\tchangeSize(sz / 2);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 1 || flag[id] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\n\t\t}\n\n\t\tboolean put(long key, long value) {\n\n\t\t\tint id = -1;\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tid = id(key, i);\n\t\t\t\tif (flag[id] == 1) {\n\t\t\t\t\tif (array[id].key == key) {\n\t\t\t\t\t\tarray[id].value = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag[id] == 0 || flag[id] == 2) {\n\t\t\t\t\tarray[id] = new Pair(key, value);\n\t\t\t\t\tflag[id] = 1;\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif (2 * cnt == sz) {\n\t\t\t\t\t\tchangeSize(2 * sz);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tint hash1(long v) {\n\t\t\treturn (int) ((a1 * v % p + b1) % p % sz);\n\t\t}\n\n\t\tint hash2(long v) {\n\t\t\treturn (int) ((a2 * v % p + b2) % p % sz);\n\t\t}\n\n\t\tint id(long v, int i) {\n\t\t\treturn (hash1(v) + i * (2 * hash2(v) + 1)) % sz;\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tPair[] tmp = new Pair[sz];\n\t\t\tint[] tmpFlag = new int[sz];\n\t\t\tfor (int i = 0; i < array.length; ++i) {\n\t\t\t\ttmp[i] = array[i];\n\t\t\t\ttmpFlag[i] = flag[i];\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tarray = new Pair[sz];\n\t\t\tflag = new int[sz];\n\t\t\tcnt = 0;\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tif (tmpFlag[i] == 1) {\n\t\t\t\t\tput(tmp[i].key, tmp[i].value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            Rect[] rects = new Rect[n];\n            List<Long> summary = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                rects[i] = new Rect();\n                for (int j = 0; j < 4; j++) {\n                    rects[i].colors[j] = in.readInt();\n                }\n                long s = summaryOf(rects[i]);\n                for (int j = 0; j < 4; j++) {\n                    summary.add(s);\n                    s = rotate(s);\n                }\n            }\n\n            LongDiscreteMap dm = new LongDiscreteMap(summary.stream().mapToLong(Long::longValue).toArray(), 0,\n                            summary.size());\n\n            int[][] rotations = new int[dm.maxRank() + 1][4];\n            for (int i = 0; i < rotations.length; i++) {\n                long val = dm.iThElement(i);\n                for (int j = 0; j < 4; j++) {\n                    rotations[i][j] = dm.rankOf(val);\n                    val = rotate(val);\n                }\n            }\n\n            int[] cnts = new int[dm.maxRank() + 1];\n            for (Rect rect : rects) {\n                rect.summary = dm.rankOf(summaryOf(rect));\n                for (int s : rotations[rect.summary]) {\n                    cnts[s] += 1;\n                }\n            }\n\n            int[] cols = new int[8];\n            int[] faces = new int[4];\n\n            long cnt = 0;\n            for (int i = 0; i < n; i++) {\n                for (int s : rotations[rects[i].summary]) {\n                    cnts[s] -= 1;\n                }\n                cols[3] = rects[i].get(0, 0);\n                cols[1] = rects[i].get(1, 0);\n                cols[0] = rects[i].get(2, 0);\n                cols[2] = rects[i].get(3, 0);\n\n                for (int j = i + 1; j < n; j++) {\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] -= 1;\n                    }\n\n                    for (int rj = 0; rj < 4; rj++) {\n\n                        cols[5] = rects[j].get(0, rj);\n                        cols[7] = rects[j].get(1, rj);\n                        cols[6] = rects[j].get(2, rj);\n                        cols[4] = rects[j].get(3, rj);\n\n\n                        faces[0] = dm.rankOf(summaryOf(cols[3], cols[7], cols[5], cols[1]));\n                        faces[1] = dm.rankOf(summaryOf(cols[1], cols[5], cols[4], cols[0]));\n                        faces[2] = dm.rankOf(summaryOf(cols[6], cols[2], cols[0], cols[4]));\n                        faces[3] = dm.rankOf(summaryOf(cols[7], cols[3], cols[2], cols[6]));\n\n                        if (faces[0] >= 0 && faces[1] >= 0 && faces[2] >= 0 && faces[3] >= 0) {\n                            long localCnt = 1;\n                            for (int t = 0; t < 4; t++) {\n                                localCnt *= cnts[faces[t]];\n                                for (int r : rotations[faces[t]]) {\n                                    cnts[r]--;\n                                }\n                            }\n                            cnt += localCnt;\n                            for (int t = 0; t < 4; t++) {\n                                for (int r : rotations[faces[t]]) {\n                                    cnts[r]++;\n                                }\n                            }\n                        }\n\n                    }\n\n\n                    for (int s : rotations[rects[j].summary]) {\n                        cnts[s] += 1;\n                    }\n                }\n            }\n\n\n\n            out.println(cnt);\n        }\n\n        public long summaryOf(Rect rect) {\n            return summaryOf(rect.colors[0], rect.colors[1], rect.colors[2], rect.colors[3]);\n        }\n\n        public long summaryOf(int a, int b, int c, int d) {\n            long ans = a;\n            ans = ans * 1000 + b;\n            ans = ans * 1000 + c;\n            ans = ans * 1000 + d;\n            return ans;\n        }\n\n        public long rotate(long x) {\n            return (x % 1000) * 1_000_000_000 + x / 1000;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Rect {\n        int[] colors = new int[4];\n        int summary;\n\n        public int get(int i, int r) {\n            return colors[(i + r) & 3];\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class LongDiscreteMap {\n        long[] val;\n        int f;\n        int t;\n\n        public LongDiscreteMap(long[] val, int f, int t) {\n            Randomized.randomizedArray(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(long x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public long iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][4];\n\t\t\tlong[] hash = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t\thash[i] = calcHashes(col[i])[0];\n\t\t\t}\n\t\t\t{\n\t\t\t\tInteger[] p = new Integer[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tp[i] = i;\n\t\t\t\t}\n\t\t\t\tfinal long[] hh = hash;\n\t\t\t\tArrays.sort(p, (a, b) -> (hh[a] < hh[b] ? -1 : (hh[a] > hh[b] ? 1 : 0)));\n\t\t\t\tint[][] ncol = new int[n][];\n\t\t\t\tlong[] nhash = new long[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tncol[p[i]] = col[i];\n\t\t\t\t\tnhash[p[i]] = hash[i];\n\t\t\t\t}\n\t\t\t\tcol = ncol;\n\t\t\t\thash = nhash;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tlong[] dp = new long[1 << 4];\n\t\t\tlong[] ways = new long[1 << 4];\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tint a = col[front][0];\n\t\t\t\tint b = col[front][1];\n\t\t\t\tint c = col[front][2];\n\t\t\t\tint d = col[front][3];\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint f = col[back][(rotBack + 0) % 4];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1) % 4];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2) % 4];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3) % 4];\n\t\t\t\t\t\tlong[] h1 = calcHashes(a, e, f, b);\n\t\t\t\t\t\tlong[] h2 = calcHashes(b, f, g, c);\n\t\t\t\t\t\tlong[] h3 = calcHashes(d, c, g, h);\n\t\t\t\t\t\tlong[] h4 = calcHashes(e, a, d, h);\n\t\t\t\t\t\tlong[][] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tArrays.fill(dp, 0);\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tSet<Long> interesting = new HashSet<>();\n\t\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\tinteresting.add(hs[i][rot]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = front + 1; i < n; ) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint j = i;\n\t\t\t\t\t\t\tint k = 0;\n\t\t\t\t\t\t\twhile (j < n && hash[i] == hash[j]) {\n\t\t\t\t\t\t\t\tif (j != back) {\n\t\t\t\t\t\t\t\t\t++k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!interesting.contains(hash[i])) {\n\t\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\t\tways[0] = 1;\n\t\t\t\t\t\t\tfor (int mask = 1; mask < 1 << 4; mask++) {\n\t\t\t\t\t\t\t\tint bit = Integer.numberOfTrailingZeros(mask);\n\t\t\t\t\t\t\t\tlong w = 0;\n\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tif (hs[bit][rot] == hash[i]) {\n\t\t\t\t\t\t\t\t\t\t++w;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tways[mask] = w * ways[mask ^ (1 << bit)];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlong[] ndp = new long[1 << 4];\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int omask = 15; omask >= 0; omask--) {\n\t\t\t\t\t\t\t\t\tif ((mask & omask) > 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tint bc = Integer.bitCount(omask);\n\t\t\t\t\t\t\t\t\tif (bc > k) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tndp[mask | omask] += dp[mask] * ways[omask] * f(k, bc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp = ndp;\n\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long f(int n, int k) {\n\t\t\tlong res = 1;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tres *= n - i;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate long[] calcHashes(int... a) {\n\t\t\tlong[] h = new long[4];\n\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\th[rot] = 1000 * h[rot] + a[(rot + i) % 4];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n \npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        Deque<Integer> queue1 = new ArrayDeque<Integer>();\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          queue1.add(idx);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              Deque<Integer> queue2 = new ArrayDeque<Integer>();\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                queue2.add(idx);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                Deque<Integer> queue3 = new ArrayDeque<Integer>();\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3);\n                      queue3.add(idx);\n                      --count[idx];\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  int idx = queue3.poll();\n                  ++count[idx];\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                int idx = queue2.poll();\n                ++count[idx];\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          int idx = queue1.poll();\n          ++count[idx];\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n \n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n \n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n \n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n \n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc062;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\n/**\n * Created by hama_du on 2016/10/19.\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        debug(code(new int[]{0,1,1,0}), code(new int[]{1,1,0,0}));\n\n        int n = in.nextInt();\n        int[][] panels = in.nextIntTable(n, 4);\n\n        long[] panelCodes = new long[n];\n        for (int i = 0; i < n ; i++) {\n            panelCodes[i] = code(panels[i]);\n        }\n\n        long ans = 0;\n\n        long[] sideCodes = new long[n];\n        for (int top = 0 ; top < n ; top++) {\n            for (int bottom = top+1 ; bottom < n ; bottom++) {\n                int sidx = 0;\n                for (int i = top+1 ; i < n ; i++) {\n                    if (i == bottom) {\n                        continue;\n                    }\n                    sideCodes[sidx++] = panelCodes[i];\n                }\n\n                for (int d = 0 ; d < 4 ; d++) {\n                    int[][] men = new int[][]{\n                            { panels[top][1], panels[top][0], panels[bottom][(d+3)%4], panels[bottom][(d+2)%4] },\n                            { panels[top][2], panels[top][1], panels[bottom][(d+2)%4], panels[bottom][(d+1)%4] },\n                            { panels[top][3], panels[top][2], panels[bottom][(d+1)%4], panels[bottom][(d+0)%4] },\n                            { panels[top][0], panels[top][3], panels[bottom][(d+0)%4], panels[bottom][(d+3)%4] }\n                    };\n                    ans += solve(men, sideCodes, sidx);\n                }\n            }\n        }\n\n        out.println(ans);\n        out.flush();\n    }\n\n    private static long same(int[] men) {\n        if (men[0] == men[1] && men[1] == men[2] && men[2] == men[3]) {\n            return 4;\n        }\n        if (men[0] == men[2] && men[1] == men[3]) {\n            return 2;\n        }\n        return 1;\n    }\n\n    private static long code(int[] men) {\n        int[] minOrd = men.clone();\n        for (int i = 1 ; i < 4; i++) {\n            int[] ord = new int[4];\n            for (int j = 0; j < 4 ; j++) {\n                ord[j] = men[(j+i)%4];\n            }\n            for (int j = 0; j < 4 ; j++) {\n                if (minOrd[j] > ord[j]) {\n                    minOrd = ord;\n                    break;\n                } else if (ord[j] > minOrd[j]) {\n                    break;\n                }\n            }\n        }\n\n        long wo = 0;\n        for (int i = 0; i < 4; i++) {\n            wo |= ((long) minOrd[i]) << (10L * i);\n        }\n        return wo;\n    }\n\n    private static long solve(int[][] men, long[] codes, int n) {\n        long[] menCodes = new long[4];\n        for (int i = 0; i < 4 ; i++) {\n            menCodes[i] = code(men[i]);\n        }\n        long[] menCounts = new long[4];\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < 4 ; j++) {\n                if (menCodes[j] == codes[i]) {\n                    menCounts[j]++;\n                }\n            }\n        }\n\n        Map<Long,Long> dec = new HashMap<>();\n        long ret = 1;\n        for (int i = 0 ; i < 4 ; i++) {\n            long A = same(men[i]);\n            ret *= A * menCounts[i] - A * dec.getOrDefault(menCodes[i], 0L);\n            dec.put(menCodes[i], dec.getOrDefault(menCodes[i], 0L) + 1);\n        }\n        if (ret < 0) {\n            return 0;\n        }\n        return ret;\n    }\n\n    private static int[] match(int[][] men, int[] panel) {\n        int[] x = new int[4];\n        for (int i = 0; i < 4 ; i++) {\n            for (int d = 0 ; d < 4 ; d++) {\n                boolean isOK = true;\n                for (int e = 0 ; e < 4 ; e++){\n                    if (men[i][e] != panel[(d+e)%4]) {\n                        isOK = false;\n                        break;\n                    }\n                }\n                if (isOK) {\n                    x[i]++;\n                }\n            }\n        }\n        return x;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tclass HashMap {\n\t\tclass Pair {\n\t\t\tlong key;\n\t\t\tlong value;\n\n\t\t\tpublic Pair(long key_, long value_) {\n\t\t\t\tkey = key_;\n\t\t\t\tvalue = value_;\n\t\t\t}\n\t\t}\n\n\t\tRandom rand = new Random();\n\t\tlong p = (long) 1e6 + 7;\n\t\tlong a = rand.nextInt((int) p - 1) + 1;\n\t\tlong b = rand.nextInt((int) p - 1) + 1;\n\t\tint sz = 16;\n\t\tint cnt = 0;\n\t\tLinkedList<Pair>[] list;\n\n\t\tpublic HashMap() {\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t}\n\n\t\tpublic HashMap(int sz_) {\n\t\t\tsz = sz_;\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t}\n\n\t\tboolean delete(long key) {\n\t\t\tint id = hash(key);\n\t\t\tboolean ret = list[id].remove(key);\n\t\t\tif (sz >= 3 * cnt) {\n\t\t\t\tchangeSize(sz / 2);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid put(long key, long value) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key == key) {\n\t\t\t\t\tlist[id].get(i).value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist[id].add(new Pair(key, value));\n\t\t\t++cnt;\n\n\t\t\tif (cnt > sz) {\n\t\t\t\tchangeSize(2 * sz);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong get(long key) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key == key) {\n\t\t\t\t\treturn list[id].get(i).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean containsKey(long key) {\n\t\t\tint id = hash(key);\n\t\t\tfor (int i = 0; i < list[id].size(); ++i) {\n\t\t\t\tif (list[id].get(i).key != key) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tint hash(long v) {\n\t\t\treturn (int) ((a * v % p + b) % p % sz);\n\t\t}\n\n\t\tvoid changeSize(int sz_) {\n\t\t\tLinkedList<Pair>[] tmp = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\ttmp[i] = new LinkedList<>();\n\t\t\t\ttmp[i].addAll(list[i]);\n\t\t\t}\n\t\t\tsz = sz_;\n\t\t\tlist = new LinkedList[sz];\n\t\t\tfor (int i = 0; i < list.length; ++i) {\n\t\t\t\tlist[i] = new LinkedList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < tmp.length; ++i) {\n\t\t\t\tfor (Pair p : tmp[i]) {\n\t\t\t\t\tput(p.key, p.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\t// HashMap<Long, Integer> map = new HashMap<>();\n\t\tHashMap map = new HashMap();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\t// HashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tHashMap pending = new HashMap();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] cs = new int[n][];\n\t\tlong[] chs = new long[n];\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcs[i] = na(4);\n\t\t\tchs[i] = h(cs[i]);\n\t\t}\n\t\tLongHashCounter lhc = new LongHashCounter();\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t// 01\n\t\t\t\t// 32\n\t\t\t\t// 10\n\t\t\t\t// 23\n\t\t\t\tinner:\n\t\t\t\tfor(int d = 0;d < 4;d++){\n\t\t\t\t\tlong[] hs = {\n\t\t\t\t\t\t\th(cs[i][1], cs[i][0], cs[j][d+1&3], cs[j][d+0&3]),\n\t\t\t\t\t\t\th(cs[i][2], cs[i][1], cs[j][d+0&3], cs[j][d+3&3]),\n\t\t\t\t\t\t\th(cs[i][3], cs[i][2], cs[j][d+3&3], cs[j][d+2&3]),\n\t\t\t\t\t\t\th(cs[i][0], cs[i][3], cs[j][d+2&3], cs[j][d+1&3])\n\t\t\t\t\t};\n\t\t\t\t\tArrays.sort(hs);\n\t\t\t\t\tlong plus = 1;\n\t\t\t\t\tfor(int k = 0;k < 4;){\n\t\t\t\t\t\tint l = k;\n\t\t\t\t\t\twhile(l < 4 && hs[k] == hs[l])l++;\n\t\t\t\t\t\tint count = lhc.get(hs[k]);\n\t\t\t\t\t\tif(hs[k] == chs[j])count--;\n\t\t\t\t\t\tif(count <= 0)continue inner;\n\t\t\t\t\t\tlong dup = 1;\n\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\ths[k] / 1000000 % 1000 == hs[k] % 1000 &&\n\t\t\t\t\t\t\t\ths[k] / 1000000000 % 1000 == hs[k] / 1000 % 1000){\n\t\t\t\t\t\t\tdup = 2;\n\t\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\t\ths[k] / 1000 % 1000 == hs[k] % 1000){\n\t\t\t\t\t\t\t\tdup = 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tlong mul = 1;\n\t\t\t\t\t\tfor(int t = 1;t <= l-k;t++){\n\t\t\t\t\t\t\tmul = mul * dup;\n\t\t\t\t\t\t\tmul = mul * (count-t+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplus = plus * mul;\n\t\t\t\t\t\t\n\t\t\t\t\t\tk = l;\n\t\t\t\t\t}\n\t\t\t\t\tret += plus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlhc.inc(chs[i], 1);\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tstatic long h(int... x)\n\t{\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tlong h = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\th = h * 1000 + x[i+j&3];\n\t\t\t}\n\t\t\tret = Math.min(ret, h);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static class LongHashCounter {\n\t\tpublic long[] keys;\n\t\tpublic int[] allocated;\n\t\tprivate int scale = 1<<2;\n\t\tprivate int rscale = 1<<1;\n\t\tprivate int mask = scale-1;\n\t\tpublic int size = 0;\n\t\t\n\t\tpublic LongHashCounter(){\n\t\t\tallocated = new int[scale];\n\t\t\tkeys = new long[scale];\n\t\t}\n\t\t\n\t\tpublic boolean containsKey(long x)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(allocated[pos] != 0){\n\t\t\t\tif(x == keys[pos])return true;\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tpublic int get(long x)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(allocated[pos] != 0){\n\t\t\t\tif(x == keys[pos])return allocated[pos];\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic int inc(long x, int v)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(allocated[pos] != 0){\n\t\t\t\tif(x == keys[pos]){\n\t\t\t\t\tallocated[pos] += v;\n\t\t\t\t\treturn allocated[pos];\n\t\t\t\t}\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\tif(size == rscale){\n\t\t\t\tresizeAndPut(x, v);\n\t\t\t}else{\n\t\t\t\tkeys[pos] = x;\n\t\t\t\tallocated[pos] = v;\n\t\t\t}\n\t\t\tsize++;\n\t\t\treturn v;\n\t\t}\n\t\t\n\t\tpublic int put(long x, int v)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(allocated[pos] != 0){\n\t\t\t\tif(x == keys[pos]){\n\t\t\t\t\tint oldval = allocated[pos];\n\t\t\t\t\tallocated[pos] = v;\n\t\t\t\t\treturn oldval;\n\t\t\t\t}\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\tif(size == rscale){\n\t\t\t\tresizeAndPut(x, v);\n\t\t\t}else{\n\t\t\t\tkeys[pos] = x;\n\t\t\t\tallocated[pos] = v;\n\t\t\t}\n\t\t\tsize++;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic boolean remove(long x)\n\t\t{\n\t\t\tint pos = h(x)&mask;\n\t\t\twhile(allocated[pos] != 0){\n\t\t\t\tif(x == keys[pos]){\n\t\t\t\t\tsize--;\n\t\t\t\t\t// take last and fill rmpos\n\t\t\t\t\tint last = pos;\n\t\t\t\t\tpos = pos+1&mask;\n\t\t\t\t\twhile(allocated[pos] != 0){\n\t\t\t\t\t\tint lh = h(keys[pos])&mask;\n\t\t\t\t\t\t// lh <= last < pos\n\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\tlh <= last && last < pos ||\n\t\t\t\t\t\t\t\tpos < lh && lh <= last ||\n\t\t\t\t\t\t\t\tlast < pos && pos < lh\n\t\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\tkeys[last] = keys[pos];\n\t\t\t\t\t\t\tallocated[last] = allocated[pos];\n\t\t\t\t\t\t\tlast = pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos+1&mask;\n\t\t\t\t\t}\n\t\t\t\t\tkeys[last] = 0;\n\t\t\t\t\tallocated[last] = 0;\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpos = pos+1&mask;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tprivate void resizeAndPut(long x, int v)\n\t\t{\n\t\t\tint nscale = scale<<1;\n\t\t\tint nrscale = rscale<<1;\n\t\t\tint nmask = nscale-1;\n\t\t\tint[] nallocated = new int[nscale];\n\t\t\tlong[] nkeys = new long[nscale];\n\t\t\tfor(int i = next(0);i < scale;i = next(i+1)){\n\t\t\t\tlong y = keys[i];\n\t\t\t\tint pos = h(y)&nmask;\n\t\t\t\twhile(nallocated[pos] != 0)pos = pos+1&nmask;\n\t\t\t\tnkeys[pos] = y;\n\t\t\t\tnallocated[pos] = allocated[i];\n\t\t\t}\n\t\t\t{\n\t\t\t\tint pos = h(x)&nmask;\n\t\t\t\twhile(nallocated[pos] != 0)pos = pos+1&nmask;\n\t\t\t\tnkeys[pos] = x;\n\t\t\t\tnallocated[pos] = v;\n\t\t\t}\n\t\t\tallocated = nallocated;\n\t\t\tkeys = nkeys;\n\t\t\tscale = nscale;\n\t\t\trscale = nrscale;\n\t\t\tmask = nmask;\n\t\t}\n\t\t\n\t\tpublic int next(int itr)\n\t\t{\n\t\t\twhile(itr < scale && allocated[itr] == 0)itr++;\n\t\t\treturn itr;\n\t\t}\n\t\t\n\t\tprivate int h(long x)\n\t\t{\n\t\t\tx ^= x>>>33;\n\t\t\tx *= 0xff51afd7ed558ccdL;\n\t\t\tx ^= x>>>33;\n\t\t\tx *= 0xc4ceb9fe1a85ec53L;\n\t\t\tx ^= x>>>33;\n\t\t\treturn (int)x;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i = next(0);i < scale;i = next(i+1)){\n\t\t\t\tsb.append(\",\");\n\t\t\t\tsb.append(keys[i] + \":\" + allocated[i]);\n\t\t\t}\n\t\t\treturn sb.length() == 0 ? \"\" : sb.substring(1);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 400, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n*4; i++) {\n//\t\t\tsb.append(999 + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemC solver = new ProblemC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemC {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[][] col = new int[n][8];\n\t\t\tlong[][] hash = new long[n][4];\n\t\t\tSet<Long> any = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tcol[i][j] = in.nextInt();\n\t\t\t\t\tcol[i][j + 4] = col[i][j];\n\t\t\t\t}\n\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\thash[i][rot] = 1000 * hash[i][rot] + col[i][(rot + j) % 4];\n\t\t\t\t\t}\n\t\t\t\t\tany.add(hash[i][rot]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tlong[] dp = new long[1 << 4];\n\t\t\tint[] ways = new int[4];\n\t\t\tfor (int front = 0; front < n; front++) {\n\t\t\t\tint a = col[front][0];\n\t\t\t\tint b = col[front][1];\n\t\t\t\tint c = col[front][2];\n\t\t\t\tint d = col[front][3];\n\t\t\t\tfor (int back = front + 1; back < n; back++) {\n\t\t\t\t\trotLoop:\n\t\t\t\t\tfor (int rotBack = 0; rotBack < 4; rotBack++) {\n\t\t\t\t\t\tint f = col[back][(rotBack + 0)];\n\t\t\t\t\t\tint e = col[back][(rotBack + 1)];\n\t\t\t\t\t\tint h = col[back][(rotBack + 2)];\n\t\t\t\t\t\tint g = col[back][(rotBack + 3)];\n\t\t\t\t\t\tlong h1 = calcHash(a, e, f, b);\n\t\t\t\t\t\tlong h2 = calcHash(b, f, g, c);\n\t\t\t\t\t\tlong h3 = calcHash(d, c, g, h);\n\t\t\t\t\t\tlong h4 = calcHash(e, a, d, h);\n\t\t\t\t\t\tlong[] hs = {h1, h2, h3, h4};\n\t\t\t\t\t\tfor (long hh : hs) {\n\t\t\t\t\t\t\tif (!any.contains(hh)) {\n\t\t\t\t\t\t\t\tcontinue rotLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrays.fill(dp, 0);\n\t\t\t\t\t\tdp[0] = 1;\n\t\t\t\t\t\tfor (int i = front + 1; i < n; i++) {\n\t\t\t\t\t\t\tif (i == back) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tArrays.fill(ways, 0);\n\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\tfor (int rot = 0; rot < 4; rot++) {\n\t\t\t\t\t\t\t\t\tif (hash[i][rot] == hs[bit]) {\n\t\t\t\t\t\t\t\t\t\t++ways[bit];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int mask = 15; mask >= 0; mask--) {\n\t\t\t\t\t\t\t\tif (dp[mask] == 0) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int bit = 0; bit < 4; bit++) {\n\t\t\t\t\t\t\t\t\tif ((mask & (1 << bit)) != 0) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdp[mask | (1 << bit)] += dp[mask] * ways[bit];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += dp[15];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calcHash(int a, int b, int c, int d) {\n\t\t\tlong h = 0;\n\t\t\th = 1000 * h + a;\n\t\t\th = 1000 * h + b;\n\t\t\th = 1000 * h + c;\n\t\t\th = 1000 * h + d;\n\t\t\treturn h;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/C2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tlong XXX = 10000;\n\tlong toKey(int[] c) {\n\t\tlong key = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tlong curKey = 0;\n\t\t\tfor (int j = 0; j < 4; j++) curKey = curKey * XXX + c[(i+j)%4];\n\t\t\tif (key > curKey) key = curKey;\n\t\t}\n\t\treturn key;\n\t}\n\t\n\tHashMap<Long, Long> hash = new HashMap<>();\n\tvoid add(long key) {\n\t\tif (hash.containsKey(key))\n\t\t\thash.put(key, hash.get(key) + 1);\n\t\telse\n\t\t\thash.put(key, 1L);\n\t}\n\t\n\tint comb(long key) {\n\t\tlong[] vals = new long[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tvals[i] = key % XXX;\n\t\t\tkey /= XXX;\n\t\t}\n\t\tif (vals[0] == vals[1] && vals[1] == vals[2] && vals[2] == vals[3])\n\t\t\treturn 4;\n\t\telse if (vals[0] == vals[2] && vals[1] == vals[3])\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\t\n\tlong get(long key) {\n\t\tif (!hash.containsKey(key)) return 0;\n\t\treturn hash.get(key);\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tint[][] C = new int[N][4];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tC[i][j] = in.nextInt();\n\t\t\t}\n\t\t\tlong key = toKey(C[i]);\n\t\t\tadd(key);\n\t\t\tSystem.out.println(Arrays.toString(C[i]) + \" \" + key);\n\t\t}\n\t\t\n\t\tlong res = 0;\n\t\tfor (int c1 = 0; c1 < N; c1++) {\n\t\t\tfor (int c2 = c1 + 1; c2 < N; c2++) {\n\t\t\t\tint x1 = C[c1][0], x2 = C[c1][1], x3 = C[c1][2], x4 = C[c1][3];\n\t\t\t\tint y1 = C[c2][1], y2 = C[c2][0], y3 = C[c2][3], y4 = C[c2][2];\n\t\t\t\tlong xkey = toKey(new int[]{x1, x2, x3, x4});\n\t\t\t\tlong ykey = toKey(new int[]{y1, y2, y3, y4});\n\t\t\t\tfor (int rotate = 0; rotate < 4; rotate++) {\n\t\t\t\t\tlong upKey     = toKey(new int[]{y1, y2, x2, x1});\n\t\t\t\t\tlong bottomKey = toKey(new int[]{y3, y4, x4, x3});\n\t\t\t\t\tlong rightKey  = toKey(new int[]{x3, x2, y2, y3});\n\t\t\t\t\tlong leftKey   = toKey(new int[]{x1, x4, y4, y1}); \n\t\t\t\t\t\n\t\t\t\t\tlong ucnt = get(upKey) * comb(upKey);\n\t\t\t\t\tlong bcnt = get(bottomKey) * comb(bottomKey);\n\t\t\t\t\tlong rcnt = get(rightKey) * comb(rightKey);\n\t\t\t\t\tlong lcnt = get(leftKey) * comb(leftKey);\n\t\t\t\t\t\n\t\t\t\t\tlong[] keys = {upKey, bottomKey, rightKey, leftKey};\n\t\t\t\t\tlong[] cnts = {ucnt, bcnt, rcnt, lcnt};\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif (xkey == keys[i]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tif (ykey == keys[i]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t\tfor (int j = i + 1; j < 4; j++)\n\t\t\t\t\t\t\tif (keys[i] == keys[j]) cnts[i] -= comb(keys[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong val = 1;\n\t\t\t\t\tfor (long c : cnts) val *= c; \n\t\t\t\t\tres += val;\n\t\t\t\t\t\n\t\t\t\t\tint ytmp = y1;\n\t\t\t\t\ty1 = y2;\n\t\t\t\t\ty2 = y3;\n\t\t\t\t\ty3 = y4;\n\t\t\t\t\ty4 = ytmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res/3);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    private Map<Long, Integer> keyDups;\n\n    private void solve(FastScanner sc) {\n        int n = sc.nextInt();\n        long[] keys = new long[n];\n        Map<Long, int[][]> rotates = new HashMap<>();\n        keyDups = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            long key = toKey(a, b, c, d);\n            keys[i] = key;\n            rotates.putIfAbsent(key, toRotates(a, b, c, d));\n            keyDups.computeIfAbsent(key, l -> 0);\n            keyDups.compute(key, (l, old) -> old + 1);\n        }\n        long count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int[] foot = rotates.get(keys[i])[0];\n                for (int[] head : rotates.get(keys[j])) {\n                    long ka = toKey(head[1], head[0], foot[1], foot[0]);\n                    long kb = toKey(head[2], head[1], foot[0], foot[3]);\n                    long kc = toKey(head[3], head[2], foot[3], foot[2]);\n                    long kd = toKey(head[0], head[3], foot[2], foot[1]);\n                    long kh = toKey(head[0], head[1], head[2], head[3]);\n                    long kf = toKey(foot[0], foot[1], foot[2], foot[3]);\n                    keyDups.compute(kh, (l, old) -> old - 1);\n                    keyDups.compute(kf, (l, old) -> old - 1);\n                    long a = match(head[1], head[0], foot[1], foot[0]);\n                    keyDups.computeIfPresent(ka, (l, old) -> old - 1);\n                    long b = match(head[2], head[1], foot[0], foot[3]);\n                    keyDups.computeIfPresent(kb, (l, old) -> old - 1);\n                    long c = match(head[3], head[2], foot[3], foot[2]);\n                    keyDups.computeIfPresent(kc, (l, old) -> old - 1);\n                    long d = match(head[0], head[3], foot[2], foot[1]);\n                    keyDups.compute(kh, (l, old) -> old + 1);\n                    keyDups.compute(kf, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(ka, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(kb, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(kc, (l, old) -> old + 1);\n                    count += a * b * c * d;\n                }\n            }\n        }\n        System.out.println(count/6);\n    }\n\n    private int match(int a, int b, int c, int d) {\n        long key = toKey(a, b, c, d);\n        int m = a == c && b == d ? (a == b ? 4 : 2) : 1;\n        return keyDups.containsKey(key) ? keyDups.get(key) * m : 0;\n    }\n\n    private int[][] toRotates(int a, int b, int c, int d) {\n        int[][] rs = new int[4][];\n        rs[0] = new int[]{a, b, c, d};\n        rs[1] = new int[]{b, c, d, a};\n        rs[2] = new int[]{c, d, a, b};\n        rs[3] = new int[]{d, a, b, c};\n        return rs;\n    }\n\n    private long toKey(int a, int b, int c, int d) {\n        return Math.min(Math.min(\n                a * 1000000000L + b * 1000000L + c * 1000 + d,\n                b * 1000000000L + c * 1000000L + d * 1000 + a), Math.min(\n                c * 1000000000L + d * 1000000L + a * 1000 + b,\n                d * 1000000000L + a * 1000000L + b * 1000 + c));\n    }\n\n    /*\n     * template\n     */\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        new Main().solve(sc);\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int bufLen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < bufLen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    bufLen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (bufLen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    private Map<Long, Integer> keyDups;\n\n    private void solve(FastScanner sc) {\n        int n = sc.nextInt();\n        long[] keys = new long[n];\n        Map<Long, int[][]> rotates = new HashMap<>();\n        keyDups = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int d = sc.nextInt();\n            long key = toKey(a, b, c, d);\n            keys[i] = key;\n            rotates.putIfAbsent(key, toRotates(a, b, c, d));\n            keyDups.computeIfAbsent(key, l -> 0);\n            keyDups.compute(key, (l, old) -> old + 1);\n        }\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int[] foot = rotates.get(keys[i])[0];\n                for (int[] head : rotates.get(keys[j])) {\n                    long ka = toKey(head[1], head[0], foot[1], foot[0]);\n                    long kb = toKey(head[2], head[1], foot[0], foot[3]);\n                    long kc = toKey(head[3], head[2], foot[3], foot[2]);\n                    long kd = toKey(head[0], head[3], foot[2], foot[1]);\n                    long kh = toKey(head[0], head[1], head[2], head[3]);\n                    long kf = toKey(foot[0], foot[1], foot[2], foot[3]);\n                    keyDups.compute(kh, (l, old) -> old - 1);\n                    keyDups.compute(kf, (l, old) -> old - 1);\n                    int a = match(head[1], head[0], foot[1], foot[0]);\n                    keyDups.computeIfPresent(ka, (l, old) -> old - 1);\n                    int b = match(head[2], head[1], foot[0], foot[3]);\n                    keyDups.computeIfPresent(kb, (l, old) -> old - 1);\n                    int c = match(head[3], head[2], foot[3], foot[2]);\n                    keyDups.computeIfPresent(kc, (l, old) -> old - 1);\n                    int d = match(head[0], head[3], foot[2], foot[1]);\n                    keyDups.compute(kh, (l, old) -> old + 1);\n                    keyDups.compute(kf, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(ka, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(kb, (l, old) -> old + 1);\n                    keyDups.computeIfPresent(kc, (l, old) -> old + 1);\n                    count += a * b * c * d;\n                }\n            }\n        }\n        System.out.println(count/6);\n    }\n\n    private int match(int a, int b, int c, int d) {\n        long key = toKey(a, b, c, d);\n        int m = a == c && b == d ? (a == b ? 4 : 2) : 1;\n        return keyDups.containsKey(key) ? keyDups.get(key) * m : 0;\n    }\n\n    private int[][] toRotates(int a, int b, int c, int d) {\n        int[][] rs = new int[4][];\n        rs[0] = new int[]{a, b, c, d};\n        rs[1] = new int[]{b, c, d, a};\n        rs[2] = new int[]{c, d, a, b};\n        rs[3] = new int[]{d, a, b, c};\n        return rs;\n    }\n\n    private long toKey(int a, int b, int c, int d) {\n        return Math.min(Math.min(\n                a * 1000000000L + b * 1000000L + c * 1000 + d,\n                b * 1000000000L + c * 1000000L + d * 1000 + a), Math.min(\n                c * 1000000000L + d * 1000000L + a * 1000 + b,\n                d * 1000000000L + a * 1000000L + b * 1000 + c));\n    }\n\n    /*\n     * template\n     */\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        new Main().solve(sc);\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int bufLen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < bufLen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    bufLen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (bufLen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  private static int N;\n  private static int count = 0;\n  private static int[][] C;\n\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    N = sc.nextInt();\n    C = sc.nextIntTable(N, 4);\n\n    Map<Long, Integer> map = new HashMap<>();\n    Map<Long, Long> rot = new HashMap<>();\n    long[] hash = new long[N];\n    for (int i = 0; i < N; i++) {\n      long h = hash(C[i][0], C[i][1], C[i][2], C[i][3]);\n      if (!map.containsKey(h)) {\n        map.put(h, 0);\n      }\n      map.put(h, map.get(h) + 1);\n      rot.put(h, rot(C[i]));\n      hash[i] = h;\n    }\n\n    int[][] idx = {{0, 4, 7, 1}, {1, 7, 6, 2}, {3, 2, 6, 5}, {0, 3, 5, 4}};\n\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        if (i == j) continue;\n\n        loop: for (int k = 0; k < 4; k++) {\n          Map<Long, Integer> tmp = new HashMap<>();\n          for (Map.Entry<Long, Integer> entry : map.entrySet()) {\n            int value = entry.getValue();\n            long key = entry.getKey();\n            if (key == hash[i])\n              value--;\n            if (key == hash[j])\n              value--;\n            tmp.put(entry.getKey(), value);\n          }\n\n          int[] c = {C[i][0], C[i][1], C[i][2], C[i][3], C[j][(0 + k) % 4], C[j][(1 + k) % 4],\n              C[j][(2 + k) % 4], C[j][(3 + k) % 4]};\n\n\n          long nc = 1;\n          for (int[] v : idx) {\n            long h = hash(c[v[0]], c[v[1]], c[v[2]], c[v[3]]);\n            if (!tmp.containsKey(h) || tmp.get(h) == 0) {\n              continue loop;\n            }\n            nc *= tmp.get(h) * rot.get(h);\n            tmp.put(h, tmp.get(h) - 1);\n          }\n\n\n          count += nc;\n        }\n      }\n    }\n    System.out.println(count / 6);\n  }\n\n  private static long rot(int... C) {\n    int ret = 0;\n    for (int i = 0; i < 4; i++) {\n      if (C[0] == C[(i + 0) % 4] && C[1] == C[(i + 1) % 4] && C[2] == C[(i + 2) % 4]\n          && C[3] == C[(i + 3) % 4]) {\n        ret ++;\n      }\n    }\n    return ret;\n  }\n\n  private static long hash(int... C) {\n    long min = Long.MAX_VALUE;\n\n    for (int k = 0; k < 4; k++) {\n      long ret = 0;\n      for (int i = 0; i < 4; i++) {\n        ret *= 1000;\n        ret += C[(i + k) % 4];\n      }\n      min = Math.min(min, ret);\n    }\n    return min;\n  }\n}\n\n\n\nclass FastScanner {\n  public static String debug = null;\n\n  private final InputStream in = System.in;\n  private int ptr = 0;\n  private int buflen = 0;\n  private byte[] buffer = new byte[1024];\n  private boolean eos = false;\n\n  private boolean hasNextByte() {\n    if (ptr < buflen) {\n      return true;\n    } else {\n      ptr = 0;\n      try {\n        if (debug != null) {\n          buflen = debug.length();\n          buffer = debug.getBytes();\n          debug = \"\";\n          eos = true;\n        } else {\n          buflen = in.read(buffer);\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      if (buflen < 0) {\n        eos = true;\n        return false;\n      } else if (buflen == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private int readByte() {\n    if (hasNextByte())\n      return buffer[ptr++];\n    else\n      return -1;\n  }\n\n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n      ptr++;\n  }\n\n  public boolean isEOS() {\n    return this.eos;\n  }\n\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n\n  public String next() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    int b = readByte();\n    while (isPrintableChar(b)) {\n      sb.appendCodePoint(b);\n      b = readByte();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() {\n    if (!hasNext())\n      throw new NoSuchElementException();\n    long n = 0;\n    boolean minus = false;\n    int b = readByte();\n    if (b == '-') {\n      minus = true;\n      b = readByte();\n    }\n    if (b < '0' || '9' < b) {\n      throw new NumberFormatException();\n    }\n    while (true) {\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n      b = readByte();\n    }\n  }\n\n  public int nextInt() {\n    return (int) nextLong();\n  }\n\n  public long[] nextLongList(int n) {\n    return nextLongTable(1, n)[0];\n  }\n\n  public int[] nextIntList(int n) {\n    return nextIntTable(1, n)[0];\n  }\n\n  public long[][] nextLongTable(int n, int m) {\n    long[][] ret = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextLong();\n      }\n    }\n    return ret;\n  }\n\n  public int[][] nextIntTable(int n, int m) {\n    int[][] ret = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        ret[i][j] = nextInt();\n      }\n    }\n    return ret;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\n\tlong hash(int[] cs) {\n\t\tlong ret = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tret = Math.min(ret, hash);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong rot(int[] cs) {\n\t\tint cnt = 0;\n\t\tlong originHash = hash(cs);\n\t\tfor (int i = 0; i < cs.length; ++i) {\n\t\t\tlong hash = 0;\n\t\t\tfor (int j = 0; j < cs.length; ++j) {\n\t\t\t\thash = hash * 1000 + cs[(i + j) % cs.length];\n\t\t\t}\n\t\t\tif (hash == originHash) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid solver(int n, int[][] C) {\n\t\tHashMap<Long, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (map.containsKey(hash(C[i]))) {\n\t\t\t\tmap.put(hash(C[i]), map.get(hash(C[i])) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(hash(C[i]), 1);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int rotation = 0; rotation < 4; ++rotation) {\n\t\t\t\t\tlong sum = 1;\n\t\t\t\t\tHashMap<Long, Integer> pending = new HashMap<>();\n\t\t\t\t\tpending.put(hash(C[i]), 1);\n\t\t\t\t\tpending.put(hash(C[j]), hash(C[i]) == hash(C[j]) ? 2 : 1);\n\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tint[] nc = { C[j][(-k + 1 + rotation + 4) % 4], C[j][(-k + rotation + 4) % 4],\n\t\t\t\t\t\t\t\tC[i][(k + 1) % 4], C[i][k] };\n\t\t\t\t\t\tif (!map.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pending.containsKey(hash(nc)) && map.get(hash(nc)) == pending.get(hash(nc)))\n\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\tsum *= (map.get(hash(nc)) - (!pending.containsKey(hash(nc)) ? 0 : pending.get(hash(nc))))\n\t\t\t\t\t\t\t\t* rot(nc);\n\t\t\t\t\t\tif (pending.containsKey(hash(nc))) {\n\t\t\t\t\t\t\tpending.put(hash(nc), pending.get(hash(nc)) + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending.put(hash(nc), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans / 6);\n\t}\n\n\tvoid start() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] C = new int[n][4];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tsolver(n, C);\n\t}\n\n\tpublic void run() {\n\t\tstart();\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskE solver = new TaskE();\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskE {    \n    final long ring = 9223372036854775783L;\n    int n;\n    int[][] c;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      c = new int[n][4];\n      for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 4; ++j)\n          c[i][j] = in.nextInt();\n      int ptr = 0;\n      Map<Long, Integer> table = new HashMap<Long, Integer>();\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          if (!table.containsKey(mask))\n            table.put(mask, ptr++);\n          mask = rotater(mask);\n        }\n      }\n      int[] count = new int[ptr];\n      for (int i = 0; i < n; ++i) {\n        long mask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        for (int j = 0; j < 4; ++j) {\n          ++count[table.get(mask)];\n          mask = rotater(mask);\n        }\n      }\n      long acc = 0;\n      boolean flag = false;\n      List<Long> list = new ArrayList<Long>();\n      Deque<Integer> queue1 = new ArrayDeque<Integer>();\n      Deque<Integer> queue2 = new ArrayDeque<Integer>();\n      Deque<Integer> queue3 = new ArrayDeque<Integer>();\n      for (int i = 0; i < n; ++i) {\n        long lmask = pack(c[i][3], c[i][2], c[i][1], c[i][0]);\n        long bk1 = lmask;\n        for (int j = 0; j < 4; ++j) {\n          int idx = table.get(bk1);\n          queue1.add(idx);\n          --count[idx];\n          bk1 = rotater(bk1);\n        }\n        for (int j = 0; j < 4; ++j) {\n          for (int k = 0; k < n; ++k)\n            if (k != i) {\n              long rmask = pack(c[k][3], c[k][2], c[k][1], c[k][0]);\n              long bk2 = rmask;\n              for (int p = 0; p < 4; ++p) {\n                int idx = table.get(bk2);\n                queue2.add(idx);\n                --count[idx];\n                bk2 = rotater(bk2);\n              }\n              for (int p = 0; p < 4; ++p) {\n                long prod = 1;\n                long rrmask = rmask;\n                long llmask = lmask;\n                boolean okay = true;\n                for (int q = 0; q < 4; ++q) {\n                  long mask = pack(extract(llmask, 16, 16), extract(rrmask, 0, 16), extract(rrmask, 16, 16), extract(llmask, 0, 16));\n                  if (table.containsKey(mask)) {\n                    prod *= count[table.get(mask)];\n                    long bk3 = mask;\n                    for (int r = 0; r < 4; ++r) {\n                      int idx = table.get(bk3);\n                      queue3.add(idx);\n                      --count[idx];\n                      bk3 = rotater(bk3);\n                    }\n                  } else\n                    okay = false;\n                  llmask = rotater(llmask);\n                  rrmask = rotatel(rrmask);\n                }\n                if (okay) {\n                  acc += prod;\n                  if (acc > Long.MAX_VALUE / 48 && acc % 24 == 0) {\n                    list.add(acc);\n                    acc = 0;\n                  }\n                }\n                while (!queue3.isEmpty()) {\n                  int idx = queue3.poll();\n                  ++count[idx];\n                }\n                rmask = rotater(rmask);\n              }\n              while (!queue2.isEmpty()) {\n                int idx = queue2.poll();\n                ++count[idx];\n              }\n            }\n          lmask = rotater(lmask);\n        }\n        while (!queue1.isEmpty()) {\n          int idx = queue1.poll();\n          ++count[idx];\n        }\n      }\n      long ans = 0;\n      for (long i : list)\n        ans += i / 24;\n      ans += acc / 24;\n      out.println(ans);\n    }\n    \n    long pack(long a, long b, long c, long d) {\n      return a << 48 | b << 32 | c << 16 | d;\n    }\n    \n    long extract(long a, int offset, int size) {\n      return a >>> offset & (1L << size) - 1;\n    }\n    \n    long rotater(long a) {\n      return a << 16 | a >>> 48;\n    }\n    \n    long rotatel(long a) {\n      return a >>> 16 | a << 48;\n    }    \n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var a = Enumerate(n, x => sc.Integer(4));\n            long ans = 0;\n            Func<int[], int, long> g = (c, d) =>\n             {\n                 var v = 0L;\n                 for (int i = 0; i < 4; i++) v = v * 1000 + c[(i + d) % 4];\n                 return v;\n             };\n            Func<int[], long[]> h = c =>\n                {\n                    var hash = new long[4];\n                    for (int d = 0; d < 4; d++)\n                        hash[d] = g(c, d);\n                    Array.Sort(hash);\n                    return hash;\n                };\n            var binomial = new long[n + 2, 6];\n            binomial[0, 0] = 1;\n            for (int i = 0; i <= n; i++)\n                for (int j = 0; j <= 4; j++)\n                {\n                    binomial[i + 1, j] += binomial[i, j];\n                    binomial[i + 1, j + 1] += binomial[i, j];\n                }\n            var fact = new int[5];\n            fact[0] = 1;\n            for (int i = 1; i < 5; i++)\n                fact[i] = fact[i - 1] * i;\n            var map = new HashMap<long, int>();\n            for (int i = 0; i < n; i++)\n                map[h(a[i])[0]]++;\n            var b = new long[n];\n            for (int i = 0; i < n; i++)\n                b[i] = h(a[i])[0];\n            var coef = new HashMap<long, int>();\n            foreach (var x in map)\n            {\n                var v = x.Key;\n                var c = new int[4];\n                for (int i = 3; i >= 0; i--)\n                {\n                    c[i] = (int)(v % 1000); v /= 1000;\n                }\n                for (int i = 0; i < 4; i++)\n                    coef[g(c, i)]++;\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                map[b[i]]--;\n                for (int d = 0; d < 4; d++)\n                {\n                    var x = new int[4];\n                    for (int j = 0; j < 4; j++)\n                        x[j] = a[i][(d + j) % 4];\n                    for (int j = i + 1; j < n; j++)\n                    {\n                        var y = a[j];\n                        map[b[j]]--;\n                        var c = Enumerate(4, v => new int[4]);\n                        c[0][0] = x[1];\n                        c[0][1] = x[0];\n                        c[0][2] = y[1];\n                        c[0][3] = y[0];\n                        c[1][0] = x[0];\n                        c[1][1] = x[3];\n                        c[1][2] = y[2];\n                        c[1][3] = y[1];\n                        c[2][0] = x[3];\n                        c[2][1] = x[2];\n                        c[2][2] = y[3];\n                        c[2][3] = y[2];\n                        c[3][0] = x[2];\n                        c[3][1] = x[1];\n                        c[3][2] = y[0];\n                        c[3][3] = y[3];\n\n                        var need = new HashMap<long, List<long>>();\n                        for (int k = 0; k < 4; k++)\n                            need[h(c[k])[0]].Add(g(c[k], 0));\n\n                        var add = 1L;\n                        foreach (var hash in need)\n                        {\n                            foreach (var v in hash.Value)\n                                add *= coef[v];\n                            var sum = hash.Value.Count;\n                            int cnt;\n                            if (map.TryGetValue(hash.Key, out cnt))\n                            {\n                                add *= binomial[cnt, sum] * fact[sum];\n                            }\n                            else add = 0;\n                        }\n                        ans += add;\n                        map[b[j]]++;\n                    }\n                }\n            }\n            IO.Printer.Out.WriteLine(ans);\n        }\n\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region HashMap<K,V>\npublic class HashMap<K, V>: Dictionary<K, V>\nwhere V : new()\n{\n    public HashMap() : base() { }\n    public HashMap(int cap) : base(cap) { }\n    new public V this[K i]\n    {\n        get\n        {\n            V v;\n            return TryGetValue(i, out v) ? v :\n            //    base[i] = default(V);\n            base[i] = new V();\n        }\n        set { base[i] = value; }\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\n// (づ°ω°)づﾐe★゜・。。・゜゜・。。・゜☆゜・。。・゜゜・。。・゜\npublic class Solver\n{\n    long Fun(int a, int b, int c, int d)\n    {\n        return Math.Min(Math.Min(1000000000L * a + 1000000 * b + 1000 * c + d, 1000000000L * b + 1000000 * c + 1000 * d + a),\n            Math.Min(1000000000L * c + 1000000 * d + 1000 * a + b, 1000000000L * d + 1000000 * a + 1000 * b + c));\n    }\n\n    public void Solve()\n    {\n        int n = ReadInt();\n        var a = ReadIntMatrix(n);\n\n        //n = 400;\n        //a = new int[400][];\n        //for (int i = 0; i < n; i++)\n        //    a[i] = new int[4];\n\n        var idx = a.Select(aa => Fun(aa[0], aa[1], aa[2], aa[3])).Distinct().ToArray();\n        Array.Sort(idx);\n        var b = a.Select(aa => Array.BinarySearch(idx, Fun(aa[0], aa[1], aa[2], aa[3]))).ToArray();\n\n        int m = idx.Length;\n        var cnt = new int[m];\n        for (int i = n - 5; i < n; i++)\n            cnt[b[i]]++;\n\n        long ans = 0;\n        Action<List<int[]>, int, int> add = (list, v1, v2) => \n        {\n            int size = list.Count;\n            if (size > 0 && list[size - 1][0] == v1 && list[size - 1][1] == v2)\n                list[size - 1][2]++;\n            else\n                list.Add(new [] { v1, v2, 1 });\n        };\n        for (int i = n - 6; i >= 0; i--)\n        {\n            Func<int, int, int, int, long> fun = (t1, t2, b1, b2) =>\n            {\n                int back = Array.BinarySearch(idx, Fun(t2, t1, b2, b1));\n                if (back < 0)\n                    return 0L;\n                int right = Array.BinarySearch(idx, Fun(a[i][1], t2, b1, a[i][2]));\n                if (right < 0)\n                    return 0L;\n                int left = Array.BinarySearch(idx, Fun(t1, a[i][0], a[i][3], b2));\n                if (left < 0)\n                    return 0L;\n                long ret;\n                if (left == right)\n                {\n                    if (left == back)\n                        ret = 1L * cnt[left] * (cnt[left] - 1) * (cnt[left] - 2);\n                    else\n                        ret = 1L * cnt[left] * (cnt[left] - 1) * cnt[back];\n                }\n                else\n                {\n                    if (left == back)\n                        ret = 1L * cnt[left] * (cnt[left] - 1) * cnt[right];\n                    else if (right == back)\n                        ret = 1L * cnt[right] * (cnt[right] - 1) * cnt[left];\n                    else\n                        ret = 1L * cnt[left] * cnt[right] * cnt[back];\n                }\n                if (t2 == b2 && t1 == b1)\n                {\n                    if (t2 == t1)\n                        ret *= 4;\n                    else\n                        ret *= 2;\n                }\n                if (a[i][1] == b1 && t2 == a[i][2])\n                {\n                    if (b1 == t2)\n                        ret *= 4;\n                    else\n                        ret *= 2;\n                }\n                if (t1 == a[i][3] && a[i][0] == b2)\n                {\n                    if (t1 == b2)\n                        ret *= 4;\n                    else\n                        ret *= 2;\n                }\n                return ret;\n            };\n\n            for (int j = i + 1; j < n; j++)\n            {\n                var to = new List<int[]>();\n                if (a[i][0] == a[j][1] && a[i][1] == a[j][0])\n                    add(to, a[j][2], a[j][3]);\n                if (a[i][0] == a[j][2] && a[i][1] == a[j][1])\n                    add(to, a[j][3], a[j][0]);\n                if (a[i][0] == a[j][3] && a[i][1] == a[j][2])\n                    add(to, a[j][0], a[j][1]);\n                if (a[i][0] == a[j][0] && a[i][1] == a[j][3])\n                    add(to, a[j][1], a[j][2]);\n                if (to.Count > 0)\n                {\n                    cnt[b[j]]--;\n                    for (int k = i + 1; k < n; k++)\n                        if (j != k)\n                        {\n                            cnt[b[k]]--;\n                            if (a[i][2] == a[i][3] && a[k][0] == a[k][1] && a[k][0] == a[k][2] && a[k][0] == a[k][3])\n                            {\n                                foreach (var t in to)\n                                    ans += 4 * t[2] * fun(t[0], t[1], a[i][2], a[i][2]);\n                            }\n                            else\n                            {\n                                if (a[i][3] == a[k][0] && a[i][2] == a[k][1])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][2], a[k][3]);\n                                if (a[i][3] == a[k][1] && a[i][2] == a[k][2])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][3], a[k][0]);\n                                if (a[i][3] == a[k][2] && a[i][2] == a[k][3])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][0], a[k][1]);\n                                if (a[i][3] == a[k][3] && a[i][2] == a[k][0])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][1], a[k][2]);\n                            }\n                            cnt[b[k]]++;\n                        }\n                    cnt[b[j]]++;\n                }\n            }\n\n            cnt[b[i]]++;\n        }\n\n        Write(ans);\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        //reader = new StreamReader(\"input.txt\");\n        //writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            //var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            //thread.Start();\n            //thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "//#pragma warning disable\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing static System.Console;\nclass E { static void Main() => new K(); }\nclass K\n{\n\tint F() => int.Parse(ReadLine());\n\tlong FL() => int.Parse(ReadLine());\n\tuint[] G() => ReadLine().Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries).Select(uint.Parse).ToArray();\n\tlong[] GL() => ReadLine().Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries).Select(long.Parse).ToArray();\n\tpublic const int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\t//SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\t//Out.Flush();\n\t}\n\tint N;\n\tuint[][] surf;\n\tint[] per;\n\tulong[] hash;\n\tDictionary<ulong, int> cnt = new Dictionary<ulong, int>();\n\tvoid Solve()\n\t{\n\t\tN = F();\n\t\tsurf = new uint[N][];\n\t\tper = new int[N];\n\t\thash = new ulong[N];\n\t\tfor (var i = 0; i < N; i++)\n\t\t{\n\t\t\tsurf[i] = G();\n\t\t\tper[i] = Period(surf[i][0], surf[i][1], surf[i][2], surf[i][3]);\n\t\t\tif (per[i] == 1) hash[i] = Hash1(surf[i][0]);\n\t\t\telse if (per[i] == 2) hash[i] = Hash2(surf[i][0], surf[i][1]);\n\t\t\telse hash[i] = Hash(surf[i][0], surf[i][1], surf[i][2], surf[i][3]);\n\t\t\tif (!cnt.ContainsKey(hash[i])) cnt[hash[i]] = 0;\n\t\t\tcnt[hash[i]]++;\n\t\t}\n\t\tvar e = 0L;\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tfor (var j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tvar count = 0L;\n\t\t\t\tcnt[hash[i]]--;\n\t\t\t\tcnt[hash[j]]--;\n\t\t\t\tfor (var rj = 0; rj < per[j]; rj++)\n\t\t\t\t{\n\t\t\t\t\tvar x = surf[i];\n\t\t\t\t\tvar y = new uint[4];\n\t\t\t\t\tfor (var k = 0; k < 4; k++) y[k] = surf[j][(k + rj) % 4];\n\t\t\t\t\tvar s = new[] {\n\t\t\t\t\t\tHash(y[3], y[2], x[3], x[2]),\n\t\t\t\t\t\tHash(y[2], y[1], x[0], x[3]),\n\t\t\t\t\t\tHash(y[1], y[0], x[1], x[0]),\n\t\t\t\t\t\tHash(y[0], y[3], x[2], x[1])\n\t\t\t\t\t};\n\t\t\t\t\tvar p = 1L;\n\t\t\t\t\tvar dup = new Dictionary<ulong, int>();\n\t\t\t\t\tforeach (var h in s)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!cnt.ContainsKey(h))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dup.ContainsKey(h)) dup[h] = 0;\n\t\t\t\t\t\tp *= (4 / Period(h)) * (cnt[h] - dup[h]);\n\t\t\t\t\t\tdup[h]++;\n\t\t\t\t\t}\n\t\t\t\t\tcount += p;\n\t\t\t\t}\n\t\t\t\te += count * (4 / per[j]);\n\t\t\t\tcnt[hash[i]]++;\n\t\t\t\tcnt[hash[j]]++;\n\t\t\t}\n\t\tConsole.WriteLine(e / 3);\n\t}\n\tstatic ulong Hash(uint i, uint j, uint k, uint l)\n\t{\n\t\tvar a = ((ulong)i << 30) | ((ulong)j << 20) | (k << 10) | l;\n\t\ta = Math.Min(a, ((ulong)j << 30) | ((ulong)k << 20) | (l << 10) | i);\n\t\ta = Math.Min(a, ((ulong)k << 30) | ((ulong)l << 20) | (i << 10) | j);\n\t\ta = Math.Min(a, ((ulong)l << 30) | ((ulong)i << 20) | (j << 10) | k);\n\t\treturn a;\n\t}\n\tstatic ulong Hash1(uint i)\n\t{\n\t\treturn ((ulong)i << 30) | ((ulong)i << 20) | (i << 10) | i;\n\t}\n\tstatic ulong Hash2(uint i, uint j)\n\t{\n\t\tif (i > j) return ((ulong)j << 30) | ((ulong)i << 20) | (j << 10) | i;\n\t\treturn ((ulong)i << 30) | ((ulong)j << 20) | (i << 10) | j;\n\t}\n\tconst ulong p1 = (1 << 30) | (1 << 20) | (1 << 10) | 1;\n\tconst ulong p2 = (1 << 20) | 1;\n\tstatic int Period(ulong h)\n\t{\n\t\treturn h % p2 == 0 ? h % p1 == 0 ? 1 : 2 : 4;\n\t}\n\tstatic int Period(uint i, uint j, uint k, uint l)\n\t{\n\t\treturn i == k && j == l ? i == j ? 1 : 2 : 4;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\nusing static System.Math;\nusing static System.Console;\nclass E { static void Main() => new K(); }\nclass K\n{\n\tpublic K()\n\t{\n\t\tvar N = int.Parse(ReadLine());\n\t\tvar surf = new uint[N][];\n\t\tvar per = new int[N];\n\t\tvar hash = new ulong[N];\n\t\tvar dict = new Dictionary<ulong, int>();\n\t\tfor (var i = 0; i < N; i++)\n\t\t{\n\t\t\tsurf[i] = ReadLine().Split().Select(uint.Parse).ToArray();\n\t\t\tper[i] = surf[i][0] == surf[i][2] && surf[i][1] == surf[i][3] ? surf[i][0] == surf[i][1] ? 1 : 2 : 4;\n\t\t\tif (per[i] == 1) hash[i] = Hash1(surf[i][0]);\n\t\t\telse if (per[i] == 2) hash[i] = Hash2(surf[i][0], surf[i][1]);\n\t\t\telse hash[i] = Hash(surf[i][0], surf[i][1], surf[i][2], surf[i][3]);\n\t\t\tif (!dict.ContainsKey(hash[i])) dict[hash[i]] = 0;\n\t\t\tdict[hash[i]]++;\n\t\t}\n\t\tvar a = 0L;\n\t\tvar y = new uint[4];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tfor (var j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tvar count = 0L;\n\t\t\t\tdict[hash[i]]--;\n\t\t\t\tdict[hash[j]]--;\n\t\t\t\tfor (var rj = 0; rj < per[j]; rj++)\n\t\t\t\t{\n\t\t\t\t\tvar x = surf[i];\n\t\t\t\t\tfor (var k = 0; k < 4; k++) y[k] = surf[j][(k + rj) % 4];\n\t\t\t\t\tvar s = new[] {\n\t\t\t\t\t\tHash(y[3], y[2], x[3], x[2]),\n\t\t\t\t\t\tHash(y[2], y[1], x[0], x[3]),\n\t\t\t\t\t\tHash(y[1], y[0], x[1], x[0]),\n\t\t\t\t\t\tHash(y[0], y[3], x[2], x[1])\n\t\t\t\t\t};\n\t\t\t\t\tvar p = 1L;\n\t\t\t\t\tvar dup = new Dictionary<ulong, int>();\n\t\t\t\t\tforeach (var h in s)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!dict.ContainsKey(h)) { p = 0; break; }\n\t\t\t\t\t\tif (!dup.ContainsKey(h)) dup[h] = 0;\n\t\t\t\t\t\tp *= (4 / Period(h)) * (dict[h] - dup[h]);\n\t\t\t\t\t\tdup[h]++;\n\t\t\t\t\t}\n\t\t\t\t\tcount += p;\n\t\t\t\t}\n\t\t\t\ta += count * (4 / per[j]);\n\t\t\t\tdict[hash[i]]++;\n\t\t\t\tdict[hash[j]]++;\n\t\t\t}\n\t\tWriteLine(a / 3);\n\t}\n\tstatic ulong Hash(uint i, uint j, uint k, uint l)\n\t{\n\t\tvar a = ((ulong)i << 30) | (j << 20) | (k << 10) | l;\n\t\ta = Min(a, ((ulong)j << 30) | (k << 20) | (l << 10) | i);\n\t\ta = Min(a, ((ulong)k << 30) | (l << 20) | (i << 10) | j);\n\t\ta = Min(a, ((ulong)l << 30) | (i << 20) | (j << 10) | k);\n\t\treturn a;\n\t}\n\tstatic ulong Hash1(uint i) => ((ulong)i << 30) | (i << 20) | (i << 10) | i;\n\tstatic ulong Hash2(uint i, uint j)\n\t{\n\t\tif (i > j) return ((ulong)j << 30) | (i << 20) | (j << 10) | i;\n\t\treturn ((ulong)i << 30) | (j << 20) | (i << 10) | j;\n\t}\n\tconst ulong p1 = (1 << 30) | (1 << 20) | (1 << 10) | 1;\n\tconst ulong p2 = (1 << 20) | 1;\n\tstatic int Period(ulong h) => h % p2 == 0 ? h % p1 == 0 ? 1 : 2 : 4;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\nusing static System.Math;\nusing static System.Console;\nclass E { static void Main() => new K(); }\nclass K\n{\n\tpublic K()\n\t{\n\t\tvar N = int.Parse(ReadLine());\n\t\tvar surf = new uint[N][];\n\t\tvar per = new int[N];\n\t\tvar hash = new ulong[N];\n\t\tvar dict = new Dictionary<ulong, int>();\n\t\tfor (var i = 0; i < N; i++)\n\t\t{\n\t\t\tsurf[i] = ReadLine().Split().Select(uint.Parse).ToArray();\n\t\t\tper[i] = surf[i][0] == surf[i][2] && surf[i][1] == surf[i][3] ? surf[i][0] == surf[i][1] ? 1 : 2 : 4;\n\t\t\tif (per[i] == 1) hash[i] = Hash1(surf[i][0]);\n\t\t\telse if (per[i] == 2) hash[i] = Hash2(surf[i][0], surf[i][1]);\n\t\t\telse hash[i] = Hash(surf[i][0], surf[i][1], surf[i][2], surf[i][3]);\n\t\t\tif (!dict.ContainsKey(hash[i])) dict[hash[i]] = 0;\n\t\t\tdict[hash[i]]++;\n\t\t}\n\t\tvar a = 0L;\n\t\tvar y = new uint[4];\n\t\tfor (var i = 0; i < N; i++)\n\t\t\tfor (var j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tvar count = 0L;\n\t\t\t\tdict[hash[i]]--;\n\t\t\t\tdict[hash[j]]--;\n\t\t\t\tfor (var rj = 0; rj < per[j]; rj++)\n\t\t\t\t{\n\t\t\t\t\tvar x = surf[i];\n\t\t\t\t\tfor (var k = 0; k < 4; k++) y[k] = surf[j][(k + rj) % 4];\n\t\t\t\t\tvar s = new[] {\n\t\t\t\t\t\tHash(y[3], y[2], x[3], x[2]),\n\t\t\t\t\t\tHash(y[2], y[1], x[0], x[3]),\n\t\t\t\t\t\tHash(y[1], y[0], x[1], x[0]),\n\t\t\t\t\t\tHash(y[0], y[3], x[2], x[1])\n\t\t\t\t\t};\n\t\t\t\t\tvar p = 1L;\n\t\t\t\t\tvar dup = new Dictionary<ulong, int>();\n\t\t\t\t\tforeach (var h in s)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!dict.ContainsKey(h)) { p = 0; break; }\n\t\t\t\t\t\tif (!dup.ContainsKey(h)) dup[h] = 0;\n\t\t\t\t\t\tp *= (h % p2 == 0 ? h % p1 == 0 ? 4 : 2 : 1) * (dict[h] - dup[h]);\n\t\t\t\t\t\tdup[h]++;\n\t\t\t\t\t}\n\t\t\t\t\tcount += p;\n\t\t\t\t}\n\t\t\t\ta += count * (4 / per[j]);\n\t\t\t\tdict[hash[i]]++;\n\t\t\t\tdict[hash[j]]++;\n\t\t\t}\n\t\tWriteLine(a / 3);\n\t}\n\tstatic ulong Hash(uint i, uint j, uint k, uint l)\n\t{\n\t\tvar a = ((ulong)i << 30) | (j << 20) | (k << 10) | l;\n\t\ta = Min(a, ((ulong)j << 30) | (k << 20) | (l << 10) | i);\n\t\ta = Min(a, ((ulong)k << 30) | (l << 20) | (i << 10) | j);\n\t\ta = Min(a, ((ulong)l << 30) | (i << 20) | (j << 10) | k);\n\t\treturn a;\n\t}\n\tstatic ulong Hash1(uint i) => ((ulong)i << 30) | (i << 20) | (i << 10) | i;\n\tstatic ulong Hash2(uint i, uint j)\n\t{\n\t\tif (i > j) return ((ulong)j << 30) | (i << 20) | (j << 10) | i;\n\t\treturn ((ulong)i << 30) | (j << 20) | (i << 10) | j;\n\t}\n\tconst ulong p1 = (1 << 30) | (1 << 20) | (1 << 10) | 1;\n\tconst ulong p2 = (1 << 20) | 1;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    long[] C;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        C = new long[N];\n        for(int i=0;i<N;i++){\n            string[] str = Console.ReadLine().Split(' ');\n            C[i] = Square(int.Parse(str[0]),int.Parse(str[1]),int.Parse(str[2]),int.Parse(str[3]));\n        }\n        Array.Sort(C);\n        long count = 0;\n        for(int i=0;i<N;i++){\n            long X = C[i];\n            for(int j=i+1;j<N;j++){\n                long Y = C[j];\n                long Y0 = Y;\n                for(int l=0;l<4;l++){\n                    long c = 1;\n                    long ax = X/1000000000;\n                    long bx = X/1000000%1000;\n                    long cx = X/1000%1000;\n                    long dx = X%1000;\n                    long ay = Y0/1000000000;\n                    long by = Y0/1000000%1000;\n                    long cy = Y0/1000%1000;\n                    long dy = Y0%1000;\n                    long C1 = Square(bx,ax,by,ay);\n                    long C2 = Square(cx,bx,ay,dy);\n                    long C3 = Square(dx,cx,dy,cy);\n                    long C4 = Square(ax,dx,cy,by);\n                    long cc = Counter(C1);\n                    if(X == C1){\n                        cc--;\n                    }\n                    if(Y == C1){\n                        cc--;\n                    }\n                    c *= cc*Roll(C1);\n                    cc = Counter(C2);\n                    if(X == C2){\n                        cc--;\n                    }\n                    if(Y == C2){\n                        cc--;\n                    }\n                    if(C1 == C2){\n                        cc--;\n                    }\n                    c *= cc*Roll(C2);\n                    cc = Counter(C3);\n                    if(X == C3){\n                        cc--;\n                    }\n                    if(Y == C3){\n                        cc--;\n                    }\n                    if(C1 == C3){\n                        cc--;\n                    }\n                    if(C2 == C3){\n                        cc--;\n                    }\n                    c *= cc*Roll(C3);\n                    cc = Counter(C4);\n                    if(X == C4){\n                        cc--;\n                    }\n                    if(Y == C4){\n                        cc--;\n                    }\n                    if(C1 == C4){\n                        cc--;\n                    }\n                    if(C2 == C4){\n                        cc--;\n                    }\n                    if(C3 == C4){\n                        cc--;\n                    }\n                    c *= cc*Roll(C4);\n                    count += c;\n                    Y0 = Y0/1000000000 + Y0%1000000000*1000;\n                }\n            }\n        }\n        sb.Append(count/3+\"\\n\");\n    }\n    long Roll(long X){\n        long Y = X/1000000000 + X%1000000000*1000;\n        if(X == Y){\n            return 4;\n        }\n        else{\n            long Z = Y/1000000000 + Y%1000000000*1000;\n            if(X == Z){\n                return 2;\n            }\n            else{\n                return 1;\n            }\n        }\n    }\n    long Square(long a,long b,long c,long d){\n        long X = 1000000000 * a + 1000000 * b + 1000 * c + d;\n        long min = X;\n        for(int i=0;i<3;i++){\n            X = X/1000000000 + X%1000000000*1000;\n            min = Math.Min(min,X);\n        }\n        return min;\n    }\n    long Counter(long X){\n        int bf = 0;\n        int bl = C.Length;\n        while(bf != bl){\n            int bc = (bf+bl)/2;\n            if(bc == C.Length || C[bc] >= X){\n                bl = bc;\n            }\n            else{\n                bf = bc+1;\n            }\n        }\n        int l = bf;\n        bf = -1;\n        bl = C.Length-1;\n        while(bf != bl){\n            int bc = (bf+bl+1)/2;\n            if(bc == -1 || C[bc] <= X){\n                bf = bc;\n            }\n            else{\n                bl = bc-1;\n            }\n        }\n        int r = bf;\n        if(l > r){\n            return 0;\n        }\n        else{\n            return r - l + 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\n// (づ°ω°)づﾐe★゜・。。・゜゜・。。・゜☆゜・。。・゜゜・。。・゜\npublic class Solver\n{\n    long Fun(int a, int b, int c, int d)\n    {\n        return Math.Min(Math.Min(1000000000L * a + 1000000 * b + 1000 * c + d, 1000000000L * b + 1000000 * c + 1000 * d + a),\n            Math.Min(1000000000L * c + 1000000 * d + 1000 * a + b, 1000000000L * d + 1000000 * a + 1000 * b + c));\n    }\n\n    public void Solve()\n    {\n        int n = ReadInt();\n        var a = ReadIntMatrix(n);\n\n        //n = 400;\n        //a = new int[n][];\n        //for (int i = 0; i < n; i++)\n        //    a[i] = new int[4];\n\n        var idx = a.Select(aa => Fun(aa[0], aa[1], aa[2], aa[3])).Distinct().ToArray();\n        Array.Sort(idx);\n        var b = a.Select(aa => Array.BinarySearch(idx, Fun(aa[0], aa[1], aa[2], aa[3]))).ToArray();\n\n        int m = idx.Length;\n        var cnt = new int[m];\n        for (int i = n - 5; i < n; i++)\n            cnt[b[i]]++;\n\n        long ans = 0;\n        Action<List<int[]>, int, int> add = (list, v1, v2) => \n        {\n            int size = list.Count;\n            if (size > 0 && list[size - 1][0] == v1 && list[size - 1][1] == v2)\n                list[size - 1][2]++;\n            else\n                list.Add(new [] { v1, v2, 1 });\n        };\n        for (int i = n - 6; i >= 0; i--)\n        {\n            Func<int, int, int, int, long> fun = (t1, t2, b1, b2) =>\n            {\n                int back = Array.BinarySearch(idx, Fun(t2, t1, b2, b1));\n                if (back < 0)\n                    return 0L;\n                int right = Array.BinarySearch(idx, Fun(a[i][1], t2, b1, a[i][2]));\n                if (right < 0)\n                    return 0L;\n                int left = Array.BinarySearch(idx, Fun(t1, a[i][0], a[i][3], b2));\n                if (left < 0)\n                    return 0L;\n                long ret;\n                if (left == right)\n                {\n                    if (left == back)\n                        ret = 1L * cnt[left] * (cnt[left] - 1) * (cnt[left] - 2);\n                    else\n                        ret = 1L * cnt[left] * (cnt[left] - 1) * cnt[back];\n                }\n                else\n                {\n                    if (left == back)\n                        ret = 1L * cnt[left] * (cnt[left] - 1) * cnt[right];\n                    else if (right == back)\n                        ret = 1L * cnt[right] * (cnt[right] - 1) * cnt[left];\n                    else\n                        ret = 1L * cnt[left] * cnt[right] * cnt[back];\n                }\n                if (t2 == b2 && t1 == b1)\n                {\n                    if (t2 == t1)\n                        ret *= 4;\n                    else\n                        ret *= 2;\n                }\n                if (a[i][1] == b1 && t2 == a[i][2])\n                {\n                    if (b1 == t2)\n                        ret *= 4;\n                    else\n                        ret *= 2;\n                }\n                if (t1 == a[i][3] && a[i][0] == b2)\n                {\n                    if (t1 == b2)\n                        ret *= 4;\n                    else\n                        ret *= 2;\n                }\n                return ret;\n            };\n\n            for (int j = i + 1; j < n; j++)\n            {\n                var to = new List<int[]>();\n                if (a[i][0] == a[j][1] && a[i][1] == a[j][0])\n                    add(to, a[j][2], a[j][3]);\n                if (a[i][0] == a[j][2] && a[i][1] == a[j][1])\n                    add(to, a[j][3], a[j][0]);\n                if (a[i][0] == a[j][3] && a[i][1] == a[j][2])\n                    add(to, a[j][0], a[j][1]);\n                if (a[i][0] == a[j][0] && a[i][1] == a[j][3])\n                    add(to, a[j][1], a[j][2]);\n                if (to.Count > 0)\n                {\n                    cnt[b[j]]--;\n                    for (int k = i + 1; k < n; k++)\n                        if (j != k)\n                        {\n                            cnt[b[k]]--;\n                            if (a[i][2] == a[i][3] && a[k][0] == a[i][2] && a[k][0] == a[k][1] && a[k][0] == a[k][2] && a[k][0] == a[k][3])\n                            {\n                                foreach (var t in to)\n                                    ans += 4 * t[2] * fun(t[0], t[1], a[i][2], a[i][2]);\n                            }\n                            else\n                            {\n                                if (a[i][3] == a[k][0] && a[i][2] == a[k][1])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][2], a[k][3]);\n                                if (a[i][3] == a[k][1] && a[i][2] == a[k][2])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][3], a[k][0]);\n                                if (a[i][3] == a[k][2] && a[i][2] == a[k][3])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][0], a[k][1]);\n                                if (a[i][3] == a[k][3] && a[i][2] == a[k][0])\n                                    foreach (var t in to)\n                                        ans += t[2] * fun(t[0], t[1], a[k][1], a[k][2]);\n                            }\n                            cnt[b[k]]++;\n                        }\n                    cnt[b[j]]++;\n                }\n            }\n\n            cnt[b[i]]++;\n        }\n\n        Write(ans);\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        //reader = new StreamReader(\"input.txt\");\n        //writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            //var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            //thread.Start();\n            //thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly int[][] Index = { new[] { 1 ,0, 1, 0 }, new[] { 2, 1, 0, 3 },\n                                      new[] { 3, 2, 3, 2 }, new[] { 0, 3, 2, 1 } };\n\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var C = Reader.IntTable(N);\n        var K = C.Select(c => Key(c)).ToArray();\n        var M = new Dictionary<long, int>();\n        for (int i = 0; i < N; i++) M[K[i]] = Mult(C[i]);\n        var dic = new Dictionary<long, int>();\n        ulong ans = 0;\n\n        foreach (long k in K)\n            dic[k] = dic.ContainsKey(k) ? dic[k] + 1 : 1;\n        for (int a = 0; a < N - 1 && dic[K[a]]-- > 0; a++)\n            for (int b = a + 1; b < N && dic[K[b]]-- > 0; dic[K[b]]++, b++)\n                for (int r = 0; r < 4; r++, Rotate(C[b]))\n                    ans += (ulong)Count(C[a], C[b], dic, M);\n\n        Console.WriteLine(ans);\n    }\n\n    private long Count(int[] A, int[] B, Dictionary<long, int> dic, Dictionary<long, int> Mult)\n    {\n        var pattern = new Dictionary<long, int>();\n        foreach (var i in Index)\n        {\n            long k = Key(new[] { A[i[0]], A[i[1]], B[i[2]], B[i[3]] });\n            if (!dic.ContainsKey(k)) return 0;\n            pattern[k] = pattern.ContainsKey(k) ? pattern[k] + 1 : 1;\n        }\n        long num = 1;\n        foreach (long k in pattern.Keys)\n            for (int i = 0; i < pattern[k]; i++)\n                num *= (dic[k] - i) * Mult[k];\n        return num;\n    }\n\n    void Rotate(int[] a) { int t = a[3]; Array.Copy(a, 0, a, 1, 3); a[0] = t; }\n\n    long Key(int[] a)\n    {\n        long min = long.MaxValue;\n        for (int r = 0; r < 4; r++, Rotate(a))\n            min = Math.Min(min, a[0] * (long)1e9 + a[1] * (long)1e6 + a[2] * 1000 + a[3]);\n        return min;\n    }\n\n    int Mult(int[] a)\n    {\n        if (a[0] == a[1] && a[1] == a[2] && a[2] == a[3]) return 4;\n        if (a[0] == a[2] && a[1] == a[3]) return 2;\n        return 1;\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    public static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        Tile[] tiles = Enumerable.Range(0, n).Select(x =>\n        {\n            var c = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return new Tile(x, c[0], c[1], c[2], c[3]);\n        }).ToArray();\n        Dictionary<long, int> tileCounts = new Dictionary<long, int>();\n        foreach (var tile in tiles)\n        {\n            if (!tileCounts.ContainsKey(tile.NormalSeed)) tileCounts.Add(tile.NormalSeed, 0);\n            tileCounts[tile.NormalSeed]++;   \n        }\n        long res = 0;\n        foreach (var topTile in tiles)\n        {\n            var topSeed = topTile.NormalSeed;\n            foreach (var bottomTile in tiles.Where(x => x.Num != topTile.Num))\n            {\n                var bottomSeed = bottomTile.NormalSeed;\n                foreach (var rotated in bottomTile.Rotates)\n                {\n                    //LU  RU\n                    //  up\n                    //LD  RD\n\n                    //RU  LU\n                    //  dn\n                    //RD  LD\n                    var tile1 = new Tile(0, topTile.RU, topTile.LU, rotated.RU, rotated.LU);\n                    var tile2 = new Tile(0, topTile.RD, topTile.RU, rotated.LU, rotated.LD);\n                    var tile3 = new Tile(0, topTile.LD, topTile.RD, rotated.LD, rotated.RD);\n                    var tile4 = new Tile(0, topTile.LU, topTile.LD, rotated.RD, rotated.RU);\n                    var seed1 = tile1.NormalSeed;\n                    var seed2 = tile2.NormalSeed;\n                    var seed3 = tile3.NormalSeed;\n                    var seed4 = tile4.NormalSeed;\n                    var count1 = tileCounts.Get(seed1) - (topSeed == seed1 ? 1 : 0) - (bottomSeed == seed1 ? 1 : 0);\n                    var count2 = tileCounts.Get(seed2) - (topSeed == seed2 ? 1 : 0) - (bottomSeed == seed2 ? 1 : 0) - (seed1 == seed2 ? 1 : 0);\n                    var count3 = tileCounts.Get(seed3) - (topSeed == seed3 ? 1 : 0) - (bottomSeed == seed3 ? 1 : 0) - (seed1 == seed3 ? 1 : 0) - (seed2 == seed3 ? 1 : 0);\n                    var count4 = tileCounts.Get(seed4) - (topSeed == seed4 ? 1 : 0) - (bottomSeed == seed4 ? 1 : 0) - (seed1 == seed4 ? 1 : 0) - (seed2 == seed4 ? 1 : 0) - (seed3 == seed4 ? 1 : 0);\n                    var perm = (long)count1 * tile1.Order * count2 * tile2.Order * count3 * tile3.Order * count4 * tile4.Order;\n                    res += perm;\n                }\n            }\n        }\n        res /= 6;\n        Console.WriteLine(res);\n    }\n    static TVal Get<TKey, TVal>(this Dictionary<TKey, TVal> dict, TKey key) => dict.ContainsKey(key) ? dict[key] : default(TVal);\n}\n\nstruct Tile\n{\n    //   0\n    // 　↑\n    //3←　→1\n    //　 ↓\n    //   2\n    public int Num;\n    public int Dir;\n    //L←→R\n    public int RU;\n    public int RD;\n    public int LU;\n    public int LD;\n    public long NormalSeed => Rotates.Min(x => x.ColorSeed);\n    public long ColorSeed => GenColorSeed(LU, RU, RD, LD);\n    public int Order => (RU == LD && LU == RD ? (RU == LU ? 4 : 2) : 1);\n    public IEnumerable<Tile> Rotates\n    {\n        get\n        {\n            yield return this;\n            var tile = this.Rotate();\n            yield return tile;\n            tile = tile.Rotate();\n            yield return tile;\n            tile = tile.Rotate();\n            yield return tile;\n        }\n    }\n    public Tile(int num, int lu, int ru, int rd, int ld)\n    {\n        Num = num;\n        Dir = 0;\n        RU = ru;\n        RD = rd;\n        LU = lu;\n        LD = ld;\n    }\n    public Tile Rotate() => new Tile()\n    {\n        Num = Num,\n        Dir = (Dir + 1) & 3,\n        RU = RD,\n        RD = LD,\n        LD = LU,\n        LU = RU\n    };\n    public static long GenColorSeed(int lu, int ru, int rd, int ld) => ((((long)lu * 1000) + ru) * 1000 + rd) * 1000 + ld;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class P\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        Tile[] tiles = Enumerable.Range(0, n).Select(x =>\n        {\n            var c = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return new Tile(x, c[0], c[1], c[2], c[3]);\n        }).ToArray();\n        Dictionary<long, int> tileCounts = new Dictionary<long, int>();\n        foreach (var tile in tiles)\n        {\n            if (!tileCounts.ContainsKey(tile.NormalSeed)) tileCounts.Add(tile.NormalSeed, 0);\n            tileCounts[tile.NormalSeed]++;\n        }\n        long res = 0;\n        foreach (var topTile in tiles)\n        {\n            var topSeed = topTile.NormalSeed;\n            foreach (var bottomTile in tiles.Where(x => x.Num != topTile.Num))\n            {\n                var bottomSeed = bottomTile.NormalSeed;\n                foreach (var rotated in bottomTile.Rotates)\n                {\n                    //LU  RU\n                    //  up\n                    //LD  RD\n\n                    //RU  LU\n                    //  dn\n                    //RD  LD\n                    var sideTiles = new[]\n                    {\n                        new Tile(0, topTile.RU, topTile.LU, rotated.RU, rotated.LU),\n                        new Tile(0, topTile.RD, topTile.RU, rotated.LU, rotated.LD),\n                        new Tile(0, topTile.LD, topTile.RD, rotated.LD, rotated.RD),\n                        new Tile(0, topTile.LU, topTile.LD, rotated.RD, rotated.RU)\n                    };\n                    var usedSeed = new List<long>() { topSeed, bottomSeed };\n                    long perm = 1;\n                    foreach (var sideTile in sideTiles)\n                    {\n                        var seed = sideTile.NormalSeed;\n                        perm *= (tileCounts.Get(seed) - usedSeed.Count(x => x == seed)) * sideTile.Order;\n                        usedSeed.Add(seed);\n                    }\n                    res += perm;\n                }\n            }\n        }\n        res /= 6;\n        Console.WriteLine(res);\n    }\n    static TVal Get<TKey, TVal>(this Dictionary<TKey, TVal> dict, TKey key) => dict.ContainsKey(key) ? dict[key] : default(TVal);\n}\n\nstruct Tile\n{\n    //   0\n    // 　↑\n    //3←　→1\n    //　 ↓\n    //   2\n    public int Num;\n    public int Dir;\n    //L←→R\n    public int RU;\n    public int RD;\n    public int LU;\n    public int LD;\n    public long NormalSeed => Rotates.Min(x => x.ColorSeed);\n    public long ColorSeed => GenColorSeed(LU, RU, RD, LD);\n    public int Order => (RU == LD && LU == RD ? (RU == LU ? 4 : 2) : 1);\n    public IEnumerable<Tile> Rotates\n    {\n        get\n        {\n            yield return this;\n            var tile = this.Rotate();\n            yield return tile;\n            tile = tile.Rotate();\n            yield return tile;\n            tile = tile.Rotate();\n            yield return tile;\n        }\n    }\n    public Tile(int num, int lu, int ru, int rd, int ld)\n    {\n        Num = num;\n        Dir = 0;\n        RU = ru;\n        RD = rd;\n        LU = lu;\n        LD = ld;\n    }\n    public Tile Rotate() => new Tile()\n    {\n        Num = Num,\n        Dir = (Dir + 1) & 3,\n        RU = RD,\n        RD = LD,\n        LD = LU,\n        LU = RU\n    };\n    public static long GenColorSeed(int lu, int ru, int rd, int ld) => ((((long)lu * 1000) + ru) * 1000 + rd) * 1000 + ld;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\nN = gets.to_i\nCARDS = readlines.map{|l| l.split.map{|x| x.to_i}}\n\ndef hashn(cols)\n  ret = Float::INFINITY\n  i = 0\n  while i < 4 \n    a,b,c,d = cols.rotate(i)\n    h = a*1000000000+b*1000000+c*1000+d\n    ret = h if h < ret\n    i += 1\n  end\n  ret\nend\n\nCOUNTS = Hash.new{|h, k| h[k] = 0}\nCARDS.each.with_index do |cols, k|\n  COUNTS[hashn(cols)] += 1\nend\n\n      #    0--1\\\n      #    |\\3--2\n      #    4 | 7|\n      #     \\5--6\nSIDES = [\n  [0,3,5,4],\n  [3,2,6,5],\n  [2,1,7,6],\n  [1,0,4,7],\n]\n\nans = 0\n# Loop for all the combinations of top/bottom cards\nfor i in 0..(N-2)\n  top = CARDS[i]\n  top_hash = hashn(top)\n  for j in (i+1)..(N-1)\n    # Loop for each rotation of the bottom card\n    4.times do |l|\n      btm = CARDS[j].rotate(l)\n      btm_hash = hashn(btm)\n      cols = top + btm\n\n      # The count is, basically, the sum of the number of candidate cards for each side.\n      total = 1\n      used = Hash.new(0)\n      used[top_hash] += 1\n      used[btm_hash] += 1\n      4.times do |i|\n        side_cols = cols.values_at(*SIDES[i])\n        side_hash = hashn(side_cols)\n        a,b,c,d = side_cols\n        m = if a==b&&b==c&&c==d\n              4\n            elsif a==c&&b==d\n              2\n            else\n              1\n            end\n        total *= (COUNTS[side_hash] - used[side_hash]) * m\n        used[side_hash] += 1\n      end\n#      p ij: [i, j], top: top, btm: btm,\n#        sides: 4.times.map{|i| cols.values_at(*SIDES[i])},\n#        total: total if total > 0\n      ans += total\n    end\n  end\nend\n\n# Each cube is counted three times, so divide by 3\np ans / 3\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nc = N.times.map { gets.split.map(&:to_i) }\n\nans = 0\nex = []\n\n(0..(N-1)).to_a.combination(2) do |i, j|\n  a = c[i]\n  b = c[j]\n  ex << i\n  4.times do\n    b.rotate!\n    N.times do |n1|\n      next if (ex + [i, j]).include?(n1)\n      p1 = c[n1]\n      4.times do\n        p1.rotate!\n        next if p1[0] != b[1] || p1[1] != a[0] || p1[2] != a[3] || p1[3] != b[2]\n        N.times do |n2|\n          next if (ex + [i, j, n1]).include?(n2)\n          p2 = c[n2]\n          4.times do\n            p2.rotate!\n            next if p2[0] !=b[2] || p2[1] != a[3] || p2[2] != a[2] || p2[3] != b[3]\n            N.times do |n3|\n              next if (ex + [i, j, n1, n2]).include?(n3)\n              p3 = c[n3]\n              4.times do\n                p3.rotate!\n                next if p3[0] != b[3] || p3[1] != a[2] || p3[2] != a[1] || p3[3] != b[0]\n                N.times do |n4|\n                  next if (ex + [i, j, n1, n2, n3]).include?(n4)\n                  p4 = c[n4]\n                  4.times do\n                    p4.rotate!\n                    next if p4[0] != b[0] || p4[1] != a[1] || p4[2] != a[0] || p4[3] != b[1]\n                    ans += 1\n                  end\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n  end\nend\n\np ans\n"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\nN = gets.to_i\nCARDS = readlines.map{|l| l.split.map{|x| x.to_i}}\n\n#def hashn(cols)\n#  ret = Float::INFINITY\n#  i = 0\n#  while i < 4 \n#    a,b,c,d = cols.rotate(i)\n#    h = a*1000000000+b*1000000+c*1000+d\n#    ret = h if h < ret\n#    i += 1\n#  end\n#  ret\n#end\ndef hashn(cols)\n  a,b,c,d = cols\n  [\n    a*1000000000+b*1000000+c*1000+d,\n    b*1000000000+c*1000000+d*1000+a,\n    c*1000000000+d*1000000+a*1000+b,\n    d*1000000000+a*1000000+b*1000+c,\n  ].min\nend\n\nCOUNTS = Hash.new{|h, k| h[k] = 0}\nCARDS.each.with_index do |cols, k|\n  COUNTS[hashn(cols)] += 1\nend\n\n      #    0--1\\\n      #    |\\3--2\n      #    4 | 7|\n      #     \\5--6\nSIDES = [\n  [0,3,5,4],\n  [3,2,6,5],\n  [2,1,7,6],\n  [1,0,4,7],\n]\n\nans = 0\n# Loop for all the combinations of top/bottom cards\nfor i in 0..(N-2)\n  #p i; break if i == 1\n  top = CARDS[i]\n  top_hash = hashn(top)\n  for j in (i+1)..(N-1)\n    # Loop for each rotation of the bottom card\n    4.times do |l|\n      btm = CARDS[j].rotate(l)\n      btm_hash = hashn(btm)\n      cols = top + btm\n\n      # The count is, basically, the sum of the number of candidate cards for each side.\n      total = 1\n      used = Hash.new(0)\n      used[top_hash] += 1\n      used[btm_hash] += 1\n      4.times do |i|\n        side_cols = cols.values_at(*SIDES[i])\n        side_hash = hashn(side_cols)\n        a,b,c,d = side_cols\n        m = if a==b&&b==c&&c==d\n              4\n            elsif a==c&&b==d\n              2\n            else\n              1\n            end\n        total *= (COUNTS[side_hash] - used[side_hash]) * m\n        used[side_hash] += 1\n      end\n#      p ij: [i, j], top: top, btm: btm,\n#        sides: 4.times.map{|i| cols.values_at(*SIDES[i])},\n#        total: total if total > 0\n      ans += total\n    end\n  end\nend\n\n# Each cube is counted three times, so divide by 3\np ans / 3\n"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\nN = gets.to_i\nCARDS = readlines.map{|l| l.split.map(&:to_i)} #.with_index{|l, i| l.split.map(&:to_i) + [i]}\n\ndef rot(ary, n)\n  ary[n..-1] + ary[0...n]\nend\n\nINDEX = Hash.new{|h, k| h[k] = []}\n#INDEX = Hash.new{|h, k|\n#  h[k] = Hash.new{|h, k|\n#    h[k] = Hash.new{|h, k|\n#      h[k] = []\n#    }\n#  }\n#}\nCARDS.each.with_index do |cols, n|\n  4.times do |i|\n    INDEX[rot(cols, i)] << n\n  end\nend\n\nans = 0\nfor i in 0..(N-2)\n  for j in (i+1)..(N-1)\n    3.times do |k|\n      a, b, c, d = rot(CARDS[i], k)\n      3.times do |l|\n        e, f, g, h = rot(CARDS[j], l)\n\n        #    a--b\\\n        #    |\\d--c\n        #    e | h|\n        #     \\f--g\n\n        cands = [\n          INDEX[[a,d,f,e]],\n          INDEX[[d,c,g,f]],\n          INDEX[[c,b,h,g]],\n          INDEX[[b,a,e,h]],\n        ]\n        #p ijk: [i+1, j+1], abcd: [a, b, c, d], efgh: [e,f,g,h], cands: cands\n        ans += cands.inject(:product).map(&:flatten).select{|x| x.uniq.size == 4}.count\n      end\n    end\n  end\nend\n\np ans / 6 #TODO\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n := input.NextInt()\n  c := make([][]int,n)\n  a := make([]Pair,n)\n  m := map[int64]int{}\n  for i:=0;i<n;i++ {\n    c[i] = make([]int,4)\n    c[i][0],c[i][1],c[i][2],c[i][3] = input.NextInts()\n    a[i] = f(c[i][0],c[i][1],c[i][2],c[i][3])\n    m[a[i].x] += a[i].y\n  }\n  ans := int64(0)\n  for i:=0;i<n;i++ {\n    m[a[i].x] -= a[i].y\n    for j:=i+1;j<n;j++ {\n      m[a[j].x] -= a[j].y\n      for k:=0;k<4;k++ {\n        x := make([]Pair,4)\n        tmp := int64(1)\n        for l:=0;l<4;l++ {\n          x[l] = f(c[i][l],c[j][(k+4-l)%4],c[j][(k+3-l)%4],c[i][(l+1)%4])\n          tmp *= int64(m[x[l].x])\n          m[x[l].x] -= x[l].y\n        }\n        for l:=0;l<4;l++ { m[x[l].x] += x[l].y }\n        ans += tmp\n      }\n      m[a[j].x] += a[j].y\n    }\n  }\n  fmt.Println(ans)\n}\n\nfunc f(x,y,z,w int) Pair {\n  c := []int64{int64(x),int64(y),int64(z),int64(w)}\n  a := make([]int64,4)\n  for i:=0;i<4;i++ {\n    for j:=0;j<4;j++ { a[i] = 1000*a[i]+c[(i+j)%4] }\n  }\n  ret := max(max(a[0],a[1]),max(a[2],a[3]))\n  cnt := 0\n  for i:=0;i<4;i++ {\n    if a[i] == ret { cnt++ }\n  }\n  return Pair{ret,cnt}\n}\n\nfunc max(x,y int64) int64 {\n  if x > y { return x }\n  return y\n}\n\ntype Pair struct { x int64;y int }\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) NextInts() (int,int,int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.Atoi(s[2])\n  w,_ := strconv.Atoi(s[3])\n  return x,y,z,w\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.1.2\"\n+/\n\nimport std.stdio, std.datetime, std.range, std.algorithm, std.conv;\n\n// import dcomp.scanner, dcomp.numeric, dcomp.algorithm, dcomp.array;\n\nint[4] normalize(int[4] x) {\n    int[4] res = x[].rotator.minPos!((a, b) => cmp(a, b) == -1).front.array;\n    return res;\n}\n\n//duplicate number\nint num(int[4] x) {\n    return x[].rotator.count!(a => equal(a, x[])).to!int;\n}\n\nlong F(int n, int k) {\n    if (n < k || n < 0) return 0;\n    //n, n-1, ..., n-k+1\n    return iota(n, n-k, -1).reduce!\"a*b\";\n}\n\nint[4][] col;\nint[int[4]] colMp;\n\nlong cnt(int a, int b, int[4][4] x) {\n    //[0,,a)\n    colMp[col[b]]--;\n    int[int[4]] mp;\n    x.each!(a => mp[a]++);\n    long ans = 1;\n    foreach (v, k; mp) {\n        if (!(v in colMp)) {\n            ans = 0;\n            continue;\n        }\n        int n = colMp[v];\n        int m = num(v);\n        //nからk個選ぶ,それぞれ重複度m\n        ans *= pow(m, k);\n        ans *= F(n, k);\n    }\n    \n    colMp[col[b]]++;\n    return ans;\n}\n\nint main(string[] argv) {\n    int[4] test;\n    Scanner sc = new Scanner();\n    int n;\n    sc.read(n);\n    col = new int[4][](n);\n    foreach (ref v; col) {\n        sc.read(v);\n        v = v.normalize;\n    }\n\n    long ans = 0;\n    foreach (i; 0..n) {\n        foreach (j; 0..i) {\n            int[4] a = col[i], right = col[j];\n            foreach (b; right[].rotator) {\n                int[4][4] x;\n                x[0] = [a[1], a[0], b[1], b[0]];\n                x[1] = [a[2], a[1], b[0], b[3]];\n                x[2] = [a[3], a[2], b[3], b[2]];\n                x[3] = [a[0], a[3], b[2], b[1]];\n                x[].each!((ref a) => a = a.normalize);\n                ans += cnt(i, j, x);\n            }\n        }\n        colMp[col[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n// import dcomp.memory;\n\nstruct FastAppender(A, bool useMyPool = false) {\n    @disable this(this); //this is not reference type(don't copy!)\n\n    import std.algorithm : max;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private size_t len, cap;\n\n    this(T[]* arr) {\n        _data = (*arr).ptr;\n        len = (*arr).length;\n        cap = (*arr).length;\n    }\n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n\n        void* nx;\n        if (useMyPool) {\n            nx = nowPool.malloc(nlen * T.sizeof);\n        } else {\n            nx = GC.malloc(nlen * T.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);\n        }\n        cap = nlen;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(4, cap*2));\n        }\n        _data[len++] = item;\n    }\n    void clear() {\n        len = 0;\n    }\n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\nT[N] toStaticArray(T, int N)(T[N] a) {return a;}\nbool cmpStaticArray(T, int N)(in T[N] a, in T[N] b) {\n    foreach (i; 0..N) {\n        if (a[i] != b[i]) return a[i] < b[i];\n    }\n    return false;\n}\n\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/memory.d */\n// module dcomp.memory;\n\nMemoryPool _nowPool;\n\n@property void nowPool(MemoryPool newPool) {\n    _nowPool = newPool;\n}\n@property MemoryPool nowPool() {\n    return _nowPool;\n}\n\nclass MemoryPool {\n    import core.memory : GC;\n    import std.algorithm : max;\n\n    static immutable Allign = 16;\n    GC.BlkInfo[] blks;\n    size_t e, idx, pos;\n    this(size_t e) {\n        this.e = e;\n        idx = pos = 0;\n    }\n    void assign(size_t sz) {\n        blks ~= GC.qalloc(sz);\n    }\n    void* malloc(size_t sz) {   \n        sz = (sz + Allign-1) / Allign * Allign;\n        while (idx < blks.length && blks[idx].size < pos + sz) {\n            idx++; pos = 0;\n        }\n\n        if (idx == blks.length) {\n            assign(max(e, sz)); pos = 0;\n        }\n        pos += sz;\n        assert(pos <= blks[idx].size);\n        return cast(void *)(cast(byte *)(blks[idx].base) + pos - sz);\n    }\n    void allFree() {\n        idx = pos = 0;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nimport std.range.primitives;\n\nRotator!Range rotator(Range)(Range r)\nif (isForwardRange!Range && hasLength!Range) {\n    return typeof(return)(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric.d */\n// module dcomp.numeric;\n\n\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\nT pow(T, U)(T x, U n) {\n    return pow(x, n, T(1));\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd, abs;\n    return a / gcd(a,b) * b;\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(T a, T b) {\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nstruct ModInt(uint MD) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (v%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make((v.to!long*r.v%MD).to!uint);}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n// f([10]) = [1*] \n// &演算での畳み込みを内積に変換する\nT[] zeta(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            if (!rev) {\n                v[i] += v[i|(1<<fe)];\n            } else {\n                v[i] -= v[i|(1<<fe)];\n            }\n        }\n    }\n    return v;\n}\n\n// xor演算での畳み込みを内積に変換する、サイズ2のFFT\nT[] hadamard(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            auto l = v[i], r = v[i|(1<<fe)];\n            if (!rev) {\n                v[i] = l+r;\n                v[i|(1<<fe)] = l-r;\n            } else {\n                v[i] = (l+r)/2;\n                v[i|(1<<fe)] = (l-r)/2;\n            }\n        }\n    }\n    return v;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv, std.array, std.algorithm, std.string;\nimport std.math, std.random, std.range, std.datetime;\nimport std.bigint;\n\nclass Face{\n\tint[] colors;\n\tint[][] colorAlts;\n\tulong count;\n\tint weight;\n\tstring key;\n\tthis(int[] x){\n\t\tcount = 1;\n\t\tcolors = x.toPreKey;\n\t\tkey = colors.toKey;\n\t\tweight = key.weight;\n\t\tif(weight == 4) colorAlts = [colors];\n\t\tif(weight == 2) colorAlts = [colors, colors[1 .. 4] ~ colors[0 .. 1]];\n\t\tif(weight == 1) colorAlts = [colors, colors[1 .. 4] ~ colors[0 .. 1],\n\t\t\t\tcolors[2 .. 4] ~ colors[0 .. 2], colors[3 .. 4] ~ colors[0 .. 3]];\n\t\t}\n\tdebug string toString(){\n\t\treturn weight.to!string ~ \" [\" ~ key ~ \"] \" ~ count.to!string;\n\t\t}\n\t}\nFace[string] cset;\n\nvoid main(){\n\tint n = readln.chomp.to!int;\n\t\n\tforeach(i; 0 .. n){\n\t\tint[] x = readln.chomp.split.map!(to!int).array;\n\t\tstring k = x.toKey;\n\t\tif(k in cset) cset[k].count += 1;\n\t\telse cset[k] = new Face(x);\n\t\t}\n\t\n\tdebug cset.values.map!(f => f.toString).join(\"\\n\").writeln;\n\t\n\tcset.rehash;\n\t\n\tulong ans = 0;\n\tforeach(a; cset.values){\n\t\tforeach(b; cset.values){\n\t\t\tforeach(cs; b.colorAlts){\n\t\t\t\tans += fn(a.colors, cs, a, b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tans /= 6;\n\tans.writeln;\n\t\n\t}\n\nint[] toPreKey(int[] x){\n\twhile(x[0] > x[1] || x[0] > x[2] || x[0] > x[3]) x = x[1 .. $] ~ x[0];\n\tif(x[0] == x[3]) x = x[3] ~ x[0 .. 3];\n\tif(x[0] == x[3]) x = x[3] ~ x[0 .. 3];\n\tif(x[0] == x[3]) x = x[3] ~ x[0 .. 3];\n\tif(x[0] == x[2] && x[1] > x[3]) x = x[2 .. 4] ~ x[0 .. 2];\n\treturn x;\n\t}\nstring toKey(int[] x){\n\treturn x.toPreKey.map!(to!string).join(\" \");\n\t}\n\nint weight(string k){\n\tint[] x = k.split.map!(to!int).array;\n\tif(x[0] == x[2] && x[1] == x[3]){\n\t\tif(x[0] == x[1]) return 4; else return 2;\n\t\t}\n\telse return 1;\n\t}\n\nulong fn(int[] x, int[] y, Face a, Face b){\n\tstring[] ks = [\n\t\t[x[0], y[0], y[3], x[1]].toKey,\n\t\t[x[1], y[3], y[2], x[2]].toKey,\n\t\t[x[2], y[2], y[1], x[3]].toKey,\n\t\t[x[3], y[1], y[0], x[0]].toKey\n\t\t];\n\tforeach(k; ks) if(!(k in cset)) return 0;\n\tFace[] fs = [a, b] ~ ks.map!(k => cset[k]).array;\n\t\n\tulong[] ns = fs.map!(f => f.count).array;\n\t\n\tforeach(i, f; fs) foreach(ii, ff; fs){\n\t\tif(i < ii) if(f.key == ff.key){\n\t\t\tns[ii] -= 1;\n\t\t\tif(ns[ii] <= 0) return 0;\n\t\t\t}\n\t\t}\n\t\n\tulong ans = 1;\n\tforeach(i, f; fs) ans *= ns[i] * f.weight;\n\tans /= fs[0].weight;\n\t\n\tdebug if(ans > 0){\n\t\twriteln(x, \" \", y);\n\t\twriteln(ns, \" \", ans);\n\t\t}\n\t\n\treturn ans;\n\t\n\t}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.1.2\"\n+/\n\nimport std.stdio, std.datetime, std.range, std.algorithm, std.conv;\n\n// import dcomp.scanner, dcomp.numeric, dcomp.algorithm, dcomp.array;\n\nint[4] normalize(int[4] x) {\n    int[4] res = x[].rotator.minPos!((a, b) => cmp(a, b) == -1).front.array;\n    return res;\n}\n\n//duplicate number\nint num(int[4] x) {\n    return x[].rotator.count!(a => equal(a, x[])).to!int;\n}\n\nlong F(int n, int k) {\n    if (n < k || n < 0) return 0;\n    //n, n-1, ..., n-k+1\n    return iota!long(n, n-k, -1).reduce!\"a*b\";\n}\n\nint[4][] col;\nint[int[4]] colMp;\n\nlong cnt(int a, int b, int[4][4] x) {\n    //[0,,a)\n    colMp[col[b]]--;\n    int[int[4]] mp;\n    x.each!(a => mp[a]++);\n    long ans = 1;\n    foreach (v, k; mp) {\n        if (!(v in colMp)) {\n            ans = 0;\n            continue;\n        }\n        int n = colMp[v];\n        int m = num(v);\n        //nからk個選ぶ,それぞれ重複度m\n        ans *= pow(m, k);\n        ans *= F(n, k);\n    }\n    \n    colMp[col[b]]++;\n    return ans;\n}\n\nint main(string[] argv) {\n    int[4] test;\n    Scanner sc = new Scanner();\n    int n;\n    sc.read(n);\n    col = new int[4][](n);\n    foreach (ref v; col) {\n        sc.read(v);\n        v = v.normalize;\n    }\n\n    long ans = 0;\n    foreach (i; 0..n) {\n        foreach (j; 0..i) {\n            int[4] a = col[i], right = col[j];\n            foreach (b; right[].rotator) {\n                int[4][4] x;\n                x[0] = [a[1], a[0], b[1], b[0]];\n                x[1] = [a[2], a[1], b[0], b[3]];\n                x[2] = [a[3], a[2], b[3], b[2]];\n                x[3] = [a[0], a[3], b[2], b[1]];\n                x[].each!((ref a) => a = a.normalize);\n                ans += cnt(i, j, x);\n            }\n        }\n        colMp[col[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n// import dcomp.memory;\n\nstruct FastAppender(A, bool useMyPool = false) {\n    @disable this(this); //this is not reference type(don't copy!)\n\n    import std.algorithm : max;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private size_t len, cap;\n\n    this(T[]* arr) {\n        _data = (*arr).ptr;\n        len = (*arr).length;\n        cap = (*arr).length;\n    }\n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n\n        void* nx;\n        if (useMyPool) {\n            nx = nowPool.malloc(nlen * T.sizeof);\n        } else {\n            nx = GC.malloc(nlen * T.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);\n        }\n        cap = nlen;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(4, cap*2));\n        }\n        _data[len++] = item;\n    }\n    void clear() {\n        len = 0;\n    }\n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\nT[N] toStaticArray(T, int N)(T[N] a) {return a;}\nbool cmpStaticArray(T, int N)(in T[N] a, in T[N] b) {\n    foreach (i; 0..N) {\n        if (a[i] != b[i]) return a[i] < b[i];\n    }\n    return false;\n}\n\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/memory.d */\n// module dcomp.memory;\n\nMemoryPool _nowPool;\n\n@property void nowPool(MemoryPool newPool) {\n    _nowPool = newPool;\n}\n@property MemoryPool nowPool() {\n    return _nowPool;\n}\n\nclass MemoryPool {\n    import core.memory : GC;\n    import std.algorithm : max;\n\n    static immutable Allign = 16;\n    GC.BlkInfo[] blks;\n    size_t e, idx, pos;\n    this(size_t e) {\n        this.e = e;\n        idx = pos = 0;\n    }\n    void assign(size_t sz) {\n        blks ~= GC.qalloc(sz);\n    }\n    void* malloc(size_t sz) {   \n        sz = (sz + Allign-1) / Allign * Allign;\n        while (idx < blks.length && blks[idx].size < pos + sz) {\n            idx++; pos = 0;\n        }\n\n        if (idx == blks.length) {\n            assign(max(e, sz)); pos = 0;\n        }\n        pos += sz;\n        assert(pos <= blks[idx].size);\n        return cast(void *)(cast(byte *)(blks[idx].base) + pos - sz);\n    }\n    void allFree() {\n        idx = pos = 0;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nimport std.range.primitives;\n\nRotator!Range rotator(Range)(Range r)\nif (isForwardRange!Range && hasLength!Range) {\n    return typeof(return)(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric.d */\n// module dcomp.numeric;\n\n\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\nT pow(T, U)(T x, U n) {\n    return pow(x, n, T(1));\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd, abs;\n    return a / gcd(a,b) * b;\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(T a, T b) {\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nstruct ModInt(uint MD) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (v%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make((v.to!long*r.v%MD).to!uint);}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n// f([10]) = [1*] \n// &演算での畳み込みを内積に変換する\nT[] zeta(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            if (!rev) {\n                v[i] += v[i|(1<<fe)];\n            } else {\n                v[i] -= v[i|(1<<fe)];\n            }\n        }\n    }\n    return v;\n}\n\n// xor演算での畳み込みを内積に変換する、サイズ2のFFT\nT[] hadamard(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            auto l = v[i], r = v[i|(1<<fe)];\n            if (!rev) {\n                v[i] = l+r;\n                v[i|(1<<fe)] = l-r;\n            } else {\n                v[i] = (l+r)/2;\n                v[i|(1<<fe)] = (l-r)/2;\n            }\n        }\n    }\n    return v;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv, std.array, std.algorithm, std.string;\nimport std.math, std.random, std.range, std.datetime;\nimport std.bigint;\n\nint[][string] cset;\nint[][] cs;\n\nvoid main(){\n\tint n = readln.chomp.to!int;\n\t\n\tforeach(i; 0 .. n){\n\t\tint[] x = readln.chomp.split.map!(to!int).array;\n\t\tcs ~= x;\n\t\tcset[x.map!(to!string).join(\" \")] ~= i;\n\t\tx = x[1 .. $] ~ x[0];\n\t\tcset[x.map!(to!string).join(\" \")] ~= i;\n\t\tx = x[1 .. $] ~ x[0];\n\t\tcset[x.map!(to!string).join(\" \")] ~= i;\n\t\tx = x[1 .. $] ~ x[0];\n\t\tcset[x.map!(to!string).join(\" \")] ~= i;\n\t\t}\n\t\n\tdebug cset.writeln;\n\t\n\tcset.rehash;\n\t\n\tBigInt ans = 0;\n\tforeach(i; 0 .. n){\n\t\tint[] x = cs[i];\n\t\tforeach(j; 0 .. n){\n\t\t\tint[] y = cs[j] ~ [];\n\t\t\tans += fn(x, y, i, j);\n\t\t\ty = y[1 .. $] ~ y[0];\n\t\t\tans += fn(x, y, i, j);\n\t\t\ty = y[1 .. $] ~ y[0];\n\t\t\tans += fn(x, y, i, j);\n\t\t\ty = y[1 .. $] ~ y[0];\n\t\t\tans += fn(x, y, i, j);\n\t\t\t}\n\t\t}\n\t\n\tans /= 6;\n\tans.writeln;\n\t}\n\nBigInt fn(int[] x, int[] y, int i, int j){\n\tif(i == j) return BigInt(0);\n\tBigInt ans;\n\tint[] u;\n\tint[] ps0, ps1, ps2, ps3;\n\tu = [x[0], y[0], y[3], x[1]];\n\tif(u.map!(to!string).join(\" \") in cset) ps0 = cset[u.map!(to!string).join(\" \")];\n\telse return BigInt(0);\n\tu = [x[1], y[3], y[2], x[2]];\n\tif(u.map!(to!string).join(\" \") in cset) ps1 = cset[u.map!(to!string).join(\" \")];\n\telse return BigInt(0);\n\tu = [x[2], y[2], y[1], x[3]];\n\tif(u.map!(to!string).join(\" \") in cset) ps2 = cset[u.map!(to!string).join(\" \")];\n\telse return BigInt(0);\n\tu = [x[3], y[1], y[0], x[0]];\n\tif(u.map!(to!string).join(\" \") in cset) ps3 = cset[u.map!(to!string).join(\" \")];\n\telse return BigInt(0);\n\t\n\tif(i == j) ans = 0;\n\telse foreach(p0; ps0){\n\t\tif(i == p0) continue;\n\t\tif(j == p0) continue;\n\t\tforeach(p1; ps1){\n\t\t\tif(i == p1) continue;\n\t\t\tif(j == p1) continue;\n\t\t\tif(p0 == p1) continue;\n\t\t\tforeach(p2; ps2){\n\t\t\t\tif(i == p2) continue;\n\t\t\t\tif(j == p2) continue;\n\t\t\t\tif(p0 == p2) continue;\n\t\t\t\tif(p1 == p2) continue;\n\t\t\t\tforeach(p3; ps3){\n\t\t\t\t\tif(i == p3) continue;\n\t\t\t\t\tif(j == p3) continue;\n\t\t\t\t\tif(p0 == p3) continue;\n\t\t\t\t\tif(p1 == p3) continue;\n\t\t\t\t\tif(p2 == p3) continue;\n\t\t\t\t\t\n\t\t\t\t\tans += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tdebug if(ans > 0) writeln(x, \" \", y, \" \", i, \" \", j, \" \", ans);\n\treturn ans;\n\t}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.1.2\"\n+/\n\nimport std.stdio, std.datetime, std.range, std.algorithm, std.conv;\n\n// import dcomp.scanner, dcomp.matrix, dcomp.numeric;\n\nalias Mint = ModInt!(10^^9 + 7);\n\nint[4] normalize(int[4] x) {\n    auto mi = x;\n    foreach (i; 0..4) {\n        mi = min(mi, x);\n        bringToFront(x[0..1], x[1..4]);\n    }\n    return mi;\n}\n\n//duplicate number\nint num(int[4] x) {\n    auto y = x;\n    int co = 0;\n    foreach (i; 0..4) {\n        if (x == y) co++;\n        bringToFront(y[0..1], y[1..$]);\n    }\n    return co;\n}\n\nint[4][] col;\n\nint[int[4]] colMp;\n\nlong F(int n, int k) {\n    if (n < k || n < 0) return 0;\n    long ans = 1;\n    foreach (i; 0..k) {\n        ans *= n-i;\n    }\n    return ans;\n}\nlong cnt(int a, int b, int[4][4] x) {\n    //[0,,a)\n    colMp[col[b]]--;\n    int[int[4]] mp;\n    x.each!(a => mp[a]++);\n    long ans = 1;\n    foreach (v, k; mp) {\n        if (!(v in colMp)) {\n            ans = 0;\n            continue;\n        }\n        int n = colMp[v];\n        int m = num(v);\n        //nからk個選ぶ,それぞれ重複度m\n        ans *= pow(m, k);\n        ans *= F(n, k);\n    }\n    \n    colMp[col[b]]++;\n    return ans;\n}\nint main(string[] argv) {\n    Scanner sc = new Scanner();\n    int n;\n    sc.read(n);\n    col = new int[4][](n);\n    foreach (ref v; col) {\n        sc.read(v);\n        v = v.normalize;\n    }\n\n    long ans = 0;\n    foreach (i; 0..n) {\n        foreach (j; 0..i) {\n            int[4] a = col[i], b = col[j];\n            foreach (d; 0..4) {\n                int[4][4] x;\n                x[0] = [a[1], a[0], b[1], b[0]];\n                x[1] = [a[2], a[1], b[0], b[3]];\n                x[2] = [a[3], a[2], b[3], b[2]];\n                x[3] = [a[0], a[3], b[2], b[1]];\n                x[].each!((ref a) => a = a.normalize);\n                ans += cnt(i, j, x);\n                bringToFront(b[0..1], b[1..4]);\n            }\n        }\n        colMp[col[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/matrix.d */\n// module dcomp.matrix;\n\nstruct SMatrix(T, size_t H, size_t W) {\n    T[W][H] data;\n    this(Args...)(Args args) {\n        static assert(args.length == H*W);\n        foreach (i, v; args) {\n            data[i/W][i%W] = v;\n        }\n    }\n\n    @property static size_t height() {return H;}\n    @property static size_t width() {return W;}\n\n    auto ref opIndex(size_t i1, size_t i2) {\n        return data[i1][i2];\n    }\n    auto opBinary(string op:\"+\", R)(R r)\n    if(height == R.height && width == R.width) {\n        auto res = this;\n        foreach (y; 0..height) foreach (x; 0..W) res[y, x] += r[y, x];\n        return res;\n    }\n    auto opBinary(string op:\"*\", R)(R r)\n    if(width == R.height) {\n        auto res = SMatrix!(T, height, R.width)();\n        foreach (y; 0..height) {\n            foreach (x; 0..R.width) {\n                foreach (k; 0..width) {\n                    res[y, x] += this[y, k]*r[k, x];\n                }\n            }\n        }\n        return res;\n    }\n    auto opOpAssign(string op, T)(T r) {return mixin (\"this=this\"~op~\"r\");}    \n}\n\nauto matrix(size_t H, size_t W, alias pred)() {\n    import std.traits : ReturnType;\n    SMatrix!(typeof(pred(0, 0)), H, W) res;\n    foreach (y; 0..H) {\n        foreach (x; 0..W) {\n            res[y, x] = pred(y, x);\n        }\n    }\n    return res;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric.d */\n// module dcomp.numeric;\n\n\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\nT pow(T, U)(T x, U n) {\n    return pow(x, n, T(1));\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd, abs;\n    return a / gcd(a,b) * b;\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(T a, T b) {\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nstruct ModInt(uint MD) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (v%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make((v.to!long*r.v%MD).to!uint);}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n// f([10]) = [1*] \n// &演算での畳み込みを内積に変換する\nT[] zeta(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            if (!rev) {\n                v[i] += v[i|(1<<fe)];\n            } else {\n                v[i] -= v[i|(1<<fe)];\n            }\n        }\n    }\n    return v;\n}\n\n// xor演算での畳み込みを内積に変換する、サイズ2のFFT\nT[] hadamard(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            auto l = v[i], r = v[i|(1<<fe)];\n            if (!rev) {\n                v[i] = l+r;\n                v[i|(1<<fe)] = l-r;\n            } else {\n                v[i] = (l+r)/2;\n                v[i|(1<<fe)] = (l-r)/2;\n            }\n        }\n    }\n    return v;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.1.2\"\n+/\n\nimport std.stdio, std.datetime, std.range, std.algorithm, std.conv;\nimport std.algorithm.iteration : fold;\n\n// import dcomp.scanner, dcomp.numeric, dcomp.algorithm, dcomp.array;\n\nint[4] normalize(int[4] x) {\n    int[4] res = x[].rotator.minPos!((a, b) => cmp(a, b) == -1).front.array;\n    return res;\n}\n\n//duplicate number\nint num(int[4] x) {\n    return x[].rotator.count!(a => equal(a, x[])).to!int;\n}\n\nint[4][] col;\n\nint[int[4]] colMp;\n\nlong F(int n, int k) {\n    if (n < k || n < 0) return 0;\n    //n, n-1, ..., n-k+1\n    return iota(n, n-k, -1).reduce!\"a*b\";\n}\n\nlong cnt(int a, int b, int[4][4] x) {\n    //[0,,a)\n    colMp[col[b]]--;\n    int[int[4]] mp;\n    x.each!(a => mp[a]++);\n    long ans = 1;\n    foreach (v, k; mp) {\n        if (!(v in colMp)) {\n            ans = 0;\n            continue;\n        }\n        int n = colMp[v];\n        int m = num(v);\n        //nからk個選ぶ,それぞれ重複度m\n        ans *= pow(m, k);\n        ans *= F(n, k);\n    }\n    \n    colMp[col[b]]++;\n    return ans;\n}\n\nint main(string[] argv) {\n\n    int[4] test;\n    Scanner sc = new Scanner();\n    int n;\n    sc.read(n);\n    col = new int[4][](n);\n    foreach (ref v; col) {\n        sc.read(v);\n        v = v.normalize;\n    }\n\n    long ans = 0;\n    foreach (i; 0..n) {\n        foreach (j; 0..i) {\n            int[4] a = col[i], right = col[j];\n            foreach (b; right[].rotator) {\n                int[4][4] x;\n                x[0] = [a[1], a[0], b[1], b[0]];\n                x[1] = [a[2], a[1], b[0], b[3]];\n                x[2] = [a[3], a[2], b[3], b[2]];\n                x[3] = [a[0], a[3], b[2], b[1]];\n                x[].each!((ref a) => a = a.normalize);\n                ans += cnt(i, j, x);\n            }\n        }\n        colMp[col[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n// import dcomp.memory;\n\nstruct FastAppender(A, bool useMyPool = false) {\n    @disable this(this); //this is not reference type(don't copy!)\n\n    import std.algorithm : max;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private size_t len, cap;\n\n    this(T[]* arr) {\n        _data = (*arr).ptr;\n        len = (*arr).length;\n        cap = (*arr).length;\n    }\n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n\n        void* nx;\n        if (useMyPool) {\n            nx = nowPool.malloc(nlen * T.sizeof);\n        } else {\n            nx = GC.malloc(nlen * T.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);\n        }\n        cap = nlen;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(4, cap*2));\n        }\n        _data[len++] = item;\n    }\n    void clear() {\n        len = 0;\n    }\n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\nT[N] toStaticArray(T, int N)(T[N] a) {return a;}\nbool cmpStaticArray(T, int N)(in T[N] a, in T[N] b) {\n    foreach (i; 0..N) {\n        if (a[i] != b[i]) return a[i] < b[i];\n    }\n    return false;\n}\n\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/memory.d */\n// module dcomp.memory;\n\nMemoryPool _nowPool;\n\n@property void nowPool(MemoryPool newPool) {\n    _nowPool = newPool;\n}\n@property MemoryPool nowPool() {\n    return _nowPool;\n}\n\nclass MemoryPool {\n    import core.memory : GC;\n    import std.algorithm : max;\n\n    static immutable Allign = 16;\n    GC.BlkInfo[] blks;\n    size_t e, idx, pos;\n    this(size_t e) {\n        this.e = e;\n        idx = pos = 0;\n    }\n    void assign(size_t sz) {\n        blks ~= GC.qalloc(sz);\n    }\n    void* malloc(size_t sz) {   \n        sz = (sz + Allign-1) / Allign * Allign;\n        while (idx < blks.length && blks[idx].size < pos + sz) {\n            idx++; pos = 0;\n        }\n\n        if (idx == blks.length) {\n            assign(max(e, sz)); pos = 0;\n        }\n        pos += sz;\n        assert(pos <= blks[idx].size);\n        return cast(void *)(cast(byte *)(blks[idx].base) + pos - sz);\n    }\n    void allFree() {\n        idx = pos = 0;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nimport std.range.primitives;\n\nRotator!Range rotator(Range)(Range r)\nif (isForwardRange!Range && hasLength!Range) {\n    return typeof(return)(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric.d */\n// module dcomp.numeric;\n\n\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\nT pow(T, U)(T x, U n) {\n    return pow(x, n, T(1));\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd, abs;\n    return a / gcd(a,b) * b;\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(T a, T b) {\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nstruct ModInt(uint MD) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (v%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make((v.to!long*r.v%MD).to!uint);}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n// f([10]) = [1*] \n// &演算での畳み込みを内積に変換する\nT[] zeta(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            if (!rev) {\n                v[i] += v[i|(1<<fe)];\n            } else {\n                v[i] -= v[i|(1<<fe)];\n            }\n        }\n    }\n    return v;\n}\n\n// xor演算での畳み込みを内積に変換する、サイズ2のFFT\nT[] hadamard(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            auto l = v[i], r = v[i|(1<<fe)];\n            if (!rev) {\n                v[i] = l+r;\n                v[i|(1<<fe)] = l-r;\n            } else {\n                v[i] = (l+r)/2;\n                v[i|(1<<fe)] = (l-r)/2;\n            }\n        }\n    }\n    return v;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.1.2\"\n+/\n\nimport std.stdio, std.datetime, std.range, std.algorithm, std.conv;\n\n// import dcomp.scanner, dcomp.numeric, dcomp.algorithm;\n\nint[4] normalize(int[4] x) {\n    int[4] res = x[].rotator.minPos!((a, b) => cmp(a, b) == -1).front.array;\n    return res;\n}\n\n//duplicate number\nint num(int[4] x) {\n    return x[].rotator.count!(a => equal(x[], a)).to!int;\n}\n\nint[4][] col;\n\nint[int[4]] colMp;\n\nlong F(int n, int k) {\n    if (n < k || n < 0) return 0;\n    long ans = 1;\n    foreach (i; 0..k) {\n        ans *= n-i;\n    }\n    return ans;\n}\n\nlong cnt(int a, int b, int[4][4] x) {\n    //[0,,a)\n    colMp[col[b]]--;\n    int[int[4]] mp;\n    x.each!(a => mp[a]++);\n    long ans = 1;\n    foreach (v, k; mp) {\n        if (!(v in colMp)) {\n            ans = 0;\n            continue;\n        }\n        int n = colMp[v];\n        int m = num(v);\n        //nからk個選ぶ,それぞれ重複度m\n        ans *= pow(m, k);\n        ans *= F(n, k);\n    }\n    \n    colMp[col[b]]++;\n    return ans;\n}\n\nint main(string[] argv) {\n    int[4] test;\n    Scanner sc = new Scanner();\n    int n;\n    sc.read(n);\n    col = new int[4][](n);\n    foreach (ref v; col) {\n        sc.read(v);\n        v = v.normalize;\n    }\n\n    long ans = 0;\n    foreach (i; 0..n) {\n        foreach (j; 0..i) {\n            int[4] a = col[i], b = col[j];\n            foreach (d; 0..4) {\n                int[4][4] x;\n                x[0] = [a[1], a[0], b[1], b[0]];\n                x[1] = [a[2], a[1], b[0], b[3]];\n                x[2] = [a[3], a[2], b[3], b[2]];\n                x[3] = [a[0], a[3], b[2], b[1]];\n                x[].each!((ref a) => a = a.normalize);\n                ans += cnt(i, j, x);\n                bringToFront(b[0..1], b[1..4]);\n            }\n        }\n        colMp[col[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nimport std.range.primitives;\n\nRotator!Range rotator(Range)(Range r)\nif (isForwardRange!Range && hasLength!Range) {\n    return typeof(return)(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric.d */\n// module dcomp.numeric;\n\n\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\nT pow(T, U)(T x, U n) {\n    return pow(x, n, T(1));\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd, abs;\n    return a / gcd(a,b) * b;\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(T a, T b) {\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nstruct ModInt(uint MD) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (v%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make((v.to!long*r.v%MD).to!uint);}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n// f([10]) = [1*] \n// &演算での畳み込みを内積に変換する\nT[] zeta(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            if (!rev) {\n                v[i] += v[i|(1<<fe)];\n            } else {\n                v[i] -= v[i|(1<<fe)];\n            }\n        }\n    }\n    return v;\n}\n\n// xor演算での畳み込みを内積に変換する、サイズ2のFFT\nT[] hadamard(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            auto l = v[i], r = v[i|(1<<fe)];\n            if (!rev) {\n                v[i] = l+r;\n                v[i|(1<<fe)] = l-r;\n            } else {\n                v[i] = (l+r)/2;\n                v[i|(1<<fe)] = (l-r)/2;\n            }\n        }\n    }\n    return v;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.1.2\"\n+/\n\nimport std.stdio, std.datetime, std.range, std.algorithm, std.conv;\n\n// import dcomp.scanner, dcomp.numeric, dcomp.algorithm, dcomp.array;\n\nint[4] normalize(int[4] x) {\n    int[4] res = x[].rotator.minPos!((a, b) => cmp(a, b) == -1).front.array;\n    return res;\n}\n\n//duplicate number\nint num(int[4] x) {\n    return x[].rotator.count!(a => equal(a, x[])).to!int;\n}\n\nint[4][] col;\n\nint[int[4]] colMp;\n\nlong F(int n, int k) {\n    if (n < k || n < 0) return 0;\n    //n, n-1, ..., n-k+1\n    return iota(n, n-k, -1).fold!\"a*b\";\n}\n\nlong cnt(int a, int b, int[4][4] x) {\n    //[0,,a)\n    colMp[col[b]]--;\n    int[int[4]] mp;\n    x.each!(a => mp[a]++);\n    long ans = 1;\n    foreach (v, k; mp) {\n        if (!(v in colMp)) {\n            ans = 0;\n            continue;\n        }\n        int n = colMp[v];\n        int m = num(v);\n        //nからk個選ぶ,それぞれ重複度m\n        ans *= pow(m, k);\n        ans *= F(n, k);\n    }\n    \n    colMp[col[b]]++;\n    return ans;\n}\n\nint main(string[] argv) {\n    int[4] test;\n    Scanner sc = new Scanner();\n    int n;\n    sc.read(n);\n    col = new int[4][](n);\n    foreach (ref v; col) {\n        sc.read(v);\n        v = v.normalize;\n    }\n\n    long ans = 0;\n    foreach (i; 0..n) {\n        foreach (j; 0..i) {\n            int[4] a = col[i], right = col[j];\n            foreach (b; right[].rotator) {\n                int[4][4] x;\n                x[0] = [a[1], a[0], b[1], b[0]];\n                x[1] = [a[2], a[1], b[0], b[3]];\n                x[2] = [a[3], a[2], b[3], b[2]];\n                x[3] = [a[0], a[3], b[2], b[1]];\n                x[].each!((ref a) => a = a.normalize);\n                ans += cnt(i, j, x);\n            }\n        }\n        colMp[col[i]]++;\n    }\n    writeln(ans);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n// import dcomp.memory;\n\nstruct FastAppender(A, bool useMyPool = false) {\n    @disable this(this); //this is not reference type(don't copy!)\n\n    import std.algorithm : max;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private size_t len, cap;\n\n    this(T[]* arr) {\n        _data = (*arr).ptr;\n        len = (*arr).length;\n        cap = (*arr).length;\n    }\n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n\n        void* nx;\n        if (useMyPool) {\n            nx = nowPool.malloc(nlen * T.sizeof);\n        } else {\n            nx = GC.malloc(nlen * T.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);\n        }\n        cap = nlen;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(4, cap*2));\n        }\n        _data[len++] = item;\n    }\n    void clear() {\n        len = 0;\n    }\n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\nT[N] toStaticArray(T, int N)(T[N] a) {return a;}\nbool cmpStaticArray(T, int N)(in T[N] a, in T[N] b) {\n    foreach (i; 0..N) {\n        if (a[i] != b[i]) return a[i] < b[i];\n    }\n    return false;\n}\n\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/memory.d */\n// module dcomp.memory;\n\nMemoryPool _nowPool;\n\n@property void nowPool(MemoryPool newPool) {\n    _nowPool = newPool;\n}\n@property MemoryPool nowPool() {\n    return _nowPool;\n}\n\nclass MemoryPool {\n    import core.memory : GC;\n    import std.algorithm : max;\n\n    static immutable Allign = 16;\n    GC.BlkInfo[] blks;\n    size_t e, idx, pos;\n    this(size_t e) {\n        this.e = e;\n        idx = pos = 0;\n    }\n    void assign(size_t sz) {\n        blks ~= GC.qalloc(sz);\n    }\n    void* malloc(size_t sz) {   \n        sz = (sz + Allign-1) / Allign * Allign;\n        while (idx < blks.length && blks[idx].size < pos + sz) {\n            idx++; pos = 0;\n        }\n\n        if (idx == blks.length) {\n            assign(max(e, sz)); pos = 0;\n        }\n        pos += sz;\n        assert(pos <= blks[idx].size);\n        return cast(void *)(cast(byte *)(blks[idx].base) + pos - sz);\n    }\n    void allFree() {\n        idx = pos = 0;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nimport std.range.primitives;\n\nRotator!Range rotator(Range)(Range r)\nif (isForwardRange!Range && hasLength!Range) {\n    return typeof(return)(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric.d */\n// module dcomp.numeric;\n\n\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\nT pow(T, U)(T x, U n) {\n    return pow(x, n, T(1));\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd, abs;\n    return a / gcd(a,b) * b;\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(T a, T b) {\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nstruct ModInt(uint MD) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this.v = (v%MD+MD)%MD;}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) {return make((v.to!long*r.v%MD).to!uint);}\n    auto opBinary(string op:\"/\")(ModInt r) {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n// f([10]) = [1*] \n// &演算での畳み込みを内積に変換する\nT[] zeta(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            if (!rev) {\n                v[i] += v[i|(1<<fe)];\n            } else {\n                v[i] -= v[i|(1<<fe)];\n            }\n        }\n    }\n    return v;\n}\n\n// xor演算での畳み込みを内積に変換する、サイズ2のFFT\nT[] hadamard(T)(T[] v, bool rev) {\n    import core.bitop : bsr;\n    int n = bsr(v.length);\n    assert(1<<n == v.length);\n    foreach (fe; 0..n) {\n        foreach (i, _; v) {\n            if (i & (1<<fe)) continue;\n            auto l = v[i], r = v[i|(1<<fe)];\n            if (!rev) {\n                v[i] = l+r;\n                v[i|(1<<fe)] = l-r;\n            } else {\n                v[i] = (l+r)/2;\n                v[i|(1<<fe)] = (l-r)/2;\n            }\n        }\n    }\n    return v;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nalias Tuple!(int, \"c1\", int, \"c2\", int, \"c3\", int, \"c4\") Die;\n\n\nDie normalize_die(int a, int b, int c, int d) {\n    auto t1 = Die(a, b, c, d);\n    auto t2 = Die(b, c, d, a);\n    auto t3 = Die(c, d, a, b);\n    auto t4 = Die(d, a, b, c);\n    auto t5 = [t1, t2, t3, t4];\n    t5.sort();\n    return t5[0];\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    bool[int][Die] mem;\n    auto dice = new Die[](N);\n\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!int);\n        auto d = normalize_die(s[0], s[1], s[2], s[3]);\n        mem[d][i] = true;\n        dice[i] = d;\n    }\n\n    long ans = 0;\n    foreach (i; 0..N) {\n        auto d1 = [dice[i].c1, dice[i].c2, dice[i].c3, dice[i].c4];\n        foreach (j; i+1..N) {\n            int c5 = dice[j][0];\n            int c6 = dice[j][1];\n            int c7 = dice[j][2];\n            int c8 = dice[j][3];\n            foreach (k; 0..4) {\n                int c1 = d1[k];\n                int c2 = d1[(k+1)%4];\n                int c3 = d1[(k+2)%4];\n                int c4 = d1[(k+3)%4];\n                auto d = new Die[](4);\n                d[0] = normalize_die(c8, c1, c4, c5);\n                d[1] = normalize_die(c2, c7, c6, c3);\n                d[2] = normalize_die(c8, c7, c2, c1);\n                d[3] = normalize_die(c4, c3, c6, c5);\n                auto a = new int[](4);\n                bool no_such_die = false;\n                foreach (l; 0..4) {\n                    if (!(d[l] in mem)) {\n                        no_such_die = true;\n                        break;\n                    }\n                    a[l] = mem[d[l]].keys.length.to!int;\n                    if (d[l] == dice[i]) a[l] -= 1;\n                    if (d[l] == dice[j]) a[l] -= 1;\n                }\n\n                if (no_such_die)\n                    continue;\n                //d.each!(writeln);\n                //a.writeln;\n\n                foreach (l; 0..4) {\n                    foreach (m; l+1..4) {\n                        if (d[l] == d[m]) a[m] -= 1;\n                    }\n                }\n                //a.writeln;\n\n                foreach (l; 0..4) {\n                    if (d[l].c1 == d[l].c2 && d[l].c2 == d[l].c3 && d[l].c3 == d[l].c4)\n                        a[l] *= 4;\n                    else if (d[l].c1 == d[l].c3 && d[l].c2 == d[l].c4)\n                        a[l] *= 2;\n                    a[l] = max(0, a[l]);\n                }\n\n                ans += a[0] * a[1] * a[2] * a[3];\n            }\n        }\n    }\n\n    writeln(ans/3);\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv, std.array, std.algorithm, std.string;\nimport std.math, std.random, std.range, std.datetime;\nimport std.bigint;\n\nint[string] cset;\nint[][] cs;\n\nvoid main(){\n\tint n = readln.chomp.to!int;\n\t\n\tforeach(i; 0 .. n){\n\t\tint[] x = readln.chomp.split.map!(to!int).array;\n\t\tcset[x.toKey] += 1;\n\t\t}\n\t\n\tdebug cset.writeln;\n\t\n\tcset.rehash;\n\t\n\t\n\tBigInt ans = 0;\n\tforeach(a; cset.keys){\n\t\tint[] x = a.split.map!(to!int).array;\n\t\tforeach(b; cset.keys){\n\t\t\tint[] y = b.split.map!(to!int).array;\n\t\t\tans += fn(x, y);\n\t\t\tif(b.weight < 4){\n\t\t\t\ty = y[1 .. $] ~ y[0];\n\t\t\t\tans += fn(x, y);\n\t\t\t\tif(b.weight < 2){\n\t\t\t\t\ty = y[1 .. $] ~ y[0];\n\t\t\t\t\tans += fn(x, y);\n\t\t\t\t\ty = y[1 .. $] ~ y[0];\n\t\t\t\t\tans += fn(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tans /= 6;\n\tans.writeln;\n\t\n\t}\n\nstring toKey(int[] x){\n\twhile(x[0] > x[1] || x[0] > x[2] || x[0] > x[3]) x = x[1 .. $] ~ x[0];\n\tif(x[0] == x[3]) x = x[3] ~ x[0 .. 3];\n\tif(x[0] == x[3]) x = x[3] ~ x[0 .. 3];\n\tif(x[0] == x[3]) x = x[3] ~ x[0 .. 3];\n\tif(x[0] == x[2] && x[1] > x[3]) x = x[2 .. 4] ~ x[0 .. 2];\n\t\n\treturn x.map!(to!string).join(\" \");\n\t}\n\nint weight(string k){\n\tint[] x = k.split.map!(to!int).array;\n\tif(x[0] == x[2] && x[1] == x[3]){\n\t\tif(x[0] == x[1]) return 4; else return 2;\n\t\t}\n\telse return 1;\n\t}\n\nBigInt fn(int[] x, int[] y){\n\tstring[] ks = [\n\t\tx.toKey,\n\t\ty.toKey,\n\t\t[x[0], y[0], y[3], x[1]].toKey,\n\t\t[x[1], y[3], y[2], x[2]].toKey,\n\t\t[x[2], y[2], y[1], x[3]].toKey,\n\t\t[x[3], y[1], y[0], x[0]].toKey\n\t\t];\n\tforeach(k; ks) if(!(k in cset)) return BigInt(0);\n\t\n\tBigInt[] ns = ks.map!(k => BigInt(cset[k])).array;\n\t\n\tforeach(i, k; ks) foreach(ii, kk; ks){\n\t\tif(k == kk) if(i < ii){\n\t\t\tns[ii] -= 1;\n\t\t\tif(ns[ii] <= 0) return BigInt(0);\n\t\t\t}\n\t\t}\n\t\n\tBigInt ans = 1;\n\tforeach(i, k; ks) ans *= ns[i] * k.weight;\n\tans /= ks[0].weight;\n\t\n\tdebug if(ans > 0){\n\t\twriteln(x, \" \", y);\n\t\twriteln(ks);\n\t\twriteln(ns, \" \", ans);\n\t\t}\n\t\n\treturn ans;\n\t\n\t}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nalias Tuple!(int, \"c1\", int, \"c2\", int, \"c3\", int, \"c4\") Die;\n\n\nDie normalize_die(int a, int b, int c, int d) {\n    auto t1 = Die(a, b, c, d);\n    auto t2 = Die(b, c, d, a);\n    auto t3 = Die(c, d, a, b);\n    auto t4 = Die(d, a, b, c);\n    auto t5 = [t1, t2, t3, t4];\n    t5.sort();\n    return t5[0];\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    bool[int][Die] mem;\n    auto dice = new Die[](N);\n\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!int);\n        auto d = normalize_die(s[0], s[1], s[2], s[3]);\n        mem[d][i] = true;\n        dice[i] = d;\n    }\n\n    long ans = 0;\n    foreach (i; 0..N) {\n        auto d1 = [dice[i].c1, dice[i].c2, dice[i].c3, dice[i].c4];\n        foreach (j; i+1..N) {\n            int c5 = dice[j][0];\n            int c6 = dice[j][1];\n            int c7 = dice[j][2];\n            int c8 = dice[j][3];\n            foreach (k; 0..4) {\n                int c1 = d1[k];\n                int c2 = d1[(k+1)%4];\n                int c3 = d1[(k+2)%4];\n                int c4 = d1[(k+3)%4];\n                auto d = new Die[](4);\n                d[0] = normalize_die(c8, c1, c4, c5);\n                d[1] = normalize_die(c2, c7, c6, c3);\n                d[2] = normalize_die(c8, c7, c2, c1);\n                d[3] = normalize_die(c4, c3, c6, c5);\n                auto a = new long[](4);\n                bool no_such_die = false;\n                foreach (l; 0..4) {\n                    if (!(d[l] in mem)) {\n                        no_such_die = true;\n                        break;\n                    }\n                    a[l] = mem[d[l]].keys.length.to!long;\n                    if (d[l] == dice[i]) a[l] -= 1;\n                    if (d[l] == dice[j]) a[l] -= 1;\n                }\n\n                if (no_such_die)\n                    continue;\n                //d.each!(writeln);\n                //a.writeln;\n\n                foreach (l; 0..4) {\n                    foreach (m; l+1..4) {\n                        if (d[l] == d[m]) a[m] -= 1;\n                    }\n                }\n                //a.writeln;\n\n                foreach (l; 0..4) {\n                    if (d[l].c1 == d[l].c2 && d[l].c2 == d[l].c3 && d[l].c3 == d[l].c4)\n                        a[l] *= 4;\n                    else if (d[l].c1 == d[l].c3 && d[l].c2 == d[l].c4)\n                        a[l] *= 2;\n                    a[l] = max(0, a[l]);\n                }\n\n                ans += a[0] * a[1] * a[2] * a[3];\n            }\n        }\n    }\n\n    writeln(ans/3);\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nalias Tuple!(int, \"c1\", int, \"c2\", int, \"c3\", int, \"c4\") Die;\n\n\nDie normalize_die(int a, int b, int c, int d) {\n    auto t1 = Die(a, b, c, d);\n    auto t2 = Die(b, c, d, a);\n    auto t3 = Die(c, d, a, b);\n    auto t4 = Die(d, a, b, c);\n    auto t5 = [t1, t2, t3, t4];\n    t5.sort();\n    return t5[0];\n}\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    long[Die] mem;\n    auto dice = new Die[](N);\n\n    foreach (i; 0..N) {\n        auto s = readln.split.map!(to!int);\n        auto d = normalize_die(s[0], s[1], s[2], s[3]);\n        if (d in mem) mem[d] += 1;\n        else mem[d] = 1;\n        dice[i] = d;\n    }\n\n    long ans = 0;\n    foreach (i; 0..N) {\n        auto d1 = [dice[i].c1, dice[i].c2, dice[i].c3, dice[i].c4];\n        foreach (j; i+1..N) {\n            int c5 = dice[j][0];\n            int c6 = dice[j][1];\n            int c7 = dice[j][2];\n            int c8 = dice[j][3];\n            foreach (k; 0..4) {\n                int c1 = d1[k];\n                int c2 = d1[(k+1)%4];\n                int c3 = d1[(k+2)%4];\n                int c4 = d1[(k+3)%4];\n                auto d = new Die[](4);\n                d[0] = normalize_die(c8, c1, c4, c5);\n                d[1] = normalize_die(c2, c7, c6, c3);\n                d[2] = normalize_die(c8, c7, c2, c1);\n                d[3] = normalize_die(c4, c3, c6, c5);\n                auto a = new long[](4);\n                bool no_such_die = false;\n                foreach (l; 0..4) {\n                    if (!(d[l] in mem)) {\n                        no_such_die = true;\n                        break;\n                    }\n                    a[l] = mem[d[l]];\n                    if (d[l] == dice[i]) a[l] -= 1;\n                    if (d[l] == dice[j]) a[l] -= 1;\n                }\n\n                if (no_such_die)\n                    continue;\n                //d.each!(writeln);\n                //a.writeln;\n\n                foreach (l; 0..4) {\n                    foreach (m; l+1..4) {\n                        if (d[l] == d[m]) a[m] -= 1;\n                    }\n                }\n                //a.writeln;\n\n                foreach (l; 0..4) {\n                    if (d[l].c1 == d[l].c2 && d[l].c2 == d[l].c3 && d[l].c3 == d[l].c4)\n                        a[l] *= 4;\n                    else if (d[l].c1 == d[l].c3 && d[l].c2 == d[l].c4)\n                        a[l] *= 2;\n                    a[l] = max(0, a[l]);\n                }\n\n                ans += a[0] * a[1] * a[2] * a[3];\n            }\n        }\n    }\n\n    writeln(ans/3);\n}\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\nproc readInt4*(): (int, int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2], v[3])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype Card = seq[int]\n\nproc `<`(c0, c1: Card): bool =\n  for k in 0..<4:\n    if c0[k] < c1[k]:\n      return true\n    if c0[k] > c1[k]:\n      return false\n  return false\n\nproc normalize(c: Card): Card =\n  let candi0 = @[ c[0], c[1], c[2], c[3] ]\n  let candi1 = @[ c[1], c[2], c[3], c[0] ]\n  let candi2 = @[ c[2], c[3], c[0], c[1] ]\n  let candi3 = @[ c[3], c[0], c[1], c[2] ]\n  return min([candi0, candi1, candi2, candi3])\n\nproc rotate(c: Card): Card = @[ c[3], c[0], c[1], c[2] ]\n\nproc solve(n: int; cs: seq[Card]; top, bottom: Card): int =\n  let side = @[\n    @[ top[0], bottom[3], bottom[2], top[1] ].normalize(),\n    @[ top[1], bottom[2], bottom[1], top[2] ].normalize(),\n    @[ top[2], bottom[1], bottom[0], top[3] ].normalize(),\n    @[ top[3], bottom[0], bottom[3], top[0] ].normalize()\n  ]\n\n  var ans = 1\n  for i in 0..<4:\n    let s = side[i]\n    var sNext = @[ s[0], s[1], s[2], s[3] + 1 ]\n    var cnt = cs.lowerBound(sNext) - cs.lowerBound(s)\n    if s == top.normalize():\n      cnt -= 1\n    if s == bottom.normalize():\n      cnt -= 1\n    for j in 0..<i:\n      if s == side[j]:\n        cnt -= 1\n\n    var k = 1\n    if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n      k = 4\n    if s[0] == s[2] and s[1] == s[3] and s[0] != s[1]:\n      k = 2\n    ans *= k * cnt\n\n  return ans\n\nproc main() =\n  let n = readInt1()\n\n  var cs = newSeq[Card](n)\n  for i in 0..<n:\n    cs[i] = readSeq().map(parseInt).normalize()\n  cs.sort(cmp[Card])\n\n  var ans = 0\n  for i in 0..<n:\n    for j in 0..<n:\n      if i == j:\n        continue\n      ans += solve(n, cs, cs[i], cs[j])\n      ans += solve(n, cs, cs[i], cs[j].rotate())\n      ans += solve(n, cs, cs[i], cs[j].rotate().rotate())\n      ans += solve(n, cs, cs[i], cs[j].rotate().rotate().rotate())\n\n  echo ans div 6\n\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\nproc readInt4*(): (int, int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2], v[3])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype Card = seq[int]\n\nproc `<`(c0, c1: Card): bool =\n  for k in 0..<4:\n    if c0[k] < c1[k]:\n      return true\n    if c0[k] > c1[k]:\n      return false\n  return false\n\nproc normalize(c: Card): Card =\n  let candi0 = @[ c[0], c[1], c[2], c[3] ]\n  let candi1 = @[ c[1], c[2], c[3], c[0] ]\n  let candi2 = @[ c[2], c[3], c[0], c[1] ]\n  let candi3 = @[ c[3], c[0], c[1], c[2] ]\n  return min([candi0, candi1, candi2, candi3])\n\nproc rotate(c: Card): Card = @[ c[3], c[0], c[1], c[2] ]\n\nproc solve(n: int; cs: seq[Card]; top, bottom: Card): int =\n  let side = @[\n    @[ top[0], bottom[3], bottom[2], top[1] ].normalize(),\n    @[ top[1], bottom[2], bottom[1], top[2] ].normalize(),\n    @[ top[2], bottom[1], bottom[0], top[3] ].normalize(),\n    @[ top[3], bottom[0], bottom[3], top[0] ].normalize()\n  ]\n\n  var ans = 1\n  for i in 0..<4:\n    let s = side[i]\n    var sNext = @[ s[0], s[1], s[2], s[3] + 1 ]\n    var cnt = cs.lowerBound(sNext) - cs.lowerBound(s)\n    if s == top.normalize():\n      cnt -= 1\n    if s == bottom.normalize():\n      cnt -= 1\n    for j in 0..<i:\n      if s == side[j]:\n        cnt -= 1\n\n    var k = 1\n    if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n      k = 4\n    if s[0] == s[2] and s[1] == s[3] and s[0] != s[1]:\n      k = 2\n    ans *= k * cnt\n\n  return ans\n\nproc main() =\n  let n = readInt1()\n\n  var cs = newSeq[Card](n)\n  for i in 0..<n:\n    cs[i] = readSeq().map(parseInt).normalize()\n  cs.sort(cmp[Card])\n\n  var ans = 0\n  for i in 0..<n:\n    for j in (i + 1)..<n:\n      if i == j:\n        continue\n      ans += solve(n, cs, cs[i], cs[j])\n      ans += solve(n, cs, cs[i], cs[j].rotate())\n      ans += solve(n, cs, cs[i], cs[j].rotate().rotate())\n      ans += solve(n, cs, cs[i], cs[j].rotate().rotate().rotate())\n\n  echo ans * 2 div 6\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nimport itertools\n\nmask = (1 << 10) - 1\n\nsymmetry = dict()\ndecode = dict()\ncounter = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    t = encode(a,b,c,d)\n    tiles.append(t)\n    counter[t] += 1\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    decode[t] = (a,b,c,d)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\nP += [(0,0,0,0,0)] * (N+1) # 負数代入対策\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode[bottom]\n    e,f,g,h = decode[top]\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\ndef compress(L):\n    L2 = list(set(L))\n    L2.sort()\n    C = {v : k for k, v in enumerate(L2, 1)}\n    return L2, C\n\ndef order(a, b, c, d):\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\n\nlimit = 5\ncalc = [[None]*limit for _ in range(limit*400)]\nfor i in range(limit*400):\n    calc[i][1] = i\n    for j in range(2, limit):\n        calc[i][j] = calc[i][j-1]*(i-j+1)\npp = [[pow(i, j) for j in range(10)] for i in range(10)]\n\nN = int(readline())\nC = [tuple(map(int, readline().split())) for _ in range(N)]\nD = Counter()\n\n\n\nRot = []\nfor i in range(N):\n    a, b, c, d = C[i]\n    Rot.append((a, b, c, d))\n    Rot.append((d, a, b, c))\n    Rot.append((c, d, a, b))\n    Rot.append((b, c, d, a))\nLc, Cr = compress(Rot)\nLc = [None] + Lc\nCc = []\n\nOd = Counter()\nBase = Counter()\nD = Counter()\nfor i in range(N):\n    a, b, c, d = C[i]\n    a, b, c, d = min((a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c))\n    od = order(a, b, c, d)\n    r1 = Cr[(a, b, c, d)]\n    r2 = Cr[(b, c, d, a)]\n    r3 = Cr[(c, d, a, b)]\n    r4 = Cr[(d, a, b, c)]\n    Base[r1] = r1\n    Base[r2] = r1\n    Base[r3] = r1\n    Base[r4] = r1\n    Od[r1] = od\n    Od[r2] = od\n    Od[r3] = od\n    Od[r4] = od\n    Cc.append((r1, r2, r3, r4))\n    D[r1] += 1\n\n\nans = 0\nfor i in range(N):\n    D[Cc[i][0]] -= 1\n    a, b, c, d = Lc[Cc[i][0]]\n    for j in range(i+1, N):\n        D[Cc[j][0]] -= 1\n        for idx in range(4):\n            e, f, g, h = Lc[Cc[j][idx]]\n            E = Counter()\n            r1 = (b, e, h, c)\n            if r1 not in Cr:\n                continue\n            r1 = Base[Cr[r1]]\n            r2 = (a, f, e, b)\n            if r2 not in Cr:\n                continue\n            r2 = Base[Cr[r2]]\n            r3 = (d, g, f, a)\n            if r3 not in Cr:\n                continue\n            r3 = Base[Cr[r3]]\n            r4 = (c, h, g, d)\n            if r4 not in Cr:\n                continue\n            r4 = Base[Cr[r4]]\n            \n            E[r1] += 1\n            E[r2] += 1\n            E[r3] += 1\n            E[r4] += 1            \n            res = 1\n            for k, n in E.items():\n                res *= calc[D[k]][n] * pp[Od[k]][n]\n            ans += res\n        \n        D[Cc[j][0]] += 1\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#    X2 \n# X1 X0 X4 X5 \n#    X3\n#\n# C0    C1\n#    X0 \n# C3    C2\n#\n# C1    C0\n#    5X \n# C2    C3\n#\nN = int(raw_input())\n# N = 6\n# N = 8\n\nC_list = []\nfor n in range(N):\n    C_list.append(map(int, raw_input().split()))\n\n\n\"\"\"\nC_list = [\n    [0, 1, 2, 3], \n    [0, 4, 6, 1], \n    [1, 6, 7, 2], \n    [2, 7, 5, 3], \n    [6, 4, 5, 7], \n    [4, 0, 3, 5]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 1, 1], \n    [0, 1, 0, 1], \n    [0, 1, 1, 0], \n    [1, 0, 0, 1], \n    [1, 0, 1, 0], \n    [1, 1, 0, 0], \n    [1, 1, 1, 1]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0]\n]\n\"\"\"\nres = 0\n\nC_dict = dict()\n\ndef sort4(x):\n    return sorted([x, [x[1], x[2], x[3], x[0]], [x[2], x[3], x[0], x[1]], [x[3], x[0], x[1], x[2]]])[0]\n\ndef rotate(A, n):\n    if n == 0:\n        return A\n    elif n == 1:\n        return [A[1], A[2], A[3], A[0]]\n    elif n == 2:\n        return [A[2], A[3], A[0], A[1]]\n    elif n == 3:\n        return [A[3], A[0], A[1], A[2]]\n    \ndef add_node(x):\n    s = str(sort4(x))\n    if C_dict.has_key(s):\n        C_dict[s]['count'] += 1\n    else:\n        # count duplicate\n        if x == rotate(x, 1):\n            w = 4\n        elif x == rotate(x, 2):\n            w = 2\n        else:\n            w = 1\n        C_dict[s] = {'count':1, 'weight':w}\n\ndef return_dict(x):\n    s = str(sort4(x))\n    if C_dict.has_key(s):\n        return [C_dict[s]['count'], C_dict[s]['weight']]\n    else:\n        return [0, 0]\n    \nfor i in range(N):\n    add_node(C_list[i])\n    \nfor i in range(N-1):\n    X0_ = C_list[i]\n    for j in range(i+1, N):\n        X5 = [C_list[j][1], C_list[j][0], C_list[j][3], C_list[j][2]]\n        for k in range(4):\n            X0 = rotate(X0_, k)\n            X1 = [X5[0], X5[1], X0[1], X0[0]]\n            X2 = [X5[1], X5[2], X0[2], X0[1]]\n            X3 = [X5[2], X5[3], X0[3], X0[2]]\n            X4 = [X5[3], X5[0], X0[0], X0[3]]\n\n            # drop duplicate\n            c1 = 0\n            c2 = 0\n            c3 = 0\n            c4 = 0\n            \n            if X2 in [rotate(X1, l) for l in range(4)]:\n                c2 += 1\n            if X3 in [rotate(X1, l) for l in range(4)]:\n                c3 += 1\n            if X3 in [rotate(X2, l) for l in range(4)]:\n                c3 += 1\n            if X4 in [rotate(X1, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X2, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X3, l) for l in range(4)]:\n                c4 += 1\n            \n            # count how many fits\n            r1, k1 = return_dict(X1)\n            r2, k2 = return_dict(X2)\n            r3, k3 = return_dict(X3)\n            r4, k4 = return_dict(X4)\n            if sort4(X0) == sort4(X1):\n                r1 -= 1\n            if sort4(X0) == sort4(X2):\n                r2 -= 1\n            if sort4(X0) == sort4(X3):\n                r3 -= 1\n            if sort4(X0) == sort4(X4):\n                r4 -= 1\n            if sort4(X5) == sort4(X1):\n                r1 -= 1\n            if sort4(X5) == sort4(X2):\n                r2 -= 1\n            if sort4(X5) == sort4(X3):\n                r3 -= 1\n            if sort4(X5) == sort4(X4):\n                r4 -= 1\n            r1 = max(r1-c1, 0)\n            r2 = max(r2-c2, 0)\n            r3 = max(r3-c3, 0)\n            r4 = max(r4-c4, 0)\n            # if r1*r2*r3*r4 > 0:\n            #     print i,j,k,X0, X5, r1, r2, r3, r4, c1, c2, c3, c4, k1, k2, k3, k4\n            res += r1*r2*r3*r4*k1*k2*k3*k4\n            \nprint res / 3"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nOd = dict()\ndef order(k):\n    if k in Od:\n        return Od[k]\n    else:\n        res = 1\n        a, b, c, d = k\n        if a == b == c == d:\n            res = 4\n        elif a == c and b == d:\n            res = 2\n        Od[k] = res\n        return res\n\ngeta = 1000\n\nDinv = Counter()\nEl = Counter()\ndef ele(k):\n    if k in El:\n        res = El[k]\n    else: \n        a, b, c, d = k\n        res = a*geta**3 + b*geta**2 + c*geta + d\n        for _ in range(3):\n            a, b, c, d = d, a, b, c\n            res = min(res, a*geta**3 + b*geta**2 + c*geta + d)\n            Dinv[res] = (a, b, c, d)\n        El[k] = res\n    return res\n\ndef calc(k, n):\n    od = order(Dinv[k])\n    val = D[k]//4\n    res = 1\n    for i in range(n):\n        res *= (val-i)\n    return res*pow(od, n)\n\nN = int(readline())\n\nC = [tuple(map(int, readline().split())) for _ in range(N)]\n\nD = Counter()\n\nfor i in range(N):\n    D[ele(C[i])] += 4\n\n\nans = 0\nfor i in range(N):\n    D[ele(C[i])] -= 4\n    for j in range(i+1, N):\n        D[ele(C[j])] -= 4\n        \n        a, b, c, d = C[i]\n        e, f, g, h = C[j]\n        for _ in range(4):\n            e, f, g, h = h, e, f, g\n            E = Counter()\n            \n            E[ele((b, e, h, c))] += 1\n            E[ele((a, f, e, b))] += 1\n            E[ele((d, g, f, a))] += 1\n            E[ele((c, h, g, d))] += 1            \n            res = 1\n            for k, n in E.items():\n                res *= calc(k, n)\n            ans += res\n        \n        D[ele(C[j])] += 4\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\ndef order(k):\n    a, b, c, d = k\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\ngeta = 1000\n\nDinv = Counter()\nEl = Counter()\ndef ele(k):\n    if k in El:\n        res = El[k]\n    else: \n        a, b, c, d = k\n        res = a*geta**3 + b*geta**2 + c*geta + d\n        for _ in range(3):\n            a, b, c, d = d, a, b, c\n            res = min(res, a*geta**3 + b*geta**2 + c*geta + d)\n            Dinv[res] = (a, b, c, d)\n        El[k] = res\n    return res\n\ndef calc(k, n):\n    od = order(Dinv[k])\n    val = D[k]//4\n    res = 1\n    for i in range(n):\n        res *= (val-i)\n    return res*pow(od, n)\n\nN = int(readline())\n\nC = [tuple(map(int, readline().split())) for _ in range(N)]\n\nD = Counter()\n\nfor i in range(N):\n    D[ele(C[i])] += 4\n\n\nans = 0\nfor i in range(N):\n    D[ele(C[i])] -= 4\n    for j in range(i+1, N):\n        D[ele(C[j])] -= 4\n        \n        a, b, c, d = C[i]\n        e, f, g, h = C[j]\n        for _ in range(4):\n            e, f, g, h = h, e, f, g\n            E = Counter()\n            \n            E[ele((b, e, h, c))] += 1\n            E[ele((a, f, e, b))] += 1\n            E[ele((d, g, f, a))] += 1\n            E[ele((c, h, g, d))] += 1            \n            res = 1\n            for k, n in E.items():\n                res *= calc(k, n)\n            ans += res\n        \n        D[ele(C[j])] += 4\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndef normal(xs):\n    mnx = min(xs)\n    xi = xs.index(mnx)\n    if xs[(xi+3)%4] == mnx:\n        if xs[(xi+2)%4] == mnx:\n            xi = (xi+2)%4\n        else:\n            xi = (xi+3)%4\n    if xs[(xi+1)%4] > xs[(xi+3)%4]:\n        xi = (xi+2)%4\n    return (xs[xi%4], xs[(xi+1)%4], xs[(xi+2)%4], xs[(xi+3)%4])\n#x = (0,2,2,0)\n#print(normal(x))\n\ndd = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    x = normal([a,b,c,d])\n    n=1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += n\n    ss.append(x)\n\ndef icr(x):\n    n = 1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += n\n\ndef dcr(x):\n    n = 1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] -= n\n\ndef f(ff, gg):\n    #print(dd)\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = list(map(normal, [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]))\n    r = 1\n    for cp in tl:\n        if cp not in dd:\n            r = 0\n            break\n        r *= dd[cp]\n        dcr(cp)\n    for cp in tl:\n        if cp not in dd:\n            break\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(i+1, N):\n        sl = ss[j]\n        dcr(sl)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint(r//3)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndef normal(xs):\n    mnx = min(xs)\n    xi = xs.index(mnx)\n    if xs[(xi+3)%4] == mnx:\n        if xs[(xi+2)%4] == mnx:\n            xi = (xi+2)%4\n        else:\n            xi = (xi+3)%4\n    if xs[(xi+1)%4] > xs[(xi+3)%4]:\n        xi = (xi+2)%4\n    return (xs[xi%4], xs[(xi+1)%4], xs[(xi+2)%4], xs[(xi+3)%4])\n#x = (0,2,2,0)\n#print(normal(x))\n\ndd = defaultdict(int)\ncc = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    x = normal([a,b,c,d])\n    n=1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += 1\n    cc[x] = n\n    ss.append(x)\n\ndef icr(x):\n    dd[x] += 1\n\ndef dcr(x):\n    dd[x] -= 1\n\ndef f(ff, gg):\n    #print(dd)\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = list(map(normal, [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]))\n    r = 1\n    for cp in tl:\n        if cp not in dd:\n            r = 0\n            break\n        r *= dd[cp]*cc[cp]\n        dcr(cp)\n    for cp in tl:\n        if cp not in dd:\n            break\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(i+1, N):\n        sl = ss[j]\n        dcr(sl)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint(r//3)\n"
  },
  {
    "language": "Python",
    "code": "n=input()\nCs=[map(int,raw_input().split()) for i in xrange(n)]\nD=[None]*n\nrot = [1]*n\ndic = {}\nr4 = range(4)\nfor i,C in enumerate(Cs):\n    l=list()\n    rc = 0\n    for j in r4:\n        c = tuple(C[j:]+C[:j])\n        if c in l:\n            rc += 1\n        else:\n            l.append(c)\n            dic.setdefault(c,[]).append(i)\n    if rc:\n        rot[i] = (rc+1)/2*2\n    D[i]=l\nans = 0\nfor i in xrange(n):\n    di=D[i][0]\n    for j in xrange(i+1,n):\n        P=[None]*4\n        for dj in D[j]:\n            dd = {}\n            dks = []\n            for k in r4:\n                dk = (di[k-3],di[k-4],dj[1-k],dj[-k])\n                P[k] = p = tuple(filter(lambda x: x!=i and x!=j, dic.get(dk, [])))\n                dd[p] = dd.get(p,0)+1\n                dks.append(dk)\n            if any(not p for p in P) or any(min(p) < i for p in P):\n                continue\n            res = 1\n            if dks[0]==dks[1]==dks[2]==dks[3]:\n                res = 4\n            elif dks[0]==dks[2] and dks[1]==dks[3]:\n                res = 2\n            for k,v in dd.items():\n                if len(k) < v:\n                    res = 0\n                    break\n                for ke in k:\n                    res *= rot[ke]\n                while v:\n                    res *= len(k)-v+1\n                    v -= 1\n            ans += res\nprint ans"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nOd = dict()\ndef order(k):\n    if k in Od:\n        return Od[k]\n    else:\n        res = 1\n        a, b, c, d = k\n        if a == b == c == d:\n            res = 4\n        elif a == c and b == d:\n            res = 2\n        Od[k] = res\n        return res\n\nEl = Counter()\ndef ele(k):\n    if k in El:\n        res = El[k]\n    else: \n        a, b, c, d = k\n        res = min((a, b, c, d), (b, c, d, a), (c, d, a, b), (d, a, b, c))\n        El[k] = res\n    return res\n\nlimit = 5\ncalc = [[None]*limit for _ in range(limit*400)]\nfor i in range(limit*400):\n    calc[i][1] = i\n    for j in range(2, limit):\n        calc[i][j] = calc[i][j-1]*(i-j+1)\npp = [[pow(i, j) for j in range(10)] for i in range(10)]\n\nN = int(readline())\nC = [tuple(map(int, readline().split())) for _ in range(N)]\nD = Counter()\n\nfor i in range(N):\n    D[ele(C[i])] += 1\n\nans = 0\nfor i in range(N):\n    D[ele(C[i])] -= 1\n    for j in range(i+1, N):\n        D[ele(C[j])] -= 1\n        \n        a, b, c, d = C[i]\n        e, f, g, h = C[j]\n        for _ in range(4):\n            e, f, g, h = h, e, f, g\n            E = Counter()\n            \n            E[ele((b, e, h, c))] += 1\n            E[ele((a, f, e, b))] += 1\n            E[ele((d, g, f, a))] += 1\n            E[ele((c, h, g, d))] += 1            \n            res = 1\n            \n            for k, n in E.items():\n                res *= calc[D[k]][n] * pp[order(k)][n]\n            ans += res\n        \n        D[ele(C[j])] += 1\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = int(input())\nC = []\nM = {}\nfor i in range(N):\n    *c, = map(int, input().split())\n    c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n    C.append(c)\n    if c not in M:\n        M[c] = deque([i])\n    else:\n        M[c].append(i)\ndef count(p, q, r, s):\n    if p == q == r == s:\n        return 4\n    if p == r and q == s:\n        return 2\n    return 1\ndef solve(ci, cj, k):\n    R = {}\n    for l in range(4):\n        #  [l]   [l-1]\n        # [l+k] [l+k+1]\n        c = ci[l], ci[l-1], cj[k-l], cj[k-l-1]\n        c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n        if c not in M:\n            return 0\n        R[c] = R.get(c, 0) + 1\n    res = 1\n    for c in R:\n        m = M[c]\n        cnt = len(m)\n        if c == cj:\n            cnt -= 1\n        if cnt < R[c]:\n            return 0\n        k = count(*c)\n        for p in range(cnt-R[c]+1, cnt+1):\n            res *= p * k\n    return res\n\nans = 0\nfor i in range(N):\n    ci = C[i]\n    q = M[ci]; q.popleft()\n    if not q:\n        del M[ci]\n    for j in range(i+1, N):\n        cj = C[j]\n        for k in range(4):\n            ans += solve(ci, cj, k)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = int(input())\nC = []\nM = {}\nfor i in range(N):\n    *c, = map(int, input().split())\n    c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n    C.append(c)\n    if c not in M:\n        M[c] = deque([i])\n    else:\n        M[c].append(i)\ndef count(p, q, r, s):\n    if p == q == r == s:\n        return 4\n    if p == r and q == s:\n        return 2\n    return 1\ndef solve(ci, cj, k):\n    R = {}\n    for l in range(4):\n        #  [l]   [l-1]\n        # [l+k] [l+k+1]\n        c = ci[l], ci[l-1], cj[k-l], cj[k-l-1]\n        c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n        if c not in M:\n            return 0\n        R[c] = R.get(c, 0) + 1\n    res = 1\n    for c in R:\n        m = M[c]\n        cnt = len(m)\n        if c == cj:\n            cnt -= 1\n        if cnt < R[c]:\n            return 0\n        k = count(*c)\n        for p in range(cnt-R[c]+1, cnt+1):\n            res *= p * k\n    return res\n\nans = 0\nfor i in range(N):\n    ci = C[i]\n    q = M[ci]; q.popleft()\n    if not q:\n        del M[ci]\n    for j in range(i+1, N):\n        cj = C[j]\n        for k in range(4):\n            ans += solve(ci, cj, k)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nP3 = 2 ** 30\nP2 = 2 ** 20\n\ndef get_min(c):\n    m = c\n    for _ in range(3):\n        c = c // 1024 + (c % 1024) * P3\n        m = min(m, c)\n\n    return m\n\n\ndef solve(n, ca, colors):\n\n    ans = 0\n    for i in range(n - 5):\n        ci = ca[i]\n        colors[ci] -= 1\n        for j in range(i + 1, n):\n            cj = ca[j]\n            colors[cj] -= 1\n            for _ in range(4):\n                nd = {}\n                c2 = (cj // P2 % 1024) * P3 + (cj // P3) * P2 + (ci // P2 % 1024) * 1024 + ci // P3\n                c2 = get_min(c2)\n                nd[c2] = 1\n                c3 = (ci % 1024) * P3 + (ci // 1024 % 1024) * P2 + (cj % 1024) * 1024 + cj // 1024 % 1024\n                c3 = get_min(c3)\n                if c3 == c2:\n                    nd[c3] += 1\n                else:\n                    nd[c3] = 1\n                c4 = (cj // P2 % 1024) * P3 + (ci // P3 % 1024) * P2 + (ci % 1024) * 1024 + cj // 1024 % 1024\n                c4 = get_min(c4)\n                if c4 == c2 or c4 == c3:\n                    nd[c4] += 1\n                else:\n                    nd[c4] = 1\n                c5 = (ci // P2 % 1024) * P3 + (cj // P3 % 1024) * P2 + (cj % 1024) * 1024 + ci // 1024 % 1024\n                c5 = get_min(c5)\n                if c5 == c2 or c5 == c3 or c5 == c4:\n                    nd[c5] += 1\n                else:\n                    nd[c5] = 1\n                r = 1\n                for c, k in nd.items():\n                    if not c in colors:\n                        r = 0\n                        break\n                    h = colors[c]\n                    if h < k:\n                        r = 0\n                        break\n                    if c // P2 == c % P2:\n                        rot = 2\n                        if c // P3 == c // P2 % 1024 and c // 1024 % 1024 == c % 1024:\n                            rot = 4\n                    else:\n                        rot = 1\n                    while 0 < k:\n                        r *= h * rot\n                        h -= 1\n                        k -= 1\n                ans += r\n                cj = cj // 1024 + (cj % 1024) * P3\n            colors[cj] += 1\n\n    return ans\n\n\ndef main():\n    n = input()\n    n = int(n)\n    colors = {}\n    ca = [-1] * n\n    for i in range(n):\n        c0, c1, c2, c3 = input().split()\n        c0 = int(c0)\n        c1 = int(c1)\n        c2 = int(c2)\n        c3 = int(c3)\n        c = c0 * P3 + c1 * P2 + c2 * 1024 + c3\n        m = get_min(c)\n        ca[i] = m\n        if m in colors:\n            colors[m] += 1\n        else:\n            colors[m] = 1\n\n\n    print(solve(n, ca, colors))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndef normal(xs):\n    mnx = min(xs)\n    xi = xs.index(mnx)\n    if xs[(xi+3)%4] == mnx:\n        if xs[(xi+2)%4] == mnx:\n            xi = (xi+2)%4\n        else:\n            xi = (xi+3)%4\n    return (xs[xi%4], xs[(xi+1)%4], xs[(xi+2)%4], xs[(xi+3)%4])\n\ndd = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    x = normal([a,b,c,d])\n    n=1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += n\n    ss.append(x)\n\ndef icr(x):\n    n = 1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += n\n\ndef dcr(x):\n    n = 1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] -= n\n\ndef f(ff, gg):\n    #print(dd)\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = list(map(normal, [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]))\n    r = 1\n#    print(ff, gg, r)\n    for cp in tl:\n        r *= dd[cp]\n        dcr(cp)\n#        print(r, cp, dd[cp])\n    for cp in tl:\n        icr(cp)\n    #print(ff,gg,r)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(i+1, N):\n        if i == j:\n            continue\n        sl = ss[j]\n        dcr(sl)\n        #print(dd)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint(r//3)\n"
  },
  {
    "language": "Python",
    "code": "#    X2 \n# X1 X0 X4 X5 \n#    X3\n#\n# C0    C1\n#    X0 \n# C3    C2\n#\n# C1    C0\n#    5X \n# C2    C3\n#\nN = int(raw_input())\n# N = 6\n# N = 8\n\nC_list = []\nfor n in range(N):\n    C_list.append(map(int, raw_input().split()))\n\n\n\"\"\"\nC_list = [\n    [0, 1, 2, 3], \n    [0, 4, 6, 1], \n    [1, 6, 7, 2], \n    [2, 7, 5, 3], \n    [6, 4, 5, 7], \n    [4, 0, 3, 5]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 1, 1], \n    [0, 1, 0, 1], \n    [0, 1, 1, 0], \n    [1, 0, 0, 1], \n    [1, 0, 1, 0], \n    [1, 1, 0, 0], \n    [1, 1, 1, 1]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0]\n]\n\"\"\"\nres = 0\n\ndef rotate(A, n):\n    if n == 0:\n        return A\n    elif n == 1:\n        return [A[1], A[2], A[3], A[0]]\n    elif n == 2:\n        return [A[2], A[3], A[0], A[1]]\n    elif n == 3:\n        return [A[3], A[0], A[1], A[2]]\n    \n\nC_list_1 = [rotate(C, 1) for C in C_list]\nC_list_2 = [rotate(C, 2) for C in C_list]\nC_list_3 = [rotate(C, 3) for C in C_list]\n\n\nfor i in range(N-1):\n    X0_ = C_list[i]\n    for j in range(i+1, N):\n        X5 = [C_list[j][1], C_list[j][0], C_list[j][3], C_list[j][2]]\n        for k in range(4):\n            X0 = rotate(X0_, k)\n            X1 = [X5[0], X5[1], X0[1], X0[0]]\n            X2 = [X5[1], X5[2], X0[2], X0[1]]\n            X3 = [X5[2], X5[3], X0[3], X0[2]]\n            X4 = [X5[3], X5[0], X0[0], X0[3]]\n\n            # drop duplicate\n            c1 = 0\n            c2 = 0\n            c3 = 0\n            c4 = 0\n            \n            if X2 in [rotate(X1, l) for l in range(4)]:\n                c2 += 1\n            if X3 in [rotate(X1, l) for l in range(4)]:\n                c3 += 1\n            if X3 in [rotate(X2, l) for l in range(4)]:\n                c3 += 1\n            if X4 in [rotate(X1, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X2, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X3, l) for l in range(4)]:\n                c4 += 1\n            \n            # count how many fits\n            r1 = 0\n            r1 += max(sum([C_list[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r1 += max(sum([C_list_1[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r1 += max(sum([C_list_2[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r1 += max(sum([C_list_3[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r2 = 0\n            r2 += max(sum([C_list[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r2 += max(sum([C_list_1[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r2 += max(sum([C_list_2[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r2 += max(sum([C_list_3[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r3 = 0\n            r3 += max(sum([C_list[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r3 += max(sum([C_list_1[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r3 += max(sum([C_list_2[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r3 += max(sum([C_list_3[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r4 = 0\n            r4 += max(sum([C_list[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            r4 += max(sum([C_list_1[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            r4 += max(sum([C_list_2[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            r4 += max(sum([C_list_3[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            res += r1*r2*r3*r4\n            \nprint res"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndef normal(xs):\n    mnx = min(xs)\n    xi = xs.index(mnx)\n    if xs[(xi+3)%4] == mnx:\n        if xs[(xi+2)%4] == mnx:\n            xi = (xi+2)%4\n        else:\n            xi = (xi+3)%4\n    return (xs[xi%4], xs[(xi+1)%4], xs[(xi+2)%4], xs[(xi+3)%4])\n\ndd = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    x = normal([a,b,c,d])\n    n=1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += n\n    ss.append(x)\n\ndef icr(x):\n    n = 1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += n\n\ndef dcr(x):\n    n = 1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] -= n\n\ndef f(ff, gg):\n    #print(dd)\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = list(map(normal, [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]))\n    r = 1\n#    print(ff, gg, r)\n    for cp in tl:\n        r *= dd[cp]\n        dcr(cp)\n#        print(r, cp, dd[cp])\n    for cp in tl:\n        icr(cp)\n    #print(ff,gg,r)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(N):\n        if i == j:\n            continue\n        sl = ss[j]\n        dcr(sl)\n        #print(dd)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint(r//6)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef get_min(c):\n    m = c\n    for _ in range(3):\n        c = c // 1024 + (c % 1024) * 2 ** 30\n        m = min(m, c)\n\n    return m\n\n\ndef solve(n, ca, colors):\n\n    ans = 0\n    for i in range(n - 5):\n        ci = ca[i]\n        colors[ci] -= 1\n        for j in range(i + 1, n):\n            cj = ca[j]\n            colors[cj] -= 1\n            for _ in range(4):\n                nd = {}\n                c2 = (cj // 2 ** 20 % 1024) * 2 ** 30 + (cj // 2 ** 30) * 2 ** 20 + (ci // 2 ** 20 % 1024) * 2 ** 10 + ci // 2 ** 30\n                c2 = get_min(c2)\n                nd[c2] = 1\n                c3 = (ci % 1024) * 2 ** 30 + (ci // 1024 % 1024) * 2 ** 20 + (cj % 1024) * 2 ** 10 + cj // 1024 % 1024\n                c3 = get_min(c3)\n                if c3 in nd:\n                    nd[c3] += 1\n                else:\n                    nd[c3] = 1\n                c4 = (cj // 2 ** 20 % 1024) * 2 ** 30 + (ci // 2 ** 30 % 1024) * 2 ** 20 + (ci % 1024) * 2 ** 10 + cj // 1024 % 1024\n                c4 = get_min(c4)\n                if c4 in nd:\n                    nd[c4] += 1\n                else:\n                    nd[c4] = 1\n                c5 = (ci // 2 ** 20 % 1024) * 2 ** 30 + (cj // 2 ** 30 % 1024) * 2 ** 20 + (cj % 1024) * 2 ** 10 + ci // 1024 % 1024\n                c5 = get_min(c5)\n                if c5 in nd:\n                    nd[c5] += 1\n                else:\n                    nd[c5] = 1\n                r = 1\n                for c, k in nd.items():\n                    if not c in colors:\n                        r = 0\n                        break\n                    h = colors[c]\n                    if h < k:\n                        r = 0\n                        break\n                    if c // 2 ** 20 == c % 2 ** 20:\n                        rot = 2\n                        if c // 2 ** 30 == c // 2 ** 20 % 1024 and c // 2 ** 10 % 1024 == c % 1024:\n                            rot = 4\n                    else:\n                        rot = 1\n                    while 0 < k:\n                        r *= h * rot\n                        h -= 1\n                        k -= 1\n                ans += r\n                cj = cj // 1024 + (cj % 1024) * 2 ** 30\n            colors[cj] += 1\n\n    return ans\n\n\ndef main():\n    n = input()\n    n = int(n)\n    colors = {}\n    ca = [-1] * n\n    for i in range(n):\n        c0, c1, c2, c3 = input().split()\n        c0 = int(c0)\n        c1 = int(c1)\n        c2 = int(c2)\n        c3 = int(c3)\n        c = c0 * 2 ** 30 + c1 * 2 ** 20 + c2 * 2 ** 10 + c3\n        m = get_min(c)\n        ca[i] = m\n        if m in colors:\n            colors[m] += 1\n        else:\n            colors[m] = 1\n\n\n    print(solve(n, ca, colors))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndef normal(xs):\n    return tuple(min((xs[j:] + xs[:j] for j in range(1, 5))))\n\ndd = defaultdict(int)\ncc = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    x = normal([a,b,c,d])\n    n=1\n    if x[0] == x[2] and x[1] == x[3]:\n        n *= 2\n        if x[0] == x[1]:\n            n *= 2\n    dd[x] += 1\n    cc[x] = n\n    ss.append(x)\n\ndef icr(x):\n    dd[x] += 1\n\ndef dcr(x):\n    dd[x] -= 1\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = list(map(normal, [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]))\n    for cp in tl:\n        if cp not in dd:\n            return 0\n    r = 1\n    for cp in tl:\n        r *= dd[cp]*cc[cp]\n        dcr(cp)\n    for cp in tl:\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(i+1, N):\n        sl = ss[j]\n        dcr(sl)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint(r//3)"
  },
  {
    "language": "Python",
    "code": "n=input()\nCs=[map(int,raw_input().split()) for i in xrange(n)]\nD=[None]*n\ndic = {}\nfor i,C in enumerate(Cs):\n    l=list()\n    for j in xrange(4):\n        l.append(tuple(C[j:]+C[:j]))\n    D[i]=l\n    for e in l:\n        dic.setdefault(e,[]).append(i)\nans = 0\nfor i in xrange(n):\n    di=D[i][0]\n    for j in xrange(i+1,n):\n        for dj in D[j]:\n            dj=list(dj)\n            P=[None]*4\n            dd = {}\n            for k in xrange(4):\n                dk = (di[k-3],di[k-4],dj[1-k],dj[-k])\n                P[k] = tuple(filter(lambda x: x!=i and x!=j, dic.get(dk, [])))\n                dd[P[k]] = dd.get(P[k],0)+1\n            if any(not p for p in P) or any(min(p) < i for p in P):\n                continue\n            res = 1\n            for k,v in dd.items():\n                dc = list(set(k))\n                if dc < v:\n                    res = 0\n                    break\n                for k2 in dc:\n                    res *= k.count(k2)\n                while v:\n                    res *= len(dc)-v+1\n                    v -= 1\n            ans += res\nprint ans"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nOd = dict()\ndef order(k):\n    if k in Od:\n        return Od[k]\n    else:\n        res = 1\n        a, b, c, d = k\n        if a == b == c == d:\n            res = 4\n        elif a == c and b == d:\n            res = 2\n        Od[k] = res\n        return res\n\nDinv = Counter()\nEl = Counter()\ndef ele(k):\n    if k in El:\n        res = El[k]\n    else: \n        a, b, c, d = k\n        res = (a<<30) + (b<<20) + (c<<10) + d\n        for _ in range(3):\n            a, b, c, d = d, a, b, c\n            res = min(res, (a<<30) + (b<<20) + (c<<10) + d)\n        Dinv[res] = (a, b, c, d)\n        El[k] = res\n    return res\n\nlimit = 5\ncalc = [[None]*limit for _ in range(limit*400)]\nfor i in range(limit*400):\n    calc[i][1] = i\n    for j in range(2, limit):\n        calc[i][j] = calc[i][j-1]*(i-j+1)\npp = [[pow(i, j) for j in range(10)] for i in range(10)]\n\nN = int(readline())\nC = [tuple(map(int, readline().split())) for _ in range(N)]\nD = Counter()\n\nfor i in range(N):\n    D[ele(C[i])] += 1\n\nans = 0\nfor i in range(N):\n    D[ele(C[i])] -= 1\n    for j in range(i+1, N):\n        D[ele(C[j])] -= 1\n        \n        a, b, c, d = C[i]\n        e, f, g, h = C[j]\n        for _ in range(4):\n            e, f, g, h = h, e, f, g\n            E = Counter()\n            \n            E[ele((b, e, h, c))] += 1\n            E[ele((a, f, e, b))] += 1\n            E[ele((d, g, f, a))] += 1\n            E[ele((c, h, g, d))] += 1            \n            res = 1\n            \n            for k, n in E.items():\n                res *= calc[D[k]][n] * pp[order(Dinv[k])][n]\n            ans += res\n        \n        D[ele(C[j])] += 1\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndef normal(xs):\n    return tuple(min((xs[j:] + xs[:j] for j in range(1, 5))))\n\ndd = defaultdict(int)\ncc = dict()\nnorm = dict()\nss = []\nfor _ in range(N):\n    xs = list(map(int, input().split()))\n    cnd = [tuple(xs[j:] + xs[:j]) for j in range(1, 5)]\n    x = min(cnd)\n    for item in cnd:\n        norm[item] = x\n    dd[x] += 1\n    cc[x] = (4 if x[0] == x[1] else 2)if x[0] == x[2] and x[1] == x[3] else 1\n    ss.append(x)\n\ndef icr(x):\n    dd[x] += 1\n\ndef dcr(x):\n    dd[x] -= 1\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    for cp in tl:\n        if cp not in norm:\n            return 0\n    r = 1\n    for cp in tl:\n        cp = norm[cp]\n        r *= dd[cp]*cc[cp]\n        dcr(cp)\n    for cp in tl:\n        cp = norm[cp]\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(i+1, N):\n        sl = ss[j]\n        dcr(sl)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint(r//3)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\nsymmetry = dict()\ndecode = dict()\ncounter = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    t = encode(a,b,c,d)\n    tiles.append(t)\n    counter[t] += 1\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    decode[t] = (a,b,c,d)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\nP += [(0,0,0,0,0)] * (N+1) # 負数代入対策\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode[bottom]\n    e,f,g,h = decode[top]\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            have = counter[tile]\n            if have < cnt:\n                x = 0\n                break\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = int(input())\nC = []\nM = {}\nfor i in range(N):\n    *c, = 0, 0, 0, 0 #map(int, input().split())\n    c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n    C.append(c)\n    if c not in M:\n        M[c] = deque([i])\n    else:\n        M[c].append(i)\ndef count(p, q, r, s):\n    if p == q == r == s:\n        return 4\n    if p == r and q == s:\n        return 2\n    return 1\ndef solve(ci, cj, k):\n    R = {}\n    for l in range(4):\n        #  [l]   [l-1]\n        # [l+k] [l+k+1]\n        c = ci[l], ci[l-1], cj[k-l], cj[k-l-1]\n        c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n        if c not in M:\n            return 0\n        R[c] = R.get(c, 0) + 1\n    res = 1\n    for c in R:\n        m = M[c]\n        cnt = len(m)\n        if c == cj:\n            cnt -= 1\n        if cnt < R[c]:\n            return 0\n        k = count(*c)\n        for p in range(cnt-R[c]+1, cnt+1):\n            res *= p * k\n    return res\n\nans = 0\nfor i in range(N):\n    ci = C[i]\n    q = M[ci]; q.popleft()\n    if not q:\n        del M[ci]\n    for j in range(i+1, N):\n        cj = C[j]\n        for k in range(4):\n            ans += solve(ci, cj, k)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nN = int(input())\nC = []\nM = {}\nfor i in range(N):\n    *c, = map(int, input().split())\n    c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n    C.append(c)\n    M.setdefault(c, []).append(i)\ndef count(p, q, r, s):\n    if p == q == r == s:\n        return 4\n    if p == r and q == s:\n        return 2\n    return 1\ndef solve(i, j, k):\n    ci = C[i]; cj = C[j]\n    R = {}\n    for l in range(4):\n        #  [l]   [l-1]\n        # [l+k] [l+k+1]\n        c = ci[l], ci[l-1], cj[(k-l+1)%4], cj[(k-l)%4]\n        c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n        if c not in M:\n            return 0\n        R[c] = R.get(c, 0) + 1\n    res = 1\n    for c in R:\n        m = M[c]\n        cnt = len(m) - bisect(m, i)\n        if c == cj:\n            cnt -= 1\n        if cnt < R[c]:\n            return 0\n        k = count(*c)\n        r = 1\n        for p in range(cnt-R[c]+1, cnt+1):\n            r *= p\n        r *= k**cnt\n        res *= r\n    return res\n\nans = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        for k in range(4):\n            ans += solve(i, j, k)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#from pprint import pprint\nimport collections\nimport itertools\n\ndef get_ltru(f, b):\n    return [(b[2], b[1], f[0], f[3]),\n            (b[1], b[0], f[1], f[0]),\n            (b[0], b[3], f[2], f[1]),\n            (b[3], b[2], f[3], f[2])]\n\ndef rotations(c):\n    return set(tuple(c[i:] + c[:i]) for i in range(4))\n\ndef count_distict(s_list):\n    sl = s_list\n    if len(s_list) == 0:\n        return 1\n    if len(s_list) == 1:\n        return len(s_list[0])\n    if len(s_list) == 2:\n        return len(s_list[0])*len(s_list[1]) - len(s_list[0]&s_list[1])\n    if len(s_list) == 3:\n        return len(s_list[0])*len(s_list[1])*len(s_list[2]) - len(s_list[0]&s_list[1])*len(sl[2]) - len(s_list[0]&s_list[2])*len(sl[1]) -len(s_list[1]&s_list[2])*len(sl[0])\\\n                + len(s_list[0]&s_list[1]&s_list[2])\n    if len(sl) == 4:\n        a,b,c,d = sl[0], sl[1], sl[2], sl[3]\n        return len(a)*len(b)*len(c)*len(d)\\\n                - len(a&b)*len(c)*len(d)\\\n                - len(a&c)*len(b)*len(d)\\\n                - len(a&d)*len(b)*len(c)\\\n                - len(b&c)*len(a)*len(d)\\\n                - len(b&d)*len(a)*len(b)\\\n                - len(c&d)*len(a)*len(b)\\\n                + 2*len(a&b&c)*len(d)\\\n                + 2*len(a&b&d)*len(c)\\\n                + 2*len(a&c&d)*len(b)\\\n                + 2*len(b&c&d)*len(a)\\\n                + len(a&b)*len(c&d)\\\n                + len(a&c)*len(b&d)\\\n                + len(b&c)*len(a&d)\\\n                - 6*len(a&b&c&d)\n\nN = int(raw_input())\n\nC = [[int(s) for s in raw_input().split()] for i in range(N)]\n\nr_to_c = {}\n\nr_to_c = collections.defaultdict(set)\n\n\nfor i in range(N):\n    for r in rotations(C[i]):\n        r_to_c[r].add(i)\n#pprint(dict(r_to_c))\n\nans = 0\nfor i,j in itertools.product(range(N), repeat=2):\n    if i == j: continue\n    f = C[i]\n    multiplier = 4//len(rotations(C[j]))\n    for b in rotations(C[j]):\n        l,t,r,u = get_ltru(f,b)\n        sym = {i:list() for i in [1,2,4]}\n        for face in (l,t,r,u):\n            sym[len(rotations(face))].append(face)\n        #print(dict(sym))\n        this_num = 1\n        for n in [1,2,4]:\n            this_num *= (4//n)**(len(sym[n]))*count_distict([r_to_c[face]-{i,j} for face in sym[n]])\n        ans += this_num*multiplier\nprint(ans//6)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import Counter, defaultdict\nimport itertools\nfrom functools import lru_cache\n\nmask = (1 << 10) - 1\n\nsymmetry = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [(x >> n) &mask for n in [0,10,20,30]]\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    tiles.append(encode(a,b,c,d))\ncounter = Counter(tiles)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\nP += [(0,0,0,0,0)] * (N+1) # 負数代入対策\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode(bottom)\n    e,f,g,h = decode(top)\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\ndef decode(x):\n    for _ in range(4):\n        yield x & mask\n        x >>= 10\n\ndef P(n,k):\n    x = 1\n    for i in range(k):\n        x *= (n-i)\n    return x\n\ndef symmetry(tile):\n    a,b,c,d = decode(tile)\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    tiles.append(encode(a,b,c,d))\ncounter = Counter(tiles)\n\ncounter\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode(bottom)\n    e,f,g,h = decode(top)\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            x *= P(counter[tile],cnt) # 残っている個数、必要枚数\n            x *= pow(symmetry(tile), cnt)\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\nsymmetry = dict()\ndecode = dict()\ncounter = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for _ in range(4):\n        a,b,c,d = b,c,d,a\n        x = a + (b << 10) + (c << 20) + (d << 30)\n        if t > x:\n            t = x\n    return t\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    t = encode(a,b,c,d)\n    tiles.append(t)\n    counter[t] += 1\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    decode[t] = (a,b,c,d)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode[bottom]\n    e,f,g,h = decode[top]\n    for _ in range(4):\n        e,f,g,h = f,g,h,e\n        # a,b,c,d\n        # e,h,g,f \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,e,h), (c,b,h,g), (d,c,g,f), (a,d,f,e)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            have = counter[tile]\n            if have < cnt:\n                x = 0\n                break\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#    X2 \n# X1 X0 X4 X5 \n#    X3\n#\n# C0    C1\n#    X0 \n# C3    C2\n#\n# C1    C0\n#    5X \n# C2    C3\n#\nN = int(raw_input())\n# N = 6\n# N = 8\n\nC_list = []\nfor n in range(N):\n    C_list.append(map(int, raw_input().split()))\n\n\n\"\"\"\nC_list = [\n    [0, 1, 2, 3], \n    [0, 4, 6, 1], \n    [1, 6, 7, 2], \n    [2, 7, 5, 3], \n    [6, 4, 5, 7], \n    [4, 0, 3, 5]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 1, 1], \n    [0, 1, 0, 1], \n    [0, 1, 1, 0], \n    [1, 0, 0, 1], \n    [1, 0, 1, 0], \n    [1, 1, 0, 0], \n    [1, 1, 1, 1]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0]\n]\n\"\"\"\nres = 0\n\ndef rotate(A, n):\n    if n == 0:\n        return A\n    elif n == 1:\n        return [A[1], A[2], A[3], A[0]]\n    elif n == 2:\n        return [A[2], A[3], A[0], A[1]]\n    elif n == 3:\n        return [A[3], A[0], A[1], A[2]]\n    \n\nC_list_1 = [rotate(C, 1) for C in C_list]\nC_list_2 = [rotate(C, 2) for C in C_list]\nC_list_3 = [rotate(C, 3) for C in C_list]\n\n\nfor i in range(N-1):\n    X0_ = C_list[i]\n    for j in range(i+1, N):\n        X5 = [C_list[j][1], C_list[j][0], C_list[j][3], C_list[j][2]]\n        for k in range(4):\n            X0 = rotate(X0_, k)\n            X1 = [X5[0], X5[1], X0[1], X0[0]]\n            X2 = [X5[1], X5[2], X0[2], X0[1]]\n            X3 = [X5[2], X5[3], X0[3], X0[2]]\n            X4 = [X5[3], X5[0], X0[0], X0[3]]\n\n            # drop duplicate\n            c1 = 0\n            c2 = 0\n            c3 = 0\n            c4 = 0\n            \n            if X2 in [rotate(X1, l) for l in range(4)]:\n                c2 += 1\n            if X3 in [rotate(X1, l) for l in range(4)]:\n                c3 += 1\n            if X3 in [rotate(X2, l) for l in range(4)]:\n                c3 += 1\n            if X4 in [rotate(X1, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X2, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X3, l) for l in range(4)]:\n                c4 += 1\n            \n            # count how many fits\n            r1 = 0\n            r1 += max(sum([C_list[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r1 += max(sum([C_list_1[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r1 += max(sum([C_list_2[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r1 += max(sum([C_list_3[m] == X1 for m in range(i+1, N) if m != j]) - c1, 0)\n            r2 = 0\n            r2 += max(sum([C_list[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r2 += max(sum([C_list_1[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r2 += max(sum([C_list_2[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r2 += max(sum([C_list_3[m] == X2 for m in range(i+1, N) if m != j]) - c2, 0)\n            r3 = 0\n            r3 += max(sum([C_list[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r3 += max(sum([C_list_1[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r3 += max(sum([C_list_2[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r3 += max(sum([C_list_3[m] == X3 for m in range(i+1, N) if m != j]) - c3, 0)\n            r4 = 0\n            r4 += max(sum([C_list[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            r4 += max(sum([C_list_1[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            r4 += max(sum([C_list_2[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            r4 += max(sum([C_list_3[m] == X4 for m in range(i+1, N) if m != j]) - c4, 0)\n            res += r1*r2*r3*r4\n            \nprint res"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndd = defaultdict(int)\ncc = dict()\nnorm = dict()\nss = []\nfor _ in range(N):\n    xs = list(map(int, input().split()))\n    cnd = [tuple(xs[j:] + xs[:j]) for j in range(1, 5)]\n    x = min(cnd)\n    for item in cnd:\n        norm[item] = x\n    dd[x] += 1\n    cc[x] = (4 if x[0] == x[1] else 2)if x[0] == x[2] and x[1] == x[3] else 1\n    ss.append(x)\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    for i in range(4):\n        if tl[i] not in norm:\n            return 0\n        tl[i] = norm[tl[i]]\n    r = 1\n    for cp in tl:\n        r *= dd[cp]*cc[cp]\n        dd[cp] -= 1\n    for cp in tl:\n        dd[cp] += 1\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dd[ff]-=1\n    for j in range(i+1, N):\n        sl = ss[j]\n        x, y, z, w = sl\n        dd[sl]-=1\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        dd[sl]+=1\nprint(r)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nN = int(input())\nC = []\nM = {}\nfor i in range(N):\n    *c, = map(int, input().split())\n    c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n    C.append(c)\n    M.setdefault(c, []).append(i)\ndef count(p, q, r, s):\n    if p == q == r == s:\n        return 4\n    if p == r and q == s:\n        return 2\n    return 1\ndef solve(i, j, k):\n    ci = C[i]; cj = C[j]\n    R = {}\n    for l in range(4):\n        #  [l]   [l-1]\n        # [l+k] [l+k+1]\n        c = ci[l], ci[l-1], cj[(k-l+1)%4], cj[(k-l)%4]\n        c = tuple(min(c[j:] + c[:j] for j in range(1, 5)))\n        if c not in M:\n            return 0\n        R[c] = R.get(c, 0) + 1\n    res = 1\n    for c in R:\n        m = M[c]\n        cnt = len(m) - bisect(m, i)\n        if c == cj:\n            cnt -= 1\n        if cnt < R[c]:\n            return 0\n        k = count(*c)\n        r = 1\n        for p in range(cnt-R[c]+1, cnt+1):\n            r *= p\n        r *= k**cnt\n        res *= r\n    return res\n\nans = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        for k in range(4):\n            ans += solve(i, j, k)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\ndd = defaultdict(int)\ncc = dict()\nnrm = dict()\nss = []\nfor _ in range(N):\n  xs = list(map(int, input().split()))\n  cnd = [tuple(xs[j:]+xs[:j])for j in range(4)]\n  x = min(cnd)\n  for item in cnd:\n    nrm[item] = x\n  dd[x] += 1\n  cc[x] = (4 if x[0]==x[1]else 2)if x[0]==x[2]and x[1]==x[3]else 1\n  ss.append(x)\ndef f(ff, gg):\n  a,b,c,d=ff\n  e,h,g,f=gg\n  tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n  q = defaultdict(int)\n  for p in tl:\n    if p not in nrm:\n      return 0\n    q[nrm[p]] += 1\n  r= 1\n  for p, c in q.items():\n    for i in range(c):\n      r *= dd[p]-i\n    r *= cc[p]**c\n  return r\nr = 0\nfor i in range(N):\n  ff = ss[i]\n  dd[ff]-=1\n  for j in range(i+1, N):\n    sl = ss[j]\n    x, y, z, w = sl\n    dd[sl]-=1\n    r += sum(f(ff,tuple(sl[j:]+sl[:j]))for j in range(4))\n    dd[sl]+=1\nprint(r)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\ndd = defaultdict(int)\ncc = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    dd[(a,b,c,d)] += 1\n    dd[(b,c,d,a)] += 1\n    dd[(c,d,a,b)] += 1\n    dd[(d,a,b,c)] += 1\n    if a == c and b == d:\n        if a == b:\n            cc[(a,b,c,d)] = 4\n        else:\n            cc[(a,b,c,d)] = 2\n            cc[(b,c,d,a)] = 2\n    else:\n        cc[(a,b,c,d)] = 1\n        cc[(b,c,d,a)] = 1\n        cc[(c,d,a,b)] = 1\n        cc[(d,a,b,c)] = 1\n    ss.append((a,b,c,d))\ndef icr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] += 1\ndef dcr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] -= 1\n\ndef f(a, b, c, d, e, f, g, h):\n    e, f, g, h = e, h, g, f\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    r = 1\n    coun = 0\n    for cp in tl:\n        coun += 1\n#        if (a,b,c,d) == (1, 1, 1, 1) and (e,f,g,h) == (0,0,0,0):\n#        if (a,b,c,d) == (1, 0, 1, 0) and (e,f,g,h) == (1,0,1,0):\n#            print(coun, dd, dd[cp])\n        #print(coun, dd, dd[cp])\n        r *= dd[cp]\n        dcr(cp)\n    for cp in tl:\n        icr(cp)\n    #print((a,b,c,d), (e,f,g,h), r)\n    return r\n\nr = 0\nfor i in range(N):\n    a,b,c,d = ss[i]\n    ff = [a,b,c,d]\n    dcr(tuple(ff))\n    for j in range(N):\n        if i == j:\n            continue\n        x, y, z, w = ss[j]\n        sl = [[x,y,z,w], [y,z,w,x], [z,w,x,y], [w,x,y,z]]\n        for s in sl:\n            dcr(tuple(s))\n            r += f(*(ff+s))\n            icr(tuple(s))\n    icr(tuple(ff))\nprint(r//6)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\nsymmetry = dict()\ndecode = dict()\ncounter = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    t = encode(a,b,c,d)\n    tiles.append(t)\n    counter[t] += 1\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    decode[t] = (a,b,c,d)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\nP += [(0,0,0,0,0)] * (N+1) # 負数代入対策\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode[bottom]\n    e,f,g,h = decode[top]\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            have = counter[tile]\n            if have < cnt:\n                x = 0\n                break\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\ndd = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    dd[(a,b,c,d)] += 1\n    dd[(b,c,d,a)] += 1\n    dd[(c,d,a,b)] += 1\n    dd[(d,a,b,c)] += 1\n    ss.append((a,b,c,d))\ndef icr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] += 1\ndef dcr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] -= 1\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e, h, g, f = gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    r = 1\n    for cp in tl:\n        r *= dd[cp]\n        dcr(cp)\n    for cp in tl:\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    a,b,c,d = ss[i]\n    ff = (a,b,c,d)\n    dcr(ff)\n    for j in range(I+1, N):\n        if i == j:\n            continue\n        x, y, z, w = ss[j]\n        sl = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sl:\n            dcr(s)\n            r += f(ff,s)\n            icr(s)\n    icr(ff)\nprint(r//3)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\ndef order(k):\n    a, b, c, d = k\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\ngeta = 1000\n\nDinv = Counter()\nEl = Counter()\ndef ele(k):\n    if k in El:\n        res = El[k]\n    else: \n        a, b, c, d = k\n        res = a*geta**3 + b*geta**2 + c*geta + d\n        for _ in range(3):\n            a, b, c, d = d, a, b, c\n            res = min(res, a*geta**3 + b*geta**2 + c*geta + d)\n            Dinv[res] = (a, b, c, d)\n        El[k] = res\n    return res\n\ndef calc(k, n):\n    od = order(Dinv[k])\n    val = D[k]//4\n    res = 1\n    for i in range(n):\n        res *= (val-i)\n    return res*pow(od, n)\n\nN = int(readline())\n\nC = [tuple(map(int, readline().split())) for _ in range(N)]\n\nD = Counter()\n\nfor i in range(N):\n    D[ele(C[i])] += 4\n\n\nans = 0\nfor i in range(N):\n    D[ele(C[i])] -= 4\n    for j in range(i+1, N):\n        D[ele(C[j])] -= 4\n        \n        a, b, c, d = C[i]\n        e, f, g, h = C[j]\n        for _ in range(4):\n            e, f, g, h = h, e, f, g\n            E = Counter()\n            \n            E[ele((b, e, h, c))] += 1\n            E[ele((a, f, e, b))] += 1\n            E[ele((d, g, f, a))] += 1\n            E[ele((c, h, g, d))] += 1            \n            res = 1\n            for k, n in E.items():\n                res *= calc(k, n)\n            ans += res\n        \n        D[ele(C[j])] += 4\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\ndef cs2int(cs):\n    ts = [sum(cs[i] * 1000**((-i+k)%4) for i in range(4)) for k in range(4)]\n    return min(ts)\ndef int2cs(i):\n    return (i//1000000000, (i//1000000)%1000, (i//1000)%1000, i%1000)\ndef dup(cs):\n    return 4 if cs[0]==cs[1]==cs[2]==cs[3] else 2 if cs[0]==cs[2] and cs[1]==cs[3] else 1\n\nif __name__==\"__main__\":\n    n = int(input())\n    bag = Counter(cs2int(tuple(map(int, input().split()))) for _ in range(n))\n    s = 0\n    for top, i in bag.items():\n        top_c = int2cs(top)\n        for bottom, j in bag.items():\n            bottom_c = int2cs(bottom)\n            for k in range(4):\n                front = cs2int((top_c[3], top_c[2], bottom_c[(1+k)%4], bottom_c[k]))\n                right = cs2int((top_c[2], top_c[1], bottom_c[(2+k)%4], bottom_c[(1+k)%4]))\n                back = cs2int((top_c[1], top_c[0], bottom_c[(3+k)%4], bottom_c[(2+k)%4]))\n                left = cs2int((top_c[0], top_c[3], bottom_c[k], bottom_c[(3+k)%4]))\n                temp = i*(j-(top==bottom))\n                temp *= bag[front]- (front==top) - (front==bottom)\n                temp *= bag[right] - (right==top) - (right==bottom) - (right==front)\n                temp *= bag[back] - (back==top) - (back==bottom) - (back==front) - (back==right)\n                temp *= bag[left] - (left==top) - (left==bottom) - (left==front) - (left==right) - (left==back)\n                temp *= dup(int2cs(front)) * dup(int2cs(right)) * dup(int2cs(back)) * dup(int2cs(left))\n                s += temp\n    print(s//6)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\ndef order(k):\n    a, b, c, d = k\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\nINF = 10**18\ngeta = 1000\n\nDinv = Counter()\ndef ele(k):\n    a, b, c, d = k\n    res = INF\n    for _ in range(4):\n        a, b, c, d = d, a, b, c\n        res = min(res, a*geta**3 + b*geta**2 + c*geta + d)\n        Dinv[res] = (a, b, c, d)\n    return res\n\ndef calc(k, n):\n    od = order(Dinv[k])\n    val = D[k]//4\n    res = 1\n    for i in range(n):\n        res *= (val-i)\n    return res*od**n\n\nN = int(readline())\n\nC = [tuple(map(int, readline().split())) for _ in range(N)]\n\nD = Counter()\n\nfor i in range(N):\n    D[ele(C[i])] += 4\n\n\nans = 0\nfor i in range(N):\n    D[ele(C[i])] -= 4\n    for j in range(i+1, N):\n        D[ele(C[j])] -= 4\n        \n        a, b, c, d = C[i]\n        e, f, g, h = C[j]\n        for _ in range(4):\n            e, f, g, h = h, e, f, g\n            E = Counter()\n            \n            E[ele((b, e, h, c))] += 1\n            E[ele((a, f, e, b))] += 1\n            E[ele((d, g, f, a))] += 1\n            E[ele((c, h, g, d))] += 1            \n            res = 1\n            for k, n in E.items():\n                res *= calc(k, n)\n            ans += res\n        \n        D[ele(C[j])] += 4\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\ndd = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    dd[(a,b,c,d)] += 1\n    dd[(b,c,d,a)] += 1\n    dd[(c,d,a,b)] += 1\n    dd[(d,a,b,c)] += 1\n    ss.append((a,b,c,d))\ndef icr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] += 1\ndef dcr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] -= 1\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e, h, g, f = gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    r = 1\n    for cp in tl:\n        r *= dd[cp]\n        dcr(cp)\n    for cp in tl:\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    a,b,c,d = ss[i]\n    ff = (a,b,c,d)\n    dcr(ff)\n    for j in range(N):\n        if i == j:\n            continue\n        x, y, z, w = ss[j]\n        sl = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sl:\n            dcr(s)\n            r += f(ff,s)\n            icr(s)\n    icr(ff)\nprint(r//6)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\n\ndd = defaultdict(int)\ncc = dict()\nnorm = dict()\nss = []\nfor _ in range(N):\n    xs = list(map(int, input().split()))\n    cnd = [tuple(xs[j:] + xs[:j]) for j in range(1, 5)]\n    x = min(cnd)\n    for item in cnd:\n        norm[item] = x\n    dd[x] += 1\n    cc[x] = (4 if x[0] == x[1] else 2)if x[0] == x[2] and x[1] == x[3] else 1\n    ss.append(x)\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    for i in range(4):\n        if tl[i] not in norm:\n            return 0\n        tl[i] = norm[tl[i]]\n    r = 1\n    for cp in tl:\n        r *= dd[cp]*cc[cp]\n        dd[cp] -= 1\n    for cp in tl:\n        dd[cp] += 1\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dd[ff]-=1\n    for j in range(i+1, N):\n        sl = ss[j]\n        x, y, z, w = sl\n        dd[sl]-=1\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        dd[sl]+=1\n    dd[ff]+=1\nprint(r//3)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\ndef decode(x):\n    for _ in range(4):\n        yield x & mask\n        x >>= 10\n\ndef P(n,k):\n    x = 1\n    for i in range(k):\n        x *= (n-i)\n    return x\n\ndef symmetry(tile):\n    a,b,c,d = decode(tile)\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    tiles.append(encode(a,b,c,d))\ncounter = Counter(tiles)\n\ncounter\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode(bottom)\n    e,f,g,h = decode(top)\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            x *= P(counter[tile],cnt) # 残っている個数、必要枚数\n            x *= pow(symmetry(tile), cnt)\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "n=input()\nCs=[map(int,raw_input().split()) for i in xrange(n)]\nD=[None]*n\nrot = [1]*n\ndic = {}\nr4 = range(4)\nfor i,C in enumerate(Cs):\n    l=list()\n    rc = 0\n    for j in r4:\n        c = tuple(C[j:]+C[:j])\n        if c in l:\n            rc += 1\n        else:\n            l.append(c)\n            dic.setdefault(c,[]).append(i)\n    if rc:\n        rot[i] = (rc+1)/2*2\n    D[i]=l\nans = 0\nfor i in xrange(n):\n    di=D[i][0]\n    for j in xrange(i+1,n):\n        for dj in D[j]:\n            dj=list(dj)\n            P=[None]*4\n            dd = {}\n            dks = []\n            for k in r4:\n                dk = (di[k-3],di[k-4],dj[1-k],dj[-k])\n                P[k] = p = tuple(filter(lambda x: x!=i and x!=j, dic.get(dk, [])))\n                dd[p] = dd.get(p,0)+1\n                dks.append(dk)\n            if any(not p for p in P) or any(min(p) < i for p in P):\n                continue\n            res = 1\n            if dks[0]==dks[1]==dks[2]==dks[3]:\n                res = 4\n            elif dks[0]==dks[2] and dks[1]==dks[3]:\n                res = 2\n            for k,v in dd.items():\n                if len(k) < v:\n                    res = 0\n                    break\n                for ke in k:\n                    res *= rot[ke]\n                while v:\n                    res *= len(k)-v+1\n                    v -= 1\n            ans += res\nprint ans"
  },
  {
    "language": "Python",
    "code": "#    X2 \n# X1 X0 X4 X5 \n#    X3\n#\n# C0    C1\n#    X0 \n# C3    C2\n#\n# C1    C0\n#    5X \n# C2    C3\n#\nN = int(raw_input())\n# N = 6\n# N = 8\n\nC_list = []\nfor n in range(N):\n    C_list.append(map(int, raw_input().split()))\n\n\n\"\"\"\nC_list = [\n    [0, 1, 2, 3], \n    [0, 4, 6, 1], \n    [1, 6, 7, 2], \n    [2, 7, 5, 3], \n    [6, 4, 5, 7], \n    [4, 0, 3, 5]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 1, 1], \n    [0, 1, 0, 1], \n    [0, 1, 1, 0], \n    [1, 0, 0, 1], \n    [1, 0, 1, 0], \n    [1, 1, 0, 0], \n    [1, 1, 1, 1]\n]\n\nC_list = [\n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0], \n    [0, 0, 0, 0]\n]\n\"\"\"\nres = 0\n\ndef rotate(A, n):\n    if n == 0:\n        return A\n    elif n == 1:\n        return [A[1], A[2], A[3], A[0]]\n    elif n == 2:\n        return [A[2], A[3], A[0], A[1]]\n    elif n == 3:\n        return [A[3], A[0], A[1], A[2]]\n    \n\nfor i in range(N-1):\n    X0_ = C_list[i]\n    for j in range(i+1, N):\n        X5 = [C_list[j][1], C_list[j][0], C_list[j][3], C_list[j][2]]\n        for k in range(4):\n            X0 = rotate(X0_, k)\n            X1 = [X5[0], X5[1], X0[1], X0[0]]\n            X2 = [X5[1], X5[2], X0[2], X0[1]]\n            X3 = [X5[2], X5[3], X0[3], X0[2]]\n            X4 = [X5[3], X5[0], X0[0], X0[3]]\n\n            # drop duplicate\n            c1 = 0\n            c2 = 0\n            c3 = 0\n            c4 = 0\n            \n            if X2 in [rotate(X1, l) for l in range(4)]:\n                c2 += 1\n            if X3 in [rotate(X1, l) for l in range(4)]:\n                c3 += 1\n            if X3 in [rotate(X2, l) for l in range(4)]:\n                c3 += 1\n            if X4 in [rotate(X1, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X2, l) for l in range(4)]:\n                c4 += 1\n            if X4 in [rotate(X3, l) for l in range(4)]:\n                c4 += 1\n            \n\n            # count duplicate\n            if X1 == rotate(X1, 1):\n                k1 = 4\n            elif X1 == rotate(X1, 2):\n                k1 = 2\n            else:\n                k1 = 1\n            if X2 == rotate(X2, 1):\n                k2 = 4\n            elif X2 == rotate(X2, 2):\n                k2 = 2\n            else:\n                k2 = 1\n            if X3 == rotate(X3, 1):\n                k3 = 4\n            elif X3 == rotate(X3, 2):\n                k3 = 2\n            else:\n                k3 = 1\n            if X4 == rotate(X4, 1):\n                k4 = 4\n            elif X4 == rotate(X4, 2):\n                k4 = 2\n            else:\n                k4 = 1\n            # count how many fits\n            r1 = max(sum([C_list[m] in [rotate(X1, l) for l in range(4)] for m in range(i+1, N) if m != j]) - c1, 0)\n            r2 = max(sum([C_list[m] in [rotate(X2, l) for l in range(4)] for m in range(i+1, N) if m != j]) - c2, 0)\n            r3 = max(sum([C_list[m] in [rotate(X3, l) for l in range(4)] for m in range(i+1, N) if m != j]) - c3, 0)\n            r4 = max(sum([C_list[m] in [rotate(X4, l) for l in range(4)] for m in range(i+1, N) if m != j]) - c4, 0)\n            #if r1*r2*r3*r4 > 0:\n                #print i,j,k,X0, X5, r1, r2, r3, r4, c1, c2, c3, c4, k1, k2, k3, k4\n            res += r1*r2*r3*r4*k1*k2*k3*k4\n            \nprint res"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, = map(int, input().split())\ndd = defaultdict(int)\nss = []\nfor _ in range(N):\n    a, b, c, d = map(int, input().split())\n    dd[(a,b,c,d)] += 1\n    dd[(b,c,d,a)] += 1\n    dd[(c,d,a,b)] += 1\n    dd[(d,a,b,c)] += 1\n    ss.append((a,b,c,d))\ndef icr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] += 1\ndef dcr(x):\n    a, b, c, d = x\n    for faf in [(b,c,d,a), (c,d,a,b), (d,a,b,c), (a,b,c,d)]:\n        dd[faf] -= 1\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e, h, g, f = gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    r = 1\n    for cp in tl:\n        r *= dd[cp]\n        dcr(cp)\n    for cp in tl:\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    a,b,c,d = ss[i]\n    ff = (a,b,c,d)\n    dcr(ff)\n    for j in range(i+1, N):\n        if i == j:\n            continue\n        x, y, z, w = ss[j]\n        sl = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sl:\n            dcr(s)\n            r += f(ff,s)\n            icr(s)\n    icr(ff)\nprint(r//3)\n \n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nimport itertools\nfrom functools import lru_cache\n\nmask = (1 << 10) - 1\n\n@lru_cache(None)\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\n@lru_cache(None)\ndef decode(x):\n    return [(x >> n) &mask for n in [0,10,20,30]]\n\n@lru_cache(None)\ndef P(n,k):\n    x = 1\n    for i in range(k):\n        x *= (n-i)\n    return x\n\n@lru_cache(None)\ndef symmetry(tile):\n    a,b,c,d = decode(tile)\n    if a == b == c == d:\n        return 4\n    if a == c and b == d:\n        return 2\n    return 1\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    tiles.append(encode(a,b,c,d))\ncounter = Counter(tiles)\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode(bottom)\n    e,f,g,h = decode(top)\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            x *= P(counter[tile],cnt) # 残っている個数、必要枚数\n            x *= pow(symmetry(tile), cnt)\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\nsymmetry = dict()\ndecode = dict()\ncounter = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for x,y,z,w in [(a,b,c,d), (b,c,d,a), (c,d,a,b), (d,a,b,c)]:\n        u = x + (y << 10) + (z << 20) + (w << 30)\n        if t > u:\n            t = u\n    return t\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    t = encode(a,b,c,d)\n    tiles.append(t)\n    counter[t] += 1\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    decode[t] = (a,b,c,d)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\nP += [(0,0,0,0,0)] * (N+1) # 負数代入対策\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode[bottom]\n    e,f,g,h = decode[top]\n    for x,y,z,w in [(e,f,g,h), (f,g,h,e), (g,h,e,f), (h,e,f,g)]:\n        # a,b,c,d\n        # x,w,z,y \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,x,w), (c,b,w,z), (d,c,z,y), (a,d,y,x)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, Counter\nimport itertools\n\nmask = (1 << 10) - 1\n\nsymmetry = dict()\ndecode = dict()\ncounter = defaultdict(int)\n\ndef encode(a,b,c,d):\n    t = 1 << 40\n    for _ in range(4):\n        a,b,c,d = b,c,d,a\n        x = a + (b << 10) + (c << 20) + (d << 30)\n        if t > x:\n            t = x\n    return t\n\nN = int(input())\ntiles = []\nfor _ in range(N):\n    a,b,c,d = map(int,input().split())\n    t = encode(a,b,c,d)\n    tiles.append(t)\n    counter[t] += 1\n    if a == b == c == d:\n        symmetry[t] = 4\n    elif a == c and b == d:\n        symmetry[t] = 2\n    else:\n        symmetry[t] = 1\n    decode[t] = (a,b,c,d)\n\nP = [(1,n,n*(n-1),n*(n-1)*(n-2),n*(n-1)*(n-2)*(n-3)) for n in range(N+1)]\nP += [(0,0,0,0,0)] * (N+1) # 負数代入対策\n\npower = [[n ** e for e in range(5)] for n in range(5)]\n\nanswer = 0\nfor bottom, top in itertools.combinations(tiles,2):\n    counter[bottom] -= 1\n    counter[top] -= 1\n    a,b,c,d = decode[bottom]\n    e,f,g,h = decode[top]\n    for _ in range(4):\n        e,f,g,h = f,g,h,e\n        # a,b,c,d\n        # e,h,g,f \n        tiles = [encode(p,q,r,s) for p,q,r,s in [(b,a,e,h), (c,b,h,g), (d,c,g,f), (a,d,f,e)]]\n        need = Counter(tiles)\n        x = 1\n        for tile, cnt in need.items():\n            have = counter[tile]\n            if have < cnt:\n                x = 0\n                break\n            x *= P[counter[tile]][cnt] # 残っている個数、必要枚数\n            x *= power[symmetry[tile]][cnt]\n        answer += x\n    counter[bottom] += 1\n    counter[top] += 1\n\n# 上下を固定した分\nanswer //= 3\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        v: [[usize; 4]; n]\n    }\n    let mut ps = vec![];\n    for p in &v {\n        ps.push(canonical(p));\n    }\n    let mut ans = 0;\n    for i in 0..n {\n        let f = &ps[i];\n        for j in i + 1..n {\n            for r in 0..4 {\n                let mut b = rotate(&ps[j], r);\n                let mut rest = vec![];\n                for k in 0..4 {\n                    rest.push(canonical(&vec![f[k], b[(4 - k) % 4], b[3 - k], f[(k + 1) % 4]]));\n                }\n                rest.sort();\n                let mut tot = 1;\n                let mut c = 0;\n                for k in 0..4 {\n                    let d  = if rest[k] == rotate(&rest[k], 1) {\n                        4\n                    } else if rest[k][0] == rest[k][2] && rest[k][1] == rest[k][3] {\n                        2\n                    } else {\n                        1\n                    };\n                    let mut t = 0;\n                    for l in i + 1..n {\n                        if l == j {\n                            continue;\n                        }\n                        if ps[l] == rest[k] {\n                            t += 1;\n                        }\n                    }\n                    if k > 0 && rest[k] == rest[k - 1] {\n                        t = (t - c) * d;\n                        c += 1;\n                    } else {\n                        t *= d;\n                        c = 1;\n                    }\n                    tot *= t;\n                }\n                ans += tot;\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn canonical(v: &Vec<usize>) -> Vec<usize> {\n    let mut rot = vec![v.clone()];\n    for i in 1..v.len() {\n        rot.push(rotate(v, i));\n    }\n    rot.sort();\n    rot[0].clone()\n}\n\nfn rotate(v: &Vec<usize>, n: usize) -> Vec<usize> {\n    v[n..].iter().chain(v[0..n].iter()).cloned().collect()\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin chmin, chmax ----------\ntrait ChangeMinMax {\n    fn chmin(&mut self, x: Self) -> bool;\n    fn chmax(&mut self, x: Self) -> bool;\n}\n\nimpl<T: PartialOrd> ChangeMinMax for T {\n    fn chmin(&mut self, x: Self) -> bool {\n        *self > x && {\n            *self = x;\n            true\n        }\n    }\n    fn chmax(&mut self, x: Self) -> bool {\n        *self < x && {\n            *self = x;\n            true\n        }\n    }\n}\n// ---------- end chmin, chmax ----------\n\nuse proconio::*;\n\n#[fastout]\nfn run() {\n    input! {\n        n: usize,\n        a: [[u16; 4]; n],\n    }\n    let mut a: Vec<_> = a.into_iter().map(|a| [a[0], a[1], a[2], a[3]]).collect();\n    let mut map = std::collections::BTreeMap::new();\n    for a in a.iter_mut() {\n        let mut x = *a;\n        for _ in 0..4 {\n            a.chmin(x.clone());\n            x.rotate_left(1);\n        }\n        *map.entry(a.clone()).or_insert(0u64) += 1;\n    }\n    let mut ans = 0;\n    for (i, f) in a.iter().enumerate() {\n        *map.get_mut(f).unwrap() -= 1;\n        for down in a.iter().skip(i + 1) {\n            *map.get_mut(down).unwrap() -= 1;\n            let mut t = [down[1], down[0], down[3], down[2]];\n            for _ in 0..4 {\n                let mut memo = std::collections::BTreeMap::new();\n                let x = [f[3], f[2], f[1], f[0], f[3]];\n                let y = [t[3], t[2], t[1], t[0], t[3]];\n                for (x, y) in x.windows(2).zip(y.windows(2)) {\n                    let mut p = [x[0], x[1], y[1], y[0]];\n                    let mut q = p.clone();\n                    for _ in 0..4 {\n                        p.chmin(q.clone());\n                        q.rotate_left(1);\n                    }\n                    *memo.entry(p).or_insert(0) += 1;\n                }\n                let mut val = 1;\n                for (p, c) in memo {\n                    let mut q = p.clone();\n                    let mut v = 0;\n                    for _ in 0..4 {\n                        if p == q {\n                            v += 1;\n                        }\n                        q.rotate_left(1);\n                    }\n                    let a = map.get(&p).cloned().unwrap_or(0);\n                    for i in 0..c {\n                        val *= (a - i) * v;\n                    }\n                }\n                ans += val;\n                t.rotate_left(1);\n            }\n            *map.get_mut(down).unwrap() += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let n = i.read::<usize>();\n    let mut c = Vec::new();\n    for _ in 0..n {\n        c.push(i.read_array::<[usize; 4], _>());\n    }\n    writeln!(o, \"{}\", solve(c)).unwrap();\n}\nfn solve(mut c: Vec<[usize; 4]>) -> usize {\n    fn f(colors: &[[usize; 4]; 2], c: &mut [[usize; 4]], n: usize) -> usize {\n        if n == 4 {\n            return 1;\n        }\n        let j0 = n;\n        let j1 = (n + 1) % 4;\n        let ct = [colors[0][j0], colors[1][j0], colors[1][j1], colors[0][j1]];\n        let mut result = 0;\n        for i in 0..c.len() {\n            c.swap(0, i);\n            let mut ci = c[0];\n            let mut r = 0;\n            for _ in 0..4 {\n                if ci == ct {\n                    r += 1;\n                }\n                ci.rotate(1);\n            }\n            if r != 0 {\n                result += r * f(colors, &mut c[1..], n + 1);\n            }\n            c.swap(0, i);\n        }\n        result\n    }\n\n    let mut colors = [[0; 4]; 2];\n    let mut result = 0;\n\n    for i0 in 0..c.len() - 5 {\n        colors[0] = c[i0];\n        let mut c = &mut c[i0 + 1..];\n        for i1 in 0..c.len() {\n            c.swap(0, i1);\n            colors[1] = c[0];\n            colors[1].reverse();\n            for _ in 0..4 {\n                result += f(&colors, &mut c[1..], 0);\n                colors[1].rotate(1);\n            }\n            c.swap(0, i1);\n        }\n    }\n    result\n}\n\nmod utils {\n    use super::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n\n        pub fn read_array<A, T>(&mut self) -> A\n        where\n            T: FromStr,\n            A: AsMut<[T]> + Default,\n        {\n            let mut a: A = Default::default();\n            {\n                let a: &mut [T] = a.as_mut();\n                let i = &mut self.read_line().split(' ');\n                for n in 0..a.len() {\n                    a[n] = next(i);\n                }\n            }\n            a\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    pub trait AtSliceExt<T> {\n        fn rotate(&mut self, mid: usize);\n    }\n    impl<T> AtSliceExt<T> for [T] {\n        fn rotate(&mut self, mid: usize) {\n            {\n                let (l, r) = self.split_at_mut(mid);\n                l.reverse();\n                r.reverse();\n            }\n            self.reverse()\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\ntype Tile = [usize; 4];\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let n = i.read::<usize>();\n    let mut c = Vec::new();\n    for _ in 0..n {\n        c.push(i.read_array::<[usize; 4], _>());\n    }\n    writeln!(o, \"{}\", solve(c)).unwrap();\n}\n\nfn solve(c: Vec<Tile>) -> usize {\n    fn f(c: &mut [(Tile, usize)], cts: &[(Tile, usize); 4], n: usize) -> usize {\n        if n == 4 {\n            return 1;\n        }\n        let ct = cts[n];\n        let mut result = 0;\n        for i in 0..c.len() {\n            if c[i].1 == 0 || c[i].0 != ct.0 {\n                continue;\n            }\n            let count = c[i].1 * ct.1;\n            c[i].1 -= 1;\n            result += count * f(c, cts, n + 1);\n            c[i].1 += 1;\n        }\n        result\n    }\n    fn normalize(mut c: Tile) -> (Tile, usize) {\n        let mut c_min = c;\n        let mut count = 1;\n        for _ in 1..4 {\n            c.rotate(1);\n            if c < c_min {\n                c_min = c;\n                count = 1;\n            } else if c == c_min {\n                count += 1;\n            }\n        }\n        (c_min, count)\n    }\n    let mut m = HashMap::new();\n    for &c in &c {\n        *m.entry(normalize(c).0).or_insert(0) += 1;\n    }\n    let mut c: Vec<_> = m.into_iter().collect();\n    let mut result = 0;\n    let mut cts = [([0; 4], 0); 4];\n    for i0 in 0..c.len() {\n        let c0 = c[i0];\n        c[i0].1 -= 1;\n        for i1 in 0..c.len() {\n            let mut c1 = c[i1];\n            if c1.1 == 0 {\n                continue;\n            }\n            c1.0.reverse();\n            c[i1].1 -= 1;\n            for _ in 0..4 {\n                for j0 in 0..4 {\n                    let j1 = (j0 + 1) % 4;\n                    cts[j0] = normalize([c0.0[j0], c1.0[j0], c1.0[j1], c0.0[j1]]);\n                }\n                result += c0.1 * c1.1 * f(&mut c, &cts, 0);\n                c1.0.rotate(1);\n            }\n            c[i1].1 += 1;\n        }\n        c[i0].1 += 1;\n    }\n    result / 6\n}\n\nmod utils {\n    use super::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n\n        pub fn read_array<A, T>(&mut self) -> A\n        where\n            T: FromStr,\n            A: AsMut<[T]> + Default,\n        {\n            let mut a: A = Default::default();\n            {\n                let a: &mut [T] = a.as_mut();\n                let i = &mut self.read_line().split(' ');\n                for n in 0..a.len() {\n                    a[n] = next(i);\n                }\n            }\n            a\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    pub trait AtSliceExt<T> {\n        fn rotate(&mut self, mid: usize);\n    }\n    impl<T> AtSliceExt<T> for [T] {\n        fn rotate(&mut self, mid: usize) {\n            {\n                let (l, r) = self.split_at_mut(mid);\n                l.reverse();\n                r.reverse();\n            }\n            self.reverse()\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\n#[derive(Debug)]\nstruct PanelSet {\n    color_map: HashMap<usize, usize>\n}\n\nimpl PanelSet {\n    fn new() -> Self {\n        PanelSet { color_map: HashMap::new() }\n    }\n\n    fn modify(&mut self, colors: &Vec<usize>, diff: i32) {\n        for d in 0..4 {\n            let cls = vec![colors[d], colors[(d+1)%4], colors[(d+2)%4], colors[(d+3)%4]];\n            let code = Self::color_code(&cls);\n            let now: i32 = (*self.color_map.get(&code).unwrap_or(&0)) as i32;\n            if now + diff == 0 {\n                self.color_map.remove(&code);\n            } else {\n                self.color_map.insert(code, (now + diff) as usize);\n            }\n        }\n    }\n\n    fn add(&mut self, colors: &Vec<usize>) {\n        self.modify(colors, 1)\n    }\n\n    fn remove(&mut self, colors: &Vec<usize>) {\n        self.modify(colors, -1)\n    }\n\n    fn way(&self, colors: &Vec<usize>) -> usize {\n        let code = Self::color_code(&colors);\n        *self.color_map.get(&code).unwrap_or(&0)\n    }\n\n    fn color_code(colors: &Vec<usize>) -> usize {\n        colors[0] * 1000000000 + colors[1] * 1000000 + colors[2] * 1000 + colors[3]\n    }\n}\n\n\nfn main() {\n    let n: usize = read();\n    let mut panels: Vec<Vec<usize>> = vec![];\n    for i in 0..n {\n        panels.push(readnc());\n    }\n\n    let mut panel_set = PanelSet::new();\n    for i in 0..n {\n        panel_set.add(&panels[i]);\n    }\n\n\n    let mut ans = 0;\n    for i in 0..n {\n        panel_set.remove(&panels[i]);\n        for j in i+1..n {\n            panel_set.remove(&panels[j]);\n\n            let upper = panels[i].clone();\n            for d in 0..4 {\n                let downer = vec![panels[j][d], panels[j][(d+3)%4], panels[j][(d+2)%4], panels[j][(d+1)%4]];\n\n                let mut ways = 1;\n                let mut required_colors = vec![];\n                for w in 0..4 {\n                    required_colors.push(vec![upper[w], downer[w], downer[(w+1)%4], upper[(w+1)%4]]);\n                }\n\n                for req in &required_colors {\n                    ways *= panel_set.way(&req);\n                    panel_set.remove(&req);\n                }\n                ans += ways;\n                for req in &required_colors {\n                    panel_set.add(&req);\n                }\n            }\n            panel_set.add(&panels[j]);\n        }\n    }\n\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\n\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let n = i.read::<usize>();\n    let mut c = Vec::new();\n    for _ in 0..n {\n        c.push(i.read_array::<[usize; 4], _>());\n    }\n    writeln!(o, \"{}\", solve(c)).unwrap();\n}\nfn solve(mut c: Vec<[usize; 4]>) -> usize {\n    fn f(colors: &[[usize; 4]; 2], c: &mut [[usize; 4]], n: usize) -> usize {\n        if n == 4 {\n            return 1;\n        }\n        let j0 = n;\n        let j1 = (n + 1) % 4;\n        let ct = [colors[0][j0], colors[1][j0], colors[1][j1], colors[0][j1]];\n        let mut result = 0;\n        for i in 0..c.len() {\n            c.swap(0, i);\n            let mut ci = c[0];\n            for _ in 0..4 {\n                if ci == ct {\n                    result += f(colors, &mut c[1..], n + 1);\n                }\n                ci.rotate(1);\n            }\n            c.swap(0, i);\n        }\n        result\n    }\n\n    let mut colors = [[0; 4]; 2];\n    let mut result = 0;\n\n    for i0 in 0..c.len() - 5 {\n        colors[0] = c[i0];\n        let mut c = &mut c[i0 + 1..];\n        for i1 in 0..c.len() {\n            c.swap(0, i1);\n            colors[1] = c[0];\n            colors[1].reverse();\n            for _ in 0..4 {\n                result += f(&colors, &mut c[1..], 0);\n                colors[1].rotate(1);\n            }\n            c.swap(0, i1);\n        }\n    }\n    result\n}\n\nmod utils {\n    use super::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n\n        pub fn read_array<A, T>(&mut self) -> A\n        where\n            T: FromStr,\n            A: AsMut<[T]> + Default,\n        {\n            let mut a: A = Default::default();\n            {\n                let a: &mut [T] = a.as_mut();\n                let i = &mut self.read_line().split(' ');\n                for n in 0..a.len() {\n                    a[n] = next(i);\n                }\n            }\n            a\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    pub trait AtSliceExt<T> {\n        fn rotate(&mut self, mid: usize);\n    }\n    impl<T> AtSliceExt<T> for [T] {\n        fn rotate(&mut self, mid: usize) {\n            {\n                let (l, r) = self.split_at_mut(mid);\n                l.reverse();\n                r.reverse();\n            }\n            self.reverse()\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        v: [[usize; 4]; n]\n    }\n    let mut ps = vec![];\n    for p in &v {\n        ps.push(canonical(p));\n    }\n    let mut ans: usize = 0;\n    for i in 0..n {\n        let f = &ps[i];\n        for j in i + 1..n {\n            for r in 0..4 {\n                let b = rotate(&ps[j], r);\n                let mut rest = vec![];\n                for k in 0..4 {\n                    rest.push(canonical(&vec![f[k], b[(4 - k) % 4], b[3 - k], f[(k + 1) % 4]]));\n                }\n                rest.sort();\n                let mut tot = 1;\n                let mut c = 0;\n                for k in 0..4 {\n                    let d  = if rest[k] == rotate(&rest[k], 1) {\n                        4\n                    } else if rest[k][0] == rest[k][2] && rest[k][1] == rest[k][3] {\n                        2\n                    } else {\n                        1\n                    };\n                    let mut t = 0;\n                    for l in i + 1..n {\n                        if l == j {\n                            continue;\n                        }\n                        if ps[l] == rest[k] {\n                            t += 1;\n                        }\n                    }\n                    if k > 0 && rest[k] == rest[k - 1] {\n                        if t < c {\n                            t = 0;\n                        } else {\n                            t = (t - c) * d;\n                        }\n                        c += 1;\n                    } else {\n                        t *= d;\n                        c = 1;\n                    }\n                    tot *= t;\n                }\n                ans += tot;\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn canonical(v: &Vec<usize>) -> Vec<usize> {\n    let mut rot = vec![v.clone()];\n    for i in 1..v.len() {\n        rot.push(rotate(v, i));\n    }\n    rot.sort();\n    rot[0].clone()\n}\n\nfn rotate(v: &Vec<usize>, n: usize) -> Vec<usize> {\n    v[n..].iter().chain(v[0..n].iter()).cloned().collect()\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cell::Cell;\nuse utils::*;\n\npub fn main() {\n    let i = stdin();\n    let mut o = Vec::new();\n    run(i.lock(), &mut o);\n    stdout().write_all(&o).unwrap();\n}\ntype Tile = [usize; 4];\nfn run<R: BufRead, W: Write>(i: R, o: &mut W) {\n    let mut i = AtRead::from(i);\n    let n = i.read::<usize>();\n    let mut c = Vec::new();\n    for _ in 0..n {\n        c.push(i.read_array::<[usize; 4], _>());\n    }\n    writeln!(o, \"{}\", solve(c)).unwrap();\n}\n\nfn solve(c: Vec<Tile>) -> usize {\n    fn f(m: &HashMap<Tile, Cell<usize>>, cts: &[(Tile, usize); 4], n: usize) -> usize {\n        if n == 4 {\n            return 1;\n        }\n        let mut result = 0;\n        if let Some(count_cell) = m.get(&cts[n].0) {\n            let count = count_cell.get();\n            if count != 0 {\n                count_cell.set(count - 1);\n                result = cts[n].1 * count * f(m, cts, n + 1);\n                count_cell.set(count);\n            }\n        }\n        result\n    }\n    fn normalize(mut c: Tile) -> (Tile, usize) {\n        let mut c_min = c;\n        let mut count = 1;\n        for _ in 1..4 {\n            c.rotate(1);\n            if c < c_min {\n                c_min = c;\n                count = 1;\n            } else if c == c_min {\n                count += 1;\n            }\n        }\n        (c_min, count)\n    }\n    let mut m = HashMap::new();\n    for &c in &c {\n        *m.entry(normalize(c).0).or_insert(Cell::new(0)).get_mut() += 1;\n    }\n    let mut result = 0;\n    let mut cts = [([0; 4], 0); 4];\n    for c0 in &m {\n        let c0_count = c0.1.get();\n        c0.1.set(c0_count - 1);\n        for c1 in &m {\n            let c1_count = c1.1.get();\n            if c1_count == 0 {\n                continue;\n            }\n            c1.1.set(c1_count - 1);\n            let mut c1c = *c1.0;\n            c1c.reverse();\n            for _ in 0..4 {\n                for j0 in 0..4 {\n                    let j1 = (j0 + 1) % 4;\n                    cts[j0] = normalize([c0.0[j0], c1c[j0], c1c[j1], c0.0[j1]]);\n                }\n                result += c0_count * c1_count * f(&m, &cts, 0);\n                c1c.rotate(1);\n            }\n            c1.1.set(c1_count);\n        }\n        c0.1.set(c0_count);\n    }\n    result / 6\n}\n\nmod utils {\n    use super::*;\n\n    pub struct AtRead<R: BufRead> {\n        r: R,\n        s: String,\n    }\n\n    impl<R: BufRead> AtRead<R> {\n        pub fn from(r: R) -> Self {\n            AtRead {\n                r: r,\n                s: String::new(),\n            }\n        }\n        pub fn read_line(&mut self) -> &str {\n            self.s.clear();\n            self.r.read_line(&mut self.s).unwrap();\n            self.s.trim()\n        }\n\n        pub fn read<T: FromStr>(&mut self) -> T {\n            self.read_line().parse().ok().unwrap()\n        }\n\n        pub fn read_array<A, T>(&mut self) -> A\n        where\n            T: FromStr,\n            A: AsMut<[T]> + Default,\n        {\n            let mut a: A = Default::default();\n            {\n                let a: &mut [T] = a.as_mut();\n                let i = &mut self.read_line().split(' ');\n                for n in 0..a.len() {\n                    a[n] = next(i);\n                }\n            }\n            a\n        }\n    }\n\n    fn next<'a, T: FromStr, I: std::iter::Iterator<Item = &'a str>>(i: &mut I) -> T {\n        i.next().unwrap().parse().ok().unwrap()\n    }\n\n    pub trait AtSliceExt<T> {\n        fn rotate(&mut self, mid: usize);\n    }\n    impl<T> AtSliceExt<T> for [T] {\n        fn rotate(&mut self, mid: usize) {\n            {\n                let (l, r) = self.split_at_mut(mid);\n                l.reverse();\n                r.reverse();\n            }\n            self.reverse()\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\n#[derive(Debug)]\nstruct PanelSet {\n    color_map: HashMap<usize, usize>\n}\n\nimpl PanelSet {\n    fn new() -> Self {\n        PanelSet { color_map: HashMap::new() }\n    }\n\n    fn modify(&mut self, colors: &Vec<usize>, diff: i32) {\n        for d in 0..4 {\n            let cls = vec![colors[d], colors[(d+1)%4], colors[(d+2)%4], colors[(d+3)%4]];\n            let code = Self::color_code(&cls);\n            let now: i32 = (*self.color_map.get(&code).unwrap_or(&0)) as i32;\n            self.color_map.insert(code, (now+diff) as usize);\n        }\n    }\n\n    fn add(&mut self, colors: &Vec<usize>) {\n        self.modify(colors, 1)\n    }\n\n    fn remove(&mut self, colors: &Vec<usize>) {\n        self.modify(colors, -1)\n    }\n\n    fn way(&self, colors: &Vec<usize>) -> usize {\n        let code = Self::color_code(&colors);\n        *self.color_map.get(&code).unwrap_or(&0)\n    }\n\n    fn color_code(colors: &Vec<usize>) -> usize {\n        colors[0] * 1000000000 + colors[1] * 1000000 + colors[2] * 1000 + colors[3]\n    }\n}\n\n\nfn main() {\n    let n: usize = read();\n    let mut panels: Vec<Vec<usize>> = vec![];\n    for i in 0..n {\n        panels.push(readnc());\n    }\n\n    let mut panel_set = PanelSet::new();\n    for i in 0..n {\n        panel_set.add(&panels[i]);\n    }\n\n\n    let mut ans = 0;\n    for i in 0..n {\n        panel_set.remove(&panels[i]);\n        for j in i+1..n {\n            panel_set.remove(&panels[j]);\n\n            let upper = panels[i].clone();\n            for d in 0..4 {\n                let downer = vec![panels[j][d], panels[j][(d+3)%4], panels[j][(d+2)%4], panels[j][(d+1)%4]];\n\n                let mut ways = 1;\n                let mut required_colors = vec![];\n                for w in 0..4 {\n                    required_colors.push(vec![upper[w], downer[w], downer[(w+1)%4], upper[(w+1)%4]]);\n                }\n\n                for req in &required_colors {\n                    ways *= panel_set.way(&req);\n                    panel_set.remove(&req);\n                }\n                ans += ways;\n                for req in &required_colors {\n                    panel_set.add(&req);\n                }\n            }\n            panel_set.add(&panels[j]);\n        }\n    }\n\n    println!(\"{}\", ans);\n}"
  }
]