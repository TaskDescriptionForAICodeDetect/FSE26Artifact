[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y, floor, steps;\n} Node;\n\ntypedef struct {\n    Node data[MAX_SIZE * MAX_SIZE * 2];\n    int front, rear;\n} Queue;\n\nvoid initQueue(Queue *q) {\n    q->front = q->rear = 0;\n}\n\nint isEmpty(Queue *q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue *q, Node node) {\n    q->data[q->rear++] = node;\n}\n\nNode dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nint minStepsToEscape(char grid[2][MAX_SIZE][MAX_SIZE], int rows, int cols, int startX, int startY, int exitX, int exitY) {\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    int visited[2][MAX_SIZE][MAX_SIZE];\n    memset(visited, 0, sizeof(visited));\n\n    Queue q;\n    initQueue(&q);\n    Node start = {startX, startY, 0, 0};\n    enqueue(&q, start);\n    visited[0][startX][startY] = 1;\n\n    while (!isEmpty(&q)) {\n        Node current = dequeue(&q);\n        if (current.x == exitX && current.y == exitY) {\n            return current.steps;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                if (grid[current.floor][nx][ny] != 'W' && !visited[current.floor][nx][ny]) {\n                    visited[current.floor][nx][ny] = 1;\n                    Node next = {nx, ny, current.floor, current.steps + 1};\n                    enqueue(&q, next);\n                }\n            }\n        }\n\n        if (grid[current.floor][current.x][current.y] == 'S') {\n            int nextFloor = 1 - current.floor;\n            if (!visited[nextFloor][current.x][current.y]) {\n                visited[nextFloor][current.x][current.y] = 1;\n                Node next = {current.x, current.y, nextFloor, current.steps + 1};\n                enqueue(&q, next);\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int rows, cols;\n    scanf(\"%d %d\", &rows, &cols);\n    char grid[2][MAX_SIZE][MAX_SIZE];\n    for (int f = 0; f < 2; f++) {\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[f][i]);\n        }\n    }\n    int startX, startY, exitX, exitY;\n    scanf(\"%d %d %d %d\", &startX, &startY, &exitX, &exitY);\n    int result = minStepsToEscape(grid, rows, cols, startX, startY, exitX, exitY);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int x, y, floor, steps;\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<char>> grid1(H, vector<char>(W));\n    vector<vector<char>> grid2(H, vector<char>(W));\n    \n    int start_x, start_y, start_floor;\n    int exit_x, exit_y, exit_floor;\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid1[i][j];\n            if (grid1[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n                start_floor = 1;\n            }\n            if (grid1[i][j] == 'E') {\n                exit_x = i;\n                exit_y = j;\n                exit_floor = 1;\n            }\n        }\n    }\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid2[i][j];\n            if (grid2[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n                start_floor = 2;\n            }\n            if (grid2[i][j] == 'E') {\n                exit_x = i;\n                exit_y = j;\n                exit_floor = 2;\n            }\n        }\n    }\n    \n    vector<vector<vector<int>>> dist(H, vector<vector<int>>(W, vector<int>(3, INT_MAX)));\n    queue<State> q;\n    \n    q.push({start_x, start_y, start_floor, 0});\n    dist[start_x][start_y][start_floor] = 0;\n    \n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (current.x == exit_x && current.y == exit_y && current.floor == exit_floor) {\n            cout << current.steps << endl;\n            return 0;\n        }\n        \n        for (int i = 0; i < 4; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            \n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            \n            if (current.floor == 1) {\n                if (grid1[nx][ny] == '#') continue;\n            } else {\n                if (grid2[nx][ny] == '#') continue;\n            }\n            \n            if (dist[nx][ny][current.floor] > current.steps + 1) {\n                dist[nx][ny][current.floor] = current.steps + 1;\n                q.push({nx, ny, current.floor, current.steps + 1});\n            }\n        }\n        \n        if ((current.floor == 1 && grid1[current.x][current.y] == 'W') || \n            (current.floor == 2 && grid2[current.x][current.y] == 'W')) {\n            int new_floor = (current.floor == 1) ? 2 : 1;\n            if (dist[current.x][current.y][new_floor] > current.steps + 1) {\n                dist[current.x][current.y][new_floor] = current.steps + 1;\n                q.push({current.x, current.y, new_floor, current.steps + 1});\n            }\n        }\n    }\n    \n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class LabyrinthEscape {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int escape(int[][] firstFloor, int[][] secondFloor, int[] start, int[] exit) {\n        int rows = firstFloor.length;\n        int cols = firstFloor[0].length;\n        boolean[][][] visited = new boolean[rows][cols][2];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start[0], start[1], 0, 0}); // x, y, floor, steps\n        visited[start[0]][start[1]][0] = true;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int floor = current[2];\n            int steps = current[3];\n\n            if (x == exit[0] && y == exit[1] && floor == exit[2]) {\n                return steps;\n            }\n\n            for (int[] dir : DIRECTIONS) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                    int[][] grid = (floor == 0) ? firstFloor : secondFloor;\n                    if (grid[nx][ny] != 1) { // 1 represents a wall\n                        if (!visited[nx][ny][floor]) {\n                            visited[nx][ny][floor] = true;\n                            queue.offer(new int[]{nx, ny, floor, steps + 1});\n                        }\n                    }\n                }\n            }\n\n            int[][] grid = (floor == 0) ? firstFloor : secondFloor;\n            if (grid[x][y] == 2) { // 2 represents a switch\n                int newFloor = 1 - floor;\n                if (!visited[x][y][newFloor]) {\n                    visited[x][y][newFloor] = true;\n                    queue.offer(new int[]{x, y, newFloor, steps + 1});\n                }\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 21:35:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public int minSteps(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][][] visited = new boolean[m][n][2];\n        Queue<int[]> queue = new LinkedList<>();\n\n        // Find start position\n        int startX = -1, startY = -1, startFloor = -1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                    startFloor = findFloor(grid, i, j);\n                    break;\n                }\n            }\n            if (startX != -1) break;\n        }\n\n        // Start BFS\n        queue.offer(new int[]{startX, startY, startFloor, 0});\n        visited[startX][startY][startFloor] = true;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], floor = current[2], steps = current[3];\n\n            // Check if exit reached\n            if (grid[x][y] == 'E') return steps;\n\n            // Try moving in 4 directions\n            for (int[] dir : DIRECTIONS) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n\n                if (isValidMove(grid, newX, newY, floor) && !visited[newX][newY][floor]) {\n                    queue.offer(new int[]{newX, newY, floor, steps + 1});\n                    visited[newX][newY][floor] = true;\n                }\n            }\n\n            // Try switching floors\n            if (grid[x][y] == 'C') {\n                int newFloor = 1 - floor;\n                if (!visited[x][y][newFloor]) {\n                    queue.offer(new int[]{x, y, newFloor, steps + 1});\n                    visited[x][y][newFloor] = true;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean isValidMove(char[][] grid, int x, int y, int floor) {\n        return x >= 0 && x < grid.length &&\n               y >= 0 && y < grid[0].length &&\n               findFloor(grid, x, y) == floor &&\n               grid[x][y] != '#';\n    }\n\n    private int findFloor(char[][] grid, int x, int y) {\n        return (grid[x][y] == '1' || grid[x][y] == 'C') ? 1 : 0;\n    }\n}",
    "timestamp": "2025-08-05 21:36:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 201\n#define MAX_QUEUE 40000\n\ntypedef struct {\n    int x, y, floor, steps;\n} State;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint bfs(char map[2][MAX_SIZE][MAX_SIZE], int rows, int cols, \n        int start_x, int start_y, int start_floor, \n        int exit_x, int exit_y, int exit_floor) {\n    \n    bool visited[2][MAX_SIZE][MAX_SIZE] = {{{false}}};\n    State queue[MAX_QUEUE];\n    int front = 0, rear = 0;\n\n    queue[rear++] = (State){start_x, start_y, start_floor, 0};\n    visited[start_floor][start_x][start_y] = true;\n\n    while (front < rear) {\n        State curr = queue[front++];\n\n        if (curr.x == exit_x && curr.y == exit_y && curr.floor == exit_floor) {\n            return curr.steps;\n        }\n\n        // Move in 4 directions\n        for (int i = 0; i < 4; i++) {\n            int nx = curr.x + dx[i];\n            int ny = curr.y + dy[i];\n\n            if (nx < 0 || nx >= rows || ny < 0 || ny >= cols || \n                map[curr.floor][nx][ny] == '#' || \n                visited[curr.floor][nx][ny]) {\n                continue;\n            }\n\n            queue[rear++] = (State){nx, ny, curr.floor, curr.steps + 1};\n            visited[curr.floor][nx][ny] = true;\n        }\n\n        // Check for stairs\n        if (map[curr.floor][curr.x][curr.y] == 'S') {\n            int next_floor = 1 - curr.floor;\n            if (!visited[next_floor][curr.x][curr.y] && \n                map[next_floor][curr.x][curr.y] != '#') {\n                queue[rear++] = (State){curr.x, curr.y, next_floor, curr.steps + 1};\n                visited[next_floor][curr.x][curr.y] = true;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int rows, cols;\n    char map[2][MAX_SIZE][MAX_SIZE];\n    int start_x, start_y, start_floor, exit_x, exit_y, exit_floor;\n\n    scanf(\"%d %d\", &rows, &cols);\n\n    for (int floor = 0; floor < 2; floor++) {\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", map[floor][i]);\n            for (int j = 0; j < cols; j++) {\n                if (map[floor][i][j] == 'O') {\n                    start_x = i;\n                    start_y = j;\n                    start_floor = floor;\n                }\n                if (map[floor][i][j] == 'X') {\n                    exit_x = i;\n                    exit_y = j;\n                    exit_floor = floor;\n                }\n            }\n        }\n    }\n\n    int result = bfs(map, rows, cols, start_x, start_y, start_floor, \n                     exit_x, exit_y, exit_floor);\n\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:36:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nclass Solution {\npublic:\n    int escapeLabyrinth(std::vector<std::vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        // Directions: up, down, left, right, switch floor\n        std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        // Queue for BFS: {row, col, floor, steps}\n        std::queue<std::tuple<int, int, int, int>> q;\n        \n        // 3D visited array to track visited states\n        std::vector<std::vector<std::vector<bool>>> visited(m, \n            std::vector<std::vector<bool>>(n, std::vector<bool>(2, false)));\n        \n        // Find start position\n        int startRow = -1, startCol = -1, startFloor = -1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'S') {\n                    startRow = i;\n                    startCol = j;\n                    startFloor = 0;\n                    break;\n                }\n            }\n            if (startRow != -1) break;\n        }\n        \n        // Initial state\n        q.push({startRow, startCol, startFloor, 0});\n        visited[startRow][startCol][startFloor] = true;\n        \n        while (!q.empty()) {\n            auto [row, col, floor, steps] = q.front();\n            q.pop();\n            \n            // Check if exit reached\n            if (grid[row][col] == 'E') {\n                return steps;\n            }\n            \n            // Regular movement\n            for (auto& [dx, dy] : directions) {\n                int newRow = row + dx;\n                int newCol = col + dy;\n                \n                // Check valid move\n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n &&\n                    grid[newRow][newCol] != '#' && !visited[newRow][newCol][floor]) {\n                    q.push({newRow, newCol, floor, steps + 1});\n                    visited[newRow][newCol][floor] = true;\n                }\n            }\n            \n            // Floor switch\n            if (grid[row][col] == 'T') {\n                int newFloor = 1 - floor;\n                if (!visited[row][col][newFloor]) {\n                    q.push({row, col, newFloor, steps + 1});\n                    visited[row][col][newFloor] = true;\n                }\n            }\n        }\n        \n        return -1;\n    }\n};",
    "timestamp": "2025-08-05 21:36:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef escape_labyrinth(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def is_valid(x, y, f):\n        return 0 <= x < rows and 0 <= y < cols and grid[x][y] != 'W' and grid[x][y][0] == f\n    \n    movements = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    start_pos = None\n    exits = set()\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S1':\n                start_pos = (i, j, '1')\n            elif grid[i][j] == 'S2':\n                start_pos = (i, j, '2')\n            elif grid[i][j] == 'E1':\n                exits.add((i, j, '1'))\n            elif grid[i][j] == 'E2':\n                exits.add((i, j, '2'))\n    \n    queue = deque([(start_pos[0], start_pos[1], start_pos[2], 0)])\n    visited = set([(start_pos[0], start_pos[1], start_pos[2])])\n    \n    while queue:\n        x, y, f, steps = queue.popleft()\n        if (x, y, f) in exits:\n            return steps\n        \n        if grid[x][y][0] == f and grid[x][y] != f and grid[x][y] != 'W':\n            next_floor = '1' if f == '2' else '2'\n            if is_valid(x, y, next_floor) and (x, y, next_floor) not in visited:\n                visited.add((x, y, next_floor))\n                queue.append((x, y, next_floor, steps + 1))\n          \n        for dx, dy in movements:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny, f) and (nx, ny, f) not in visited:\n                visited.add((nx, ny, f))\n                queue.append((nx, ny, f, steps + 1))\n    \n    return -1",
    "timestamp": "2025-08-13 07:06:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LabyrinthEscape {\n    \n    static class Position {\n        int x, y, floor, steps;\n        Position(int x, int y, int floor, int steps) {\n            this.x = x;\n            this.y = y;\n            this.floor = floor;\n            this.steps = steps;\n        }\n    }\n\n    public static int escapeLabyrinth(char[][][] maze, int startX, int startY, int startFloor, int exitX, int exitY) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n\n        // Directions for moving: up, down, left, right\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        // Queue for BFS: stores positions with current steps\n        Queue<Position> queue = new LinkedList<>();\n        queue.offer(new Position(startX, startY, startFloor, 0));\n        \n        // Visited array to keep track of visited states\n        boolean[][][] visited = new boolean[rows][cols][2];\n        visited[startX][startY][startFloor] = true;\n        \n        while (!queue.isEmpty()) {\n            Position pos = queue.poll();\n            // Check if we reached the exit\n            if (pos.x == exitX && pos.y == exitY && pos.floor == 0) {\n                return pos.steps;\n            }\n            \n            // Explore all 4 neighboring positions\n            for (int[] dir : directions) {\n                int newX = pos.x + dir[0];\n                int newY = pos.y + dir[1];\n                if (isValid(maze, newX, newY, pos.floor, visited)) {\n                    visited[newX][newY][pos.floor] = true;\n                    queue.offer(new Position(newX, newY, pos.floor, pos.steps + 1));\n                }\n            }\n            \n            // Check switch operations (if any and valid)\n            if (maze[pos.x][pos.y][pos.floor] == 'S') {\n                int newFloor = 1 - pos.floor; // Switch floor\n                if (!visited[pos.x][pos.y][newFloor]) {\n                    visited[pos.x][pos.y][newFloor] = true;\n                    queue.offer(new Position(pos.x, pos.y, newFloor, pos.steps + 1));\n                }\n            }\n        }\n        \n        return -1; // If escape is not possible\n    }\n\n    private static boolean isValid(char[][][] maze, int x, int y, int floor, boolean[][][] visited) {\n        return x >= 0 && x < maze.length && y >= 0 && y < maze[0].length &&\n               maze[x][y][floor] != '#' && !visited[x][y][floor];\n    }\n\n    public static void main(String[] args) {\n        // Example usage with a 3x3x2 maze (2 floors)\n        char[][][] maze = {\n            { {'S', '.', 'E'}, {'#', '.', '#'}, {'S', '.', '.'} }, // Floor 0\n            { {'.', '#', '.'}, {'.', 'S', '.'}, {'#', '.', '.'} }  // Floor 1\n        };\n        int startX = 0, startY = 0, startFloor = 0, exitX = 0, exitY = 2;\n        System.out.println(escapeLabyrinth(maze, startX, startY, startFloor, exitX, exitY));\n    }\n}",
    "timestamp": "2025-08-13 07:06:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define FLOOR_COUNT 2\n\ntypedef struct {\n    int x;\n    int y;\n    int floor;\n} Cell;\n\ntypedef struct {\n    Cell *data;\n    int front;\n    int rear;\n    int capacity;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->capacity = capacity;\n    queue->front = queue->rear = 0;\n    queue->data = (Cell*)malloc(queue->capacity * sizeof(Cell));\n    return queue;\n}\n\nbool isQueueEmpty(Queue* queue) {\n    return queue->rear == queue->front;\n}\n\nvoid enqueue(Queue* queue, Cell item) {\n    queue->data[queue->rear++] = item;\n}\n\nCell dequeue(Queue* queue) {\n    return queue->data[queue->front++];\n}\n\nvoid destroyQueue(Queue* queue) {\n    free(queue->data);\n    free(queue);\n}\n\nint minStepsToEscape(char*** labyrinth, int n, int m, Cell start, Cell end) {\n    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    bool visited[FLOOR_COUNT][n][m];\n    memset(visited, false, sizeof(visited));\n    \n    Queue* queue = createQueue(n * m * FLOOR_COUNT);\n    enqueue(queue, start);\n    visited[start.floor][start.x][start.y] = true;\n    int steps = 0;\n    \n    while (!isQueueEmpty(queue)) {\n        int size = queue->rear - queue->front;\n        for (int i = 0; i < size; i++) {\n            Cell current = dequeue(queue);\n\n            if (current.x == end.x && current.y == end.y && current.floor == end.floor) {\n                destroyQueue(queue);\n                return steps;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int nx = current.x + directions[d][0];\n                int ny = current.y + directions[d][1];\n                int nf = current.floor;\n\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && labyrinth[nf][nx][ny] != '#' && !visited[nf][nx][ny]) {\n                    enqueue(queue, (Cell){nx, ny, nf});\n                    visited[nf][nx][ny] = true;\n                }\n            }\n\n            if (labyrinth[current.floor][current.x][current.y] == 'S') {\n                int nf = current.floor == 0 ? 1 : 0;\n                if (!visited[nf][current.x][current.y]) {\n                    enqueue(queue, (Cell){current.x, current.y, nf});\n                    visited[nf][current.x][current.y] = true;\n                }\n            }\n        }\n        steps++;\n    }\n    \n    destroyQueue(queue);\n    return -1;\n}\n\nint main() {\n    // Initialize labyrinth, start & end points here for testing\n    return 0;\n}",
    "timestamp": "2025-08-13 07:07:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef escape_labyrinth(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def is_valid(r, c, floor):\n        return 0 <= r < rows and 0 <= c < cols and grid[r][c] != '#' and not visited[floor][r][c]\n    \n    def find_start_and_exit():\n        start, exit = None, None\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 'S':\n                    start = (r, c)\n                elif grid[r][c] == 'E':\n                    exit = (r, c)\n        return start, exit\n    \n    start, exit = find_start_and_exit()\n    visited = [[[False]*cols for _ in range(rows)] for _ in range(2)]\n    queue = deque([(start[0], start[1], 0, 0)])  # row, col, floor, steps\n    visited[0][start[0]][start[1]] = True\n    \n    while queue:\n        r, c, floor, steps = queue.popleft()\n        \n        if (r, c) == exit:\n            return steps\n        \n        # Try moving in 4 directions\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if is_valid(nr, nc, floor):\n                visited[floor][nr][nc] = True\n                queue.append((nr, nc, floor, steps + 1))\n        \n        # Try changing floors via switch\n        if grid[r][c] == 'T':\n            next_floor = 1 - floor\n            if is_valid(r, c, next_floor):\n                visited[next_floor][r][c] = True\n                queue.append((r, c, next_floor, steps + 1))\n        \n        # Try stairs\n        if grid[r][c] == 'U':  # Up stairs\n            next_floor = 1\n            if is_valid(r, c, next_floor):\n                visited[next_floor][r][c] = True\n                queue.append((r, c, next_floor, steps + 1))\n        \n        if grid[r][c] == 'D':  # Down stairs\n            next_floor = 0\n            if is_valid(r, c, next_floor):\n                visited[next_floor][r][c] = True\n                queue.append((r, c, next_floor, steps + 1))\n    \n    return -1",
    "timestamp": "2025-08-13 07:07:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    H = int(data[idx])\n    idx += 1\n    W = int(data[idx])\n    idx += 1\n    \n    grid1 = []\n    grid2 = []\n    \n    for _ in range(H):\n        grid1.append(data[idx])\n        idx += 1\n    for _ in range(H):\n        grid2.append(data[idx])\n        idx += 1\n    \n    # Find start and exit positions\n    start = None\n    exit_pos = None\n    for i in range(H):\n        for j in range(W):\n            if grid1[i][j] == 'S':\n                start = (i, j, 0)\n            if grid1[i][j] == 'E' or grid2[i][j] == 'E':\n                exit_pos = (i, j, 0) if grid1[i][j] == 'E' else (i, j, 1)\n    \n    if not start or not exit_pos:\n        print(-1)\n        return\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = [[[False for _ in range(W)] for __ in range(H)] for ___ in range(2)]\n    q = deque()\n    q.append((start[0], start[1], start[2], 0))\n    visited[start[2]][start[0]][start[1]] = True\n    \n    found = False\n    answer = -1\n    \n    while q:\n        i, j, floor, steps = q.popleft()\n        \n        if (i, j, floor) == exit_pos:\n            answer = steps\n            found = True\n            break\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                current_grid = grid1 if floor == 0 else grid2\n                if current_grid[ni][nj] == 'W':\n                    continue\n                if not visited[floor][ni][nj]:\n                    visited[floor][ni][nj] = True\n                    q.append((ni, nj, floor, steps + 1))\n        \n        # Check for switch\n        current_grid = grid1 if floor == 0 else grid2\n        if current_grid[i][j] == 'U':\n            new_floor = 1 - floor\n            if not visited[new_floor][i][j]:\n                visited[new_floor][i][j] = True\n                q.append((i, j, new_floor, steps + 1))\n    \n    print(answer if found else -1)\n\nsolve()",
    "timestamp": "2025-08-13 07:08:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nstruct State {\n    int x, y, floor, steps;\n};\n\nint escapeLabyrinth(const vector<vector<char>>& floor1, const vector<vector<char>>& floor2,\n                    int startX, int startY, int startFloor, int exitX, int exitY) {\n    \n    int n = floor1.size();\n    int m = floor1[0].size();\n    \n    vector<vector<vector<bool>>> visited(2, vector<vector<bool>>(n, vector<bool>(m, false)));\n    queue<State> q;\n    \n    q.push({startX, startY, startFloor, 0});\n    visited[startFloor][startX][startY] = true;\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (current.x == exitX && current.y == exitY && current.floor == 1) {\n            return current.steps;\n        }\n        \n        for (int k = 0; k < 4; ++k) {\n            int nx = current.x + dx[k], ny = current.y + dy[k];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                if (current.floor == 0 && floor1[nx][ny] != '#' && !visited[0][nx][ny]) {\n                    visited[0][nx][ny] = true;\n                    q.push({nx, ny, 0, current.steps + 1});\n                } else if (current.floor == 1 && floor2[nx][ny] != '#' && !visited[1][nx][ny]) {\n                    visited[1][nx][ny] = true;\n                    q.push({nx, ny, 1, current.steps + 1});\n                }\n            }\n        }\n\n        if (current.floor == 0 && floor1[current.x][current.y] == 'S' && !visited[1][current.x][current.y]) {\n            visited[1][current.x][current.y] = true;\n            q.push({current.x, current.y, 1, current.steps + 1});\n        } else if (current.floor == 1 && floor2[current.x][current.y] == 'S' && !visited[0][current.x][current.y]) {\n            visited[0][current.x][current.y] = true;\n            q.push({current.x, current.y, 0, current.steps + 1});\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<char>> floor1(n, vector<char>(m));\n    vector<vector<char>> floor2(n, vector<char>(m));\n    \n    int startX, startY, startFloor;\n    cin >> startX >> startY >> startFloor;\n    \n    int exitX, exitY;\n    cin >> exitX >> exitY;\n    \n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> floor1[i][j];\n    \n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> floor2[i][j];\n    \n    cout << escapeLabyrinth(floor1, floor2, startX, startY, startFloor, exitX, exitY) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:36:05"
  }
]