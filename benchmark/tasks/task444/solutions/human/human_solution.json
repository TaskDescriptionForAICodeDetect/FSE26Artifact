[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nstruct State{\n    // (y,x), floor f, bit b\n    int y,x,f,b;\n};\n\ninline int switch_num(char c){\n    if('a'<=c && c<='j') return c-'a';\n    if('A'<=c && c<='J') return c-'A';\n    return -1;\n}\n\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nconst int INF = 19191919;\nconst int N = 50, M = 1<<10;\nint d[N][N][2][M];\n\nint main(){\n    int w,h;\n    cin >>w >>h;\n\n    vector<string> m(h);\n    rep(i,h) cin >>m[i];\n\n    int s;\n    cin >>s;\n    vector<vector<string>> ms(s);\n    rep(i,s){\n        ms[i] = vector<string>(h);\n        rep(j,h) cin >>ms[i][j];\n    }\n\n    queue<State> que;\n    rep(i,N)rep(j,N)rep(k,2)rep(l,M) d[i][j][k][l] = INF;\n\n    pi start, goal;\n    rep(i,h)rep(j,w){\n        if(m[i][j] == '%') start = {i,j};\n        if(m[i][j] == '&') goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n    auto FLOOR = [&](int y, int x, int bit){\n        int ret = 0;\n        if(m[y][x]=='^' || ('A'<=m[y][x] && m[y][x]<='J')) ret = 1;\n        rep(i,s)if(bit>>i&1){\n            if(ms[i][y][x]=='*') ret = !ret;\n        }\n        return ret;\n    };\n\n    auto CHECK = [&](State c, State nc){\n        if(d[nc.y][nc.x][nc.f][nc.b] > d[c.y][c.x][c.f][c.b]+1){\n            d[nc.y][nc.x][nc.f][nc.b] = d[c.y][c.x][c.f][c.b]+1;\n            que.push({nc});\n        }\n    };\n\n    d[start.fi][start.se][0][0] = 0;\n    que.push({start.fi, start.se, 0, 0});\n    while(!que.empty()){\n        State c = que.front();\n        que.pop();\n\n        // move another floor\n        if(m[c.y][c.x]=='|'){\n            State nc(c);\n            nc.f = !nc.f;\n            CHECK(c, nc);\n        }\n\n        // operate switch\n        int sn = switch_num(m[c.y][c.x]);\n        if(sn!=-1){\n            State nc(c);\n            nc.b ^= (1<<switch_num(m[c.y][c.x]));\n            if(ms[sn][c.y][c.x] == '*') nc.f = !nc.f;\n            CHECK(c, nc);\n        }\n\n        // move adjacent\n        rep(i,4){\n            State nc(c);\n            nc.y += dy[i];\n            nc.x += dx[i];\n            if(!IN(nc.y, nc.x) || m[nc.y][nc.x]=='#') continue;\n\n            if(m[nc.y][nc.x]=='|' || nc.f==FLOOR(nc.y,nc.x,nc.b)) CHECK(c, nc);\n        }\n    }\n\n    int ans = INF;\n    rep(i,2)rep(j,1<<s) ans = min(ans, d[goal.fi][goal.se][i][j]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint dp[55][55][2][1333];\nint bef[1030][55][55];\nsigned main(){\n\trep(i,55)rep(j,55)rep(q,2)rep(k,1333)dp[i][j][q][k]=inf;\n\t\n\tint n,m;\n\tcin>>m>>n;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\t\n\tvector<vs>ini(2,in);\n\t\n\trep(i,n)rep(j,m){\n\t\tif(in[i][j]=='%')ini[1][i][j]='#';\n\t\tif(in[i][j]=='_')ini[1][i][j]='#';\n\t\tif(in[i][j]=='^')ini[0][i][j]='#';\n\t\tif(islower(in[i][j]))ini[1][i][j]='#';\n\t\tif(isupper(in[i][j])){\n\t\t\tini[0][i][j]='#';\n\t\t\tini[1][i][j]=tolower(in[i][j]);\n\t\t}\n\t\tif(in[i][j]=='&')ini[1][i][j]='#';\n\t}\n\t\n\tint q;\n\tcin>>q;\n\tvector<vs>w(q,vs(n));\n\trep(i,q)rep(j,n)cin>>w[i][j];\n\t\n\tqueue<tp>que;\n\trep(i,n)rep(j,m)if(in[i][j]=='%'){\n\t\tque.push(tp(i,j,0,0));\n\t\tdp[i][j][0][0]=0;\n\t}\n\t\n\trep(C,1<<q){\n\t\trep(c,10)if(C&1<<c)rep(i,n)rep(j,m)if(w[c][i][j]=='*')\n\t\t\tbef[C][i][j]^=1;\n\t}\n\t\n\tint out=inf;\n\twhile(!que.empty()){\n\t\tint x,y,f,s;\n\t\ttie(x,y,f,s)=que.front();\n//\t\tcout<<x<<\" \"<<y<<\" \"<<f<<\" \"<<s<<\" \"<<dp[x][y][f][s]<<endl;\n\t\tque.pop();\n\t\t\n\t\tvector<vs>now=ini;\n\t\trep(i,n)rep(j,m)if(bef[s][i][j])\n\t\t\tswap(now[0][i][j],now[1][i][j]);\n\n\t\tif(now[f][x][y]=='&'){\n\t\t\tout=dp[x][y][f][s];\n\t\t\tbreak;\n\t\t}\n\t\trep(k,4){\n\t\t\tint nx=x+dx[k];\n\t\t\tint ny=y+dy[k];\n\t\t\tif(now[f][nx][ny]=='#')continue;\n\t\t\tif(dp[x][y][f][s]+1<dp[nx][ny][f][s]){\n\t\t\t\tdp[nx][ny][f][s]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(nx,ny,f,s));\n\t\t\t}\n\t\t}\n\t\tif(isalpha(now[f][x][y])){\n\t\t\tint ns=s^1<<(now[f][x][y]-'a');\n\t\t\tint nf=f;\n\t\t\tif(w[now[f][x][y]-'a'][x][y]=='*')nf^=1;\n\t\t\tif(dp[x][y][f][s]+1<dp[x][y][nf][ns]){\n\t\t\t\tdp[x][y][nf][ns]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(x,y,nf,ns));\n\t\t\t}\n\t\t}\n\t\tif(now[f][x][y]=='|'){\n\t\t\tint nf=f^1;\n\t\t\tif(dp[x][y][f][s]+1<dp[x][y][nf][s]){\n\t\t\t\tdp[x][y][nf][s]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(x,y,nf,s));\n\t\t\t}\n\t\t}\n\t}\n\tif(out==inf)out=-1;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing State = tuple<int, int, int, int, char>;\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0, '_'));\n\n    vector<vector<vvi>> min_dist(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n\n    while(q.size()){\n        int cc, cx, cy, cb; char cf;\n        tie(cc, cx, cy, cb, cf) = q.top();\n        q.pop();\n\n        if(cx == tx and cy == ty){\n            cout << cc << endl;\n            return 0;\n        }\n\n        int cfi = (cf == '^');\n        if(min_dist[cy][cx][cb][cfi] != inf) continue;\n        min_dist[cy][cx][cb][cfi] = cc;\n\n        int nc = cc + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(min_dist[cy][cx][nb][nfi] == inf){\n                q.push(State(nc, cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(min_dist[cy][cx][cb][nfi] == inf){\n                q.push(State(nc, cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and min_dist[ny][nx][cb][cfi] == inf){\n                q.push(State(nc, nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and min_dist[ny][nx][cb][nfi] == inf){\n                q.push(State(nc, nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint W,H;\nchar stage[51][51];\nchar switches[11][51][51];\nint dp[1<<10][51][51][2];\nint total_switches;\n\nbool check_floor(int S,int dx,int dy,int current){\n  if(stage[dy][dx] == '|') return true;\n\n  int floor = 0;\n  if('a' <= stage[dy][dx] && stage[dy][dx] <= 'z'\n     || stage[dy][dx] == '_'\n     || stage[dy][dx] == '&'\n     || stage[dy][dx] == '%'){\n    floor = 0;\n  }\n  else if('A' <= stage[dy][dx] && stage[dy][dx] <= 'Z'\n     || stage[dy][dx] == '^'){\n    floor = 1;\n  }\n\n  for(int switch_i = 0; switch_i < total_switches; switch_i++){\n    if((S & (1<<switch_i)) && switches[switch_i][dy][dx] == '*'){\n      floor++;\n      floor %= 2;\n    }\n  }\n  return (current == floor);\n}\n\nint alpha2idx(char alpha){\n  if('A' <= alpha && alpha <= 'Z'){\n    return alpha - 'A';\n  }\n  return alpha - 'a';\n}\n\nclass State{\npublic:\n  int S;\n  int x;\n  int y;\n  int floor;\n  int cost;\n  State(int S,int x,int y,int floor,int cost) :\n    S(S),x(x),y(y),floor(floor),cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint bfs(int sx,int sy){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,sx,sy,0,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    int S = s.S;\n    int floor = s.floor;\n    int cost = s.cost;\n\n    for(int i = 0; i < 4; i++){\n      int dx = s.x + tx[i];\n      int dy = s.y + ty[i];\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(stage[dy][dx] == '#') continue;\n      if(!check_floor(S,dx,dy,floor)) continue;\n\n      if(dp[S][dx][dy][floor] > cost + 1){\n        dp[S][dx][dy][floor] = cost + 1;\n        que.push(State(S,dx,dy,floor,cost + 1));\n      }\n\n      if(isalpha(stage[dy][dx])){\n        //use switch\n        int switch_i = alpha2idx(stage[dy][dx]);\n        int next_S = S ^ (1<<switch_i);\n        int next_floor = floor;\n        \n        if(switches[switch_i][dy][dx] == '*'){\n          next_floor++;\n          next_floor %= 2;\n        }\n        \n        if(dp[next_S][dx][dy][next_floor] > cost + 2){\n          dp[next_S][dx][dy][next_floor] = cost + 2;\n          que.push(State(next_S,dx,dy,next_floor,cost + 2));\n        }\n        \n        //don't use switch\n        if(dp[S][dx][dy][floor] > cost + 1){\n          dp[S][dx][dy][floor] = cost + 1;\n          que.push(State(S,dx,dy,floor,cost + 1));\n        }\n      }\n      else{\n        int next_floor = floor;\n        \n        if(stage[dy][dx] == '|'){\n          next_floor++;\n          next_floor %= 2;\n          if(dp[S][dx][dy][next_floor] > cost + 2){\n            dp[S][dx][dy][next_floor] = cost + 2;\n            que.push(State(S,dx,dy,next_floor,cost + 2));\n          }\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&W,&H)){\n    memset(dp,0x3f,sizeof(dp));\n    int sx,sy;\n    int gx,gy;\n    for(int y = 0; y < H; y++){\n      char line[64];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(stage[y][x] == '%'){\n          sx = x;\n          sy = y;\n        }\n        if(stage[y][x] == '&'){\n          gx = x;\n          gy = y;\n        }\n      }\n    }\n    scanf(\"%d\",&total_switches);\n    for(int switch_i = 0; switch_i < total_switches; switch_i++){\n      for(int y = 0; y < H; y++){\n        char line[64];\n        scanf(\"%s\",line);\n        for(int x = 0; x < W; x++){\n          switches[switch_i][y][x] = line[x];\n        }\n      }\n    }\n    bfs(sx,sy);\n    int res = INF;\n    for(int S = 0; S < (1<<total_switches); S++){\n      for(int floor = 0; floor < 2; floor++){\n        res = min(dp[S][gx][gy][floor],res);\n      }\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {-1, 0, 1, 0};\n\nint W, H, S;\nstring M[50], MS[10][50];\nint bit[50][50], v[2][50][50][1 << 10];\nint mov[50][50];\n\nint Solve()\n{\n  memset(v, -1, sizeof(v));\n  for(int k = 0; k < S; k++) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(MS[k][i][j] == '*') bit[j][i] |= 1 << k;\n      }\n    }\n  }\n  queue< tuple< int, int, int, int > > que;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      switch(M[i][j]) {\n        case '|':\n          mov[j][i] = 3;\n          break;\n        case '_':\n          mov[j][i] = 1;\n          break;\n        case '^':\n          mov[j][i] = 2;\n          break;\n        case 'a' ... 'j':\n          mov[j][i] = 1;\n          M[i][j] -= 'a';\n          break;\n        case 'A' ... 'J':\n          mov[j][i] = 2;\n          M[i][j] -= 'A';\n          break;\n        case '%':\n          que.emplace(0, j, i, 0);\n          v[0][j][i][0] = 0;\n          mov[j][i] = 1;\n          break;\n        case '&':\n          mov[j][i] = 1;\n          break;\n        default:\n          mov[j][i] = 0;\n          break;\n      }\n    }\n  }\n\n  while(!que.empty()) {\n    int f, x, y, button;\n    tie(f, x, y, button) = que.front();\n    que.pop();\n    if(M[y][x] == '&') {\n      return (v[f][x][y][button]);\n    } else if(M[y][x] == '|') {\n      int nf = f ^ 1;\n      if(v[nf][x][y][button] == -1) {\n        v[nf][x][y][button] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, button);\n      }\n    } else if(M[y][x] < 10) {\n      int nbutton = button ^ (1 << M[y][x]);\n      int nf = (f + ((bit[x][y] >> M[y][x]) & 1)) & 1;\n      if(v[nf][x][y][nbutton] == -1) {\n        v[nf][x][y][nbutton] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, nbutton);\n      }\n    }\n    for(int i = 0; i < 4; i++) {\n      int nx = x + vx[i], ny = y + vy[i];\n      int isgo = (f + __builtin_popcount(bit[nx][ny] & button)) & 1;\n      if(v[f][nx][ny][button] == -1 && (mov[nx][ny] & ++isgo)) {\n        v[f][nx][ny][button] = v[f][x][y][button] + 1;\n        que.emplace(f, nx, ny, button);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    cin >> M[i];\n  }\n  cin >> S;\n  for(int i = 0; i < S; i++) {\n    for(int j = 0; j < H; j++) {\n      cin >> MS[i][j];\n    }\n  }\n  cout << Solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint H, W, S;\nint sx, sy, gx, gy;\nvector<string> board;\nvector<vector<string>> switches;\nint d[50][50][2][1 << 10];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nint whichFloor(int x, int y, int bit) {\n    int f = 0;\n    if (board[x][y] == '^' || isupper(board[x][y])) f = 1;\n    rep(s, S) {\n        if (((bit >> s) & 1) && switches[s][x][y] == '*') {\n            f ^= 1;\n        }\n    }\n    return f;\n}\n\nbool cango(int f, int nx, int ny, int bit) {\n    if (board[nx][ny] == '|') return true;\n    if (board[nx][ny] == '#') return false;\n    return f == whichFloor(nx, ny, bit);\n}\n\nint bfs() {\n    using State = tuple<int, int, int, int>; // x, y, f, bit\n    queue<State> que;\n    que.emplace(sx, sy, 0, 0);\n    rep(i, H) rep(j, W) rep(f, 2) rep(bit, 1 << S) d[i][j][f][bit] = inf;\n    d[sx][sy][0][0] = 0;\n\n    auto update = [&](int x, int y, int f, int bit, int cost) {\n        if (d[x][y][f][bit] != inf) return;\n        d[x][y][f][bit] = cost + 1;\n        que.emplace(x, y, f, bit);\n    };\n\n    while (!que.empty()) {\n        int x, y, f, bit;\n        tie(x, y, f, bit) = que.front(); que.pop();\n        int cost = d[x][y][f][bit];\n\n        // output(x, y, f, bit, cost);\n\n        if (x == gx && y == gy) {\n            return cost;\n        }\n\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (cango(f, nx, ny, bit)) {\n                update(nx, ny, f, bit, cost);\n            }\n        }\n\n        if (board[x][y] == '|') {\n            update(x, y, f^1, bit, cost);\n        }\n\n        if ((f == 1 && isupper(board[x][y])) || (f == 0 && islower(board[x][y]))) {\n            int id_switch = (isupper(board[x][y]) ? board[x][y] - 'A' : board[x][y] - 'a');\n            int nbit = bit ^ (1 << id_switch);\n            int nf = f;\n            // output(board[x][y], id_switch, x, y);\n            if (switches[id_switch][x][y] == '*') {\n                nf ^= 1;\n            }\n            // cerr << \"hey!\" << endl;\n\n            update(x, y, nf, nbit, cost);\n        }\n\n\n    }\n\n    return -1;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> W >> H;\n    board.resize(H);\n    rep(i, H) {\n        cin >> board[i];\n        rep(j, W) {\n            if (board[i][j] == '%') {\n                sx = i; sy = j;\n            } else if (board[i][j] == '&') {\n                gx = i; gy = j;\n            }\n        }\n    }\n    cin >> S;\n    switches.resize(S, vector<string>(H));\n    rep(s, S) {\n        rep(i, H) cin >> switches[s][i];\n    }\n\n    cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,S;\nstring s[50],mv[10][50],mp[1<<10][2][50];\nbool fst[50][50];\nint d[1<<10][2][50][50];\nint inf=1e8,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main(){\n\tcin>>W>>H;\n\trep(i,H) cin>>s[i];\n\tcin>>S;\n\trep(i,S) rep(j,H) cin>>mv[i][j];\n\trep(i,H) rep(j,W){\n\t\tif(s[i][j]=='_'||islower(s[i][j])||s[i][j]=='%'||s[i][j]=='&') fst[i][j]=1;\n\t}\n\trep(b,1<<S){\n\t\trep(i,H) rep(j,W){\n\t\t\tif(s[i][j]=='#'||s[i][j]=='|'){\n\t\t\t\tmp[b][0][i]+=s[i][j];\n\t\t\t\tmp[b][1][i]+=s[i][j];\n\t\t\t}else{\n\t\t\t\tint f=1-fst[i][j];\n\t\t\t\trep(k,S) if((b>>k)&1) if(mv[k][i][j]=='*') f=1-f;\n\t\t\t\tchar c=s[i][j];\n\t\t\t\tif(isupper(c)) c=c-'A'+'a';\n\t\t\t\tif(c=='_'||c=='^') c='.';\n\t\t\t\tmp[b][f][i]+=c;\n\t\t\t\tmp[b][1-f][i]+=\"#\";\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> qb,qf,qx,qy;\n\tqb.push(0);\n\tqf.push(0);\n\trep(i,1<<S) rep(j,2) rep(k,H) rep(l,W) d[i][j][k][l]=inf;\n\trep(i,H) rep(j,W) if(s[i][j]=='%') qx.push(i),qy.push(j),d[0][0][i][j]=0;\n\twhile(!qb.empty()){\n\t\tint b=qb.front(),f=qf.front(),x=qx.front(),y=qy.front();\n\t\tqb.pop(),qf.pop(),qx.pop(),qy.pop();\n\t\tif(mp[b][f][x][y]=='&'){\n\t\t\tcout<<d[b][f][x][y]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tif(mp[b][f][nx][ny]!='#'&&d[b][f][nx][ny]==inf){\n\t\t\t\tqb.push(b),qf.push(f),qx.push(nx),qy.push(ny);\n\t\t\t\td[b][f][nx][ny]=d[b][f][x][y]+1;\n\t\t\t}\n\t\t}\n\t\tif(mp[b][f][x][y]=='|'&&d[b][1-f][x][y]==inf){\n\t\t\tqb.push(b),qf.push(1-f),qx.push(x),qy.push(y);\n\t\t\td[b][1-f][x][y]=d[b][f][x][y]+1;\n\t\t}\n\t\tif(islower(mp[b][f][x][y])){\n\t\t\tint s=mp[b][f][x][y]-'a';\n\t\t\tint nb=b^(1<<s);\n\t\t\tint nf=f;\n\t\t\tif(mv[s][x][y]=='*') nf=1-nf;\n\t\t\tif(d[nb][nf][x][y]==inf){\n\t\t\t\tqb.push(nb),qf.push(nf),qx.push(x),qy.push(y);\n\t\t\t\td[nb][nf][x][y]=d[b][f][x][y]+1;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 55\n#define MAX_W 55\n#define MAX_S 15\n\nstruct State{\n  int d,x,y,s,f;\n  State(int d,int x,int y,int s,int f) :\n    d(d),x(x),y(y),s(s),f(f) {}\n};\n\nchar M[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W][1<<MAX_S][2];\n\nint getFloor(int x,int y,int f){\n  if(M[y][x] == '|'){ return f; }\n  if(M[y][x] == '_' || islower(M[y][x])){\n    return 0;\n  }\n  return 1;\n}\n\nint main(){\n  int H,W,sx,sy,gx,gy,S;\n  char MS[MAX_H][MAX_W][MAX_S];\n  cin >> W >> H;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '%'){\n        M[i][j] = '_';\n        sx = j; sy = i;\n      }\n      if(M[i][j] == '&'){\n        M[i][j] = '_';\n        gx = j; gy = i;\n      }\n    }\n  }\n  cin >> S;\n  for(int i = 0 ; i < S ; i++){\n    for(int j = 0 ; j < H ; j++){\n      for(int k = 0 ; k < W ; k++){\n        cin >> MS[j][k][i];\n      }\n    }\n  }\n  int ans = -1;\n  memset(visited,false,sizeof(visited));\n  visited[sy][sx][0][0] = true;\n  const int dx[] = {-1,0,1,0};\n  const int dy[] = {0,-1,0,1};\n  queue<State> Q;\n  Q.push(State(0,sx,sy,0,0));\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    int x = s.x, y = s.y;\n    if(x == gx && y == gy){\n      ans = s.d;\n      break;\n    }\n    if(islower(M[y][x])){\n      int sw = M[y][x] - 'a';\n      int next = s.s ^ (1<<sw);\n      int nf = s.f;\n      if(MS[y][x][sw] == '*'){\n        nf = 1-nf;\n      }\n      if(!visited[y][x][next][nf]){\n        visited[y][x][next][nf] = true;\n        Q.push(State(s.d+1,x,y,next,nf));\n      }\n    }\n    if(isupper(M[y][x])){\n      int sw = M[y][x] - 'A';\n      int next = s.s ^ (1<<sw);\n      int nf = s.f;\n      if(MS[y][x][sw] == '*'){\n        nf = 1-nf;\n      }\n      if(!visited[y][x][next][nf]){\n        visited[y][x][next][nf] = true;\n        Q.push(State(s.d+1,x,y,next,nf));\n      }\n    }\n    if(M[y][x] == '|'){\n      int next = 1-s.f;\n      if(!visited[y][x][s.s][next]){\n        visited[y][x][s.s][next] = true;\n        Q.push(State(s.d+1,x,y,s.s,next));\n      }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      int f = s.f;\n      if(0 > nx || W <= nx || 0 > ny || H <= ny){\n        continue;\n      }\n      if(M[ny][nx] == '#'){ continue; }\n      int nf = getFloor(nx,ny,f);\n      for(int j = 0 ; j < S ; j++){\n        if((s.s >> j) & 1){\n          if(MS[ny][nx][j] == '*'){\n            nf = 1 - nf;\n          }\n        }\n      }\n      if(f == nf && !visited[ny][nx][s.s][nf]){\n        visited[ny][nx][s.s][nf] = true;\n        Q.push(State(s.d+1,nx,ny,s.s,nf));\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 30;\nconst ll mod=1000000007LL;\nconst short dx[4]={1,0,-1,0};\nconst short dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<short, short, int, char>;\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vvi sw_field(h, vi(w));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[y][x] |= (1 << i);\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(State(sx, sy, 0, '_'));\n\n    vector<vector<vvi>> min_cost(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n    min_cost[sy][sx][0][0] = 0;\n\n    while(q.size()){\n        short cx, cy; int cb; char cf;\n        tie(cx, cy, cb, cf) = q.front();\n        q.pop();\n\n        int cfi = (cf == '^');\n\n        if(cx == tx and cy == ty){\n            cout << min_cost[cy][cx][cb][cfi] << endl;\n            return 0;\n        }\n\n        int nc = min_cost[cy][cx][cb][cfi] + 1;\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(chmin(min_cost[cy][cx][cb][nfi], nc)){\n                q.push(State(cx, cy, cb, nf));\n            }\n        }\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[cy][cx] & (1 << idx)){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(chmin(min_cost[cy][cx][nb][nfi], nc)){\n                q.push(State(cx, cy, nb, nf));\n            }\n        }\n\n        rep(i, 4){\n            short nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and chmin(min_cost[ny][nx][cb][cfi], nc)){\n                q.push(State(nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = (__builtin_popcount(sw_field[ny][nx] & cb) % 2 == 1);\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and chmin(min_cost[ny][nx][cb][nfi], nc)){\n                q.push(State(nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int W, H; cin >> W >> H;\n    vector<string> M(H); cin >> M;\n    int S; cin >> S;\n    auto MS = make_v<string>(S, H); cin >> MS;\n\n    auto Switch = make_vector<int>(H, W, -1),\n         Floor = make_v<int>(H, W);\n    auto Moved = make_v<int>(S, H, W);\n\n    int si, sj, ti, tj;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (M[i][j] == '%') {\n                si = i, sj = j;\n            }\n            if (M[i][j] == '&') {\n                ti = i, tj = j;\n            }\n            if (M[i][j] == '^') {\n                Floor[i][j] = 1;\n            }\n            if ('a' <= M[i][j] and M[i][j] < 'a' + S) {\n                Switch[i][j] = M[i][j] - 'a';\n            }\n            if ('A' <= M[i][j] and M[i][j] < 'A' + S) {\n                Switch[i][j] = M[i][j] - 'A';\n                Floor[i][j] = 1;\n            }\n        }\n    }\n    // for (int i = 0; i < H; ++i) {\n    //     DUMP(Switch[i]);\n    // }\n    // for (int i = 0; i < H; ++i) {\n    //     DUMP(Floor[i]);\n    // }\n\n    for (int k = 0; k < S; ++k) {\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (MS[k][i][j] == '*') {\n                    Moved[k][i][j] = 1;\n                }\n            }\n        }\n    }\n    // for (int k = 0; k < S; ++k) {\n    //     for (int i = 0; i < H; ++i) {\n    //         DUMP(Moved[k][i]);\n    //     }\n    //     cerr << endl;\n    // }\n\n    function<int(int,int,int)> getFloor = [&](int i, int j, int s) {\n        int floor = Floor[i][j];\n        for (int k = 0; k < S; ++k) if (s >> k & 1) {\n            floor ^= Moved[k][i][j];\n        }\n        return floor;\n    };\n\n    int dy[] = {1, 0, -1, 0},\n        dx[] = {0, -1, 0, 1};\n\n    using State = tuple<int,int,int,int>;\n    queue<pair<int,State>> que;\n    que.emplace(0, make_tuple(si, sj, 0, 0));\n\n    auto used = make_v<bool>(2, H, W, 1<<S);\n    used[0][si][sj][0] = true;\n\n    int ans = -1;\n\n    while (!que.empty()) {\n        int dist; State tp; tie(dist, tp) = que.front(); que.pop();\n        int i, j, f, s; tie(i, j, f, s) = tp;\n\n        if (i == ti and j == tj) {\n            ans = dist;\n            break;\n        }\n\n        // DUMP(i);\n        // DUMP(j);\n        // DUMP(f);\n        // DUMP(dist);\n        // DUMP(bitset<10>(s));\n        // cerr << endl;\n\n        if (Switch[i][j] != -1) {\n            int ts = s ^ 1<<Switch[i][j];\n            int nextFloor = getFloor(i, j, ts);\n            if (!used[nextFloor][i][j][ts]) {\n                que.emplace(dist + 1, make_tuple(i, j, nextFloor, ts));\n                used[nextFloor][i][j][ts] = true;\n            }\n        }\n        if (M[i][j] == '|') {\n            if (!used[1-f][i][j][s]) {\n                que.emplace(dist + 1, make_tuple(i, j, 1-f, s));\n                used[1-f][i][j][s] = true;\n            }\n        }\n        for (int t = 0; t < 4; ++t) {\n            int y = i + dy[t], x = j + dx[t];\n            if (M[y][x] == '#') {\n                continue;\n            }\n            if (getFloor(y,x,s) != f and M[y][x] != '|') {\n                continue;\n            }\n            if (!used[f][y][x][s]) {\n                que.emplace(dist + 1, make_tuple(y, x, f, s));\n                used[f][y][x][s] = true;\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nvector<vector<int>>field;\nvector<vector<bitset<11>>>byswitches;\n\nint memo[50][50][2][2048];\n\nconst int dx[] = { -1,0,1,0,0,0 };\nconst int dy[] = { 0,1,0,-1,0,0 };\nconst int dz[] = { 0,0,0,0,1,-1 };\n\n\nbool isup(const int x, const int y, const bitset<11>&bs) {\n\tbool up = false;\n\tfor (int i = 0; i < 11; ++i) {\n\t\tif (bs[i] && byswitches[y][x][i])up = !up;\n\t}\n\treturn up;\n}\n\nbool canmove(const int x, const int y,const int z, const bitset<11>&bs) {\n\tif (z < 0 || z >= 2)return false;\n\tif (field[y][x] == 0)return false;\n\tif (field[y][x] == 1)return true;\n\telse if (isup(x, y, bs) == z)return true;\n\telse return false;\n}\nstruct aa {\n\tint x;\n\tint y;\n\tint z;\n\tbitset<11>bs;\n\tint time;\n\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint sx = 0, sy = 0,gx=0,gy=0;\nint dfs() {\n\tqueue<aa>que;\n\tbitset<11>bs;\n\tbs[0] = true;\n\tque.push(aa{ sx,sy,0,bs,0 });\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tconst int nowx = atop.x;\n\t\tconst int nowy = atop.y;\n\t\tconst int nowz = atop.z;\n\t\tconst bitset<11> nowbs = atop.bs;\n\t\tconst int nowtime = atop.time;\n\t\tif (nowx == gx&&nowy == gy) {\n\t\t\tans = nowtime;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int way = 0; way < 6; ++way) {\n\t\t\tconst int nextx = nowx + dx[way];\n\t\t\tconst int nexty = nowy + dy[way];\n\t\t\tconst int nextz = nowz + dz[way];\n\t\t\tconst bitset<11> nextbs = nowbs;\n\t\t\tconst int nexttime = nowtime + 1;\n\t\t\tif (canmove(nextx, nexty, nextz, nextbs)) {\n\t\t\t\tif (memo[nextx][nexty][nextz][nextbs.to_ulong()]>nexttime) {\n\t\t\t\t\tmemo[nextx][nexty][nextz][nextbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextx,nexty,nextz,nextbs,nexttime });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (field[nowy][nowx] >= 3) {\n\t\t\t\tconst int nextx = nowx ;\n\t\t\t\tconst int nexty = nowy ;\n\t\t\t\tint nextz;\n\t\t\t\t{\n\t\t\t\t\tif (byswitches[nowy][nowx][field[nowy][nowx] - 2]) {\n\t\t\t\t\t\tnextz = !nowz;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnextz = nowz;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbitset<11> nextbs = nowbs;\n\t\t\t\tconst int nexttime = nowtime + 1;\n\t\t\t\tnextbs[field[nowy][nowx] - 2] = !nextbs[field[nowy][nowx] - 2];\n\t\t\t\tif (canmove(nextx, nexty, nextz, nextbs)) {\n\t\t\t\t\tif (memo[nextx][nexty][nextz][nextbs.to_ulong()]>nexttime) {\n\t\t\t\t\t\tmemo[nextx][nexty][nextz][nextbs.to_ulong()] = nexttime;\n\t\t\t\t\t\tque.push(aa{ nextx,nexty,nextz,nextbs,nexttime });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tfor (int i = 0; i < 50; ++i) {\n\t\tfor (int j = 0; j < 50; ++j) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tfor (int l = 0; l < 2048; ++l) {\n\t\t\t\t\tmemo[i][j][k][l] = 1e9;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint H, W; cin >> W >> H;\n\tfield = vector<vector<int>>(H, vector<int>(W));\n\tbyswitches = vector<vector<bitset<11>>>(H, vector<bitset<11>>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (st[j] == '#')field[i][j] = 0;\n\t\t\telse if (st[j] == '|')field[i][j] = 1;\n\t\t\telse if (st[j] == '%') {\n\t\t\t\tsx = j; sy = i;\n\t\t\t\tfield[i][j] = 2;\n\t\t\t}\n\t\t\telse if (st[j] == '&') {\n\t\t\t\tgx = j; gy = i;\n\t\t\t\tfield[i][j] = 2;\n\t\t\t}\n\t\t\telse if (st[j] == '_') {\n\t\t\t\tfield[i][j] = 2;\n\t\t\t}\n\t\t\telse if (st[j] == '^') {\n\t\t\t\tfield[i][j] = 2;\n\t\t\t\tbyswitches[i][j][0] = true;\n\t\t\t}\n\t\t\telse if(st[j]>='a'&&st[j]<='z'){\n\t\t\t\tfield[i][j] = 3 + st[j] -'a';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 3 + st[j] - 'A';\n\t\t\t\tbyswitches[i][j][0] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint S; cin >> S;\n\tfor (int s = 0;s < S; ++s) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '*')byswitches[i][j][s + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dfs();\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=vector<string>;\nstruct State{\n    int h,w;\n    int f;\n    int bit;\n    int cnt;\n};\nusing vi=vector<int>;\nusing v2i=vector<vi>;\nusing v3i=vector<v2i>;\nusing v4i=vector<v3i>;\nint dh[]={0,-1,0,1};\nint dw[]={1,0,-1,0};\nint main(){\n    int w,h;\n    cin>>w>>h;\n    Field org(h);\n    for(int i=0;i<h;i++) cin>>org[i];\n    int s;\n    cin>>s;\n    vector<Field> swt(s,Field(h));\n    for(int i=0;i<s;i++){\n        for(int j=0;j<h;j++){\n            cin>>swt[i][j];\n        }\n    }\n    const int INF=1e9;\n    v4i dp(h,v3i(w,v2i(2,vi(1<<s,INF))));\n    auto isUsed=[&](State x){\n        if(dp[x.h][x.w][x.f][x.bit]!=INF) return true;\n        dp[x.h][x.w][x.f][x.bit]=x.cnt;\n        return false;\n    };\n\n    queue<State> que;\n    State goal;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(org[i][j]=='%'){\n                org[i][j]='_';\n                que.push({i,j,0,0,0});\n            }\n            if(org[i][j]=='&'){\n                org[i][j]='_';\n                goal={i,j,0,-1,INF};\n            }\n        }\n    }\n    auto turn=[&](State x){\n        if(!isalpha(org[x.h][x.w])) return x;\n        int k;\n        if(isupper(org[x.h][x.w])){\n            k=org[x.h][x.w]-'A';\n        }\n        else{\n            k=org[x.h][x.w]-'a';\n        }\n        x.bit^=(1<<k);\n        if(swt[k][x.h][x.w]=='*') x.f=(!x.f);\n        return x;\n    };\n    auto stair=[&](State x){\n        if(org[x.h][x.w]=='|'){\n            x.f=!x.f;\n            return x;\n        }\n        else return x;\n    };\n    auto height=[](char c){\n        if(c=='_') return 0;\n        if(c=='^') return 1;\n        assert(isalpha(c));\n        if(islower(c)) return 0;\n        else return 1;\n    };\n    auto isValid=[&](State x){\n        if(org[x.h][x.w]=='#') return false;\n        else if(org[x.h][x.w]=='|') return true;\n        else{\n            int f=height(org[x.h][x.w]);\n            for(int i=0;i<s;i++){\n                if((x.bit>>i)&1 && swt[i][x.h][x.w]=='*'){\n                    f=!f;\n                }\n            }\n            return f==x.f;\n        }\n    };\n    assert(que.size()==1);\n    while(!que.empty()){\n        State st=que.front(); que.pop();\n        if(isUsed(st)) continue;\n        for(int i=0;i<4;i++){\n            State to={st.h+dh[i],st.w+dw[i],st.f,st.bit,st.cnt+1};\n            if(isValid(to)){\n                que.push(to);\n            }\n        }\n        st.cnt++;\n        que.push(turn(st));\n        que.push(stair(st));\n    }\n    int res=INF;\n    for(int i=0;i<(1<<s);i++){\n        for(int j=0;j<2;j++){\n            res=min(res,dp[goal.h][goal.w][j][i]);\n        }\n    }\n    cout<<(res==INF ? -1 : res)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint H, W, S;\nint sx, sy, gx, gy;\nvector<string> board;\nvector<vector<string>> switches;\nint d[50][50][2][1 << 10];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint whichFloor(int x, int y, int bit) {\n    int f = 0;\n    if (board[x][y] == '^' || isupper(board[x][y])) f = 1;\n    rep(s, S) {\n        if (((bit >> s) & 1) && switches[s][x][y] == '*') {\n            f ^= 1;\n        }\n    }\n    return f;\n}\n\nbool cango(int f, int nx, int ny, int bit) {\n    if (board[nx][ny] == '|') return true;\n    if (board[nx][ny] == '#') return false;\n    return f == whichFloor(nx, ny, bit);\n}\n\nint bfs() {\n    using State = tuple<int, int, int, int>; // x, y, f, bit\n    queue<State> que;\n    que.emplace(sx, sy, 0, 0);\n    rep(i, H) rep(j, W) rep(f, 2) rep(bit, 1 << S) d[i][j][f][bit] = inf;\n    d[sx][sy][0][0] = 0;\n\n    auto update = [&](int x, int y, int f, int bit, int cost) {\n        if (d[x][y][f][bit] != inf) return;\n        d[x][y][f][bit] = cost + 1;\n        que.emplace(x, y, f, bit);\n    };\n\n    while (!que.empty()) {\n        int x, y, f, bit;\n        tie(x, y, f, bit) = que.front(); que.pop();\n        int cost = d[x][y][f][bit];\n\n        // output(x, y, f, bit, cost);\n\n        if (x == gx && y == gy) {\n            return cost;\n        }\n\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (cango(f, nx, ny, bit)) {\n                update(nx, ny, f, bit, cost);\n            }\n        }\n\n        if (board[x][y] == '|') {\n            update(x, y, f^1, bit, cost);\n        }\n\n        if (isalpha(board[x][y]) && f == whichFloor(x, y, bit)) {\n            int id_switch = (isupper(board[x][y]) ? board[x][y] - 'A' : board[x][y] - 'a');\n            int nbit = bit ^ (1 << id_switch);\n            int nf = f;\n            if (switches[id_switch][x][y] == '*') {\n                nf ^= 1;\n            }\n            update(x, y, nf, nbit, cost);\n        }\n\n\n    }\n\n    return -1;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> W >> H;\n    board.resize(H);\n    rep(i, H) {\n        cin >> board[i];\n        rep(j, W) {\n            if (board[i][j] == '%') {\n                sx = i; sy = j;\n            } else if (board[i][j] == '&') {\n                gx = i; gy = j;\n            }\n        }\n    }\n    cin >> S;\n    switches.resize(S, vector<string>(H));\n    rep(s, S) {\n        rep(i, H) cin >> switches[s][i];\n    }\n\n    cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if (i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nstruct Elm {\n  int r, c;\n  int sw;\n  int st;\n  int d;\n};\n\nbool dp[50][50][1<<10][2];\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int w, h;\n  cin >> w >> h;\n  vector<string> ing(h);\n  for(int i=0;i<(h);++i) cin >> ing[i];\n  int s;\n  cin >> s;\n  vector<vector<string>> insw(s, vector<string>(h));\n  for(int i=0;i<(s);++i) {\n    for(int j=0;j<(h);++j) {\n      cin >> insw[i][j];\n    }\n  }\n  vector<vector<vector<bool>>> floor(2, vector<vector<bool>>(h, vector<bool>(w)));\n  vector<vector<bool>> stair(h, vector<bool>(w));\n  vector<vector<vector<char>>> swval(2, vector<vector<char>>(h, vector<char>(w, -1)));\n  vector<vector<vector<bool>>> sw(s, vector<vector<bool>>(h, vector<bool>(w)));\n  P st, gl;\n  for(int i=0;i<(h);++i) {\n    for(int j=0;j<(w);++j) {\n      switch (ing[i][j]) {\n        case '|':\n          floor[0][i][j] = true;\n          floor[1][i][j] = true;\n          stair[i][j] = true;\n          break;\n        case '_':\n          floor[0][i][j] = true;\n          break;\n        case '^':\n          floor[1][i][j] = true;\n          break;\n        case '%':\n          floor[0][i][j] = true;\n          st = {i, j};\n          break;\n        case '&':\n          floor[0][i][j] = true;\n          gl = {i, j};\n          break;\n        default:\n          if ('a' <= ing[i][j] && ing[i][j] <= 'j') {\n            floor[0][i][j] = true;\n            swval[0][i][j] = ing[i][j] - 'a';\n          } else if ('A' <= ing[i][j] && ing[i][j] <= 'J') {\n            floor[1][i][j] = true;\n            swval[1][i][j] = ing[i][j] - 'A';\n          }\n          break;\n      }\n    }\n  }\n  for(int i=0;i<(s);++i) {\n    for(int j=0;j<(h);++j) {\n      for(int k=0;k<(w);++k) {\n        if (insw[i][j][k] == '*') {\n          sw[i][j][k] = true;\n        }\n      }\n    }\n  }\n  ing.clear();\n  insw.clear();\n  for(int i=0;i<50;++i) {\n    for(int j=0;j<50;++j) {\n      for(int k=0;k<(1<<10);++k) {\n        for(int l=0;l<2;++l) {\n          dp[i][j][k][l] = false;\n        }\n      }\n    }\n  }\n  queue<Elm> que;\n  dp[st.first][st.second][0][0] = true;\n  que.push({st.first, st.second, 0, 0, 0});\n  vi dr = {-1, 1, 0, 0};\n  vi dc = {0, 0, -1, 1};\n  int ans = -1;\n  while(!que.empty()) {\n    auto elm = que.front(); que.pop();\n    if(elm.r == gl.first && elm.c == gl.second) {\n      ans = elm.d;\n      break;\n    }\n    //cout << elm.r << \":\" << elm.c << \":\" << elm.sw << \":\" << elm.st << \":\" << elm.d << endl;\n    if(stair[elm.r][elm.c]) {\n      if(!dp[elm.r][elm.c][elm.sw][!elm.st]) {\n        dp[elm.r][elm.c][elm.sw][!elm.st] = true;\n        que.push({elm.r, elm.c, elm.sw, !elm.st, elm.d + 1});\n      }\n    }\n    bool st = elm.st;\n    for(int i=0;i<(s);++i) {\n      if ((1 << i) & elm.sw) st ^= sw[i][elm.r][elm.c];\n    }\n    int val = swval[st][elm.r][elm.c];\n    if(val != -1) {\n      if(!dp[elm.r][elm.c][elm.sw ^ (1<<val)][elm.st ^ sw[val][elm.r][elm.c]]) {\n        dp[elm.r][elm.c][elm.sw ^ (1<<val)][elm.st ^ sw[val][elm.r][elm.c]] = true;\n        que.push({elm.r, elm.c, elm.sw ^ (1<<val), elm.st ^ sw[val][elm.r][elm.c], elm.d + 1});\n      }\n    }\n    for(int i=0;i<(4);++i) {\n      int nr = elm.r + dr[i], nc = elm.c + dc[i];\n      if(!(0 <= nr && nr < h && 0 <= nc && nc < w)) continue;\n      bool nst = elm.st;\n      for(int j=0;j<(s);++j) {\n        if((1<<j) & elm.sw) nst ^= sw[j][nr][nc];\n      }\n      if(!floor[nst][nr][nc]) continue;\n      if(!dp[nr][nc][elm.sw][elm.st]) {\n        dp[nr][nc][elm.sw][elm.st] = true;\n        que.push({nr, nc, elm.sw, elm.st, elm.d+1});\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {-1, 0, 1, 0};\n\nint W, H, S;\nstring M[50], MS[10][50];\n\nint Solve()\n{\n  int bit[50][50] = {{}}, v[2][50][50][1 << 10];\n  int move[50][50];\n  memset(v, -1, sizeof(v));\n\n  for(int k = 0; k < S; k++) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(MS[k][i][j] == '*') bit[j][i] |= 1 << k;\n      }\n    }\n  }\n  queue< tuple< int, int, int, int > > que;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      switch(M[i][j]) {\n        case '|':\n          move[j][i] = 3;\n          break;\n        case '_':\n          move[j][i] = 1;\n          break;\n        case '^':\n          move[j][i] = 2;\n          break;\n        case 'a' ... 'j':\n          move[j][i] = 1;\n          M[i][j] -= 'a';\n          break;\n        case 'A' ... 'J':\n          move[j][i] = 2;\n          M[i][j] -= 'A';\n          break;\n        case '%':\n          que.emplace(0, j, i, 0);\n          v[0][j][i][0] = 0;\n          move[j][i] = 1;\n          break;\n        case '&':\n          move[j][i] = 1;\n          break;\n        default:\n          move[j][i] = 0;\n          break;\n      }\n    }\n  }\n\n  while(!que.empty()) {\n    int f, x, y, button;\n    tie(f, x, y, button) = que.front();\n    que.pop();\n    if(M[y][x] == '&') {\n      return (v[f][x][y][button]);\n    } else if(M[y][x] == '|') {\n      int nf = f ^ 1;\n      if(v[nf][x][y][button] == -1) {\n        v[nf][x][y][button] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, button);\n      }\n    } else if(M[y][x] < 10) {\n      int nbutton = button ^ (1 << M[y][x]);\n      int nf = (f + ((bit[x][y] >> M[y][x]) & 1)) & 1;\n      if(v[f][x][y][nbutton] == -1) {\n        v[nf][x][y][nbutton] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, nbutton);\n      }\n    }\n    for(int i = 0; i < 4; i++) {\n      int nx = x + vx[i], ny = y + vy[i];\n      int isgo = (f + __builtin_popcount(bit[nx][ny] & button)) & 1;\n      if(v[f][nx][ny][button] == -1 && (move[nx][ny] & ++isgo)) {\n        v[f][nx][ny][button] = v[f][x][y][button] + 1;\n        que.emplace(f, nx, ny, button);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    cin >> M[i];\n  }\n  cin >> S;\n  for(int i = 0; i < S; i++) {\n    for(int j = 0; j < H; j++) {\n      cin >> MS[i][j];\n    }\n  }\n  cout << Solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nconstexpr int MAX_SIZE = 50;\nconstexpr int MAX_S = 10;\n\nint w, h;\nint sx, sy, gx, gy;\n\nstring field[MAX_SIZE];\nbool initial_floar[MAX_SIZE][MAX_SIZE];\nint match[MAX_SIZE][MAX_SIZE];\nint dist[MAX_SIZE][MAX_SIZE][2][1 << MAX_S];\n\nbool get_floor(int x, int y, int s) {\n\treturn (__builtin_popcount(match[y][x] & s) + initial_floar[y][x]) & 1;\n}\n\nint bfs() {\n\ttypedef tuple<int, int, bool, int> state; // x, y, floor, switch state\n\tconstexpr int dx[] = {1, 0, -1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tqueue<state> que;\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INT_MAX);\n\tdist[sy][sx][0][0] = 0;\n\tque.push(state(sx, sy, 0, 0));\n\n\twhile(!que.empty()) {\n\t\tint x, y, s;\n\t\tbool f;\n\t\ttie(x, y, f, s) = que.front();\n\t\tque.pop();\n\n\t\tconst int &d = dist[y][x][f][s];\n\n\t\tdump(x, y, f, s, d);\n\n\t\tif(field[y][x] == '|') {\n\t\t\tif(dist[y][x][!f][s] > d + 1) {\n\t\t\t\tdist[y][x][!f][s] = d + 1;\n\t\t\t\tque.push(state(x, y, !f, s));\n\t\t\t}\n\t\t}\n\n\t\tif(islower(field[y][x])) {\n\t\t\tconst int next_s = s ^ (1 << (field[y][x] - 'a'));\n\t\t\tconst bool next_f = get_floor(x, y, next_s);\n\n\t\t\tif(dist[y][x][next_f][next_s] > d + 1) {\n\t\t\t\tdist[y][x][next_f][next_s] = d + 1;\n\t\t\t\tque.push(state(x, y, next_f, next_s));\n\t\t\t}\n\t\t}\n\n\t\trep(dir, 4) {\n\t\t\tconst int nx = x + dx[dir];\n\t\t\tconst int ny = y + dy[dir];\n\n\t\t\tif(field[ny][nx] == '#') continue;\n\t\t\tif(field[ny][nx] != '|' && f != get_floor(nx, ny, s)) continue;\n\n\t\t\tif(dist[ny][nx][f][s] > d + 1) {\n\t\t\t\tif(nx == gx && ny == gy) return d + 1;\n\t\t\t\tdist[ny][nx][f][s] = d + 1;\n\t\t\t\tque.push(state(nx, ny, f, s));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> w >> h;\n\n\trep(i, h) {\n\t\tcin >> field[i];\n\n\t\trep(j, w) {\n\t\t\tswitch(field[i][j]) {\n\t\t\tcase '%':\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tinitial_floar[i][j] = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(isupper(field[i][j])) {\n\t\t\t\t\tinitial_floar[i][j] = 1;\n\t\t\t\t\tfield[i][j] = tolower(field[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint s;\n\tcin >> s;\n\n\trep(k, s) {\n\t\trep(i, h) {\n\t\t\tstring row;\n\t\t\tcin >> row;\n\n\t\t\trep(j, w) {\n\t\t\t\tif(row[j] == '*') {\n\t\t\t\t\tmatch[i][j] |= (1 << k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << bfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cctype>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct state{\n\tint x,y,u,S; // u: ä»ä¸éãäºéã, S: æ¼ããã¹ã¤ããã®éå\n\tstate(int x,int y,int u,int S):x(x),y(y),u(u),S(S){}\n};\n\nint main(){\n\tint W,H; scanf(\"%d%d\",&W,&H);\n\tchar B[50][51];\n\trep(i,H) scanf(\"%s\",B[i]);\n\n\tint m; scanf(\"%d\",&m);\n\tchar sw[10][50][51];\n\trep(k,m) rep(i,H) scanf(\"%s\",sw[k][i]);\n\n\tint sx,sy,gx,gy;\n\trep(i,H) rep(j,W) {\n\t\tif(B[i][j]=='%') sx=j, sy=i, B[i][j]='_';\n\t\tif(B[i][j]=='&') gx=j, gy=i, B[i][j]='_';\n\t}\n\n\tstatic int dp[50][50][2][1<<10];\n\trep(x,W) rep(y,H) rep(k,2) rep(S,1<<m) dp[x][y][k][S]=INF;\n\tdp[sx][sy][0][0]=0;\n\n\tint ans=-1;\n\tqueue<state> Q; Q.push(state(sx,sy,0,0));\n\twhile(!Q.empty()){\n\t\tint x=Q.front().x,y=Q.front().y,u=Q.front().u,S=Q.front().S; Q.pop();\n\n\t\tif(x==gx && y==gy){ ans=dp[x][y][u][S]; break; }\n\n\t\t// åãéã®é£æ¥ãã¹ã¸ã®ç§»å\n\t\trep(k,4){\n\t\t\tint xx=x+dx[k],yy=y+dy[k];\n\t\t\tint u2=(B[yy][xx]=='^'||isupper(B[yy][xx])?1:0); // (xx,yy) ãä»ä½éã«ããã\n\t\t\trep(i,m) if(S&1<<i && sw[i][yy][xx]=='*') u2=1-u2;\n\t\t\tif(B[yy][xx]=='|') u2=u; // éæ®µã«ã¯ã©ã¡ãã®éãããè¡ãã\n\n\t\t\tif(B[yy][xx]=='#' || u2!=u) continue; // (xx,yy) ã«é²å¥ã§ããªã\n\n\t\t\tif(dp[xx][yy][u][S]>dp[x][y][u][S]+1){\n\t\t\t\tdp[xx][yy][u][S]=dp[x][y][u][S]+1;\n\t\t\t\tQ.push(state(xx,yy,u,S));\n\t\t\t}\n\t\t}\n\t\t// éæ®µã®ä¸ãä¸ã\n\t\tif(B[y][x]=='|'){\n\t\t\tif(dp[x][y][1-u][S]>dp[x][y][u][S]+1){\n\t\t\t\tdp[x][y][1-u][S]=dp[x][y][u][S]+1;\n\t\t\t\tQ.push(state(x,y,1-u,S));\n\t\t\t}\n\t\t}\n\t\t// ã¹ã¤ãããæ¼ã\n\t\tif(isalpha(B[y][x])){\n\t\t\tint id=tolower(B[y][x])-'a';\n\t\t\tint u2=u;\n\t\t\tint S2=S^(1<<id);\n\t\t\tif(sw[id][y][x]=='*') u2=1-u2;\n\n\t\t\tif(dp[x][y][u2][S2]>dp[x][y][u][S]+1){\n\t\t\t\tdp[x][y][u2][S2]=dp[x][y][u][S]+1;\n\t\t\t\tQ.push(state(x,y,u2,S2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nint w,h,s;\nstring mp[N];\nstring sw[11][N];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n \nbool check(int x,int y,int f,int bit){\n  if(mp[y][x]=='#')return 0;\n \n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n \n  char ch = mp[y][x];\n  if((cnt+f)%2==0)\n    if(isupper(ch)||ch=='^')return 0;\n  \n  if((cnt+f)%2==1)\n    if(islower(ch)||ch=='_'||ch=='&'||ch=='%')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n \nint used[N][N][2][1<<10];\nstruct dat{int x,y,f,bit,cost;};\nint bfs(int sx,int sy){\n  queue<dat> Q;\n  Q.push((dat){sx,sy,0,0,0});\n  \n  while(!Q.empty()){\n    dat t=Q.front();Q.pop();\n    int x=t.x,y=t.y,f=t.f,bit=t.bit,cost=t.cost;\n    if(mp[y][x]=='&')return cost;\n    if(used[x][y][f][bit]++) continue;\n    \n    if(mp[y][x]=='|') Q.push((dat){x,y,!f,bit,cost+1});\n    int th=mp[y][x]-(isupper(mp[y][x])? 'A':'a');\n    if(isalpha(mp[y][x]))Q.push((dat){x,y,(sw[th][y][x]=='*')?!f:f,nbit(bit,th),cost+1});\n    \n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(check(nx,ny,f,bit))Q.push((dat){nx,ny,f,bit,cost+1});\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')cout<<bfs(j,i)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nstruct state{\n\tint lev, r, c, swit, dist;\n\n\tvoid pp(int k){\n\t\tstring s;\n\t\tint x = swit;\n\t\trep(i, k) s += '0' + !!(x&(1<<i));\n\t\tprintf(\"lev = %d, pos = (%d, %d), swit = %s, dist = %d\\n\", lev, r, c, s.c_str(), dist);\n\t}\n};\n\nint pos[50][50][1 << 10];\nint vis[2][50][50][1 << 10];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint grid(char c){\n\treturn c == '^' || !!isupper(c);\n}\n\nvoid go(state &s, queue<state> &q){\n\tif (vis[s.lev][s.r][s.c][s.swit]) return;\n\tvis[s.lev][s.r][s.c][s.swit] = 1;\n\tq.push(s);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint w, h;\n\tcin >> w >> h;\n\tvector<string> v(h);\n\trep(i, h) cin >> v[i];\n\n\tint n;\n\tcin >> n;\n\tvector<vector<string>> sw(n);\n\trep(i, n){\n\t\tsw[i].resize(h);\n\t\trep(j, h) cin >> sw[i][j];\n\t}\n\n\tint sr = -1, sc = -1;\n\tint gr = -1, gc = -1;\n\trep(i, h) rep(j, w){\n\t\tchar &c = v[i][j];\n\t\tif (c == '%') sr = i, sc = j;\n\t\tif (c == '&') gr = i, gc = j;\n\t\tif (c == '#') continue;\n\t\tif (c == '|') continue;\n\t\tint def = grid(c);\n\t\tif (isupper(c)) c += 'a' - 'A';\n\t\trep(k, 1 << n){\n\t\t\tint &x = pos[i][j][k];\n\t\t\tx = def;\n\t\t\trep(l, n) if ((k>>l&1) && sw[l][i][j] == '*') x ^= 1;\n\t\t}\n\t}\n\n\tqueue<state> q;\n\tstate init{ 0, sr, sc, 0, 0 };\n\tgo(init, q);\n\n\twhile (!q.empty()){\n\t\tauto s = q.front();\n\t\tq.pop();\n\n\t\t//s.pp(n);\n\n\t\tif (s.r == gr && s.c == gc){\n\t\t\tcout << s.dist << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\t++s.dist;\n\t\tif (v[s.r][s.c] == '|'){\n\t\t\tauto nxt = s;\n\t\t\tnxt.lev ^= 1;\n\t\t\tgo(nxt, q);\n\t\t}\n\n\t\tif (isalpha(v[s.r][s.c])){\n\t\t\tauto nxt = s;\n\t\t\tnxt.swit ^= 1 << v[s.r][s.c] - 'a';\n\t\t\tif (pos[s.r][s.c][nxt.swit] != nxt.lev) nxt.lev ^= 1;\n\t\t\tgo(nxt, q);\n\t\t}\n\n\t\trep(d, 4){\n\t\t\tauto nxt = s;\n\t\t\tnxt.r += dx[d], nxt.c += dy[d];\n\t\t\tif (v[nxt.r][nxt.c] == '#') continue;\n\t\t\tif (v[nxt.r][nxt.c] != '|' && pos[nxt.r][nxt.c][nxt.swit] != nxt.lev) continue;\n\t\t\tgo(nxt, q);\n\t\t}\n\t}\n\tcout << -1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint w, h, s;\nint st, go;\nchar m[50][50], tmp[(1<<10)][50][50];\nchar ms[10][50][50];\nint dp[(1<<10)*50*50*2+50*50*2+50*50+50];\n\nint main(){\n\trep(i,(1<<10)*50*50*2+50*50*2+50*50+50) dp[i] = INF;\n\tcin >> w >> h;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == '%'){\n\t\t\tst = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t\tif(m[i][j] == '&'){\n\t\t\tgo = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t}\n\tcin >> s;\n\trep(i,s) rep(j,h) rep(k,w) cin >> ms[i][j][k];\n\trep(i,(1<<s)){\n\t\trep(j,h) rep(k,w) tmp[i][j][k] = m[j][k];\n\t\tint I = i;\n\t\trep(j,s){\n\t\t\tif(I&1){\n\t\t\t\trep(k,h) rep(l,w){\n\t\t\t\t\tif(ms[j][k][l] == '*'){\n\t\t\t\t\t\tif(tmp[i][k][l] == '_') tmp[i][k][l] = '^';\n\t\t\t\t\t\telse if(tmp[i][k][l] == '^') tmp[i][k][l] = '_';\n\t\t\t\t\t\telse if('a' <= tmp[i][k][l] && tmp[i][k][l] <= 'z'){\n\t\t\t\t\t\t\ttmp[i][k][l] = toupper(tmp[i][k][l]);\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\ttmp[i][k][l] = tolower(tmp[i][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tI >>= 1;\n\t\t}\n\t}\n\tqueue<int> que;\n\tque.push(st);\n\tdp[st] = 0;\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tque.pop();\n\t\tint i = q/(2*50*50), j = (q%(50*50))/50, k = q%50, f = (q%(2*50*50))/(50*50);\n\t\tif(tmp[i][j][k] == '#') continue;\n\t\tif(!f){\n\t\t\trep(l,4){\n\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\tif(tmp[i][J][K] == '|' || tmp[i][J][K] == '_' || ('a' <= tmp[i][J][K]&&tmp[i][J][K] <= 'z')){\n\t\t\t\t\tif(dp[i*2*50*50+50*J+K] != INF) continue;\n\t\t\t\t\tdp[i*2*50*50+50*J+K] = dp[q]+1;\n\t\t\t\t\tque.push(i*2*50*50+50*J+K);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[i][j][k] == '|' && dp[i*2*50*50+50*50+50*j+k] == INF){\n\t\t\t\tdp[i*2*50*50+50*50+50*j+k] = dp[q]+1;\n\t\t\t\tque.push(i*2*50*50+50*50+50*j+k);\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\trep(l,4){\n\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\tif(tmp[i][J][K] == '|' || tmp[i][J][K] == '^' || ('A' <= tmp[i][J][K]&&tmp[i][J][K] <= 'Z')){\n\t\t\t\t\tif(dp[i*2*50*50+50*50+50*J+K] != INF) continue;\n\t\t\t\t\tdp[i*2*50*50+50*50+50*J+K] = dp[q]+1;\n\t\t\t\t\tque.push(i*2*50*50+50*50+50*J+K);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[i][j][k] == '|' && dp[i*2*50*50+50*j+k] == INF){\n\t\t\t\tdp[i*2*50*50+50*j+k] = dp[q]+1;\n\t\t\t\tque.push(i*2*50*50+50*j+k);\n\t\t\t}\n\t\t}\n\t\tif(!f && 'a' <= tmp[i][j][k] && tmp[i][j][k] <= 'z'){\n\t\t\tint z = tmp[i][j][k]-'a';\n\t\t\tint flo = 0;\n\t\t\tif(ms[z][j][k] == '*') flo = 1;\n\t\t\tif(i&(1<<z)){\n\t\t\t\tif(dp[(i-(1<<z))*2*50*50+flo*50*50+50*j+k] == INF){\n\t\t\t\t\tdp[(i-(1<<z))*2*50*50+flo*50*50+50*j+k] = dp[q]+1;\n\t\t\t\t\tque.push((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(dp[(i+(1<<z))*2*50*50+flo*50*50+50*j+k] == INF){\n\t\t\t\t\tdp[(i+(1<<z))*2*50*50+flo*50*50+50*j+k] = dp[q]+1;\n\t\t\t\t\tque.push((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f && 'A' <= tmp[i][j][k] && tmp[i][j][k] <= 'Z'){\n\t\t\tint z = tmp[i][j][k] - 'A';\n\t\t\tint flo = 1;\n\t\t\tif(ms[z][j][k] == '*') flo = 0;\n\t\t\tif(i&(1<<z)){\n\t\t\t\tif(dp[(i-(1<<z))*2*50*50+flo*50*50+50*j+k] == INF){\n\t\t\t\t\tdp[(i-(1<<z))*2*50*50+flo*50*50+50*j+k] = dp[q]+1;\n\t\t\t\t\tque.push((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(dp[(i+(1<<z))*2*50*50+flo*50*50+50*j+k] == INF){\n\t\t\t\t\tdp[(i+(1<<z))*2*50*50+flo*50*50+50*j+k] = dp[q]+1;\n\t\t\t\t\tque.push((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,(1<<10)*50*50*2+50*50*2+50*50+50){\n\t\tif(i%(50*50) != go) continue;\n\t\tans = min(ans,dp[i]);\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nint H, W;\nll dist[55][55][2][1<<10];\nstring M[55];\nstring MS[16][55];\nint gh, gw, sh, sw;\nint S;\nint dh[4] = {1, -1, 0, 0};\nint dw[4] = {0, 0, 1, -1};\n\nstruct state {\n    int h, w, f, bits;\n};\n\nbool can(state now) {\n    if(now.h < 0 or now.h >= H) return false;\n    if(now.w < 0 or now.w >= W) return false;\n    if(M[now.h][now.w] == '#') return false;\n    if(M[now.h][now.w] == '|') return true;\n    int f = 0;\n    if(M[now.h][now.w] == '^') f = 1;\n    if(M[now.h][now.w] >= 'A' and M[now.h][now.w] <= 'Z') f = 1;\n    for(int i = 0; i < S; i++) {\n        if(!(now.bits & (1 << i))) continue;\n        if(MS[i][now.h][now.w] == '*') f = 1 - f;\n    }\n    return now.f == f;\n}\n\nint main() {\n    cin >> W >> H;\n    for(int h = 0; h < H; h++) {\n        cin >> M[h];\n        for(int w = 0; w < W; w++) {\n            if(M[h][w] == '%') {\n                sh = h;\n                sw = w;\n            }\n            if(M[h][w] == '&') {\n                gh = h;\n                gw = w;\n            }\n            for(int k = 0; k < 2; k++) {\n                for(int j = 0; j < (1<<10); j++) {\n                    dist[h][w][k][j] = INF;\n                }\n            }\n        }\n    }\n    cin >> S;\n    for(int s = 0; s < S; s++) {\n        for(int h = 0; h < H; h++) {\n            cin >> MS[s][h];\n        }\n    }\n    state start;\n    start.h = sh;\n    start.w = sw;\n    start.bits = 0;\n    start.f = 0;\n    dist[sh][sw][0][0] = 0;\n    queue<state> que;\n    que.push(start);\n    while(!que.empty()) {\n        auto from = que.front();\n        que.pop();\n        ll c = dist[from.h][from.w][from.f][from.bits] + 1;\n        if(M[from.h][from.w] == '|') {\n            auto to = from;\n            to.f = 1 - to.f;\n            if(chmin(dist[to.h][to.w][to.f][to.bits], c)) que.push(to);\n        }\n        for(int k = 0; k < 4; k++) {\n            auto to = from;\n            to.h += dh[k];\n            to.w += dw[k];\n            if(!can(to)) continue;\n            if(chmin(dist[to.h][to.w][to.f][to.bits], c)) que.push(to);\n        }\n        for(int i = 0; i < S; i++) {\n            auto to = from;\n            if(M[to.h][to.w] == (char)('a' + i)) {\n            } else if(M[to.h][to.w] == (char)('A' + i)) {\n            } else {\n                continue;\n            }\n            to.bits ^= (1 << i);\n            if(MS[i][to.h][to.w] == '*') to.f ^= 1;\n            if(chmin(dist[to.h][to.w][to.f][to.bits], c)) que.push(to);\n        }\n    }\n    ll ans = INF;\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < (1 << S); j++) {\n            chmin(ans, dist[gh][gw][i][j]);\n        }\n    }\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint W, H, S;\nchar M[55][55];\nchar MS[11][55][55];\nint flr[55][55];\nint sy, sx, gy, gx;\n\nint dist[2][55][55][1<<10];\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nbool in(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> W >> H;\n  rep(i, H) rep(j, W) {\n    cin >> M[i][j];\n    if(M[i][j] == '%') sy = i, sx = j;\n    else if(M[i][j] == '&') gy = i, gx = j;\n    else if(M[i][j] == '_' || islower(M[i][j])) flr[i][j] = 0;\n    else if(M[i][j] == '^' || isupper(M[i][j])) flr[i][j] = 1;\n  }\n  cin >> S;\n  rep(i, S) rep(j, H) rep(k, W) cin >> MS[i][j][k];\n\n\n  queue< tuple<int, int, int, int> > que;\n\n  memset(dist, -1, sizeof(dist));\n  dist[0][sy][sx][0] = 0;\n  que.emplace(0, sy, sx, 0);\n\n  while(que.size()) {\n    int f, y, x, bit;\n    tie(f, y, x, bit) = que.front(); que.pop();\n    if(y == gy && x == gx) {\n      cout << dist[f][y][x][bit] << endl;\n      return 0;\n    }\n    if(M[y][x] == '|' && dist[!f][y][x][bit] == -1) {\n      dist[!f][y][x][bit] = dist[f][y][x][bit] + 1;\n      que.emplace(!f, y, x, bit);\n    }\n    if(isalpha(M[y][x])) {\n      int g = flr[y][x];\n      rep(j, S) if(((bit >> j) & 1) && MS[j][y][x] == '*') g = !g;\n      if(f == g) {\n\tint nf = f, ny = y, nx = x, nbit = bit;\n\tint digit = M[ny][nx] - (islower(M[ny][nx]) ? 'a' : 'A');\n\tnbit ^= 1<<digit;\n\tif(MS[digit][ny][nx] == '*') nf = !nf;\n\tif(dist[nf][ny][nx][nbit] == -1) {\n\t  dist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\t  que.emplace(nf, ny, nx, nbit);\n\t}\n      }\n    }\n    rep(i, 4) {\n      int nf = f, ny = y + dy[i], nx = x + dx[i], nbit = bit;\n      if(!in(ny, nx) || M[ny][nx] == '#') continue;\n      int g = flr[ny][nx];\n      rep(j, S) if(((nbit >> j) & 1) && MS[j][ny][nx] == '*') g = !g;\n      if(nf == g || M[ny][nx] == '|') {\n\tdist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\tque.emplace(nf, ny, nx, nbit);\n      }\n    }\n  }\n  cout << -1 << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint dp[55][55][2][1333];\nint bef[1030][55][55];\nsigned main(){\n\trep(i,55)rep(j,55)rep(q,2)rep(k,1333)dp[i][j][q][k]=inf;\n\t\n\tint n,m;\n\tcin>>m>>n;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\t\n\tvector<vs>ini(2,in);\n\t\n\trep(i,n)rep(j,m){\n\t\tif(in[i][j]=='%')ini[1][i][j]='#';\n\t\tif(in[i][j]=='_')ini[1][i][j]='#';\n\t\tif(in[i][j]=='^')ini[0][i][j]='#';\n\t\tif(islower(in[i][j]))ini[1][i][j]='#';\n\t\tif(isupper(in[i][j])){\n\t\t\tini[0][i][j]='#';\n\t\t\tini[1][i][j]=tolower(in[i][j]);\n\t\t}\n\t\tif(in[i][j]=='&')ini[1][i][j]='#';\n\t}\n\t\n\tint q;\n\tcin>>q;\n\tvector<vs>w(q,vs(n));\n\trep(i,q)rep(j,n)cin>>w[i][j];\n\t\n\tqueue<tp>que;\n\trep(i,n)rep(j,m)if(in[i][j]=='%'){\n\t\tque.push(tp(i,j,0,0));\n\t\tdp[i][j][0][0]=0;\n\t}\n\t\n\trep(C,1<<q){\n\t\trep(c,10)if(C&1<<c)rep(i,n)rep(j,m)if(w[c][i][j]=='*')\n\t\t\tbef[C][i][j]^=1;\n\t}\n\t\n\tint out=inf;\n\twhile(!que.empty()){\n\t\tint x,y,f,s;\n\t\ttie(x,y,f,s)=que.front();\n\t\t// cout<<x<<\" \"<<y<<\" \"<<f<<\" \"<<s<<\" \"<<dp[x][y][f][s]<<endl;\n\t\tque.pop();\n\t\t\n\t\t\n\t\tvector<vs>now(2,vs(3,string(3,'a')));\n\t\t// show2d(now);\n\t\trep(i,2)rep(j,3)rep(k,3)now[i][j][k]=ini[i][x+j-1][y+k-1];\n\t\t// show2d(now);\n\t\trep(i,3)rep(j,3)if(bef[s][x+i-1][y+j-1]){\n\t\t\tswap(now[0][i][j],now[1][i][j]);\n\t\t}\n\t\tif(now[f][1][1]=='&'){\n\t\t\tout=dp[x][y][f][s];\n\t\t\tbreak;\n\t\t}\n\t\trep(k,4){\n\t\t\tint nx=x+dx[k];\n\t\t\tint ny=y+dy[k];\n\t\t\tif(now[f][dx[k]+1][dy[k]+1]=='#')continue;\n\t\t\tif(dp[x][y][f][s]+1<dp[nx][ny][f][s]){\n\t\t\t\tdp[nx][ny][f][s]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(nx,ny,f,s));\n\t\t\t}\n\t\t}\n\t\tif(isalpha(now[f][1][1])){\n\t\t\tint ns=s^1<<(now[f][1][1]-'a');\n\t\t\tint nf=f;\n\t\t\tif(w[now[f][1][1]-'a'][x][y]=='*')nf^=1;\n\t\t\tif(dp[x][y][f][s]+1<dp[x][y][nf][ns]){\n\t\t\t\tdp[x][y][nf][ns]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(x,y,nf,ns));\n\t\t\t}\n\t\t}\n\t\tif(now[f][1][1]=='|'){\n\t\t\tint nf=f^1;\n\t\t\tif(dp[x][y][f][s]+1<dp[x][y][nf][s]){\n\t\t\t\tdp[x][y][nf][s]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(x,y,nf,s));\n\t\t\t}\n\t\t}\n\t}\n\tif(out==inf)out=-1;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nint W, H, S;\nchar M[55][55];\nchar MS[11][55][55];\nint flr[55][55];\n\nint dist[2][55][55][1<<10];\n\nint sx, sy, gx, gy;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint main(){\n  cin >> W >> H;\n  rep(i, H) rep(j, W) {\n    cin >> M[i][j];\n    if(M[i][j] == '%') sx = j, sy = i;\n    if(M[i][j] == '&') gx = j, gy = i;\n    if(islower(M[i][j]) || M[i][j] == '_') flr[i][j] = 0;\n    if(isupper(M[i][j]) || M[i][j] == '^') flr[i][j] = 1;\n  }\n  cin >> S;\n  rep(i, S) rep(j, H) rep(k, W) cin >> MS[i][j][k];\n  \n  int ans = -1;\n\n  memset(dist, -1, sizeof(dist));\n  queue< tuple<int, int, int, int> > que;\n  que.emplace(0, sy, sx, 0);\n  dist[0][sy][sx][0] = 0;\n  while(!que.empty()) {\n    int f, y, x, bit;\n    tie(f, y, x, bit) = que.front(); que.pop(); \n    if(y == gy && x == gx) {\n      ans = dist[f][y][x][bit];\n      break;\n    }\n    //cout << f << \" \" << y << \" \" << x << \" \" << endl;\n    //rep(i, 10) cout << (int)((bit >> i) & 1);\n    //cout << endl;\n    rep(i, 4) {\n      int nf = f, ny = y + dy[i], nx = x + dx[i], nbit = bit;\n      if(0 <= ny && ny < H && 0 <= nx && nx < W &&\n\t M[ny][nx] != '#' && dist[nf][ny][nx][nbit] == -1) {\n\tint t = flr[ny][nx];\n\trep(k, S) if((nbit >> k) & 1) if(MS[k][ny][nx] == '*') t = !t;\n\tif(nf == t || M[ny][nx] == '|') {\n\t  que.emplace(nf, ny, nx, nbit);\n\t  dist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\t}\n      }\n    }\n    if(M[y][x] == '|' && dist[!f][y][x][bit] == -1) {\n      que.emplace(!f, y, x, bit);\n      dist[!f][y][x][bit] = dist[f][y][x][bit] + 1;\n    }\n    int t = flr[y][x];\n    rep(k, S) if((bit >> k) & 1) if(MS[k][y][x] == '*') t = !t;\n    if(t == f && isalpha(M[y][x])) {\n      int nf = f;\n      int nbit = bit;\n      int digit = 0;\n      if(islower(M[y][x])) digit = M[y][x] - 'a';\n      else digit = M[y][x] - 'A';      \n      if((nbit >> digit) & 1) nbit = nbit - (1 << digit);\n      else nbit = nbit + (1 << digit);\n      if(MS[digit][y][x] == '*') nf = !nf;\n      if(dist[nf][y][x][nbit] == -1) {\n\tque.emplace(nf, y, x, nbit);\n\tdist[nf][y][x][nbit] = dist[f][y][x][bit] + 1;\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 50\n#define MAX_W 50\n#define MAX_S 10\n\nstruct State{\n  int d,x,y,s,f;\n  State(int d,int x,int y,int s,int f) :\n    d(d),x(x),y(y),s(s),f(f) {}\n};\n\nchar M[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W][1<<MAX_S][2];\n\nint getFloor(int x,int y,int f){\n  if(M[y][x] == '|'){ return f; }\n  if(M[y][x] == '_' || islower(M[y][x])){\n    return 0;\n  }\n  return 1;\n}\n\nint main(){\n  int H,W,sx,sy,gx,gy,S;\n  char MS[MAX_H][MAX_W][MAX_S];\n  cin >> W >> H;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '%'){\n        M[i][j] = '_';\n        sx = j; sy = i;\n      }\n      if(M[i][j] == '&'){\n        M[i][j] = '_';\n        gx = j; gy = i;\n      }\n    }\n  }\n  cin >> S;\n  for(int i = 0 ; i < S ; i++){\n    for(int j = 0 ; j < H ; j++){\n      for(int k = 0 ; k < W ; k++){\n        cin >> MS[j][k][i];\n      }\n    }\n  }\n  int ans = -1;\n  memset(visited,false,sizeof(visited));\n  visited[sy][sx][0][0] = true;\n  const int dx[] = {-1,0,1,0};\n  const int dy[] = {0,-1,0,1};\n  queue<State> Q;\n  Q.push(State(0,sx,sy,0,0));\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    int x = s.x, y = s.y;\n    if(x == gx && y == gy){\n      ans = s.d;\n      break;\n    }\n    if(islower(M[y][x])){\n      int sw = M[y][x] - 'a';\n      int next = s.s ^ (1<<sw);\n      int nf = s.f;\n      if(MS[y][x][sw] == '*'){\n        nf = 1-nf;\n      }\n      if(!visited[y][x][next][nf]){\n        visited[y][x][next][nf] = true;\n        Q.push(State(s.d+1,x,y,next,nf));\n      }\n    }\n    if(isupper(M[y][x])){\n      int sw = M[y][x] - 'A';\n      int next = s.s ^ (1<<sw);\n      int nf = s.f;\n      if(MS[y][x][sw] == '*'){\n        nf = 1-nf;\n      }\n      if(!visited[y][x][next][nf]){\n        visited[y][x][next][nf] = true;\n        Q.push(State(s.d+1,x,y,next,nf));\n      }\n    }\n    if(M[y][x] == '|'){\n      int next = 1-s.f;\n      if(!visited[y][x][s.s][next]){\n        visited[y][x][s.s][next] = true;\n        Q.push(State(s.d+1,x,y,s.s,next));\n      }\n    }\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      int f = s.f;\n      if(0 > nx || W <= nx || 0 > ny || H <= ny){\n        continue;\n      }\n      if(M[ny][nx] == '#'){ continue; }\n      int nf = getFloor(nx,ny,f);\n      for(int j = 0 ; j < S ; j++){\n        if((s.s >> j) & 1){\n          if(MS[ny][nx][j] == '*'){\n            nf = 1 - nf;\n          }\n        }\n      }\n      if(f == nf && !visited[ny][nx][s.s][nf]){\n        visited[ny][nx][s.s][nf] = true;\n        Q.push(State(s.d+1,nx,ny,s.s,nf));\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint d[1<<10][55][55][2];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int w, h;\n  cin >> w >> h;\n  vector<string> board(h);\n  REP(i, h) cin >> board[i];\n  int s;\n  cin >> s;\n  vector<vector<string>> t(s, vector<string>(h));\n  REP(i, s) REP(j, h) cin >> t[i][j];\n\n  vector<vector<string>> ope(1<<s, vector<string>(h));\n\n  int sx = -1, sy = -1, gx = -1, gy = -1;\n  REP(y, h) REP(x, w) {\n    if(board[y][x] == '%') sx = x, sy = y, board[y][x] = '_';\n    if(board[y][x] == '&') gx = x, gy = y, board[y][x] = '_';\n  }\n\n  // cout << (int)'a' << \" \" << (int)'A' << endl;\n  REP(i, 1<<s) {\n    ope[i] = vector<string>(h, string(w, '.'));\n    REP(j, s) if(i&1<<j) {\n      REP(y, h) REP(x, w) {\n        if(t[j][y][x] == '*') {\n          if(ope[i][y][x] == '*') ope[i][y][x] = '.';\n          else ope[i][y][x] = '*';\n        }\n      }\n    }\n    // cout << \"ope\" << endl;\n    // REP(y, h) cout << ope[i][y] << endl;\n    REP(y, h) REP(x, w) {\n      if(ope[i][y][x] == '*') {\n        if(board[y][x] == '_') ope[i][y][x] = '^';\n        else if(board[y][x] == '^') ope[i][y][x] = '_';\n        else if('a' <= board[y][x] && board[y][x] <= 'z') {\n          ope[i][y][x] = board[y][x] - ('a' - 'A');\n        } else if('A' <= board[y][x] && board[y][x] <= 'Z') {\n          ope[i][y][x] = board[y][x] + ('a' - 'A');\n        } else ope[i][y][x] = board[y][x];\n      } else {\n        ope[i][y][x] = board[y][x];\n      }\n    }\n    // cout << \"i:\" << i << endl;\n    // REP(y, h) cout << ope[i][y] << endl;\n  }\n\n  REP(i, 1<<s) REP(j, h) REP(k, w) REP(l, 2) d[i][j][k][l] = LLINF;\n  d[0][sy][sx][0] = 0;\n  priority_queue<VI, VVI, greater<VI>> que;\n  que.push({d[0][sy][sx][0], 0, sy, sx, 0});\n\n  while(que.size()) {\n    VI v = que.top(); que.pop();\n    int mask = v[1], y = v[2], x = v[3], fl = v[4];\n    if(d[mask][y][x][fl] < v[0]) continue;\n    // REP(i, h) cout << ope[mask][i] << endl;\n    // cout << \"cost:\" << v[0] << \" mask:\" << mask << \" y:\" << y << \" x:\" << x << \" \" << fl << endl;\n    // ä¸ä¸å·¦å³ã¸ã®ç§»å\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      char tmp[2] = {'_', '^'};\n      bool cond = ope[mask][ny][nx] == tmp[fl] || (isupper(ope[mask][ny][nx]) && fl == 1) || (islower(ope[mask][ny][nx]) && fl == 0) || (ope[mask][ny][nx] == '|');\n      if(IN(0LL, w, nx) && IN(0LL, h, ny) && cond\n        && d[mask][ny][nx][fl] > d[mask][y][x][fl] + 1) {\n        d[mask][ny][nx][fl] = d[mask][y][x][fl] + 1;\n        que.push({d[mask][ny][nx][fl], mask, ny, nx, fl});\n      }\n    }\n    // éæ®µ\n    if(ope[mask][y][x] == '|' && d[mask][y][x][!fl] > d[mask][y][x][fl] + 1) {\n      d[mask][y][x][!fl] = d[mask][y][x][fl] + 1;\n      que.push({d[mask][y][x][fl], mask, y, x, !fl});\n    }\n    // ã¹ã¤ãã\n    if(isupper(ope[mask][y][x]) && fl == 1) {\n      int nmask = mask ^ (1<<(ope[mask][y][x]-'A'));\n      int nfl = fl;\n      if((isupper(ope[nmask][y][x]) && islower(ope[mask][y][x]))\n        || (islower(ope[nmask][y][x]) && isupper(ope[mask][y][x]))) {\n        nfl = !nfl;\n      }\n      if(d[nmask][y][x][nfl] > d[mask][y][x][fl] + 1) {\n        d[nmask][y][x][nfl] = d[mask][y][x][fl] + 1;\n        que.push({d[nmask][y][x][nfl], nmask, y, x, nfl});\n      }\n    }\n    if(islower(ope[mask][y][x]) && fl == 0) {\n      int nmask = mask ^ (1<<(ope[mask][y][x]-'A'));\n      int nfl = fl;\n      if((isupper(ope[nmask][y][x]) && islower(ope[mask][y][x]))\n        || (islower(ope[nmask][y][x]) && isupper(ope[mask][y][x]))) {\n        nfl = !nfl;\n      }\n      if(d[nmask][y][x][nfl] > d[mask][y][x][fl] + 1) {\n        d[nmask][y][x][nfl] = d[mask][y][x][fl] + 1;\n        que.push({d[nmask][y][x][nfl], nmask, y, x, nfl});\n      }\n    }\n  }\n\n  int ret = LLINF;\n  REP(i, 1<<s) REP(j, 2) chmin(ret, d[i][gy][gx][j]);\n  if(ret == LLINF) cout << -1 << endl;\n  else cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nstruct state\n{\n  int f;\n  int i, j;\n  unsigned s;\n  state() : f(0), i(-1), j(-1), s(0) {}\n  state(int a, int b, int c, unsigned d) : f(a), i(b), j(c), s(d) {}\n};\n\nstruct dungeon\n{\n  vector<string> grid;\n  vector<vector<string> > moves;\n\n  inline static int initial_floor(char c)\n  {\n    return c == '^' || isupper(c);\n  }\n\n  char get(const state& s) const\n  {\n    const char c = grid[s.i][s.j];\n    if (c == '#' || c == '|') {\n      return c;\n    }\n    int f = initial_floor(c);\n    const int S = moves.size();\n    for (int i = 0; i < S; i++) {\n      const vector<string>& g = moves[i];\n      if ((s.s & (1<<i)) && g[s.i][s.j] == '*') {\n        f ^= 1;\n      }\n    }\n    if (f == s.f) {\n      return tolower(c);\n    } else {\n      return '#';\n    }\n  }\n};\n\nint main()\n{\n  int H, W;\n  dungeon d;\n  cin >> W >> H;\n  d.grid.resize(H);\n  state start;\n  for (int i = 0; i < H; i++) {\n    cin >> d.grid[i];\n    for (int j = 0; j < W; j++) {\n      if (d.grid[i][j] == '%') {\n        start.i = i;\n        start.j = j;\n      }\n    }\n  }\n  int S;\n  cin >> S;\n  for (int k = 0; k < S; k++) {\n    vector<string> v(H);\n    for (int i = 0; i < H; i++) {\n      cin >> v[i];\n    }\n    d.moves.push_back(v);\n  }\n\n  static const int INF = 10000000;\n  static int dist[2][50][50][1<<10];\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < H; j++) {\n      for (int k = 0; k < W; k++) {\n        fill_n(dist[i][j][k], 1<<S, INF);\n      }\n    }\n  }\n  dist[start.f][start.i][start.j][start.s] = 0;\n  queue<state> q;\n  q.push(start);\n  int ans = INF;\n  while (!q.empty()) {\n    const state s = q.front();\n    q.pop();\n    const int dd = dist[s.f][s.i][s.j][s.s] + 1;\n    const char here = d.get(s);\n    if (here == '&') {\n      ans = min(ans, dd-1);\n    }\n\n    for (int i = 0; i < 4; i++) {\n      static const int di[] = {-1, 1, 0, 0}, dj[] = {0, 0, -1, 1};\n      const state t(s.f, s.i + di[i], s.j + dj[i], s.s);\n      int& next = dist[t.f][t.i][t.j][t.s];\n      if (d.get(t) != '#' && dd < next) {\n        next = dd;\n        q.push(t);\n      }\n    }\n\n    if (here == '|') {\n      const state t(s.f ^ 1, s.i, s.j, s.s);\n      int& next = dist[t.f][t.i][t.j][t.s];\n      if (dd < next) {\n        next = dd;\n        q.push(t);\n      }\n    } else if (isalpha(here)) {\n      const int sw = here - 'a';\n      int f = s.f;\n      if (d.moves[sw][s.i][s.j] == '*') {\n        f ^= 1;\n      }\n      const state t(f, s.i, s.j, s.s ^ (1<<sw));\n      int& next = dist[t.f][t.i][t.j][t.s];\n      if (dd < next) {\n        next = dd;\n        q.push(t);\n      }\n    }\n  }\n  if (ans == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=55,INF=1<<30;\nint H,W,K,sh,sw,gh,gw;\nint dis[MAX][MAX][2][1024];\nchar S[MAX][MAX],T[MAX][MAX][10];\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nstruct dat{\n    int h;\n    int w;\n    int f;\n    int state;\n};\n\nvoid BFS(){\n    dis[sh][sw][0][0]=0;\n    queue<dat> Q;\n    Q.push({sh,sw,0,0});\n    \n    while(!Q.empty()){\n        auto u=Q.front();Q.pop();\n        int h=u.h,w=u.w,f=u.f,state=u.state,d=dis[h][w][f][state];\n        \n        int s=0;\n        for(int i=0;i<K;i++){\n            if(state&(1<<i)){\n                if(T[h][w][i]=='*') s^=1;\n            }\n        }\n        \n        if(S[h][w]=='|'){\n            if(chmin(dis[h][w][f^1][state],d+1)){\n                Q.push({h,w,f^1,state});\n            }\n        }\n        \n        if(s==f){\n            if('a'<=S[h][w]&&S[h][w]<='z'){\n                int x=S[h][w]-'a';\n                if(chmin(dis[h][w][f^(T[h][w][x]=='*')][state^(1<<x)],d+1)){\n                    Q.push({h,w,f^(T[h][w][x]=='*'),state^(1<<x)});\n                }\n            }\n        }else{\n            if('A'<=S[h][w]&&S[h][w]<='Z'){\n                int x=S[h][w]-'A';\n                if(chmin(dis[h][w][f^(T[h][w][x]=='*')][state^(1<<x)],d+1)){\n                    Q.push({h,w,f^(T[h][w][x]=='*'),state^(1<<x)});\n                }\n            }\n        }\n        \n        for(int k=0;k<4;k++){\n            int toh=h+dh[k],tow=w+dw[k];\n            if(toh<0||toh>=H||tow<0||tow>=W) continue;\n            \n            int s=0;\n            for(int i=0;i<K;i++){\n                if(state&(1<<i)){\n                    if(T[toh][tow][i]=='*') s^=1;\n                }\n            }\n            if(s==f){\n                if(S[toh][tow]=='#'||S[toh][tow]=='^') continue;\n                if('A'<=S[toh][tow]&&S[toh][tow]<='Z') continue;\n            }else{\n                if(S[toh][tow]=='#'||S[toh][tow]=='_'||S[toh][tow]=='%'||S[toh][tow]=='&') continue;\n                if('a'<=S[toh][tow]&&S[toh][tow]<='z') continue;\n            }\n            \n            if(chmin(dis[toh][tow][f][state],d+1)){\n                Q.push({toh,tow,f,state});\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>W>>H;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n            if(S[i][j]=='%'){\n                sh=i;sw=j;\n            }\n            if(S[i][j]=='&'){\n                gh=i;gw=j;\n            }\n            \n            for(int k=0;k<2;k++) for(int l=0;l<1024;l++) dis[i][j][k][l]=INF;\n        }\n    }\n    cin>>K;\n    for(int t=0;t<K;t++){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>T[i][j][t];\n            }\n        }\n    }\n    \n    BFS();\n    \n    int ans=INF;\n    \n    for(int k=0;k<2;k++){\n        for(int l=0;l<(1<<K);l++){\n            int s=0;\n            for(int i=0;i<K;i++){\n                if(l&(1<<i)){\n                    if(T[gh][gw][i]=='*') s^=1;\n                }\n            }\n            if(s==k) chmin(ans,dis[gh][gw][k][l]);\n        }\n    }\n    \n    \n    if(ans==INF) ans=-1;\n    \n    cout<<ans<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, int, char>;\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0, '_'));\n\n    vector<vector<vvb>> used(h, vector<vvb>(w, vvb(1 << n, vb(2, false))));\n\n    while(q.size()){\n        int cc, cx, cy, cb; char cf;\n        tie(cc, cx, cy, cb, cf) = q.top();\n        q.pop();\n\n        if(cx == tx and cy == ty){\n            cout << cc << endl;\n            return 0;\n        }\n\n        int cfi = (cf == '^');\n        if(used[cy][cx][cb][cfi]) continue;\n        used[cy][cx][cb][cfi] = true;\n\n        int nc = cc + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(not used[cy][cx][nb][nfi]){\n                q.push(State(nc, cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(not used[cy][cx][cb][nfi]){\n                q.push(State(nc, cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and not used[ny][nx][cb][cfi]){\n                q.push(State(nc, nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and not used[ny][nx][cb][nfi]){\n                q.push(State(nc, nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, char>;\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vvi sw_field(h, vi(w));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[y][x] |= (1 << i);\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(State(sx, sy, 0, '_'));\n\n    vector<vector<vvi>> min_cost(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n    min_cost[sy][sx][0][0] = 0;\n\n    while(q.size()){\n        int cx, cy, cb; char cf;\n        tie(cx, cy, cb, cf) = q.front();\n        q.pop();\n\n        int cfi = (cf == '^');\n\n        if(cx == tx and cy == ty){\n            cout << min_cost[cy][cx][cb][cfi] << endl;\n            return 0;\n        }\n\n        int nc = min_cost[cy][cx][cb][cfi] + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[cy][cx] & (1 << idx)){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(chmin(min_cost[cy][cx][nb][nfi], nc)){\n                q.push(State(cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(chmin(min_cost[cy][cx][cb][nfi], nc)){\n                q.push(State(cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and chmin(min_cost[ny][nx][cb][cfi], nc)){\n                q.push(State(nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = (__builtin_popcount(sw_field[ny][nx] & cb) % 2 == 1);\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and chmin(min_cost[ny][nx][cb][nfi], nc)){\n                q.push(State(nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nbool is_change[10][50][50];\n\nstruct State{\n\tState(int arg_floor,int arg_row,int arg_col,int arg_button_state,int arg_step){\n\t\tfloor = arg_floor;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tbutton_state = arg_button_state;\n\t\tstep = arg_step;\n\t}\n\n\tbool operator<(const struct State &arg) const{\n\t\treturn step > arg.step;\n\t};\n\tint floor,row,col,button_state,step;\n};\n\nint W,H,POW[11],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar first_map[50][51];\n\nint dp[2][51][51][1024];\n\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_map[row][col] == '%'){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t\tfirst_map[row][col] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tfor(int i = 0; i < S; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tis_change[i][row][col] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tchar tmp_map[H][W+1];\n\n\tfor(int i = 0; i < S; i++){\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tscanf(\"%s\",tmp_map[row]);\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(tmp_map[row][col] == '*'){\n\t\t\t\t\tis_change[i][row][col] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfor(int state = 0; state < POW[S]; state++)dp[i][row][col][state] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpriority_queue<State> Q;\n\tdp[0][start_row][start_col][0] = 0;\n\tQ.push(State(0,start_row,start_col,0,0));\n\n\tint calc_map[2][H][W];\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().step > dp[Q.top().floor][Q.top().row][Q.top().col][Q.top().button_state]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tint calc_table[H][W];\n\t\tfor(int row = max(0,Q.top().row-1); row <= min(Q.top().row+1,H-1); row++){\n\t\t\tfor(int col = max(0,Q.top().col-1); col <= min(Q.top().col+1,W-1); col++)calc_table[row][col] = 0;\n\t\t}\n\n\t\tfor(int loop = 0; loop < S; loop++){\n\t\t\tif(Q.top().button_state & (1 << loop)){\n\t\t\t\tfor(int row = max(0,Q.top().row-1); row <= min(Q.top().row+1,H-1); row++){\n\t\t\t\t\tfor(int col = max(0,Q.top().col-1); col <= min(Q.top().col+1,W-1); col++){\n\t\t\t\t\t\tif(is_change[loop][row][col])calc_table[row][col]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = max(0,Q.top().row-1); row <= min(Q.top().row+1,H-1); row++){\n\t\t\tfor(int col = max(0,Q.top().col-1); col <= min(Q.top().col+1,W-1); col++){\n\t\t\t\tswitch(first_map[row][col]){\n\t\t\t\tcase '#':\n\t\t\t\t\tcalc_map[0][row][col] = '#';\n\t\t\t\t\tcalc_map[1][row][col] = '#';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tcalc_map[0][row][col] = '|';\n\t\t\t\t\tcalc_map[1][row][col] = '|';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '&';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '&';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(first_map[row][col] >= 'a' && first_map[row][col] <= 'j'){\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col];\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col]-32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col]+32;\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\tif(Q.top().floor == 0){\n\n\t\t\t\tif(calc_map[0][adj_row][adj_col] == '_'){\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] >= 'a' && calc_map[0][adj_row][adj_col] <= 'j'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'a';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tif(is_change[num][adj_row][adj_col]){\n\t\t\t\t\t\tnext_floor = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(calc_map[1][adj_row][adj_col] == '^'){\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] >= 'A' && calc_map[1][adj_row][adj_col] <= 'J'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'A';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tif(is_change[num][adj_row][adj_col]){\n\t\t\t\t\t\tnext_floor = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 55, ST = 1 << 10, dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}, INF = 1000000000;\nint n, m, sx, sy, ex, ey, k, qhead, qtail, q[ST * N * N * 2][4], dis[N][N][2][ST];\nchar map[N][N], col[10][N][N], pre[ST][N][N];\n\nvoid change (char &grid) {\n\tif (grid == '^') {\n\t\tgrid = '_';\n\t} else if (grid == '_') {\n\t\tgrid = '^';\n\t}\n\tif (grid >= 'a' && grid <= 'j') {\n\t\tgrid = 'A' + grid - 'a';\n\t} else if (grid >= 'A' && grid <= 'J') {\n\t\tgrid = 'a' + grid - 'A';\n\t}\n}\n\nint height (const char &a) {\n\treturn a == '_' || a >= 'a' && a <= 'j' ? 0 : 1;\n}\n\nint shift (const char &a) {\n\tif (a >= 'a' && a <= 'j') return a - 'a';\n\tif (a >= 'A' && a <= 'J') return a - 'A';\n\treturn -1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%s\", map[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (map[i][j] == '%') {\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}\n\t\t\tif (map[i][j] == '&') {\n\t\t\t\tex = i;\n\t\t\t\tey = j;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tscanf(\"%s\", col[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << k; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\tpre[i][r][c] = map[r][c];\n\t\t\t\tif (pre[i][r][c] == '%' || pre[i][r][c] == '&') pre[i][r][c] = '_';\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tfor (int r = 0; r < n; ++r) {\n\t\t\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\t\t\tif (col[j][r][c] == '*') {\n\t\t\t\t\t\t\tchange(pre[i][r][c]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < n; ++x) {\n\t\tfor (int y = 0; y < m; ++y) {\n\t\t\tfor (int z = 0; z < 2; ++z) {\n\t\t\t\tfor (int st = 0; st < 1 << k; ++st) {\n\t\t\t\t\tdis[x][y][z][st] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdis[sx][sy][0][0] = 0;\n\tqhead = 0; qtail = 1; q[1][0] = sx; q[1][1] = sy; q[1][2] = 0; q[1][3] = 0;\n\twhile (qhead < qtail) {\n\t\t++qhead;\n\t\tint nx = q[qhead][0], ny = q[qhead][1], nz = q[qhead][2], nst = q[qhead][3];\n//cout << nx << ' ' << ny << ' ' << nz << ' ' << pre[nst][nx][ny] << ' ' << height(pre[nst][nx][ny]) << ' ' << shift(pre[nst][nx][ny]) << endl;\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint tx = nx + dx[d], ty = ny + dy[d];\n\t\t\tif (tx >= 0 && tx < n && ty >= 0 && ty < m && pre[nst][tx][ty] != '#' && (pre[nst][tx][ty] == '|' || height(pre[nst][tx][ty]) == nz) && dis[tx][ty][nz][nst] == INF) {\n\t\t\t\tdis[tx][ty][nz][nst] = dis[nx][ny][nz][nst] + 1;\n\t\t\t\t++qtail; q[qtail][0] = tx; q[qtail][1] = ty; q[qtail][2] = nz; q[qtail][3] = nst;\n\t\t\t}\n\t\t}\n\t\tif (map[nx][ny] == '|' && dis[nx][ny][nz ^ 1][nst] == INF) {\n\t\t\tdis[nx][ny][nz ^ 1][nst] = dis[nx][ny][nz][nst] + 1;\n\t\t\t++qtail; q[qtail][0] = nx; q[qtail][1] = ny; q[qtail][2] = nz ^ 1; q[qtail][3] = nst;\n\t\t}\n\t\tif (shift(pre[nst][nx][ny]) != -1) {\n\t\t\tint tst = nst ^ (1 << shift(pre[nst][nx][ny])), tz = nz;\n\t\t\tif (pre[tst][nx][ny] != '|') tz = height(pre[tst][nx][ny]);\n\t\t\tif (dis[nx][ny][tz][tst] == INF) {\n\t\t\t\tdis[nx][ny][tz][tst] = dis[nx][ny][nz][nst] + 1;\n\t\t\t\t++qtail; q[qtail][0] = nx; q[qtail][1] = ny; q[qtail][2] = tz; q[qtail][3] = tst;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int z = 0; z < 2; ++z) {\n\t\tfor (int st = 0; st < 1 << k; ++st) {\n\t\t\tans = min(ans, dis[ex][ey][z][st]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<queue>\n#include<vector>\n#include<bitset>\n#include<algorithm>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 51\n#define X first\n#define Y second\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nstruct P\n{\n  int x,y,state,cost;\n  bool floor;\n  P(int x=inf,int y=inf,int state=inf,int cost=inf,bool floor=false):x(x),y(y),state(state),cost(cost),floor(floor){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint W,H,S;\nchar G[MAX][MAX];//åæç¶æã®ã°ãªãã\nvector<int> swt[MAX][MAX];//swt[y][x] := (x,y)ã«å½±é¿ãä¸ããã¹ã¤ãã\nint mincost[2][(1<<10)][MAX][MAX];\nii st;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nbool getFloor(char c)//false -> 1, true -> 2\n{\n  if(c == '_' || c == '&' || c == '%' || (isalpha(c) && islower(c)))return false;\n  if(c == '^' || (isalpha(c) && isupper(c)))return true;\n\n  return true;//stair\n}\n\nvoid compute()\n{\n  priority_queue<P> Q;\n  Q.push(P(st.X,st.Y,0,0,0));//int x | int y | int state | int cost | bool floor\n  mincost[0][0][st.Y][st.X] = 0;\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      int x = p.x, y = p.y, state = p.state, cost = p.cost;\n      bool floor = p.floor;\n\n      bitset<10> sta(state);\n      //cout << \"(\" << x << \",\" << y << \") \" << sta << \" cost = \" << cost << \" floor : \" << (floor?\"2\":\"1\") << endl;\n\n      if(G[y][x] == '&')\n\t{\n\t  cout << p.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = x + dx[i];\n\t  int ny = y + dy[i];\n\t  if(!( 0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(G[ny][nx] == '#')continue;\n\n\t  char nc = G[ny][nx];\n\t  bool nfloor = getFloor(nc);\n\t  int cnt = 0;\n\n\t  rep(j,swt[ny][nx].size())\n\t    if((state>>swt[ny][nx][j]) & 1)cnt++;\n\n\t  if(cnt%2)nfloor = !nfloor;\n\t  \n\t  if(nc == '|')//stair\n\t    {\n\t      //same floor\n\t      if(mincost[floor][state][ny][nx] > cost + 1)\n\t\t{\n\t\t  mincost[floor][state][ny][nx] = cost + 1;\t      \n\t\t  Q.push(P(nx,ny,state,cost+1,floor));\n\t\t}\n\n\t      //move down\n\t      if(mincost[!floor][state][ny][nx] > cost + 2)\n\t\t{\t      \n\t\t  mincost[!floor][state][ny][nx] = cost + 2;\n\t\t  Q.push(P(nx,ny,state,cost+2,!floor));\n\t\t}\n\n\t      continue;\n\t    }\n\n\t  if(floor != nfloor)continue;\n\t  \n\t  if(isalpha(nc))//switch\n\t    {\n\t      \n\t      //dont use\n\t      if(mincost[floor][state][ny][nx] > cost + 1)\n\t\t{\n\t\t  mincost[floor][state][ny][nx] = cost + 1;\n\t\t  Q.push(P(nx,ny,state,cost+1,floor));\n\t\t}\n\t      \n\t      //use that\n\t      nc = tolower(nc);\n\t      int index = nc - 'a';\n\t      int nstate = state ^ (1<<index);\n\t      rep(j,swt[ny][nx].size())\n\t\tif(index == swt[ny][nx][j])\n\t\t  {\n\t\t    nfloor = !nfloor;\n\t\t    break;\n\t\t  }\n\n\t      if(mincost[nfloor][nstate][ny][nx] > cost + 2)\n\t\t{\n\t\t  mincost[nfloor][nstate][ny][nx] = cost + 2;\n\t\t  Q.push(P(nx,ny,nstate,cost+2,nfloor));\n\t\t}\n\n\t      continue;\n\t    }\n\t  \n\t  \t    \n\t  //other\n\t  if(mincost[floor][state][ny][nx] > cost + 1)\n\t    {\n\t      mincost[floor][state][ny][nx] = cost + 1;\n\t      Q.push(P(nx,ny,state,cost+1,floor));\n\t    }\n\t  \n\t}\n\n    }\n\n  cout << -1 << endl;\n\n}\n\nvoid init()\n{\n  rep(i,H)rep(j,W)swt[i][j].clear();\n  rep(l,2)rep(i,(1<<10))rep(j,H)rep(k,W)mincost[l][i][j][k] = inf;\n}\n\nint main()\n{\n\n  while(cin >> W >> H)\n    { \n      init();\n      rep(i,H)rep(j,W)\n\t{\n\t  cin >> G[i][j];\n\t  if(G[i][j] == '%')st = ii(j,i);\n\t}\n\n      cin >> S;\n      rep(s,S)\n\t{\n\t  char c;\n\t  rep(y,H)rep(x,W)\n\t    {\n\t      cin >> c;\n\t      if(c == '*')swt[y][x].push_back(s);\n\t    }\n\t}\n\t\n      compute();\n\n    }\n  return 0;\n}\n\n\n\n\n\n  /*\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(G[p.y][p.x] == '&')\n\t{\n\t  cout << p.cost << endl;\n\t  return;\n\t}\n\n      bool floor = p.floor;\n      int cnt = 0;\n      rep(i,swt[p.y][p.x].size())\n\tif((p.state>>swt[p.y][p.x][i]) & 1)cnt++;\n      if(cnt%2)floor = !floor;\n\t\n      rep(i,4)\n\t{\n\t  int nx = p.x + dx[i];\n\t  int ny = p.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  bool nfloor = getFloor(G[ny][nx]);\n\t  cnt = 0;\n\t  rep(j,swt[ny][nx].size())\n\t    if((p.state>>swt[ny][nx][j]) & 1)cnt++;\n\t  if(cnt%2)nfloor = !nfloor;\n\n\t  if(isalpha(G[ny][nx]))\n\t    {\n\t      if(nfloor != floor)continue;\n\t      if(mincost[p.state][ny][nx] > p.cost+1)\n\t\t{\n\t\t  mincost[p.state][ny][nx] = p.cost+1;\n\t\t  Q.push(P(nx,ny,p.state,p.cost+1,nfloor));\n\t\t}\n\t      char c = tolower(G[ny][nx]);\n\t      int nstate = p.state ^ (1<<(c-'a'));\n\t      if(mincost[nstate][ny][nx] > p.cost+2)\n\t\t{\n\t\t  mincost[nstate][ny][nx] = p.cost+2;\n\t\t  Q.push(P(nx,ny,nstate,p.cost+2));\n\t\t}\n\t    }\n\t  else if(G[ny][nx] == '|')\n\t    {\n\t      if(mincost[p.state][ny][nx] > p.cost+1)\n\t\t{\n\t\t  mincost[p.state][ny][nx] = p.cost+1;\n\t\t  Q.push(P(nx,ny,p.state,p.cost+1));\n\t\t}\n\n\n\t    }\n\t  else\n\t    {\n\t      if(nfloor != floor)continue;\n\n\t    }\n\t}\n    }\n  */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\nstring sw[11][N];\nint w,h,s;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n \nbool check(int x,int y,int f,int bit){\n  if(mp[y][x]=='#')return 0;\n \n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n \n  char ch = mp[y][x];\n  if((cnt+f)%2==0)\n    if(isupper(ch)||ch=='^')return 0;\n  \n  if((cnt+f)%2==1)\n    if(islower(ch)||ch=='_'||ch=='&'||ch=='%')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n \nint used[N][N][2][1<<10],mem[N][N][2][1<<10];\nint dfs(int x,int y,int f,int bit){\n  if(mp[y][x] == '&'&&f==0)return 0;\n  if(used[x][y][f][bit]++)return mem[x][y][f][bit];\n\n  int res=mem[x][y][f][bit]=1e6;\n  \n  return mem[x][y][f][bit]=res;\n}\n\nstruct dat{int x,y,f,bit,cost;};\n\nint bfs(int sx,int sy){\n  queue<dat> Q;\n  Q.push((dat){sx,sy,0,0,0});\n  int *res=NULL;\n\n  while(!Q.empty()){\n    dat t=Q.front();Q.pop();\n    int x=t.x,y=t.y,f=t.f,bit=t.bit,cost=t.cost;\n    if(used[x][y][f][bit]&&mem[x][y][f][bit]<=cost) continue;\n    if(!used[x][y][f][bit]++) mem[x][y][f][bit]=cost;\n    mem[x][y][f][bit]=min(mem[x][y][f][bit],cost);\n    if(mp[y][x]=='&')res=&mem[x][y][f][bit];\n\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(!check(nx,ny,f,bit))continue;\n      int th=mp[ny][nx]-(isupper(mp[ny][nx])? 'A':'a');\n      if(mp[ny][nx]=='|')Q.push((dat){nx,ny,!f,bit,cost+2});\n      if(isalpha(mp[ny][nx]))Q.push((dat){nx,ny,(sw[th][ny][nx]=='*')?!f:f,nbit(bit,th),cost+2});\n      Q.push((dat){nx,ny,f,bit,cost+1});\n    }\n  }\n  if(res==NULL) return -1;\n  return *res;\n}\n  \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n \n  int ans=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')ans=bfs(j,i);\n  \n  if(ans>=1e6)cout<<-1<<endl;\n  else cout<<ans<<endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\nstring sw[11][N];\nint w,h,s;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n \nbool check(int x,int y,int f,int bit){\n  if(mp[y][x]=='#')return 0;\n \n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n \n  char ch = mp[y][x];\n  if((cnt+f)%2==0)\n    if(isupper(ch)||ch=='^')return 0;\n  \n  if((cnt+f)%2==1)\n    if(islower(ch)||ch=='_'||ch=='&'||ch=='%')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n \nint used[N][N][2][1<<10],mem[N][N][2][1<<10];\nint dfs(int x,int y,int f,int bit){\n  if(mp[y][x] == '&'&&f==0)return 0;\n  if(used[x][y][f][bit]++)return mem[x][y][f][bit];\n\n  int res=mem[x][y][f][bit]=1e6;\n  \n  return mem[x][y][f][bit]=res;\n}\n\nstruct dat{int x,y,f,bit,cost;};\n\nint bfs(int sx,int sy){\n  queue<dat> Q;\n  Q.push((dat){sx,sy,0,0,0});\n  int *res=NULL;\n\n  while(!Q.empty()){\n    dat t=Q.front();Q.pop();\n    int x=t.x,y=t.y,f=t.f,bit=t.bit,cost=t.cost;\n    if(used[x][y][f][bit]&&mem[x][y][f][bit]<=cost) continue;\n    if(!used[x][y][f][bit]++) mem[x][y][f][bit]=cost;\n    mem[x][y][f][bit]=min(mem[x][y][f][bit],cost);\n    \n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(!check(nx,ny,f,bit))continue;\n      int th=mp[ny][nx]-(isupper(mp[ny][nx])? 'A':'a');\n      if(mp[ny][nx]=='|')Q.push((dat){nx,ny,!f,bit,cost+2});\n      if(isalpha(mp[ny][nx]))Q.push((dat){nx,ny,(sw[th][ny][nx]=='*')?!f:f,nbit(bit,th),cost+2});\n      Q.push((dat){nx,ny,f,bit,cost+1});\n    }\n  }\n  if(res==NULL) return -1;\n  return *res;\n}\n  \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n \n  int ans=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')ans=bfs(j,i);\n  \n  if(ans>=1e6)cout<<-1<<endl;\n  else cout<<ans<<endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int z, y, x, s;\n    Data(int z0, int y0, int x0, int s0){\n        z = z0;\n        y = y0;\n        x = x0;\n        s = s0;\n    }\n    int toInt(){\n        return ((z * 50 + y) * 50 + x) * 1024 + s;\n    }\n};\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint main()\n{\n    int h, w;\n    cin >> w >> h;\n\n    vector<string> m(h, string(w, ' '));\n    int sy, sx;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            cin >> m[i][j];\n            if(m[i][j] == '%'){\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n\n    int sn;\n    cin >> sn;\n    vector<vector<string> > ms(10, vector<string>(h, string(w, ' ')));\n    for(int i=0; i<sn; ++i){\n        for(int j=0; j<h; ++j){\n            cin >> ms[i][j];\n        }\n    }\n\n    vector<bool> dp(2*50*50*1024, false);\n    dp[Data(0, sy, sx, 0).toInt()] = true;\n    queue<Data> q;\n    q.push(Data(0, sy, sx, 0));\n\n    int ret = 0;\n    while(!q.empty()){\n        int n = q.size();\n        while(--n >= 0){\n            int z = q.front().z;\n            int y = q.front().y;\n            int x = q.front().x;\n            int s = q.front().s;\n            q.pop();\n\n            if(m[y][x] == '&'){\n                cout << ret << endl;\n                return 0;\n            }if(m[y][x] == '|'){\n                Data d(z^1, y, x, s);\n                if(!dp[d.toInt()]){\n                    dp[d.toInt()] = true;\n                    q.push(d);\n                }\n            }else if(isalpha(m[y][x])){\n                int s2 = s;\n                s2 ^= 1 << (tolower(m[y][x]) - 'a');\n                int z2 = z;\n                if(ms[tolower(m[y][x]) - 'a'][y][x] == '*')\n                    z2 ^= 1;\n                Data d(z2, y, x, s2);\n                if(!dp[d.toInt()]){\n                    dp[d.toInt()] = true;\n                    q.push(d);\n                }\n            }\n\n            for(int i=0; i<4; ++i){\n                int y2 = y + dy[i];\n                int x2 = x + dx[i];\n                if(m[y2][x2] == '#')\n                    continue;\n\n                int z2 = z;\n                if(m[y2][x2] != '|'){\n                    z2 = 0;\n                    if(m[y2][x2] == '^' || isupper(m[y2][x2]))\n                        z2 = 1;\n\n                    bitset<10> bs(s);\n                    for(int j=0; j<10; ++j){\n                        if(bs[j] && ms[j][y2][x2] == '*')\n                            z2 ^= 1;\n                    }\n\n                    if(z != z2)\n                        continue;\n                }\n\n                Data d(z2, y2, x2, s);\n                if(!dp[d.toInt()]){\n                    dp[d.toInt()] = true;\n                    q.push(d);\n                }\n            }\n        }\n        ++ ret;\n    }\n\n    cout << -1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint w, h, s;\nint st, go;\nchar m[50][50], tmp[50][50];\nchar ms[10][50][50];\nint dp[(1<<10)*2*50*50+2*50*50+50*50+50];\n//vector<int> e[(1<<10)*2*50*50+2*50*50+50*50+50];\nmap<int,vector<int> > e;\n\nint main(){\n\trep(i,(1<<10)*2*50*50+2*50*50+50*50+50) dp[i] = INF;\n\tcin >> w >> h;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == '%'){\n\t\t\tst = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t\tif(m[i][j] == '&'){\n\t\t\tgo = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t}\n\tcin >> s;\n\trep(i,s) rep(j,h) rep(k,w) cin >> ms[i][j][k];\n\trep(i,(1<<s)){\n\t\trep(j,h) rep(k,w) tmp[j][k] = m[j][k];\n\t\tint I = i;\n\t\trep(j,s){\n\t\t\tif(I&1){\n\t\t\t\trep(k,h) rep(l,w){\n\t\t\t\t\tif(ms[j][k][l] == '*'){\n\t\t\t\t\t\tif(tmp[k][l] == '_') tmp[k][l] = '^';\n\t\t\t\t\t\telse if(tmp[k][l] == '^') tmp[k][l] = '_';\n\t\t\t\t\t\telse if('a' <= tmp[k][l] && tmp[k][l] <= 'z'){\n\t\t\t\t\t\t\ttmp[k][l] = toupper(tmp[k][l]);\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\ttmp[k][l] = tolower(tmp[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tI >>= 1;\n\t\t}\n\t\trep(j,h) rep(k,w){\n\t\t\tif(tmp[j][k] == '#') continue;\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '_' || ('a' <= tmp[j][k]&&tmp[j][k] <= 'z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '_' || ('a' <= tmp[J][K]&&tmp[J][K] <= 'z')){\n\t\t\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '^' || ('A' <= tmp[j][k]&&tmp[j][k] <= 'Z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '^' || ('A' <= tmp[J][K]&&tmp[J][K] <= 'Z')){\n\t\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|'){\n\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*50+50*j+k);\n\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*j+k);\n\t\t\t}\n\t\t\tif('a' <= tmp[j][k] && tmp[j][k] <= 'z'){\n\t\t\t\tint z = tmp[j][k]-'a';\n\t\t\t\tint flo = 0;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 1;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif('A' <= tmp[j][k] && tmp[j][k] <= 'Z'){\n\t\t\t\tint z = tmp[j][k] - 'A';\n\t\t\t\tint flo = 1;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 0;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> que;\n\tque.push(st);\n\tdp[st] = 0;\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q].size()){\n\t\t\tif(dp[e[q][i]] != INF) continue;\n\t\t\tdp[e[q][i]] = dp[q]+1;\n\t\t\tque.push(e[q][i]);\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,(1<<10)*2*50*50+2*50*50+50*50+50){\n\t\tif(i%(50*50) != go) continue;\n\t\tans = min(ans,dp[i]);\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e8;\nusing vi = vector<int>;\n\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<string> v(H);\n    int sy, sx, gy, gx;\n    for(int i=0; i<H; ++i) {\n        cin >> v[i];\n        for(int j=0; j<W; ++j) {\n            if(v[i][j] == '%') {\n                sy = i;\n                sx = j;\n            }\n            if(v[i][j] == '&') {\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    int S;\n    cin >> S;\n    vector<vector<string>> sw(S, vector<string>(H));\n    for(int i=0; i<S; ++i) {\n        for(int j=0; j<H; ++j) {\n            cin >> sw[i][j];\n        }\n    }\n    vector<vector<vi>> state(1 << S, vector<vi>(H, vi(W)));\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if(v[i][j] == '^' || 'A' <= v[i][j] && v[i][j] <= 'Z') {\n                state[0][i][j] = 1;\n            }\n        }\n    }\n    for(int b=1; b<1<<S; ++b) {\n        state[b] = state[0];\n        for(int h=0; h<H; ++h) {\n            for(int w=0; w<W; ++w) {\n                for(int i=0; i<S; ++i) {\n                    if((b >> i) & 1) {\n                        if(sw[i][h][w] == '*') {\n                            state[b][h][w] ^= 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    vector<vector<vector<vi>>> d(1 << S, vector<vector<vi>>(2, vector<vi>(H, vi(W, INF))));\n    d[0][0][sy][sx] = 0;\n    queue<tuple<int, int, int, int>> que;\n    que.push(make_tuple(0, 0, sy, sx));\n    int res = INF;\n    while(!que.empty()) {\n        int b, flr, y, x;\n        tie(b, flr, y, x) = que.front();\n        //cout << \"b: \" << b << \" flr: \" << flr+1 << \"  y: \" << y << \"  x: \" << x << \"  d: \" << d[b][flr][y][x] << endl;\n        if(y == gy && x == gx) {\n            res = d[b][flr][y][x];\n            break;\n        }\n        que.pop();\n        if(v[y][x] == '|') {\n            if(d[b][flr^1][y][x] == INF) {\n                d[b][flr^1][y][x] = d[b][flr][y][x] + 1;\n                que.push(make_tuple(b, flr^1, y, x));\n            }\n        }\n        if(isalpha(v[y][x])) {\n            int k = ('A' <= v[y][x] && v[y][x] <= 'Z' ? v[y][x] - 'A' : v[y][x] - 'a');\n            int nb = b ^ (1 << k);\n            int nf = state[nb][y][x];\n            if(d[nb][nf][y][x] == INF) {\n                d[nb][nf][y][x] = d[b][flr][y][x] + 1;\n                que.push(make_tuple(nb, nf, y, x));\n            }\n        }\n        for(int i=0; i<4; ++i) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx || v[ny][nx] == '#' || v[ny][nx] != '|' && flr != state[b][ny][nx]) {\n                continue;\n            }\n            if(d[b][flr][ny][nx] == INF) {\n                d[b][flr][ny][nx] = d[b][flr][y][x] + 1;\n                que.push(make_tuple(b, flr, ny, nx));\n            }\n        }\n    }\n    cout << (res == INF ? -1 : res) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n \nchar field[50][50];\nint s[50][50];\nbool diff[10][50][50];\nbool used[50][50][2][2048];\n \nstruct state{\n    int y,x,f,sw;\n    int step;\n    state(int y, int x, int f, int sw, int step)\n        :y(y),x(x),f(f),sw(sw),step(step){}\n    state(){}\n};\n \nint main(){\n    memset(s, -1, sizeof(s));\n    memset(diff, 0, sizeof(diff));\n    memset(used, 0, sizeof(used));\n    int w,h;\n    cin >> w >> h;\n    int sy,sx,gy,gx;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            cin >> field[i][j];\n            if('a'<=field[i][j] && field[i][j]<='z'){\n                s[i][j] = field[i][j] -'a';\n                field[i][j] = '_';\n            }\n            if('A'<=field[i][j] && field[i][j]<='Z'){\n                s[i][j] = field[i][j] -'A';\n                field[i][j] = '^';\n            }\n            if(field[i][j] == '%'){\n                sy = i;\n                sx = j;\n                field[i][j] = '_';\n            }\n            if(field[i][j] == '&'){\n                gy = i;\n                gx = j;\n                field[i][j] = '_';\n            }\n        }\n    }\n \n    int m;\n    cin >> m;\n    for(int r=0; r<m; r++){\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                char c;\n                cin >> c;\n                if(c == '*') diff[r][i][j] = true;\n            }\n        }\n    }\n \n    queue<state> wait;\n    wait.push(state(sy,sx,0,0,0));\n    used[sy][sx][0][0] = true;\n    int ans = -1;\n    while(!wait.empty()){\n        state curr = wait.front();\n        int y = curr.y;\n        int x = curr.x;\n        int f = curr.f;\n        int sw = curr.sw;\n        int step = curr.step;\n        wait.pop();\n        if(y == gy && x == gx){\n            ans = step;\n            break;\n        }\n        if(field[y][x] == '|'){\n            if(!used[y][x][1-f][sw]){\n                used[y][x][1-f][sw] = true;\n                wait.push(state(y, x, 1-f, sw, step+1));\n            }\n        }\n        if(s[y][x] != -1){\n            int nsw = sw ^ (1<<s[y][x]);\n            int nf = f ^ diff[s[y][x]][y][x];\n            if(!used[y][x][nf][nsw]){\n                used[y][x][nf][nsw] = true;\n                wait.push(state(y, x, nf, nsw, step+1));\n            }\n        }\n        for(int i=0; i<4; i++){\n            int ny = y +dy[i];\n            int nx = x +dx[i];\n            if(field[ny][nx] == '#') continue;\n            if(field[ny][nx] == '|'){\n                if(!used[ny][nx][f][sw]){\n                    used[ny][nx][f][sw] = true;\n                    wait.push(state(ny, nx, f, sw, step+1));\n                }\n                continue;\n            }\n            int nf = (field[ny][nx] == '_')? 0: 1;\n            for(int j=0; j<m; j++){\n                if((sw & 1<<j) != 0){\n                    nf ^= diff[j][ny][nx];\n                }\n            }\n            if(f != nf) continue;\n            if(!used[ny][nx][nf][sw]){\n                used[ny][nx][nf][sw] = true;\n                wait.push(state(ny, nx, nf, sw, step+1));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nstruct State {\n    int row, col, mask, floor, cost;\n    State(int row, int col, int mask, int floor, int cost) :\n        row(row), col(col), mask(mask), floor(floor), cost(cost) {}\n};\n\nconst int MAX_W = 51;\nconst int MAX_H = 51;\nconst int MAX_S = 11;\n\nbool valid[MAX_H][MAX_W][1 << MAX_S][2];\nint cost[MAX_H][MAX_W][1 << MAX_S][2];\n\nstring m[MAX_H], ms[MAX_S][MAX_H];\n\nint w, h, s;\n\nint dr[4] = {1, 0, -1, 0},\n    dc[4] = {0, 1, 0, -1};\n\nvoid push_with_test(queue<State>& que, int nr, int nc, int nm, int nf, int ncost) {\n    int& ref_cost = cost[nr][nc][nm][nf];\n    if (valid[nr][nc][nm][nf] && ref_cost == -1) {\n        ref_cost = ncost;\n        que.push(State(nr, nc, nm, nf, ref_cost));\n    }\n}\n\nint bfs(int sr, int sc) {\n    queue<State> que;\n    memset(cost, -1, sizeof(cost));\n\n    cost[sr][sc][0][0] = 0;\n    que.push(State(sr, sc, 0, 0, cost[sr][sc][0][0]));\n\n    while (!que.empty()) {\n        State st = que.front(); que.pop();\n\n        if (m[st.row][st.col] == '&') {\n            return st.cost;\n        }\n\n        // ??Â£??\\????????????????Â§????\n        for (int i = 0; i < 4; i++) {\n            int nr = st.row + dr[i],\n                nc = st.col + dc[i],\n                nm = st.mask,\n                nf = st.floor;\n            push_with_test(que, nr, nc, nm, nf, st.cost + 1);\n        }\n\n        // ?????????????????????????????????????????Â´??????\n        if (m[st.row][st.col] == '|') {\n            int nr = st.row,\n                nc = st.col,\n                nm = st.mask,\n                nf = (st.floor + 1) % 2;\n            push_with_test(que, nr, nc, nm, nf, st.cost + 1);\n        }\n\n        // ?????????????????????????????????????????????????????????\n        if (isalpha(m[st.row][st.col])) {\n            char alpha = m[st.row][st.col];\n            int alpha_i = isupper(alpha) ? (alpha - 'A') : (alpha - 'a'),\n                nr = st.row,\n                nc = st.col,\n                nm = st.mask ^ (1 << alpha_i),\n                nf = ms[alpha_i][st.row][st.col] == '*' ? (st.floor + 1) % 2 :\n                                                                    st.floor;\n            push_with_test(que, nr, nc, nm, nf, st.cost + 1);\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    cin >> w >> h;\n    \n    int sr, sc;\n    for (int r = 0; r < h; r++) {\n        cin >> m[r];\n        for (int c = 0; c < w; c++) {\n            if (m[r][c] == '%') {\n                sr = r;\n                sc = c;\n                break;\n            }\n        }\n    }\n\n    cin >> s;\n    for (int s_i = 0; s_i < s; s_i++) {\n        for (int r = 0; r < h; r++) {\n            cin >> ms[s_i][r];\n        }\n    }\n\n    // valid????????????\n    for (int r = 0; r < h; r++) {\n        for (int c = 0; c < w; c++) {\n            for (int mask = 0; mask < (1 << s); mask++) {\n                if (m[r][c] == '#') {\n                    continue;\n                } else if (m[r][c] == '|') {\n                    valid[r][c][mask][0] = valid[r][c][mask][1] = true;\n                    continue;\n                }\n\n                int init_floor = (isupper(m[r][c]) || m[r][c] == '^') ? 1 : 0,\n                    move = 0;\n                for (int s_i = 0; s_i < s; s_i++) {\n                    if (((mask >> s_i) & 1) && ms[s_i][r][c] == '*') {\n                        move++;\n                    }\n                }\n                valid[r][c][mask][(init_floor + move) % 2] = true;\n            }\n        }\n    }\n\n    cout << bfs(sr, sc) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint x,y,c,f,sw;\n\tState(int x, int y, int c, int f, int sw)\n\t\t:x(x),y(y),c(c),f(f), sw(sw)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nint W, H, S;\nint dx[] = { -1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\nbool vis[55][55][2][1<<10];\n\nstring field[50];\nstring switches[50][10];\n\nint toInt(char c)\n{\n\tc = tolower(c);\n\n\treturn c - 'a';\n}\n\nint calcInit(char c)\n{\n\tif(isupper(c)) return 1;\n\tif(c == '^') return 1;\n\n\treturn 0;\n}\n\nint calcFloor(int x, int y, int sw, char c)\n{\n\tint res = calcInit(c);\n\tfor(int i=0; i<S; i++) {\n\t\tif(switches[y][i][x] != '*') continue;\n\t\tif((sw >> i) & 1) res =  ( res + 1 ) % 2;\n\t}\n\n\treturn res;\n}\n\nvoid qpush(int x, int y, int c, int f, int sw, queue<State>& q)\n{\n\tif(vis[x][y][f][sw]) return;\n\tvis[x][y][f][sw] = 1;\n\n\tq.push(State(x,y,c,f,sw));\n}\n\nint main()\n{\n\tcin >> W >> H;\n\n\n\n\tfor(int i=0; i<H; i++) \n\t\tcin >> field[i];\n\n\n\tcin >> S;\n\tfor(int k=0; k<S; k++)\n\tfor(int i=0; i<H; i++)\n\t\tcin >> switches[i][k];\n\n\tmemset(vis, 0, sizeof(vis));\n\n\tint sx,sy;\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t\tif(field[i][j] == '%') { sx = j; sy = i; }\n\n\tqueue<State> q;\n\tqpush(sx, sy, 0, 0, 0, q);\n\n\tint res = -1;\n\twhile(!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\n\t\tif(field[s.y][s.x] == '&') {\n\t\t\tres = s.c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(field[s.y][s.x] == '|') {\n\t\t\t\tfor(int i=0; i<2; i++) {\n\t\t\t\t\tqpush(s.x,s.y,s.c+1,i,s.sw,q);\n\t\t\t\t}\n\t\t}\n\n\t\tif(isalpha(field[s.y][s.x])) {\n\t\t\tint tsw = s.sw ^ (1<<(toInt(field[s.y][s.x])));\n\t\t\tint tf = calcFloor(s.x,s.y,tsw,field[s.y][s.x]);\n\t\t\tqpush(s.x,s.y,s.c+1,tf,tsw,q);\n\t\t}\n\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint tx = s.x + dx[i];\n\t\t\tint ty = s.y + dy[i];\n\t\t\tint tc = s.c + 1;\n\t\t\tint tf = s.f;\n\n\t\t\tif(field[ty][tx] == '#') continue;\n\t\t\tif(field[ty][tx] != '|') {\n\t\t\t\tif(tf != calcFloor(tx, ty, s.sw, field[ty][tx])) continue;\n\t\t\t}\n\n\t\t\tqpush(tx,ty,tc,tf,s.sw, q);\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint data[2][51][51],sy,sx,gy,gx;\nint sw[51][51],h,w,num;\nstring s[51],t;\nint dy[]={0,0,-1,1};\nint dx[]={-1,1,0,0};\nbool used[51][51][1<<10][2];\nstruct dat{\n    int y,x,sw,flo,cost;\n    dat(int a,int b,int c,int d,int e){\n        y=a;x=b;sw=c;flo=d;cost=e;\n    }\n};\nsigned main(){\n    memset(data,-1,sizeof(data));\n    cin>>w>>h;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n        if(s[i][j]=='%')data[0][i][j]=100,sy=i,sx=j;\n        if(s[i][j]=='&')data[0][i][j]=100,gy=i,gx=j;\n        if(s[i][j]=='_')data[0][i][j]=100;\n        if(s[i][j]=='^')data[1][i][j]=100;\n        if(s[i][j]=='|')data[0][i][j]=data[1][i][j]=101;\n        if(isalpha(s[i][j])){\n            if(islower(s[i][j]))data[0][i][j]=(s[i][j]-'a');\n            if(isupper(s[i][j]))data[1][i][j]=(s[i][j]-'A');\n        }\n    }\n    cin>>num;\n    r(i,num)r(j,h){\n        cin>>t;\n        r(k,w)if(t[k]=='*')sw[j][k]|=(1<<i);\n    }\n    queue<dat>q;\n    q.push(dat(sy,sx,0,0,0));\n    used[sy][sx][0][0]=1;\n    while(!q.empty()){\n        dat a=q.front();q.pop();\n        if(a.y==gy&&a.x==gx&&a.flo==0){\n            cout<<a.cost<<endl;\n            return 0;\n        }\n        int y=a.y;\n        int x=a.x;\n\n        // éæ®µ\n        if(data[a.flo][y][x]==101){\n            if(!used[y][x][a.sw][a.flo^1]){\n                used[y][x][a.sw][a.flo^1]=1;\n                q.push(dat(y,x,a.sw,a.flo^1,a.cost+1));\n            }\n        }\n\n        // ç§»å\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            int A=a.sw;\n            int B=sw[ny][nx];\n            int C=A&B;\n            int D=__builtin_popcount(C)+a.flo;D%=2;\n            if(data[D][ny][nx]!=-1){\n                //cout<<ny<<' '<<nx<<endl;\n                if(!used[ny][nx][a.sw][a.flo]){\n                    used[ny][nx][a.sw][a.flo]=1;\n                    q.push(dat(ny,nx,a.sw,a.flo,a.cost+1));\n                }\n            }\n        }\n\n        // ã¹ã¤ãã\n        if(isalpha(s[y][x])){\n            int A=a.sw;\n            int B=sw[y][x];\n            int C=A&B;\n            int D=__builtin_popcount(C)+a.flo;D%=2;\n            int E=data[D][y][x];\n            int F=0;\n            if(islower(s[y][x]))F|=(1<<(s[y][x]-'a'));\n            if(isupper(s[y][x]))F|=(1<<(s[y][x]-'A'));\n            if(F&B){\n                if(!used[y][x][a.sw^F][a.flo^1]){\n                    used[y][x][a.sw^F][a.flo^1]=1;\n                    q.push(dat(y,x,a.sw^F,a.flo^1,a.cost+1));\n                }\n            }\n            else{\n                if(!used[y][x][a.sw^F][a.flo]){\n                    used[y][x][a.sw^F][a.flo]=1;\n                    q.push(dat(y,x,a.sw^F,a.flo,a.cost+1));\n                }\n            }\n        }\n    }\n    cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10;\nconst int MAXH = 51;\nconst int MAXW = 51;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint H, W, si, sj, gi, gj;\nchar G[MAXH][MAXW];\nint S;\nint T[MAXN][MAXH][MAXW];\nint F[1<<MAXN][MAXH][MAXW];\nint cost[1<<MAXN][2][MAXH][MAXW];\n\nstruct State {\n  int s, f, i, j;\n};\n\nint bfs() {\n  queue<State> que;\n  memset(cost, -1, sizeof(cost));\n  State src = {0, 0, si, sj};\n  que.push(src);\n  cost[src.s][src.f][src.i][src.j] = 0;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(s.i == gi && s.j == gj) return cost[s.s][s.f][s.i][s.j];\n    for(int k = 0; k < 4; ++k) {\n      const State t = {s.s, s.f, s.i + di[k], s.j + dj[k]};\n      if(t.i < 0 || t.i >= H) continue;\n      if(t.j < 0 || t.j >= W) continue;\n      if(G[t.i][t.j] == '#') continue;\n      if(G[t.i][t.j] != '|' && F[t.s][t.i][t.j] != t.f) continue;\n      if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n      que.push(t);\n      cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n    }\n\n    if(isalpha(G[s.i][s.j]))\n      do {\n        int id = toupper(G[s.i][s.j]) - 'A';\n        int ns = s.s ^ (1 << id);\n        const State t = {ns, F[ns][s.i][s.j], s.i, s.j};\n        if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n        que.push(t);\n        cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n      } while(0);\n\n    if(G[s.i][s.j] == '|')\n      do {\n        const State t = {s.s, s.f ^ 1, s.i, s.j};\n        if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n        que.push(t);\n        cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n      } while(0);\n  }\n  return -1;\n}\n\nbool getFloor(char c) {\n  if(isalpha(c)) return isupper(c);\n  if(c == '_') return 0;\n  if(c == '^') return 1;\n  return 0;\n}\n\nint main() {\n  while(cin >> W >> H) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == '%') {\n          G[i][j] = '_';\n          si = i;\n          sj = j;\n        }\n        if(G[i][j] == '&') {\n          G[i][j] = '_';\n          gi = i;\n          gj = j;\n        }\n      }\n    }\n    cin >> S;\n    for(int k = 0; k < S; ++k) {\n      for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n          char c; cin >> c;\n          T[k][i][j] = (c == '*');\n        }\n      }\n    }\n    for(int b = 0; b < (1<<S); ++b) {\n      for(int i = 0; i < H; ++i){\n        for(int j = 0; j < W; ++j) {\n          F[b][i][j] = getFloor(G[i][j]);\n          for(int k = 0; k < S; ++k){\n            if(b >> k & 1); else continue;\n            F[b][i][j] ^= T[k][i][j];\n          }\n        }\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<queue>\n\nusing namespace std;\n\nstruct State{\n  int y,x,t,b,s;\n};\n\nint main(){\n  int W,H;\n  cin>>W>>H;\n  char M[50][51];\n  int sy,sx;\n  for(int i=0;i<H;i++){\n    cin>>M[i];\n    for(int j=0;j<W;j++){\n      if(M[i][j]=='%'){\n\tsy=i;\n\tsx=j;\n      }\n    }\n  }\n  int S;\n  cin>>S;\n  char MS[10][50][51];\n  for(int i=0;i<S;i++){\n    for(int j=0;j<H;j++){\n      cin>>MS[i][j];\n    }\n  }\n  queue<State> que;\n  que.push({sy,sx,0,0,0});\n  static bool p[50][50][1<<10][2];\n  while(!que.empty()){\n    State cs=que.front();\n    if(M[cs.y][cs.x]=='&')break;\n    que.pop();\n    if(p[cs.y][cs.x][cs.b][cs.s]++)continue;\n    for(int i=0;i<4;i++){\n      static int d[]={0,-1,0,1,0};\n      int ny=cs.y+d[i];\n      int nx=cs.x+d[i+1];\n      if(M[ny][nx]=='#')continue;\n      int is=isupper(M[ny][nx])||M[ny][nx]=='^';\n      for(int j=0;j<S;j++){\n\tis^=cs.b>>j&1&&MS[j][ny][nx]=='*';\n      }\n      if(is==cs.s||M[ny][nx]=='|'){\n\tque.push({ny,nx,cs.t+1,cs.b,cs.s});\n      }\n    }\n    if(M[cs.y][cs.x]=='|'){\n      que.push({cs.y,cs.x,cs.t+1,cs.b,cs.s^1});\n    }\n    if(isalpha(M[cs.y][cs.x])){\n      int nb=M[cs.y][cs.x]-(isupper(M[cs.y][cs.x])?'A':'a');\n      que.push({cs.y,cs.x,cs.t+1,cs.b^1<<nb,cs.s^MS[nb][cs.y][cs.x]=='*'});\n    }\n  }\n  cout<<(que.empty()?-1:que.front().t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint W,H;\nchar stage[51][51];\nchar switches[11][51][51];\nint dp[1<<10][51][51][2];\nint total_switches;\n\nbool check_floor(int S,int dx,int dy,int current){\n  if(stage[dy][dx] == '|') return true;\n\n  int floor = 0;\n  if('a' <= stage[dy][dx] && stage[dy][dx] <= 'z'\n     || stage[dy][dx] == '_'\n     || stage[dy][dx] == '&'\n     || stage[dy][dx] == '%'){\n    floor = 0;\n  }\n  else if('A' <= stage[dy][dx] && stage[dy][dx] <= 'Z'\n     || stage[dy][dx] == '^'){\n    floor = 1;\n  }\n\n  for(int switch_i = 0; switch_i < total_switches; switch_i++){\n    if((S & (1<<switch_i)) && switches[switch_i][dy][dx] == '*'){\n      floor++;\n      floor %= 2;\n    }\n  }\n  return (current == floor);\n}\n\nint alpha2idx(char alpha){\n  if('A' <= alpha && alpha <= 'Z'){\n    return alpha - 'A';\n  }\n  return alpha - 'a';\n}\n\nint dfs(int S,int sx,int sy,int floor,int cost){\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(stage[dy][dx] == '#') continue;\n    if(!check_floor(S,dx,dy,floor)) continue;\n\n    if(dp[S][dx][dy][floor] > cost + 1){\n      dp[S][dx][dy][floor] = cost + 1;\n      dfs(S,dx,dy,floor,cost + 1);\n    }\n\n    if(isalpha(stage[dy][dx])){\n      //use switch\n      int switch_i = alpha2idx(stage[dy][dx]);\n      int next_S = S ^ (1<<switch_i);\n      int next_floor = floor;\n\n      if(switches[switch_i][dy][dx] == '*'){\n        next_floor++;\n        next_floor %= 2;\n      }\n\n      if(dp[next_S][dx][dy][next_floor] > cost + 2){\n        dp[next_S][dx][dy][next_floor] = cost + 2;\n        dfs(next_S,dx,dy,next_floor,cost + 2);\n      }\n\n      //don't use switch\n      if(dp[S][dx][dy][floor] > cost + 1){\n              dp[S][dx][dy][floor] = cost + 1;\n              dfs(S,dx,dy,floor,cost + 1);\n      }\n    }\n    else{\n      int next_floor = floor;\n\n      if(stage[dy][dx] == '|'){\n        next_floor++;\n        next_floor %= 2;\n        if(dp[S][dx][dy][next_floor] > cost + 2){\n          dp[S][dx][dy][next_floor] = cost + 2;\n          dfs(S,dx,dy,next_floor,cost + 2);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&W,&H)){\n    memset(dp,0x3f,sizeof(dp));\n    int sx,sy;\n    int gx,gy;\n    for(int y = 0; y < H; y++){\n      char line[64];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(stage[y][x] == '%'){\n          sx = x;\n          sy = y;\n        }\n        if(stage[y][x] == '&'){\n          gx = x;\n          gy = y;\n        }\n      }\n    }\n    scanf(\"%d\",&total_switches);\n    for(int switch_i = 0; switch_i < total_switches; switch_i++){\n      for(int y = 0; y < H; y++){\n        char line[64];\n        scanf(\"%s\",line);\n        for(int x = 0; x < W; x++){\n          switches[switch_i][y][x] = line[x];\n        }\n      }\n    }\n    dfs(0,sx,sy,0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_switches); S++){\n      for(int floor = 0; floor < 2; floor++){\n        res = min(dp[S][gx][gy][floor],res);\n      }\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n \n \ntemplate <class W, class WW>\nvoid push(W& dis, WW& q, int T, int f, int x, int y, int d)\n{\n    if (d < dis[T][f][y][x])\n    {\n        dis[T][f][y][x] = d;\n        q.push(make_pair(make_pair(T, f), make_pair(x, y)));\n    }\n}\nint main()\n{\n    int w, h, s;\n    char m[52][52];\n    char ms[10][52][52];\n\n    cin >> w >> h;\n    for (int i = 0; i < h; ++i)\n        cin >> m[i];\n    cin >> s;\n    for (int i = 0; i < s; ++i)\n        for (int j = 0; j < h; ++j)\n            cin >> ms[i][j];\n\n\n    int sx, sy;\n    static char c[1 << 10][2][52][52];\n    CL(c, '#');\n    for (int T = 0; T < 1 << s; ++T)\n    {\n        for (int y = 0; y < h; ++y)\n        {\n            for (int x = 0; x < w; ++x)\n            {\n                char p, q;\n                p = q = '#';\n                if (isalpha(m[y][x]))\n                {\n                    if (islower((m[y][x])))\n                        p = m[y][x];\n                    else\n                        q = tolower(m[y][x]);\n                }\n                else  if (m[y][x] == '%')\n                {\n                    p = '.';\n                    sx = x, sy = y;\n                }\n                else if (m[y][x] == '&')\n                    p = '&';\n                else if (m[y][x] == '_')\n                    p = '.';\n                else if (m[y][x] == '^')\n                    q = '.';\n                else\n                    p = q = m[y][x];\n\n                for (int i = 0; i < s; ++i)\n                    if (T >> i & 1)\n                        if (ms[i][y][x] == '*')\n                            swap(p, q);\n\n                c[T][0][y][x] = p;\n                c[T][1][y][x] = q;\n            }\n        }\n    }\n\n    const int INF = 1 << 29;\n    static int dis[1 << 10][2][52][52];\n    for (int T = 0; T < 1 << s; ++T)\n        for (int f = 0; f < 2; ++f)\n            for (int y = 0; y < h; ++y)\n                for (int x = 0; x < w; ++x)\n                    dis[T][f][y][x] = INF;\n\n    int res = INF;\n\n    typedef pair<pint, pint> P;\n    queue<P> q;\n    dis[0][0][sy][sx] = 0;\n    q.push(P(pint(0, 0), pint(sx, sy)));\n    while (!q.empty())\n    {\n        P aa = q.front();\n        q.pop();\n\n        int T = aa.first.first, f = aa.first.second;\n        int x = aa.second.first, y = aa.second.second;\n\n\n        if (c[T][f][y][x] == '&')\n        {\n            res = dis[T][f][y][x];\n            break;\n        }\n\n        int nd = dis[T][f][y][x] + 1;\n        char w = c[T][f][y][x];\n        if (isalpha(w))\n        {\n            int k = w - 'a';\n            int nT = T ^ (1 << k);\n            int nf = c[nT][f][y][x] == '#' ? (f ^ 1) : f;\n\n            push(dis, q, nT, nf, x, y, nd);\n        }\n        else if (w == '|')\n        {\n            int nf = f ^ 1;\n            push(dis, q, T, nf, x, y, nd);\n        }\n\n        for (int i = 0; i < 4; ++i)\n        {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (c[T][f][ny][nx] != '#')\n                push(dis, q, T, f, nx, ny, nd);\n        }\n    }\n\n    if (res == INF)\n        res = -1;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S (1<<10)\n#define INF (1e9)\n#define N 50\n#define M 10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\ntypedef pair<int,P1> P2;\nint d[S][2][N][N],h,w,m,sy,sx,gy,gx;\nstring s[N],t[M][N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint getFloor(int y,int x,int A){\n  if(s[y][x]=='|')return 3;\n  int cnt=0;\n  for(int i=0;i<m;i++){\n    if(!(A&(1<<i)))continue;\n    if(t[i][y][x]=='*')cnt++;\n  }\n  if('A'<=s[y][x]&&s[y][x]<='Z')return (cnt%2)?0:1;\n  if(s[y][x]=='^')return (cnt%2)?0:1;\n  return (cnt%2)?1:0;\n}\n\nint bfs(){\n  for(int i=0;i<S;i++)\n    for(int j=0;j<2;j++)\n      for(int k=0;k<N;k++)\n\tfor(int l=0;l<N;l++)\n\t      d[i][j][k][l]=INF;\n  queue<P2> q;\n  q.push(P2(0,P1(P(0,0),P(sy,sx))));\n  d[0][0][sy][sx]=0;\n  while(!q.empty()){\n    P2 t=q.front(); q.pop();\n    int cost=t.first;\n    int Switch=t.second.first.first;\n    int F=t.second.first.second;\n    int y=t.second.second.first;\n    int x=t.second.second.second;\n    if(d[Switch][F][y][x]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(s[ny][nx]=='#')continue;\n      int nSwitch=Switch,f=0;\n      if('a'<=s[y][x]&&s[y][x]<='z')\n\tnSwitch^=(1<<(s[y][x]-'a')),f=1;\n      if('A'<=s[y][x]&&s[y][x]<='Z')\n\tnSwitch^=(1<<(s[y][x]-'A')),f=1;\n      int nF=getFloor(y,x,nSwitch);\n      if(s[y][x]=='|'){\n\tif(d[Switch][!F][y][x]>cost+1){\n\t  d[Switch][!F][y][x]=cost+1;\n\t  q.push(P2(cost+1,P1(P(Switch,!F),P(y,x))));\n\t}\n      }\n      if(f&&d[nSwitch][nF][y][x]>cost+1){\n\td[nSwitch][nF][y][x]=cost+1;\n\tq.push(P2(cost+1,P1(P(nSwitch,nF),P(y,x))));\n      }\n      int r=getFloor(ny,nx,Switch);\n      if(r==3)r=F;\n      if(F!=r)continue;\n      if(d[Switch][F][ny][nx]>cost+1){\n\td[Switch][F][ny][nx]=cost+1;\n\tq.push(P2(cost+1,P1(P(Switch,F),P(ny,nx))));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='%')sy=i,sx=j;\n      if(s[i][j]=='&')gy=i,gx=j;\n    }\n  }\n  cin>>m;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<h;j++)\n      cin>>t[i][j];\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#define sgn(v) (abs((v))<eps?0:((v)<0?-1:1))\n#define sqr(v) ((v)*(v))\n#define mb make_pair\n#define debug 0\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\nconst double eps=1e-9;\nconst double pi=acos(-1);\nchar mp[51][51];\nchar sp[10][51][51];\nint dp[1<<10][51][51][2];\nconst int inf=1e9+100;\nint tx,ty,sx,sy;\nint w,h,k;\nstruct State\n{\n\tint sta,loc,flr;\n\tState(){}\n\tState(int s,int l,int f)\n\t{\n\t\tsta=s;loc=l;flr=f;\n\t}\n};\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\nbool vis[(1<<10)*5002+5000+2];\nqueue<State> q;\ninline int tod(int sta,int x,int y,int flr)\n{\n\treturn sta*5002+(x*h+y)*2+flr;\n}\nvoid dfs(int sx,int sy)\n{\n\tint x,y,cur,nsta,sta,flr,sgn;\n\tint i,j;\n\tState now;\n\tdp[0][sx][sy][0]=0;\n\t//cout <<sx<<\" \"<<sy<<\" \"<<h<<endl;\n\tq.push(State(0,sx*h+sy,0));\n\tvis[(sx*h+sy)*2]=true;\n\twhile(!q.empty())\n\t{\n\t\tnow=q.front();\t\n\t\tq.pop();\n\t\tx=now.loc/h;\n\t\ty=now.loc%h;\n\t\tsta=now.sta;\n\t\tflr=now.flr;\n\t\t//cout <<sta<<\" x&y:\"<<x<<\" \"<<y<<\" \"<<flr<<\" \"<<vis[tod(sta,x,y,flr)]<<\" \"<<dp[sta][x][y][flr]<<endl;\n\t\tvis[tod(sta,x,y,flr)]=false;\n\t\tif(mp[x][y]=='|')\n\t\t{\n\t\t\tif(dp[sta][x][y][flr^1]>dp[sta][x][y][flr]+1)\n\t\t\t{\n\t\t\t\tdp[sta][x][y][flr^1]=dp[sta][x][y][flr]+1;\n\t\t\t\tif(!vis[tod(sta,x,y,flr^1)])\n\t\t\t\t{\n\t\t\t\t\tvis[tod(sta,x,y,flr^1)]=true;\n\t\t\t\t\tq.push(State(sta,x*h+y,flr^1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(cur=0,j=0;j<k;++j)\n\t\t\tif((sta&(1<<j))&&sp[j][x][y]=='*')cur^=1;\n\t\tif(isupper(mp[x][y])&&(cur^flr)==1)\n\t\t{\n\t\t\tif(sta&(1<<(mp[x][y]-'A')))\n\t\t\t\tnsta=sta&(~(1<<(mp[x][y]-'A')));\n\t\t\telse\n\t\t\t\tnsta=sta|(1<<(mp[x][y]-'A'));\n\t\t\tsgn=(sp[mp[x][y]-'A'][x][y]=='*');\n\t\t\tif(dp[nsta][x][y][flr^sgn]>dp[sta][x][y][flr]+1)\n\t\t\t{\n\t\t\t\tdp[nsta][x][y][flr^sgn]=dp[sta][x][y][flr]+1;\n\t\t\t\tif(!vis[tod(nsta,x,y,flr^sgn)])\n\t\t\t\t{\n\t\t\t\t\tvis[tod(nsta,x,y,flr^sgn)]=true;\n\t\t\t\t\tq.push(State(nsta,x*h+y,flr^1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(islower(mp[x][y])&&(cur^flr)==0)\n\t\t{\n\t\t\tif(sta&(1<<(mp[x][y]-'a')))\n\t\t\t\tnsta=sta&(~(1<<(mp[x][y]-'a')));\n\t\t\telse \n\t\t\t\tnsta=sta|(1<<(mp[x][y]-'a'));\n\t\t\tsgn=(sp[mp[x][y]-'a'][x][y]=='*');\n\t\t\tif(dp[nsta][x][y][flr^sgn]>dp[sta][x][y][flr]+1)\n\t\t\t{\n\t\t\t\tdp[nsta][x][y][flr^sgn]=dp[sta][x][y][flr]+1;\n\t\t\t\tif(!vis[tod(nsta,x,y,flr^sgn)])\n\t\t\t\t{\n\t\t\t\t\tvis[tod(nsta,x,y,flr^sgn)]=true;\n\t\t\t\t\tq.push(State(nsta,x*h+y,flr^1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;++i)\n\t\t{\n\t\t\tsx=x+dx[i];\n\t\t\tsy=y+dy[i];\n\t\t\tif(sx<0||sx>=w||sy<0||sy>=h)continue;\n\t\t\tfor(cur=0,j=0;j<k;++j)\n\t\t\t\tif((sta&(1<<j))&&sp[j][sx][sy]=='*')cur^=1;\n\t\t\tif((isupper(mp[sx][sy])||mp[sx][sy]=='^')&&(cur^flr)==1)\n\t\t\t{\n\t\t\t\tif(dp[sta][sx][sy][flr]>dp[sta][x][y][flr]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[sta][sx][sy][flr]=dp[sta][x][y][flr]+1;\n\t\t\t\t\tif(!vis[tod(sta,sx,sy,flr)])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[tod(sta,sx,sy,flr)]=true;\n\t\t\t\t\t\tq.push(State(sta,sx*h+sy,flr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((islower(mp[sx][sy])||mp[sx][sy]=='_'||mp[sx][sy]=='&'||mp[sx][sy]=='%')&&(cur^flr)==0)\n\t\t\t{\n\t\t\t\tif(dp[sta][sx][sy][flr]>dp[sta][x][y][flr]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[sta][sx][sy][flr]=dp[sta][x][y][flr]+1;\n\t\t\t\t\tif(!vis[tod(sta,sx,sy,flr)])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[tod(sta,sx,sy,flr)]=true;\n\t\t\t\t\t\tq.push(State(sta,sx*h+sy,flr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(mp[sx][sy]=='|')\n\t\t\t{\n\t\t\t\tif(dp[sta][sx][sy][flr]>dp[sta][x][y][flr]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[sta][sx][sy][flr]=dp[sta][x][y][flr]+1;\n\t\t\t\t\tif(!vis[tod(sta,sx,sy,flr)])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[tod(sta,sx,sy,flr)]=true;\n\t\t\t\t\t\tq.push(State(sta,sx*h+sy,flr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j,p;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(i=0;i<w;++i)\n\t\tscanf(\"%s\",mp[i]);\n\tscanf(\"%d\",&k);\n\tfor(i=0;i<k;++i)\n\t\tfor(j=0;j<w;++j)\n\t\t\tscanf(\"%s\",sp[i][j]);\t\n\tint full=1<<k;\n\tfor(i=0;i<full;++i)\n\t\tfor(j=0;j<w;++j)\n\t\t\tfor(p=0;p<h;++p)\n\t\t\t\tdp[i][j][p][0]=dp[i][j][p][1]=inf;\n\tfor(i=0;i<w;++i)\n\t\tfor(j=0;j<h;++j)\n\t\t\tif(mp[i][j]=='%')sx=i,sy=j;\n\t\t\telse if(mp[i][j]=='&')tx=i,ty=j;\n\t//cout <<\"pre finished\"<<\" \"<<sx<<\" \"<<sy<<\" \"<<tx<<\" \"<<ty<<\" \"<<full<<endl;\n\tdfs(sx,sy);\n\tint ans=inf;\n\tfor(i=0;i<full;++i)\n\t{\n\t\tans=min(ans,dp[i][tx][ty][0]);\n\t\tans=min(ans,dp[i][tx][ty][1]);\n\t}\n\tif(ans!=inf)printf(\"%d\\n\",ans);\n\telse printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*Rainto96\n*Beijing University of Posts and Telecommunications School of Software Engineering\n*http://blog.csdn.net/u011775691\n*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <vector>\n#include <climits>\nusing namespace std;\n#define pb push_back\n#define ALL(x) x.begin(),x.end()\n#define VINT vector<int>\n#define PII pair<int,int>\n#define MP(x,y) make_pair((x),(y))\n#define ll long long\n#define ull unsigned ll\n#define MEM0(x)  memset(x,0,sizeof(x))\n#define MEM(x,val) memset((x),val,sizeof(x))\n#define scan(x) scanf(\"%d\",&(x))\n#define scan2(x,y) scanf(\"%d%d\",&(x),&(y))\n#define scan3(x,y,z) scanf(\"%d%d%d\",&(x),&(y),&(z))\n#define scan4(x,y,z,k) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(k))\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nusing namespace std;\nint n,m,s;//m hang n lie\nint c[55][55][1111];//\nchar g[55][55];\nchar sg[11][55][55];\nint sx,sy;\nstruct Info{\n        int x,y,up,sta,step;\n};\nint dir[4][2]={-1,0,0,1,1,0,0,-1};\nbool vis[52][52][2][1100];//\nvoid bfs(){\n        queue<Info> que;\n        que.push((Info){sx,sy,0,0,0});\n        vis[sx][sy][0][0] = true;\n        bool flag= false;\n        while(!que.empty()){\n                Info now = que.front() ; que.pop();\n                int x = now.x, y=now.y, up=now.up, sta=now.sta, step=now.step;\n                //if(g[x][y]!='|' && c[x][y][sta] != up) continue;\n                //cerr<<x<<\" \"<<y<<\" \"<<up<<endl;\n                if(g[x][y] == '&'){\n                        flag=true;\n                        printf(\"%d\\n\",step);\n                        break;\n                }\n                if(g[x][y] == '|'){\n                        if(!vis[x][y][up^1][sta]){\n                                vis[x][y][up^1][sta] = true;\n                                que.push((Info){x,y,up^1,sta,step+1});\n                        }\n                }\n                if(isalpha(g[x][y])){\n                        int id;\n                        if(g[x][y] >='A' && g[x][y] <= 'Z')  id=g[x][y] - 'A';\n                        else id = g[x][y] -'a';\n                        int nup = c[x][y][sta^(1<<id)];\n                        if(!vis[x][y][nup][sta^(1<<id)]){\n                                vis[x][y][nup][sta^(1<<id)] = true;\n                                que.push((Info){x,y,nup,sta^(1<<id),step+1} );\n                        }\n                }\n                for(int i=0;i<4;i++){\n                        int nx = x + dir[i][0] , ny = y + dir[i][1];\n                        if(nx<0 || nx>=m || ny<0 || ny>=n || g[nx][ny] == '#') continue;\n                        if(g[nx][ny]!='|' && c[nx][ny][sta] != up) continue;\n                        if(!vis[nx][ny][up][sta]){\n                                vis[nx][ny][up][sta] = true;\n                                que.push((Info){nx,ny,up,sta,step+1});\n                        }\n                }\n        }\n        if(!flag) puts(\"-1\");\n}\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(\"C:/OJ/in.txt\",\"r\",stdin);\n\t#endif\n\twhile(scan2(n,m)==2){\n                MEM0(vis);\n                MEM0(c);\n                for(int i=0;i<m;i++) {\n                        scanf(\"%s\",g[i]);\n                        for(int j=0;j<n;j++){\n                                if(g[i][j] == '%') sx=i , sy=j;\n                        }\n                }\n                scan(s);\n                for(int i=0;i<s;i++){\n                        for(int j=0;j<m;j++) scanf(\"%s\",sg[i][j]);\n                }\n                for(int i=0;i<m;i++){\n                        for(int j=0;j<n;j++){\n                                if(g[i][j] == '#' || g[i][j] == '|') continue;\n                                for(int k=0;k<(1<<s);k++){\n                                        bool state = false;\n                                        for(int p=0;p<s;p++){\n                                                if(k&(1<<p)){\n                                                        if(sg[p][i][j] =='*')\n                                                        state ^= 1;\n                                                }\n                                        }\n                                        c[i][j][k] = state ^ (g[i][j]=='^' || (g[i][j]>='A' && g[i][j]<='Z'));\n                                }\n                        }\n                }\n                bfs();\n\t}\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\nint d[] = { 0, 1, 0, -1, 0 };\nint dist[50][50][1 << 10][2];\nint isup[50][50][1 << 10];\n\nint main() {\n    int w, h, s;\n    cin >> w >> h;\n    vector<string> m(h);\n    int si, sj;\n    for (int i = 0; i < h; ++i) {\n        cin >> m[i];\n        for (int j = 0; j < w; ++j) {\n            if (m[i][j] == '%') {\n                si = i;\n                sj = j;\n            }\n        }\n    }\n    cin >> s;\n    vector<vector<string>> ms(max(s, 1), vector<string>(h));\n    for (int i = 0; i < s; ++i) {\n        for (int j = 0; j < h; ++j) {\n            cin >> ms[i][j];\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (m[i][j] == '#' || m[i][j] == '|') continue;\n\n            for (int k = 0; k < (1 << s); ++k) {\n                int up = m[i][j] == '^' || m[i][j] >= 'A' && m[i][j] <= 'Z';\n                for (int l = 0; l < s; ++l)\n                    if (((k >> l) & 1) && ms[l][i][j] == '*')\n                        up ^= 1;\n\n                isup[i][j][k] = up;\n            }\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            for (int k = 0; k < (1 << s); ++k) {\n                for (int l = 0; l < 2; ++l)\n                    dist[i][j][k][l] = M;\n            }\n        }\n    }\n    queue<int> qi, qj, qs, qh;\n    dist[si][sj][0][0] = 0;\n    qi.push(si);\n    qj.push(sj);\n    qs.push(0);\n    qh.push(0);\n    while (!qi.empty()) {\n        int pi = qi.front(), pj = qj.front(), ps = qs.front(), ph = qh.front();\n        qi.pop();\n        qj.pop();\n        qs.pop();\n        qh.pop();\n        int dis = dist[pi][pj][ps][ph];\n        if (m[pi][pj] == '&') {\n            cout << dis << \"\\n\";\n            return 0;\n        }\n        if (m[pi][pj] == '|' && dist[pi][pj][ps][1 - ph] > dis + 1) {\n            dist[pi][pj][ps][1 - ph] = dis + 1;\n            qi.push(pi);\n            qj.push(pj);\n            qs.push(ps);\n            qh.push(1 - ph);\n        }\n        else if (m[pi][pj] >= 'A' && m[pi][pj] <= 'Z' || m[pi][pj] >= 'a' && m[pi][pj] <= 'z') {\n            int sw = (m[pi][pj] | 32) - 'a';\n            int ts = ps ^ (1 << sw);\n            int th = (ms[sw][pi][pj] == '*' ? 1 - ph : ph);\n            if (dist[pi][pj][ts][th] > dis + 1) {\n                dist[pi][pj][ts][th] = dis + 1;\n                qi.push(pi);\n                qj.push(pj);\n                qs.push(ts);\n                qh.push(th);\n            }\n        }\n        for (int i = 0; i < 4; ++i) {\n            int ti = pi + d[i], tj = pj + d[i + 1];\n            if (m[ti][tj] != '#' && (m[ti][tj] == '|' || ph == isup[ti][tj][ps]) && dist[ti][tj][ps][ph] > dis + 1) {\n                dist[ti][tj][ps][ph] = dis + 1;\n                qi.push(ti);\n                qj.push(tj);\n                qs.push(ps);\n                qh.push(ph);\n            }\n        }\n    }\n    cout << \"-1\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10;\nconst int MAXH = 51;\nconst int MAXW = 51;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint H, W, si, sj, gi, gj;\nchar G[MAXH][MAXW];\nint S;\nint T[MAXN][MAXH][MAXW];\nint F[1<<MAXN][MAXH][MAXW];\nint cost[1<<MAXN][2][MAXH][MAXW];\n\nstruct State {\n  int s, f, i, j;\n};\n\nint bfs() {\n  queue<State> que;\n  memset(cost, -1, sizeof(cost));\n  State src = {0, 0, si, sj};\n  que.push(src);\n  cost[src.s][src.f][src.i][src.j] = 0;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(s.i == gi && s.j == gj) return cost[s.s][s.f][s.i][s.j];\n    for(int k = 0; k < 4; ++k) {\n      const State t = {s.s, s.f, s.i + di[k], s.j + dj[k]};\n      if(t.i < 0 || t.i >= H) continue;\n      if(t.j < 0 || t.j >= W) continue;\n      if(G[t.i][t.j] == '#') continue;\n      if(G[t.i][t.j] != '|' && F[t.s][t.i][t.j] != t.f) continue;\n      if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n      que.push(t);\n      cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n    }\n\n    if(isalpha(G[s.i][s.j]))\n      do {\n        int id = toupper(G[s.i][s.j]) - 'A';\n        int ns = s.s ^ (1 << id);\n        const State t = {ns, F[ns][s.i][s.j], s.i, s.j};\n        if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n        que.push(t);\n        cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n      } while(0);\n\n    if(G[s.i][s.j] == '|')\n      do {\n        const State t = {s.s, s.f ^ 1, s.i, s.j};\n        if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n        que.push(t);\n        cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n      } while(0);\n  }\n  return -1;\n}\n\nint getFloor(char c) {\n  if(isalpha(c)) return isupper(c);\n  if(c == '_') return 0;\n  if(c == '^') return 1;\n  return 0;\n}\n\nint main() {\n  while(cin >> W >> H) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == '%') {\n          G[i][j] = '_';\n          si = i;\n          sj = j;\n        }\n        if(G[i][j] == '&') {\n          G[i][j] = '_';\n          gi = i;\n          gj = j;\n        }\n      }\n    }\n    cin >> S;\n    for(int k = 0; k < S; ++k) {\n      for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n          char c; cin >> c;\n          T[k][i][j] = (c == '*');\n        }\n      }\n    }\n    for(int b = 0; b < (1<<S); ++b) {\n      for(int i = 0; i < H; ++i){\n        for(int j = 0; j < W; ++j) {\n          F[b][i][j] = getFloor(G[i][j]);\n          for(int k = 0; k < S; ++k){\n            if(b >> k & 1); else continue;\n            F[b][i][j] ^= T[k][i][j];\n          }\n        }\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * main.cpp\n *\n *  Created on: 2014è·ã¨7è­?è­ã»\n *      Author: whd\n */\n\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\ntypedef long long big;\n\nconst int dx[] = { 0, 0, 1, -1 };\nconst int dy[] = { 1, -1, 0, 0 };\n\nint w, h;\nchar map[1 << 10][50][50];\nint id[50][50];\nint s;\nchar swi[10][50][50];\nint sx, sy, tx, ty;\nbool vis[1 << 10];\nstruct state {\n\tint st, f, x, y;\n\tstate() {\n\t}\n\tstate(int st, int f, int x, int y) :\n\t\t\tst(st), f(f), x(x), y(y) {\n\t}\n} q[(1 << 10) * 2 * 50 * 50];\nint qh, qt;\nint d[1 << 10][2][50][50];\nint ans;\n\nint main() {\n\tscanf(\"%d%d\", &w, &h);\n\tmemset(id, -1, sizeof id);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tscanf(\" %c\", &map[0][i][j]);\n\t\t\tif (map[0][i][j] == '%') {\n\t\t\t\tsx = i, sy = j;\n\t\t\t\tmap[0][i][j] = '_';\n\t\t\t}\n\t\t\tif (map[0][i][j] == '&') {\n\t\t\t\ttx = i, ty = j;\n\t\t\t\tmap[0][i][j] = '_';\n\t\t\t}\n\t\t\tif ('a' <= map[0][i][j] && map[0][i][j] <= 'z') {\n\t\t\t\tid[i][j] = map[0][i][j] - 'a';\n\t\t\t\tmap[0][i][j] = '_';\n\t\t\t}\n\t\t\tif ('A' <= map[0][i][j] && map[0][i][j] <= 'Z') {\n\t\t\t\tid[i][j] = map[0][i][j] - 'A';\n\t\t\t\tmap[0][i][j] = '^';\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\", &s);\n\tfor (int k = 0; k < s; k++) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tscanf(\" %c\", &swi[k][i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvis[0] = true;\n\tmemset(d, -1, sizeof d);\n\tans = -1;\n\tq[qh] = state(0, 0, sx, sy);\n\td[0][0][sx][sy] = 0;\n\twhile (qh <= qt) {\n\t\tstate u = q[qh++], v;\n\t\tif ( u.x == tx && u.y == ty) {\n\t\t\tans = d[u.st][u.f][u.x][u.y];\n\t\t\tbreak;\n\t\t}\n//\t\tcout << u.st << \" \" << u.f << \" \" << u.x << \" \" << u.y << \" : \"\n//\t\t\t\t<< d[u.st][u.f][u.x][u.y] << endl;\n//\t\tfor (int i = 0; i < h; i++) {\n//\t\t\tfor (int j = 0; j < w; j++) {\n//\t\t\t\tcout << map[u.st][i][j];\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\t\tif (map[u.st][u.x][u.y] == '|') {\n\t\t\tv.st = u.st, v.f = u.f ^ 1, v.x = u.x, v.y = u.y;\n\t\t\tif (d[v.st][v.f][v.x][v.y] == -1) {\n\t\t\t\td[v.st][v.f][v.x][v.y] = d[u.st][u.f][u.x][u.y] + 1;\n\t\t\t\tq[++qt] = v;\n\t\t\t}\n\t\t}\n\t\tif ((map[u.st][u.x][u.y] == '|' && u.f == 0)\n\t\t\t\t|| map[u.st][u.x][u.y] == '_') {\n\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\tv.st = u.st, v.f = u.f, v.x = u.x + dx[dir], v.y = u.y + dy[dir];\n\t\t\t\tif ((map[v.st][v.x][v.y] == '|' && v.f == 0)\n\t\t\t\t\t\t|| map[v.st][v.x][v.y] == '_') {\n\t\t\t\t\tif (d[v.st][v.f][v.x][v.y] == -1) {\n\t\t\t\t\t\td[v.st][v.f][v.x][v.y] = d[u.st][u.f][u.x][u.y] + 1;\n\t\t\t\t\t\tq[++qt] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((map[u.st][u.x][u.y] == '|' && u.f == 1)\n\t\t\t\t|| map[u.st][u.x][u.y] == '^') {\n\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\tv.st = u.st, v.f = u.f, v.x = u.x + dx[dir], v.y = u.y + dy[dir];\n\t\t\t\tif ((map[v.st][v.x][v.y] == '|' && v.f == 1)\n\t\t\t\t\t\t|| map[v.st][v.x][v.y] == '^') {\n\t\t\t\t\tif (d[v.st][v.f][v.x][v.y] == -1) {\n\t\t\t\t\t\td[v.st][v.f][v.x][v.y] = d[u.st][u.f][u.x][u.y] + 1;\n\t\t\t\t\t\tq[++qt] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (id[u.x][u.y] != -1) {\n\t\t\tv.st = u.st ^ (1 << id[u.x][u.y]), v.f = u.f\n\t\t\t\t\t^ (swi[id[u.x][u.y]][u.x][u.y] == '*'), v.x = u.x, v.y = u.y;\n\t\t\tif (d[v.st][v.f][v.x][v.y] == -1) {\n\t\t\t\td[v.st][v.f][v.x][v.y] = d[u.st][u.f][u.x][u.y] + 1;\n\t\t\t\tq[++qt] = v;\n\t\t\t}\n\t\t\tif (!vis[v.st]) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (swi[id[u.x][u.y]][i][j] == '*') {\n\t\t\t\t\t\t\tmap[v.st][i][j] = '_' + '^' - map[u.st][i][j];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmap[v.st][i][j] = map[u.st][i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct State{\n\tint bits, f, x, y;\n\tState(int bits_, int f_, int x_, int y_){\n\t\tbits = bits_; f = f_; x = x_; y = y_;\n\t}\n\tState(){}\n};\n\nconst int INF = 1e+8;\n// å¥å\nint w, h, s;\n// m[y][x] := (x,y) ã®ç¶æãè¿ã£ã¦ãã.\nchar m[51][51];\n// ms[k][y][x] := k çªç®ã®ã¹ã¤ããã«ã¤ãã¦(x,y)ãç§»åããã¨ãã¯ '*' ãè¿ã£ã¦ãã\nchar ms[10][51][51];\n// ã¹ã¿ã¼ãã¨ã´ã¼ã«\nint sx, sy, gx, gy;\n\n// d[bits][f][y][x] := ã¹ã¤ãããæ¼ããç¶æbits, f éã®(x,y) ã¾ã§ã®æå°ã® stepæ°\nint d[(1<<10)+1][2][51][51];\n// 4è¿å\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n\n// (ã¹ã¤ããã®æ¼ããç¶æ,é,xåº§æ¨,yåº§æ¨)ãç¶æã«ãã¦å¹åªåæ¢ç´¢\nint bfs(){\n\t// åæå\n\tfor(int i=0 ; i < (1<<s) ; i++ ){\n\t\tfor(int f=0 ; f < 2 ; f++ ){\n\t\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\t\td[i][f][y][x] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<State> q;\n\tq.push( State(0,0,sx,sy) );\n\td[0][0][sy][sx] = 0;\n\t\n\tint res = -1;\n\twhile( !q.empty() ){\n\t\tint x = q.front().x;\n\t\tint y = q.front().y;\n\t\tint f = q.front().f;\n\t\tint bits = q.front().bits;\n\t\tint cost = d[bits][f][y][x];\n\t\tq.pop();\n\t\t// ã´ã¼ã«ã®ã¨ã\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// 4 æ¹åã«ç§»å\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\t// (mx,my) ãä½éã«ããã (2Fã«ããã®ã¯'^'ãå¤§æå­ã®ã¢ã«ãã¡ãããã®ã¨ãã®ã¿)\n\t\t\tint f2 = ( m[my][mx] == '^' || isupper(m[my][mx])? 1 : 0 );\n\t\t\t// ãã¹ã¦ã®ONã®ã¹ã¤ããããã§ãã¯ãã¦èªåã®éãèª¿ã¹ã\n\t\t\tfor(int j=0 ; j < s ; j++ ){\n\t\t\t\tif( bits & (1<<j) && ms[j][my][mx] == '*' ){\n\t\t\t\t\tf2 = (f2+1) % 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// éæ®µã¯ã©ã¡ãã®éãããè¡ãæ¥å¯è½\n\t\t\tif( m[my][mx] == '|' ) f2 = f;\n\t\t\t\n\t\t\t// ä¾µå¥ã§ããªãã¨ã\n\t\t\tif( m[my][mx] == '#' || f2 != f ) continue;\n\t\t\t\n\t\t\tif( cost + 1 < d[bits][f][my][mx] ){\n\t\t\t\td[bits][f][my][mx] = cost + 1;\n\t\t\t\tq.push( State(bits, f, mx, my) );\n            }\n\t\t}\n\t\t\n\t\t// ã¯ããã«ããã¨ã\n\t\tif( m[y][x] == '|' ){\n\t\t\tint next_f = (f+1) % 2;\n\t\t\tif( cost + 1 < d[bits][next_f][y][x] ){\n\t\t\t\td[bits][next_f][y][x] = cost + 1;\n\t\t\t\tq.push( State(bits, next_f, x, y) );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ã¹ã¤ãããããã¨ã\n\t\tif( isalpha(m[y][x]) ){\n\t\t\tint k = tolower(m[y][x]) - 'a';\n\t\t\tint f2 = f;\n\t\t\t// xor ã§kçªç®ã®ã¹ã¤ããã ON => OFF ã OFF => ON ã«å¤æ´\n\t\t\tint next_bits = bits ^ (1<<k);\n\t\t\t// èªåã®ããéãå¤ããã¨ã\n\t\t\tif( ms[k][y][x] == '*' ){\n\t\t\t\tf2 = (f2+1) % 2;\n\t\t\t}\n\t\t\t\n\t\t\tif( cost + 1 < d[next_bits][f2][y][x] ){\n\t\t\t\td[next_bits][f2][y][x] = cost + 1;\n\t\t\t\tq.push( State(next_bits, f2, x, y) );\n\t\t\t}\n        }\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> w >> h;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> m[y];\n\t}\n\tcin >> s;\n\tfor(int i=0 ; i < s ; i++ ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> ms[i][y];\n\t\t}\n\t}\n\t// ã¹ã¿ã¼ãã¨ã´ã¼ã«ã®ä½ç½®ããã§ãã¯.\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == '%' ){\n\t\t\t\tsx = x; sy = y;\n\t\t\t\tm[y][x] = '_';\n\t\t\t}else if( m[y][x] == '&' ){\n\t\t\t\tgx = x; gy = y;\n\t\t\t\tm[y][x] = '_';\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// è§£ãåºå\n\tcout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Data> V;\n};\n\nstruct State{\n\tState(int arg_floor,int arg_row,int arg_col,int arg_button_state,int arg_step){\n\t\tfloor = arg_floor;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tbutton_state = arg_button_state;\n\t\tstep = arg_step;\n\t}\n\tint floor,row,col,button_state,step;\n};\n\nint W,H,POW[11],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar first_map[50][51];\n\nint dp[2][50][50][1024];\n\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_map[row][col] == '%'){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t\tfirst_map[row][col] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tInfo info[S];\n\tchar tmp_map[H][W];\n\n\tfor(int i = 0; i < S; i++){\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tscanf(\"%s\",tmp_map[row]);\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(tmp_map[row][col] == '*'){\n\t\t\t\t\tinfo[i].V.push_back(Data(row,col));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfor(int state = 0; state < POW[S]; state++)dp[i][row][col][state] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tqueue<State> Q;\n\tdp[0][start_row][start_col][0] = 0;\n\tQ.push(State(0,start_row,start_col,0,0));\n\n\tint calc_map[2][H][W];\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().step > dp[Q.front().floor][Q.front().row][Q.front().col][Q.front().button_state]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tint calc_table[H][W];\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++)calc_table[row][col] = 0;\n\t\t}\n\n\t\tfor(int loop = 0; loop < S; loop++){\n\t\t\tif(Q.front().button_state & (1 << loop)){\n\t\t\t\tfor(int i = 0; i < info[loop].V.size(); i++){\n\t\t\t\t\tcalc_table[info[loop].V[i].row][info[loop].V[i].col]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tswitch(first_map[row][col]){\n\t\t\t\tcase '#':\n\t\t\t\t\tcalc_map[0][row][col] = '#';\n\t\t\t\t\tcalc_map[1][row][col] = '#';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tcalc_map[0][row][col] = '|';\n\t\t\t\t\tcalc_map[1][row][col] = '|';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '&';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '&';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(first_map[row][col] >= 'a' && first_map[row][col] <= 'j'){\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col];\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col]-32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col]+32;\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.front().row + diff_row[i];\n\t\t\tint adj_col = Q.front().col + diff_col[i];\n\n\t\t\tif(Q.front().floor == 0){\n\n\t\t\t\tif(calc_map[0][adj_row][adj_col] == '_'){\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.front().button_state] > Q.front().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.front().button_state] = Q.front().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.front().button_state,Q.front().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.front().button_state] > Q.front().step+2){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.front().button_state] = Q.front().step+2;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.front().button_state,Q.front().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.front().button_state] > Q.front().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.front().button_state] = Q.front().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.front().button_state,Q.front().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.front().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] >= 'a' && calc_map[0][adj_row][adj_col] <= 'j'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.front().button_state] > Q.front().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.front().button_state] = Q.front().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.front().button_state,Q.front().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.front().floor][adj_row][adj_col] - 'a';\n\n\t\t\t\t\tint next_floor = Q.front().floor;\n\t\t\t\t\tfor(int k = 0; k < info[num].V.size(); k++){\n\t\t\t\t\t\tif(info[num].V[k].row == adj_row && info[num].V[k].col == adj_col){\n\t\t\t\t\t\t\tnext_floor = 1 - next_floor;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.front().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.front().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.front().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.front().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.front().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.front().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(calc_map[1][adj_row][adj_col] == '^'){\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.front().button_state] > Q.front().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.front().button_state] = Q.front().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.front().button_state,Q.front().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.front().button_state] > Q.front().step+2){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.front().button_state] = Q.front().step+2;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.front().button_state,Q.front().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.front().button_state] > Q.front().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.front().button_state] = Q.front().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.front().button_state,Q.front().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.front().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] >= 'A' && calc_map[1][adj_row][adj_col] <= 'J'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.front().button_state] > Q.front().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.front().button_state] = Q.front().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.front().button_state,Q.front().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.front().floor][adj_row][adj_col] - 'A';\n\n\t\t\t\t\tint next_floor = Q.front().floor;\n\t\t\t\t\tfor(int k = 0; k < info[num].V.size(); k++){\n\t\t\t\t\t\tif(info[num].V[k].row == adj_row && info[num].V[k].col == adj_col){\n\t\t\t\t\t\t\tnext_floor = 1 - next_floor;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.front().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.front().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.front().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.front().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.front().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.front().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {-1, 0, 1, 0};\n\nint W, H, S;\nstring M[50], MS[10][50];\nint bit[50][50], v[2][50][50][1 << 10];\nint mov[50][50];\n\nint Solve()\n{\n  memset(v, -1, sizeof(v));\n  for(int k = 0; k < S; k++) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(MS[k][i][j] == '*') bit[j][i] |= 1 << k;\n      }\n    }\n  }\n  queue< tuple< int, int, int, int > > que;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      switch(M[i][j]) {\n        case '|':\n          mov[j][i] = 3;\n          break;\n        case '_':\n          mov[j][i] = 1;\n          break;\n        case '^':\n          mov[j][i] = 2;\n          break;\n        case 'a' ... 'j':\n          mov[j][i] = 1;\n          M[i][j] -= 'a';\n          break;\n        case 'A' ... 'J':\n          mov[j][i] = 2;\n          M[i][j] -= 'A';\n          break;\n        case '%':\n          que.emplace(0, j, i, 0);\n          v[0][j][i][0] = 0;\n          mov[j][i] = 1;\n          break;\n        case '&':\n          mov[j][i] = 1;\n          break;\n        default:\n          mov[j][i] = 0;\n          break;\n      }\n    }\n  }\n\n  while(!que.empty()) {\n    int f, x, y, button;\n    tie(f, x, y, button) = que.front();\n    que.pop();\n    if(M[y][x] == '&') {\n      return (v[f][x][y][button]);\n    } else if(M[y][x] == '|') {\n      int nf = f ^ 1;\n      if(v[nf][x][y][button] == -1) {\n        v[nf][x][y][button] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, button);\n      }\n    } else if(M[y][x] < 10) {\n      int nbutton = button ^ (1 << M[y][x]);\n      int nf = (f + (MS[M[y][x]][y][x] == '*')) & 1;\n      if(v[nf][x][y][nbutton] == -1) {\n        v[nf][x][y][nbutton] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, nbutton);\n      }\n    }\n    for(int i = 0; i < 4; i++) {\n      int nx = x + vx[i], ny = y + vy[i];\n      int isgo = (f + __builtin_popcount(bit[nx][ny] & button)) & 1;\n      if(v[f][nx][ny][button] == -1 && (mov[nx][ny] & ++isgo)) {\n        v[f][nx][ny][button] = v[f][x][y][button] + 1;\n        que.emplace(f, nx, ny, button);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    cin >> M[i];\n  }\n  cin >> S;\n  for(int i = 0; i < S; i++) {\n    for(int j = 0; j < H; j++) {\n      cin >> MS[i][j];\n    }\n  }\n  cout << Solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <valarray>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n \nstruct P {\n  int  y, x;\n  int f;\n  int S;\n  P(int y, int x, int f, int S) : y(y),x(x),f(f),S(S) {}\n};\n \nchar ba[50][50];\nchar ms[10][50][50];\nint dist[50][50][2][1<<10];\n \nint main() {\n  int w, h;\n  cin >> w >> h;\n  int sx,sy;\n  int gx,gy;\n  REP(i,h) {\n    REP(j,w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == '%') {\n        sy = i; sx = j;\n      } else if (ba[i][j] == '&') {\n        gy = i, gx = j;\n      }\n    }\n  }\n  int m;\n  cin >> m;\n  REP(k,m) {\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ms[k][i][j];\n      }\n    }\n  }\n  queue<P> Q;\n  memset(dist,-1,sizeof(dist));\n  Q.push(P(sy,sx,0,0));\n  dist[sy][sx][0][0] = 0;\n  const int dy[] = {-1,0,1,0};\n  const int dx[] = {0,1,0,-1};\n  int ans = -1;\n  while(!Q.empty()) {\n    P p = Q.front(); Q.pop();\n    int d = dist[p.y][p.x][p.f][p.S];\n    int y = p.y;\n    int x = p.x;\n    int S = p.S;\n    bool f = p.f;\n \n    // // cout << x << \" \" << y << \" \" << f << \" \" << bitset<2>(S) << \"  \" << d << end\n    //   l;\n     \n    if (ba[y][x] == '&') {\n      ans = d;\n      break;\n    }\n     \n    REP(k,4) {\n      int yy = p.y + dy[k];\n      int xx = p.x + dx[k];\n      if (yy<0||yy>=h||xx<0||xx>=w) continue;\n      // if (yy==5 && xx==1) {\n      //   cout << \"!!!!!!!!!!!!!\" << endl;\n      //   cout << ba[yy][xx] << endl;\n      // }\n      if (ba[yy][xx] == '#') continue;\n      bool ff;\n      if (ba[yy][xx] == '^') ff = 1;\n      if (ba[yy][xx] == '_') ff = 0;\n      if (islower(ba[yy][xx])) ff = 0;\n      if (isupper(ba[yy][xx])) ff = 1;\n      if (ba[yy][xx] == '&' || ba[yy][xx] == '%') ff = 0;\n       \n      REP(i,m) {\n        if (S>>i&1) {\n          if (ms[i][yy][xx] == '*') ff ^= 1;\n        }\n      }\n      // if (yy==5 && xx==1 && ba[yy][xx] == 'B') {\n      //   cout << \"!!!!!!!\" << ff << \" \" << f << \" \" << x << \" \" << y << endl;\n      // }\n \n      if (ba[yy][xx] != '|' && ff != f) continue;\n \n      if (dist[yy][xx][p.f][p.S] == -1) {\n        dist[yy][xx][p.f][p.S] = d+1;\n        Q.push(P(yy,xx,p.f,p.S));\n      }\n    }\n    if (isalpha(ba[y][x])) {\n      int k;\n      if (islower(ba[y][x])) {\n        k = ba[y][x] - 'a';\n      } else {\n        k = ba[y][x] - 'A';\n      }\n      bool ff = f;\n      if (ms[k][y][x] == '*') {\n        ff ^= 1;\n      }\n \n      int T = S ^ (1<<k);\n      if (dist[y][x][ff][T] == -1) {\n        dist[y][x][ff][T] = d+1;\n        Q.push(P(y,x,ff,T));\n      }\n    }\n    if (ba[y][x] == '|') {\n      bool ff = f^1;\n      if (dist[y][x][ff][S] == -1) {\n        dist[y][x][ff][S] = d+1;\n        Q.push(P(y,x,ff,S));\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint data[2][51][51],sy,sx,gy,gx;\nint sw[51][51],h,w,num;\nstring s[51],t;\nint dy[]={0,0,-1,1};\nint dx[]={-1,1,0,0};\nbool used[51][51][1<<10][2];\nstruct dat{\n    int y,x,sw,flo,cost;\n    dat(int a,int b,int c,int d,int e){\n        y=a;x=b;sw=c;flo=d;cost=e;\n    }\n};\nsigned main(){\n    memset(data,-1,sizeof(data));\n    cin>>w>>h;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w){\n        if(s[i][j]=='%')data[0][i][j]=100,sy=i,sx=j;\n        if(s[i][j]=='&')data[0][i][j]=100,gy=i,gx=j;\n        if(s[i][j]=='_')data[0][i][j]=100;\n        if(s[i][j]=='^')data[1][i][j]=100;\n        if(s[i][j]=='|')data[0][i][j]=data[1][i][j]=101;\n        if(isalpha(s[i][j])){\n            if(islower(s[i][j]))data[0][i][j]=(s[i][j]-'a');\n            if(isupper(s[i][j]))data[1][i][j]=(s[i][j]-'A');\n        }\n    }\n    cin>>num;\n    r(i,num)r(j,h){\n        cin>>t;\n        r(k,w)if(t[k]=='*')sw[j][k]|=(1<<i);\n    }\n    queue<dat>q;\n    q.push(dat(sy,sx,0,0,0));\n    used[sy][sx][0][0]=1;\n    while(!q.empty()){\n        dat a=q.front();q.pop();\n        if(a.y==gy&&a.x==gx){\n            cout<<a.cost<<endl;\n            return 0;\n        }\n        int y=a.y;\n        int x=a.x;\n\n        // éæ®µ\n        if(data[a.flo][y][x]==101){\n            if(!used[y][x][a.sw][a.flo^1]){\n                used[y][x][a.sw][a.flo^1]=1;\n                q.push(dat(y,x,a.sw,a.flo^1,a.cost+1));\n            }\n        }\n\n        // ç§»å\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            int A=a.sw;\n            int B=sw[ny][nx];\n            int C=A&B;\n            int D=__builtin_popcount(C)+a.flo;D%=2;\n            if(data[D][ny][nx]!=-1){\n                //cout<<ny<<' '<<nx<<endl;\n                if(!used[ny][nx][a.sw][a.flo]){\n                    used[ny][nx][a.sw][a.flo]=1;\n                    q.push(dat(ny,nx,a.sw,a.flo,a.cost+1));\n                }\n            }\n        }\n\n        // ã¹ã¤ãã\n        if(isalpha(s[y][x])){\n            int A=a.sw;\n            int B=sw[y][x];\n            int C=A&B;\n            int D=__builtin_popcount(C)+a.flo;D%=2;\n            int E=data[D][y][x];\n            int F=0;\n            if(islower(s[y][x]))F|=(1<<(s[y][x]-'a'));\n            if(isupper(s[y][x]))F|=(1<<(s[y][x]-'A'));\n            if(F&B){\n                if(!used[y][x][a.sw^F][a.flo^1]){\n                    used[y][x][a.sw^F][a.flo^1]=1;\n                    q.push(dat(y,x,a.sw^F,a.flo^1,a.cost+1));\n                }\n            }\n            else{\n                if(!used[y][x][a.sw^F][a.flo]){\n                    used[y][x][a.sw^F][a.flo]=1;\n                    q.push(dat(y,x,a.sw^F,a.flo,a.cost+1));\n                }\n            }\n        }\n    }\n    cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int mod = 1e9 + 7;\n\nint W, H, S;\nchar M[55][55];\nchar MS[11][55][55];\nbool flr[55][55];\nint sy, sx, gy, gx;\n\nint dist[2][55][55][1<<10];\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nbool in(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> W >> H;\n  rep(i, H) rep(j, W) {\n    cin >> M[i][j];\n    if(M[i][j] == '%') sy = i, sx = j;\n    else if(M[i][j] == '&') gy = i, gx = j;\n    else if(M[i][j] == '_' || islower(M[i][j])) flr[i][j] = 0;\n    else if(M[i][j] == '^' || isupper(M[i][j])) flr[i][j] = 1;\n  }\n  cin >> S;\n  rep(i, S) rep(j, H) rep(k, W) cin >> MS[i][j][k];\n\n  queue< tuple<int, int, int, int> > que;\n\n  memset(dist, -1, sizeof(dist));\n  dist[0][sy][sx][0] = 0;\n  que.emplace(0, sy, sx, 0);\n\n  while(que.size()) {\n    int f, y, x, bit;\n    tie(f, y, x, bit) = que.front(); que.pop();\n    if(y == gy && x == gx) {\n      cout << dist[f][y][x][bit] << endl;\n      return 0;\n    }\n    if(M[y][x] == '|' && dist[!f][y][x][bit] == -1) {\n      dist[!f][y][x][bit] = dist[f][y][x][bit] + 1;\n      que.emplace(!f, y, x, bit);\n    }\n    if(isalpha(M[y][x])) {\n      int g = flr[y][x];\n      rep(j, S) if(((bit >> j) & 1) && MS[j][y][x] == '*') g = !g;\n      if(f == g) {\n\tint nf = f, ny = y, nx = x, nbit = bit;\n\tint digit = M[ny][nx] - (islower(M[ny][nx]) ? 'a' : 'A');\n\tnbit ^= 1<<digit;\n\tif(MS[digit][ny][nx] == '*') nf = !nf;\n\tif(dist[nf][ny][nx][nbit] == -1) {\n\t  dist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\t  que.emplace(nf, ny, nx, nbit);\n\t}\n      }\n    }\n    rep(i, 4) {\n      int nf = f, ny = y + dy[i], nx = x + dx[i], nbit = bit;\n      if(!in(ny, nx) || M[ny][nx] == '#' || ~dist[nf][ny][nx][nbit]) continue;\n      int g = flr[ny][nx];\n      rep(j, S) if(((nbit >> j) & 1) && MS[j][ny][nx] == '*') g = !g;\n      if(nf == g || M[ny][nx] == '|') {\n\tdist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\tque.emplace(nf, ny, nx, nbit);\n      }\n    }\n  }\n  cout << -1 << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nVS maze[1<<10];\nchar rev(char c){\n  switch(c){\n  case '_': return '^';\n  case '^': return '_';\n\t/*\n  case '%': return '$';\n  case '$': return '%';\n  case '&': return '~';\n  case '~': return '&';\n\t*/\n  }\n  if('A' <= c && c <= 'Z') return 'a'+c-'A';\n  return 'A'+c-'a';\n}\n\nint dist[1<<11][51][51];\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int W, H, S; cin >> W >> H;\n  vector<VS> mapd(12, VS(H));\n  REP(i,H) cin >> mapd[0][i];\n  cin >> S;\n  REP(i,S) REP(j,H)\n\tcin >> mapd[i+1][j];\n\n  int sy, sx, gy, gx;\n  REP(y,H) REP(x,W)\n\tif(mapd[0][y][x] == '%')\n\t  sx = x, sy = y, mapd[0][y][x] = '_';\n\telse if(mapd[0][y][x] == '&')\n\t  gx = x, gy = y, mapd[0][y][x] = '_';\n\t\t\t\t\t   \n  REP(b,1<<S){\n\tmaze[b].assign(H, string(W, ' '));\n\tREP(y,H) REP(x,W){\n\t  char c = mapd[0][y][x];\n\t  if(c == '#' || c == '|')\n\t\tmaze[b][y][x] = c;\n\t  else{\n\t\tbool on = false;\n\t\tREP(i,S)\n\t\t  if(b>>i&1 && mapd[i+1][y][x] == '*')\n\t\t\ton ^= true;\n\t\tif(!on) maze[b][y][x] = c;\n\t\telse maze[b][y][x] = rev(c);\n\t  }\n\t}\n  }\n\n  /*\n  REP(b,1<<S){\n\tREP(y,H){\n\t  REP(x,W) cout << maze[b][y][x];\n\t  cout<<endl;\n\t}\n\tcout << \"----------------\"<<endl;\n  }\n  */\n\n  queue<tuple<int,int,int>> q;\n  q.push(make_tuple(sx,sy,0));\n  fill((int*)dist, (int*)dist+(1<<11)*51*51, INF);\n  dist[0][sy][sx] = 0;\n  while(!q.empty()){\n\tint x, y, s, up;\n\ttie(x,y,s) = q.front(); q.pop();\n\tup = s >> 10 & 1;\n\tint ms = s ^ (up << 10);\n\n\tREP(i,4){\n\t  int tx = x + dx[i], ty = y + dy[i];\n\t  if(dist[s][ty][tx] < INF) continue;\n\t  char tc = maze[ms][ty][tx];\n\t  if(tc == '#') continue;\n\t  if(!up){\n\t\tif(tc == '^' || ('A' <= tc && tc <= 'Z')) continue;\n\t  }\n\t  else{\n\t\tif(tc == '_' || ('a' <= tc && tc <= 'z')) continue;\n\t  }\n\t  dist[s][ty][tx] = dist[s][y][x] + 1;\n\t  q.push(make_tuple(tx,ty,s));\n\t}\n\n\tchar c = maze[ms][y][x];\n\tif(c == '|'){\n\t  if(dist[s^(1<<10)][y][x] == INF){\n\t\tdist[s^(1<<10)][y][x] = dist[s][y][x] + 1;\n\t\tq.push(make_tuple(x,y,s^(1<<10)));\n\t  }\n\t}\n\telse if('a' <= c && c <= 'z'){\n\t  int b = 1 << (c-'a');\n\t  if(maze[ms^b][y][x] != maze[ms][y][x])\n\t\tb |= 1 << 10;\n\t  if(dist[s^b][y][x] == INF){\n\t\tdist[s^b][y][x] = dist[s][y][x] + 1;\n\t\tq.push(make_tuple(x,y,s^b));\n\t  }\n\t}\n\telse if('A' <= c && c <= 'Z'){\n\t  int b = 1 << (c-'A');\n\t  if(maze[ms^b][y][x] != maze[ms][y][x])\n\t\tb |= 1 << 10;\n\t  if(dist[s^b][y][x] == INF){\n\t\tdist[s^b][y][x] = dist[s][y][x] + 1;\n\t\tq.push(make_tuple(x,y,s^b));\n\t  }\n\t}\n  }\n\n  int ans = INF;\n  for(int s=0;s<1<<11;++s)\n\tans = min(ans, dist[s][gy][gx]);\n\n  cout << (ans < INF? ans: -1) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint w, h, s;\nint st, go;\nchar m[50][50], tmp[50][50];\nchar ms[10][50][50];\n//int dp[(1<<10)*2*50*50+2*50*50+50*50+50];\n//vector<int> e[(1<<10)*2*50*50+2*50*50+50*50+50];\nunordered_map<int,int> dp;\nunordered_map<int,int>::iterator it;\nunordered_map<int,vector<int> > e;\n\nint main(){\n\tcin >> w >> h;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == '%'){\n\t\t\tst = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t\tif(m[i][j] == '&'){\n\t\t\tgo = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t}\n\tcin >> s;\n\trep(i,s) rep(j,h) rep(k,w) cin >> ms[i][j][k];\n\trep(i,(1<<s)){\n\t\trep(j,h) rep(k,w) tmp[j][k] = m[j][k];\n\t\tint I = i;\n\t\trep(j,s){\n\t\t\tif(I&1){\n\t\t\t\trep(k,h) rep(l,w){\n\t\t\t\t\tif(ms[j][k][l] == '*'){\n\t\t\t\t\t\tif(tmp[k][l] == '_') tmp[k][l] = '^';\n\t\t\t\t\t\telse if(tmp[k][l] == '^') tmp[k][l] = '_';\n\t\t\t\t\t\telse if('a' <= tmp[k][l] && tmp[k][l] <= 'z'){\n\t\t\t\t\t\t\ttmp[k][l] = toupper(tmp[k][l]);\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\ttmp[k][l] = tolower(tmp[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tI >>= 1;\n\t\t}\n\t\trep(j,h) rep(k,w){\n\t\t\tif(tmp[j][k] == '#') continue;\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '_' || ('a' <= tmp[j][k]&&tmp[j][k] <= 'z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '_' || ('a' <= tmp[J][K]&&tmp[J][K] <= 'z')){\n\t\t\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '^' || ('A' <= tmp[j][k]&&tmp[j][k] <= 'Z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '^' || ('A' <= tmp[J][K]&&tmp[J][K] <= 'Z')){\n\t\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|'){\n\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*50+50*j+k);\n\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*j+k);\n\t\t\t}\n\t\t\tif('a' <= tmp[j][k] && tmp[j][k] <= 'z'){\n\t\t\t\tint z = tmp[j][k]-'a';\n\t\t\t\tint flo = 0;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 1;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif('A' <= tmp[j][k] && tmp[j][k] <= 'Z'){\n\t\t\t\tint z = tmp[j][k] - 'A';\n\t\t\t\tint flo = 1;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 0;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> que;\n\tque.push(st);\n\tdp[st] = 0;\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q].size()){\n\t\t\tif(dp.count(e[q][i])) continue;\n\t\t\tdp[e[q][i]] = dp[q]+1;\n\t\t\tque.push(e[q][i]);\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(it = dp.begin(); it != dp.end(); it++){\n\t\tif((*it).first%(50*50) != go) continue;\n\t\tans = min(ans,(*it).second);\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nint W,H,S;\nchar field[101][101];\nchar event[11][101][101];\nint moves[1<<10][51][51];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint d[51][51][1<<10][2];\n\ntypedef pair<pii,pair<int,int> > Sit;\nint sy,sx,gy,gx;\n\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>field[i][j];\n      if(field[i][j]=='%'){\n\tsy=i;sx=j;\n\tfield[i][j]='.';\n      }\n      else if(field[i][j]=='&'){\n\tgy=i;gx=j;\n\tfield[i][j]='.';\n      }\n      else if((field[i][j]>='A'&&field[i][j]<='Z')||(field[i][j]>='a'&&field[i][j]<='z')){\n\tchar ch=field[i][j];\n\tif(ch>='a'&&ch<='z')ch=ch-'a'+'A';\n      }\n    }\n  }\n  cin>>S;\n  for(int k=0;k<S;k++)\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tcin>>event[k][i][j];\n  for(int i=1;i<(1<<S);i++){\n    for(int j=0;j<10;j++){\n      if((i>>j)&1){\n\tfor(int k=0;k<H;k++){\n\t  for(int l=0;l<W;l++){\n\t    if(event[j][k][l]=='*'){\n\t      moves[i][k][l]=moves[i&~(1<<j)][k][l]^1;\n\t    }\n\t    else\n\t      moves[i][k][l]=moves[i&~(1<<j)][k][l];\n\t  }\n\t}\n      }\n    }\n  }\n  queue<Sit> q;\n  q.push(make_pair(pii(sy,sx),make_pair(0,0)));\n  memset(d,-1,sizeof(d));\n  d[sy][sx][0][0]=0;\n  while(q.size()){\n    pair<pii,pii> p=q.front();q.pop();\n    const int cy=p.first.first,cx=p.first.second;\n    const int mask=p.second.first,rank=p.second.second;\n    const int ccost=d[cy][cx][mask][rank];\n    if(field[cy][cx]=='|'){\n      int nrank=rank^1;\n      if(d[cy][cx][mask][nrank]<0){\n\td[cy][cx][mask][nrank]=ccost+1;\n\tq.push(Sit(pii(cy,cx),pii(mask,nrank)));\n      }\n    }\n    if(field[cy][cx]>='A'&&field[cy][cx]<='Z'){\n      const int ch=field[cy][cx]-'A';\n      int nmask=mask;\n      if(!((nmask>>ch)&1))nmask|=(1<<ch);\n      else nmask&=~(1<<ch);\n      int nrank=rank;\n      if(moves[nmask][cy][cx]!=moves[mask][cy][cx])nrank^=1;\n      if(d[cy][cx][nmask][nrank]<0){\n\td[cy][cx][nmask][nrank]=ccost+1;\n\tq.push(Sit(pii(cy,cx),pii(nmask,nrank)));\n      }\n    }\n    else if(field[cy][cx]>='a'&&field[cy][cx]<='z'){\n      int ch=field[cy][cx]-'a';\n      int nmask=mask;\n      if(!((nmask>>ch)&1))\n\tnmask|=(1<<ch);\n      else\n\tnmask&=~(1<<ch);\n      int nrank=rank;\n      if(moves[nmask][cy][cx]!=moves[mask][cy][cx])nrank^=1;\n      if(d[cy][cx][nmask][nrank]<0){\n\td[cy][cx][nmask][nrank]=ccost+1;\n\tq.push(Sit(pii(cy,cx),pii(nmask,nrank)));\n      }\n    }\n    for(int i=0;i<4;i++){\n      const int ny=cy+dy[i];\n      const int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'&&d[ny][nx][mask][rank]<0){\n\tif((field[ny][nx]=='_'||(field[ny][nx]>='a'&&field[ny][nx]<='z'))&&!(moves[mask][ny][nx]^rank)){\n\t  d[ny][nx][mask][rank]=ccost+1;\n\t  q.push(Sit(pii(ny,nx),pii(mask,rank)));\n\t}\n\telse if((field[ny][nx]=='^'||(field[ny][nx]>='A'&&field[ny][nx]<='Z'))&&(moves[mask][ny][nx]^rank)){\n\t  d[ny][nx][mask][rank]=ccost+1;\n\t  q.push(Sit(pii(ny,nx),pii(mask,rank)));\n\t}\n\telse if(field[ny][nx]=='|'){\n\t  d[ny][nx][mask][rank]=ccost+1;\n\t  q.push(Sit(pii(ny,nx),pii(mask,rank)));\n\t}\n\telse if(field[ny][nx]=='.'&&!(moves[mask][ny][nx]^rank)){\n\t  d[ny][nx][mask][rank]=ccost+1;\n\t  q.push(Sit(pii(ny,nx),pii(mask,rank)));\n\t}\n      }\n    }\n  }\n  const int INF=1<<30;\n  int res=INF;\n  for(int i=0;i<(1<<10);i++){\n    int a=moves[i][gy][gx];\n    if(d[gy][gx][i][a]!=-1)\n      res=min(res,d[gy][gx][i][a]);\n  }\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int H = 50;\nconst int W = 50;\nconst int S = 10;\n\nclass State{\npublic:\n   int f, y, x, state, cost;\n   State(){}\n   State(int state, int f, int y, int x, int cost) : state(state), f(f), y(y), x(x), cost(cost) {}\n};\n\nint h, w, s, sx, sy;\nchar input[H][W];\nchar data[S][H][W];\nint init[H][W];\nint data2[(1<<S)][H][W];\nbool vis[(1<<S)][2][H][W];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint solve(){\n   fill(vis[0][0][0], vis[(1<<s)][0][0], false);\n   State u, v;\n   u = State(0, 0, sy, sx, 0);\n   queue<State> q;\n   q.push(u);\n   vis[u.state][u.f][u.y][u.x] = true;\n   /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\t cout << data2[1][i][j] << ' ';\n      }\n      cout << endl;\n      }*/\n   while(!q.empty()){\n      u = q.front();\n      q.pop();\n      //cout << u.state << ' ' << u.f << ' ' << u.y << ' ' << u.x << ' ' << u.cost << endl;\n      if(u.f == data2[u.state][u.y][u.x] && input[u.y][u.x] == '&'){\n\t return u.cost;\n      }\n      for(int i=0;i<4;i++){\n\t int ny = u.y + dy[i];\n\t int nx = u.x + dx[i];\n\t if(ny < 0 || ny >= h) continue;\n\t if(nx < 0 || nx >= w) continue;\n\t if(input[ny][nx] == '#') continue;\n\t /*if(u.state == 1 && u.f == 1 && u.y == 3 && u.x == 4 && u.cost == 3){\n\t    cout << ny << ' ' << nx << endl;\n\t    }*/\n\t if(u.f != data2[u.state][ny][nx] && input[ny][nx] != '|') continue;\n\t if(!vis[u.state][u.f][ny][nx]){\n\t    vis[u.state][u.f][ny][nx] = true;\n\t    q.push(State(u.state, u.f, ny, nx, u.cost + 1));\n\t }\n      }\n      if(input[u.y][u.x] == '|'){\n\t if(!vis[u.state][1-u.f][u.y][u.x]){\n\t    vis[u.state][1-u.f][u.y][u.x] = true;\n\t    q.push(State(u.state, 1 - u.f, u.y, u.x, u.cost + 1));\n\t }\n      }\n      if(input[u.y][u.x] >= 'a' && input[u.y][u.x] <= 'j' && u.f == data2[u.state][u.y][u.x]){\n\t int tmp = input[u.y][u.x] - 'a';\n\t int next = u.state;\n\t if((u.state >> tmp) & 1){\n\t    next &= ~(1<<tmp);\n\t }else{\n\t    next |= (1<<tmp);\n\t }\n\t v = State(next, u.f, u.y, u.x, u.cost + 1);\n\t v.f = data2[next][v.y][v.x];\n\t if(!vis[v.state][v.f][v.y][v.x]){\n\t    vis[v.state][v.f][v.y][v.x] = true;\n\t    q.push(v);\n\t }\n      }\n      if(input[u.y][u.x] >= 'A' && input[u.y][u.x] <= 'J' && u.f == data2[u.state][u.y][u.x]){\n\t int tmp = input[u.y][u.x] - 'A';\n\t int next = u.state;\n\t if((u.state >> tmp) & 1){\n\t    next &= ~(1<<tmp);\n\t }else{\n\t    next |= (1<<tmp);\n\t }\n\t v = State(next, u.f, u.y, u.x, u.cost + 1);\n\t v.f = data2[next][v.y][v.x];\n\t if(!vis[v.state][v.f][v.y][v.x]){\n\t    vis[v.state][v.f][v.y][v.x] = true;\n\t    q.push(v);\n\t }\n      }\n   }\n   return -1;\n}\n\nmain(){\n   cin >> w >> h;\n   for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\t cin >> input[i][j];\n\t if(input[i][j] == '%'){\n\t    sy = i;\n\t    sx = j;\n\t }\n\t init[i][j] = 0;\n\t if(input[i][j] == '^') init[i][j] = 1;\n\t if(input[i][j] >= 'A' && input[i][j] <= 'J') init[i][j] = 1;\n      }\n   }\n   cin >> s;\n   for(int k=0;k<s;k++){\n      for(int i=0;i<h;i++){\n\t for(int j=0;j<w;j++){\n\t    cin >> data[k][i][j];\n\t }\n      }\n   }\n   for(int k=0;k<(1<<s);k++){\n      for(int i=0;i<h;i++){\n\t for(int j=0;j<w;j++){\n\t    data2[k][i][j] = init[i][j];\n\t    for(int l=0;l<s;l++){\n\t       if(((k>>l) & 1) && data[l][i][j] == '*') data2[k][i][j] = 1 - data2[k][i][j];\n\t    }\n\t }\n      }\n   }\n   cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint H,W,S;\nstring s[50],t[10][50];\nint dp[2][50][50][1<<10];\nint d[5]={0,1,0,-1,0};\nmain()\n{\n\tcin>>W>>H;\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tcin>>s[i];\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tif(s[i][j]=='%')\n\t\t\t{\n\t\t\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t\t\t}\n\t\t}\n\t}\n\tcin>>S;\n\tfor(int i=0;i<2;i++)for(int j=0;j<H;j++)for(int k=0;k<W;k++)for(int l=0;l<1<<S;l++)\n\t{\n\t\tdp[i][j][k][l]=2e9;\n\t}\n\tdp[0][Q.front().second.first][Q.front().second.second][0]=0;\n\tfor(int i=0;i<S;i++)\n\t{\n\t\tfor(int j=0;j<H;j++)cin>>t[i][j];\n\t}\n\twhile(!Q.empty())\n\t{\n\t\tint f=Q.front().first.first,sw=Q.front().first.second,x=Q.front().second.first,y=Q.front().second.second;\n\t\tQ.pop();\n\t\tint nxt=dp[f][x][y][sw]+1;\n\t\tif(s[x][y]=='&')\n\t\t{\n\t\t\tcout<<dp[f][x][y][sw]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=x+d[r],ty=y+d[r+1];\n\t\t\tif(tx<0||ty<0||tx>=H||ty>=W||s[tx][ty]=='#')continue;\n\t\t\tint nf=s[tx][ty]=='^'||s[tx][ty]>='A'&&s[tx][ty]<='J'?1:0;\n\t\t\tfor(int k=0;k<S;k++)\n\t\t\t{\n\t\t\t\tif(sw>>k&1&&t[k][tx][ty]=='*')nf++;\n\t\t\t}\n\t\t\tnf%=2;\n\t\t\tif(s[tx][ty]!='|'&&nf!=f)continue;\n\t\t\tif(dp[f][tx][ty][sw]>nxt)\n\t\t\t{\n\t\t\t\tdp[f][tx][ty][sw]=nxt;\n\t\t\t\tQ.push(make_pair(make_pair(f,sw),make_pair(tx,ty)));\n\t\t\t}\n\t\t}\n\t\tif(s[x][y]=='|')\n\t\t{\n\t\t\tif(dp[1-f][x][y][sw]>nxt)\n\t\t\t{\n\t\t\t\tdp[1-f][x][y][sw]=nxt;\n\t\t\t\tQ.push(make_pair(make_pair(1-f,sw),make_pair(x,y)));\n\t\t\t}\n\t\t}\n\t\telse if(s[x][y]>='a'&&s[x][y]<='j')\n\t\t{\n\t\t\tint id=s[x][y]-'a';\n\t\t\tint nf=t[id][x][y]=='*'?1-f:f;\n\t\t\tint nsw=sw^1<<id;\n\t\t\tif(dp[nf][x][y][nsw]>nxt)\n\t\t\t{\n\t\t\t\tdp[nf][x][y][nsw]=nxt;\n\t\t\t\tQ.push(make_pair(make_pair(nf,nsw),make_pair(x,y)));\n\t\t\t}\n\t\t}\n\t\telse if(s[x][y]>='A'&&s[x][y]<='J')\n\t\t{\n\t\t\tint id=s[x][y]-'A';\n\t\t\tint nf=t[id][x][y]=='*'?1-f:f;\n\t\t\tint nsw=sw^1<<id;\n\t\t\tif(dp[nf][x][y][nsw]>nxt)\n\t\t\t{\n\t\t\t\tdp[nf][x][y][nsw]=nxt;\n\t\t\t\tQ.push(make_pair(make_pair(nf,nsw),make_pair(x,y)));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\nstring sw[11][N];\nint w,h,s;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n \nbool check(int x,int y,int f,int bit){\n  if(mp[y][x]=='#')return 0;\n \n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n \n  char ch = mp[y][x];\n  if((cnt+f)%2==0)\n    if(isupper(ch)||ch=='^')return 0;\n  \n  if((cnt+f)%2==1)\n    if(islower(ch)||ch=='_'||ch=='&'||ch=='%')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n \nint used[N][N][2][1<<10],mem[N][N][2][1<<10];\nint dfs(int x,int y,int f,int bit){\n  if(mp[y][x] == '&'&&f==0)return 0;\n  if(used[x][y][f][bit]++)return mem[x][y][f][bit];\n\n  int res=mem[x][y][f][bit]=1e6;\n  \n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(!check(nx,ny,f,bit))continue;\n\n    int th=mp[ny][nx]-(isupper(mp[ny][nx])? 'A':'a');\n    if(mp[ny][nx]=='|')res=min(res,2+dfs(nx,ny,!f,bit));\n    if(isalpha(mp[ny][nx]))res=min(res,2+dfs(nx,ny,(sw[th][ny][nx]=='*')?!f:f,nbit(bit,th)));\n    res=min(res,1+dfs(nx,ny,f,bit));\n  }\n  return mem[x][y][f][bit]=res;\n}\n  \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n \n  int ans=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')ans=dfs(j,i,0,0);\n \n  if(ans>=1e6)cout<<-1<<endl;\n  else cout<<ans<<endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nstruct State {\n    int row, col, mask, floor, cost;\n    State(int row, int col, int mask, int floor, int cost) :\n        row(row), col(col), mask(mask), floor(floor), cost(cost) {}\n};\n\nconst int MAX_W = 51;\nconst int MAX_H = 51;\nconst int MAX_S = 11;\n\nbool valid[MAX_H][MAX_W][1 << MAX_S][2];\nint cost[MAX_H][MAX_W][1 << MAX_S][2];\n\nstring m[MAX_H], ms[MAX_S][MAX_H];\n\nint w, h, s;\n\nint dr[4] = {1, 0, -1, 0},\n    dc[4] = {0, 1, 0, -1};\n\nbool can_move(int r, int c) {\n    return true;\n}\n\nvoid push_with_test(queue<State>& que, int nrow, int ncol, int nmask, int nfloor, int ncost) {\n    int& ref_cost = cost[nrow][ncol][nmask][nfloor];\n    if (valid[nrow][ncol][nmask][nfloor] && ref_cost == -1) {\n        ref_cost = ncost;\n        que.push(State(nrow, ncol, nmask, nfloor, ref_cost));\n    }\n}\n\nint bfs(int start_r, int start_c) {\n    queue<State> que;\n    memset(cost, -1, sizeof(cost));\n\n    cost[start_r][start_c][0][0] = 0;\n    que.push(State(start_r, start_c, 0, 0, cost[start_r][start_c][0][0]));\n\n    while (!que.empty()) {\n        State state = que.front(); que.pop();\n\n        if (m[state.row][state.col] == '&') {\n            return state.cost;\n        }\n\n        // ??Â£??\\????????????????Â§????\n        for (int i = 0; i < 4; i++) {\n            int nrow = state.row + dr[i],\n                ncol = state.col + dc[i],\n                nmask = state.mask,\n                nfloor = state.floor,\n                ncost = state.cost + 1;\n            push_with_test(que, nrow, ncol, nmask, nfloor, ncost);\n        }\n\n        // ?????????????????????????????????????????Â´??????\n        if (m[state.row][state.col] == '|') {\n            int nrow = state.row,\n                ncol = state.col,\n                nmask = state.mask,\n                nfloor = (state.floor + 1) % 2,\n                ncost = state.cost + 1;\n            push_with_test(que, nrow, ncol, nmask, nfloor, ncost);\n        }\n        // ?????????????????????????????????????????????????????????\n        if (isalpha(m[state.row][state.col])) {\n            char alpha = m[state.row][state.col];\n            int alpha_i = isupper(alpha) ? (alpha - 'A') : (alpha - 'a'),\n                nrow = state.row,\n                ncol = state.col,\n                nmask = state.mask ^ (1 << alpha_i),\n                nfloor = ms[alpha_i][state.row][state.col] == '*' ? (state.floor + 1) % 2 :\n                                                                    state.floor,\n                ncost = state.cost + 1;\n            push_with_test(que, nrow, ncol, nmask, nfloor, ncost);\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    cin >> w >> h;\n    \n    int start_r, start_c;\n    for (int r = 0; r < h; r++) {\n        cin >> m[r];\n        for (int c = 0; c < w; c++) {\n            if (m[r][c] == '%') {\n                start_r = r;\n                start_c = c;\n                break;\n            }\n        }\n    }\n\n    cin >> s;\n    for (int s_i = 0; s_i < s; s_i++) {\n        for (int r = 0; r < h; r++) {\n            cin >> ms[s_i][r];\n        }\n    }\n\n    // valid????????????\n    for (int r = 0; r < h; r++) {\n        for (int c = 0; c < w; c++) {\n            for (int mask = 0; mask < (1 << s); mask++) {\n                if (m[r][c] == '#') {\n                    continue;\n                } else if (m[r][c] == '|') {\n                    valid[r][c][mask][0] = valid[r][c][mask][1] = true;\n                    continue;\n                }\n\n                int init_floor = (isupper(m[r][c]) || m[r][c] == '^') ? 1 : 0,\n                    move = 0;\n                for (int s_i = 0; s_i < s; s_i++) {\n                    if (((mask >> s_i) & 1) && ms[s_i][r][c] == '*') {\n                        move++;\n                    }\n                }\n                valid[r][c][mask][(init_floor + move) % 2] = true;\n            }\n        }\n    }\n\n    cout << bfs(start_r, start_c) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct State{\n\tint bits, f, x, y;\n\tState(int bits_, int f_, int x_, int y_){\n\t\tbits = bits_; f = f_; x = x_; y = y_;\n\t}\n\tState(){}\n};\n\nconst int INF = 1e+8;\n// å¥å\nint w, h, s;\n// m[y][x] := (x,y) ã®ç¶æãè¿ã£ã¦ãã.\nchar m[51][51];\n// ms[k][y][x] := k çªç®ã®ã¹ã¤ããã«ã¤ãã¦(x,y)ãç§»åããã¨ãã¯ '*' ãè¿ã£ã¦ãã\nchar ms[10][51][51];\n// ã¹ã¿ã¼ãã¨ã´ã¼ã«\nint sx, sy, gx, gy;\n\n// d[bits][f][y][x] := ã¹ã¤ãããæ¼ããç¶æbits, f éã®(x,y) ã¾ã§ã®æå°ã® stepæ°\nint d[(1<<10)+1][2][51][51];\n// 4è¿å\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n\n// (ã¹ã¤ããã®æ¼ããç¶æ,é,xåº§æ¨,yåº§æ¨)ãç¶æã«ãã¦å¹åªåæ¢ç´¢\nint bfs(){\n\t// åæå\n\tfor(int i=0 ; i < (1<<s) ; i++ ){\n\t\tfor(int f=0 ; f < 2 ; f++ ){\n\t\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\t\td[i][f][y][x] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<State> q;\n\tq.push( State(0,0,sx,sy) );\n\td[0][0][sy][sx] = 0;\n\t\n\tint res = -1;\n\twhile( !q.empty() ){\n\t\tint x = q.front().x;\n\t\tint y = q.front().y;\n\t\tint f = q.front().f;\n\t\tint bits = q.front().bits;\n\t\tint cost = d[bits][f][y][x];\n\t\tq.pop();\n\t\t// ã´ã¼ã«ã®ã¨ã\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cost;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// 4 æ¹åã«ç§»å\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\t// (mx,my) ãä½éã«ããã (2Fã«ããã®ã¯'^'ãå¤§æå­ã®ã¢ã«ãã¡ãããã®ã¨ãã®ã¿)\n\t\t\tint f2 = ( m[my][mx] == '^' || isupper(m[my][mx])? 1 : 0 );\n\t\t\t// ãã¹ã¦ã®ONã®ã¹ã¤ããããã§ãã¯ãã¦èªåã®éãèª¿ã¹ã\n\t\t\tfor(int j=0 ; j < s ; j++ ){\n\t\t\t\tif( bits & (1<<j) && ms[j][my][mx] == '*' ){\n\t\t\t\t\tf2 = (f2+1) % 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// éæ®µã¯ã©ã¡ãã®éãããè¡ãæ¥å¯è½\n\t\t\tif( m[my][mx] == '|' ) f2 = f;\n\t\t\t\n\t\t\t// ä¾µå¥ã§ããªãã¨ã\n\t\t\tif( m[my][mx] == '#' || f2 != f ) continue;\n\t\t\t\n\t\t\tif( cost + 1 < d[bits][f][my][mx] ){\n\t\t\t\td[bits][f][my][mx] = cost + 1;\n\t\t\t\tq.push( State(bits, f, mx, my) );\n            }\n\t\t\tif( m[my][mx] == '#' ) continue;\n\t\t\t\n\t\t\tState next(bits, f, mx, my);\n\t\t\tif( d[bits][f][my][mx] == INF ){\n\t\t\t\td[bits][f][my][mx] = cost + 1;\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ã¯ããã«ããã¨ã\n\t\tif( m[y][x] == '|' ){\n\t\t\tint next_f = (f+1) % 2;\n\t\t\tif( cost + 1 < d[bits][next_f][y][x] ){\n\t\t\t\td[bits][next_f][y][x] = cost + 1;\n\t\t\t\tq.push( State(bits, next_f, x, y) );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ã¹ã¤ãããããã¨ã\n\t\tif( isalpha(m[y][x]) ){\n\t\t\tint k = tolower(m[y][x]) - 'a';\n\t\t\tint f2 = f;\n\t\t\t// xor ã§kçªç®ã®ã¹ã¤ããã ON => OFF ã OFF => ON ã«å¤æ´\n\t\t\tint next_bits = bits ^ (1<<k);\n\t\t\t// èªåã®ããä½ç½®ãå¤ããã¨ã\n\t\t\tif( ms[k][y][x] == '*' ){\n\t\t\t\tf2 = (f2+1) % 2;\n\t\t\t}\n\t\t\t\n\t\t\tif( cost + 1 < d[next_bits][f2][y][x] ){\n\t\t\t\td[next_bits][f2][y][x] = cost + 1;\n\t\t\t\tq.push( State(next_bits, f2, x, y) );\n\t\t\t}\n        }\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> w >> h;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> m[y];\n\t}\n\tcin >> s;\n\tfor(int i=0 ; i < s ; i++ ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> ms[i][y];\n\t\t}\n\t}\n\t// ã¹ã¿ã¼ãã¨ã´ã¼ã«ã®ä½ç½®ããã§ãã¯.\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == '%' ){\n\t\t\t\tsx = x; sy = y;\n\t\t\t\tm[y][x] = '_';\n\t\t\t}else if( m[y][x] == '&' ){\n\t\t\t\tgx = x; gy = y;\n\t\t\t\tm[y][x] = '_';\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// è§£ãåºå\n\tcout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[60][60];\nint key[11][60][60];\nchar in[60][60];\nint bfs[1<<10][60][60][2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<a;j++)scanf(\"%s\",in[j]);\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++){\n\t\t\tif(in[j][k]=='*')key[i][j][k]=1;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<(1<<c);i++)for(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[i][j][k][0]=bfs[i][j][k][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='%'){\n\t\tbfs[0][i][j][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t}\n\twhile(Q.size()){\n\t\tint v=Q.front().first.first;\n\t\tint f=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!~bfs[v][row+dx[i]][col+dy[i]][f]&&\n\t\t\tstr[row+dx[i]][col+dy[i]]!='#'){\n\t\t\t\tint H=0;if(str[row+dx[i]][col+dy[i]]=='^'||('A'<=str[row+dx[i]][col+dy[i]]&&str[row+dx[i]][col+dy[i]]<='Z'))H=1;\n\t\t\t\tfor(int j=0;j<c;j++)if((v&(1<<j))&&key[j][row+dx[i]][col+dy[i]])H=!H;\n\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='|'||H==f){\n\t\t\t\t\tbfs[v][row+dx[i]][col+dy[i]][H]=bfs[v][row][col][f]+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(v,H),make_pair(row+dx[i],col+dy[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str[row][col]=='|'&&!~bfs[v][row][col][!f]){\n\t\t\tbfs[v][row][col][!f]=bfs[v][row][col][f]+1;\n\t\t\tQ.push(make_pair(make_pair(v,!f),make_pair(row,col)));\n\t\t}\n\t\tif('a'<=(32|str[row][col])&&(32|str[row][col])<='z'){\n\t\t\tint H=f;\n\t\t\tif(key[(32|str[row][col])-'a'][row][col])H=!H;\n\t\t\tint to=v^(1<<((32|str[row][col])-'a'));\n\t\t\tif(!~bfs[to][row][col][H]){\n\t\t\t\tbfs[to][row][col][H]=bfs[v][row][col][f]+1;\n\t\t\t\tQ.push(make_pair(make_pair(to,H),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='&'){\n\t\tfor(int k=0;k<(1<<c);k++){\n\t\t\tif(~bfs[k][i][j][0])ret=min(ret,bfs[k][i][j][0]);\n\t\t}\n\t}\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint w, h, s;\nint st, go;\nchar m[50][50], tmp[50][50];\nchar ms[10][50][50];\n//int dp[(1<<10)*2*50*50+2*50*50+50*50+50];\n//vector<int> e[(1<<10)*2*50*50+2*50*50+50*50+50];\nmap<int,int> dp;\nmap<int,int>::iterator it;\nmap<int,vector<int> > e;\n\nint main(){\n\tcin >> w >> h;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == '%'){\n\t\t\tst = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t\tif(m[i][j] == '&'){\n\t\t\tgo = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t}\n\tcin >> s;\n\trep(i,s) rep(j,h) rep(k,w) cin >> ms[i][j][k];\n\trep(i,(1<<s)){\n\t\trep(j,h) rep(k,w) tmp[j][k] = m[j][k];\n\t\tint I = i;\n\t\trep(j,s){\n\t\t\tif(I&1){\n\t\t\t\trep(k,h) rep(l,w){\n\t\t\t\t\tif(ms[j][k][l] == '*'){\n\t\t\t\t\t\tif(tmp[k][l] == '_') tmp[k][l] = '^';\n\t\t\t\t\t\telse if(tmp[k][l] == '^') tmp[k][l] = '_';\n\t\t\t\t\t\telse if('a' <= tmp[k][l] && tmp[k][l] <= 'z'){\n\t\t\t\t\t\t\ttmp[k][l] = toupper(tmp[k][l]);\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\ttmp[k][l] = tolower(tmp[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tI >>= 1;\n\t\t}\n\t\trep(j,h) rep(k,w){\n\t\t\tif(tmp[j][k] == '#') continue;\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '_' || ('a' <= tmp[j][k]&&tmp[j][k] <= 'z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '_' || ('a' <= tmp[J][K]&&tmp[J][K] <= 'z')){\n\t\t\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '^' || ('A' <= tmp[j][k]&&tmp[j][k] <= 'Z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '^' || ('A' <= tmp[J][K]&&tmp[J][K] <= 'Z')){\n\t\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|'){\n\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*50+50*j+k);\n\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*j+k);\n\t\t\t}\n\t\t\tif('a' <= tmp[j][k] && tmp[j][k] <= 'z'){\n\t\t\t\tint z = tmp[j][k]-'a';\n\t\t\t\tint flo = 0;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 1;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif('A' <= tmp[j][k] && tmp[j][k] <= 'Z'){\n\t\t\t\tint z = tmp[j][k] - 'A';\n\t\t\t\tint flo = 1;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 0;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> que;\n\tque.push(st);\n\tdp[st] = 0;\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q].size()){\n\t\t\tif(dp.count(e[q][i])) continue;\n\t\t\tdp[e[q][i]] = dp[q]+1;\n\t\t\tque.push(e[q][i]);\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(it = dp.begin(); it != dp.end(); it++){\n\t\tif((*it).first%(50*50) != go) continue;\n\t\tans = min(ans,(*it).second);\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "v\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Data> V;\n};\n\nstruct State{\n\tState(int arg_floor,int arg_row,int arg_col,int arg_button_state,int arg_step){\n\t\tfloor = arg_floor;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tbutton_state = arg_button_state;\n\t\tstep = arg_step;\n\t}\n\n\tbool operator<(const struct State &arg) const{\n\t\treturn step > arg.step;\n\t};\n\tint floor,row,col,button_state,step;\n};\n\nint W,H,POW[11],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar first_map[50][51];\n\nint dp[2][50][50][1024];\n\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_map[row][col] == '%'){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t\tfirst_map[row][col] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tInfo info[S];\n\tchar tmp_map[H][W];\n\n\tfor(int i = 0; i < S; i++){\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tscanf(\"%s\",tmp_map[row]);\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(tmp_map[row][col] == '*'){\n\t\t\t\t\tinfo[i].V.push_back(Data(row,col));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfor(int state = 0; state < POW[S]; state++)dp[i][row][col][state] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpriority_queue<State> Q;\n\tdp[0][start_row][start_col][0] = 0;\n\tQ.push(State(0,start_row,start_col,0,0));\n\n\tint calc_map[2][H][W];\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().step > dp[Q.top().floor][Q.top().row][Q.top().col][Q.top().button_state]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tint calc_table[H][W];\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++)calc_table[row][col] = 0;\n\t\t}\n\n\t\tfor(int loop = 0; loop < S; loop++){\n\t\t\tif(Q.top().button_state & (1 << loop)){\n\t\t\t\tfor(int i = 0; i < info[loop].V.size(); i++){\n\t\t\t\t\tcalc_table[info[loop].V[i].row][info[loop].V[i].col]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tswitch(first_map[row][col]){\n\t\t\t\tcase '#':\n\t\t\t\t\tcalc_map[0][row][col] = '#';\n\t\t\t\t\tcalc_map[1][row][col] = '#';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tcalc_map[0][row][col] = '|';\n\t\t\t\t\tcalc_map[1][row][col] = '|';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '&';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '&';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(first_map[row][col] >= 'a' && first_map[row][col] <= 'j'){\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col];\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col]-32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col]+32;\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\tif(Q.top().floor == 0){\n\n\t\t\t\tif(calc_map[0][adj_row][adj_col] == '_'){\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] >= 'a' && calc_map[0][adj_row][adj_col] <= 'j'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'a';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tfor(int k = 0; k < info[num].V.size(); k++){\n\t\t\t\t\t\tif(info[num].V[k].row == adj_row && info[num].V[k].col == adj_col){\n\t\t\t\t\t\t\tnext_floor = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(calc_map[1][adj_row][adj_col] == '^'){\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] >= 'A' && calc_map[1][adj_row][adj_col] <= 'J'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'A';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tfor(int k = 0; k < info[num].V.size(); k++){\n\t\t\t\t\t\tif(info[num].V[k].row == adj_row && info[num].V[k].col == adj_col){\n\t\t\t\t\t\t\tnext_floor = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct pos{\n\tint sw, x, y, f;\n\tpos(){}\n\tpos(int s, int a, int b, int c){\n\t\tsw = s, x = a, y = b, f = c;\n\t}\n};\n\nint W, H;\nchar M[55][55];\nint S;\nint MS[10][55][55];\nint sx, sy;\nint dist[1024][55][55][2];\nqueue<pos> Q;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nint bfs()\n{\n\tfor(int i = 0; i < 1024; i++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tdist[i][x][y][0] = dist[i][x][y][1] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdist[0][sx][sy][0] = 0;\n\tQ.push( pos(0, sx, sy, 0) );\n\t\n\tpos v;\n\tint sw, f, x, y;\n\tint nsw, nf, nx, ny;\n\tchar c, nc;\n\twhile(Q.size()){\n\t\tv = Q.front(), Q.pop();\n\t\tsw = v.sw, f = v.f, x = v.x, y = v.y;\n\t\tfor(int dir = 0; dir < 4; dir++){\n\t\t\tnx = x + dx[dir], ny = y + dy[dir];\n\t\t\tnc = M[nx][ny];\n\t\t\tif(nc == '#') continue;\n\t\t\tif(nc == '_' || nc == '%' || nc == '&' || (nc >= 'a' && nc <= 'j') ) nf = 0;\n\t\t\telse nf = 1;\n\t\t\tfor(int i = 0; i < S; i++){\n\t\t\t\tif(sw & (1 << i) && MS[i][nx][ny]) nf = !nf;\n\t\t\t}\n\t\t\tif(nc == '|') nf = f;\n\t\t\tif(nc == '|' || f == nf){\n\t\t\t\tif(dist[sw][nx][ny][nf] < inf) continue;\n\t\t\t\tdist[sw][nx][ny][nf] = dist[sw][x][y][f] + 1;\n\t\t\t\tif(nc == '&') return dist[sw][nx][ny][nf];\n\t\t\t\tQ.push( pos(sw, nx, ny, nf) );\n\t\t\t}\n\t\t}\n\t\tc = M[x][y];\n\t\tif(c == '|'){\n\t\t\tif(dist[sw][x][y][!f] == inf){\n\t\t\t\tdist[sw][x][y][!f] = dist[sw][x][y][f] + 1;\n\t\t\t\tQ.push( pos(sw, x, y, !f) );\n\t\t\t}\n\t\t}\n\t\tif( (c >= 'a' && c <= 'j') || (c >= 'A' && c <= 'J') ){\n\t\t\tif(c >= 'a') c -= 'a' - 'A';\n\t\t\tint b = c - 'A';\n\t\t\tif(sw & (1 << b)) nsw = sw & ~(1<<b);\n\t\t\telse nsw = sw | (1<<b);\n\t\t\t\n\t\t\tnf = f;\n\t\t\tif(MS[b][x][y]) nf = !nf;\n\t\t\t\n\t\t\tif(dist[nsw][x][y][nf] == inf){\n\t\t\t\tdist[nsw][x][y][nf] = dist[sw][x][y][f] + 1;\n\t\t\t\tQ.push( pos(nsw, x, y, nf) );\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void)\n{\n\tcin >> W >> H;\n\tfor(int y = 0; y < H; y++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> M[x][y];\n\t\t\tif(M[x][y] == '%') sx = x, sy = y;\n\t\t}\n\t}\n\tcin >> S;\n\tchar tmp;\n\tfor(int s = 0; s < S; s++){\n\t\tfor(int y = 0; y < H; y++){\n\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\tcin >> tmp;\n\t\t\t\tif(tmp == '*') MS[s][x][y] = 1;\n\t\t\t\telse MS[s][x][y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << bfs() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 55, ST = 1 << 10, dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}, INF = 1000000000, Q = ST * N * N / 10;\nint n, m, sx, sy, ex, ey, k, qhead, qtail, q[Q][4], dis[N][N][2][ST];\nchar map[N][N], col[10][N][N], pre[ST][N][N];\n\nvoid change (char &grid) {\n\tif (grid == '^') {\n\t\tgrid = '_';\n\t} else if (grid == '_') {\n\t\tgrid = '^';\n\t}\n\tif (grid >= 'a' && grid <= 'j') {\n\t\tgrid = 'A' + grid - 'a';\n\t} else if (grid >= 'A' && grid <= 'J') {\n\t\tgrid = 'a' + grid - 'A';\n\t}\n}\n\nint height (const char &a) {\n\treturn a == '_' || a >= 'a' && a <= 'j' ? 0 : 1;\n}\n\nint shift (const char &a) {\n\tif (a >= 'a' && a <= 'j') return a - 'a';\n\tif (a >= 'A' && a <= 'J') return a - 'A';\n\treturn -1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%s\", map[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (map[i][j] == '%') {\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}\n\t\t\tif (map[i][j] == '&') {\n\t\t\t\tex = i;\n\t\t\t\tey = j;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tscanf(\"%s\", col[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1 << k; ++i) {\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\tpre[i][r][c] = map[r][c];\n\t\t\t\tif (pre[i][r][c] == '%' || pre[i][r][c] == '&') pre[i][r][c] = '_';\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tfor (int r = 0; r < n; ++r) {\n\t\t\t\t\tfor (int c = 0; c < m; ++c) {\n\t\t\t\t\t\tif (col[j][r][c] == '*') {\n\t\t\t\t\t\t\tchange(pre[i][r][c]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = 0; x < n; ++x) {\n\t\tfor (int y = 0; y < m; ++y) {\n\t\t\tfor (int z = 0; z < 2; ++z) {\n\t\t\t\tfor (int st = 0; st < 1 << k; ++st) {\n\t\t\t\t\tdis[x][y][z][st] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdis[sx][sy][0][0] = 0;\n\tqhead = 0; qtail = 1; q[1][0] = sx; q[1][1] = sy; q[1][2] = 0; q[1][3] = 0;\n\twhile (qhead != qtail) {\n\t\t++qhead;\n\t\tif (qhead == Q) qhead = 0;\n\t\tint nx = q[qhead][0], ny = q[qhead][1], nz = q[qhead][2], nst = q[qhead][3];\n//cout << nx << ' ' << ny << ' ' << nz << ' ' << pre[nst][nx][ny] << ' ' << height(pre[nst][nx][ny]) << ' ' << shift(pre[nst][nx][ny]) << endl;\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint tx = nx + dx[d], ty = ny + dy[d];\n\t\t\tif (tx >= 0 && tx < n && ty >= 0 && ty < m && pre[nst][tx][ty] != '#' && (pre[nst][tx][ty] == '|' || height(pre[nst][tx][ty]) == nz) && dis[tx][ty][nz][nst] == INF) {\n\t\t\t\tdis[tx][ty][nz][nst] = dis[nx][ny][nz][nst] + 1;\n\t\t\t\t++qtail; if (qtail == Q) qtail = 0;\n\t\t\t\tq[qtail][0] = tx; q[qtail][1] = ty; q[qtail][2] = nz; q[qtail][3] = nst;\n\t\t\t}\n\t\t}\n\t\tif (map[nx][ny] == '|' && dis[nx][ny][nz ^ 1][nst] == INF) {\n\t\t\tdis[nx][ny][nz ^ 1][nst] = dis[nx][ny][nz][nst] + 1;\n\t\t\t++qtail; if (qtail == Q) qtail = 0;\n\t\t\tq[qtail][0] = nx; q[qtail][1] = ny; q[qtail][2] = nz ^ 1; q[qtail][3] = nst;\n\t\t}\n\t\tif (shift(pre[nst][nx][ny]) != -1) {\n\t\t\tint tst = nst ^ (1 << shift(pre[nst][nx][ny])), tz = nz;\n\t\t\tif (pre[tst][nx][ny] != '|') tz = height(pre[tst][nx][ny]);\n\t\t\tif (dis[nx][ny][tz][tst] == INF) {\n\t\t\t\tdis[nx][ny][tz][tst] = dis[nx][ny][nz][nst] + 1;\n\t\t\t\t++qtail; if (qtail == Q) qtail = 0;\n\t\t\t\tq[qtail][0] = nx; q[qtail][1] = ny; q[qtail][2] = tz; q[qtail][3] = tst;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int z = 0; z < 2; ++z) {\n\t\tfor (int st = 0; st < 1 << k; ++st) {\n\t\t\tans = min(ans, dis[ex][ey][z][st]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{\n  int y,x,f,bit;\n};\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint H,W,N;\nchar t[50][50];\nint T[50][50];\nint u[50][50];\nint sy,sx,gy,gx;\nint d[50][50][2][(1<<10)];\n\nint solve(){\n  memset(d,-1,sizeof(d));\n  d[sy][sx][0][0]=0;\n  queue< state > Q;\n  Q.push((state){sy,sx,0,0});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    int y=s.y,x=s.x,f=s.f,bit=s.bit;\n    int cost=d[y][x][f][bit];\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      int key=__builtin_popcount(u[ny][nx]&bit);\n      if(t[ny][nx]=='#')continue;\n      key=(key+T[ny][nx])%2;\n      if(t[ny][nx]!='|'&&f!=key)continue;\n      if(d[ny][nx][f][bit]!=-1)continue;\n      d[ny][nx][f][bit]=cost+1;\n      Q.push((state){ny,nx,f,bit});\n    }\n    \n    if('a'<=t[y][x]&&t[y][x]<='z'){\n      int c=t[y][x]-'a';\n      int nbit=bit^(1<<c);\n      int nf=f;\n      if(u[y][x]>>c&1)nf=1-nf;\n      if(d[y][x][nf][nbit]==-1){\n        d[y][x][nf][nbit]=cost+1;\n        Q.push((state){y,x,nf,nbit});\n      }\n    }\n    \n    if('A'<=t[y][x]&&t[y][x]<='Z'){\n      int c=t[y][x]-'A';\n      int nbit=bit^(1<<c);\n      int nf=f;\n      if(u[y][x]>>c&1)nf=1-nf;\n      if(d[y][x][nf][nbit]==-1){\n        d[y][x][nf][nbit]=cost+1;\n        Q.push((state){y,x,nf,nbit});\n      }\n    }\n\n    if(t[y][x]=='|'&&d[y][x][1-f][bit]==-1){\n      d[y][x][1-f][bit]=cost+1;\n      Q.push((state){y,x,1-f,bit});\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='%'){\n        sy=i,sx=j;\n      }\n      if(t[i][j]=='&'){\n        gy=i,gx=j;\n      }\n      T[i][j]=0;\n      if('A'<=t[i][j]&&t[i][j]<='Z')T[i][j]=1;\n      if(t[i][j]=='^')T[i][j]=1;\n    }\n  }\n  \n  char ch;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<H;j++){\n      for(int k=0;k<W;k++){\n        cin>>ch;\n        if(ch=='*')u[j][k]|=(1<<i);\n      }\n    }\n  }\n\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_SIZE = 50;\nconstexpr int MAX_S = 10;\n\nint w, h;\nint sx, sy, gx, gy;\n\nstring field[MAX_SIZE];\nbool initial_floar[MAX_SIZE][MAX_SIZE];\nint match[MAX_SIZE][MAX_SIZE];\nint dist[MAX_SIZE][MAX_SIZE][2][1 << MAX_S];\n\nbool get_floor(int x, int y, int s) {\n\treturn (__builtin_popcount(match[y][x] & s) + initial_floar[y][x]) & 1;\n}\n\nint bfs() {\n\ttypedef tuple<int, int, bool, int> state; // x, y, floor, switch state\n\tconstexpr int dx[] = {1, 0, -1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tqueue<state> que;\n\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INT_MAX);\n\tdist[sy][sx][0][0] = 0;\n\tque.push(state(sx, sy, 0, 0));\n\n\twhile(!que.empty()) {\n\t\tint x, y, s;\n\t\tbool f;\n\t\ttie(x, y, f, s) = que.front();\n\t\tque.pop();\n\n\t\tconst int &d = dist[y][x][f][s];\n\n\t\tdump(x, y, f, s, d);\n\n\t\tif(field[y][x] == '|') {\n\t\t\tif(dist[y][x][!f][s] > d + 1) {\n\t\t\t\tif(x == gx && y == gy && f == 1) return d + 1;\n\t\t\t\tdist[y][x][!f][s] = d + 1;\n\t\t\t\tque.push(state(x, y, !f, s));\n\t\t\t}\n\t\t}\n\n\t\tif(islower(field[y][x])) {\n\t\t\tconst int next_s = s ^ (1 << (field[y][x] - 'a'));\n\t\t\tconst int next_f = get_floor(x, y, next_s);\n\n\t\t\tif(dist[y][x][next_f][next_s] > d + 1) {\n\t\t\t\tdist[y][x][next_f][next_s] = d + 1;\n\t\t\t\tque.push(state(x, y, next_f, next_s));\n\t\t\t}\n\t\t}\n\n\t\trep(dir, 4) {\n\t\t\tconst int nx = x + dx[dir];\n\t\t\tconst int ny = y + dy[dir];\n\n\t\t\tif(field[ny][nx] == '#') continue;\n\t\t\tif(field[ny][nx] != '|' && f != get_floor(nx, ny, s)) continue;\n\n\t\t\tif(dist[ny][nx][f][s] > d + 1) {\n\t\t\t\tif(nx == gx && ny == gy && f == 0) return d + 1;\n\t\t\t\tdist[ny][nx][f][s] = d + 1;\n\t\t\t\tque.push(state(nx, ny, f, s));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> w >> h;\n\n\trep(i, h) {\n\t\tcin >> field[i];\n\n\t\trep(j, w) {\n\t\t\tswitch(field[i][j]) {\n\t\t\tcase '%':\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tinitial_floar[i][j] = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(isupper(field[i][j])) {\n\t\t\t\t\tinitial_floar[i][j] = 1;\n\t\t\t\t\tfield[i][j] += 'a' - 'A';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint s;\n\tcin >> s;\n\n\trep(k, s) {\n\t\trep(i, h) {\n\t\t\tstring row;\n\t\t\tcin >> row;\n\n\t\t\trep(j, w) {\n\t\t\t\tif(row[j] == '*') {\n\t\t\t\t\tmatch[i][j] |= (1 << k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << bfs() << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<queue>\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint w,h,s;\nstring g[50],ms[10][50];\nbool f[1<<10][50][50];\nint d[1<<10][2][50][50];\nint sx,sy;\nint dy[] = { -1,0,1,0}, dx[] = {0,1,0,-1};\n\n\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++){\n    cin >> g[i];\n    for(int j=0;j<w;j++){\n      if(g[i][j] == '%'){\n\tsy = i;\n\tsx = j;\n      }\n    }\n  }\n\n  cin >> s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++)cin >> ms[i][j];\n\n  for(int i=0;i<(1<<s);i++){\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n\td[i][0][j][k] = d[i][1][j][k] = -1;\n\tbool t = false;\n\tfor(int l=0;l<s;l++){\n\t  if( (i>>l)&1 ){\n\t    if(ms[l][j][k] == '*')t = !t;\n\t  }\n\t}\n\tf[i][j][k] = t;\n      }\n    }\n  }\n\n  queue<P2> q;\n  q.push(P2(P(0,0),P(sy,sx)));\n  d[0][0][sy][sx] = 0;\n\n  while(q.size()){\n    P2 p = q.front(); q.pop();\n    int s = p.fs.fs, fl = p.fs.sc, y = p.sc.fs, x = p.sc.sc;\n\n    for(int i=0;i<4;i++){\n      int ty = y + dy[i], tx = x + dx[i];\n      if(g[ty][tx] == '#')continue;\n\n      bool now = f[s][ty][tx];\n      //cout << now << \" \" << ty << \" \" << tx << endl;\n      if( (now == fl) && g[ty][tx] == '&'){\n\tcout << d[s][fl][y][x] + 1 << endl;\n\treturn 0;\n      }\n      if( (now == fl) && g[ty][tx] == '^')continue;\n      if( (now == fl) && 'A'<= g[ty][tx] && g[ty][tx] <= 'J')continue;\n      if( (now != fl) && g[ty][tx] == '_')continue;\n      if( (now != fl) && 'a'<= g[ty][tx] && g[ty][tx] <= 'j')continue;\n      if( (now != fl) && (g[ty][tx] == '&' || g[ty][tx] == '%') )continue;\n\n      if(d[s][fl][ty][tx]<0){\n\td[s][fl][ty][tx] = d[s][fl][y][x] + 1;\n\tq.push(P2(P(s,fl),P(ty,tx)));\n      }\n    }\n\n    if( (g[y][x] == '|') && (d[s][1-fl][y][x] < 0) ){\n      d[s][1-fl][y][x] = d[s][fl][y][x] + 1;\n      q.push(P2(P(s,1-fl),P(y,x)));\n    }\n\n    bool now = f[s][y][x];\n    if( (now==fl) && 'a'<=g[y][x] && g[y][x]<='j'){\n      int tmp = g[y][x] - 'a';\n      int st = s ^ (1<<tmp);\n      int tfl = fl;\n      if(ms[tmp][y][x] == '*')tfl = 1-fl;\n      if(d[st][tfl][y][x]<0){\n\td[st][tfl][y][x] = d[s][fl][y][x] + 1;\n\tq.push(P2(P(st,tfl),P(y,x)));\n      }\n    }\n    if( (now!=fl) && 'A'<=g[y][x] && g[y][x]<='J'){\n      int tmp = g[y][x] - 'A';\n      int st = s ^ (1<<tmp);\n      int tfl = fl;\n      if(ms[tmp][y][x] == '*')tfl = 1-fl;\n      if(d[st][tfl][y][x]<0){\n\td[st][tfl][y][x] = d[s][fl][y][x] + 1;\n\tq.push(P2(P(st,tfl),P(y,x)));\n      }\n    }\n  }\n  cout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define fprintf(...) void(0)\n\nconst int INF = 1 << 28;\nint board[1 << 10][55][55];\nint switch_loc[15][55][55], switch_map[15][55][55], switch_id[55][55];\nint dist[1 << 10][55][55][2];\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nint get_alph(char c) {\n    if('a' <= c && c <= 'z') return c - 'a';\n    return c - 'A';\n}\n\nint get_swid(int id) {\n    static const int shift_sw = 2;\n    return shift_sw + id;\n}\n\nint dec_swid(int id) {\n    static const int shift_sw = 2;\n    return id - shift_sw;\n}\n\nstruct Elem {\n    int state, x, y, f, cost;\n};\n\nconst int WALL   = -1;\nconst int STAIR  = -2;\nconst int FIRST  = 0;\nconst int SECOND = 1;\n\nint W, H;\nint main() {\n    memset(switch_id, -1, sizeof(switch_id));\n    fill(dist[0][0][0], dist[1 << 10][0][0], INF);\n    scanf(\"%d%d\", &W, &H);\n\n    int sx, sy, gx, gy;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            char chr; scanf(\" %c\", &chr);\n\n            if(chr == '%') {\n                sx = i, sy = j;\n                board[0][i][j] = FIRST;\n            }\n            else if(chr == '&') {\n                gx = i, gy = j;\n                board[0][i][j] = FIRST;\n            }\n            else if(chr == '#') {\n                board[0][i][j] = WALL;\n            }\n            else if(chr == '|') {\n                board[0][i][j] = STAIR;\n            }\n            else if(chr == '_') {\n                board[0][i][j] = FIRST;\n            }\n            else if(chr == '^') {\n                board[0][i][j] = SECOND;\n            }\n            else {\n                int alph = get_alph(chr);\n                switch_loc[alph][i][j] = true;\n                switch_id[i][j] = alph;\n                if(islower(chr)) {\n                    board[0][i][j] = FIRST;\n                }\n                else {\n                    board[0][i][j] = SECOND;\n                }\n            }\n        }\n    }\n\n    int S; scanf(\"%d\", &S);\n    for(int id=0; id<S; id++) {\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                char chr; scanf(\" %c\", &chr);\n                if(chr == '*') {\n                    switch_map[id][i][j] = true;\n                }\n            }\n        }\n    }\n\n    for(int bit=0; bit<(1<<S); bit++) {\n        int mod2[55][55] = {};\n        for(int id=0; id<S; id++) {\n            if(bit >> id & 1) {\n                for(int i=0; i<H; i++) {\n                    for(int j=0; j<W; j++) {\n                        if(switch_map[id][i][j]) mod2[i][j] ^= 1;\n                    }\n                }\n            }\n        }\n\n        fprintf(stderr, \"bit = %d\\n\", bit);\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                int num = board[0][i][j];\n                if(num == WALL || num == STAIR) {\n                    board[bit][i][j] = num;\n                }\n                else {\n                    board[bit][i][j] = num ^ mod2[i][j];\n                }\n                fprintf(stderr, \"%2d \", board[bit][i][j]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n    }\n\n    queue<Elem> que;\n    dist[0][sx][sy][0] = 0;\n\n    // state, x, y, f, cost\n    que.push(Elem{0, sx, sy, 0, 0});\n\n    int ans = INF;\n    while(que.size()) {\n        Elem cur = que.front(); que.pop();\n        int x = cur.x, y = cur.y, f = cur.f, bit = cur.state, cost = cur.cost;\n\n        if(x == gx && y == gy) {\n            ans = min(ans, cost);\n        }\n        if(cost > dist[bit][x][y][f]) continue;\n\n        // printf(\"x = %d, y = %d, bit = %d, step = %d, floor = %d\\n\", x, y, bit, cost, f);\n\n        // move\n        for(int k=0; k<4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(board[bit][nx][ny] == WALL) continue;\n\n            // move\n            if(board[bit][nx][ny] == f || board[bit][nx][ny] == STAIR) {\n                if(dist[bit][nx][ny][f] > cost + 1) {\n                    dist[bit][nx][ny][f] = cost + 1;\n                    que.push(Elem{bit, nx, ny, f, cost + 1});\n                }\n            }\n\n            // stair\n            if(board[bit][nx][ny] == STAIR) {\n                if(dist[bit][nx][ny][f^1] > cost + 2) {\n                    dist[bit][nx][ny][f^1] = cost + 2;\n                    que.push(Elem{bit, nx, ny, f^1, cost + 2});\n                }\n            }\n        }\n\n        // switch\n        if(switch_id[x][y] >= 0) {\n            int id = switch_id[x][y];\n            int nbit = bit ^ (1 << id);\n\n            int nf = board[nbit][x][y];\n            if(dist[nbit][x][y][nf] > cost + 1) {\n                dist[nbit][x][y][nf] = cost + 1;\n                que.push(Elem{nbit, x, y, nf, cost + 1});\n            }\n        }\n    }\n\n    printf(\"%d\\n\", ans == INF ? -1 : ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//åç©ã dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//å¤ç©ãcross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//ç·åã¨ç¹ã®è·é¢\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//ç·åã®äº¤å·®å¤å®\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//ç·åã®äº¤ç¹\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//ç·åã¨ç·åã®è·é¢\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//åã¨åã®äº¤ç¹\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nint grid[2][50][50];\nint dp[2][50][50][(1 << 10)];\nint cnt[50][50];\nint cnter(int a) {\n    int ans = 0;\n    REP(t, 20) {\n        if ((1 << t) & a) {\n            ans++;\n        }\n    }\n    return ans;\n}\nvoid solve(){\n    int w, h;\n    cin >> w >> h;\n    REP(i, 2) {\n        REP(q, 50) {\n            REP(j, 50) {\n                REP(t, (1 << 10)) {\n                    dp[i][q][j][t] = 1e9;\n                }\n            }\n        }\n    }\n    queue<tuple<int, int, int, int>> next;\n    tuple<int, int, int> goal;\n    REP(i, h) {\n        string s;\n        cin >> s;\n        REP(q, w) {\n            if (s[q] == '|') {\n                grid[0][i][q] = 1;\n                grid[1][i][q] = 1;\n            }\n            if (s[q] == '_') {\n                grid[0][i][q] = 2;\n            }\n            if (s[q] == '^') {\n                grid[1][i][q] = 2;\n            }\n            if (s[q] == '%') {\n                grid[0][i][q] = 2;\n                dp[0][i][q][0] = 0;\n                next.push(make_tuple(0, i, q, 0));\n            }\n            if (s[q] == '&') {\n                grid[0][i][q] = 2;\n                goal = make_tuple(0, i, q);\n            }\n            if (s[q] >= 'a' && s[q] <= 'z') {\n                grid[0][i][q] = 3 + s[q] - 'a';\n            }\n            if (s[q] >= 'A' && s[q] <= 'Z') {\n                grid[1][i][q] = 3 + s[q] - 'A';\n            }\n        }\n    }\n    int s;\n    cin >> s;\n    REP(tea, s) {\n        REP(i, h) {\n            string b;\n            cin >> b;\n            REP(q, w) {\n                if (b[q] != '.') {\n                    cnt[i][q] |= (1 << tea);\n                }\n            }\n        }\n    }\n    while (next.empty() == false) {\n        tuple<int, int, int, int> now = next.front();\n        next.pop();\n        int cost = dp[get<0>(now)][get<1>(now)][get<2>(now)][get<3>(now)] + 1;\n        if (grid[0][get<1>(now)][get<2>(now)] == 1) {\n            if (dp[(get<0>(now) + 1) % 2][get<1>(now)][get<2>(now)][get<3>(now)] == 1e9) {\n                dp[(get<0>(now) + 1) % 2][get<1>(now)][get<2>(now)][get<3>(now)] = cost;\n                next.push(make_tuple((get<0>(now) + 1) % 2, get<1>(now), get<2>(now), get<3>(now)));\n            }\n        }\n        if (grid[(get<0>(now) + cnter(cnt[get<1>(now)][get<2>(now)] & get<3>(now))) % 2][get<1>(now)][get<2>(now)] >= 3) {\n            int target = grid[(get<0>(now) + cnter(cnt[get<1>(now)][get<2>(now)] & get<3>(now))) % 2][get<1>(now)][get<2>(now)];\n            target -= 3;\n            int nexts = get<0>(now);\n            if ((1 << target) & cnt[get<1>(now)][get<2>(now)]) {\n                nexts++;\n                nexts %= 2;\n            }\n            if (dp[nexts][get<1>(now)][get<2>(now)][get<3>(now) ^ (1 << target)] == 1e9) {\n                dp[nexts][get<1>(now)][get<2>(now)][get<3>(now) ^ (1 << target)] = cost;\n                next.push(make_tuple(nexts, get<1>(now), get<2>(now), get<3>(now) ^ (1 << target)));\n            }\n        }\n        const int dx[4] = { 1,0,-1,0 };\n        const int dy[4] = { 0,1,0,-1 };\n        REP(t, 4) {\n            int x = dx[t] + get<1>(now);\n            int y = dy[t] + get<2>(now);\n            if (x >= 0 && x < h && y >= 0 && y < w) {\n                if (dp[get<0>(now)][x][y][get<3>(now)] != 1e9) continue;\n                if (grid[(get<0>(now) + cnter(cnt[x][y] & get<3>(now))) % 2][x][y] >= 1) {\n                    dp[get<0>(now)][x][y][get<3>(now)] = cost;\n                    next.push(make_tuple(get<0>(now), x, y, get<3>(now)));\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    REP(i, (1 << s)) {\n        ans = min(ans, dp[0][get<1>(goal)][get<2>(goal)][i]);\n        ans = min(ans, dp[1][get<1>(goal)][get<2>(goal)][i]);\n    }\n    if (ans == 1e9) ans = -1;\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10;\nconst int MAXH = 51;\nconst int MAXW = 51;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint H, W, si, sj, gi, gj;\nchar G[MAXH][MAXW];\nint S;\nint T[MAXN][MAXH][MAXW];\nint F[1<<MAXN][MAXH][MAXW];\nint cost[1<<MAXN][2][MAXH][MAXW];\n\nstruct State {\n  int s, f, i, j;\n};\n\nint bfs() {\n  queue<State> que;\n  memset(cost, -1, sizeof(cost));\n  State src = {0, 0, si, sj};\n  que.push(src);\n  cost[src.s][src.f][src.i][src.j] = 0;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(s.i == gi && s.j == gj) return cost[s.s][s.f][s.i][s.j];\n    for(int k = 0; k < 4; ++k) {\n      const State t = {s.s, s.f, s.i + di[k], s.j + dj[k]};\n      if(t.i < 0 || t.i >= H) continue;\n      if(t.j < 0 || t.j >= W) continue;\n      if(G[t.i][t.j] == '#') continue;\n      if(G[t.i][t.j] != '|' && F[t.s][t.i][t.j] != t.f) continue;\n      if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n      que.push(t);\n      cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n    }\n\n    if(isalpha(G[s.i][s.j]))\n      do {\n        int id = toupper(G[s.i][s.j]) - 'A';\n        int ns = s.s ^ (1 << id);\n        const State t = {ns, F[ns][s.i][s.j], s.i, s.j};\n        if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n        que.push(t);\n        cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n      } while(0);\n\n    if(G[s.i][s.j] == '|')\n      do {\n        const State t = {s.s, s.f ^ 1, s.i, s.j};\n        if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n        que.push(t);\n        cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n      } while(0);\n  }\n  return -1;\n}\n\nbool getFloor(char c) {\n  if(isalpha(c)) return isupper(c);\n  if(c == '_') return 0;\n  if(c == '^') return 1;\n  return 0;\n}\n\nint main() {\n  while(cin >> W >> H) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == '%') {\n          G[i][j] = '_';\n          si = i;\n          sj = j;\n        }\n        if(G[i][j] == '&') {\n          G[i][j] = '_';\n          gi = i;\n          gj = j;\n        }\n      }\n    }\n    cin >> S;\n    for(int k = 0; k < S; ++k) {\n      for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n          char c; cin >> c;\n          T[k][i][j] = (c == '*');\n        }\n      }\n    }\n    for(int b = 0; b < (1<<S); ++b) {\n      for(int i = 0; i < H; ++i){\n        for(int j = 0; j < W; ++j) {\n          F[b][i][j] = getFloor(G[i][j]);\n          for(int k = 0; k < S; ++k){\n            if(b >> k & 1); else continue;\n            F[b][i][j] ^= T[k][i][j];\n          }\n        }\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int inf=1<<28;\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nstring board[55];\nstring tmp[10][55];\nbool sw[1024][55][55];\n\nint dist[55][55][2][1024];\n\nint main(void){\n\tint w,h;\n\tcin >> w >> h;\n\trep(i,h) cin >> board[i];\n\n\tint s;\n\tcin >> s;\n\trep(idx,s)rep(i,h) cin >> tmp[idx][i];\n\n\n\trep(mask,1<<s){\n\t\trep(i,h)rep(j,w) sw[mask][i][j]=false;\n\t\trep(idx,s) if(mask&bit(idx)) rep(i,h)rep(j,w) if(tmp[idx][i][j]=='*') sw[mask][i][j]^=true;\n\t}\n\n\trep(i,h)rep(j,w)rep(d,2)rep(mask,1<<s) dist[i][j][d][mask]=inf;\n\t\n\tusing state=tuple<int,int,int,int>;\n\tint si=-1,sj=-1;\n\trep(i,h)rep(j,w) if(board[i][j]=='%') si=i,sj=j;\n\n\tdist[si][sj][0][0]=0;\n\tqueue<state> q;\n\tq.push(state(si,sj,0,0));\n\n\twhile(!q.empty()){\n\t\tint ci,cj,cd,cmask;\n\t\ttie(ci,cj,cd,cmask)=q.front();q.pop();\n\t\t//cout << ci << \" \" << cj << \" \" << cd << \" \" << cmask << endl;\n\t\trep(d,4){\n\t\t\tconst int ni=ci+dy[d],nj=cj+dx[d],nd=cd,nmask=cmask;\n\t\t\tif(board[ni][nj]=='#') continue;\n\t\t\t\n\t\t\tint tar=-1;\n\t\t\tif(board[ni][nj]=='_'||islower(board[ni][nj])||board[ni][nj]=='%'||board[ni][nj]=='&') tar=1;\n\t\t\tif(board[ni][nj]=='^'||isupper(board[ni][nj])) tar=2;\n\t\t\tif(tar!=-1) tar^=(3*sw[nmask][ni][nj]);\n\t\t\tif(board[ni][nj]=='|') tar=3;\n\t\t\t\n\t\t\tif((tar&bit(nd))==0) continue;\n\t\t\tif(chmin(dist[ni][nj][nd][nmask],dist[ci][cj][cd][cmask]+1))\n\t\t\t\tq.push(state(ni,nj,nd,nmask));\n\t\t}\n\n\t\tif(board[ci][cj]=='|'){\n\t\t\tconst int ni=ci,nj=cj,nd=cd^1,nmask=cmask;\n\t\t\tif(chmin(dist[ni][nj][nd][nmask],dist[ci][cj][cd][cmask]+1))\n\t\t\t\tq.push(state(ni,nj,nd,nmask));\n\t\t}\n\n\t\tif(isalpha(board[ci][cj])){\n\t\t\tint idx=tolower(board[ci][cj])-'a';\n\t\t\tconst int ni=ci,nj=cj;\n\t\t\tconst int nmask=cmask^bit(idx);\n\t\t\tconst int nd=cd^(sw[cmask][ni][nj]^sw[nmask][ni][nj]);\n\t\t\tif(chmin(dist[ni][nj][nd][nmask],dist[ci][cj][cd][cmask]+1))\n\t\t\t\tq.push(state(ni,nj,nd,nmask));\n\t\t}\n\t}\n\n\tint gi=-1,gj=-1;\n\trep(i,h)rep(j,w) if(board[i][j]=='&') gi=i,gj=j;\n\tint ans=inf;\n\trep(d,2)rep(mask,1<<s) chmin(ans,dist[gi][gj][d][mask]);\n\tif(ans==inf) ans=-1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10;\nconst int MAXH = 51;\nconst int MAXW = 51;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint H, W, si, sj, gi, gj;\nchar G[MAXH][MAXW];\nint S;\nint T[MAXN][MAXH][MAXW];\nint F[1<<MAXN][MAXH][MAXW];\nint cost[1<<MAXN][2][MAXH][MAXW];\n\nstruct State {\n  int s, f, i, j;\n};\n\nint bfs() {\n  queue<State> que;\n  memset(cost, -1, sizeof(cost));\n  State src = {0, 0, si, sj};\n  que.push(src);\n  cost[src.s][src.f][src.i][src.j] = 0;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(s.i == gi && s.j == gj) return cost[s.s][s.f][s.i][s.j];\n    for(int k = 0; k < 4; ++k) {\n      const State t = {s.s, s.f, s.i + di[k], s.j + dj[k]};\n      if(t.i < 0 || t.i >= H) continue;\n      if(t.j < 0 || t.j >= W) continue;\n      if(G[t.i][t.j] == '#') continue;\n      if(G[t.i][t.j] != '|' && F[t.s][t.i][t.j] != t.f) continue;\n      if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n      que.push(t);\n      cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n    }\n    if(isalpha(G[s.i][s.j])) {\n      int id = toupper(G[s.i][s.j]) - 'A';\n      int ns = s.s ^ (1 << id);\n      const State t = {ns, F[ns][s.i][s.j], s.i, s.j};\n      if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n      que.push(t);\n      cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n    }\n    if(G[s.i][s.j] == '|') {\n      const State t = {s.s, s.f ^ 1, s.i, s.j};\n      if(cost[t.s][t.f][t.i][t.j] != -1) continue;\n      que.push(t);\n      cost[t.s][t.f][t.i][t.j] = cost[s.s][s.f][s.i][s.j] + 1;\n    }\n  }\n  return -1;\n}\n\nint getFloor(char c) {\n  if(isalpha(c)) return isupper(c);\n  if(c == '_') return 0;\n  if(c == '^') return 1;\n  return 0;\n}\n\nint main() {\n  while(cin >> W >> H) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == '%') {\n          G[i][j] = '_';\n          si = i;\n          sj = j;\n        }\n        if(G[i][j] == '&') {\n          G[i][j] = '_';\n          gi = i;\n          gj = j;\n        }\n      }\n    }\n    cin >> S;\n    for(int k = 0; k < S; ++k) {\n      for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n          char c; cin >> c;\n          T[k][i][j] = (c == '*');\n        }\n      }\n    }\n    for(int b = 0; b < (1<<S); ++b) {\n      for(int i = 0; i < H; ++i){\n        for(int j = 0; j < W; ++j) {\n          F[b][i][j] = getFloor(G[i][j]);\n          for(int k = 0; k < S; ++k){\n            if(b >> k & 1); else continue;\n            F[b][i][j] ^= T[k][i][j];\n          }\n        }\n      }\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint w, h, s;\nint st, go;\nchar m[50][50], tmp[50][50];\nchar ms[10][50][50];\nint dp[(1<<10)*2*50*50+2*50*50+50*50+50];\nvector<int> e[(1<<10)*2*50*50+2*50*50+50*50+50];\n\nint main(){\n\trep(i,(1<<10)*2*50*50+2*50*50+50*50+50) dp[i] = INF;\n\tcin >> w >> h;\n\trep(i,h) rep(j,w){\n\t\tcin >> m[i][j];\n\t\tif(m[i][j] == '%'){\n\t\t\tst = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t\tif(m[i][j] == '&'){\n\t\t\tgo = i*50+j;\n\t\t\tm[i][j] = '_';\n\t\t}\n\t}\n\tcin >> s;\n\trep(i,s) rep(j,h) rep(k,w) cin >> ms[i][j][k];\n\trep(i,(1<<s)){\n\t\trep(j,h) rep(k,w) tmp[j][k] = m[j][k];\n\t\tint I = i;\n\t\trep(j,s){\n\t\t\tif(I&1){\n\t\t\t\trep(k,h) rep(l,w){\n\t\t\t\t\tif(ms[j][k][l] == '*'){\n\t\t\t\t\t\tif(tmp[k][l] == '_') tmp[k][l] = '^';\n\t\t\t\t\t\telse if(tmp[k][l] == '^') tmp[k][l] = '_';\n\t\t\t\t\t\telse if('a' <= tmp[k][l] && tmp[k][l] <= 'z'){\n\t\t\t\t\t\t\ttmp[k][l] = toupper(tmp[k][l]);\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\ttmp[k][l] = tolower(tmp[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tI >>= 1;\n\t\t}\n\t\trep(j,h) rep(k,w){\n\t\t\tif(tmp[j][k] == '#') continue;\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '_' || ('a' <= tmp[j][k]&&tmp[j][k] <= 'z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '_' || ('a' <= tmp[J][K]&&tmp[J][K] <= 'z')){\n\t\t\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|' || tmp[j][k] == '^' || ('A' <= tmp[j][k]&&tmp[j][k] <= 'Z')){\n\t\t\t\trep(l,4){\n\t\t\t\t\tint J = j+dh[l], K = k+dw[l];\n\t\t\t\t\tif(0 > J || J >= h) continue;\n\t\t\t\t\tif(0 > K || K >= w) continue;\n\t\t\t\t\tif(tmp[J][K] == '|' || tmp[J][K] == '^' || ('A' <= tmp[J][K]&&tmp[J][K] <= 'Z')){\n\t\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*50+50*J+K);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp[j][k] == '|'){\n\t\t\t\te[i*2*50*50+50*j+k].push_back(i*2*50*50+50*50+50*j+k);\n\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back(i*2*50*50+50*j+k);\n\t\t\t}\n\t\t\tif('a' <= tmp[j][k] && tmp[j][k] <= 'z'){\n\t\t\t\tint z = tmp[j][k]-'a';\n\t\t\t\tint flo = 0;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 1;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif('A' <= tmp[j][k] && tmp[j][k] <= 'Z'){\n\t\t\t\tint z = tmp[j][k] - 'A';\n\t\t\t\tint flo = 1;\n\t\t\t\tif(ms[z][j][k] == '*') flo = 0;\n\t\t\t\tif(i&(1<<z)){\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i-(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t} else{\n\t\t\t\t\te[i*2*50*50+50*50+50*j+k].push_back((i+(1<<z))*2*50*50+flo*50*50+50*j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> que;\n\tque.push(st);\n\tdp[st] = 0;\n\twhile(!que.empty()){\n\t\tint q = que.front();\n\t\tque.pop();\n\t\trep(i,e[q].size()){\n\t\t\tif(dp[e[q][i]] != INF) continue;\n\t\t\tdp[e[q][i]] = dp[q]+1;\n\t\t\tque.push(e[q][i]);\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,(1<<10)*2*50*50+2*50*50+50*50+50){\n\t\tif(i%(50*50) != go) continue;\n\t\tans = min(ans,dp[i]);\n\t}\n\tif(ans == INF) ans = -1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#define INF 1e8\nusing namespace std;\nint w,h,s;\nint sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nstruct data{\n\tint f,x,y,bit;\n\tdata(){}\n\tdata(int ff,int xx,int yy,int bbit){\n\t\tf=ff;\n\t\tx=xx;\n\t\ty=yy;\n\t\tbit=bbit;\n\t}\n};\n\nint dp[2][51][51][1<<10];\nint fie[51][51];\nint change[11][51][51];\nint where[1<<10][51][51];\nint bfs(){\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=50;j++){\n\t\t\tfor(int k=0;k<=50;k++){\n\t\t\t\tfor(int l=0;l<(1<<s);l++){\n\t\t\t\t\tdp[i][j][k][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<data> que;\n\tque.push(data(0,sx,sy,0));\n\tdp[0][sx][sy][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.front();\n\t\tque.pop();\n\t\tif(q.x==gx && q.y==gy)return dp[q.f][q.x][q.y][q.bit];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=q.x+dx[i],ny=q.y+dy[i];\n\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(where[q.bit][nx][ny]!=q.f && fie[nx][ny]!=-2)continue;\n\t\t\t\tif(dp[q.f][nx][ny][q.bit]==INF){\n\t\t\t\t\tdp[q.f][nx][ny][q.bit]=dp[q.f][q.x][q.y][q.bit]+1;\n\t\t\t\t\tque.push(data(q.f,nx,ny,q.bit));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(fie[q.x][q.y]==-2){\n\t\t\tif(dp[1-q.f][q.x][q.y][q.bit]==INF){\n\t\t\t\tdp[1-q.f][q.x][q.y][q.bit]=dp[q.f][q.x][q.y][q.bit]+1;\n\t\t\t\tque.push(data(1-q.f,q.x,q.y,q.bit));\n\t\t\t}\n\t\t}\n\t\tif(fie[q.x][q.y]>=0 && fie[q.x][q.y]<=19){\n\t\t\tint nbit=q.bit^(1<<(fie[q.x][q.y]%10));\n\t\t\tif(dp[where[nbit][q.x][q.y]][q.x][q.y][nbit]==INF){\n\t\t\t\tdp[where[nbit][q.x][q.y]][q.x][q.y][nbit]=dp[q.f][q.x][q.y][q.bit]+1;\n\t\t\t\tque.push(data(where[nbit][q.x][q.y],q.x,q.y,nbit));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&w,&h);\n\tfor(int i=0;i<h;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[j]=='#')fie[j][i]=-1;\n\t\t\tif(str[j]=='|')fie[j][i]=-2;\n\t\t\tif(str[j]=='%'){\n\t\t\t\tsx=j,sy=i;\n\t\t\t\tfie[j][i]=-3;\n\t\t\t}\n\t\t\tif(str[j]=='&'){\n\t\t\t\tgx=j,gy=i;\n\t\t\t\tfie[j][i]=-4;\n\t\t\t}\n\t\t\tif(str[j]>='a' && str[j]<='j'){\n\t\t\t\tfie[j][i]=str[j]-'a';\n\t\t\t}\n\t\t\tif(str[j]>='A' && str[j]<='J'){\n\t\t\t\tfie[j][i]=str[j]-'A'+10;\n\t\t\t}\n\t\t\tif(str[j]=='_')fie[j][i]=-5;\n\t\t\tif(str[j]=='^')fie[j][i]=-6;\n\t\t}\n\t}\n\tscanf(\"%d\",&s);\n\tfor(int i=0;i<s;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\tif(str[k]=='#')change[i][k][j]=-1;\n\t\t\t\tif(str[k]=='|')change[i][k][j]=-2;\n\t\t\t\tif(str[k]=='*')change[i][k][j]=1;\n\t\t\t\tif(str[k]=='.')change[i][k][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<s);i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\tif(fie[k][j]>=10 || fie[k][j]==-6)where[i][k][j]=1;\n\t\t\t\telse where[i][k][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<s;j++){\n\t\t\tif(!(i>>j & 1))continue;\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int l=0;l<w;l++){\n\t\t\t\t\tif(change[j][l][k]==1)where[i][l][k]=1-where[i][l][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n Author : Speedcell\n Update : 2013-05-30\nVersion : soppYcell 2.2(a)\n*/\n\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <memory>\n#include <complex>\n#include <numeric>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <ctype.h>\n#include <locale.h>\n\nusing namespace std;\n\n#pragma pack(4)\n\n#ifndef __CONSTANT__\n#define __CONSTANT__\n\ntypedef long long LONG;\n\nconst double pi = acos(-1.0);\nconst int   inf = 0x7f7f7f7f;\nconst LONG  INF = 0x7f7f7f7f7f7f7f7fll;\n\nconst int go[8][2] = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n\n#endif // __CONSTANT__\n\n#ifndef __IO__\n#define __IO__\n\ninline bool RD(int    & a) {return scanf(\"%d\",&a)!=EOF;}\ninline bool RD(char   & a) {return scanf(\"%c\",&a)!=EOF;}\ninline bool RD(char   * a) {return scanf(\"%s\", a)!=EOF;}\ninline bool RD(double & a) {return scanf(\"%lf\",&a)!=EOF;}\ninline bool RD(LONG   & a) {return scanf(\"%I64d\",&a)!=EOF;}\n\ntemplate<class T1> inline bool\n    IN(T1 & a) {return RD(a);}\ntemplate<class T1,class T2> inline bool\n    IN(T1 & a,T2 & b) {return RD(a)&&RD(b);}\ntemplate<class T1,class T2,class T3> inline bool\n    IN(T1 & a,T2 & b,T3 & c) {return RD(a)&&RD(b)&&RD(c);}\ntemplate<class T1,class T2,class T3,class T4> inline bool\n    IN(T1 & a,T2 & b,T3 & c,T4 & d) {return RD(a)&&RD(b)&&RD(c)&&RD(d);}\ntemplate<class T1,class T2,class T3,class T4,class T5> inline bool\n    IN(T1 & a,T2 & b,T3 & c,T4 & d,T5 & e) {return RD(a)&&RD(b)&&RD(c)&&RD(d)&&RD(e);}\ntemplate<class T1,class T2,class T3,class T4,class T5,class T6> inline bool\n    IN(T1 & a,T2 & b,T3 & c,T4 & d,T5 & e,T6 & f) {return RD(a)&&RD(b)&&RD(c)&&RD(d)&&RD(e)&&RD(f);}\ntemplate<class T1,class T2,class T3,class T4,class T5,class T6,class T7> inline bool\n    IN(T1 & a,T2 & b,T3 & c,T4 & d,T5 & e,T6 & f,T7 & g) {return RD(a)&&RD(b)&&RD(c)&&RD(d)&&RD(e)&&RD(f)&&RD(g);}\n\ninline void PT(int    a) {printf(\"%d\",a);}\ninline void PT(char   a) {printf(\"%c\",a);}\ninline void PT(char * a) {printf(\"%s\",a);}\ninline void PT(double a) {printf(\"%f\",a);}\ninline void PT(LONG   a) {printf(\"%I64d\",a);}\ninline void PT(const char a[]) {printf(\"%s\",a);}\n\ntemplate<class T1> inline void\n    OT(T1 a) {PT(a);}\ntemplate<class T1,class T2> inline void\n    OT(T1 a,T2 b) {PT(a),PT(' '),PT(b);}\ntemplate<class T1,class T2,class T3> inline void\n    OT(T1 a,T2 b,T3 c) {PT(a),PT(' '),PT(b),PT(' '),PT(c);}\ntemplate<class T1,class T2,class T3,class T4> inline void\n    OT(T1 a,T2 b,T3 c,T4 d) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d);}\ntemplate<class T1,class T2,class T3,class T4,class T5> inline void\n    OT(T1 a,T2 b,T3 c,T4 d,T5 e) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT(' '),PT(e);}\ntemplate<class T1,class T2,class T3,class T4,class T5,class T6> inline void\n    OT(T1 a,T2 b,T3 c,T4 d,T5 e,T6 f) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT(' '),PT(e),PT(' '),PT(f);}\ntemplate<class T1,class T2,class T3,class T4,class T5,class T6,class T7> inline void\n    OT(T1 a,T2 b,T3 c,T4 d,T5 e,T6 f,T7 g) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT(' '),PT(e),PT(' '),PT(f),PT(' '),PT(g);}\n\ntemplate<class T1> inline void\n    OL(T1 a) {PT(a),PT('\\n');}\ntemplate<class T1,class T2> inline void\n    OL(T1 a,T2 b) {PT(a),PT(' '),PT(b),PT('\\n');}\ntemplate<class T1,class T2,class T3> inline void\n    OL(T1 a,T2 b,T3 c) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT('\\n');}\ntemplate<class T1,class T2,class T3,class T4> inline void\n    OL(T1 a,T2 b,T3 c,T4 d) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT('\\n');}\ntemplate<class T1,class T2,class T3,class T4,class T5> inline void\n    OL(T1 a,T2 b,T3 c,T4 d,T5 e) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT(' '),PT(e),PT('\\n');}\ntemplate<class T1,class T2,class T3,class T4,class T5,class T6> inline void\n    OL(T1 a,T2 b,T3 c,T4 d,T5 e,T6 f) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT(' '),PT(e),PT(' '),PT(f),PT('\\n');}\ntemplate<class T1,class T2,class T3,class T4,class T5,class T6,class T7> inline void\n    OL(T1 a,T2 b,T3 c,T4 d,T5 e,T6 f,T7 g) {PT(a),PT(' '),PT(b),PT(' '),PT(c),PT(' '),PT(d),PT(' '),PT(e),PT(' '),PT(f),PT(' '),PT(g),PT('\\n');}\n\n#endif // __IO__\n\n#ifndef __MACRO__\n#define __MACRO__\n\n#define ML(times) int tcase; IN(tcase); FOR(times,1,tcase)\n\n#define FOR(i,a,b) for(int i=int(a),_##i=int(b);i<=_##i;i++)\n#define DWN(i,b,a) for(int i=int(b),_##i=int(a);_##i<=i;i--)\n#define ECH(i,u,pre,next) for(int i=int(pre[u]);i!=-1;i=int(next[i]))\n\n#define MEM(a,v) memset(a,v,sizeof(a))\n#define CLR(a,v) FOR(_i##a,0,sizeof(a)/sizeof(a[0])-1) a[_i##a]=v\n\n#define LOOP(a,n)                                               \\\n    FOR(_i##a,0,(n)-1)                                          \\\n        OT(a[_i##a]),OT(_i##a!=__i##a?' ':'\\n')\n#define LOOP2(a,n,m)                                            \\\n    FOR(_i##a,0,(n)-1) FOR(_j##a,0,(m)-1)                       \\\n        OT(a[_i##a][_j##a]),OT(_j##a!=__j##a?' ':'\\n')\n#define LOOPG(G,n,pre,next)                                     \\\n    FOR(_i##a,0,(n)-1) ECH(_j##a,_i##a,pre,next)                \\\n        OL(_i##a,G[_j##a].v,G[_j##a].w)\n\n#endif // __MACRO__\n\n#ifndef __BIT__\n#define __BIT__\n\ntemplate<class T> inline T lb(T i) {return i&-i;}\ntemplate<class T> inline T lc(T i) {return i<<1;}\ntemplate<class T> inline T rc(T i) {return i<<1|1;}\ntemplate<class T> inline T at(T a,int i) {return a& (T(1)<<i);}\ntemplate<class T> inline T nt(T a,int i) {return a^ (T(1)<<i);}\ntemplate<class T> inline T s1(T a,int i) {return a| (T(1)<<i);}\ntemplate<class T> inline T s0(T a,int i) {return a&~(T(1)<<i);}\n\n#endif // __BIT__\n\n#ifndef __DOUBLE__\n#define __DOUBLE__\n\nconst double eps = 1e-8;\n\ninline int cmp(double a,double b=0) {return fabs(b-a)<eps?0:((b-a)<eps?+1:-1);}\n\ninline double smax(double a,double b) {return cmp(b,a)<0?a:b;}\ninline double smin(double a,double b) {return cmp(a,b)<0?a:b;}\ntemplate<typename type> inline type smax(type a,type b) {return b<a?a:b;}\ntemplate<typename type> inline type smin(type a,type b) {return a<b?a:b;}\n\n#endif // __DOUBLE__\n\nconst int MAXV = 51;\nconst int MAXE = 1<<10;\n\nint n,m,s;\nchar a[MAXV][MAXV],b[MAXV][MAXV];\nmap<int,map<int,map<int,bool> > > switcher;//TODO\n\ndeque<int> X,Y,F,B;\nint dis[MAXV][MAXV][2][MAXE];\nbool inq[MAXV][MAXV][2][MAXE];\n\nint floor(int x,int y,int b)\n{\n\tint ans=(a[x][y]=='^'||('A'<=a[x][y]&&a[x][y]<='Z'));\n\tFOR(i,0,s-1) if(at(b,i))\n\t{\n\t\tif(switcher[i][x][y]) ans^=1;\n\t}\n\treturn ans;\n}\nbool sameFloor(int x,int y,int f,int b)\n{\n\tif(a[x][y]=='#') return false;\n\telse if(a[x][y]=='|') return true;\n\telse return floor(x,y,b)==f;\n}\nbool within(int x,int y,int f,int b)\n{\n\tif((0<=x&&x<n)&&(0<=y&&y<m)) return sameFloor(x,y,f,b);\n\telse return false;\n}\n\nvoid update(int xx,int yy,int ff,int bb,int x,int y,int f,int b)\n{\n\tif(dis[xx][yy][ff][bb]>dis[x][y][f][b]+1)\n\t{\n\t\tdis[xx][yy][ff][bb]=dis[x][y][f][b]+1;\n\t\tif(!inq[xx][yy][ff][bb])\n\t\t{\n\t\t\tinq[xx][yy][ff][bb]=true;\n\t\t\tX.push_back(xx);\n\t\t\tY.push_back(yy);\n\t\t\tF.push_back(ff);\n\t\t\tB.push_back(bb);\n\t\t}\n\t}\n}\n\nint SPFA(int x,int y,int f,int b,int tx,int ty)\n{\n\tMEM(dis,inf); dis[x][y][f][b]=0;\n\tMEM(inq,false); inq[x][y][f][b]=true;\n\n\twhile(!X.empty()) X.pop_front();\n\twhile(!Y.empty()) Y.pop_front();\n\twhile(!F.empty()) F.pop_front();\n\twhile(!B.empty()) B.pop_front();\n\tX.push_back(x);\n\tY.push_back(y);\n\tF.push_back(f);\n\tB.push_back(b);\n\n\twhile(!X.empty())\n\t{\n\t\tx=X.front(); X.pop_front();\n\t\ty=Y.front(); Y.pop_front();\n\t\tf=F.front(); F.pop_front();\n\t\tb=B.front(); B.pop_front();\n\t\tinq[x][y][f][b]=false;\n\t\tif(x==tx&&y==ty&&sameFloor(tx,ty,f,b)) return dis[x][y][f][b];\n\t\tFOR(i,0,3)\n\t\t{\n\t\t\tint xx=x+go[i][0];\n\t\t\tint yy=y+go[i][1];\n\t\t\tif(within(xx,yy,f,b)) update(xx,yy,f,b,x,y,f,b);\n\t\t}\n\t\tif(a[x][y]=='|')\n\t\t\tupdate(x,y,!f,b,x,y,f,b);\n\t\tif(sameFloor(x,y,f,b)&&'a'<=a[x][y]&&a[x][y]<='z')\n\t\t\tupdate(x,y,f^switcher[a[x][y]-'a'][x][y],nt(b,a[x][y]-'a'),x,y,f,b);\n\t\tif(sameFloor(x,y,f,b)&&'A'<=a[x][y]&&a[x][y]<='Z')\n\t\t\tupdate(x,y,f^switcher[a[x][y]-'A'][x][y],nt(b,a[x][y]-'A'),x,y,f,b);\n\t}\n\n\tint ans=inf;\n\tFOR(i,0,((1<<s)-1))\n\t{\n\t\tans=smin(ans,dis[tx][ty][floor(tx,ty,i)][i]);\n\t}\n\treturn ans==inf?-1:ans;\n}\n\nint main()\n{\n    while(IN(m,n))\n\t{\n\t\tFOR(i,0,n-1)\n\t\t{\n\t\t\tgetchar();\n\t\t\tIN(a[i]);\n\t\t}\n\t\tIN(s);\n\t\tswitcher.clear();\n\t\tFOR(k,0,s-1)\n\t\t{\n\t\t\tFOR(i,0,n-1)\n\t\t\t{\n\t\t\t\tgetchar();\n\t\t\t\tIN(b[i]);\n\t\t\t}\n\t\t\tFOR(i,0,n-1) FOR(j,0,m-1)\n\t\t\t{\n\t\t\t\tif(b[i][j]=='*')\n\t\t\t\t{\n\t\t\t\t\tswitcher[k][i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x,y,tx,ty;\n\t\tFOR(i,0,n-1) FOR(j,0,m-1)\n\t\t{\n\t\t\tif(a[i][j]=='%')\n\t\t\t{\n\t\t\t\tx=i;\n\t\t\t\ty=j;\n\t\t\t}\n\t\t\telse if(a[i][j]=='&')\n\t\t\t{\n\t\t\t\ttx=i;\n\t\t\t\tty=j;\n\t\t\t}\n\t\t}\n\t\tOL(SPFA(x,y,0,0,tx,ty));\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int W, H;\n    vector<string> M;\n    int S;\n    vector< vector<string> > MS;\n    void input() {\n        cin >> W >> H;\n        M.clear(); M.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> M[i];\n        }\n        cin >> S;\n        MS.clear(); MS.resize(S);\n        for (int i = 0; i < S; i++) {\n            MS[i].clear(); MS[i].resize(H);\n            for (int j = 0; j < H; j++) {\n                cin >> MS[i][j];\n            }\n        }\n    }\n\n    const int dy[] = {-1, 0, 1, 0};\n    const int dx[] = {0, 1, 0, -1};\n\n    string to_s(int n) {\n        string ret;\n        for (int i = 0; i < S; i++) {\n            ret.push_back( (n & (1 << i)) ? '1' : '0' );\n        }\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n\n    struct P {\n        int y, x, floor;\n        int t;\n        int bit;\n        P() {}\n        P(int y, int x, int floor, int bit, int t) : y(y), x(x), floor(floor), t(t), bit(bit) {}\n    };\n    ostream& operator<<(ostream& os, const P& p) {\n        return os << \"P[ (\" << p.y << \",\" << p.x << \",\" << p.floor << \") % \" << to_s(p.bit) << \" \" << p.t << \" ]\";\n    }\n\n    void find_init(P& init) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (M[i][j] == '%') {\n                    init.y = i;\n                    init.x = j;\n                    init.floor = 0;\n                    init.bit = 0;\n                    return;\n                }\n            }\n        }\n    }\n\n    int init_floor(char c) {\n        if (c == '_') return 0;\n        if (c == '^') return 1;\n        if (c == '%') return 0;\n        if (c == '&') return 0;\n        if (isupper(c)) return 1;\n        if (islower(c)) return 0;\n        assert(0);\n    }\n\n    int cfloor(int y, int x, int bit) {\n        char c = M[y][x];\n        int f = init_floor(c);\n        bool flag = false;\n        for (int i = 0; i < S; i++) {\n            if ( (bit & (1 << i)) && MS[i][y][x] == '*' ) {\n                flag = !flag;\n            }\n        }\n        if (flag) return !f;\n        else return f;\n    }\n\n    bool blocked(int y, int x, int floor, int bit) {\n        char c = M[y][x];\n        if (c == '#') return true;\n        if (c == '|') return false;\n        if (cfloor(y, x, bit) != floor) return true;\n        return false;\n    }\n\n    bool visited[51][51][2][1 << 10];\n    void solve() {\n        if (false) {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    char c;\n                    if (M[i][j] == '#') {\n                        c = '#';\n                    } else if (M[i][j] == '|') {\n                        c = '|';\n                    } else {\n                        c = cfloor(i, j, 0) + '0';\n                    }\n                    cout << c << \" \";\n                }\n                cout << endl;\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        P init;\n        find_init(init);\n        queue<P> Q;\n        Q.push(init);\n        visited[init.y][init.x][init.floor][init.bit] = true;\n        bool found = false;\n        while (!Q.empty()) {\n            P c = Q.front(); Q.pop();\n            int y = c.y,\n                x = c.x;\n            if (M[y][x] == '&') {\n                found = true;\n                cout << c.t << endl;\n                break;\n            }\n            for (int i = 0; i < 4; i++) {\n                int ny = y + dy[i],\n                    nx = x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (blocked(ny, nx, c.floor, c.bit)) continue;\n                P next(ny, nx, c.floor, c.bit, c.t + 1);\n                bool& v = visited[ny][nx][c.floor][c.bit];\n                if (v) continue;\n                v = true;\n                //cout << c << \" -> \" << next << endl;\n                Q.push(next);\n            }\n            if (isalpha(M[y][x])) {\n                char cc = tolower(M[y][x]);\n                int s = int(cc - 'a');\n                int nbit = c.bit ^ (1 << s);\n                bool& v = visited[y][x][c.floor][nbit];\n                if (!v) {\n                    v = true;\n                    int nfloor = c.floor;\n                    if (MS[s][y][x] == '*') {\n                        nfloor = !c.floor;\n                    }\n                    Q.push(P(y, x, nfloor, nbit, c.t + 1));\n                }\n            }\n            if ('|' == M[y][x]) {\n                bool& v = visited[y][x][!c.floor][c.bit];\n                if (!v) {\n                    v = true;\n                    Q.push(P(y, x, !c.floor, c.bit, c.t + 1));\n                }\n            }\n        }\n        if (!found) {\n            cout << -1 << endl;\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[60][60];\nint key[11][60][60];\nchar in[60][60];\nint bfs[1<<10][60][60][2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<a;j++)scanf(\"%s\",in[j]);\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++){\n\t\t\tif(in[j][k]=='*')key[i][j][k]=1;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<(1<<c);i++)for(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[i][j][k][0]=bfs[i][j][k][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='%'){\n\t\tbfs[0][i][j][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t}\n\twhile(Q.size()){\n\t\tint v=Q.front().first.first;\n\t\tint f=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!~bfs[v][row+dx[i]][col+dy[i]][f]&&\n\t\t\tstr[row+dx[i]][col+dy[i]]!='#'){\n\t\t\t\tint H=0;if(str[row+dx[i]][col+dy[i]]=='^'||('A'<=str[row+dx[i]][col+dy[i]]&&str[row+dx[i]][col+dy[i]]<='Z'))H=1;\n\t\t\t\tfor(int j=0;j<c;j++)if((v&(1<<j))&&key[j][row+dx[i]][col+dy[i]])H=!H;\n\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='|'||H==f){\n\t\t\t\t\tbfs[v][row+dx[i]][col+dy[i]][f]=bfs[v][row][col][f]+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(v,f),make_pair(row+dx[i],col+dy[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str[row][col]=='|'&&!~bfs[v][row][col][!f]){\n\t\t\tbfs[v][row][col][!f]=bfs[v][row][col][f]+1;\n\t\t\tQ.push(make_pair(make_pair(v,!f),make_pair(row,col)));\n\t\t}\n\t\tif('a'<=(32|str[row][col])&&(32|str[row][col])<='z'){\n\t\t\tint H=f;\n\t\t\tif(key[(32|str[row][col])-'a'][row][col])H=!H;\n\t\t\tint to=v^(1<<((32|str[row][col])-'a'));\n\t\t\tif(!~bfs[to][row][col][H]){\n\t\t\t\tbfs[to][row][col][H]=bfs[v][row][col][f]+1;\n\t\t\t\tQ.push(make_pair(make_pair(to,H),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='&'){\n\t\tfor(int k=0;k<(1<<c);k++){\n\t\t\tint H=0;\n\t\t\tfor(int l=0;l<c;l++)if((k&(1<<l))&&key[l][i][j])H=!H;\n\t\t\tif(~bfs[k][i][j][H])ret=min(ret,bfs[k][i][j][H]);\n\t\t}\n\t}\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dp[50][50][2][1<<10];\nchar m[50][50];\nchar ms[50][50][10];\nstruct st{\n  int y,x,f,b;\n  st(){}\n  st(int y,int x,int f,int b):y(y),x(x),f(f),b(b){}\n};\nint main(){\n  memset(m,'#',sizeof(m));\n  memset(ms,'#',sizeof(ms));\n  int w,h,s;\n  int sy,sx,gy,gx;\n  cin>>w>>h;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin>>m[i][j];\n      if(m[i][j]=='%') sy=i,sx=j,m[i][j]='.';\n      if(m[i][j]=='&') gy=i,gx=j,m[i][j]='.';\n    }\n  cin>>s;\n  for(int k=0;k<s;k++)\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>ms[i][j][k];\n  memset(dp,-1,sizeof(dp));\n  queue<st> q;\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n  q.push(st(sy,sx,0,0));\n  int ans=-1;\n  while(!q.empty()){\n    st p=q.front();q.pop();\n    if(dp[p.y][p.x][p.f][p.b]<0) dp[p.y][p.x][p.f][p.b]=0;\n    int ny,nx,nf,nb,nd=dp[p.y][p.x][p.f][p.b]+1;\n    //cout<<p.y<<\" \"<<p.x<<\" \"<<p.f<<\" \"<<p.b<<\":\"<<nd-1<<endl;\n    ny=p.y;nx=p.x;nf=p.f;nb=p.b;\n    if(ny==gy&&nx==gx){\n      ans=dp[ny][nx][nf][nb];\n      break;\n    }\n    if(m[p.y][p.x]=='|'){\n      ny=p.y;nx=p.x;nf=!p.f;nb=p.b;\n      if(dp[ny][nx][nf][nb]<0){\n\tdp[ny][nx][nf][nb]=nd;\n\tq.push(st(ny,nx,nf,nb));\n      }\n    }\n    if(isalpha(m[p.y][p.x])){\n      int c=m[p.y][p.x]-'A';\n      if(islower(m[p.y][p.x])) c+='A'-'a';\n      ny=p.y;nx=p.x;nf=p.f;nb=p.b;\n      if((nb>>c)&1) nb-=1<<c;\n      else nb+=1<<c;\n      if(ms[ny][nx][c]=='*') nf=!nf;\n      if(dp[ny][nx][nf][nb]<0){\n\tdp[ny][nx][nf][nb]=nd;\n\tq.push(st(ny,nx,nf,nb));\n      }\n    }\n    for(int k=0;k<4;k++){\n      ny=p.y+ay[k];nx=p.x+ax[k];nf=p.f;nb=p.b;\n      if(m[ny][nx]=='#') continue;\n      int f=isupper(m[ny][nx])||m[ny][nx]=='^';\n      for(int i=0;i<s;i++)\n\t(f+=(nb>>i&1)&&ms[ny][nx][i]=='*')%=2;\n      if((f==nf||m[ny][nx]=='|')&&dp[ny][nx][nf][nb]<0){\n\tdp[ny][nx][nf][nb]=nd;\n\tq.push(st(ny,nx,nf,nb));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nbool is_change[10][50][50];\n\nstruct State{\n\tState(int arg_floor,int arg_row,int arg_col,int arg_button_state,int arg_step){\n\t\tfloor = arg_floor;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tbutton_state = arg_button_state;\n\t\tstep = arg_step;\n\t}\n\n\tbool operator<(const struct State &arg) const{\n\t\treturn step > arg.step;\n\t};\n\tint floor,row,col,button_state,step;\n};\n\nint W,H,POW[11],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar first_map[50][51];\n\nint dp[2][51][51][1024];\n\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_map[row][col] == '%'){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t\tfirst_map[row][col] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tfor(int i = 0; i < S; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tis_change[i][row][col] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tchar tmp_map[H][W+1];\n\n\tfor(int i = 0; i < S; i++){\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tscanf(\"%s\",tmp_map[row]);\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(tmp_map[row][col] == '*'){\n\t\t\t\t\tis_change[i][row][col] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfor(int state = 0; state < POW[S]; state++)dp[i][row][col][state] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpriority_queue<State> Q;\n\tdp[0][start_row][start_col][0] = 0;\n\tQ.push(State(0,start_row,start_col,0,0));\n\n\tint calc_map[2][H][W];\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().step > dp[Q.top().floor][Q.top().row][Q.top().col][Q.top().button_state]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tint calc_table[H][W];\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++)calc_table[row][col] = 0;\n\t\t}\n\n\t\tfor(int loop = 0; loop < S; loop++){\n\t\t\tif(Q.top().button_state & (1 << loop)){\n\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\tif(is_change[loop][row][col])calc_table[row][col]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = max(0,Q.top().row-1); row <= min(Q.top().row+1,H-1); row++){\n\t\t\tfor(int col = max(0,Q.top().col-1); col <= min(Q.top().col+1,W-1); col++){\n\t\t\t\tswitch(first_map[row][col]){\n\t\t\t\tcase '#':\n\t\t\t\t\tcalc_map[0][row][col] = '#';\n\t\t\t\t\tcalc_map[1][row][col] = '#';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tcalc_map[0][row][col] = '|';\n\t\t\t\t\tcalc_map[1][row][col] = '|';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '&';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '&';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(first_map[row][col] >= 'a' && first_map[row][col] <= 'j'){\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col];\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col]-32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col]+32;\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\tif(Q.top().floor == 0){\n\n\t\t\t\tif(calc_map[0][adj_row][adj_col] == '_'){\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] >= 'a' && calc_map[0][adj_row][adj_col] <= 'j'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'a';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tif(is_change[num][adj_row][adj_col]){\n\t\t\t\t\t\tnext_floor = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(calc_map[1][adj_row][adj_col] == '^'){\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] >= 'A' && calc_map[1][adj_row][adj_col] <= 'J'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'A';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tif(is_change[num][adj_row][adj_col]){\n\t\t\t\t\t\tnext_floor = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nint w,h,s;\nstring mp[N];\nstring sw[11][N];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n \nbool check(int x,int y,int f,int bit){\n  if(mp[y][x]=='#')return 0;\n \n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n \n  char ch = mp[y][x];\n  if((cnt+f)%2==0)\n    if(isupper(ch)||ch=='^')return 0;\n  \n  if((cnt+f)%2==1)\n    if(islower(ch)||ch=='_'||ch=='&'||ch=='%')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n \nint used[N][N][2][1<<10];\nstruct dat{int x,y,f,bit,cost;};\nint bfs(int sx,int sy){\n  queue<dat> Q;\n  Q.push((dat){sx,sy,0,0,0});\n  \n  while(!Q.empty()){\n    dat t=Q.front();Q.pop();\n    int x=t.x,y=t.y,f=t.f,bit=t.bit,cost=t.cost;\n    if(mp[y][x]=='&')return cost;\n    if(used[x][y][f][bit]++) continue;\n    \n    if(mp[y][x]=='|') Q.push((dat){x,y,!f,bit,cost+1});\n    int th=mp[y][x]-(isupper(mp[y][x])? 'A':'a');\n    if(isalpha(mp[y][x]))Q.push((dat){x,y,(sw[th][y][x]=='*')?!f:f,nbit(bit,th),cost+1});\n    \n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(check(nx,ny,f,bit))Q.push((dat){nx,ny,f,bit,cost+1});\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')cout<<bfs(j,i)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\nint d[] = { 0, 1, 0, -1, 0 };\n\nint main() {\n    int w, h, s;\n    cin >> w >> h;\n    vector<string> m(h);\n    int si, sj;\n    for (int i = 0; i < h; ++i) {\n        cin >> m[i];\n        for (int j = 0; j < w; ++j) {\n            if (m[i][j] == '%') {\n                si = i;\n                sj = j;\n            }\n        }\n    }\n    cin >> s;\n    vector<vector<string>> ms(max(s, 1), vector<string>(h));\n    for (int i = 0; i < s; ++i) {\n        for (int j = 0; j < h; ++j) {\n            cin >> ms[i][j];\n        }\n    }\n    vector<vector<vector<int>>> isup(h, vector<vector<int>>(w, vector<int>(1 << s)));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (m[i][j] == '#' || m[i][j] == '|') continue;\n\n            for (int k = 0; k < (1 << s); ++k) {\n                int up = m[i][j] == '^' || m[i][j] >= 'A' && m[i][j] <= 'Z';\n                for (int l = 0; l < s; ++l) {\n                    if (((k >> l) & 1) && ms[l][i][j] == '*')\n                        up ^= 1;\n                }\n                isup[i][j][k] = up;\n            }\n        }\n    }\n\n    queue<int> qi, qj, qs, qh;\n    vector<vector<vector<vector<int>>>> dist(h, vector<vector<vector<int>>>(w, vector<vector<int>>(1 << s, vector<int>(2, M))));\n    dist[si][sj][0][0] = 0;\n    qi.push(si);\n    qj.push(sj);\n    qs.push(0);\n    qh.push(0);\n    while (!qi.empty()) {\n        int pi = qi.front(), pj = qj.front(), ps = qs.front(), ph = qh.front();\n        qi.pop();\n        qj.pop();\n        qs.pop();\n        qh.pop();\n//        cout << pi << \" \" << pj << \" \" << ps << \" \" << ph << \"\\n\";\n        int dis = dist[pi][pj][ps][ph];\n        if (m[pi][pj] == '&') {\n            cout << dis << \"\\n\";\n            return 0;\n        }\n        if (m[pi][pj] == '|' && dist[pi][pj][ps][1 - ph] > dis + 1) {\n            dist[pi][pj][ps][1 - ph] = dis + 1;\n            qi.push(pi);\n            qj.push(pj);\n            qs.push(ps);\n            qh.push(1 - ph);\n        }\n        else if (m[pi][pj] >= 'A' && m[pi][pj] <= 'Z' || m[pi][pj] >= 'a' && m[pi][pj] <= 'z') {\n            int sw = (m[pi][pj] | 32) - 'a';\n            int ts = ps ^ (1 << sw);\n            int th = (ms[sw][pi][pj] == '*' ? 1 - ph : ph);\n            if (dist[pi][pj][ts][th] > dis + 1) {\n                dist[pi][pj][ts][th] = dis + 1;\n                qi.push(pi);\n                qj.push(pj);\n                qs.push(ts);\n                qh.push(th);\n            }\n        }\n        for (int i = 0; i < 4; ++i) {\n            int ti = pi + d[i], tj = pj + d[i + 1];\n            if (m[ti][tj] != '#' && (m[ti][tj] == '|' || ph == isup[ti][tj][ps]) && dist[ti][tj][ps][ph] > dis + 1) {\n                dist[ti][tj][ps][ph] = dis + 1;\n                qi.push(ti);\n                qj.push(tj);\n                qs.push(ps);\n                qh.push(ph);\n            }\n        }\n    }\n    cout << \"-1\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf = 1 << 30;\nconst ll mod=1000000007LL;\nconst short dx[4]={1,0,-1,0};\nconst short dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<short, short, int, char>;\n\nint min_cost[50][50][1024][2];\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vvi sw_field(h, vi(w));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[y][x] |= (1 << i);\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(State(sx, sy, 0, '_'));\n\n    // vector<vector<vvi>> min_cost(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n    rep(i, h) rep(j, w) rep(k, 1 << n) rep(l, 2) min_cost[i][j][k][l] = inf;\n    min_cost[sy][sx][0][0] = 0;\n\n    while(q.size()){\n        short cx, cy; int cb; char cf;\n        tie(cx, cy, cb, cf) = q.front();\n        q.pop();\n\n        int cfi = (cf == '^');\n\n        if(cx == tx and cy == ty){\n            cout << min_cost[cy][cx][cb][cfi] << endl;\n            return 0;\n        }\n\n        int nc = min_cost[cy][cx][cb][cfi] + 1;\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(chmin(min_cost[cy][cx][cb][nfi], nc)){\n                q.push(State(cx, cy, cb, nf));\n            }\n        }\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[cy][cx] & (1 << idx)){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(chmin(min_cost[cy][cx][nb][nfi], nc)){\n                q.push(State(cx, cy, nb, nf));\n            }\n        }\n\n        rep(i, 4){\n            short nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and chmin(min_cost[ny][nx][cb][cfi], nc)){\n                q.push(State(nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = (__builtin_popcount(sw_field[ny][nx] & cb) % 2 == 1);\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and chmin(min_cost[ny][nx][cb][nfi], nc)){\n                q.push(State(nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\nint d[] = { 0, 1, 0, -1, 0 };\n\nint main() {\n    int w, h, s;\n    cin >> w >> h;\n    vector<string> m(h);\n    int si, sj;\n    for (int i = 0; i < h; ++i) {\n        cin >> m[i];\n        for (int j = 0; j < w; ++j) {\n            if (m[i][j] == '%') {\n                si = i;\n                sj = j;\n            }\n        }\n    }\n    cin >> s;\n    vector<vector<string>> ms(max(s, 1), vector<string>(h));\n    for (int i = 0; i < s; ++i) {\n        for (int j = 0; j < h; ++j) {\n            cin >> ms[i][j];\n        }\n    }\n    vector<vector<vector<bool>>> isup(h, vector<vector<bool>>(w, vector<bool>(1 << s)));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (m[i][j] == '#' || m[i][j] == '|') continue;\n\n            for (int k = 0; k < (1 << s); ++k) {\n                int up = m[i][j] == '^' || m[i][j] >= 'A' && m[i][j] <= 'Z';\n                for (int l = 0; l < s; ++l) {\n                    if (((k >> l) & 1) && ms[l][i][j] == '*')\n                        up ^= 1;\n                }\n                isup[i][j][k] = up;\n            }\n        }\n    }\n\n    queue<int> qi, qj, qs, qh;\n    vector<vector<vector<vector<int>>>> dist(h, vector<vector<vector<int>>>(w, vector<vector<int>>(1 << s, vector<int>(2, M))));\n    dist[si][sj][0][0] = 0;\n    qi.push(si);\n    qj.push(sj);\n    qs.push(0);\n    qh.push(0);\n    while (!qi.empty()) {\n        int pi = qi.front(), pj = qj.front(), ps = qs.front(), ph = qh.front();\n        qi.pop();\n        qj.pop();\n        qs.pop();\n        qh.pop();\n        int dis = dist[pi][pj][ps][ph];\n        if (m[pi][pj] == '&') {\n            cout << dis << \"\\n\";\n            return 0;\n        }\n        if (m[pi][pj] == '|' && dist[pi][pj][ps][1 - ph] > dis + 1) {\n            dist[pi][pj][ps][1 - ph] = dis + 1;\n            qi.push(pi);\n            qj.push(pj);\n            qs.push(ps);\n            qh.push(1 - ph);\n        }\n        else if (m[pi][pj] >= 'A' && m[pi][pj] <= 'Z' || m[pi][pj] >= 'a' && m[pi][pj] <= 'z') {\n            int sw = (m[pi][pj] | 32) - 'a';\n            int ts = ps ^ (1 << sw);\n            int th = (ms[sw][pi][pj] == '*' ? 1 - ph : ph);\n            if (dist[pi][pj][ts][th] > dis + 1) {\n                dist[pi][pj][ts][th] = dis + 1;\n                qi.push(pi);\n                qj.push(pj);\n                qs.push(ts);\n                qh.push(th);\n            }\n        }\n        for (int i = 0; i < 4; ++i) {\n            int ti = pi + d[i], tj = pj + d[i + 1];\n            if (m[ti][tj] != '#' && (m[ti][tj] == '|' || ph == isup[ti][tj][ps]) && dist[ti][tj][ps][ph] > dis + 1) {\n                dist[ti][tj][ps][ph] = dis + 1;\n                qi.push(ti);\n                qj.push(tj);\n                qs.push(ps);\n                qh.push(ph);\n            }\n        }\n    }\n    cout << \"-1\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nstruct State{\n  int x, y, d, S;\n  State () {}\n  State(int x, int y, int d, int S) : \n    x(x), y(y), d(d), S(S) {}\n};\nint dist[50][50][2][1<<10];\nint get_dist(State s){\n  return dist[s.y][s.x][s.d][s.S];\n}\nvoid set_dist(State s, int n){\n  dist[s.y][s.x][s.d][s.S] = n;\n}\nvoid print(State s){\n  //printf(\"x:%d y:%d d:%d S:%d dist:%d\\n\", s.x, s.y, s.d, s.S, get_dist(s));\n}\nint main(){\n  int W, H;\n  while(cin>>W>>H && W){\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    int S; cin>>S;\n    vector<string> sw_grid[10];\n    REP(i, S){\n      sw_grid[i] = vector<string>(H);\n      REP(y, H) cin>>sw_grid[i][y];\n    }\n    queue<State> que;\n    memset(dist, -1, sizeof(dist));\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == '%'){\n        dist[y][x][0][0] = 0;\n        que.push(State(x, y, 0, 0));\n      }\n    }\n    int ans = INF;\n    while(!que.empty()){\n      State now = que.front(); que.pop();\n      print(now);\n      char now_c = grid[now.y][now.x];\n      if(now_c == '&'){\n        ans = get_dist(now);\n        break;\n      }\n      if(now_c == '|'){\n        State next = now;\n        next.d ^= 1;\n        if(get_dist(next) == -1){\n          que.push(next);\n          set_dist(next, get_dist(now) + 1);\n        }\n      }\n      if(isalpha(now_c)){\n        int c_idx = (islower(now_c)) ? (now_c - 'a') : (now_c - 'A');\n        State next = now;\n        next.S ^= (1<<c_idx);\n        if(sw_grid[c_idx][next.y][next.x] == '*'){\n          next.d ^= 1;\n        }\n        if(get_dist(next) == -1){\n          que.push(next);\n          set_dist(next, get_dist(now) + 1);\n        }\n      }\n      REP(r, 4){\n        State next = now;\n        next.x += dx[r];\n        next.y += dy[r];\n        char c = grid[next.y][next.x];\n        int changed = 0;\n        REP(i, 10) if((next.S & (1 << i)) && sw_grid[i][next.y][next.x] == '*') changed ^= 1;\n        if(c == '#') continue;\n        if((islower(c) || c == '_' || c == '&' || c == '%') && changed != next.d) continue;\n        if((isupper(c) || c == '^') && (1 ^ changed) != next.d) continue;\n        if(get_dist(next) == -1){\n          que.push(next);\n          set_dist(next, get_dist(now) + 1);\n        }\n      }\n    }\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'['; rep(i,a.size()) os<<(i?\" \":\"\")<<a[i]; return os<<']';\n}\n\nconst char START='%';\nconst char GOAL='&';\nconst char WALL='#';\nconst char STAIR='|';\nconst char FIRST='_';\nconst char SECOND='^';\n\nconst int INFTY=1<<29;\n\nstruct State{\n\tint i,j;\n\tint floor,sw,weight;\n\tState(){}\n\tState(int i,int j,int f,int s,int w):i(i),j(j),floor(f),sw(s),weight(w){}\n\tbool operator<(const State& s)const{return weight<s.weight;}\n\tbool operator>(const State& s)const{return weight>s.weight;}\n};\n\nvoid solve(vs& grid,pii start,pii goal,vvi& floor,vvi& move,int s)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tstatic int dist[1<<10][3][50][50]; // [sw][floor][i][j]\n\trep(i,1<<s) rep(j,2) rep(k,h) rep(l,w) dist[i][j+1][k][l]=INFTY;\n\t\n\tpriority_queue<State,vector<State>,greater<State> > pq;\n\tpq.push(State(start.first,start.second,1,0,0));\n\twhile(pq.size()){\n\t\tState cur=pq.top(); pq.pop();\n\t\tint ci=cur.i,cj=cur.j;\n\t\tint cf=cur.floor,cs=cur.sw,cw=cur.weight;\n\t\tif(dist[cs][cf][ci][cj]!=INFTY)\n\t\t\tcontinue;\n\t\tdist[cs][cf][ci][cj]=cw;\n\t\t\n\t\t// éæ®µ\n\t\tif(grid[ci][cj]==STAIR)\n\t\t\tpq.push(State(ci,cj,3-cf,cs,cw+1));\n\t\t\n\t\t// ã¹ã¤ãã\n\t\tif(isalpha(grid[ci][cj])){\n\t\t\tchar offset=isupper(grid[ci][cj])?'A':'a';\n\t\t\tint ns=cs^1<<(grid[ci][cj]-offset);\n\t\t\tint nf=cf;\n\t\t\tif(move[ci][cj]>>(grid[ci][cj]-offset)&1)\n\t\t\t\tnf=3-nf;\n\t\t\tpq.push(State(ci,cj,nf,ns,cw+1));\n\t\t}\n\t\t\n\t\t// 4è¿å\n\t\tint di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\trep(k,4){\n\t\t\tint ni=ci+di[k],nj=cj+dj[k];\n\t\t\tif(grid[ni][nj]==WALL) continue;\n\t\t\tif(grid[ni][nj]==STAIR)\n\t\t\t\tpq.push(State(ni,nj,cf,cs,cw+1));\n\t\t\telse{\n\t\t\t\tint nf=floor[ni][nj];\n\t\t\t\tassert(nf==1 || nf==2);\n\t\t\t\trep(i,s) if((cs>>i&1) && (move[ni][nj]>>i&1))\n\t\t\t\t\tnf=3-nf;\n\t\t\t\tif(nf!=cf)\n\t\t\t\t\tcontinue;\n\t\t\t\tpq.push(State(ni,nj,nf,cs,cw+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res=INFTY;\n\trep(i,1<<s) rep(j,2)\n\t\tres=min(res,dist[i][j+1][goal.first][goal.second]);\n\tcout<<(res==INFTY?-1:res)<<endl;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h && w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint s; cin>>s;\n\t\tvector<vs> sws(s,vs(h));\n\t\trep(i,s) rep(j,h) cin>>sws[i][j];\n\t\t\n\t\tpii start,goal;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]==START)\n\t\t\t\tstart=mp(i,j);\n\t\t\tif(grid[i][j]==GOAL)\n\t\t\t\tgoal=mp(i,j);\n\t\t}\n\t\t\n\t\tvvi move(h,vi(w)); // içªç®ã®ã¹ã¤ãããæ¼ããã¨ãã«éãå¤ãããã©ãã\n\t\trep(k,s) rep(i,h) rep(j,w)\n\t\t\tif(sws[k][i][j]=='*')\n\t\t\t\tmove[i][j]|=1<<k;\n\t\t\n\t\tvvi floor(h,vi(w)); // å£ã¨éæ®µã¯0éã¨ãã\n\t\trep(i,h) rep(j,w) if(grid[i][j]!=WALL && grid[i][j]!=STAIR){\n\t\t\tif(grid[i][j]==START || grid[i][j]==GOAL || grid[i][j]==FIRST || islower(grid[i][j]))\n\t\t\t\tfloor[i][j]=1;\n\t\t\telse\n\t\t\t\tfloor[i][j]=2;\n\t\t}\n\t\t\n\t\tsolve(grid,start,goal,floor,move,s);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\nstring sw[11][N];\nint w,h,s;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nbool check(int x,int y,int f,int bit){\n  if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return 0;\n\n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n\n  if((cnt%2==0&&f==0)||(f==1&&cnt%2==1)){\n    if(isupper(mp[y][x])||mp[y][x]=='^')return 0;\n  }\n  else if(islower(mp[y][x])||mp[y][x]=='_')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n\nint used[N][N][2][1<<10],mem[N][N][2][1<<10];\nint dfs(int x,int y,int f,int bit){\n  cout<<x<<\" \"<<y<<\" \"<<f<<\" \"<<bit<<endl;\n  if(mp[y][x] == '&'&&f==0)return 0;\n\n  if(used[x][y][f][bit]++)return mem[x][y][f][bit];\n  int &res=mem[x][y][f][bit]=1e5;\n  \n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(!check(nx,ny,f,bit))continue;\n    int th=mp[ny][nx]-(isupper(mp[ny][nx])? 'A':'a');\n    if(mp[ny][nx]=='|')res=min(res,2+dfs(nx,ny,!f,bit));\n    if(isalpha(mp[ny][nx]))res=min(res,2+dfs(nx,ny,(f+sw[th][ny][nx]=='*')%2,nbit(bit,th)));\n    res=min(res,1+dfs(nx,ny,f,bit));\n  }\n  return res;\n}\n\n\n\n\nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n\n  int ans=1e9;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')ans=dfs(j,i,0,0);\n\n  if(ans>=1e5)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nmap<int, vector<vector<string> > > memo;\n\nclass State\n{\npublic:\n  int x, y, f, s, c;\n  State(int _x, int _y, int _f, int _s, int _c)\n    :x(_x), y(_y), f(_f), s(_s), c(_c) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->c > st.c;\n  }\n};\n\nvoid generate(int idx, int bit, vector<vector<string> > M, const vector<vector<pair<int, int> > >& s, const int S)\n{\n  memo[bit] = M;\n  if (idx >= S)\n    return;\n\n  generate(idx+1, bit, M, s, S);\n  for (unsigned int i = 0; i < s[idx].size(); ++i)\n    swap(M[0][s[idx][i].second][s[idx][i].first], M[1][s[idx][i].second][s[idx][i].first]);\n  generate(idx+1, bit | (1 << idx), M, s, S);\n}\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H) {\n    vector<string> Mi(H);\n    for (int i = 0; i < H; ++i)\n      cin >> Mi[i];\n\n    int sx, sy;\n    vector<vector<string> > M(2, vector<string>(H, string(W, ' ')));\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        if (Mi[i][j] == '_') {\n          M[0][i][j] = '.';\n          M[1][i][j] = '#';\n        } else if (Mi[i][j] == '^') {\n          M[1][i][j] = '.';\n          M[0][i][j] = '#'; \n        } else if (Mi[i][j] == '%') {\n          M[0][i][j] = '.';\n          M[1][i][j] = '#';\n          sx = j;\n          sy = i;\n        } else if (Mi[i][j] == '&') {\n          M[0][i][j] = '&';\n          M[1][i][j] = '#';\n        } else if (isalpha(Mi[i][j])) {\n          if (islower(Mi[i][j])) {\n            M[0][i][j] = Mi[i][j];\n            M[1][i][j] = '#';\n          } else {\n            M[1][i][j] = tolower(Mi[i][j]);\n            M[0][i][j] = '#';\n          }\n        } else {\n          M[0][i][j] = M[1][i][j] = Mi[i][j];\n        }\n      }\n    }\n\n\n    int S;\n    cin >> S;\n    vector<vector<pair<int, int> > > s(S);\n    for (int i = 0; i < S; ++i) {\n      for (int j = 0; j < H; ++j) {\n        string MS;\n        cin >> MS;\n        for (int k = 0; k < W; ++k) {\n          if (MS[k] == '*')\n            s[i].push_back(make_pair(k, j));\n        }\n      }\n    }\n\n    memo.clear();\n    generate(0, 0, M, s, S);\n\n    int ans = -1;\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0, 0, 0));\n    vector<vector<vector<vector<int> > > > dp(1 << S, vector<vector<vector<int> > >(2, vector<vector<int> >(H, vector<int>(W, INF))));\n    while (!que.empty()) {\n      State st = que.top();\n      que.pop();\n\n      if (memo[st.s][st.f][st.y][st.x] == '&') {\n        ans = st.c;\n        break;\n      }\n\n      if (dp[st.s][st.f][st.y][st.x] < st.c)\n        continue;\n      dp[st.s][st.f][st.y][st.x] = st.c;\n\n      for (int d = 0; d < 4; ++d) {\n        int x = st.x + dx[d];\n        int y = st.y + dy[d];\n        if (x < 0 || W <= x || y < 0 || H <= y || memo[st.s][st.f][y][x] == '#')\n          continue;\n        if (dp[st.s][st.f][y][x] > st.c+1) {\n          dp[st.s][st.f][y][x] = st.c+1;\n          que.push(State(x, y, st.f, st.s, st.c+1));\n        }\n      }\n\n      if (memo[st.s][st.f][st.y][st.x] == '|') {\n        st.f ^= 1;\n        if (dp[st.s][st.f][st.y][st.x] > st.c+1) {\n          dp[st.s][st.f][st.y][st.x] = st.c+1;\n          que.push(State(st.x, st.y, st.f, st.s, st.c+1));\n        }\n      } else if (isalpha(memo[st.s][st.f][st.y][st.x])) {\n        int sw = memo[st.s][st.f][st.y][st.x] - 'a';\n        for (unsigned int i = 0; i < s[sw].size(); ++i) {\n          if (st.x == s[sw][i].first && st.y == s[sw][i].second) {\n            st.f ^= 1;\n            break;\n          }\n        }\n        st.s ^= (1 << sw);\n        if (dp[st.s][st.f][st.y][st.x] > st.c+1) {\n          dp[st.s][st.f][st.y][st.x] = st.c+1;\n          que.push(State(st.x, st.y, st.f, st.s, st.c+1));\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int i,j,s,k;\n};\n\nint H,W,S;\nint si,sj,gi,gj;\nstring b[100];\nbool sw[10][100][100];\nint dist[50][50][1<<10][2];\nint dd[]={-1,0,1,0,-1};\n\nint main(){\n  cin>>W>>H;\n  rep(i,H){\n    cin>>b[i];\n    rep(j,W){\n      if(b[i][j]=='%'){\n        si=i; sj=j;\n      }\n      if(b[i][j]=='&'){\n        gi=i; gj=j;\n      }\n    }\n  }\n  cin>>S;\n  rep(s,S){\n    rep(i,H){\n      string in;\n      cin>>in;\n      rep(j,W){\n        if(in[j]=='*'){\n          sw[s][i][j]=true;\n        }\n      }\n    }\n  }\n  queue<state> que;\n  rep(i,H)rep(j,W)rep(s,1<<S)rep(k,2)dist[i][j][s][k]=INF;\n  que.push((state){si,sj,0,0});\n  dist[si][sj][0][0]=0;\n  while(que.size()){\n    state s=que.front(); que.pop();\n    int crtd=dist[s.i][s.j][s.s][s.k];\n    if(s.i==gi&&s.j==gj){\n      cout<<crtd<<endl;\n      return 0;\n    }\n    rep(dir,4){ // move\n      int ni=s.i+dd[dir],nj=s.j+dd[dir+1];\n      if(ni<0||ni>=H||nj<0||nj>=W||b[ni][nj]=='#'||dist[ni][nj][s.s][s.k]!=INF)continue;\n      if(b[ni][nj]=='|'){\n        dist[ni][nj][s.s][s.k]=crtd+1;\n        que.push((state){ni,nj,s.s,s.k});\n        continue;\n      }\n      bool oneortwo=('A'<=b[ni][nj]&&b[ni][nj]<='J')||(b[ni][nj]=='^');\n      rep(i,S){\n        if(((s.s>>i)&1)&&(sw[i][ni][nj]))oneortwo^=true;\n      }\n      if(s.k!=oneortwo)continue;\n      dist[ni][nj][s.s][s.k]=crtd+1;\n      que.push((state){ni,nj,s.s,s.k});\n    }\n    if(b[s.i][s.j]=='|'){ // updown\n      if(dist[s.i][s.j][s.s][1-s.k]==INF){\n        dist[s.i][s.j][s.s][1-s.k]=crtd+1;\n        que.push((state){s.i,s.j,s.s,1-s.k});\n      }\n    }\n    if(isalpha(b[s.i][s.j])){ // switch\n      int knd=b[s.i][s.j]-(b[s.i][s.j]>='a'?'a':'A');\n      int nxtk=(sw[knd][s.i][s.j]?1-s.k:s.k);\n      int nxts=s.s^(1<<knd);\n      if(dist[s.i][s.j][nxts][nxtk]==INF){\n        dist[s.i][s.j][nxts][nxtk]=crtd+1;\n        que.push((state){s.i,s.j,nxts,nxtk});\n      }\n    }\n  }\n  cout<<-1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int short\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, char>;\n\nsigned main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(State(sx, sy, 0, '_'));\n\n    vector<vector<vvi>> min_cost(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n    min_cost[sy][sx][0][0] = 0;\n\n    while(q.size()){\n        int cx, cy, cb; char cf;\n        tie(cx, cy, cb, cf) = q.front();\n        q.pop();\n\n        int cfi = (cf == '^');\n\n        if(cx == tx and cy == ty){\n            cout << min_cost[cy][cx][cb][cfi] << endl;\n            return 0;\n        }\n\n        int nc = min_cost[cy][cx][cb][cfi] + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(chmin(min_cost[cy][cx][nb][nfi], nc)){\n                q.push(State(cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(chmin(min_cost[cy][cx][cb][nfi], nc)){\n                q.push(State(cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and chmin(min_cost[ny][nx][cb][cfi], nc)){\n                q.push(State(nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and chmin(min_cost[ny][nx][cb][nfi], nc)){\n                q.push(State(nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, char>;\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(State(sx, sy, 0, '_'));\n\n    vector<vector<vvi>> min_cost(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n    min_cost[sy][sx][0][0] = 0;\n\n    while(q.size()){\n        int cx, cy, cb; char cf;\n        tie(cx, cy, cb, cf) = q.front();\n        q.pop();\n\n        int cfi = (cf == '^');\n\n        if(cx == tx and cy == ty){\n            cout << min_cost[cy][cx][cb][cfi] << endl;\n            return 0;\n        }\n\n        int nc = min_cost[cy][cx][cb][cfi] + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(chmin(min_cost[cy][cx][nb][nfi], nc)){\n                q.push(State(cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(chmin(min_cost[cy][cx][cb][nfi], nc)){\n                q.push(State(cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and chmin(min_cost[ny][nx][cb][cfi], nc)){\n                q.push(State(nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and chmin(min_cost[ny][nx][cb][nfi], nc)){\n                q.push(State(nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {-1, 0, 1, 0};\n\nint W, H, S;\nstring M[50], MS[10][50];\nint bit[50][50], v[2][50][50][1 << 10];\nint mov[50][50];\n\nint Solve()\n{\n  memset(v, -1, sizeof(v));\n  for(int k = 0; k < S; k++) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(MS[k][i][j] == '*') bit[j][i] |= 1 << k;\n      }\n    }\n  }\n  queue< tuple< int, int, int, int > > que;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      switch(M[i][j]) {\n        case '|':\n          mov[j][i] = 3;\n          break;\n        case '_':\n          mov[j][i] = 1;\n          break;\n        case '^':\n          mov[j][i] = 2;\n          break;\n        case 'a' ... 'j':\n          mov[j][i] = 1;\n          M[i][j] -= 'a';\n          break;\n        case 'A' ... 'J':\n          mov[j][i] = 2;\n          M[i][j] -= 'A';\n          break;\n        case '%':\n          que.emplace(0, j, i, 0);\n          v[0][j][i][0] = 0;\n          mov[j][i] = 1;\n          break;\n        case '&':\n          mov[j][i] = 1;\n          break;\n        default:\n          mov[j][i] = 0;\n          break;\n      }\n    }\n  }\n\n  while(!que.empty()) {\n    int f, x, y, button;\n    tie(f, x, y, button) = que.front();\n    que.pop();\n    if(M[y][x] == '&') {\n      return (v[f][x][y][button]);\n    } else if(M[y][x] == '|') {\n      int nf = f ^ 1;\n      if(v[nf][x][y][button] == -1) {\n        v[nf][x][y][button] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, button);\n      }\n    } else if(M[y][x] < 10) {\n      int nbutton = button ^ (1 << M[y][x]);\n      int nf = (f + ((bit[x][y] >> M[y][x]) & 1)) & 1;\n      if(v[f][x][y][nbutton] == -1) {\n        v[nf][x][y][nbutton] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, nbutton);\n      }\n    }\n    for(int i = 0; i < 4; i++) {\n      int nx = x + vx[i], ny = y + vy[i];\n      int isgo = (f + __builtin_popcount(bit[nx][ny] & button)) & 1;\n      if(v[f][nx][ny][button] == -1 && (mov[nx][ny] & ++isgo)) {\n        v[f][nx][ny][button] = v[f][x][y][button] + 1;\n        que.emplace(f, nx, ny, button);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    cin >> M[i];\n  }\n  cin >> S;\n  for(int i = 0; i < S; i++) {\n    for(int j = 0; j < H; j++) {\n      cin >> MS[i][j];\n    }\n  }\n  cout << Solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\nstring sw[11][N];\nint w,h,s;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n \nbool check(int x,int y,int f,int bit){\n  if(mp[y][x]=='#')return 0;\n \n  int cnt=0;\n  for(int i=0;i<s;i++)\n    if((bit>>i)&1)cnt+=sw[i][y][x]=='*';\n \n  char ch = mp[y][x];\n  if((cnt+f)%2==0)\n    if(isupper(ch)||ch=='^')return 0;\n  \n  if((cnt+f)%2==1)\n    if(islower(ch)||ch=='_'||ch=='&'||ch=='%')return 0;\n  return 1;\n}\n\nint nbit(int bit,int x){\n  if((bit>>x)&1) return ~((~bit)|(1<<x));\n  return bit|(1<<x);\n}\n \nint used[N][N][2][1<<10],mem[N][N][2][1<<10];\nstruct dat{int x,y,f,bit,cost;};\nint bfs(int sx,int sy){\n  queue<dat> Q;\n  Q.push((dat){sx,sy,0,0,0});\n  \n  while(!Q.empty()){\n    dat t=Q.front();Q.pop();\n    int x=t.x,y=t.y,f=t.f,bit=t.bit,cost=t.cost;\n    if(mp[y][x]=='&')return cost;\n    if(used[x][y][f][bit]++) continue;\n    mem[x][y][f][bit]=cost;\n\n    if(mp[y][x]=='|') Q.push((dat){x,y,!f,bit,cost+1});\n    int th=mp[y][x]-(isupper(mp[y][x])? 'A':'a');\n    if(isalpha(mp[y][x]))Q.push((dat){x,y,(sw[th][y][x]=='*')?!f:f,nbit(bit,th),cost+1});\n    \n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(check(nx,ny,f,bit))Q.push((dat){nx,ny,f,bit,cost+1});\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cin>>s;\n  for(int i=0;i<s;i++)\n    for(int j=0;j<h;j++) cin>>sw[i][j];\n \n  int ans=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]=='%')cout<<bfs(j,i)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cctype>\n#include <cstdio>\nusing namespace std;\n\nclass State{\npublic:\n  int f, x, y, bit, cost;\n\n  State(int _f, int _x, int _y, int _bit, int _cost){\n    f = _f;\n    x = _x;\n    y = _y;\n    bit = _bit;\n    cost = _cost;\n  }\n\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint w, h, n, sx, sy;\nchar t[52][52];\nchar s[12][52][52];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool closed[2][52][52][1024];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed, 0, sizeof(closed));\n  open.push(State(0, sx, sy, 0, 0));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.f][st.y][st.x][st.bit]){\n      continue;\n    }\n    closed[st.f][st.y][st.x][st.bit] = true;\n\n    if(t[st.y][st.x] == '&'){\n      cout << st.cost << endl;\n      return;\n    }\n\n    if(t[st.y][st.x] == '|'){\n      open.push(State(!st.f, st.x, st.y, st.bit, st.cost + 1));\n    }\n\n    if(isalpha(t[st.y][st.x])){\n      int sw = t[st.y][st.x] - (isupper(t[st.y][st.x]) ? 'A' : 'a');\n      int nf = st.f;\n      int nx = st.x;\n      int ny = st.y;\n      int nbit = st.bit ^ (1 << sw);\n      int ncost = st.cost + 1;\n\n      if(s[sw][st.y][st.x] == '*'){\n\tnf = !nf;\n      }\n\n      open.push(State(nf, nx, ny, nbit, ncost));\n    }\n\n    for(int i = 0; i < 4; i++){\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n\n      if(t[ny][nx] == '#') continue;\n\n      int nf = (t[ny][nx] == '^' || isupper(t[ny][nx]) ? 1 : 0);\n\n      for(int j = 0; (1 << j) <= st.bit; j++){\n\tif( !( st.bit & (1 << j) ) ) continue;\n\tif(s[j][ny][nx] == '*'){\n\t  nf = !nf;\n\t}\n      }\n\n      if(t[ny][nx] != '|' && st.f != nf) continue;\n\n      open.push(State(st.f, nx, ny, st.bit, st.cost + 1));\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main() {\n  while(cin >> w >> h){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n\n      for(int j = 0; j < w; j++){\n\tif(t[i][j] == '%'){\n\t  sx = j;\n\t  sy = i;\n\t}\n      }\n    }\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < h; j++){\n\tcin >> s[i][j];\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\n#define PUSH(r, c, f, m) do{\t\t\t\\\n    rs.push(r);\t\t\t\t\t\\\n    cs.push(c);\t\t\t\t\t\\\n    fs.push(f); \t\t\t\t\\\n    ms.push(m); \t\t\t\t\\\n  }while(0)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint W, H, S;\nchar I[55][55];\nbool M[10][55][55];\nint  D[2][55][55][1 << 10];\n\ninline bool inside(int r, int c){\n  return 0 <= r && r < H && 0 <= c && c < W;\n}\n\ninline bool cur_floor(int r, int c, int f, int mask){\n  bool ok = f == 0;\n  if(I[r][c] == '#') return false;\n  if(I[r][c] == '|') return true;\n  if(I[r][c] == '^' || isupper(I[r][c])) ok = !ok;\n  REP(s, S) if(PARITY(mask >> s) && M[s][r][c]) ok = !ok;\n  return ok;\n}\n\n\nint main(){\n  memset(D, -1, sizeof(D));\n  memset(M, false, sizeof(M));\n  \n  cin >> W >> H;\n  int sr, sc;\n  REP(r, H)REP(c, W){\n    cin >> I[r][c];\n    if(I[r][c] == '%'){\n      sr = r;\n      sc = c;\n    }\n  }\n\n  cin >> S;\n  char ch;  \n  REP(s, S)REP(r, H)REP(c, W){\n    cin >> ch;\n    M[s][r][c] = ch == '*';\n  }\n\n  queue<int> rs, cs, fs, ms;\n  rs.push(sr);\n  cs.push(sc);\n  fs.push(0);\n  ms.push(0);\n  D[0][sr][sc][0] = 0;\n  \n  int dr[4] = {0, 1, 0, -1};\n  int dc[4] = {-1, 0, 1, 0};\n\n  bool goal = false;\n  while(!rs.empty()){\n    int r = rs.front(); rs.pop();\n    int c = cs.front(); cs.pop();\n    int f = fs.front(); fs.pop();\n    int mask = ms.front(); ms.pop();\n    \n    if(I[r][c] == '&' && cur_floor(r, c, f, mask)){\n      cout << D[f][r][c][mask] << endl;\n      goal = true;\n      break;\n    }\n    \n    REP(i, 4){\n      int nr = r + dr[i];\n      int nc = c + dc[i];\n      if(inside(nr, nc) && cur_floor(nr, nc, f, mask) && D[f][nr][nc][mask] ==-1){\n\tD[f][nr][nc][mask] = D[f][r][c][mask] + 1;\n\tPUSH(nr, nc, f, mask);\n      }\n    }\n\n    if(I[r][c] == '|' && D[1 - f][r][c][mask] == -1){\n      D[1 - f][r][c][mask] = D[f][r][c][mask] + 1;\n      PUSH(r, c, 1 - f, mask);\n    }\n\n    if(isalpha(I[r][c]) && cur_floor(r, c, f, mask)){\n      int k = isupper(I[r][c]) ? I[r][c] - 'A' : I[r][c] - 'a';\n      int nmask = mask ^ (1 << k);\n      int nf = cur_floor(r, c, f, nmask) ? f : 1 - f;\n      if(D[nf][r][c][nmask] == -1){\n\tD[nf][r][c][nmask] = D[f][r][c][mask] + 1;\n\tPUSH(r, c, nf, nmask);\n      }\n    }\n  }\n  if(!goal) cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, int, char>;\n\nint main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0, '_'));\n\n    vector<vector<vvb>> used(h, vector<vvb>(w, vvb(1 << n, vb(2, false))));\n\n    while(q.size()){\n        int cc, cx, cy, cb; char cf;\n        tie(cc, cx, cy, cb, cf) = q.top();\n        q.pop();\n\n        if(cx == tx and cy == ty){\n            cout << cc << endl;\n            return 0;\n        }\n\n        int cfi = (cf == '^');\n        if(used[cy][cx][cb][cfi]) continue;\n        used[cy][cx][cb][cfi] = true;\n\n        int nc = cc + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(not used[cy][cx][nb][nfi]){\n                q.push(State(nc, cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(not used[cy][cx][cb][nfi]){\n                q.push(State(nc, cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and not used[ny][nx][cb][cfi]){\n                q.push(State(nc, nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and not used[ny][nx][cb][nfi]){\n                q.push(State(nc, nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nstruct State{\n    // (y,x), floor f, bit b\n    int y,x,f,b;\n};\n\ninline int switch_num(char c){\n    if('a'<=c && c<='j') return c-'a';\n    if('A'<=c && c<='J') return c-'A';\n    return -1;\n}\n\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nconst int INF = 19191919;\nconst int N = 50, M = 1<<10;\nint d[N][N][2][M];\n\nint main(){\n    int w,h;\n    cin >>w >>h;\n\n    vector<string> m(h);\n    rep(i,h) cin >>m[i];\n\n    int s;\n    cin >>s;\n    vector<vector<string>> ms(s);\n    rep(i,s){\n        ms[i] = vector<string>(h);\n        rep(j,h) cin >>ms[i][j];\n    }\n\n    rep(i,N)rep(j,N)rep(k,2)rep(l,M) d[i][j][k][l] = INF;\n\n    pi start, goal;\n    rep(i,h)rep(j,w){\n        if(m[i][j] == '%') start = {i,j};\n        if(m[i][j] == '&') goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n    auto FLOOR = [&](int y, int x, int bit){\n        int ret = 0;\n        if(m[y][x]=='^' || ('A'<=m[y][x] && m[y][x]<='J')) ret = 1;\n        rep(i,s)if(bit>>i&1){\n            if(ms[i][y][x]=='*') ret = !ret;\n        }\n        return ret;\n    };\n\n    queue<State> que;\n    d[start.fi][start.se][0][0] = 0;\n    que.push({start.fi, start.se, 0, 0});\n    while(!que.empty()){\n        State c = que.front();\n        que.pop();\n\n        // move another floor\n        if(m[c.y][c.x]=='|'){\n            State nc(c);\n            nc.f = !nc.f;\n            if(d[nc.y][nc.x][nc.f][nc.b] > d[c.y][c.x][c.f][c.b]+1){\n                d[nc.y][nc.x][nc.f][nc.b] = d[c.y][c.x][c.f][c.b]+1;\n                que.push({nc});\n            }\n        }\n\n        // operate switch\n        int sn = switch_num(m[c.y][c.x]);\n        if(sn!=-1){\n            State nc(c);\n            nc.b ^= (1<<switch_num(m[c.y][c.x]));\n            if(ms[sn][c.y][c.x] == '*') nc.f = !nc.f;\n\n            if(d[nc.y][nc.x][nc.f][nc.b] > d[c.y][c.x][c.f][c.b]+1){\n                d[nc.y][nc.x][nc.f][nc.b] = d[c.y][c.x][c.f][c.b]+1;\n                que.push({nc});\n            }\n        }\n\n        // move adjacent\n        rep(i,4){\n            State nc(c);\n            nc.y += dy[i];\n            nc.x += dx[i];\n            if(!IN(nc.y, nc.x) || m[nc.y][nc.x]=='#') continue;\n\n            if(m[nc.y][nc.x]=='|' || nc.f==FLOOR(nc.y,nc.x,nc.b)){\n                if(d[nc.y][nc.x][nc.f][nc.b] > d[c.y][c.x][c.f][c.b]+1){\n                    d[nc.y][nc.x][nc.f][nc.b] = d[c.y][c.x][c.f][c.b]+1;\n                    que.push({nc});\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,2)rep(j,1<<s) ans = min(ans, d[goal.fi][goal.se][i][j]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nstruct Data\n{\n\tint x, y, kai, sw;\n};\n\nint step[50][50][2][1024];\n\nint main()\n{\n\tint h, w;\n\tcin >> w >> h;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tint s; cin >> s;\n\tvector<vs> v(s, vs(h));\n\tREP(i, s)\n\t{\n\t\tREP(j, h) cin >> v[i][j];\n\t}\n\tmap<pii, int> mp;\n\tint sx, sy, gx, gy;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == '%')\n\t\t{\n\t\t\tsx = i, sy = j;\n\t\t\tfld[i][j] = '_';\n\t\t}\n\t\tif (fld[i][j] == '&')\n\t\t{\n\t\t\tgx = i, gy = j;\n\t\t\tfld[i][j] = '_';\n\t\t}\n\t\tif (islower(fld[i][j]))\n\t\t{\n\t\t\tmp[pii(i, j)] = fld[i][j] - 'a';\n\t\t\tfld[i][j] = '_';\n\t\t}\n\t\tif (isupper(fld[i][j]))\n\t\t{\n\t\t\tmp[pii(i, j)] = fld[i][j] - 'A';\n\t\t\tfld[i][j] = '^';\n\t\t}\n\t}\n\tMS(step, -1);\n\tstep[sx][sy][0][0] = 0;\n\tqueue<Data> que;\n\tque.push(Data{ sx,sy,0,0 });\n\twhile (!que.empty())\n\t{\n\t\tData d = que.front();\n\t\tque.pop();\n\t\tint x = d.x, y = d.y, kai = d.kai, sw = d.sw;\n\t\tint st = step[x][y][kai][sw];\n\t\tif (fld[x][y] == '|' && step[x][y][1 - kai][sw] == -1)\n\t\t{\n\t\t\tstep[x][y][1 - kai][sw] = st + 1;\n\t\t\tque.push(Data{ x,y,1 - kai,sw });\n\t\t}\n\t\tif (mp.count(pii(x, y)))\n\t\t{\n\t\t\tint n = mp[pii(x, y)];\n\t\t\tint nsw = sw ^ (1 << n);\n\t\t\tint nkai = kai;\n\t\t\tif (v[n][x][y] == '*') nkai = 1 - kai;\n\t\t\tif (step[x][y][nkai][nsw] == -1)\n\t\t\t{\n\t\t\t\tstep[x][y][nkai][nsw] = st + 1;\n\t\t\t\tque.push(Data{ x,y,nkai,nsw });\n\t\t\t}\n\t\t}\n\t\tREP(i, 4)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\tif (fld[nx][ny] == '_' || fld[nx][ny] == '^')\n\t\t\t{\n\t\t\t\tint nkai = (fld[nx][ny] == '_' ? 0 : 1);\n\t\t\t\tREP(j, s)\n\t\t\t\t{\n\t\t\t\t\tif ((sw >> j) & 1 && v[j][nx][ny] == '*') nkai = 1 - nkai;\n\t\t\t\t}\n\t\t\t\tif (nkai != kai) continue;\n\t\t\t}\n\t\t\tif (step[nx][ny][kai][sw] == -1)\n\t\t\t{\n\t\t\t\tstep[nx][ny][kai][sw] = st + 1;\n\t\t\t\tque.push(Data{ nx,ny,kai,sw });\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tREP(i, 2)REP(j, 1 << s)\n\t{\n\t\tif (step[gx][gy][i][j] != -1) chmin(ans, step[gx][gy][i][j]);\n\t}\n\tif (ans == INF) puts(\"-1\");\n\telse cout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n#define F first\n#define S second\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w, s, sy, sx, gy, gx;\nbool v[50][50][2][1 << 10], two[50][50][1 << 10];\nint move[50][50];\nstring in[50], ins[10][50];\n\nint main(){\n\tcin >> w >> h;\n\trep(i, h){\n\t\tcin >> in[i];\n\t\trep(j, w){\n\t\t\tif(in[i][j] == '%') sy = i, sx = j;\n\t\t\tif(in[i][j] == '&') gy = i, gx = j;\n\t\t}\n\t}\n\tcin >> s;\n\trep(i, s) rep(j, h) cin >> ins[i][j];\n\t\n\trep(k, s) rep(i, h) rep(j, w) if(ins[k][i][j] == '*') move[i][j] |= 1 << k;\n\trep(i, h) rep(j, w){\n\t\tif(in[i][j] == '#' || in[i][j] == '|') continue;\n\t\tbool first = 1;\n\t\tif(isalpha(in[i][j]) && isupper(in[i][j]) ||\n\t\t\tin[i][j] == '^') first = 0;\n\t\trep(k, 1 << s) two[i][j][k] = __builtin_popcount(k & move[i][j]) % 2 == first;\n\t}\n\t\n\tdeque<pair<pi, int> > q;\n\tq.pb(mp(mp(0, sy * w + sx), 0));\n\twhile(!q.empty()){\n\t\tint y = q.front().F.S / w, x = q.front().F.S % w, c = q.front().F.F;\n\t\tint bit = q.front().S % (1 << s), f = q.front().S / (1 << s);\n\t\tq.pop_front();\n\t\tif(v[y][x][f][bit]) continue;\n\t\tv[y][x][f][bit] = 1;\n\t\t\n\t\tif(y == gy && x == gx){\n\t\t\tcout << c << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(d, 4){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w || in[ny][nx] == '#') continue;\n\t\t\tif(in[ny][nx] != '|' && two[ny][nx][bit] != f || v[ny][nx][f][bit]) continue;\n\t\t\t\n\t\t\tq.pb(mp(mp(c + 1, ny * w + nx), f * (1 << s) + bit));\n\t\t}\n\t\tif(isalpha(in[y][x])){\n\t\t\tint k = tolower(in[y][x]) - 'a';\n\t\t\tint nbit = bit ^ 1 << k, nf = f;\n\t\t\tif(move[y][x] & 1 << k) nf ^= 1;\n\t\t\tif(!v[y][x][nf][nbit]) q.pb(mp(mp(c + 1, y * w + x), nf * (1 << s) + nbit));\n\t\t}\n\t\tif(in[y][x] == '|'){\n\t\t\tf ^= 1;\n\t\t\tif(!v[y][x][f][bit]) q.pb(mp(mp(c + 1, y * w + x), f * (1 << s) + bit));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {-1, 0, 1, 0};\n\nint W, H, S;\nstring M[50], MS[10][50];\nbool s[1 << 10][50][50];\nint bit[50][50], v[2][50][50][1 << 10];\nint mov[50][50];\n\nint Solve()\n{\n  memset(v, -1, sizeof(v));\n  for(int k = 0; k < S; k++) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(MS[k][i][j] == '*') bit[j][i] |= 1 << k;\n      }\n    }\n  }\n  for(int i = 0; i < 1 << S; i++) {\n    for(int l = 0; l < S; l++) {\n      if((i >> l) & 1) {\n        for(int j = 0; j < H; j++) {\n          for(int k = 0; k < W; k++) {\n            if(MS[l][j][k] == '*') s[i][k][j] ^= 1;\n          }\n        }\n      }\n    }\n  }\n  queue< tuple< int, int, int, int > > que;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      switch(M[i][j]) {\n        case '|':\n          mov[j][i] = 3;\n          break;\n        case '_':\n          mov[j][i] = 1;\n          break;\n        case '^':\n          mov[j][i] = 2;\n          break;\n        case 'a' ... 'j':\n          mov[j][i] = 1;\n          M[i][j] -= 'a';\n          break;\n        case 'A' ... 'J':\n          mov[j][i] = 2;\n          M[i][j] -= 'A';\n          break;\n        case '%':\n          que.emplace(0, j, i, 0);\n          v[0][j][i][0] = 0;\n          mov[j][i] = 1;\n          break;\n        case '&':\n          mov[j][i] = 1;\n          break;\n        default:\n          mov[j][i] = 0;\n          break;\n      }\n    }\n  }\n\n  while(!que.empty()) {\n    int f, x, y, button;\n    tie(f, x, y, button) = que.front();\n    que.pop();\n    if(M[y][x] == '&') {\n      return (v[f][x][y][button]);\n    } else if(M[y][x] == '|') {\n      int nf = f ^ 1;\n      if(v[nf][x][y][button] == -1) {\n        v[nf][x][y][button] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, button);\n      }\n    } else if(M[y][x] < 10) {\n      int nbutton = button ^ (1 << M[y][x]);\n      int nf = (f + ((bit[x][y] >> M[y][x]) & 1)) & 1;\n      if(v[nf][x][y][nbutton] == -1) {\n        v[nf][x][y][nbutton] = v[f][x][y][button] + 1;\n        que.emplace(nf, x, y, nbutton);\n      }\n    }\n    for(int i = 0; i < 4; i++) {\n      int nx = x + vx[i], ny = y + vy[i];\n      int isgo = (f + s[button][nx][ny]) & 1;\n      if(v[f][nx][ny][button] == -1 && (mov[nx][ny] & ++isgo)) {\n        v[f][nx][ny][button] = v[f][x][y][button] + 1;\n        que.emplace(f, nx, ny, button);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    cin >> M[i];\n  }\n  cin >> S;\n  for(int i = 0; i < S; i++) {\n    for(int j = 0; j < H; j++) {\n      cin >> MS[i][j];\n    }\n  }\n  cout << Solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \n#define int short\nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, int, char>;\n\nsigned main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, sx, sy, 0, '_'));\n\n    vector<vector<vvb>> used(h, vector<vvb>(w, vvb(1 << n, vb(2, false))));\n\n    while(q.size()){\n        int cc, cx, cy, cb; char cf;\n        tie(cc, cx, cy, cb, cf) = q.top();\n        q.pop();\n\n        if(cx == tx and cy == ty){\n            cout << cc << endl;\n            return 0;\n        }\n\n        int cfi = (cf == '^');\n        if(used[cy][cx][cb][cfi]) continue;\n        used[cy][cx][cb][cfi] = true;\n\n        int nc = cc + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(not used[cy][cx][nb][nfi]){\n                q.push(State(nc, cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(not used[cy][cx][cb][nfi]){\n                q.push(State(nc, cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and not used[ny][nx][cb][cfi]){\n                q.push(State(nc, nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and not used[ny][nx][cb][nfi]){\n                q.push(State(nc, nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<map>\n#include<string>\n#define sgn(v) (abs((v))<eps?0:((v)<0?-1:1))\n#define sqr(v) ((v)*(v))\n#define mb make_pair\n#define debug 0\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\nconst double eps=1e-9;\nconst double pi=acos(-1);\nchar mp[51][51];\nchar sp[10][51][51];\nint dp[1<<10][51][51][2];\nconst int inf=1e9+100;\nint w,h,k;\nstruct State\n{\n\tint sta,loc,flr;\n\tState(){}\n\tState(int s,int l,int f)\n\t{\n\t\tsta=s;loc=l;flr=f;\n\t}\n};\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\nbool vis[(1<<10)*5002+5000+2];\nqueue<State> q;\ninline int tod(int sta,int x,int y,int flr)\n{\n\treturn sta*5002+(x*h+y)*2+flr;\n}\nvoid dfs(int sx,int sy)\n{\n\tint x,y,cur,nsta,sta,flr,sgn;\n\tint i,j;\n\tState now;\n\tdp[0][sx][sy][0]=0;\n\t//cout <<sx<<\" \"<<sy<<\" \"<<h<<endl;\n\tq.push(State(0,sx*h+sy,0));\n\tvis[(sx*h+sy)*2]=true;\n\twhile(!q.empty())\n\t{\n\t\tnow=q.front();\t\n\t\tq.pop();\n\t\tx=now.loc/h;\n\t\ty=now.loc%h;\n\t\tsta=now.sta;\n\t\tflr=now.flr;\n\t\t//cout <<sta<<\" x&y:\"<<x<<\" \"<<y<<\" \"<<flr<<\" \"<<vis[tod(sta,x,y,flr)]<<\" \"<<dp[sta][x][y][flr]<<endl;\n\t\tvis[tod(sta,x,y,flr)]=false;\n\t\tif(mp[x][y]=='|')\n\t\t{\n\t\t\tif(dp[sta][x][y][flr^1]>dp[sta][x][y][flr]+1)\n\t\t\t{\n\t\t\t\tdp[sta][x][y][flr^1]=dp[sta][x][y][flr]+1;\n\t\t\t\tif(!vis[tod(sta,x,y,flr^1)])\n\t\t\t\t{\n\t\t\t\t\tvis[tod(sta,x,y,flr^1)]=true;\n\t\t\t\t\tq.push(State(sta,x*h+y,flr^1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(cur=0,j=0;j<k;++j)\n\t\t\tif((sta&(1<<j))&&sp[j][x][y]=='*')cur^=1;\n\t\tif(isupper(mp[x][y])&&(cur^flr)==1)\n\t\t{\n\t\t\tif(sta&(1<<(mp[x][y]-'A')))\n\t\t\t\tnsta=sta&(~(1<<(mp[x][y]-'A')));\n\t\t\telse\n\t\t\t\tnsta=sta|(1<<(mp[x][y]-'A'));\n\t\t\tsgn=(sp[mp[x][y]-'A'][x][y]=='*');\n\t\t\tif(dp[nsta][x][y][flr^sgn]>dp[sta][x][y][flr]+1)\n\t\t\t{\n\t\t\t\tdp[nsta][x][y][flr^sgn]=dp[sta][x][y][flr]+1;\n\t\t\t\tif(!vis[tod(nsta,x,y,flr^sgn)])\n\t\t\t\t{\n\t\t\t\t\tvis[tod(nsta,x,y,flr^sgn)]=true;\n\t\t\t\t\tq.push(State(nsta,x*h+y,flr^sgn));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(islower(mp[x][y])&&(cur^flr)==0)\n\t\t{\n\t\t\tif(sta&(1<<(mp[x][y]-'a')))\n\t\t\t\tnsta=sta&(~(1<<(mp[x][y]-'a')));\n\t\t\telse \n\t\t\t\tnsta=sta|(1<<(mp[x][y]-'a'));\n\t\t\tsgn=(sp[mp[x][y]-'a'][x][y]=='*');\n\t\t\tif(dp[nsta][x][y][flr^sgn]>dp[sta][x][y][flr]+1)\n\t\t\t{\n\t\t\t\tdp[nsta][x][y][flr^sgn]=dp[sta][x][y][flr]+1;\n\t\t\t\tif(!vis[tod(nsta,x,y,flr^sgn)])\n\t\t\t\t{\n\t\t\t\t\tvis[tod(nsta,x,y,flr^sgn)]=true;\n\t\t\t\t\tq.push(State(nsta,x*h+y,flr^sgn));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;++i)\n\t\t{\n\t\t\tsx=x+dx[i];\n\t\t\tsy=y+dy[i];\n\t\t\tif(sx<0||sx>=w||sy<0||sy>=h)continue;\n\t\t\tfor(cur=0,j=0;j<k;++j)\n\t\t\t\tif((sta&(1<<j))&&sp[j][sx][sy]=='*')cur^=1;\n\t\t\tif((isupper(mp[sx][sy])||mp[sx][sy]=='^')&&(cur^flr)==1)\n\t\t\t{\n\t\t\t\tif(dp[sta][sx][sy][flr]>dp[sta][x][y][flr]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[sta][sx][sy][flr]=dp[sta][x][y][flr]+1;\n\t\t\t\t\tif(!vis[tod(sta,sx,sy,flr)])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[tod(sta,sx,sy,flr)]=true;\n\t\t\t\t\t\tq.push(State(sta,sx*h+sy,flr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((islower(mp[sx][sy])||mp[sx][sy]=='_'||mp[sx][sy]=='&'||mp[sx][sy]=='%')&&(cur^flr)==0)\n\t\t\t{\n\t\t\t\tif(dp[sta][sx][sy][flr]>dp[sta][x][y][flr]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[sta][sx][sy][flr]=dp[sta][x][y][flr]+1;\n\t\t\t\t\tif(!vis[tod(sta,sx,sy,flr)])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[tod(sta,sx,sy,flr)]=true;\n\t\t\t\t\t\tq.push(State(sta,sx*h+sy,flr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(mp[sx][sy]=='|')\n\t\t\t{\n\t\t\t\tif(dp[sta][sx][sy][flr]>dp[sta][x][y][flr]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[sta][sx][sy][flr]=dp[sta][x][y][flr]+1;\n\t\t\t\t\tif(!vis[tod(sta,sx,sy,flr)])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[tod(sta,sx,sy,flr)]=true;\n\t\t\t\t\t\tq.push(State(sta,sx*h+sy,flr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j,p;\n\tint sx,sy,tx,ty;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(i=0;i<w;++i)\n\t\tscanf(\"%s\",mp[i]);\n\tscanf(\"%d\",&k);\n\tfor(i=0;i<k;++i)\n\t\tfor(j=0;j<w;++j)\n\t\t\tscanf(\"%s\",sp[i][j]);\t\n\tint full=1<<k;\n\tfor(i=0;i<full;++i)\n\t\tfor(j=0;j<w;++j)\n\t\t\tfor(p=0;p<h;++p)\n\t\t\t\tdp[i][j][p][0]=dp[i][j][p][1]=inf;\n\tfor(i=0;i<w;++i)\n\t\tfor(j=0;j<h;++j)\n\t\t\tif(mp[i][j]=='%')sx=i,sy=j;\n\t\t\telse if(mp[i][j]=='&')tx=i,ty=j;\n\t//cout <<\"pre finished\"<<\" \"<<sx<<\" \"<<sy<<\" \"<<tx<<\" \"<<ty<<\" \"<<full<<endl;\n\tdfs(sx,sy);\n\tint ans=inf;\n\tfor(i=0;i<full;++i)\n\t{\n\t\tans=min(ans,dp[i][tx][ty][0]);\n\t\tans=min(ans,dp[i][tx][ty][1]);\n\t}\n\tif(ans!=inf)printf(\"%d\\n\",ans);\n\telse printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int mod = 1e9 + 7;\n\nint W, H, S;\nchar M[55][55];\nchar MS[11][55][55];\nbool flr[55][55];\nint sy, sx, gy, gx;\n\nint dist[2][55][55][1<<10];\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nbool in(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> W >> H;\n  rep(i, H) rep(j, W) {\n    cin >> M[i][j];\n    if(M[i][j] == '%') sy = i, sx = j;\n    else if(M[i][j] == '&') gy = i, gx = j;\n    else if(M[i][j] == '_' || islower(M[i][j])) flr[i][j] = 0;\n    else if(M[i][j] == '^' || isupper(M[i][j])) flr[i][j] = 1;\n  }\n  cin >> S;\n  rep(i, S) rep(j, H) rep(k, W) cin >> MS[i][j][k];\n\n\n  queue< tuple<int, int, int, int> > que;\n\n  memset(dist, -1, sizeof(dist));\n  dist[0][sy][sx][0] = 0;\n  que.emplace(0, sy, sx, 0);\n\n  while(que.size()) {\n    int f, y, x, bit;\n    tie(f, y, x, bit) = que.front(); que.pop();\n    if(y == gy && x == gx) {\n      cout << dist[f][y][x][bit] << endl;\n      return 0;\n    }\n    if(M[y][x] == '|' && dist[!f][y][x][bit] == -1) {\n      dist[!f][y][x][bit] = dist[f][y][x][bit] + 1;\n      que.emplace(!f, y, x, bit);\n    }\n    if(isalpha(M[y][x])) {\n      int g = flr[y][x];\n      rep(j, S) if(((bit >> j) & 1) && MS[j][y][x] == '*') g = !g;\n      if(f == g) {\n\tint nf = f, ny = y, nx = x, nbit = bit;\n\tint digit = M[ny][nx] - (islower(M[ny][nx]) ? 'a' : 'A');\n\tnbit ^= 1<<digit;\n\tif(MS[digit][ny][nx] == '*') nf = !nf;\n\tif(dist[nf][ny][nx][nbit] == -1) {\n\t  dist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\t  que.emplace(nf, ny, nx, nbit);\n\t}\n      }\n    }\n    rep(i, 4) {\n      int nf = f, ny = y + dy[i], nx = x + dx[i], nbit = bit;\n      if(!in(ny, nx) || M[ny][nx] == '#') continue;\n      int g = flr[ny][nx];\n      rep(j, S) if(((nbit >> j) & 1) && MS[j][ny][nx] == '*') g = !g;\n      if(nf == g || M[ny][nx] == '|') {\n\tdist[nf][ny][nx][nbit] = dist[f][y][x][bit] + 1;\n\tque.emplace(nf, ny, nx, nbit);\n      }\n    }\n  }\n  cout << -1 << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 50\n#define MAX_W 50\n#define MAX_S 10\n \nstruct State{\n    int d,x,y,s,f;\n    State(int d,int x,int y,int s,int f) :\n\td(d),x(x),y(y),s(s),f(f) {}\n};\n \nchar M[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W][1<<MAX_S][2];\n \nint getFloor(int x,int y,int f){\n    if(M[y][x] == '|') return f;\n    if(M[y][x] == '_' || islower(M[y][x])){\n\treturn 0;\n    }\n    return 1;\n}\n \nint main(){\n    int H,W,sx,sy,gx,gy,S;\n    char MS[MAX_H][MAX_W][MAX_S];\n    cin >> W >> H;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> M[i][j];\n\t    if(M[i][j] == '%'){\n\t\tM[i][j] = '_';\n\t\tsx = j; sy = i;\n\t    }\n\t    if(M[i][j] == '&'){\n\t\tM[i][j] = '_';\n\t\tgx = j; gy = i;\n\t    }\n\t}\n    }\n    cin >> S;\n    for(int i = 0 ; i < S ; i++){\n\tfor(int j = 0 ; j < H ; j++){\n\t    for(int k = 0 ; k < W ; k++){\n\t\tcin >> MS[j][k][i];\n\t    }\n\t}\n    }\n    int ans = -1;\n    memset(visited,false,sizeof(visited));\n    visited[sy][sx][0][0] = true;\n    const int dx[] = {-1,0,1,0};\n    const int dy[] = {0,-1,0,1};\n    queue<State> Q;\n    Q.push(State(0,sx,sy,0,0));\n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n\tint x = s.x, y = s.y;\n\tif(x == gx && y == gy){\n\t    ans = s.d;\n\t    break;\n\t}\n\tif(islower(M[y][x])){\n\t    int sw = M[y][x] - 'a';\n\t    int next = s.s ^ (1<<sw);\n\t    int nf = s.f;\n\t    if(MS[y][x][sw] == '*'){\n\t\tnf = 1-nf;\n\t    }\n\t    if(!visited[y][x][next][nf]){\n\t\tvisited[y][x][next][nf] = true;\n\t\tQ.push(State(s.d+1,x,y,next,nf));\n\t    }\n\t}\n\tif(isupper(M[y][x])){\n\t    int sw = M[y][x] - 'A';\n\t    int next = s.s ^ (1<<sw);\n\t    int nf = s.f;\n\t    if(MS[y][x][sw] == '*'){\n\t\tnf = 1-nf;\n\t    }\n\t    if(!visited[y][x][next][nf]){\n\t\tvisited[y][x][next][nf] = true;\n\t\tQ.push(State(s.d+1,x,y,next,nf));\n\t    }\n\t}\n\tif(M[y][x] == '|'){\n\t    int next = 1-s.f;\n\t    if(!visited[y][x][s.s][next]){\n\t\tvisited[y][x][s.s][next] = true;\n\t\tQ.push(State(s.d+1,x,y,s.s,next));\n\t    }\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\t    int f = s.f;\n\t    if(0 > nx || W <= nx || 0 > ny || H <= ny){\n\t\tcontinue;\n\t    }\n\t    if(M[ny][nx] == '#') continue;\n\t    int nf = getFloor(nx,ny,f);\n\t    for(int j = 0 ; j < S ; j++){\n\t\tif((s.s >> j) & 1){\n\t\t    if(MS[ny][nx][j] == '*'){\n\t\t\tnf = 1 - nf;\n\t\t    }\n\t\t}\n\t    }\n\t    if(f == nf && !visited[ny][nx][s.s][nf]){\n\t\tvisited[ny][nx][s.s][nf] = true;\n\t\tQ.push(State(s.d+1,nx,ny,s.s,nf));\n\t    }\n\t}\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \n#define int short\nusing vs = vector<string>;\nusing vvi = vector<vi>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing State = tuple<int, int, int, char>;\n\nsigned main(void){\n    int w, h; cin >> w >> h;\n\n    vs field(h);\n    vvi sw_idx(h, vi(w, -1));\n    int sx, sy, tx, ty;\n    rep(y, h){\n        cin >> field[y];\n        rep(x, w){\n            if(field[y][x] == '%'){\n                sx = x, sy = y;\n                field[y][x] = '_';\n            }\n            if(field[y][x] == '&'){\n                tx = x, ty = y;\n                field[y][x] = '_';\n            }\n            if(isupper(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'A';\n                field[y][x] = '^';\n            }\n            if(islower(field[y][x])){\n                sw_idx[y][x] = field[y][x] - 'a';\n                field[y][x] = '_';\n            }\n        }\n    }\n\n    int n; cin >> n;\n    vector<vvi> sw_field(n, vvi(h, vi(w)));\n\n    rep(i, n){\n        rep(y, h){\n            rep(x, w){\n                char c; cin >> c;\n                if(c == '*') sw_field[i][y][x] = 1;\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(State(sx, sy, 0, '_'));\n\n    vector<vector<vvi>> min_cost(h, vector<vvi>(w, vvi(1 << n, vi(2, inf))));\n    min_cost[sy][sx][0][0] = 0;\n\n    while(q.size()){\n        int cx, cy, cb; char cf;\n        tie(cx, cy, cb, cf) = q.front();\n        q.pop();\n\n        int cfi = (cf == '^');\n\n        if(cx == tx and cy == ty){\n            cout << min_cost[cy][cx][cb][cfi] << endl;\n            return 0;\n        }\n\n        int nc = min_cost[cy][cx][cb][cfi] + 1;\n\n        if(sw_idx[cy][cx] != -1){\n            int idx = sw_idx[cy][cx];\n\n            int nb = cb ^ (1 << idx);\n            char nf = cf;\n            if(sw_field[idx][cy][cx]){\n                nf = (cf == '^' ? '_' : '^');\n            }\n            int nfi = (nf == '^');\n            if(chmin(min_cost[cy][cx][nb][nfi], nc)){\n                q.push(State(cx, cy, nb, nf));\n            }\n        }\n\n        if(field[cy][cx] == '|'){\n            char nf = (cf == '^' ? '_' : '^');\n            int nfi = (nf == '^');\n\n            if(chmin(min_cost[cy][cx][cb][nfi], nc)){\n                q.push(State(cx, cy, cb, nf));\n            }\n        }\n\n        rep(i, 4){\n            int nx = cx + dx[i], ny = cy + dy[i];\n\n            if(field[ny][nx] == '#') continue;\n\n            if(field[ny][nx] == '|' and chmin(min_cost[ny][nx][cb][cfi], nc)){\n                q.push(State(nx, ny, cb, cf));\n                continue;\n            }\n\n            bool nrev = false;\n            rep(j, n){\n                if(sw_field[j][ny][nx] and (cb & (1 << j))){\n                    nrev ^= true;\n                }\n            }\n\n            char nf;\n            if(nrev) nf = (field[ny][nx] == '^' ? '_':'^');\n            else     nf =  field[ny][nx];\n            int nfi = (nf == '^');\n\n            if(cf == nf and chmin(min_cost[ny][nx][cb][nfi], nc)){\n                q.push(State(nx, ny, cb, nf));\n            }\n        }\n    }\n\n    cout << -1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[60][60];\nint key[11][60][60];\nchar in[60][60];\nint bfs[1<<10][60][60][2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<a;j++)scanf(\"%s\",in[j]);\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++){\n\t\t\tif(in[j][k]=='*')key[i][j][k]=1;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<(1<<c);i++)for(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[i][j][k][0]=bfs[i][j][k][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='%'){\n\t\tbfs[0][i][j][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t}\n\twhile(Q.size()){\n\t\tint v=Q.front().first.first;\n\t\tint f=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!~bfs[v][row+dx[i]][col+dy[i]][f]&&\n\t\t\tstr[row+dx[i]][col+dy[i]]!='#'){\n\t\t\t\tint H=0;if(str[row+dx[i]][col+dy[i]]=='^'||('A'<=str[row+dx[i]][col+dy[i]]&&str[row+dx[i]][col+dy[i]]<='B'))H=1;\n\t\t\t\tfor(int j=0;j<c;j++)if((v&(1<<j))&&key[j][row+dx[i]][col+dy[i]])H=!H;\n\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='|'||H==f){\n\t\t\t\t\tbfs[v][row+dx[i]][col+dy[i]][f]=bfs[v][row][col][f]+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(v,f),make_pair(row+dx[i],col+dy[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str[row][col]=='|'&&!~bfs[v][row][col][!f]){\n\t\t\tbfs[v][row][col][!f]=bfs[v][row][col][f]+1;\n\t\t\tQ.push(make_pair(make_pair(v,!f),make_pair(row,col)));\n\t\t}\n\t\tif('a'<=(32|str[row][col])&&(32|str[row][col])<='z'){\n\t\t\tint H=f;\n\t\t\tif(key[(32|str[row][col])-'a'][row][col])H=!H;\n\t\t\tint to=v^(1<<((32|str[row][col])-'a'));\n\t\t\tif(!~bfs[to][row][col][H]){\n\t\t\t\tbfs[to][row][col][H]=bfs[v][row][col][f]+1;\n\t\t\t\tQ.push(make_pair(make_pair(to,H),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='&'){\n\t\tfor(int k=0;k<(1<<c);k++){\n\t\t\tif(~bfs[k][i][j][0])ret=min(ret,bfs[k][i][j][0]);\n\t\t}\n\t}\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\nint H, W, N, dist[52][52][2][1 << 10]; string S[52], T[10][52], C[1 << 10][52];\nqueue<tuple<int, int, int, int>>Q;\n\nvoid refresh(int a1, int a2, int a3, int a4, int a5) {\n\tif (dist[a1][a2][a3][a4] > a5) {\n\t\tdist[a1][a2][a3][a4] = a5;\n\t\tQ.push(make_tuple(a1, a2, a3, a4));\n\t}\n}\nint floors(char c) {\n\tif (c >= 'a' && c <= 'z') return 0;\n\tif (c >= 'A' && c <= 'Z') return 1;\n\tif (c == '_') return 0;\n\tif (c == '^') return 1;\n\treturn -1;\n}\n\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 0; i < H; i++) cin >> S[i];\n\tint sx = 0, sy = 0, gx = 0, gy = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S[i][j] == '%') { sx = i; sy = j; S[i][j] = '_'; }\n\t\t\tif (S[i][j] == '&') { gx = i; gy = j; S[i][j] = '_'; }\n\t\t}\n\t}\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < H; j++) cin >> T[i][j];\n\t}\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tstring V[52]; for (int j = 0; j < H; j++) V[j] = S[j];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i / (1 << j)) % 2 == 0) continue;\n\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\tif (T[j][k][l] == '*') {\n\t\t\t\t\t\tif (V[k][l] == '_') V[k][l] = '^';\n\t\t\t\t\t\telse if (V[k][l] == '^') V[k][l] = '_';\n\t\t\t\t\t\telse if (V[k][l] >= 'a' && V[k][l] <= 'z') V[k][l] -= 32;\n\t\t\t\t\t\telse if (V[k][l] >= 'A' && V[k][l] <= 'Z') V[k][l] += 32;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < H; j++) C[i][j] = V[j];\n\t}\n\tfor (int i = 0; i < (1 << N); i++) { for (int j = 0; j < H; j++) { for (int k = 0; k < W; k++) { dist[j][k][0][i] = (1 << 30); dist[j][k][1][i] = (1 << 30); } } }\n\tdist[sx][sy][0][0] = 0; Q.push(make_tuple(sx, sy, 0, 0));\n\twhile (!Q.empty()) {\n\t\tint cx = get<0>(Q.front()), cy = get<1>(Q.front()), fl = get<2>(Q.front()), mask = get<3>(Q.front()); Q.pop();\n\t\tint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\n\t\tif (C[mask][cx][cy] == '|') {\n\t\t\trefresh(cx, cy, fl ^ 1, mask, dist[cx][cy][fl][mask] + 1);\n\t\t}\n\t\tif (C[mask][cx][cy] >= 'a' && C[mask][cx][cy] <= 'z') {\n\t\t\tchar c = C[mask][cx][cy];\n\t\t\tint id = (mask ^ (1 << (c - 'a')));\n\t\t\trefresh(cx, cy, floors(C[id][cx][cy]), id, dist[cx][cy][fl][mask] + 1);\n\t\t}\n\t\tif (C[mask][cx][cy] >= 'A' && C[mask][cx][cy] <= 'Z') {\n\t\t\tchar c = C[mask][cx][cy];\n\t\t\tint id = (mask ^ (1 << (c - 'A')));\n\t\t\trefresh(cx, cy, floors(C[id][cx][cy]), id, dist[cx][cy][fl][mask] + 1);\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint fx = cx + dx[i], fy = cy + dy[i];\n\t\t\tif (C[mask][fx][fy] == '#') continue;\n\t\t\tif (fl == 0 && floors(C[mask][fx][fy]) == 1) continue;\n\t\t\tif (fl == 1 && floors(C[mask][fx][fy]) == 0) continue;\n\t\t\trefresh(fx, fy, fl, mask, dist[cx][cy][fl][mask] + 1);\n\t\t}\n\t}\n\tint minx = (1 << 30);\n\tfor (int i = 0; i < (1 << N); i++) { minx = min(minx, dist[gx][gy][0][i]); minx = min(minx, dist[gx][gy][1][i]); }\n\tif (minx == (1 << 30))minx = -1;\n\tcout << minx << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define S (1<<10)\n#define INF (1e9)\n#define N 50\n#define M 10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\ntypedef pair<int,P1> P2;\nint d[S][2][N][N],h,w,m,sy,sx,gy,gx;\nstring s[N],t[M][N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint getFloor(int y,int x,int A){\n  if(s[y][x]=='|')return 3;\n  int cnt=0;\n  for(int i=0;i<m;i++){\n    if(!(A&(1<<i)))continue;\n    if(t[i][y][x]=='*')cnt++;\n  }\n  if('A'<=s[y][x]&&s[y][x]<='Z')return (cnt%2)?0:1;\n  if(s[y][x]=='^')return (cnt%2)?0:1;\n  return (cnt%2)?1:0;\n}\n\nint bfs(){\n  for(int i=0;i<S;i++)\n    for(int j=0;j<2;j++)\n      for(int k=0;k<N;k++)\n\tfor(int l=0;l<N;l++)\n\t      d[i][j][k][l]=INF;\n  queue<P2> q;\n  q.push(P2(0,P1(P(0,0),P(sy,sx))));\n  d[0][0][sy][sx]=0;\n  while(!q.empty()){\n    P2 t=q.front(); q.pop();\n    int cost=t.X,Sw=t.Y.X.X;\n    int F=t.Y.X.Y,y=t.Y.Y.X,x=t.Y.Y.Y;\n    if(d[Sw][F][y][x]<cost)continue;\n    if(y==gy&&x==gx)return cost;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(s[ny][nx]=='#')continue;\n      int nSw=Sw,f=0;\n      if('a'<=s[y][x]&&s[y][x]<='z')\n\tnSw^=(1<<(s[y][x]-'a')),f=1;\n      if('A'<=s[y][x]&&s[y][x]<='Z')\n\tnSw^=(1<<(s[y][x]-'A')),f=1;\n      int nF=getFloor(y,x,nSw);\n      if(s[y][x]=='|'){\n\tif(d[Sw][!F][y][x]>cost+1){\n\t  d[Sw][!F][y][x]=cost+1;\n\t  q.push(P2(cost+1,P1(P(Sw,!F),P(y,x))));\n\t}\n      }\n      if(f&&d[nSw][nF][y][x]>cost+1){\n\td[nSw][nF][y][x]=cost+1;\n\tq.push(P2(cost+1,P1(P(nSw,nF),P(y,x))));\n      }\n      int r=getFloor(ny,nx,Sw);\n      if(r==3)r=F;\n      if(F!=r)continue;\n      if(d[Sw][F][ny][nx]>cost+1){\n\td[Sw][F][ny][nx]=cost+1;\n\tq.push(P2(cost+1,P1(P(Sw,F),P(ny,nx))));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='%')sy=i,sx=j;\n      if(s[i][j]=='&')gy=i,gx=j;\n    }\n  }\n  cin>>m;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<h;j++)\n      cin>>t[i][j];\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[60][60];\nint key[11][60][60];\nchar in[60][60];\nint bfs[1<<10][60][60][2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<a;j++)scanf(\"%s\",in[j]);\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++){\n\t\t\tif(in[j][k]=='*')key[i][j][k]=1;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<(1<<c);i++)for(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[i][j][k][0]=bfs[i][j][k][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='%'){\n\t\tbfs[0][i][j][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t}\n\twhile(Q.size()){\n\t\tint v=Q.front().first.first;\n\t\tint f=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!~bfs[v][row+dx[i]][col+dy[i]][f]&&\n\t\t\tstr[row+dx[i]][col+dy[i]]!='#'){\n\t\t\t\tint H=0;if(str[row+dx[i]][col+dy[i]]=='^'||('A'<=str[row+dx[i]][col+dy[i]]&&str[row+dx[i]][col+dy[i]]<='Z'))H=1;\n\t\t\t\tfor(int j=0;j<c;j++)if((v&(1<<j))&&key[j][row+dx[i]][col+dy[i]])H=!H;\n\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='|'||H==f){\n\t\t\t\t\tbfs[v][row+dx[i]][col+dy[i]][f]=bfs[v][row][col][f]+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(v,f),make_pair(row+dx[i],col+dy[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str[row][col]=='|'&&!~bfs[v][row][col][!f]){\n\t\t\tbfs[v][row][col][!f]=bfs[v][row][col][f]+1;\n\t\t\tQ.push(make_pair(make_pair(v,!f),make_pair(row,col)));\n\t\t}\n\t\tif('a'<=(32|str[row][col])&&(32|str[row][col])<='z'){\n\t\t\tint H=f;\n\t\t\tif(key[(32|str[row][col])-'a'][row][col])H=!H;\n\t\t\tint to=v^(1<<((32|str[row][col])-'a'));\n\t\t\tif(!~bfs[to][row][col][H]){\n\t\t\t\tbfs[to][row][col][H]=bfs[v][row][col][f]+1;\n\t\t\t\tQ.push(make_pair(make_pair(to,H),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='&'){\n\t\tfor(int k=0;k<(1<<c);k++){\n\t\t\tif(~bfs[k][i][j][0])ret=min(ret,bfs[k][i][j][0]);\n\t\t}\n\t}\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int,int> T;\n\nunsigned dist[2][52][52][1<<10];\nchar M[52][52];\nchar MS[10][52][52];\nint main() {\n\tint W,H;\n\tmemset(dist,-1,sizeof(dist));\n\tcin >> W >> H;\n\tint x=0,y=0;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin >> M[i][j];\n\t\t\tif(M[i][j]=='%'){\n\t\t\t\tx=i;\n\t\t\t\ty=j;\n\t\t\t}\n\t\t}\n\t}\n\tint S=0;\n\tcin >> S;\n\tfor(int k=0;k<S;k++){\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin >> MS[k][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tqueue<T> Q;\n\tQ.push(T(0,x,y,0));\n\tdist[0][x][y][0]=0;\n\twhile(Q.size()){\n\t\tT t=Q.front();\n\t\tint f=get<0>(t);\n\t\tx=get<1>(t);\n\t\ty=get<2>(t);\n\t\tint st=get<3>(t);\n\t\tunsigned d=dist[f][x][y][st];\n\t\tint dx=1,dy=0;\n\t\tQ.pop();\n\t\t//cout << f << \", \" << x << \", \" << y << \", \" << st << \": \" << dist[f][x][y][st] << endl;\n\t\tfor(int k=0;k<4;k++,swap(dx,dy),dx*=-1){\n\t\t\tint p=x+dx;\n\t\t\tint q=y+dy;\n\t\t\tif(('a'<=M[p][q]&&M[p][q]<='j')||\n\t\t\t   M[p][q]=='_'||\n\t\t\t   M[p][q]=='%'||\n\t\t\t   M[p][q]=='&'||\n\t\t\t   M[p][q]=='^'||\n\t\t\t   ('A'<=M[p][q]&&M[p][q]<='J')){\n\t\t\t\tint nex=(M[p][q]=='^'||('A'<=M[p][q]&&M[p][q]<='J'))?1:0;\n\t\t\t\tfor(int i=0;i<S;i++){\n\t\t\t\t\tif((st&(1<<i))&&MS[i][p][q]=='*'){\n\t\t\t\t\t\tnex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nex%2!=f){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (M[p][q]=='|'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(M[p][q]=='&'){\n\t\t\t\tcout << d+1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(d+1<dist[f][p][q][st]){\n\t\t\t\tdist[f][p][q][st]=d+1;\n\t\t\t\tQ.push(T(f,p,q,st));\n\t\t\t}\n\t\t}\n\t\tif(('a'<=M[x][y]&&M[x][y]<='j')||\n\t\t   ('A'<=M[x][y]&&M[x][y]<='J')){\n\t\t\tint i=('a'<=M[x][y]&&M[x][y]<='j')?M[x][y]-'a':M[x][y]-'A';\n\t\t\tint nex=MS[i][x][y]=='*'?f^1:f;\n\t\t\tif(d+1<dist[nex][x][y][st^(1<<i)]){\n\t\t\t\tdist[nex][x][y][st^(1<<i)]=d+1;\n\t\t\t\tQ.push(T(nex,x,y,st^(1<<i)));\n\t\t\t}\n\t\t}\n\t\tif(M[x][y]=='|'){\n\t\t\tif(d+1<dist[f^1][x][y][st]){\n\t\t\t\tdist[f^1][x][y][st]=d+1;\n\t\t\t\tQ.push(T(f^1,x,y,st));\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"-1\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint dp[55][55][2][1333];\nsigned main(){\n\trep(i,55)rep(j,55)rep(q,2)rep(k,1333)dp[i][j][q][k]=inf;\n\t\n\tint n,m;\n\tcin>>m>>n;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\t\n\tvector<vs>ini(2,in);\n\t\n\trep(i,n)rep(j,m){\n\t\tif(in[i][j]=='%')ini[1][i][j]='#';\n\t\tif(in[i][j]=='_')ini[1][i][j]='#';\n\t\tif(in[i][j]=='^')ini[0][i][j]='#';\n\t\tif(islower(in[i][j]))ini[1][i][j]='#';\n\t\tif(isupper(in[i][j])){\n\t\t\tini[0][i][j]='#';\n\t\t\tini[1][i][j]=tolower(in[i][j]);\n\t\t}\n\t\tif(in[i][j]=='&')ini[1][i][j]='#';\n\t}\n\t\n\tint q;\n\tcin>>q;\n\tvector<vs>w(q,vs(n));\n\trep(i,q)rep(j,n)cin>>w[i][j];\n\t\n\tqueue<tp>que;\n\trep(i,n)rep(j,m)if(in[i][j]=='%'){\n\t\tque.push(tp(i,j,0,0));\n\t\tdp[i][j][0][0]=0;\n\t}\n\tint out=inf;\n\twhile(!que.empty()){\n\t\tint x,y,f,s;\n\t\ttie(x,y,f,s)=que.front();\n//\t\tcout<<x<<\" \"<<y<<\" \"<<f<<\" \"<<s<<\" \"<<dp[x][y][f][s]<<endl;\n\t\tque.pop();\n\t\t\n\t\tvector<vs>now=ini;\n\t\trep(c,10)if(s&1<<c)rep(i,n)rep(j,m)if(w[c][i][j]=='*')\n\t\t\tswap(now[0][i][j],now[1][i][j]);\n\n\t\tif(now[f][x][y]=='&'){\n\t\t\tout=dp[x][y][f][s];\n\t\t\tbreak;\n\t\t}\n\t\trep(k,4){\n\t\t\tint nx=x+dx[k];\n\t\t\tint ny=y+dy[k];\n\t\t\tif(now[f][nx][ny]=='#')continue;\n\t\t\tif(dp[x][y][f][s]+1<dp[nx][ny][f][s]){\n\t\t\t\tdp[nx][ny][f][s]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(nx,ny,f,s));\n\t\t\t}\n\t\t}\n\t\tif(isalpha(now[f][x][y])){\n\t\t\tint ns=s^1<<(now[f][x][y]-'a');\n\t\t\tint nf=f;\n\t\t\tif(w[now[f][x][y]-'a'][x][y]=='*')nf^=1;\n\t\t\tif(dp[x][y][f][s]+1<dp[x][y][nf][ns]){\n\t\t\t\tdp[x][y][nf][ns]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(x,y,nf,ns));\n\t\t\t}\n\t\t}\n\t\tif(now[f][x][y]=='|'){\n\t\t\tint nf=f^1;\n\t\t\tif(dp[x][y][f][s]+1<dp[x][y][nf][s]){\n\t\t\t\tdp[x][y][nf][s]=dp[x][y][f][s]+1;\n\t\t\t\tque.push(tp(x,y,nf,s));\n\t\t\t}\n\t\t}\n\t}\n\tif(out==inf)out=-1;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nclass Node{\npublic:\n\tint floor, h, w, flag;\n\tNode(int floor, int h, int w, int flag) : floor(floor), h(h), w(w), flag(flag) {}\n};\n\nint bitCount(int t){\n\tint res = 0;\n\tfor(int i=t;i;i&=(i-1)) res++;\n\treturn res;\n}\n\nint main(){\n\tint W, H, S;\n\tstring mp[50];\n\tint mask[50][50];\n\tint floor[50][50];\n\tstatic int cost[2][50][50][1024];\n\twhile(cin >> W >> H && W){\n\t\tmemset(mask, 0, sizeof(mask));\n\t\tmemset(floor, 0, sizeof(floor));\n\n\t\tfor(int h=0;h<H;h++) cin >> mp[h];\n\t\tcin >> S;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tfor(int h=0;h<H;h++){\n\t\t\t\tstring str; cin >> str;\n\t\t\t\tfor(int w=0;w<W;w++){\n\t\t\t\t\tif(str[w] == '*') mask[h][w] |= 1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<Node> qu;\n\t\tmemset(cost, -1, sizeof(cost));\n\n\t\tfor(int h=0;h<H;h++){\n\t\t\tfor(int w=0;w<W;w++){\n\t\t\t\tif(mp[h][w]=='^' || isupper(mp[h][w]))\n\t\t\t\t\tfloor[h][w] = 1;\n\t\t\t\tif(mp[h][w]=='%'){\n\t\t\t\t\tqu.push(Node(0, h, w, 0));\n\t\t\t\t\tcost[0][h][w][0] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = -1;\n\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.front(); qu.pop();\n\t\t\tint fl = nd.floor, h = nd.h, w = nd.w, flag = nd.flag;\n\t\t\tif(mp[h][w]=='&'){\n\t\t\t\tres = cost[fl][h][w][flag];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(mp[h][w]=='|'){\n\t\t\t\tif(cost[1-fl][h][w][flag] == -1){\n\t\t\t\t\tcost[1-fl][h][w][flag] = cost[fl][h][w][flag]+1;\n\t\t\t\t\tqu.push(Node(1-fl, h, w, flag));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isalpha(mp[h][w])){\n\t\t\t\tint s = isupper(mp[h][w]) ? mp[h][w]-'A' : mp[h][w]-'a';\n\t\t\t\tint nflag = flag^(1<<s);\n\t\t\t\tint nfl = (floor[h][w]+bitCount(mask[h][w]&nflag))%2;\n\t\t\t\tif(cost[nfl][h][w][nflag] == -1){\n\t\t\t\t\tcost[nfl][h][w][nflag] = cost[fl][h][w][flag]+1;\n\t\t\t\t\tqu.push(Node(nfl, h, w, nflag));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nh = h+dx[i], nw = w+dy[i];\n\t\t\t\tif(mp[nh][nw]=='#') continue;\n\t\t\t\tif(mp[nh][nw]!='|' && fl != (floor[nh][nw]+bitCount(mask[nh][nw]&flag))%2) continue;\n\n\t\t\t\tif(cost[fl][nh][nw][flag] == -1){\n\t\t\t\t\tcost[fl][nh][nw][flag] = cost[fl][h][w][flag]+1;\n\t\t\t\t\tqu.push(Node(fl, nh, nw, flag));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[60][60];\nint key[11][60][60];\nchar in[60][60];\nint bfs[1<<10][60][60][2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<a;j++)scanf(\"%s\",in[j]);\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++){\n\t\t\tif(in[j][k]=='*')key[i][j][k]=1;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<(1<<c);i++)for(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[i][j][k][0]=bfs[i][j][k][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='%'){\n\t\tbfs[0][i][j][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t}\n\twhile(Q.size()){\n\t\tint v=Q.front().first.first;\n\t\tint f=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!~bfs[v][row+dx[i]][col+dy[i]][f]&&\n\t\t\tstr[row+dx[i]][col+dy[i]]!='#'){\n\t\t\t\tint H=0;if(str[row+dx[i]][col+dy[i]]=='^'||('A'<=str[row+dx[i]][col+dy[i]]&&str[row+dx[i]][col+dy[i]]<='Z'))H=1;\n\t\t\t\tfor(int j=0;j<c;j++)if((v&(1<<j))&&key[j][row+dx[i]][col+dy[i]])H=!H;\n\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='|'||H==f){\n\t\t\t\t\tbfs[v][row+dx[i]][col+dy[i]][f]=bfs[v][row][col][f]+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(v,f),make_pair(row+dx[i],col+dy[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str[row][col]=='|'&&!~bfs[v][row][col][!f]){\n\t\t\tbfs[v][row][col][!f]=bfs[v][row][col][f]+1;\n\t\t\tQ.push(make_pair(make_pair(v,!f),make_pair(row,col)));\n\t\t}\n\t\tif('a'<=(32|str[row][col])&&(32|str[row][col])<='z'){\n\t\t\tint H=f;\n\t\t\tif(key[(32|str[row][col])-'a'][row][col])H=!H;\n\t\t\tint to=v^(1<<((32|str[row][col])-'a'));\n\t\t\tif(!~bfs[to][row][col][H]){\n\t\t\t\tbfs[to][row][col][H]=bfs[v][row][col][f]+1;\n\t\t\t\tQ.push(make_pair(make_pair(to,H),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='&'){\n\t\tfor(int k=0;k<(1<<c);k++){\n\t\t\tint H=0;\n\t\t\tfor(int l=0;l<c;l++)if((k&(1<<l))&&key[l][i][b])H=!H;\n\t\t\tif(~bfs[k][i][j][H])ret=min(ret,bfs[k][i][j][H]);\n\t\t}\n\t}\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2447.cc: A Two Floors Dungeon\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_W = 50;\nconst int MAX_H = 50;\nconst int MAX_S = 10;\nconst int SBITS = 1 << MAX_S;\n\nconst int INF = 1 << 30;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\nenum { F_W = -1, F_F = 0, F_ST = 1, F_SW = 2 };\n\nstruct Stat {\n  int d, x, y, f, sw;\n  Stat() {}\n  Stat(int _d, int _x, int _y, int _f, int _sw):\n    d(_d), x(_x), y(_y), f(_f), sw(_sw) {}\n};\n\n/* global variables */\n\nint prtys[SBITS];\nint flds[MAX_H][MAX_W], ifs[MAX_H][MAX_W], sws[MAX_H][MAX_W];\nint dists[MAX_H][MAX_W][2][SBITS];\n\n/* subroutines */\n\ninline int calc_f(int x, int y, int sw) {\n  return ifs[y][x] ^ prtys[sws[y][x] & sw];\n}\n\n/* main */\n\nint main() {\n  int w, h;\n  cin >> w >> h;\n\n  int sx, sy, gx, gy;\n\n  for (int y = 0; y < h; y++) {\n    string s;\n    cin >> s;\n    for (int x = 0; x < w; x++) {\n      flds[y][x] = F_F;\n      ifs[y][x] = 0;\n      switch (s[x]) {\n      case '#': flds[y][x] = F_W; break;\n      case '|': flds[y][x] = F_ST; break;\n      case '_': break;\n      case '^': ifs[y][x] = 1; break;\n      case '%': sx = x; sy = y; break;\n      case '&': gx = x; gy = y; break;\n      default:\n\tif (s[x] >= 'a' && s[x] <= 'j')\n\t  flds[y][x] = F_SW + s[x] - 'a';\n\telse if (s[x] >= 'A' && s[x] <= 'J') {\n\t  flds[y][x] = F_SW + s[x] - 'A';\n\t  ifs[y][x] = 1;\n\t}\n      }\n    }\n  }\n\n  int sn;\n  cin >> sn;\n  int sbits = 1 << sn;\n\n  for (int i = 0, bi = 1; i < sn; i++, bi <<= 1)\n    for (int y = 0; y < h; y++) {\n      string s;\n      cin >> s;\n      for (int x = 0; x < w; x++)\n\tif (s[x] == '*') sws[y][x] |= bi;\n    }\n\n  for (int bits = 0; bits < sbits; bits++) {\n    prtys[bits] = 0;\n    for (int i = 0, bi = 1; i < sn; i++, bi <<= 1)\n      if (bits & bi) prtys[bits] ^= 1;\n  }\n  \n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      for (int f = 0; f < 2; f++)\n\tfor (int bits = 0; bits < sbits; bits++)\n\t  dists[y][x][f][bits] = INF;\n\n  dists[sy][sx][0][0] = 0;\n\n  queue<Stat> q;\n  q.push(Stat(0, sx, sy, 0, 0));\n\n  while (! q.empty()) {\n    Stat u = q.front(); q.pop();\n    if (u.x == gx && u.y == gy) break;\n\n    int vd = u.d + 1;\n\n    // up/down stair\n    if (flds[u.y][u.x] == F_ST) {\n      int vf = 1 - u.f;\n      if (dists[u.y][u.x][vf][u.sw] > vd) {\n\tdists[u.y][u.x][vf][u.sw] = vd;\n\tq.push(Stat(vd, u.x, u.y, vf, u.sw));\n      }\n    }\n\n    // toggle sw\n    if (flds[u.y][u.x] >= F_SW) {\n      int si = flds[u.y][u.x] - F_SW;\n      int vsw = u.sw ^ (1 << si);\n      int vf = calc_f(u.x, u.y, vsw);\n      if (dists[u.y][u.x][vf][vsw] > vd) {\n\tdists[u.y][u.x][vf][vsw] = vd;\n\tq.push(Stat(vd, u.x, u.y, vf, vsw));\n      }\n    }\n\n    // move to adjacent grid\n    for (int di = 0; di < 4; di++) {\n      int vx = u.x + dxs[di], vy = u.y + dys[di];\n      if (flds[vy][vx] == F_W) continue;\n      int vf = (flds[vy][vx] == F_ST) ? u.f : calc_f(vx, vy, u.sw);\n      if (vf == u.f && dists[vy][vx][vf][u.sw] > vd) {\n\tdists[vy][vx][vf][u.sw] = vd;\n\tq.push(Stat(vd, vx, vy, vf, u.sw));\n      }\n    }\n  }\n\n  int mind = INF;\n  for (int f = 0; f < 2; f++)\n    for (int bits = 0; bits < sbits; bits++)\n      if (mind > dists[gy][gx][f][bits]) mind = dists[gy][gx][f][bits];\n\n  printf(\"%d\\n\", (mind >= INF) ? -1 : mind);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tvector<Data> V;\n};\n\nstruct State{\n\tState(int arg_floor,int arg_row,int arg_col,int arg_button_state,int arg_step){\n\t\tfloor = arg_floor;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tbutton_state = arg_button_state;\n\t\tstep = arg_step;\n\t}\n\n\tbool operator<(const struct State &arg) const{\n\t\treturn step > arg.step;\n\t};\n\tint floor,row,col,button_state,step;\n};\n\nint W,H,POW[11],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar first_map[50][51];\n\nint dp[2][51][51][1024];\n\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tint start_row,start_col;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",first_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(first_map[row][col] == '%'){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t\tfirst_map[row][col] = '_';\n\t\t\t}\n\t\t}\n\t}\n\n\tint S;\n\tscanf(\"%d\",&S);\n\n\tInfo info[S];\n\tchar tmp_map[H][W+1];\n\n\tfor(int i = 0; i < S; i++){\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tscanf(\"%s\",tmp_map[row]);\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(tmp_map[row][col] == '*'){\n\t\t\t\t\tinfo[i].V.push_back(Data(row,col));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 2; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfor(int state = 0; state < POW[S]; state++)dp[i][row][col][state] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpriority_queue<State> Q;\n\tdp[0][start_row][start_col][0] = 0;\n\tQ.push(State(0,start_row,start_col,0,0));\n\n\tint calc_map[2][H][W];\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().step > dp[Q.top().floor][Q.top().row][Q.top().col][Q.top().button_state]){\n\t\t\tQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tint calc_table[H][W];\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++)calc_table[row][col] = 0;\n\t\t}\n\n\t\tfor(int loop = 0; loop < S; loop++){\n\t\t\tif(Q.top().button_state & (1 << loop)){\n\t\t\t\tfor(int i = 0; i < info[loop].V.size(); i++){\n\t\t\t\t\tcalc_table[info[loop].V[i].row][info[loop].V[i].col]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tswitch(first_map[row][col]){\n\t\t\t\tcase '#':\n\t\t\t\t\tcalc_map[0][row][col] = '#';\n\t\t\t\t\tcalc_map[1][row][col] = '#';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tcalc_map[0][row][col] = '|';\n\t\t\t\t\tcalc_map[1][row][col] = '|';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '_';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '^';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\tcalc_map[0][row][col] = '&';\n\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\tcalc_map[1][row][col] = '&';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(first_map[row][col] >= 'a' && first_map[row][col] <= 'j'){\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col];\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col]-32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(calc_table[row][col]%2 == 0){\n\t\t\t\t\t\t\tcalc_map[0][row][col] = '^';\n\t\t\t\t\t\t\tcalc_map[1][row][col] = first_map[row][col];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_map[0][row][col] = first_map[row][col]+32;\n\t\t\t\t\t\t\tcalc_map[1][row][col] = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint adj_row = Q.top().row + diff_row[i];\n\t\t\tint adj_col = Q.top().col + diff_col[i];\n\n\t\t\tif(Q.top().floor == 0){\n\n\t\t\t\tif(calc_map[0][adj_row][adj_col] == '_'){\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[0][adj_row][adj_col] >= 'a' && calc_map[0][adj_row][adj_col] <= 'j'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'a';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tfor(int k = 0; k < info[num].V.size(); k++){\n\t\t\t\t\t\tif(info[num].V[k].row == adj_row && info[num].V[k].col == adj_col){\n\t\t\t\t\t\t\tnext_floor = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(calc_map[1][adj_row][adj_col] == '^'){\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '|'){\n\n\t\t\t\t\tif(dp[0][adj_row][adj_col][Q.top().button_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[0][adj_row][adj_col][Q.top().button_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(0,adj_row,adj_col,Q.top().button_state,Q.top().step+2));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] == '&'){\n\t\t\t\t\tprintf(\"%d\\n\",Q.top().step+1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}else if(calc_map[1][adj_row][adj_col] >= 'A' && calc_map[1][adj_row][adj_col] <= 'J'){\n\n\t\t\t\t\tif(dp[1][adj_row][adj_col][Q.top().button_state] > Q.top().step+1){\n\t\t\t\t\t\tdp[1][adj_row][adj_col][Q.top().button_state] = Q.top().step+1;\n\t\t\t\t\t\tQ.push(State(1,adj_row,adj_col,Q.top().button_state,Q.top().step+1));\n\t\t\t\t\t}\n\n\t\t\t\t\tint num = calc_map[Q.top().floor][adj_row][adj_col] - 'A';\n\n\t\t\t\t\tint next_floor = Q.top().floor;\n\t\t\t\t\tfor(int k = 0; k < info[num].V.size(); k++){\n\t\t\t\t\t\tif(info[num].V[k].row == adj_row && info[num].V[k].col == adj_col){\n\t\t\t\t\t\t\tnext_floor = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint next_state;\n\t\t\t\t\tif(Q.top().button_state & (1 << num)){\n\t\t\t\t\t\tnext_state = Q.top().button_state - POW[num];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = Q.top().button_state + POW[num];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(dp[next_floor][adj_row][adj_col][next_state] > Q.top().step+2){\n\t\t\t\t\t\tdp[next_floor][adj_row][adj_col][next_state] = Q.top().step+2;\n\t\t\t\t\t\tQ.push(State(next_floor,adj_row,adj_col,next_state,Q.top().step+2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[60][60];\nint key[11][60][60];\nchar in[60][60];\nint bfs[1<<10][60][60][2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint c;scanf(\"%d\",&c);\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<a;j++)scanf(\"%s\",in[j]);\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++){\n\t\t\tif(in[j][k]=='*')key[i][j][k]=1;\n\t\t}\n\t}\n\tqueue<pair<pair<int,int>,pair<int,int> > >Q;\n\tfor(int i=0;i<(1<<c);i++)for(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[i][j][k][0]=bfs[i][j][k][1]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='%'){\n\t\tbfs[0][i][j][0]=0;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(i,j)));\n\t}\n\twhile(Q.size()){\n\t\tint v=Q.front().first.first;\n\t\tint f=Q.front().first.second;\n\t\tint row=Q.front().second.first;\n\t\tint col=Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!~bfs[v][row+dx[i]][col+dy[i]][f]&&\n\t\t\tstr[row+dx[i]][col+dy[i]]!='#'){\n\t\t\t\tint H=0;if(str[row+dx[i]][col+dy[i]]=='^'||('A'<=str[row+dx[i]][col+dy[i]]&&str[row+dx[i]][col+dy[i]]<='Z'))H=1;\n\t\t\t\tfor(int j=0;j<c;j++)if((v&(1<<j))&&key[j][row+dx[i]][col+dy[i]])H=!H;\n\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='|'||H==f){\n\t\t\t\t\tbfs[v][row+dx[i]][col+dy[i]][f]=bfs[v][row][col][f]+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(v,f),make_pair(row+dx[i],col+dy[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str[row][col]=='|'&&!~bfs[v][row][col][!f]){\n\t\t\tbfs[v][row][col][!f]=bfs[v][row][col][f]+1;\n\t\t\tQ.push(make_pair(make_pair(v,!f),make_pair(row,col)));\n\t\t}\n\t\tif('a'<=(32|str[row][col])&&(32|str[row][col])<='z'){\n\t\t\tint H=f;\n\t\t\tif(key[(32|str[row][col])-'a'][row][col])H=!H;\n\t\t\tint to=v^(1<<((32|str[row][col])-'a'));\n\t\t\tif(!~bfs[to][row][col][H]){\n\t\t\t\tbfs[to][row][col][H]=bfs[v][row][col][f]+1;\n\t\t\t\tQ.push(make_pair(make_pair(to,H),make_pair(row,col)));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=999999999;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='&'){\n\t\tfor(int k=0;k<(1<<c);k++){\n\t\t\tint H=0;\n\t\t\tfor(int l=0;l<c;l++)if((k&(1<<l))&&key[l][i][b])\n\t\t\tif(~bfs[k][i][j][H])ret=min(ret,bfs[k][i][j][H]);\n\t\t}\n\t}\n\tif(ret>99999999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<int,P2> PP;\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nint d[55][55][1<<10][2],dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint main() {\n  int n,m;\n  cin >> m >> n;\n  string s[n];\n  for(int i=0; i<n; i++) cin >> s[i];\n  int N;\n  cin >> N;\n  string t[N][n];\n  for(int i=0;i<N;i++)for(int j=0;j<n;j++)cin >> t[i][j];\n  for(int i=0;i<n;i++)for(int j=0;j<m;j++)for(int k=0;k<(1<<N);k++)for(int l=0;l<2;l++) d[i][j][k][l]=1<<29;\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<m; j++) {\n      if(s[i][j]=='%') {\n        d[i][j][0][0]=0;\n        que.push(PP(0,P2(P(i,j),P(0,0))));\n      }\n    }\n  }\n  map<char,int> ma;\n  ma['_']=0;ma['^']=1;ma['%']=0;ma['&']=0;\n  for(int i=0; i<N; i++) {\n    ma[(char)('a'+i)]=0;\n    ma[(char)('A'+i)]=1;\n  }\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    int xx=p.S.F.F,yy=p.S.F.S,tt=p.S.S.F,k=p.S.S.S,cc=p.F;\n    if(s[xx][yy]=='&') {\n      cout << cc << endl;\n      return 0;\n    }\n    if(d[xx][yy][tt][k]>cc) continue;\n    for(int i=0; i<4; i++) {\n      int x=xx+dx[i],y=yy+dy[i];\n      if(!check(n,m,x,y)||s[x][y]=='#') continue;\n      int c=0;\n      for(int j=0; j<N; j++) {\n        if((tt&(1<<j))&&t[j][x][y]=='*') c++;\n      }\n      if(ma.count(s[x][y])&&(ma[s[x][y]]^(c%2))!=k) continue;\n      if(d[x][y][tt][k]>d[xx][yy][tt][k]+1) {\n        d[x][y][tt][k]=d[xx][yy][tt][k]+1;\n        que.push(PP(d[x][y][tt][k],P2(P(x,y),P(tt,k))));\n      }\n    }\n    if(isalpha(s[xx][yy])) {\n      int r=islower(s[xx][yy])?(s[xx][yy]-'a'):(s[xx][yy]-'A');\n      int f=t[r][xx][yy]=='*';\n      if(d[xx][yy][tt^(1<<r)][k^f]>d[xx][yy][tt][k]+1) {\n        d[xx][yy][tt^(1<<r)][k^f]=d[xx][yy][tt][k]+1;\n        que.push(PP(d[xx][yy][tt^(1<<r)][k^f],P2(P(xx,yy),P(tt^(1<<r),k^f))));\n      }\n    }\n    if(s[xx][yy]=='|') {\n      if(d[xx][yy][tt][k^1]>d[xx][yy][tt][k]+1) {\n        d[xx][yy][tt][k^1]=d[xx][yy][tt][k]+1;\n        que.push(PP(d[xx][yy][tt][k^1],P2(P(xx,yy),P(tt,k^1))));\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint H, W, S;\nint sx, sy, gx, gy;\nvector<string> board;\nvector<vector<string>> switches;\nint d[50][50][2][1 << 10];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nint whichFloor(int x, int y, int bit) {\n    int f = 0;\n    if (board[x][y] == '^' || isupper(board[x][y])) f = 1;\n    rep(s, S) {\n        if (((bit >> s) & 1) && switches[s][x][y] == '*') {\n            f ^= 1;\n        }\n    }\n    return f;\n}\n\nbool cango(int f, int nx, int ny, int bit) {\n    if (board[nx][ny] == '|') return true;\n    if (board[nx][ny] == '#') return false;\n    return f == whichFloor(nx, ny, bit);\n}\n\nint bfs() {\n    using State = tuple<int, int, int, int>; // x, y, f, bit\n    queue<State> que;\n    que.emplace(sx, sy, 0, 0);\n    rep(i, H) rep(j, W) rep(f, 2) rep(bit, 1 << S) d[i][j][f][bit] = inf;\n    d[sx][sy][0][0] = 0;\n\n    auto update = [&](int x, int y, int f, int bit, int cost) {\n        if (d[x][y][f][bit] != inf) return;\n        d[x][y][f][bit] = cost + 1;\n        que.emplace(x, y, f, bit);\n    };\n\n    while (!que.empty()) {\n        int x, y, f, bit;\n        tie(x, y, f, bit) = que.front(); que.pop();\n        int cost = d[x][y][f][bit];\n\n        // output(x, y, f, bit, cost);\n\n        if (x == gx && y == gy) {\n            return cost;\n        }\n\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (cango(f, nx, ny, bit)) {\n                update(nx, ny, f, bit, cost);\n            }\n        }\n\n        if (board[x][y] == '|') {\n            update(x, y, f^1, bit, cost);\n        }\n\n        if ((f == 1 && isupper(board[x][y])) || (f == 0 && islower(board[x][y]))) {\n            int id_switch = (isupper(board[x][y]) ? board[x][y] - 'A' : board[x][y] - 'a');\n            int nbit = bit ^ (1 << id_switch);\n            int nf = f;\n            // output(board[x][y], id_switch, x, y);\n            if (switches[id_switch][x][y] == '*') {\n                nf ^= 1;\n            }\n            // cerr << \"hey!\" << endl;\n\n            update(x, y, nf, nbit, cost);\n        }\n\n\n    }\n\n    return -1;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> W >> H;\n    board.resize(H);\n    rep(i, H) {\n        cin >> board[i];\n        rep(j, W) {\n            if (board[i][j] == '%') {\n                sx = i; sy = j;\n            } else if (board[i][j] == '&') {\n                gx = i; gy = j;\n            }\n        }\n    }\n    cin >> S;\n    switches.resize(S, vector<string>(H));\n    rep(s, S) {\n        rep(i, H) cin >> switches[s][i];\n    }\n\n    cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ld INF = 1e+30;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nint n, m;\n\nchar mp[1024][2][50][50];\nchar ch[10][50][50];\nstruct status {\n\tint i, j, x, y;\n\tbool operator<(const status &s)const {\n\t\tif (i != s.i)return i < s.i;\n\t\tif (j != s.j)return j < s.j;\n\t\tif (x != s.x)return x < s.x;\n\t\treturn y < s.y;\n\t}\n};\nbool used[1024][2][50][50];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nvoid solve() {\n\tcin >> m >> n;\n\tint sx, sy,gx,gy;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '#' || t == '|') {\n\t\t\t\trep(k, 2) {\n\t\t\t\t\tmp[0][k][i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (t == '_') {\n\t\t\t\tmp[0][0][i][j] = '.';\n\t\t\t\tmp[0][1][i][j] = '#';\n\t\t\t}\n\t\t\telse if (t == '^') {\n\t\t\t\tmp[0][0][i][j] = '#';\n\t\t\t\tmp[0][1][i][j] = '.';\n\t\t\t}\n\t\t\telse if ('a' <= t && t <= 'z') {\n\t\t\t\tmp[0][0][i][j] = '0'+(t-'a');\n\t\t\t\tmp[0][1][i][j] = '#';\n\t\t\t}\n\t\t\telse if ('A' <= t && t <= 'Z') {\n\t\t\t\tmp[0][0][i][j] = '#';\n\t\t\t\tmp[0][1][i][j] = '0'+(t-'A');\n\t\t\t}\n\t\t\telse if (t == '%') {\n\t\t\t\tsx = i, sy = j;\n\t\t\t\tmp[0][0][i][j] = '.';\n\t\t\t\tmp[0][1][i][j] = '#';\n\t\t\t}\n\t\t\telse if (t == '&') {\n\t\t\t\tgx = i, gy = j;\n\t\t\t\tmp[0][0][i][j] = '.';\n\t\t\t\tmp[0][1][i][j] = '#';\n\t\t\t}\n\t\t}\n\t}\n\tint s; cin >> s;\n\trep(i, s) {\n\t\trep(j, n) {\n\t\t\trep(k, m) {\n\t\t\t\tcin >> ch[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, (1 << s)) {\n\t\trep(j, 2) {\n\t\t\trep(k, n) {\n\t\t\t\trep(l, m) {\n\t\t\t\t\tmp[i][j][k][l] = mp[0][j][k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, s) {\n\t\t\tif (i&(1 << j)) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\trep(l, m) {\n\t\t\t\t\t\tif (ch[j][k][l] == '*') {\n\t\t\t\t\t\t\tswap(mp[i][0][k][l], mp[i][1][k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tmp = 0;\n\tqueue<status> q; q.push({ 0,0,sx,sy });\n\tused[0][0][sx][sy] = true;\n\tint ans = -1;\n\twhile (!q.empty()) {\n\t\tint len = q.size();\n\t\t//cout << tmp << endl;\n\t\trep(aa, len) {\n\t\t\tstatus v = q.front(); q.pop();\n\t\t\t//cout << v.i << \" \" << v.j << \" \" << v.x << \" \" << v.y << endl;\n\t\t\tint x = v.x, y = v.y;\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\tans = tmp;\n\t\t\t\twhile (!q.empty())q.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar memo = mp[v.i][v.j][x][y];\n\t\t\tif (memo == '|') {\n\t\t\t\tif (!used[v.i][v.j ^ 1][x][y]) {\n\t\t\t\t\tused[v.i][v.j ^ 1][x][y] = true;\n\t\t\t\t\tq.push({ v.i,v.j ^ 1,x,y });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ('0' <= memo && memo <= '9') {\n\t\t\t\tint u = memo - '0';\n\t\t\t\tint ni = v.i ^ (1 << u);\n\t\t\t\tint nj = v.j;\n\t\t\t\tif (mp[ni][v.j][x][y] == '#') {\n\t\t\t\t\tnj ^= 1;\n\t\t\t\t}\n\t\t\t\tif (!used[ni][nj][x][y]) {\n\t\t\t\t\tused[ni][nj][x][y] = true;\n\t\t\t\t\tq.push({ ni,nj,x,y });\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 4) {\n\t\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\t\tif (mp[v.i][v.j][nx][ny] != '#') {\n\t\t\t\t\tif (!used[v.i][v.j][nx][ny]) {\n\t\t\t\t\t\tused[v.i][v.j][nx][ny] = true;\n\t\t\t\t\t\tq.push({ v.i,v.j,nx,ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp++;\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nstruct state\n{\n  int f;\n  int i, j;\n  unsigned s;\n  state() : f(0), i(-1), j(-1), s(0) {}\n  state(int a, int b, int c, unsigned d) : f(a), i(b), j(c), s(d) {}\n};\n\nstruct dungeon\n{\n  vector<string> grid;\n  vector<vector<string> > moves;\n\n  inline static int initial_floor(char c)\n  {\n    return c == '^' || isupper(c);\n  }\n\n  char get(const state& s) const\n  {\n    const char c = grid[s.i][s.j];\n    if (c == '#' || c == '|') {\n      return c;\n    }\n    int f = initial_floor(c);\n    const int S = moves.size();\n    for (int i = 0; i < S; i++) {\n      const vector<string>& g = moves[i];\n      if ((s.s & (1<<i)) && g[s.i][s.j] == '*') {\n        f ^= 1;\n      }\n    }\n    if (f == s.f) {\n      return tolower(c);\n    } else {\n      return '#';\n    }\n  }\n};\n\nint main()\n{\n  int H, W;\n  dungeon d;\n  cin >> W >> H;\n  d.grid.resize(H);\n  state start;\n  for (int i = 0; i < H; i++) {\n    cin >> d.grid[i];\n    for (int j = 0; j < W; j++) {\n      if (d.grid[i][j] == '%') {\n        start.i = i;\n        start.j = j;\n      }\n    }\n  }\n  int S;\n  cin >> S;\n  for (int k = 0; k < S; k++) {\n    vector<string> v(H);\n    for (int i = 0; i < H; i++) {\n      cin >> v[i];\n    }\n    d.moves.push_back(v);\n  }\n\n  static const int INF = 10000000;\n  static int dist[2][50][50][1<<10];\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < H; j++) {\n      for (int k = 0; k < W; k++) {\n        fill_n(dist[i][j][k], 1<<S, INF);\n      }\n    }\n  }\n  dist[start.f][start.i][start.j][start.s] = 0;\n  queue<state> q;\n  q.push(start);\n  while (!q.empty()) {\n    const state s = q.front();\n    q.pop();\n    const int dd = dist[s.f][s.i][s.j][s.s] + 1;\n    const char here = d.get(s);\n    if (here == '&') {\n      cout << dd-1 << endl;\n      return 0;\n    }\n\n    for (int i = 0; i < 4; i++) {\n      static const int di[] = {-1, 1, 0, 0}, dj[] = {0, 0, -1, 1};\n      const state t(s.f, s.i + di[i], s.j + dj[i], s.s);\n      int& next = dist[t.f][t.i][t.j][t.s];\n      if (d.get(t) != '#' && dd < next) {\n        next = dd;\n        q.push(t);\n      }\n    }\n\n    if (here == '|') {\n      const state t(s.f ^ 1, s.i, s.j, s.s);\n      int& next = dist[t.f][t.i][t.j][t.s];\n      if (dd < next) {\n        next = dd;\n        q.push(t);\n      }\n    } else if (isalpha(here)) {\n      const int sw = here - 'a';\n      int f = s.f;\n      if (d.moves[sw][s.i][s.j] == '*') {\n        f ^= 1;\n      }\n      const state t(f, s.i, s.j, s.s ^ (1<<sw));\n      int& next = dist[t.f][t.i][t.j][t.s];\n      if (dd < next) {\n        next = dd;\n        q.push(t);\n      }\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2447 A Two Floors Dungeon\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define QMAX 800000\ntypedef struct { short s; char f, r, c; } Q;\nQ q[QMAX+10]; int top, end;\n\nint S;\nchar map[53][53];\nchar sw[11][53][53];\nint mov[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint memo[1024][2][53][53];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int s, int f, int r, int c)\n{\n\tint i, g;\n\n\tif (map[r][c] == '|') return 1;\n\tg = map[r][c] == '^' || isupper(map[r][c]);\n\tfor (i = 0; i < S; i++) if ((s >> i) & 1) g ^= sw[i][r][c];\n\treturn g == f;\n}\n\nvoid enq(int ns, int nf, int nr, int nc, int k)\n{\n\tif (memo[ns][nf][nr][nc]) return;\n\tmemo[ns][nf][nr][nc] = k;\n\tq[end].s = ns, q[end].f = nf, q[end].r = nr, q[end++].c = nc;\n}\n\nint calc(int sr, int sc)\n{\n\tint i, k, s, f, r, c, nr, nc;\n\n\tq[0].r = sr, q[0].c = sc, top = 0, end = 1;\n\tmemo[0][0][sr][sc] = 1;\n\twhile (top != end) {\n\t\tif (end >= QMAX) break;\n\t\ts = q[top].s, f = q[top].f, r = q[top].r, c = q[top++].c;\n\t\tk = memo[s][f][r][c] + 1;\n\t\tif (map[r][c] == '&') return k-2;\n\t\tif (map[r][c] == '|') enq(s, f ^ 1, r, c, k);\n\t\tif (isalpha(map[r][c])) {\n\t\t\ti = (map[r][c] & 0x1f) - 1;\n\t\t\tenq(s ^ (1 << i), f ^ sw[i][r][c], r, c, k);\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mov[i][0], nc = c + mov[i][1];\n\t\t\tif (map[nr][nc] == '#') continue;\n\t\t\tif (check(s, f, nr, nc)) enq(s, f, nr, nc, k);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint W, H, i, r, c, sr, sc; \n\tchar buf[53];\n\n\tW = in(), H = in();\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 53, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n\t\t}\n\t}\n\n\tS = in();\n\tfor (i = 0; i < S; i++) {\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tfgets(buf, 53, stdin);\n\t\t\tfor (c = 0; c < W; c++) {\n\t\t\t\tif (buf[c] == '*') sw[i][r][c] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", calc(sr, sc));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2447 A Two Floors Dungeon\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define QMAX 800000\ntypedef struct { short s; char f, r, c; } Q;\nQ q[QMAX+10]; int top, end;\n\nint S;\nchar map[53][53];\nchar sw[11][53][53];\nint mov[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint memo[1024][2][53][53];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int s, int f, int r, int c)\n{\n\tint i, g;\n\n\tif (map[r][c] == '|') return 1;\n\tg = map[r][c] == '^' || isupper(map[r][c]);\n\tfor (i = 0; i < S; i++) if ((s >> i) & 1) g ^= sw[i][r][c];\n\treturn g == f;\n}\n\nvoid enq(int ns, int nf, int nr, int nc, int s, int f, int r, int c)\n{\n\tif (memo[ns][nf][nr][nc]) return;\n\tmemo[ns][nf][nr][nc] = memo[s][f][r][c] + 1;\n\tq[end].s = ns, q[end].f = nf, q[end].r = nr, q[end++].c = nc;\n}\n\nint calc(int sr, int sc)\n{\n\tint k, s, f, r, c, nr, nc;\n\n\tq[0].r = sr, q[0].c = sc, top = 0, end = 1;\n\tmemo[0][0][sr][sc] = 1;\n\twhile (top != end) {\n\t\tif (end >= QMAX) break;\n\t\ts = q[top].s, f = q[top].f, r = q[top].r, c = q[top++].c;\n\t\tif (map[r][c] == '&') return memo[s][f][r][c]-1;\n\t\tif (map[r][c] == '|') enq(s, f ^ 1, r, c, s, f, r, c);\n\t\tif (isalpha(map[r][c])) {\n\t\t\tk = (map[r][c] & 0x1f) - 1;\n\t\t\tenq(s ^ (1 << k), f ^ sw[k][r][c], r, c, s, f, r, c);\n\t\t}\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tnr = r + mov[k][0], nc = c + mov[k][1];\n\t\t\tif (map[nr][nc] == '#') continue;\n\t\t\tif (check(s, f, nr, nc)) enq(s, f, nr, nc, s, f, r, c);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint W, H, i, r, c, sr, sc; \n\tchar buf[53];\n\n\tW = in(), H = in();\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 53, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n\t\t}\n\t}\n\n\tS = in();\n\tfor (i = 0; i < S; i++) {\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tfgets(buf, 53, stdin);\n\t\t\tfor (c = 0; c < W; c++) {\n\t\t\t\tif (buf[c] == '*') sw[i][r][c] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", calc(sr, sc));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2447 A Two Floors Dungeon\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define QMAX 800000\ntypedef struct { short s; char f, r, c; } Q;\nQ q[QMAX+10]; int top, end;\n\nint W, H, S;\nchar map[53][53];\nchar sw[11][53][53];\nint mov[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint memo[1024][2][53][53];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int s, int f, int r, int c)\n{\n\tint i, g;\n\n    if (map[r][c] == '|') return 1;\n    g = map[r][c] == '^' || isupper(map[r][c]);\n    for (i = 0; i < S; ++i) if ((s >> i) & 1) g ^= sw[i][r][c];\n    return f == g;\n}\n\nvoid enq(int ns, int nf, int nr, int nc, int s, int f, int r, int c)\n{\n\tint k;\n\n\tif (memo[ns][nf][nr][nc] >= 0) return;\n\tmemo[ns][nf][nr][nc] = k = memo[s][f][r][c] + 1;\n\tq[end].s = ns, q[end].f = nf, q[end].r = nr, q[end++].c = nc;\n}\n\nint calc(int sr, int sc)\n{\n\tint k, s, f, r, c, nr, nc;\n\n\tmemset(memo, -1, sizeof memo);\n\tq[0].s = q[0].f = 0, q[0].r = sr, q[0].c = sc, top = 0, end = 1;\n\tmemo[0][0][sr][sc] = 0;\n    while (top != end) {\n\t\tif (end >= QMAX) break;\n\t\ts = q[top].s, f = q[top].f, r = q[top].r, c = q[top++].c;\n\t\tif (map[r][c] == '&') return memo[s][f][r][c];\n\t\tif (map[r][c] == '|') enq(s, f ^ 1, r, c, s, f, r, c);\n\t\tif (isalpha(map[r][c])) {\n\t\t\tk = tolower(map[r][c]) - 'a';\n\t\t\tenq(s ^ (1 << k), f ^ sw[k][r][c], r, c, s, f, r, c);\n        }\n        for (k = 0; k < 4; k++) {\n            nr = r + mov[k][0], nc = c + mov[k][1];\n\t\t\tif (map[nr][nc] == '#') continue;\n\t\t\tif (!check(s, f, nr, nc)) continue;\n\t\t\tenq(s, f, nr, nc, s, f, r, c);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, r, c, sr, sc; \n\tchar buf[53];\n\n\tW = in(), H = in();\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 53, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n        }\n\t}\n\n\tS = in();\n\tfor (i = 0; i < S; i++) {\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tfgets(buf, 53, stdin);\n\t\t\tfor (c = 0; c < W; c++) {\n\t\t\t\tif (buf[c] == '*') sw[i][r][c] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", calc(sr, sc));\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2447 A Two Floors Dungeon\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { short s; char f, r, c; } Q;\nQ q[QMAX+2]; int top, end;\n\nint W, H, S;\nchar map[53][53];\nchar sw[11][53][53];\nint mov[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint memo[1024][2][53][53];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int s, int f, int r, int c)\n{\n\tint i, g;\n\n    if (map[r][c] == '|') return 1;\n    g = map[r][c] == '^' || isupper(map[r][c]);\n    for (i = 0; i < S; ++i) if ((s >> i) & 1) g ^= sw[i][r][c];\n    return f == g;\n}\n\nvoid enq(int ns, int nf, int nr, int nc, int s, int f, int r, int c)\n{\n\tif (memo[ns][nf][nr][nc] >= 0) return;\n\tmemo[ns][nf][nr][nc] = memo[s][f][r][c] + 1;\n\tq[end].s = ns, q[end].f = nf, q[end].r = nr, q[end].c = nc;\n\tif (++end == QMAX) end = 0;\n}\n\nint calc(int sr, int sc)\n{\n\tint k, s, f, r, c, nr, nc;\n\n\tmemset(memo, -1, sizeof memo);\n\tq[0].s = q[0].f = 0, q[0].r = sr, q[0].c = sc, top = 0, end = 1;\n\tmemo[0][0][sr][sc] = 0;\n    while (top != end) {\n\t\ts = q[top].s, f = q[top].f, r = q[top].r, c = q[top].c;\n\t\tif (++top == QMAX) top = 0;\n\t\tif (map[r][c] == '&') return memo[s][f][r][c];\n\t\tif (map[r][c] == '|') enq(s, f ^ 1, r, c, s, f, r, c);\n\t\tif (isalpha(map[r][c])) {\n\t\t\tk = tolower(map[r][c]) - 'a';\n\t\t\tenq(s ^ (1 << k), f ^ sw[k][r][c], r, c, s, f, r, c);\n        }\n        for (k = 0; k < 4; k++) {\n            nr = r + mov[k][0], nc = c + mov[k][1];\n\t\t\tif (map[nr][nc] == '#') continue;\n\t\t\tif (!check(s, f, nr, nc)) continue;\n\t\t\tenq(s, f, nr, nc, s, f, r, c);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, r, c, sr, sc; \n\tchar buf[53];\n\n\tW = in(), H = in();\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 53, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n        }\n\t}\n\n\tS = in();\n\tfor (i = 0; i < S; i++) {\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tfgets(buf, 53, stdin);\n\t\t\tfor (c = 0; c < W; c++) {\n\t\t\t\tif (buf[c] == '*') sw[i][r][c] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", calc(sr, sc));\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint w, h;\n\tint s;\n\tchar[][] map;\n\tchar[][][] maps;\n\n\tvoid run(){\n\t\tw=sc.nextInt();\n\t\th=sc.nextInt();\n\t\tmap=new char[h][];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tmap[i]=sc.next().toCharArray();\n\t\t}\n\t\ts=sc.nextInt();\n\t\tmaps=new char[s][h][];\n\t\tfor(int j=0; j<s; j++){\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tmaps[j][i]=sc.next().toCharArray();\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tchar WALL='#', STAIRS='|', FIRST='_', SECOND='^', START='%', GOAL='&';\n\n\tvoid solve(){\n\t\tint[][][][] d=new int[h][w][2][1<<s];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tfill(d[j][i][0], INF);\n\t\t\t\tfill(d[j][i][1], INF);\n\t\t\t}\n\t\t}\n\n\t\tint xs=-1, ys=-1; // %\n\t\tint xg=-1, yg=-1; // &\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tif(map[j][i]==START){\n\t\t\t\t\txs=i;\n\t\t\t\t\tys=j;\n\t\t\t\t}else if(map[j][i]==GOAL){\n\t\t\t\t\txg=i;\n\t\t\t\t\tyg=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\n\t\tboolean[][][] ok=new boolean[2][h][w];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tchar c=map[j][i];\n\t\t\t\tok[0][j][i]=c==STAIRS||c==FIRST\n\t\t\t\t\t\t||Character.isLowerCase(c)||c==START||c==GOAL;\n\t\t\t\tok[1][j][i]=c==STAIRS||c==SECOND\n\t\t\t\t\t\t||Character.isUpperCase(c);\n\t\t\t}\n\t\t}\n\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xs, ys, 0, 0));\n\t\td[ys][xs][0][0]=0;\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n//\t\t\tdebug(p.x, p.y, p.floor, p.sw, d[p.y][p.x][p.floor][p.sw]);\n\t\t\tint floor=0;\n\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\tif((p.sw>>i&1)==1&&maps[i][p.y][p.x]=='*'){\n\t\t\t\t\tfloor=1-floor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p.floor==1){\n\t\t\t\tfloor=1-floor;\n\t\t\t}\n\t\t\tLinkedList<P> next=new LinkedList<P>();\n\t\t\tif(map[p.y][p.x]==STAIRS){\n\t\t\t\tnext.add(new P(p.x, p.y, 1-p.floor, p.sw));\n\t\t\t}\n\t\t\t// ã¹ã¤ãã\n\t\t\tif(Character.isLetter(map[p.y][p.x])){\n\t\t\t\tint sw=Character.toLowerCase(map[p.y][p.x])-'a';\n\t\t\t\tif(maps[sw][p.y][p.x]=='*'){\n\t\t\t\t\tnext.add(new P(p.x, p.y, 1-p.floor, p.sw^(1<<sw)));\n\t\t\t\t}else{\n\t\t\t\t\tnext.add(new P(p.x, p.y, p.floor, p.sw^(1<<sw)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i], p.floor, p.sw);\n\t\t\t\tint floor2=0;\n\t\t\t\tfor(int j=0; j<s; j++){\n\t\t\t\t\tif((q.sw>>j&1)==1&&maps[j][q.y][q.x]=='*'){\n\t\t\t\t\t\tfloor2=1-floor2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q.floor==1){\n\t\t\t\t\tfloor2=1-floor2;\n\t\t\t\t}\n\n\t\t\t\tif(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&ok[floor2][q.y][q.x]){\n\t\t\t\t\tnext.add(q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(P q : next){\n\t\t\t\tif(d[p.y][p.x][p.floor][p.sw]+1<d[q.y][q.x][q.floor][q.sw]){\n\t\t\t\t\td[q.y][q.x][q.floor][q.sw]=d[p.y][p.x][p.floor][p.sw]+1;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min=INF;\n\t\tfor(int i=0; i<1<<s; i++){\n\t\t\tmin=min(min, d[yg][xg][0][i]);\n\t\t}\n\t\tprintln((min<INF?min:-1)+\"\");\n\t}\n\n\tclass P{\n\t\tint x, y, floor, sw;\n\n\t\tP(int x, int y, int floor, int sw){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.floor=floor;\n\t\t\tthis.sw=sw;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint w, h;\n\tint s;\n\tchar[][] map;\n\tchar[][][] maps;\n\n\tvoid run(){\n\t\tw=sc.nextInt();\n\t\th=sc.nextInt();\n\t\tmap=new char[h][];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tmap[i]=sc.next().toCharArray();\n\t\t}\n\t\ts=sc.nextInt();\n\t\tmaps=new char[s][h][];\n\t\tfor(int j=0; j<s; j++){\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tmaps[j][i]=sc.next().toCharArray();\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tchar WALL='#', STAIRS='|', FIRST='_', SECOND='^', START='%', GOAL='&';\n\n\tvoid solve(){\n\t\tint[][][][] d=new int[h][w][2][1<<s];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tfill(d[j][i][0], INF);\n\t\t\t\tfill(d[j][i][1], INF);\n\t\t\t}\n\t\t}\n\n\t\tint xs=-1, ys=-1;\n\t\tint xg=-1, yg=-1;\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tif(map[j][i]==START){\n\t\t\t\t\txs=i;\n\t\t\t\t\tys=j;\n\t\t\t\t}else if(map[j][i]==GOAL){\n\t\t\t\t\txg=i;\n\t\t\t\t\tyg=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\n\t\tboolean[][][] ok=new boolean[2][h][w];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tchar c=map[j][i];\n\t\t\t\tok[0][j][i]=c==STAIRS||c==FIRST||Character.isLowerCase(c)\n\t\t\t\t\t\t||c==START||c==GOAL;\n\t\t\t\tok[1][j][i]=c==STAIRS||c==SECOND||Character.isUpperCase(c);\n\t\t\t}\n\t\t}\n\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xs, ys, 0, 0));\n\t\td[ys][xs][0][0]=0;\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n//\t\t\tdebug(p.x, p.y, p.floor, p.sw, d[p.y][p.x][p.floor][p.sw]);\n\t\t\tint virtualFloor=p.floor;\n\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\tif((p.sw>>i&1)==1&&maps[i][p.y][p.x]=='*'){\n\t\t\t\t\tvirtualFloor=1-virtualFloor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<P> next=new LinkedList<P>();\n\t\t\tif(map[p.y][p.x]==STAIRS){\n\t\t\t\tnext.add(new P(p.x, p.y, 1-p.floor, p.sw));\n\t\t\t}\n\t\t\t// ã¹ã¤ãã\n\t\t\tif(Character.isLetter(map[p.y][p.x])){\n\t\t\t\tint sw=Character.toLowerCase(map[p.y][p.x])-'a';\n\t\t\t\tif(maps[sw][p.y][p.x]=='*'){\n\t\t\t\t\tnext.add(new P(p.x, p.y, 1-p.floor, p.sw^(1<<sw)));\n\t\t\t\t}else{\n\t\t\t\t\tnext.add(new P(p.x, p.y, p.floor, p.sw^(1<<sw)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tP q=new P(p.x+dx[k], p.y+dy[k], p.floor, p.sw);\n\t\t\t\tint virtualFloor2=q.floor;\n\t\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\t\tif((q.sw>>i&1)==1&&maps[i][q.y][q.x]=='*'){\n\t\t\t\t\t\tvirtualFloor2=1-virtualFloor2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok[virtualFloor2][q.y][q.x]){\n\t\t\t\t\tnext.add(q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(P q : next){\n\t\t\t\tif(d[p.y][p.x][p.floor][p.sw]+1<d[q.y][q.x][q.floor][q.sw]){\n\t\t\t\t\td[q.y][q.x][q.floor][q.sw]=d[p.y][p.x][p.floor][p.sw]+1;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min=INF;\n\t\tfor(int sw=0; sw<1<<s; sw++){\n\t\t\tint virtualFloor=0;\n\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\tif((sw>>i&1)==1&&maps[i][yg][xg]=='*'){\n\t\t\t\t\tvirtualFloor=1-virtualFloor;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// min=min(min, d[yg][xg][0][sw]);\n\t\t\tif(virtualFloor==0){\n\t\t\t\tmin=min(min, d[yg][xg][0][sw]);\n\t\t\t}else{\n\t\t\t\tmin=min(min, d[yg][xg][1][sw]);\n\t\t\t}\n\t\t}\n\t\tprintln((min<INF?min:-1)+\"\");\n\t}\n\n\tclass P{\n\t\tint x, y, floor, sw;\n\n\t\tP(int x, int y, int floor, int sw){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.floor=floor;\n\t\t\tthis.sw=sw;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// A Two Floors Dungeon\n// 2012/09/22\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint w, h;\n\tint s;\n\tchar[][] map;\n\tchar[][][] maps;\n\n\tstatic final char WALL='#', STAIRS='|', FIRST='_', SECOND='^', START='%',\n\t\t\tGOAL='&';\n\n\tvoid run(){\n\t\tw=sc.nextInt();\n\t\th=sc.nextInt();\n\t\tmap=new char[h][];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tmap[i]=sc.next().toCharArray();\n\t\t}\n\t\ts=sc.nextInt();\n\t\tmaps=new char[s][h][];\n\t\tfor(int j=0; j<s; j++){\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tmaps[j][i]=sc.next().toCharArray();\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint xs=-1, ys=-1;\n\t\tint xg=-1, yg=-1;\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tif(map[j][i]==START){\n\t\t\t\t\txs=i;\n\t\t\t\t\tys=j;\n\t\t\t\t}else if(map[j][i]==GOAL){\n\t\t\t\t\txg=i;\n\t\t\t\t\tyg=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\n\t\tboolean[][][] ok=new boolean[2][h][w];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tchar c=map[j][i];\n\t\t\t\tok[0][j][i]=c==STAIRS||c==FIRST||Character.isLowerCase(c)\n\t\t\t\t\t\t||c==START||c==GOAL;\n\t\t\t\tok[1][j][i]=c==STAIRS||c==SECOND||Character.isUpperCase(c);\n\t\t\t}\n\t\t}\n\n\t\tint[][][][] d=new int[h][w][2][1<<s];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\tfill(d[j][i][0], INF);\n\t\t\t\tfill(d[j][i][1], INF);\n\t\t\t}\n\t\t}\n\t\td[ys][xs][0][0]=0;\n\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xs, ys, 0, 0));\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tint virtualFloor=p.floor;\n\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\tif((p.sw>>i&1)==1&&maps[i][p.y][p.x]=='*'){\n\t\t\t\t\tvirtualFloor=1-virtualFloor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<P> next=new LinkedList<P>();\n\t\t\tif(map[p.y][p.x]==STAIRS){\n\t\t\t\tnext.add(new P(p.x, p.y, 1-p.floor, p.sw));\n\t\t\t}\n\t\t\tif(Character.isLetter(map[p.y][p.x])){\n\t\t\t\tint sw=Character.toLowerCase(map[p.y][p.x])-'a';\n\t\t\t\tif(maps[sw][p.y][p.x]=='*'){\n\t\t\t\t\tnext.add(new P(p.x, p.y, 1-p.floor, p.sw^(1<<sw)));\n\t\t\t\t}else{\n\t\t\t\t\tnext.add(new P(p.x, p.y, p.floor, p.sw^(1<<sw)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\tP q=new P(p.x+dx[k], p.y+dy[k], p.floor, p.sw);\n\t\t\t\tint virtualFloor2=q.floor;\n\t\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\t\tif((q.sw>>i&1)==1&&maps[i][q.y][q.x]=='*'){\n\t\t\t\t\t\tvirtualFloor2=1-virtualFloor2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok[virtualFloor2][q.y][q.x]){\n\t\t\t\t\tnext.add(q);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(P q : next){\n\t\t\t\tif(d[p.y][p.x][p.floor][p.sw]+1<d[q.y][q.x][q.floor][q.sw]){\n\t\t\t\t\td[q.y][q.x][q.floor][q.sw]=d[p.y][p.x][p.floor][p.sw]+1;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min=INF;\n\t\tfor(int sw=0; sw<1<<s; sw++){\n\t\t\tint virtualFloor=0;\n\t\t\tfor(int i=0; i<s; i++){\n\t\t\t\tif((sw>>i&1)==1&&maps[i][yg][xg]=='*'){\n\t\t\t\t\tvirtualFloor=1-virtualFloor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(virtualFloor==0){\n\t\t\t\tmin=min(min, d[yg][xg][0][sw]);\n\t\t\t}else{\n\t\t\t\tmin=min(min, d[yg][xg][1][sw]);\n\t\t\t}\n\t\t}\n\t\tprintln((min<INF?min:-1)+\"\");\n\t}\n\n\tclass P{\n\t\tint x, y, floor, sw;\n\n\t\tP(int x, int y, int floor, int sw){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.floor=floor;\n\t\t\tthis.sw=sw;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def encode(floors, x, y, z)\n    (floors[0] << 2513) + (floors[1] << 13) + (x << 7) + (y << 1) + z\nend\n\ndef decode(state)\n    [[(state >> 2513), (state >> 13) & ((1 << 2500) - 1)], (state >> 7) & 0b111111, (state >> 1) & 0b111111, state & 0b1 ]\nend\n\nw, h = gets.split.map(&:to_i)\n\nfloor0 = floor1 = 0\n\nswitch = {}\ngx = gy = nil\nsx = sy = nil\n\n(0..h-1).each do |i|\n    gets.chomp.each_char.with_index do |c, j|\n        case c\n        when ?#\n        when ?_\n            floor0 |= 1 << i * w + j\n        when ?^\n            floor1 |= 1 << i * w + j\n        when /[a-z]/\n            floor0 |= 1 << i * w + j\n            switch[[j, i]] = c\n        when /[A-Z]/\n            floor1 |= 1 << i * w + j\n            switch[[j, i]] = c.downcase\n        when ?|\n            floor0 |= 1 << i * w + j\n            floor1 |= 1 << i * w + j\n        when ?&\n            floor0 |= 1 << i * w + j\n            gx = j\n            gy = i\n        when ?%\n            floor0 |= 1 << i * w + j\n            sx = j\n            sy = i\n        end\n    end\nend\n\nmove = {}\ngets.to_i.times do |k|\n    s = (?a.ord + k).chr\n    m = 0\n    (0..h-1).each do |i|\n        gets.chomp.each_char.with_index do |c, j|\n            if c == ?*\n                m |= 1 << i * w + j\n            end\n        end\n    end\n    move[s] = m\nend\n\ninit_state = encode([floor0, floor1], sx, sy, 0)\ndist = {init_state => 0}\nqueue = [init_state]\n\ncatch(:break) do\n    until queue.empty?\n        state = queue.shift\n        floors, x, y, z = decode(state)\n        next_states = []\n        if floors[z ^ 1][y * w + x] == 1\n            next_states << encode(floors, x, y, z ^ 1)\n        end\n        [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dx, dy|\n            u, v = x + dx, y + dy\n            next if u < 0 || u >= w || v < 0 || v >= h\n            next if floors[z][v * w + u] != 1\n            next_states << encode(floors, u, v, z)\n        end\n        if c = switch[[x, y]]\n            z1 = z\n            z1 ^= 1 if move[c][y * w + x] == 1\n            next_states << encode([floors[0] ^ move[c], floors[1] ^ move[c]], x, y, z1)\n        end\n        next_states.each do |s|\n            next if dist[s]\n            dist[s] = dist[state] + 1\n            floors, x, y, z = decode(s)\n            if x == gx && y == gy\n                puts dist[s]\n                throw(:break)\n            end\n            queue << s\n        end\n    end\n    puts -1\nend"
  },
  {
    "language": "Ruby",
    "code": "def encode(switch_state, x, y, z)\n    (switch_state << 13) + (x << 7) + (y << 1) + z\nend\n\ndef decode(state)\n    [state >> 13, (state >> 7) & 0b111111, (state >> 1) & 0b111111, state & 0b1]\nend\n\nw, h = gets.split.map(&:to_i)\n\ninit_floor = wall = stair = 0\n\nswitch = {}\ngx = gy = nil\nsx = sy = nil\n\n(0..h-1).each do |i|\n    gets.chomp.each_char.with_index do |c, j|\n        bit = 1 << i * w + j\n        case c\n        when ?#\n            wall   |= bit\n        when ?_\n        when ?^\n            init_floor |= bit\n        when /[a-z]/\n            switch[[j, i]] = c.ord - ?a.ord\n        when /[A-Z]/\n            init_floor |= bit\n            switch[[j, i]] = c.ord - ?A.ord\n        when ?|\n            stair |= bit\n        when ?&\n            gx = j\n            gy = i\n        when ?%\n            sx = j\n            sy = i\n        end\n    end\nend\n\nmover = Hash.new(0)\ngets.to_i.times do |k|\n    s = (?a.ord + k).chr\n    m = 0\n    (0..h-1).each do |i|\n        gets.chomp.each_char.with_index do |c, j|\n            if c == ?*\n                mover[[j, i]] |= (1 << k)\n            end\n        end\n    end\nend\n\ninit_state = encode(0, sx, sy, 0)\ndist = {init_state => 0}\nqueue = [init_state]\n\ndef one_num_parity(x)\n    k = 0\n    until x == 0\n        x &= (x - 1)\n        k ^= 1\n    end\n    k\nend\n\ncatch(:break) do\n    until queue.empty?\n        state = queue.shift\n        switch_state, x, y, z = decode(state)\n        next_states = []\n\n        if stair[y * w + x] == 1\n            next_states << encode(switch_state, x, y, z ^ 1)\n        end\n\n        if i = switch[[x, y]]\n            z1 = z\n            z1 ^= 1 if mover[[x, y]][i] == 1\n            next_states << encode(switch_state ^ (1 << i), x, y, z ^ mover[[x, y]][i])\n        end\n\n        [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dx, dy|\n            u, v = x + dx, y + dy\n            next if u < 0 || u >= w || v < 0 || v >= h\n            next if wall[v * w + u] == 1\n            if stair[v * w + u] == 1\n                next_states << encode(switch_state, u, v, z)\n            elsif init_floor[v * w + u] ^ one_num_parity(mover[[u, v]] & switch_state) == z\n                next_states << encode(switch_state, u, v, z)\n            end\n        end\n\n        next_states.each do |s|\n            next if dist[s]\n            dist[s] = dist[state] + 1\n            _, x, y, _ = decode(s)\n            if x == gx && y == gy\n                puts dist[s]\n                throw(:break)\n            end\n            queue << s\n        end\n    end\n    puts -1\nend"
  },
  {
    "language": "Ruby",
    "code": "def encode(switch_state, x, y, z)\n    (switch_state << 13) + (x << 7) + (y << 1) + z\nend\n\ndef decode(state)\n    [state >> 13, (state >> 7) & 0b111111, (state >> 1) & 0b111111, state & 0b1]\nend\n\nw, h = gets.split.map(&:to_i)\n\ninit_floor = wall = stair = 0\n\nswitch = {}\ngx = gy = nil\nsx = sy = nil\n\n(0..h-1).each do |i|\n    gets.chomp.each_char.with_index do |c, j|\n        bit = 1 << i * w + j\n        case c\n        when ?#\n            wall   |= bit\n        when ?_\n        when ?^\n            init_floor |= bit\n        when /[a-z]/\n            switch[[j, i]] = c.ord - ?a.ord\n        when /[A-Z]/\n            init_floor |= bit\n            switch[[j, i]] = c.ord - ?A.ord\n        when ?|\n            stair |= bit\n        when ?&\n            gx = j\n            gy = i\n        when ?%\n            sx = j\n            sy = i\n        end\n    end\nend\n\nmover = (0..h-1).map { [0] * w }\ngets.to_i.times do |k|\n    s = (?a.ord + k).chr\n    m = 0\n    (0..h-1).each do |i|\n        gets.chomp.each_char.with_index do |c, j|\n            if c == ?*\n                mover[i][j] |= (1 << k)\n            end\n        end\n    end\nend\n\ninit_state = encode(0, sx, sy, 0)\ndist = {init_state => 0}\nqueue = [init_state]\n\ndef one_num_parity(x)\n    k = 0\n    until x == 0\n        x &= (x - 1)\n        k ^= 1\n    end\n    k\nend\n\ndirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\ncatch(:break) do\n    until queue.empty?\n        state = queue.shift\n        switch_state, x, y, z = decode(state)\n        next_states = []\n\n        if stair[y * w + x] == 1\n            next_states << encode(switch_state, x, y, z ^ 1)\n        end\n\n        if i = switch[[x, y]]\n            next_states << encode(switch_state ^ (1 << i), x, y, z ^ mover[y][x][i])\n        end\n\n        dirs.each do |dx, dy|\n            u, v = x + dx, y + dy\n            pos = v * w + u\n            next if wall[pos] == 1\n            if stair[pos] == 1\n                next_states << encode(switch_state, u, v, z)\n            elsif init_floor[pos] ^ one_num_parity(mover[v][u] & switch_state) == z\n                next_states << encode(switch_state, u, v, z)\n            end\n        end\n\n        next_states.each do |s|\n            next if dist[s]\n            dist[s] = dist[state] + 1\n            _, x, y, _ = decode(s)\n            if x == gx && y == gy\n                puts dist[s]\n                throw(:break)\n            end\n            queue << s\n        end\n    end\n    puts -1\nend"
  },
  {
    "language": "Ruby",
    "code": "def encode(floors, x, y, z)\n    (floors[0] << 2513) + (floors[1] << 13) + (x << 7) + (y << 1) + z\nend\n\ndef decode(state)\n    [[(state >> 2513), (state >> 13) & ((1 << 2500) - 1)], (state >> 7) & 0b111111, (state >> 1) & 0b111111, state & 0b1 ]\nend\n\nw, h = gets.split.map(&:to_i)\n\nfloor0 = floor1 = 0\n\nswitch = {}\ngx = gy = nil\nsx = sy = nil\n\n(0..h-1).each do |i|\n    gets.chomp.each_char.with_index do |c, j|\n        case c\n        when ?#\n        when ?_\n            floor0 |= 1 << i * w + j\n        when ?^\n            floor1 |= 1 << i * w + j\n        when /[a-z]/\n            floor0 |= 1 << i * w + j\n            switch[[j, i]] = c\n        when /[A-Z]/\n            floor1 |= 1 << i * w + j\n            switch[[j, i]] = c.downcase\n        when ?|\n            floor0 |= 1 << i * w + j\n            floor1 |= 1 << i * w + j\n        when ?&\n            floor0 |= 1 << i * w + j\n            gx = j\n            gy = i\n        when ?%\n            floor0 |= 1 << i * w + j\n            sx = j\n            sy = i\n        end\n    end\nend\n\nmove = {}\ngets.to_i.times do |k|\n    s = (?a.ord + k).chr\n    m = 0\n    (0..h-1).each do |i|\n        gets.chomp.each_char.with_index do |c, j|\n            if c == ?*\n                m |= 1 << i * w + j\n            end\n        end\n    end\n    move[s] = m\nend\n\ninit_state = encode([floor0, floor1], sx, sy, 0)\ndist = {init_state => 0}\nqueue = [init_state]\n\ncatch(:break) do\n    until queue.empty?\n        state = queue.shift\n        floors, x, y, z = decode(state)\n        next_states = []\n        if floors[z ^ 1][y * w + x] == 1\n            next_states << encode(floors, x, y, z ^ 1)\n        end\n        [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dx, dy|\n            u, v = x + dx, y + dy\n            next if u < 0 || u >= w || v < 0 || v >= h\n            next if floors[z][v * w + u] != 1\n            next_states << encode(floors, u, v, z)\n        end\n        if c = switch[[x, y]]\n            z1 = z\n            z1 ^= 1 if move[c][y * w + x] == 1\n            next_states << encode([floors[0] ^ move[c], floors[1] ^ move[c]], x, y, z1)\n        end\n        next_states.each do |s|\n            next if dist[s]\n            dist[s] = dist[state] + 1\n            floors, x, y, z = decode(s)\n            if x == gx && y == gy && z == 0\n                puts dist[s]\n                throw(:break)\n            end\n            queue << s\n        end\n    end\n    puts -1\nend"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\ndef main():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    W, H = map(int, readline().split())\n    MP = [readline() for i in range(H)]\n    A = [[-1]*W for i in range(H)]\n    B = [[-1]*W for i in range(H)]\n    C = [[0]*W for i in range(H)]\n    SW0 = 'ABCDEFGHIJ'\n    SW1 = 'abcdefghij'\n    for i, mp in enumerate(MP):\n        Ai = A[i]; Bi = B[i]\n        for j, c in enumerate(mp):\n            if c == '#':\n                continue\n            if c in '^' or c in SW0:\n                Ai[j] = 1\n                if c != '^':\n                    Bi[j] = SW0.index(c)+1\n            elif c in '_%&' or c in SW1:\n                Ai[j] = 0\n                if c == '%':\n                    sx = j; sy = i\n                elif c == '&':\n                    gx = j; gy = i\n                elif c != '_':\n                    Bi[j] = SW1.index(c)+1\n            elif c == '|':\n                Bi[j] = 0\n                Ai[j] = 2\n    S = int(readline())\n    for k in range(S):\n        MP = [readline() for i in range(H)]\n        for i, mp in enumerate(MP):\n            Ci = C[i]\n            for j, c in enumerate(mp):\n                if c == '*':\n                    Ci[j] |= (2 << k)\n\n    dist = [[{} for i in range(W)] for j in range(H)]\n    dist[sy][sx][0] = 0\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    bc = [0]*(2 << S)\n    for i in range(1, 2 << S):\n        bc[i] = bc[i ^ (i & -i)] ^ 1\n    que = deque([(0, sx, sy, 0)])\n    while que:\n        state, x, y, d = que.popleft()\n        if B[y][x] == 0:\n            if state^1 not in dist[y][x]:\n                dist[y][x][state^1] = d+1\n                que.append((state^1, x, y, d+1))\n        elif B[y][x] != -1:\n            n_state = state ^ (1 << B[y][x]) ^ (state & 1)\n            n_state ^= bc[n_state & C[y][x]] ^ A[y][x]\n            if n_state not in dist[y][x]:\n                dist[y][x][n_state] = d+1\n                que.append((n_state, x, y, d+1))\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < W or not 0 <= ny < H or A[ny][nx] == -1:\n                continue\n            if A[ny][nx] == 2:\n                if state not in dist[ny][nx]:\n                    dist[ny][nx][state] = d+1\n                    que.append((state, nx, ny, d+1))\n            else:\n                np = bc[state & C[ny][nx]] ^ A[ny][nx]\n                if state&1 == np and state not in dist[ny][nx]:\n                    dist[ny][nx][state] = d+1\n                    que.append((state, nx, ny, d+1))\n    if dist[gy][gx]:\n        write(\"%d\\n\" % min(dist[gy][gx].values()))\n    else:\n        write(\"-1\\n\")\nmain()\n"
  }
]