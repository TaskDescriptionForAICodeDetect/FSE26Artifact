[
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,E,T,W[333],G[1010],C[1010],S[1010][11];\nint d[333],rest[333];\nvi to[333];\nint used[333];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>E>>T,T--;\n\trep(i,N)cin>>W[i];\n\trep(i,E){\n\t\tcin>>G[i]>>C[i],G[i]--;\n\t\trep(j,C[i]){\n\t\t\tcin>>S[i][j],S[i][j]--;\n\t\t\tto[S[i][j]].pb(i);\n\t\t}\n\t}\n\n\trep(i,N){\n\t\tif(W[i] == 1) d[i] = 1;\n\t\telse d[i] = INF;\n\t}\n\trep(i,E){\n\t\trest[i] = C[i];\n\t}\n\trep(_,N){\n\t\tint cur = -1, best = INF;\n\t\trep(i,N)if(!used[i] && d[i] < best){\n\t\t\tcur = i;\n\t\t\tbest = d[i];\n\t\t}\n\t\tif(cur == T){\n\t\t\treturn cout<<d[cur]<<endl,0;\n\t\t}\n\t\tif(cur == -1){\n\t\t\treturn cout<<-1<<endl,0;\n\t\t}\n\t\t//cout<<cur<<\" \"<<best<<endl;\n\n\t\tused[cur] = 1;\n\t\trep(i,sz(to[cur])){\n\t\t\tint T = to[cur][i];\n\t\t\trest[T]--;\n\t\t\tif(rest[T] == 0){\n\t\t\t\tvi cost;\n\t\t\t\trep(j,C[T]){\n\t\t\t\t\tcost.pb(d[S[T][j]]);\n\t\t\t\t}\n\t\t\t\tsort(cost.begin(),cost.end(),greater<int>());\n\t\t\t\tint c = 0;\n\t\t\t\trep(j,sz(cost)){\n\t\t\t\t\tc = max(c, (int)cost[j] + j);\n\t\t\t\t}\n\t\t\t\td[G[T]] = min(d[G[T]],c);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct howto {\n\tint wit;\n\tvector<int>needs;\n\thowto(const int g) :wit(g), needs() {}\n};\nstruct aa {\n\tint wit;\n\tint need;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.need> r.need;\n\t}\n};\nint main() {\n\tint N, E, T; cin >> N >> E >> T; T--;\n\tvector<int>costs(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint w; cin >> w;\n\t\tif (w)costs[i] = 1;\n\t\telse costs[i] = 1e8;\n\t}\n\tvector<howto>hows;\n\tvector<bool>howuses(E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint g, c; cin >> g >> c;\n\t\tg--;\n\t\thows.push_back(howto(g));\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint s; cin >> s; s--;\n\t\t\thows[i].needs.push_back(s);\n\t\t}\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tfor (int h = 0; h<hows.size(); ++h) {\n\t\tvector<int>neednums;\n\t\tfor (auto n : hows[h].needs) {\n\t\t\tneednums.push_back(costs[n]);\n\t\t}\n\t\tsort(neednums.begin(), neednums.end());\n\t\tint amax = 0;\n\t\tfor (int i = 0; i < neednums.size(); ++i) {\n\t\t\tamax = max(int(neednums[i]+neednums.size() - i - 1), amax);\n\t\t}\n\t\tif (amax < costs[hows[h].wit])que.push(aa{ hows[h].wit,amax });\n\t}\n\tint ans = 1e8;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.need < costs[atop.wit]) {\n\t\t\tcosts[atop.wit] = atop.need;\n\t\t\tfor (int h = 0; h<hows.size(); ++h) {\n\t\t\t\tvector<int>neednums;\n\t\t\t\tfor (auto n : hows[h].needs) {\n\t\t\t\t\tneednums.push_back(costs[n]);\n\t\t\t\t}\n\t\t\t\tsort(neednums.begin(), neednums.end());\n\t\t\t\tint amax = 0;\n\t\t\t\tfor (int i = 0; i < neednums.size(); ++i) {\n\t\t\t\t\tamax = max(int(neednums[i] + neednums.size() - i - 1), amax);\n\t\t\t\t}\n\t\t\t\tif (amax < costs[hows[h].wit])que.push(aa{ hows[h].wit,amax });\n\t\t\t}\n\t\t}\n\t}\n\tif (costs[T]>1e6)costs[T] = -1;\n\tcout << costs[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nvvi G[MAX_N];\nint memo[MAX_N];\n\nint dfs(int nw,vector<bool>& flag){\n    if(flag[nw]) return -1;\n    if(memo[nw]) return memo[nw];\n    flag[nw] = true;\n    int mn = INF;\n    rep(i,len(G[nw])){\n        bool ok = true;\n        vi kekka;\n        int sz = len(G[nw][i]);\n        rep(j,sz){\n            int res = dfs(G[nw][i][j],flag);\n            if(res < 0){\n                ok = false;\n                break;\n            }\n            kekka.pb(res);\n        }\n        if(ok){\n            int val = sz;\n            sort(all(kekka));\n            rep(j,len(kekka)){\n                cmx(val,kekka[j]+sz-1-j);\n            }\n            cmn(mn,val);\n        }\n    }\n    if(mn == INF){\n        memo[nw] = 0;\n    }else{\n        memo[nw] = mn;\n    }\n    flag[nw] = false;\n    return memo[nw];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    rep(i,n){\n        cin >> memo[i];\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        G[a-1].pb(hoge);\n    }\n    vector<bool> flag(n,false);\n    cout << dfs(t,flag) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_N = 300;\nconstexpr int INF = (1 << 29);\n\nint N, E, T;\nbool w[MAX_N];\n\nvector<vector<int>> G[MAX_N];\n\nint memo[MAX_N];\n\nint dfs(int v) {\n\tint &res = memo[v];\n\tif(res != -1) return res;\n\n\tif(w[v]) {\n\t\tres = 1;\n\t}\n\telse {\n\t\tres = INF;\n\n\t\tfor(const auto &nodes : G[v]) {\n\t\t\tvector<int> need;\n\t\t\tneed.reserve(nodes.size());\n\n\t\t\tfor(const auto &c : nodes) {\n\t\t\t\tneed.emplace_back(dfs(c));\n\t\t\t}\n\n\t\t\tsort(need.rbegin(), need.rend());\n\n\t\t\tint tmp = 0;\n\t\t\tfor(int i = 0; i < static_cast<int>(nodes.size()); ++i) {\n\t\t\t\tchmax(tmp, need[i] + i);\n\t\t\t}\n\n\t\t\tchmin(res, tmp);\n\t\t}\n\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\n\tfor(int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\n\tfor(int i = 0; i < E; ++i) {\n\t\tint g, c;\n\t\tcin >> g >> c;\n\n\t\tvector<int> material(c);\n\t\tfor(auto &e : material) {\n\t\t\tcin >> e;\n\t\t\t--e;\n\t\t}\n\n\t\tG[g - 1].emplace_back(move(material));\n\t}\n\n\tmemset(memo, -1, sizeof(memo));\n\tconst int ans = dfs(T - 1);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, T;\nint dp[310];\nvector<int> akuma[310]; // ©ª©gªfromÆÈÁÄ¢éedgeÌindexÌW\nint edgeCount[1100];\nint edgeTo[1100];\nvector<int> edgeFrom[1100];\n\nvoid Push(priority_queue<pair<int, int> > &que, int index) {\n  int e = edgeFrom[index].size();\n  vector<int> costs(e);\n  REP(i, e) {\n    costs[i] = dp[edgeFrom[index][i]];\n  }\n  sort(costs.rbegin(), costs.rend());\n  int ans = 0;\n  REP(i, e) {\n    ans = max(ans, costs[i] + i);\n  }\n  que.push(make_pair(-ans, edgeTo[index]));\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &T) > 0) {\n    // initialize\n    T--;\n    MEMSET(dp, -1);\n    REP(i, 310) { akuma[i].clear(); }\n    REP(i, 1100) { edgeFrom[i].clear(); }\n    MEMSET(edgeCount, 0);\n    MEMSET(edgeTo, -1);\n    priority_queue<pair<int, int> > que;\n\n    // input\n    REP(i, n) {\n      int leaf;\n      int v = scanf(\"%d\", &leaf);\n      assert(v == 1);\n      if (leaf == 1) {\n        que.push(make_pair(-1, i));\n      }\n    }\n    REP(i, m) {\n      int k, to;\n      int v = scanf(\"%d %d\", &to, &k);\n      assert(v == 2);\n      to--;\n      edgeTo[i] = to;\n      edgeCount[i] = k;\n      REP(j, k) {\n        int from;\n        int v = scanf(\"%d\", &from);\n        assert(v == 1);\n        from--;\n        edgeFrom[i].push_back(from);\n        akuma[from].push_back(i);\n      }\n    }\n\n    // process\n    while (!que.empty()) {\n      int node = que.top().second;\n      int cost = -que.top().first;\n      que.pop();\n      if (dp[node] != -1) { continue; }\n      dp[node] = cost;\n      FORIT(it, akuma[node]) {\n        edgeCount[*it]--;\n        assert(edgeCount[*it] >= 0);\n        if (edgeCount[*it] == 0) {\n          Push(que, *it);\n        }\n      }\n    }\n    //REP(i, n) {\n    //  cout << dp[i] << \" \";\n    //}\n    //cout << endl;\n    printf(\"%d\\n\", dp[T]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dp[310];\n\nbool easy[310];\nvector<vi> recipe[310];\n\n\nint main(void){\n\tint n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,n) cin >> easy[i];\n\trep(i,e){\n\t\tvi in;\n\t\tint g,c;\n\t\tcin >> g >> c;\n\t\trep(j,c){\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tin.pb(s-1);\n\t\t}\n\t\trecipe[g-1].pb(in);\n\t}\n\trep(i,n) dp[i]=-1;\n\trep(loop,n)rep(v,n){\n\t\tif(easy[v]){\n\t\t\tdp[v]=1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint res=-1;\n\t\tfor(auto &r:recipe[v]){\n\t\t\tbool ok=true;\n\t\t\tvi cost;\n\t\t\tfor(auto &i:r){\n\t\t\t\tif(dp[i]==-1) ok=false;\n\t\t\t\tcost.pb(dp[i]);\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tint cur=0,m=cost.size();\n\t\t\tsort(cost.begin(),cost.end());\n\t\t\trep(i,m) cur=max(cur,cost[i]+(m-1-i));\n\t\t\tif(res==-1||res>cur) res=cur;\n\t\t}\n\t\tif(dp[v]==-1||dp[v]>res) dp[v]=res;\n\t}\n\tcout << dp[t-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t, g[300], dp[300];\nbool ok[300];\nvi s[1000];\n\nint main(){\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint k, a;\n\t\tcin >> g[i] >> k; g[i]--;\n\t\trep(j, k) cin >> a, s[i].pb(a - 1);\n\t}\n\trep(i, n) dp[i] = ok[i] ? 1 : inf;\n\trep(it, n) rep(i, e){\n\t\tint dp2[300], &res = dp[g[i]];\n\t\trep(j, s[i].size()) dp2[j] = dp[s[i][j]];\n\t\tsort(dp2, dp2 + s[i].size(), greater<int>());\n\t\tres = 0;\n\t\trep(j, s[i].size()) res = max(res, j + dp2[j]);\n\t}\n\tcout << (dp[t - 1] == inf ? -1 : dp[t - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, t; cin >> n >> e >> t; t--;\n    vll ret(n, INF);\n    rep(i, n) {\n        ll tmp; cin >> tmp;\n        if (tmp)\n            ret[i] = 1;\n    }\n\n    vvll lows(e);\n    vll lows_target(e);\n    vvll observer(n);\n    rep(i, e) {\n        ll target; cin >> target; target--;\n        ll material_num; cin >> material_num;\n        vll tmp(material_num);\n        rep(j, material_num) {\n            cin >> tmp[j];\n            tmp[j]--;\n            observer[tmp[j]].pb(i);\n        }\n        lows[i] = tmp;\n        lows_target[i] = target;\n    }\n\n    /*\n    cout << \"# lows\" << endl;\n    cout << lows << endl;\n    cout << \"# lows target\" << endl;\n    cout << lows_target << endl;\n    cout << \"# observer\" << endl;\n    cout << observer << endl;\n    cout << \"# ret\" << endl;\n    cout << ret << endl;\n    */\n\n    queue<ll> notification; \n    rep(i, n) {\n        if (ret[i] == 1) {\n            notification.push(i);\n        }\n    }\n\n    while (!notification.empty()) {\n        ll updated = notification.front(); notification.pop();\n        for (auto low_index : observer[updated]) {\n            vll& low = lows[low_index];\n            vll materials;\n            vll materials_cost;\n            ll m = 0;\n            for (auto material : low) {\n                if (ret[material] == INF) {\n                    goto skip;\n                }\n                materials.pb(material);\n                materials_cost.pb(ret[material]);\n            }\n            sort(all(materials_cost), greater<ll>());\n            rep(i, materials_cost.size()) {\n                chmax(m, i + materials_cost[i]);\n            }\n            /*\n            cout << lows_target[low_index] << \" : \" << m << endl;\n            rep(i, materials.size()) {\n                cout << i + ret[materials[i]] << \" \";\n            } cout << endl;\n            */\n\n            if (ret[lows_target[low_index]] > m) {\n                ret[lows_target[low_index]] = m;\n                notification.push(lows_target[low_index]);\n            }\n            skip:;\n        }\n    }\n\n    if (ret[t] != INF) {\n        cout << ret[t] << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nstruct edge\n{\n    int st;\n    vi vec;\n    edge(){};\n    edge(int a,vi b){\n        st = a,vec = b;\n    }\n};\n\nvector<edge> eda;\nint memo[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    fill(memo,memo+n,INF);\n    rep(i,n){\n        int a;\n        cin >> a;\n        if(a){\n            memo[i] = 1;\n        }\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        eda.emplace_back(a,hoge);\n    }\n    while(1){\n        bool update = false;\n        rep(i,e){\n            edge& e = eda[i];\n            vi hoge;\n            bool ok = true;\n            each(it,e.vec){\n                if(memo[it] == INF){\n                    ok = false;\n                }\n                hoge.pb(memo[it]);\n            }\n            if(ok){\n                int val = len(e.vec);\n                sort(all(hoge));\n                rep(j,len(hoge)){\n                    cmx(val,hoge[j]+len(e.vec)-1-j);\n                }\n                if(val < memo[e.st]){\n                    memo[e.st] = val;\n                    update = true;\n                }\n            }\n        }\n        if(!update) break;\n    }\n    if(memo[t] == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << memo[t] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint w[10800];\nbool come[10800];\nbool loop[108000];\nvector< vector<int> > material[10800];\nint g, c, x ;\nint memo[108000];\nvoid dfs(int x, int start = -1){\n\tif(start == x){\n\t\tloop[x] = true;\n\t\treturn;\n\t}\n\telse if(start == -1){\n\t\tstart = x;\n\t}\n\tif(come[x])return;\n\tcome[x] = true;\n\tif(w[x])return;\n\tfor(int i = 0;i < material[x].size();i++){\n\t\tfor(int j = 0;j < material[x][i].size();j++){\n\t\t\tint to = material[x][i][j];\n\t\t\tdfs(to, x);\n\t\t}\n\t}\n}\n\nint solve(int x){\n\tint &res = memo[x];\n\tif(res != 0)return res;\n\tif(w[x])return res = 1;\n\tif(loop[x])return res = -1;\n\tres = 1 << 30;\n\tfor(int i = 0;i < material[x].size();i++){\n\t\tint tmp = material[x][i].size();\n\t\tvector<int> cnts;\n\t\tfor(int j = 0;j < material[x][i].size();j++){\n\t\t\tint to = material[x][i][j];\n\t\t\tint t = solve(to);\n\t\t\tif(t == -1){\n\t\t\t\ttmp = 1 << 30;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnts.push_back(t);\n\t\t}\n\t\tsort(cnts.begin(), cnts.end(), greater<int>() );\n\t\tfor(int j = 0;j < cnts.size();j++){\n\t\t\ttmp = max(tmp, cnts[j] + j);\n\t\t}\n\t\tres = min(res, tmp);\n\t}\n\tif(res == 1 << 30)return res = -1;\n\telse return res;\n\t\n}\n\nint main(){\n\tint n, e, t;\n\tcin >> n >> e >> t;t--;\n\tfor(int i = 0;i < n;i++)cin >> w[i];\n\tfor(int i = 0;i < e;i++){\n\t\tcin >> g >> c;g--;\n\t\tvector<int> tmp;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> x;x--;\n\t\t\ttmp.push_back(x);\n\t\t}\n\t\tmaterial[g].push_back(tmp);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(w[i])continue;\n\t\tfill(come, come + n, false);\n\t\tdfs(i);\n\t}\n\tcout << solve(t) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, E, T;\nvector<int> W;\nvector<int> G;\nvector<int> S[1000];\nint memo[300];\nint dfs(int K, vector<bool> used){\n  if(memo[K] != -1) return memo[K];\n  if(W[K]) return 1;\n  int res = INF;\n  used[K] = true;\n  REP(i, E) if(G[i] == K){\n    vector<int> need;\n    REP(j, S[i].size()) {\n      if(used[S[i][j]]) need.push_back(INF);\n      else need.push_back(dfs(S[i][j], used));\n    }\n    sort(need.begin(), need.end());\n    reverse(need.begin(), need.end());\n    int ans = 0;\n    REP(i, need.size()) ans = max(ans, need[i] + i);\n    res = min(res, ans);\n  }\n  return memo[K] = res;\n}\nint main(){\n  while(cin >> N >> E >> T){\n    T--;\n    W.assign(N, 0);\n    REP(i, N) cin >> W[i];\n    G.assign(E, 0);\n    REP(i, E){\n      cin >> G[i]; G[i]--;\n      int C; cin >> C;\n      S[i].assign(C, 0);\n      REP(j, C) cin >> S[i][j];\n      REP(j, C) S[i][j] --;\n    }\n    vector<bool> used(N, false);\n    memset(memo, -1, sizeof memo);\n    int ans = dfs(T, used);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Law {\n\tint G;\n\tvector<int> S;\n};\n\nvoid update(int pos, int need, vector<int>& dp) {\n\tif (need >= dp[pos]) return;\n\tdp[pos] = min(dp[pos], need);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N); cin >> W;\n\tvector<Law> law;\n\tREP(i, E) {\n\t\tint G, C; cin >> G >> C; --G;\n\t\tvector<int> S(C); cin >> S;\n\t\tREP(i, C) S[i]--;\n\t\tlaw.pb( (Law){G, S} );\n\t}\n\tvector<int> dp(N, inf);\n\tREP(i, N) {\n\t\tif (W[i] == 1) {\n\t\t\tupdate(i, 1, dp);\n\t\t}\n\t}\n\tREP(t, E) REP(i, N) REP(j, E) {\n\t\tint M = 0, m = inf;\n\t\tREP(k, law[j].S.size()) {\n\t\t\tint id = law[j].S[k];\n\t\t\tM = max(M, dp[id]);\n\t\t\tm = min(m, dp[id]);\n\t\t}\n\t\tdp[law[j].G] = min(dp[law[j].G], max(M, (int)law[j].S.size()-1+m));\n\t}\n\tif (dp[T] == inf) cout << -1 << endl;\n\telse cout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n\nint N, E, T, W[500], G[2000], C[2000], S[2000][16], dp[500];\n\nint main() {\n    scanf(\"%d%d%d\", &N, &E, &T);\n    T--;\n    rep(i, N) scanf(\"%d\", W+i);\n    rep(i, E) {\n        scanf(\"%d%d\", G+i, C+i);\n        G[i]--;\n        rep(j, C[i]) scanf(\"%d\", S[i]+j);\n        rep(j, C[i]) S[i][j]--;\n    }\n    memset(dp, -1, sizeof(dp));\n    priority_queue<pair<int, int> > q;\n    rep(i, N) if(W[i]) q.push(mp(-1, i));\n    while(!q.empty() && dp[T]==-1) {\n        pair<int, int> vx(q.top());\n        q.pop();\n        const int ix = vx.second;\n        if(dp[ix]!=-1) continue;\n        dp[ix] = -vx.first;\n        rep(i, E) if(dp[G[i]]==-1) {\n            bool can = true;\n            rep(j, C[i]) if(dp[S[i][j]]==-1) can = false;\n            if(can) {\n                vector<int> v;\n                rep(j, C[i]) v.push_back(dp[S[i][j]]);\n                sort(v.begin(), v.end(), greater<int>());\n                int mx = 0;\n                rep(j, v.size()) mx = max(mx, v[j]+j);\n                q.push(mp(-mx, G[i]));\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[T]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, t; cin >> n >> e >> t; t--;\n    vll ret(n, INF);\n    rep(i, n) {\n        ll tmp; cin >> tmp;\n        if (tmp)\n            ret[i] = 1;\n    }\n\n    vvll lows(e);\n    vll lows_target(e);\n    vvll observer(n);\n    rep(i, e) {\n        ll target; cin >> target; target--;\n        ll material_num; cin >> material_num;\n        vll tmp(material_num);\n        rep(j, material_num) {\n            cin >> tmp[j];\n            tmp[j]--;\n            observer[tmp[j]].pb(i);\n        }\n        lows[i] = tmp;\n        lows_target[i] = target;\n    }\n\n    /*\n    cout << \"# lows\" << endl;\n    cout << lows << endl;\n    cout << \"# lows target\" << endl;\n    cout << lows_target << endl;\n    cout << \"# observer\" << endl;\n    cout << observer << endl;\n    cout << \"# ret\" << endl;\n    cout << ret << endl;\n    */\n\n    queue<ll> notification; \n    rep(i, n) {\n        if (ret[i] == 1) {\n            notification.push(i);\n        }\n    }\n\n    while (!notification.empty()) {\n        ll updated = notification.front(); notification.pop();\n        for (auto low_index : observer[updated]) {\n            vll& low = lows[low_index];\n            vll materials;\n            ll m = 0;\n            for (auto material : low) {\n                if (ret[material] == INF) {\n                    goto skip;\n                }\n                materials.pb(material);\n            }\n            sort(all(materials), greater<ll>());\n            rep(i, materials.size()) {\n                chmax(m, i + ret[materials[i]]);\n            }\n\n//            cout << lows_target[low_index] << \" \" << materials << endl;\n//            cout << m << \"#m\" << endl;\n            if (ret[lows_target[low_index]] > m) {\n                ret[lows_target[low_index]] = m;\n                notification.push(lows_target[low_index]);\n            }\n            skip:;\n        }\n    }\n\n    if (ret[t] != INF) {\n        cout << ret[t] << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<27)\ntypedef pair<int,int> P;\n\nint N,E,T;\nvector<P> G[500];\n\nstruct Node{\n  int c,g;\n  vector<int> S;\n \n  void init(int c,int g){\n    this->c = c; if( c > 0 ) S = vector<int>(c,INF);\n    this->g = g;\n  }\n  bool check(){\n    for(int i=0;i<c;i++)\n      if( S[i] >= INF) return false;\n    return true;\n  }\n  bool update(int id,int x){\n    if( S[id] > x ){\n      S[id] = x; return true;\n    } return false;\n  }\n  int value() const{\n    if( S.empty() ) return 1;\n    vector<int> s = S;\n    sort(s.begin(),s.end());\n    int ret = 0;\n    for(int i=c-1,cnt=0;i>=0;i--,cnt++){\n      ret = max ( cnt + s[i], ret );\n    }\n    return ret;\n  }\n  \n  bool operator<(const Node& b)const{\n    return value() > b.value();\n  }\n\n};\n\nNode H[2000];\n\nint main(){\n\n  priority_queue<Node> q;\n\n  cin >> N >> E >> T;\n  for(int i=0;i<N;i++){\n    int w;\n    cin >> w;\n    if( w == 1 ){\n      Node n;\n      n.init(0,i+1);\n      H[i+E] = n;\n      q.push( n );\n    }\n  }\n  for(int i=0;i<E;i++){\n    int g,c;\n    cin >> g >> c;\n    H[i].init(c,g);\n    for(int j=0;j<c;j++){\n      int s;\n      cin >> s;\n      G[s].push_back( P(i,j) );\n    }\n  }\n\n  while( !q.empty() ){\n    Node st = q.top(); q.pop();\n    int val = st.value();\n    int id = st.g;\n    for(int i=0;i<(int)G[id].size();i++){\n      P to = G[id][i];\n      if( H[to.first].update(to.second,val) ){\n\tif( H[to.first].check() ){\n\t  q.push( H[to.first] );\n\t}\n      }\n    }\n  }\n\n  int res = INF;\n  for(int i=0;i<N+E;i++){\n    //  cout << H[i].g << \" \"<< H[i].value() << endl;\n    if( H[i].g == T ) res = min( res, H[i].value() );\n  }\n  if( res >= INF ) cout << -1 << endl;\n  else cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nstatic const int INF = 10000000;\n\npair<vector<int>, bool>\nbellman_ford(const vector<vector<vector<int> > >& rules, const vector<int>& seed)\n{\n  const int N = seed.size();\n  vector<int> dist(N, INF);\n  for (int i = 0; i < N; i++) {\n    if (seed[i]) {\n      dist[i] = 1;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int u = 0; u < N; u++) {\n      for (vector<vector<int> >::const_iterator it = rules[u].begin(); it != rules[u].end(); ++it) {\n        vector<int> v;\n        for (vector<int>::const_iterator jt = it->begin(); jt != it->end(); ++jt) {\n          v.push_back(dist[*jt]);\n        }\n        sort(v.begin(), v.end(), greater<int>());\n        int d = 0;\n        for (vector<int>::const_iterator jt = v.begin(); jt != v.end(); ++jt) {\n          d = max(d, int(*jt + (jt - v.begin())));\n        }\n        dist[u] = min(dist[u], d);\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int u = 0; u < N; u++) {\n      for (vector<vector<int> >::const_iterator it = rules[u].begin(); it != rules[u].end(); ++it) {\n        vector<int> v;\n        for (vector<int>::const_iterator jt = it->begin(); jt != it->end(); ++jt) {\n          v.push_back(dist[*jt]);\n        }\n        sort(v.begin(), v.end(), greater<int>());\n        int d = 0;\n        for (vector<int>::const_iterator jt = v.begin(); jt != v.end(); ++jt) {\n          d = max(d, int(*jt + (jt - v.begin())));\n        }\n        if (d < dist[u]) {\n          return make_pair(dist, false);\n        }\n      }\n    }\n  }\n  return make_pair(dist, true);\n}\n\nint main()\n{\n  int N, E, T;\n  cin >> N >> E >> T;\n  --T;\n  vector<int> seed(N);\n  for (int i = 0; i < N; i++) {\n    cin >> seed[i];\n  }\n  vector<vector<vector<int> > > rules(N);\n  for (int i = 0; i < E; i++) {\n    int g, c;\n    cin >> g >> c;\n    --g;\n    vector<int> r(c);\n    for (int j = 0; j < c; j++) {\n      cin >> r[j];\n      --r[j];\n    }\n    rules[g].push_back(r);\n  }\n\n  const pair<vector<int>, bool> r = bellman_ford(rules, seed);\n  if (r.second && r.first[T] < INF) {\n    cout << r.first[T] << endl;\n  } else {\n    cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, E, T;\n    while (cin >> N >> E >> T) {\n        --T;\n        vector<int> start;\n        REP(i, N) {\n            int w; cin >> w;\n            if (w == 1) start.push_back(i);\n        }\n\n        // rules[goal][rule][seed]\n        vector<vector<vector<int>>> rules(N);\n        REP(i, E) {\n            int g, c; cin >> g >> c; --g;\n            vector<int> seeds(c);\n            REP(j, c) {\n                cin >> seeds[j];\n                --seeds[j];\n            }\n            rules[g].push_back(move(seeds));\n        }\n\n        static const int inf = 1e8;\n        vector<int> width(N, inf);\n        for (int g : start) width[g] = 1;\n        bool updated;\n        do {\n            updated = false;\n            REP(g, N) {\n                for (auto& rule : rules[g]) {\n                    vector<int> ws(rule.size());\n                    REP(i, rule.size())\n                        ws[i] = width[rule[i]];\n                    sort(ws.begin(), ws.end(), greater<int>());\n                    int v = 0;\n                    REP(i, ws.size())\n                        v = max(v, ws[i]+i);\n                    if (v < width[g]) {\n                        width[g] = v;\n                        updated = true;\n                    }\n                }\n            }\n        } while (updated);\n\n        cout << (width[T] < inf ? width[T] : -1) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, E, T;\nint W[310], G[1010], C[1010], S[1010][15];\n\nsigned main() {\n    cin >> N >> E >> T; T--;\n    for(int i=0; i<N; i++) {\n        cin >> W[i];\n        if(W[i] == 0) W[i] = INF;\n    }\n    vector<int> used_rule(E);\n    for(int i=0; i<E; i++) {\n        cin >> G[i] >> C[i]; G[i]--;\n        for(int k=0; k<C[i]; k++) {\n            cin >> S[i][k];\n            S[i][k]--;\n        }\n    }\n\n    for(int z=0; z<E; z++) {\n        bool change = false;\n        for(int i=0; i<E; i++) {\n            if(used_rule[i]) continue;\n            bool ok = true;\n            for(int k=0; k<C[i]; k++) {\n                ok &= (W[ S[i][k] ] < INF);\n            }\n            if(!ok) continue;\n\n            // use i-th rule\n            change = true;\n            used_rule[i] = true;\n\n            vector<int> ws;\n            for(int k=0; k<C[i]; k++) {\n                ws.push_back(W[ S[i][k] ]);\n            }\n            sort(ws.rbegin(), ws.rend());\n\n            int t = 0;\n            for(size_t k=0; k<ws.size(); k++) {\n                t = max<int>(t, k + ws[k]);\n            }\n            chmin(W[ G[i] ], t);\n            // fprintf(stderr, \"rule %lld: t = %lld\\n\", i, t);\n        }\n        if(!change) break;\n    }\n    if(W[T] == INF) cout << -1 << endl;\n    else cout << W[T] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nvvi G[MAX_N];\nint memo[MAX_N];\n\nint dfs(int nw,vector<bool>& flag){\n    if(flag[nw]){\n        flag[nw] = false;\n        return -1;\n    }\n    flag[nw] = true;\n    if(memo[nw]){\n        flag[nw] = false;\n        return memo[nw];\n    }\n    int mn = INF;\n    rep(i,len(G[nw])){\n        bool ok = true;\n        vi kekka;\n        int sz = len(G[nw][i]);\n        rep(j,sz){\n            int res = dfs(G[nw][i][j],flag);\n            if(res < 0){\n                ok = false;\n                break;\n            }\n            kekka.pb(res);\n        }\n        if(ok){\n            int val = sz;\n            sort(all(kekka));\n            rep(j,len(kekka)){\n                cmx(val,kekka[j]+sz-1-j);\n            }\n            cmn(mn,val);\n        }\n    }\n    if(mn == INF){\n        memo[nw] = -1;\n    }else{\n        memo[nw] = mn;\n    }\n    flag[nw] = false;\n    return memo[nw];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    vi w(n);\n    rep(i,n){\n        cin >> w[i];\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        G[a-1].pb(hoge);\n    }\n    rep(i,n){\n        if(w[i]) memo[i] = 1;\n    }\n    vector<bool> flag(n,false);\n    cout << dfs(t,flag) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint main(){\n\tint n,m,g; scanf(\"%d%d%d\",&n,&m,&g); g--;\n\n\tbool leaf[300];\n\trep(u,n){ int a; scanf(\"%d\",&a); leaf[u]=a; }\n\n\tvector<int> from[1000];\n\tint to[1000];\n\trep(i,m){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tto[i]=a-1;\n\t\trep(j,b) scanf(\"%d\",&a), from[i].push_back(a-1);\n\t}\n\n\tint dp[300];\n\trep(u,n) dp[u]=(leaf[u]?1:INF);\n\trep(i,n) rep(j,m) {\n\t\tint cost[10];\n\t\trep(k,from[j].size()) cost[k]=dp[from[j][k]];\n\t\tsort(cost,cost+from[j].size(),greater<int>());\n\n\t\tint nextcost=0;\n\t\trep(k,from[j].size()) nextcost=max(nextcost,k+cost[k]);\n\t\tdp[to[j]]=min(dp[to[j]],nextcost);\n\t}\n\n\tprintf(\"%d\\n\",dp[g]<INF?dp[g]:-1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nstruct Info{\n\tint result,element_num;\n\tvector<int> element;\n};\n\nint N,E,T;\nint POW[11],use_num[1024];\nint in_num[1000],relation[1000][300];\nint min_need[300];\nint dp[1024];\nvector<int> G[1000];\nInfo info[1000];\n\nint main(){\n\n\tfor(int i = 0; i < 11; i++)POW[i] = pow(2,i);\n\n\t//状態毎にいくつbitが立っているか、事前に計算しておく\n\tint num_1;\n\tfor(int state = 0; state < POW[10]; state++){\n\t\tnum_1 = 0;\n\t\tfor(int loop = 0; loop < 10; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tnum_1++;\n\t\t\t}\n\t\t}\n\t\tuse_num[state] = num_1;\n\t}\n\n\tscanf(\"%d %d %d\",&N,&E,&T);\n\n\tfor(int i = 0;i < E; i++){\n\t\tin_num[i] = 0;\n\t\tfor(int k = 0; k < N; k++)relation[i][k] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++)min_need[i] = BIG_NUM;\n\n\tint tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tif(tmp == 1){//手に入れやすい卵\n\t\t\tmin_need[i] = 1;\n\t\t}\n\t}\n\n\t//合成法則の情報を取得\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&info[loop].result,&info[loop].element_num);\n\n\t\tinfo[loop].result--; //0オリジンにする\n\n\t\tfor(int i = 0; i < info[loop].element_num; i++){ //要素を取得するとともに、未確定情報の個数を計上する(トポロジカル的に考える)\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\ttmp--;\n\t\t\tinfo[loop].element.push_back(tmp);\n\t\t\tif(min_need[tmp] == BIG_NUM){ //手に入れにくい魔女\n\t\t\t\tG[tmp].push_back(loop); //依存関係をエッジ化する\n\t\t\t\tin_num[loop]++;\n\t\t\t\trelation[loop][tmp] = 1; //★★ある魔女について、複数の合成情報があるため、単純なin_numの引き算ではバグる★★\n\t\t\t}\n\t\t}\n\t}\n\n\t//確定できる合成情報のindexをpush\n\tqueue<int> Q;\n\tfor(int i = 0; i < E; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\tint index,tmp_num,next_state,can_recycle_num;\n\tbool update_FLG;\n\twhile(!Q.empty()){\n\t\tindex = Q.front();\n\t\tQ.pop();\n\n\t\t//必要な卵の個数をdp計算する(★★作成順の都合により、単純な引き算では不可★★)\n\t\ttmp_num = info[index].element_num;\n\t\tfor(int state = 0; state < POW[tmp_num]; state++)dp[state] = BIG_NUM;\n\n\t\tdp[0] = 0;\n\t\tfor(int state = 0; state < POW[tmp_num]-1; state++){\n\t\t\tfor(int loop = 0; loop < tmp_num; loop++){\n\t\t\t\tif(state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tnext_state = state+POW[loop];\n\t\t\t\t\tcan_recycle_num = dp[state]-use_num[state]; //最小個数-使用個数 = リサイクル可能数\n\t\t\t\t\tdp[next_state] = min(dp[next_state],dp[state]+max(0,min_need[info[index].element[loop]]-can_recycle_num));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdate_FLG = false;\n\t\tif(min_need[info[index].result] > dp[POW[tmp_num]-1]){\n\t\t\tmin_need[info[index].result] = dp[POW[tmp_num]-1];\n\t\t\tupdate_FLG = true;\n\t\t}\n\t\tmin_need[info[index].result] = min(min_need[info[index].result],dp[POW[tmp_num]-1]);\n\n\t\tfor(int i = 0; i < G[info[index].result].size(); i++){ //依存関係のある情報を検索\n\n\t\t\tif(relation[G[info[index].result][i]][info[index].result] == 1){\n\n\t\t\t\trelation[G[info[index].result][i]][info[index].result] = 0;\n\t\t\t\tin_num[G[info[index].result][i]]--; //未確定情報の数を1つ減らす\n\t\t\t\tif(in_num[G[info[index].result][i]] == 0){ //未確定情報が無くなった場合\n\t\t\t\t\tQ.push(G[info[index].result][i]);\n\t\t\t\t}\n\t\t\t}else{ //relatino[G[info[index].result][i]][info[index].result] == 0 //既出の情報の場合\n\n\t\t\t\tif(!update_FLG)continue;\n\n\t\t\t\tif(in_num[G[info[index].result][i]] == 0){ //未確定情報が無い場合、最小値が更新される可能性があるのでpush\n\t\t\t\t\tQ.push(G[info[index].result][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT--;\n\tif(min_need[T] == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",min_need[T]);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int v,t;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nint main(){\n  int N,E,T;\n  cin>>N>>E>>T;\n  priority_queue<S> que;\n  for(int i=1;i<=N;i++){\n    int W;\n    cin>>W;\n    if(W){\n      que.push({i,1});\n    }\n  }\n  int G[1234],C[1234],S[1234][12];\n  for(int i=0;i<E;i++){\n    cin>>G[i]>>C[i];\n    for(int j=0;j<C[i];j++){\n      cin>>S[i][j];\n    }\n  }\n  int nn[312]={};\n  while(!que.empty()){\n    auto c=que.top();\n    que.pop();\n    if(nn[c.v])continue;\n    nn[c.v]=c.t;\n    for(int i=0;i<E;i++){\n      bool u=false;\n      bool f=false;\n      vector<int> v(C[i]);\n      for(int j=0;j<C[i];j++){\n\tu|=S[i][j]==c.v;\n\tf|=!nn[S[i][j]];\n\tv[j]=nn[S[i][j]];\n      }\n      if(u&&!f){\n\tsort(begin(v),end(v));\n\tint m=0;\n\tfor(int k=0;k<v.size();k++){\n\t  m=max<int>(m,v.size()-1-k+v[k]);\n\t}\n\tque.push({G[i],m});\n      }\n    }\n  }\n  cout<<(nn[T]?nn[T]:-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1e8;\nvector<int> cost;\nstruct synthesize{\n  int goal;\n  vector<int> start;\n  synthesize(int g, vector<int> s):\n    goal(g), start(s) {}\n  void update(){\n    int tot=0;\n    for(int ii : start) tot=max(tot, cost[ii]);\n    if(tot==INF) return;\n\n    int c=start.size(), use=tot;\n    priority_queue<int> pq;\n    for(int ii : start) pq.push(cost[ii]);\n    while(!pq.empty()){\n      int v=pq.top(); pq.pop();\n      if(use<v){\n        tot++;\n        use++;\n      }\n      use--;\n    }\n    cost[goal]=min(tot, cost[goal]);\n  }\n}; \n\nint main(){\n\tint n, e, t; cin >> n >> e >> t;\n  cost.assign(n+1, INF);\n  for(int i=1; i<=n; i++){\n    int tmp; cin >> tmp;\n    if(tmp==1) cost[i]=1;\n  }\n  vector<synthesize> vec;\n  for(int i=0; i<e; i++){\n    int g, c; cin >> g >> c;\n    vector<int> s(c);\n    for(int j=0; j<c; j++) cin >> s[j];\n    vec.push_back(synthesize(g, s));\n  }\n\n  for(int i=0; i<n; i++){\n    for(int j=0; j<e; j++){\n      vec[j].update();\n    }\n  }\n\n  cout << (cost[t] != INF ? cost[t] : -1) << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Law {\n\tint G;\n\tvector<int> S;\n};\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N); cin >> W;\n\tvector<Law> law;\n\tREP(i, E) {\n\t\tint G, C; cin >> G >> C; --G;\n\t\tvector<int> S(C); cin >> S;\n\t\tREP(i, C) S[i]--;\n\t\tlaw.pb( (Law){G, S} );\n\t}\n\tvector<int> dp(N, inf);\n\tREP(i, N) {\n\t\tif (W[i] == 1) {\n\t\t\tdp[i] = min(dp[i], 1);\n\t\t}\n\t}\n\tREP(t, N) REP(i, N) REP(j, E) {\n\t\tint M = 0, m = inf;\n\t\tvector<int> a(law[j].S.size());\n\t\tREP(k, law[j].S.size()) {\n\t\t\tint id = law[j].S[k];\n\t\t\ta[k] = dp[id];\n//\t\t\tM = max(M, dp[id]);\n//\t\t\tm = min(m, dp[id]);\n\t\t}\n\t\tsort( ALL(a), greater<int>() );\n\t\tint c = 1;\n\t\tREP(i, a.size()) {\n\t\t\tc = max(c, a[i]+(int)i);\n\t\t}\n\t\tdp[law[j].G] = min(dp[law[j].G], c);\n\t}\n\tif (dp[T] == inf) cout << -1 << endl;\n\telse cout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n\nconst int inf = 1<<29;\nint n,e,t;\nint w[301], memo[301];\nbool seen[301];\nvector<vector<int> > production[301];\n\nint rec(int v) {\n    if(memo[v] != -2) return memo[v];\n    if(w[v] == 1) return memo[v] = 1;\n\n    if(seen[v]) return -1;\n    seen[v] = true;\n    int ret = inf;\n    for(int i=0; i<production[v].size(); ++i) {\n        vector<int> child;\n        int tmp = 0,j;\n        for(j=0; j<production[v][i].size(); ++j) {\n            int k = rec(production[v][i][j]);\n            if(k == -1) goto NEXT;\n            child.push_back(k);\n        }\n\n\n        sort(child.begin(), child.end(), greater<int>());\n        for(j=0; j<child.size(); ++j) tmp = max(j+child[j],tmp);\n        ret = min(ret, tmp);\n    NEXT:;\n    }\n    seen[v] = false;\n\n    if(ret == inf) return memo[v] = -1;\n    return memo[v] = ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    memset(seen, false, sizeof(seen));\n\n    cin>>n>>e>>t;\n    rep(i,301) memo[i] = -2;\n    rep(i,n) cin>>w[i+1];\n    rep(i,e) {\n        int g,c;\n        cin>>g>>c;\n        vector<int> v(c);\n        rep(j,c) cin>>v[j];\n        production[g].push_back(v);\n    }\n\n    cout<<rec(t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int inf = (1<<29);\nconst int N = 300;\nconst int E = 1000;\nstruct st{\n  int tar;\n  vector<int> req;\n};\nvector<st> edge;\nint cost[N];\n\nvoid update(int index){\n  vector<int> tmp(edge[index].req.size());\n  rep(i,edge[index].req.size()){\n    int next=edge[index].req[i];\n    if (cost[next] == inf)return;\n    tmp[i]=cost[next];\n  }\n  sort(tmp.begin(),tmp.end(),greater<int>());\n  //rep(j,tmp.size())cout << tmp[j]<<\" \" ;cout << endl;\n  int gs=0;\n  int keep=0;\n  int rem=0;//rem=gs-keep\n  rep(i,tmp.size()){\n    int req=tmp[i];\n    //cout <<\"update \" <<inf <<\" \" <<  req <<\" \" << rem <<\" \" << gs << endl;\n    if (req > rem)gs+=req-rem;\n    keep++;\n    rem=gs-keep;\n  }\n  int tar=edge[index].tar;\n  //cout <<\"update result \" <<  tar <<\" \" << cost[tar] << \" \" << gs << endl;\n  cost[tar]=min(cost[tar],gs);\n}\n\nint solve(int n,int tar){\n  rep(loop,n){\n    rep(i,edge.size()){\n      update(i);\n    }\n    //rep(i,n)cout << cost[i] <<\" \" ;cout << endl;\n  }\n  return cost[tar];\n}\n\nmain(){\n  int n,e,t;\n  while(cin>>n>>e>>t){\n    t--;\n    edge.clear();\n    rep(i,n){\n      int tmp;cin>>tmp;\n      cost[i]=tmp==1?1:inf;\n    }\n    rep(i,e){\n      st ins;\n      cin>>ins.tar;\n      ins.tar--;\n      int size;\n      cin>>size;\n      rep(j,size){int tmp;cin>>tmp;ins.req.push_back(tmp-1);}\n      edge.push_back(ins);\n    }\n    int ans = solve(n,t);\n    cout << ((ans == inf)? -1 : ans) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,E,T;\nint W[300];\nint G[1000],C[1000],S[1000][10];\n\nint F[300];\n\nsigned main(){\n    cin>>N>>E>>T;\n    rep(i,N)cin>>W[i];\n    rep(i,E){\n        cin>>G[i]>>C[i];\n        G[i]--;\n        rep(j,C[i]){\n            cin>>S[i][j];\n            S[i][j]--;\n        }\n    }\n\n    fill_n(F,N,1001001001);\n    rep(i,N)if(W[i])F[i]=1;\n\n    for(int i=0;i<N;i++){\n        for(int j=0;j<E;j++){\n            vint v;\n            rep(k,C[j])v.pb(F[S[j][k]]);\n            sort(all(v));\n            reverse(all(v));\n            int w=0;\n            rep(k,C[j]){\n                if(w-k<v[k]){\n                    w=k+v[k];\n                }\n            }\n            chmin(F[G[j]],w);\n        }\n    }\n    T--;\n    if(F[T]==1001001001)cout<<-1<<endl;\n    else cout<<F[T]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\nconstexpr int inf = 1e9+7;\nint main() {\n    int n, e, t; scanf(\"%d%d%d\", &n, &e, &t); -- t;\n    vector<bool> w(n); repeat (i, n) { int w_i; scanf(\"%d\", &w_i); w[i] = w_i; }\n    vector<int> goal(e), cnt(e);\n    vector<vector<int> > src(e);\n    vector<vector<int> > use(n);\n    repeat (i, e) {\n        scanf(\"%d%d\", &goal[i], &cnt[i]); -- goal[i];\n        src[i].resize(cnt[i]); repeat (j, cnt[i]) { scanf(\"%d\", &src[i][j]); -- src[i][j]; }\n        for (int s : src[i]) use[s].push_back(i);\n    }\n    vector<int> cost(n, inf);\n    reversed_priority_queue<pair<int, int> > que;\n    repeat (i, n) if (w[i]) {\n        que.emplace(1, i);\n    }\n    auto use_law = [&](int j) {\n        vector<int> costs(src[j].size());\n        repeat (k, src[j].size()) {\n            costs[k] = cost[src[j][k]];\n        }\n        whole(sort, costs);\n        whole(reverse, costs);\n        int cost_i = 0;\n        repeat (k, costs.size()) {\n            setmax(cost_i, costs[k] + k);\n        }\n        int i = goal[j];\n        if (cost_i < cost[i]) {\n            que.emplace(cost_i, i);\n        }\n    };\n    while (not que.empty()) {\n        int cost_i, i; tie(cost_i, i) = que.top(); que.pop();\n        if (cost[i] <= cost_i) continue;\n        assert (cost[i] == inf);\n        cost[i] = cost_i;\n        for (int j : use[i]) {\n            cnt[j] -= 1;\n            if (cnt[j] == 0) {\n                use_law(j);\n            }\n        }\n    }\n    int result = cost[t];\n    if (result == inf) result = -1;\n    printf(\"%d\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Law {\n\tint G;\n\tvector<int> S;\n};\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N); cin >> W;\n\tvector<Law> law;\n\tREP(i, E) {\n\t\tint G, C; cin >> G >> C; --G;\n\t\tvector<int> S(C); cin >> S;\n\t\tREP(i, C) S[i]--;\n\t\tlaw.pb( (Law){G, S} );\n\t}\n\tvector<int> dp(N, inf);\n\tREP(i, N) {\n\t\tif (W[i] == 1) {\n\t\t\tdp[i] = min(dp[i], 1);\n\t\t}\n\t}\n\tREP(t, E) REP(i, N) REP(j, E) {\n\t\tint M = 0, m = inf;\n\t\tvector<int> a(law[j].S.size());\n\t\tREP(k, law[j].S.size()) {\n\t\t\tint id = law[j].S[k];\n\t\t\ta[k] = dp[id];\n//\t\t\tM = max(M, dp[id]);\n//\t\t\tm = min(m, dp[id]);\n\t\t}\n\t\tsort( ALL(a), greater<int>() );\n\t\tint c = 1;\n\t\tREP(i, a.size()) {\n\t\t\tc = max(c, a[i]+(int)i);\n\t\t}\n\t\tdp[law[j].G] = min(dp[law[j].G], c);\n\t}\n\tif (dp[T] == inf) cout << -1 << endl;\n\telse cout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\n#define INF 1000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n, e, t;\nint w[300];\nint cost[300];\nvector<vector<int> > need[300];\n\nint main(){\n    cin >> n >> e >> t;\n    t--;\n    rep(i,n) cost[i] = INF;\n    rep(i,n){\n        cin >> w[i];\n        if(w[i]) cost[i] = 1;\n    }\n    rep(i,e){\n        int g, c;\n        cin >> g >> c;\n        g--;\n        vector<int> hoge;\n        rep(j,c){\n            int tmp;\n            cin >> tmp;\n            tmp--;\n            hoge.push_back(tmp);\n        }\n        need[g].push_back(hoge);\n    }\n    while(true){\n        int val = INF;\n        int id = 0;\n        rep(i,n){\n            rep(u,need[i].size()){\n                if(cost[i] != INF) continue;\n                int cnt = 0;\n                int tmpv = 0;\n                rep(j,need[i][u].size()){\n                    if(cnt < cost[need[i][u][j]]) cnt = cost[need[i][u][j]];\n                }\n                tmpv--;\n                rep(j,need[i][u].size()){\n                    if(cost[need[i][u][j]] == cnt) tmpv++;\n                }\n                tmpv += cnt;\n                tmpv = max(tmpv,(int)need[i][u].size());\n                if(val > tmpv){\n                    val = tmpv;\n                    id = i;\n                }\n            }\n        }\n        if(val == INF) break;\n        cost[id] = val;\n    }\n    if(cost[t] == INF) cost[t] = -1;\n    cout << cost[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N,E,T;\nvector<bool> check;\nvector<int> cost;\nvector<vector<vector<int> > > rule;\nconst int NOT=-2;\n\nint calc(int idx){\n\tif(cost[idx]>=0) return cost[idx];\n\tif(cost[idx]==NOT) return NOT;\n\tif(check[idx]){cost[idx]=NOT;return NOT;}\n\tcheck[idx]=true;\n\tif(rule[idx].size()==0){cost[idx]=NOT; return NOT;}\n\tint res=1000000000;\n\tfor(int i=0;i<rule[idx].size();i++){\n\t\tvector<int> C;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<rule[idx][i].size();j++){\n\t\t\tint p=calc(rule[idx][i][j]);\n\t\t\tif(p==NOT){cost[idx]=NOT;ok=false;break;}\n\t\t\tC.push_back(p);\n\t\t}\n\t\tif(ok){\n\t\t\tsort(C.begin(),C.end());\n\t\t\tint num=0,fill=0;\n\t\t\tfor(int k=C.size()-1;k>=0;k--){\n\t\t\t\tnum=max(num,fill+C[k]);\n\t\t\t\tfill++;\n\t\t\t}\n\t\t\tres=min(res,num);\n\t\t}\n\t}\n\tif(res==1000000000) return cost[idx]=NOT;\n\treturn cost[idx]=res;\n}\n\n\nint main()\n{\n\tcin>>N>>E>>T;\n\tT--;\n\tcheck.resize(N,false);\n\tcost.resize(N,-1);\n\tfor(int i=0;i<N;i++){\n\t\tint t;cin>>t;\n\t\tif(t==1){cost[i]=1;}\n\t}\n\trule.resize(N);\n\n\tfor(int i=0;i<E;i++){\n\t\tint idx,num; cin>>idx>>num;\n\t\tidx--;\n\t\tvector<int> now;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tint t;cin>>t;t--;\n\t\t\tnow.push_back(t);\n\t\t}\n\t\trule[idx].push_back(now);\n\t}\n\tint res=calc(T);\n\n\tif(res==NOT) cout<<-1<<endl;\n\telse cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define INF (1<<27)\ntypedef pair<int,int> P;\n \nint N,E,T;\nvector<P> G[500];\n \nstruct Node{\n  int c,g;\n  vector<int> S;\n  \n  void init(int c,int g){\n    this->c = c; if( c > 0 ) S = vector<int>(c,INF);\n    this->g = g;\n  }\n  bool check(){\n    for(int i=0;i<c;i++)\n      if( S[i] >= INF) return false;\n    return true;\n  }\n  bool update(int id,int x){\n    if( S[id] > x ){\n      S[id] = x; return true;\n    } return false;\n  }\n  int value() const{\n    if( S.empty() ) return 1;\n    vector<int> s = S;\n    sort(s.begin(),s.end());\n    int ret = 0;\n    for(int i=c-1,cnt=0;i>=0;i--,cnt++){\n      ret = max ( cnt + s[i], ret );\n    }\n    return ret;\n  }\n   \n  bool operator<(const Node& b)const{\n    return value() > b.value();\n  }\n \n};\n \nNode H[2000];\n \nint main(){\n \n  priority_queue<Node> q;\n \n  cin >> N >> E >> T;\n  for(int i=0;i<N;i++){\n    int w;\n    cin >> w;\n    if( w == 1 ){\n      Node n;\n      n.init(0,i+1);\n      H[i+E] = n;\n      q.push( n );\n    }\n  }\n  for(int i=0;i<E;i++){\n    int g,c;\n    cin >> g >> c;\n    H[i].init(c,g);\n    for(int j=0;j<c;j++){\n      int s;\n      cin >> s;\n      G[s].push_back( P(i,j) );\n    }\n  }\n \n  while( !q.empty() ){\n    Node st = q.top(); q.pop();\n    int val = st.value();\n    int id = st.g;\n    for(int i=0;i<(int)G[id].size();i++){\n      P to = G[id][i];\n      if( H[to.first].update(to.second,val) ){\n    if( H[to.first].check() ){\n      q.push( H[to.first] );\n    }\n      }\n    }\n  }\n \n  int res = INF;\n  for(int i=0;i<N+E;i++){\n    //  cout << H[i].g << \" \"<< H[i].value() << endl;\n    if( H[i].g == T ) res = min( res, H[i].value() );\n  }\n  if( res >= INF ) cout << -1 << endl;\n  else cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nll dp[310];\nvvint vv[310];\nint n;\nint used[310];\nll foo(int x){\n\tif(dp[x]!=INF){\n\t\treturn dp[x];\n\t}\n\tif(used[x]) return INF;\n\t// dump(x+1);\n\tll ret=INF+1;\n\tused[x]=1;\n\trep(i,vv[x].size()){\n\t\tvll tmp;\n\t\trep(j,vv[x][i].size()){\n\t\t\ttmp.PB(foo(vv[x][i][j]));\n\t\t}\n\t\tsort(ALL(tmp));\n\t\treverse(ALL(tmp));\n\t\tll t1=0;\n\t\tll t2=0;\n\t\trep(i,tmp.size()){\n\t\t\tif(t2>=tmp[i]){\n\t\t\t\t// t2-=tmp[i];\n\t\t\t\tt2--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt1+=tmp[i]-t2;\n\t\t\t\tt2=tmp[i]-1;\n\t\t\t}\n\t\t}\n\t\tret=min(ret,t1);\n\t}\n\tused[x]=0;\n\treturn dp[x]=ret;\n}\nvoid mainmain(){\n\tint e,T;\n\tcin>>n>>e>>T;\n\t// dump(n);\n\tT--;\n\tvint w(n);\n\trep(i,n) cin>>w[i];\n\trep(i,e){\n\t\tint a,b;\n\t\t// dump(a);\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tint tt=vv[a].size();\n\t\tvv[a].resize(vv[a].size()+1);\n\t\trep(j,b){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tt--;\n\t\t\tvv[a][tt].PB(t);\n\t\t}\n\t}\n\trep(i,310){\n\t\tdp[i]=INF;\n\t}\n\trep(i,n){\n\t\tif(w[i]) dp[i]=1;\n\t}\n\tfoo(T);\n\tif(dp[T]>=INF) cout<<-1<<endl;\n\telse cout<<dp[T]<<endl;\n}\n\n\nmain() {\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t;\nbool ok[300];\n\nint main(){\n\tmap<int, vector<vi> > mm;\n\t\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint g, k;\n\t\tcin >> g >> k;\n\t\tvi v(k);\n\t\trep(j, k) cin >> v[j], v[j]--;\n\t\tmm[g - 1].pb(v);\n\t}\n\tt--;\n\t\n\tif(ok[t]){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tset<vi> s;\n\tvi v(1, t);\n\tpriority_queue<pair<int, vi> > q;\n\tq.push(mp(-1, v));\n\twhile(!q.empty()){\n\t\tv = q.top().second;\n\t\tint co = q.top().first; q.pop();\n\t\tif(s.count(v)) continue;\n\t\ts.insert(v);\n\t\t\n\t\tif(v.empty()){\n\t\t\tcout << -co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(i, v.size()) each(j, mm[v[i]]){\n\t\t\tvi nv = v;\n\t\t\teach(k, *j){\n\t\t\t\tif(!ok[*k]) nv.pb(*k);\n\t\t\t}\n\t\t\tswap(nv[i], nv.back());\n\t\t\tnv.erase(nv.end() - 1);\n\t\t\tsort(all(nv));\n\t\t\tint nco = v.size() + j->size() - 1;\n\t\t\tnco = min(-nco, co);\n\t\t\tif(!s.count(nv)) q.push(mp(nco, nv));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, E, T;\nvector<int> W;\nvector<int> G;\nvector<int> S[1000];\nint memo[300];\nint dfs(int K, vector<bool> used){\n  if(memo[K] != -1 && memo[K] < INF) return memo[K];\n  if(W[K]) return 1;\n  int res = INF;\n  used[K] = true;\n  REP(i, E) if(G[i] == K){\n    vector<int> need;\n    REP(j, S[i].size()) {\n      if(used[S[i][j]]) need.push_back(INF);\n      else need.push_back(dfs(S[i][j], used));\n    }\n    sort(need.begin(), need.end());\n    reverse(need.begin(), need.end());\n    int ans = 0;\n    REP(i, need.size()) ans = max(ans, need[i] + i);\n    res = min(res, ans);\n  }\n  return memo[K] = res;\n}\nint main(){\n  while(cin >> N >> E >> T){\n    T--;\n    W.assign(N, 0);\n    REP(i, N) cin >> W[i];\n    G.assign(E, 0);\n    REP(i, E){\n      cin >> G[i]; G[i]--;\n      int C; cin >> C;\n      S[i].assign(C, 0);\n      REP(j, C) cin >> S[i][j];\n      REP(j, C) S[i][j] --;\n    }\n    /*\n    vector<bool> used(N, false);\n    memset(memo, -1, sizeof memo);\n    int ans = dfs(T, used);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    */\n    bool update;\n    vector<int> dist(N, INF);\n    REP(i, N) if(W[i]) dist[i] = 1;\n    while(true){\n      update = false;\n      REP(i, E){\n        vector<int> need;\n        REP(j, S[i].size()){\n          need.push_back(dist[S[i][j]]);\n        }\n        sort(need.begin(), need.end());\n        reverse(need.begin(), need.end());\n        int res = 0;\n        REP(j, need.size()) res = max(res, need[j] + j);\n        if(dist[G[i]] > res){\n          update = true;\n          dist[G[i]] = res;\n        }\n      }\n      if(!update) break;\n    }\n    if(dist[T] == INF) dist[T] = -1;\n    cout << dist[T] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint INF=1e8;\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    t--;\n    vector<int> dp(n,INF);\n    for(int i=0;i<n;i++){\n        int w;\n        cin>>w;\n        if(w){\n            dp[i]=1;\n        }\n    }\n    vector<int> g(e);\n    vector<vector<int>> s(e);\n    for(int i=0;i<e;i++){\n        cin>>g[i];\n        g[i]--;\n        int c;\n        cin>>c;\n        s[i].assign(c,0);\n        for(int j=0;j<c;j++){\n            cin>>s[i][j];\n            s[i][j]--;\n        }\n    }\n    bool update=true;\n    while(update){\n        update=false;\n        for(int j=0;j<e;j++){\n            int ma=0;\n            int mi=INF;\n            bool isok=false;\n            vector<int> vals(s[j].size());\n            for(int k=0;k<s[j].size();k++){\n                vals[k]=dp[s[j][k]];\n            }\n            sort(vals.rbegin(),vals.rend());\n            int sc=0;\n            for(int k=0;k<s[j].size();k++){\n                sc=max(sc,k+vals[k]);\n            }\n            if(sc<dp[g[j]]){\n                dp[g[j]]=sc;\n                update=true;\n            }\n        }\n    }\n    if(dp[t]>=INF){\n        cout<<-1<<endl;\n    }\n    else{\n        cout<<dp[t]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nconstexpr int INF = (1 << 29);\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N, E, T;\n\tcin >> N >> E >> T;\n\n\tvector<int> dp(N, INF);\n\n\tfor(int i = 0; i < N; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\t\tif(w == 1) dp[i] = 1;\n\t}\n\n\tvector<vector<vector<int>>> G(N);\n\n\tfor(int i = 0; i < E; ++i) {\n\t\tint g, c;\n\t\tcin >> g >> c;\n\n\t\tvector<int> material(c);\n\t\tfor(auto &e : material) {\n\t\t\tcin >> e;\n\t\t\t--e;\n\t\t}\n\n\t\tG[g - 1].emplace_back(move(material));\n\t}\n\n\twhile(true) {\n\t\tbool update = false;\n\n\t\tfor(int v = 0; v < N; ++v) {\n\t\t\tfor(const auto &nodes : G[v]) {\n\t\t\t\tvector<int> need;\n\t\t\t\tneed.reserve(nodes.size());\n\n\t\t\t\tfor(const auto &c : nodes) {\n\t\t\t\t\tneed.emplace_back(dp[c]);\n\t\t\t\t}\n\n\t\t\t\tsort(need.rbegin(), need.rend());\n\n\t\t\t\tint tmp = 0;\n\t\t\t\tfor(int i = 0; i < static_cast<int>(need.size()); ++i) {\n\t\t\t\t\tchmax(tmp, need[i] + i);\n\t\t\t\t}\n\n\t\t\t\tif(dp[v] > tmp) {\n\t\t\t\t\tdp[v] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!update) break;\n\t}\n\n\tcout << (dp[T - 1] == INF ? -1 : dp[T - 1]) << endl;\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,E,T;\nint W[300];\nint G[1000],C[1000],S[1000][10];\n\nint F[300];\n\nsigned main(){\n    cin>>N>>E>>T;\n    rep(i,N)cin>>W[i];\n    rep(i,E){\n        cin>>G[i]>>C[i];\n        G[i]--;\n        rep(j,C[i]){\n            cin>>S[i][j];\n            S[i][j]--;\n        }\n    }\n\n    fill_n(F,N,1001001001);\n    rep(i,N)if(W[i])F[i]=1;\n\n    for(int i=0;i<N;i++){\n        for(int j=0;j<E;j++){\n            vint v;\n            rep(k,C[j])v.pb(F[S[j][k]]);\n            sort(all(v));\n            reverse(all(v));\n            int w=0;\n            rep(k,C[j]){\n                if(w-k<v[k]){\n                    w=k+v[k];\n                }\n            }\n            chmin(F[G[j]],w);\n        }\n    }\n    T--;\n    if(F[T]==1001001001)cout<<-1<<endl;\n    else cout<<F[T]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_N = 300;\nconstexpr int INF = (1 << 29);\n\nint N, E, T;\nbool w[MAX_N];\n\nvector<vector<int>> G[MAX_N];\n\nint memo[MAX_N];\n\nint dfs(int v) {\n\tint &res = memo[v];\n\tif(res != -1) return res;\n\n\tif(w[v]) {\n\t\tres = 1;\n\t}\n\telse {\n\t\tres = INF;\n\n\t\tfor(const auto &nodes : G[v]) {\n\t\t\tvector<int> need;\n\t\t\tneed.reserve(nodes.size());\n\n\t\t\tfor(const auto &c : nodes) {\n\t\t\t\tneed.emplace_back(dfs(c));\n\t\t\t}\n\n\t\t\tsort(need.rbegin(), need.rend());\n\n\t\t\tint tmp = 0;\n\t\t\tfor(int i = 0; i < static_cast<int>(nodes.size()); ++i) {\n\t\t\t\tchmax(tmp, need[i] + i);\n\t\t\t}\n\n\t\t\tchmin(res, tmp);\n\t\t}\n\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> E >> T;\n\n\tfor(int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\n\tfor(int i = 0; i < E; ++i) {\n\t\tint g, c;\n\t\tcin >> g >> c;\n\n\t\tvector<int> material(c);\n\t\tfor(auto &e : material) {\n\t\t\tcin >> e;\n\t\t\t--e;\n\t\t}\n\n\t\tG[g - 1].emplace_back(move(material));\n\t}\n\n\tmemset(memo, -1, sizeof(memo));\n\tconst int ans = dfs(T - 1);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[310];\nint d[310];\nint b;\nvector<int> g[1100];\nvector<int>h[310];\nint to[1100];\n\nint main(){\n\tint a,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",d+i);\n\tfor(int i=0;i<a;i++)dp[i]=999999999;\n\tfor(int i=0;i<b;i++)g[i].clear();\n\tfor(int i=0;i<a;i++)h[i].clear();\n\tfor(int i=0;i<b;i++){\n\t\tint p;\n\t\tscanf(\"%d%d\",to+i,&p);\n\t\tto[i]--;\n\t\th[to[i]].push_back(i);\n\t\tfor(int j=0;j<p;j++){\n\t\t\tint q;scanf(\"%d\",&q);\n\t\t\tq--;g[i].push_back(q);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)if(d[i])dp[i]=1;\n\tfor(int i=0;i<310;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tvector<int>res;\n\t\t\tfor(int k=0;k<g[j].size();k++)res.push_back(dp[g[j][k]]);\n\t\t\tstd::sort(res.begin(),res.end());\n\t\t\tint val=0;\n\t\t\tfor(int k=0;k<g[j].size();k++)val=max(val,res[k]+(int)(g[j].size()-1-k));\n\t\t\tdp[to[j]]=min(dp[to[j]],val);\n\t\t}\n\t}\n\tc--;\n\tif(dp[c]>99999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",dp[c]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_N 310\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n\n\nstruct Recipe{\n  int G;\n  vector<int> S;\n};\n\n\nint N,E,T,W[MAX_N],C;\nint mincost[MAX_N];\n\nbool cmp(const int& a,const int& b){\n  return mincost[a] > mincost[b];\n}\n\n\nint main(){\n  cin >> N >> E >> T;\n  --T;\n  Recipe *reci = new Recipe[E];\n  rep(i,N)cin>>W[i],mincost[i] = (W[i]?1:IINF);\n  rep(i,E){\n    cin >> reci[i].G >> C;\n    --reci[i].G;\n    reci[i].S.resize(C);\n    rep(k,C){\n      cin >> reci[i].S[k];\n      --reci[i].S[k];\n    }\n  }\n\n  bool update = true;\n  while(update){\n    update = false;\n    rep(i,E){\n      bool ok = true;\n      int greef = 0,need = 0;\n      sort(reci[i].S.begin(),reci[i].S.end(),cmp);\n      rep(j,reci[i].S.size()){\n        if( mincost[reci[i].S[j]] == IINF ){\n          ok = false;\n          break;\n        } else{\n          if( greef >= mincost[reci[i].S[j]] ) --greef;\n          else{\n            need += mincost[reci[i].S[j]] - greef;\n            greef = mincost[reci[i].S[j]] - 1;\n          }\n        }\n      }\n      if(ok && mincost[reci[i].G] > need ){\n        mincost[reci[i].G] = need;\n        update = true;\n      }\n    }\n  }\n\n  cout << ((mincost[T]!=IINF)?mincost[T]:-1) << endl;\n\n  delete [] reci;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 10000000;\n\nint dfs(vector<int>& dep, const vector<pair<int, vector<int>>>& cmp, const vector<int>& esy, int i, int rec = 0) {\n  if (dep[i] >= 0) return dep[i];\n  if (esy[i] == 1) return dep[i] = 1;\n  auto itr = lower_bound(begin(cmp), end(cmp), make_pair(i, vector<int>()));\n  auto itr2 = lower_bound(begin(cmp), end(cmp), make_pair(i+1, vector<int>()));\n  if (itr == end(cmp) || itr->first != i) return dep[i] = INF;\n  int ming = INF;\n  for(auto k=itr;k!=itr2;++k){\n    vector<int> nums;\n    for(int j:k->second){\n      nums.push_back(dfs(dep,cmp,esy,j));\n    }\n    sort(begin(nums),end(nums));\n    int maxe = 0;\n    int n = nums.size();\n    REP(j,n){\n      maxe = max(maxe, nums[j] + (n-j-1));\n    }\n    ming = min(ming, max(maxe, n));\n  }\n  return dep[i] = ming;\n}\n\nint main() {\n  int n,e,t;\n  cin>>n>>e>>t;\n  --t;\n  vector<int> esy(n);\n  REP(i,n)cin>>esy[i];\n  vector<pair<int, vector<int>>> cmp;\n  REP(i,e){\n    int g,c;\n    cin>>g>>c;\n    --g;\n    vector<int> cld(c);\n    REP(j,c){\n      cin>>cld[j];\n      --cld[j];\n    }\n    cmp.emplace_back(g, cld);\n  }\n  sort(begin(cmp),end(cmp));\n  vector<int> dep(n,-1);\n  dfs(dep, cmp, esy, t);\n  if (dep[t] < INF)\n    cout << dep[t] << endl;\n  else\n    cout << -1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int v,t;\n  bool operator<(S s)const{\n    return t<s.t;\n  }\n};\n\nint main(){\n  int N,E,T;\n  cin>>N>>E>>T;\n  priority_queue<S> que;\n  for(int i=1;i<=N;i++){\n    int W;\n    cin>>W;\n    if(W){\n      que.push({i,1});\n    }\n  }\n  int G[1234],C[1234],S[1234][12];\n  for(int i=0;i<E;i++){\n    cin>>G[i]>>C[i];\n    for(int j=0;j<C[i];j++){\n      cin>>S[i][j];\n    }\n  }\n  int nn[312]={};\n  while(!que.empty()){\n    auto c=que.top();\n    que.pop();\n    if(nn[c.v])continue;\n    nn[c.v]=c.t;\n    for(int i=0;i<E;i++){\n      bool u=false;\n      bool f=false;\n      vector<int> v(C[i]);\n      for(int j=0;j<C[i];j++){\n\tu|=S[i][j]==c.v;\n\tf|=!nn[S[i][j]];\n\tv[j]=nn[S[i][j]];\n      }\n      if(u&&!f){\n\tsort(begin(v),end(v));\n\tint m=0;\n\tfor(int k=0;k<v.size();k++){\n\t  m=max<int>(m,v.size()-1-k+v[k]);\n\t}\n\tque.push({G[i],m});\n      }\n    }\n  }\n  cout<<(nn[T]?nn[T]:-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[310];\nint d[310];\nint b;\nvector<int> g[1100];\nvector<int>h[310];\nint to[1100];\nint calc(int a,int dep){\n\tif(~dp[a])return dp[a];\n\tif(d[a])return dp[a]=1;\n\tif(dep==100)return 999999999;\n\tint ret=999999999;\n\tfor(int i=0;i<h[a].size();i++){\n\t\tvector<int>res;\n\t\tint at=h[a][i];\n\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\tres.push_back(calc(g[at][j],dep+1));\n\t\t}\n\t\tstd::sort(res.begin(),res.end());\n\t\tint t=0;\n\t\tfor(int j=0;j<res.size();j++)t=max(t,res[j]+(int)(res.size()-1-j));\n\t\tret=min(ret,t);\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",d+i);\n\tfor(int i=0;i<a;i++)dp[i]=-1;\n\tfor(int i=0;i<b;i++)g[i].clear();\n\tfor(int i=0;i<a;i++)h[i].clear();\n\tfor(int i=0;i<b;i++){\n\t\tint p;\n\t\tscanf(\"%d%d\",to+i,&p);\n\t\tto[i]--;\n\t\th[to[i]].push_back(i);\n\t\tfor(int j=0;j<p;j++){\n\t\t\tint q;scanf(\"%d\",&q);\n\t\t\tq--;g[i].push_back(q);\n\t\t}\n\t}\n\tint ret=calc(c-1,0);\n\tif(ret>99999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N,E,T;\nvector<bool> check;\nvector<int> cost;\nvector<vector<vector<int> > > rule;\nconst int NOT=-2;\n\nint calc(int idx){\n\tif(cost[idx]>=0) return cost[idx];\n\tif(cost[idx]==NOT) return NOT;\n\tif(check[idx]){cost[idx]=NOT;return NOT;}\n\tcheck[idx]=true;\n\tif(rule[idx].size()==0){cost[idx]=NOT; return NOT;}\n\n\n\tint res=1000000000;\n\tfor(int i=0;i<rule[idx].size();i++){\n\t\tvector<int> C;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<rule[idx][i].size();j++){\n\t\t\tint p=calc(rule[idx][i][j]);\n\t\t\tif(p==NOT){cost[idx]=NOT;ok=false;break;}\n\t\t\tC.push_back(p);\n\t\t}\n\t\tif(ok){\n\t\t\tsort(C.begin(),C.end());\n\t\t\tint a=C.size()-1;\n\t\t\tint num=0;\n\t\t\twhile(a>=0 &&  C[a]==C[C.size()-1]){\n\t\t\t\ta--;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tres=min(res,max(num-1+C[C.size()-1],(int)C.size()+C[0]-1));\n\t\t}\n\t}\n\tif(res==1000000000) return NOT;\n\treturn cost[idx]=res;\n}\n\n\nint main()\n{\n\tcin>>N>>E>>T;\n\tT--;\n\tcheck.resize(N,false);\n\tcost.resize(N,-1);\n\tfor(int i=0;i<N;i++){\n\t\tint t;cin>>t;\n\t\tif(t==1){cost[i]=1;}\n\t}\n\trule.resize(N);\n\n\tfor(int i=0;i<E;i++){\n\t\tint idx,num; cin>>idx>>num;\n\t\tidx--;\n\t\tvector<int> now;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tint t;cin>>t;t--;\n\t\t\tnow.push_back(t);\n\t\t}\n\t\trule[idx].push_back(now);\n\t}\n\tint res=calc(T);\n\n\tif(res==NOT) cout<<-1<<endl;\n\telse cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, E, T;\nvector<int> W;\nvector<int> G;\nvector<int> S[1000];\nint dfs(int K, vector<bool> used){\n  if(W[K]) return 1;\n  int res = INF;\n  used[K] = true;\n  REP(i, E) if(G[i] == K){\n    vector<int> need;\n    REP(j, S[i].size()) {\n      if(used[S[i][j]]) need.push_back(INF);\n      else need.push_back(dfs(S[i][j], used));\n    }\n    sort(need.begin(), need.end());\n    reverse(need.begin(), need.end());\n    int ans = 0;\n    REP(i, need.size()) ans = max(ans, need[i] + i);\n    res = min(res, ans);\n  }\n  return res;\n}\nint main(){\n  while(cin >> N >> E >> T){\n    T--;\n    W.assign(N, 0);\n    REP(i, N) cin >> W[i];\n    G.assign(E, 0);\n    REP(i, E){\n      cin >> G[i]; G[i]--;\n      int C; cin >> C;\n      S[i].assign(C, 0);\n      REP(j, C) cin >> S[i][j];\n      REP(j, C) S[i][j] --;\n    }\n    vector<bool> used(N, false);\n    int ans = dfs(T, used);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint w[10800];\nbool come[10800];\nbool able[10800];\nvector< vector<int> > material[10800];\nint g, c, x ;\nint memo[108000];\n\n\nvoid check(int x){\n\tif(w[x])able[x] = true;\n\tif(able[x])return;\n\tfor(int i = 0;i < material[x].size();i++){\n\t\tbool ok = true;\n\t\tfor(int j = 0;j < material[x][i].size();j++){\n\t\t\tint to = material[x][i][j];\n\t\t\tif(!able[to])ok = false;\n\t\t}\n\t\tif(ok){\n\t\t\table[x] = ok;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nint solve(int x){\n\tint &res = memo[x];\n\tif(res != 0)return res;\n\tif(w[x])return res = 1;\n\tif(!able[x])return res = -1;\n\tres = 1 << 30;\n\tfor(int i = 0;i < material[x].size();i++){\n\t\tint tmp = material[x][i].size();\n\t\tvector<int> cnts;\n\t\tfor(int j = 0;j < material[x][i].size();j++){\n\t\t\tint to = material[x][i][j];\n\t\t\tint t = solve(to);\n\t\t\tif(t == -1){\n\t\t\t\ttmp = 1 << 30;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnts.push_back(t);\n\t\t}\n\t\tif(tmp == 1 << 30)continue;\n\t\tsort(cnts.begin(), cnts.end(), greater<int>() );\n\t\tfor(int j = 0;j < cnts.size();j++){\n\t\t\ttmp = max(tmp, cnts[j] + j);\n\t\t}\n\t\tres = min(res, tmp);\n\t}\n\tif(res == 1 << 30)return res = -1;\n\telse return res;\n\t\n}\n\nint main(){\n\tint n, e, t;\n\tcin >> n >> e >> t;t--;\n\tfor(int i = 0;i < n;i++)cin >> w[i];\n\tfor(int i = 0;i < e;i++){\n\t\tcin >> g >> c;g--;\n\t\tvector<int> tmp;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> x;x--;\n\t\t\ttmp.push_back(x);\n\t\t}\n\t\tmaterial[g].push_back(tmp);\n\t}\n\tfor(int i = 0;i < 2*n;i++)\n\t\tfor(int j = 0;j < n;j++)\n\t\t\tcheck(j);\n\n\tcout << solve(t) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n\nconst int inf = 1<<29;\nint n,e,t;\nint w[301], memo[301];\nbool seen[301];\n\nvector<pair<int,vector<int> > > production;\n\nint main() {\n    ios::sync_with_stdio(false);\n    memset(seen, false, sizeof(seen));\n\n    cin>>n>>e>>t;\n    rep(i,301) memo[i] = -1;\n    rep(i,n) cin>>w[i+1];\n    rep(i,e) {\n        int g,c;\n        cin>>g>>c;\n        vector<int> v(c);\n        rep(j,c) cin>>v[j];\n        production.push_back(make_pair(g,v));\n    }\n\n    queue<int> q;\n    rep(i,n+1) if(w[i] == 1) q.push(i), memo[i] = 1;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n\n        rep(i,production.size()) {\n            if(memo[production[i].first] != -1) continue;\n            bool ok = true;\n            vector<int> &vs = production[i].second, h;\n            rep(j,vs.size()) {\n                if(memo[vs[j]] == -1) {\n                    ok = false;\n                    break;\n                }\n                h.push_back(memo[vs[j]]);\n            }\n\n            if(ok) {\n                sort(h.begin(), h.end(), greater<int>());\n                int r = 0;\n                rep(j,h.size()) r = max(r,j+h[j]);\n                memo[production[i].first] = r;\n                q.push(production[i].first);\n            }\n        }\n    }\n\n    cout<<memo[t]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,e,t;\n  cin>>n>>e>>t;\n  t--;\n  int dp[n];\n  REP(i,n) {\n    bool w;cin>>w;\n    dp[i] = w?1:INF;\n  }\n  vector<vector<int> > v[n];\n  REP(i,e) {\n    int g, c;\n    cin >>g>>c;\n    g--;\n    vector<int> tmpv;\n    REP(j,c) {\n      int s;\n      cin >> s;\n      s--;\n      tmpv.push_back(s);\n    }\n    v[g].push_back(tmpv);\n  }\n  bool update = 1;\n  while(update) {\n    update = 0;\n    REP(i,n) {\n      if (v[i].size()==0)continue;\n      FOR(it, v[i]) {\n        vector<int> tmpv;\n        FOR(jt, *it) {\n          tmpv.push_back(dp[*jt]);\n        }\n        sort(ALL(tmpv), greater<int>());\n        int tmp = 0;\n        REP(j, tmpv.size()) {\n          tmp = max(tmp, j+tmpv[j]);\n        }\n        //printf(\"i=%d tmp=%d\\n\",i,tmp);\n        if (dp[i] > tmp) {\n          update = 1;\n          dp[i] = tmp;\n        }\n      }\n    }\n  }\n  if (dp[t] == INF) cout << -1 << endl;\n  else cout << dp[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n \nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n \n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n \nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n \nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n \ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n \nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n \ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n \n \n \n/* The main code follows. */\n \nint N,E,T;\nint sar[310];\npair<int,set<int>> gen[1010];\nheap<int> ned[1010];\nvector<int> grp[310];\n \nsigned main() {\n    cin>>N>>E>>T;\n    minheap<pii> hp;\n\n    for(int i=1; i<=N; ++i) {\n        int w; cin>>w;\n        if(w) sar[i]=1,hp.emplace(1,i),sar[i]=1;\n        else sar[i]=inf<int>;\n    }\n\n    rep(i,E) {\n        int g,c; cin>>g>>c;\n        gen[i].fir=g;\n        rep(j,c) {\n            int x; cin>>x;\n            gen[i].sec.emplace(x);\n            grp[x].emplace_back(i);\n        }\n    }\n\n    while(!hp.empty()) {\n        int x,s; tie(s,x)=hp.top();\n        hp.pop();\n        if(s>sar[x]) continue;\n        for(auto &i:grp[x]) {\n            gen[i].sec.erase(x);\n            ned[i].emplace(s);\n            if(gen[i].sec.empty()) {\n                int ss=1,num=0;\n                while(!ned[i].empty()) {\n                    int t=ned[i].top();\n                    ned[i].pop();\n                    chmax(ss,t+num++);\n                }\n                if(chmin(sar[gen[i].fir],ss)) {\n                    hp.emplace(ss,gen[i].fir);\n                }\n            }\n        }\n    }\n\n    if(sar[T]>=inf<int>) esc(-1);\n    esc(sar[T]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n#define MAX_N 305\n#define MAX_E 1005\nint N,E,T;\nint W[MAX_N];\nint dp[MAX_N];\n \nvector<int> S[MAX_E];\nint G[MAX_E];\n \nvoid init(){\n  for(int i=0;i<MAX_E;i++)S[i].clear();\n}\n \nint solve(){\n  for(int i=0;i<N;i++){\n    if(W[i]==1)dp[i]=1;\n    else dp[i]=INF;\n  }\n  vector<int> vec;\n \n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<E;i++){\n \n      vec.clear();\n      for(int j=0;j<(int)S[i].size();j++){\n    int x=S[i][j];\n    vec.push_back(dp[x]);\n      }\n      sort(vec.begin(),vec.end());\n      reverse(vec.begin(),vec.end());\n \n      int cost=vec[0];\n      for(int j=1;j<(int)vec.size();j++){\n    cost=max(cost,vec[j]+j);\n      }\n \n      if(dp[G[i]]>cost){\n    dp[G[i]]=cost;\n    update=true;\n      }\n       \n    }//i\n  }//while\n \n  if(dp[T]==INF)return -1;\n  else return dp[T];\n}\n \nint main(){\n  while(cin>>N>>E>>T){\n    T--;\n    init();\n    for(int i=0;i<N;i++)cin>>W[i];\n    for(int i=0;i<E;i++){\n      int c;\n      cin>>G[i]>>c;\n      G[i]--;\n      S[i].resize(c);\n      for(int j=0;j<c;j++){\n    cin>>S[i][j];\n    S[i][j]--;\n      }\n    }\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int v,t;\n  bool operator<(S s)const{\n    return t<s.t;\n  }\n};\n\nint main(){\n  int N,E,T;\n  cin>>N>>E>>T;\n  priority_queue<S> que;\n  for(int i=1;i<=N;i++){\n    int W;\n    cin>>W;\n    if(W){\n      que.push({i,1});\n    }\n  }\n  int G[1234],C[1234],S[1234][12];\n  for(int i=0;i<E;i++){\n    cin>>G[i]>>C[i];\n    for(int j=0;j<C[i];j++){\n      cin>>S[i][j];\n    }\n  }\n  int nn[312]={};\n  while(!que.empty()){\n    auto c=que.top();\n    que.pop();\n    if(nn[c.v])continue;\n    nn[c.v]=c.t;\n    for(int i=0;i<E;i++){\n      bool u=false;\n      bool f=false;\n      vector<int> v(C[i]);\n      for(int j=0;j<C[i];j++){\n\tu|=S[i][j]==c.v;\n\tf|=!nn[S[i][j]];\n\tv[j]=nn[S[i][j]];\n      }\n      if(u&&!f){\n\tsort(begin(v),end(v));\n\tint m=0;\n\tfor(int i=0;i<v.size();i++){\n\t  m=max<int>(m,v.size()-1-i+v[i]);\n\t}\n\tque.push({G[i],m});\n      }\n    }\n  }\n  cout<<(nn[T]?nn[T]:-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint N,M,T;\nint W[303];\nint D[303];\nint G[1001];\nvector<int> S[1001];\n\nint main(){\n  cin>>N>>M>>T;\n  T--;\n  rep(i,N)cin>>W[i];\n  rep(i,M){\n    cin>>G[i];\n    G[i]--;\n    int k;\n    cin>>k;\n    while(k--){\n      int s;\n      cin>>s;\n      s--;\n      S[i].push_back(s);\n    }\n  }\n  rep(i,N){\n    if(W[i])D[i]=1;\n    else D[i]=INF;\n  }\n  rep(i,N){\n    rep(j,M){\n      vector<int> ss=S[j];\n      sort(all(ss),[=](const int& a,const int& b){return D[a] > D[b];});\n      int d=0;\n      rep(k,ss.size()){\n        maxch(d,k+D[ss[k]]);\n      }\n      minch(D[G[j]],d);\n    }\n  }\n  if(D[T]==INF)cout<<-1<<endl;\n  else cout<<D[T]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF = 100000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int n,e,t;\n\tstatic int w[302];\n\tstatic int g[1002],c[1002];\n\tstatic int s[1002][12];\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\trep1(i,n)scanf(\"%d\",&w[i]);\n\trep(i,e){\n\t\tscanf(\"%d%d\",&g[i],&c[i]);\n\t\trep(j,c[i]){\n\t\t\tscanf(\"%d\",&s[i][j]);\n\t\t}\n\t}\n\trep1(i,n){\n\t\tif(w[i] == 0)w[i] = INF;\n\t}\n\t\n\tbool updata = true;\n\twhile(updata){\n\t\tupdata = false;\n\t\trep(i,e){\n\t\t\tvector<int> vec;\n\t\t\trep(j,c[i])vec.pb(w[s[i][j]]);\n\t\t\tsor(vec); rev(vec);\n\t\t\tint ret = 0;\n\t\t\trep(j,vec.size())ret = max ( ret , vec[j] + j );\n\t\t\tif(w[g[i]] > ret){\n\t\t\t\tw[g[i]] = ret;\n\t\t\t\tupdata = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(w[t] == INF)puts(\"-1\");\n\telse printf(\"%d\\n\",w[t]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, E, T;\nvector<int> W;\nvector<int> G;\nvector<int> S[1000];\nint memo[300];\nint dfs(int K, vector<bool> used){\n  if(memo[K] != -1 && memo[K] < INF) return memo[K];\n  if(W[K]) return 1;\n  int res = INF;\n  used[K] = true;\n  REP(i, E) if(G[i] == K){\n    vector<int> need;\n    REP(j, S[i].size()) {\n      if(used[S[i][j]]) need.push_back(INF);\n      else need.push_back(dfs(S[i][j], used));\n    }\n    sort(need.begin(), need.end());\n    reverse(need.begin(), need.end());\n    int ans = 0;\n    REP(i, need.size()) ans = max(ans, need[i] + i);\n    res = min(res, ans);\n  }\n  return memo[K] = res;\n}\nint main(){\n  while(cin >> N >> E >> T){\n    T--;\n    W.assign(N, 0);\n    REP(i, N) cin >> W[i];\n    G.assign(E, 0);\n    REP(i, E){\n      cin >> G[i]; G[i]--;\n      int C; cin >> C;\n      S[i].assign(C, 0);\n      REP(j, C) cin >> S[i][j];\n      REP(j, C) S[i][j] --;\n    }\n    vector<bool> used(N, false);\n    memset(memo, -1, sizeof memo);\n    int ans = dfs(T, used);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dfs(const vector<vector<vector<int>>>& g,int u,vector<int>& memo)\n{\n\tif(memo[u]) return memo[u];\n\tmemo[u]=-1;\n\t\n\tfor(auto rule:g[u]){\n\t\tvector<int> tmp;\n\t\tfor(int v:rule) tmp.push_back(dfs(g,v,memo));\n\t\tif(count(begin(tmp),end(tmp),-1)) continue;\n\t\tsort(begin(tmp),end(tmp),greater<int>());\n\t\tint value=0;\n\t\tfor(int i=0;i<tmp.size();i++)\n\t\t\tvalue=max(value,i+tmp[i]);\n\t\tif(memo[u]==-1 || memo[u]>value)\n\t\t\tmemo[u]=value;\n\t}\n\treturn memo[u];\n}\n\nint main()\n{\n\tfor(int n,e,t;cin>>n>>e>>t && n|e|t;){\n\t\tt--;\n\t\tvector<int> ob(n); // obtainable or not\n\t\tfor(int& x:ob) cin>>x;\n\t\tvector<vector<vector<int>>> g(n);\n\t\tfor(int i=0;i<e;i++){\n\t\t\tint u,m; cin>>u>>m; u--;\n\t\t\tvector<int> tmp;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tint v; cin>>v; v--;\n\t\t\t\ttmp.push_back(v);\n\t\t\t}\n\t\t\tg[u].push_back(tmp);\n\t\t}\n\t\t\n\t\tvector<int> memo(n);\n\t\tfor(int i=0;i<n;i++) if(ob[i]) memo[i]=1;\n\t\tcout<<dfs(g,t,memo)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int v,t;\n  bool operator<(S s)const{\n    return t<s.t;\n  }\n};\n\nint main(){\n  int N,E,T;\n  cin>>N>>E>>T;\n  priority_queue<S> que;\n  for(int i=1;i<=N;i++){\n    int W;\n    cin>>W;\n    if(W){\n      que.push({i,1});\n    }\n  }\n  int G[1234],C[1234],S[1234][12];\n  for(int i=0;i<E;i++){\n    cin>>G[i]>>C[i];\n    for(int j=0;j<C[i];j++){\n      cin>>S[i][j];\n    }\n  }\n  int nn[312]={};\n  while(!que.empty()){\n    auto c=que.top();\n    que.pop();\n    if(nn[c.v])continue;\n    nn[c.v]=c.t;\n    for(int i=0;i<E;i++){\n      bool u=false;\n      bool f=false;\n      vector<int> v(C[i]);\n      for(int j=0;j<C[i];j++){\n\tu|=S[i][j]==c.v;\n\tf|=!nn[S[i][j]];\n\tv[j]=nn[S[i][j]];\n      }\n      if(u&&!f){\n\tsort(begin(v),end(v));\n\tint m=0;\n\tfor(int k=0;k<v.size();k++){\n\t  m=max<int>(m,v.size()-1-k+v[k]);\n\t}\n\tque.push({G[i],m});\n      }\n    }\n  }\n  cout<<(nn[T]?nn[T]:-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> cost;\nvector<vector<vector<int>>> g;\n\nvoid calcost(int ind,set<int> &nowuse){\n    if(nowuse.find(ind)!=nowuse.end())return;\n    nowuse.insert(ind);\n    for(auto ng:g[ind]){\n        vector<int> d;\n        for(auto tg:ng){\n            if(cost[tg]==-1)calcost(tg,nowuse);\n            d.emplace_back(cost[tg]);\n        }\n        sort(d.rbegin(),d.rend());\n        int ans=0;\n        for (int i = 0; i < d.size(); ++i) {\n            if(d[i]==-1){\n                ans=-1;\n                break;\n            }\n            ans=max(ans,i+d[i]);\n        }\n        if(cost[ind]==-1)cost[ind]=ans;\n        else cost[ind]=min(cost[ind],ans);\n    }\n}\n\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    --t;\n    cost.assign(n,-1);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin>>a;\n        if(a==1){\n            cost[i]=1;\n            if(i==t){\n                cout<<1<<endl;\n                return 0;\n            }\n        }\n    }\n    g.resize(n);\n    for (int i = 0; i < e; ++i) {\n        int gn,cn;\n        cin>>gn>>cn;\n        --gn;\n        vector<int> t(cn);\n        for (int j = 0; j < cn; ++j) {\n            cin>>t[j];\n            --t[j];\n        }\n        g[gn].push_back(t);\n    }\n    for (int i = 0; i < n; ++i) {\n        if(cost[i]!=-1)continue;\n        set<int> ts;\n        calcost(i,ts);\n    }\n    cout<<cost[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> cost;\nvector<vector<vector<int>>> g;\n\nvoid calcost(int ind,set<int> nowuse){\n    if(nowuse.find(ind)!=nowuse.end())return;\n    nowuse.insert(ind);\n    for(auto ng:g[ind]){\n        vector<int> d;\n        for(auto tg:ng){\n            if(cost[tg]==-1)calcost(tg,nowuse);\n            d.emplace_back(cost[tg]);\n        }\n        sort(d.rbegin(),d.rend());\n        int ans=0;\n        for (int i = 0; i < d.size(); ++i) {\n            if(d[i]==-1){\n                ans=-1;\n                break;\n            }\n            ans=max(ans,i+d[i]);\n        }\n        if(cost[ind]==-1)cost[ind]=ans;\n        else cost[ind]=min(cost[ind],ans);\n    }\n}\n\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    --t;\n    cost.assign(n,-1);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin>>a;\n        if(a==1){\n            cost[i]=1;\n            if(i==t){\n                cout<<1<<endl;\n                return 0;\n            }\n        }\n    }\n    g.resize(n);\n    for (int i = 0; i < e; ++i) {\n        int gn,cn;\n        cin>>gn>>cn;\n        --gn;\n        vector<int> t(cn);\n        for (int j = 0; j < cn; ++j) {\n            cin>>t[j];\n            --t[j];\n        }\n        g[gn].push_back(t);\n    }\n    for (int i = 0; i < n; ++i) {\n        if(cost[i]!=-1)continue;\n        set<int> ts;\n        calcost(i,ts);\n    }\n    cout<<cost[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\n#define INF 1000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n, e, t;\nint w[300];\nint cost[300];\nvector<vector<int> > need[300];\nvector<int> huga;\n\nint main(){\n    cin >> n >> e >> t;\n    t--;\n    rep(i,n) cost[i] = INF;\n    rep(i,n){\n        cin >> w[i];\n        if(w[i]) cost[i] = 1;\n    }\n    rep(i,e){\n        int g, c;\n        cin >> g >> c;\n        g--;\n        vector<int> hoge;\n        rep(j,c){\n            int tmp;\n            cin >> tmp;\n            tmp--;\n            hoge.push_back(tmp);\n        }\n        need[g].push_back(hoge);\n    }\n    while(true){\n        int val = INF;\n        int id = 0;\n        rep(i,n){\n            rep(u,need[i].size()){\n                if(cost[i] != INF) continue;\n                int cnt = 0;\n                int ss = 0, ee = 10000000, mid;\n                huga.clear();\n                rep(j,need[i][u].size()){\n                    huga.push_back(cost[need[i][u][j]]);\n                }\n                sort(huga.begin(),huga.end(),greater<int>());\n                while(ee-ss > 1){\n                    mid = (ss+ee)/2;\n                    int tmp = mid;\n                    rep(j,huga.size()){\n                        if(tmp < huga[j]){\n                            tmp = -1;\n                            break;\n                        }\n                        tmp--;\n                    }\n                    if(tmp >= 0){\n                        ee = mid;\n                    } else{\n                        ss = mid;\n                    }\n                }\n                if(val > ee){\n                    val = ee;\n                    id = i;\n                }\n            }\n        }\n        if(val == INF) break;\n        cost[id] = val;\n    }\n    if(cost[t] == INF) cost[t] = -1;\n    cout << cost[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t, g[1000], dp[300];\nbool ok[300];\nvi s[1000];\n\nint main(){\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint k, a;\n\t\tcin >> g[i] >> k; g[i]--;\n\t\trep(j, k) cin >> a, s[i].pb(a - 1);\n\t}\n\trep(i, n) dp[i] = ok[i] ? 1 : inf;\n\trep(it, n) rep(i, e){\n\t\tint dp2[300], res = 0;\n\t\trep(j, s[i].size()) dp2[j] = dp[s[i][j]];\n\t\tsort(dp2, dp2 + s[i].size(), greater<int>());\n\t\trep(j, s[i].size()) res = max(res, j + dp2[j]);\n\t\tdp[g[i]] = min(dp[g[i]], res);\n\t}\n\tcout << (dp[t - 1] >= inf ? -1 : dp[t - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> cost;\nvector<vector<vector<int>>> g;\n\nvoid calcost(int ind){\n    for(auto ng:g[ind]){\n        vector<int> d;\n        for(auto tg:ng){\n            if(cost[tg]==-1)calcost(tg);\n            if(cost[tg]==-1){\n                cost[ind]=-1;\n                return;\n            }\n            d.emplace_back(cost[tg]);\n        }\n        sort(d.rbegin(),d.rend());\n        int ans=0;\n        for (int i = 0; i < d.size(); ++i) {\n            ans=max(ans,i+d[i]);\n        }\n        if(cost[ind]==-1)cost[ind]=ans;\n        else cost[ind]=min(cost[ind],ans);\n    }\n}\n\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    --t;\n    cost.assign(n,-1);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin>>a;\n        if(a==1){\n            cost[i]=1;\n            if(i==t){\n                cout<<1<<endl;\n                return 0;\n            }\n        }\n    }\n    g.resize(n);\n    for (int i = 0; i < e; ++i) {\n        int gn,cn;\n        cin>>gn>>cn;\n        --gn;\n        vector<int> t(cn);\n        for (int j = 0; j < cn; ++j) {\n            cin>>t[j];\n            --t[j];\n        }\n        g[gn].push_back(t);\n    }\n    for (int i = 0; i < n; ++i) {\n        if(cost[i]!=-1)continue;\n        calcost(i);\n    }\n    cout<<cost[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N, E, T;\nvint W, G, C;\nvector<vint> S;\nvint minseed;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> E >> T; T--;\n\n  resz(W, N);\n  rep(i, N) cin >> W[i];\n\n  resz(G, E);\n  resz(C, E);\n  resz(S, E);\n  rep(i, E) {\n    cin >> G[i] >> C[i]; G[i]--;\n    resz(S[i], C[i]);\n    rep(j, C[i]) {\n      cin >> S[i][j]; S[i][j]--;\n    }\n  }\n\n  resz(minseed, N, inf);\n  rep(i, N) if(W[i]) minseed[i] = 1;\n\n  rep(i, N) {\n    rep(j, E) {\n      vint seed;\n      rep(k, C[j]) seed.push_back(minseed[S[j][k]]);\n      sort(all(seed)); reverse(all(seed));\n      int needseed = C[j];\n      rep(k, C[j]) chmax(needseed, seed[k]+k);\n      chmin(minseed[G[j]], needseed);\n    }\n  }\n\n  cout << (minseed[T] == inf ? -1 : minseed[T]) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\ntemplate <typename T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint dist[300];\nbool visited[300];\npriority_queue<i_i, vector<i_i>, greater<i_i>> que;\nint N, E, T;\nint W[300];\nint G[1000];\nint C[1000];\nint S[1000][10];\nvector<int> State[1000];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> E >> T;\n    T--;\n    for(int i = 0; i < N; i++) {\n        dist[i] = 1e9;\n    }\n    for(int i = 0; i < N; i++) {\n        cin >> W[i];\n        if(W[i] == 1) {\n            dist[i] = 1;\n            que.push({1, i});\n        }\n    }\n    for(int i = 0; i < E; i++) {\n        cin >> G[i];\n        G[i]--;\n        cin >> C[i];\n        for(int j = 0; j < C[i]; j++) {\n            cin >> S[i][j];\n            S[i][j]--;\n        }\n    }\n    while(!que.empty()) {\n        i_i tmp = que.top();\n        que.pop();\n        int now = tmp.second;\n        int cost = tmp.first;\n        if(visited[now]) continue;\n        visited[now] = true;\n        //cerr << now << \" \" << cost << endl;\n        for(int i = 0; i < E; i++) {\n            for(int j = 0; j < C[i]; j++) {\n                if(S[i][j] == now) {\n                    //cerr << \"push: \" << now << \" to \" << i << endl;\n                    State[i].push_back(cost);\n                }\n            }\n            if(State[i].size() == C[i]) {\n                //cerr << \"complete: \" << i << endl;\n                sort(State[i].begin(), State[i].end());\n                int ans = 0;\n                for(int j = 0; j < State[i].size(); j++) {\n                    chmax(ans, (int)State[i].size() - 1 - j + State[i][j]);\n                }\n                if(chmin(dist[G[i]], ans)) {\n                    que.push({ans, G[i]});\n                }\n            }\n        }\n    }\n    if(dist[T] == 1e9) dist[T] = -1;\n    cout << dist[T] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\n\nint main()\n{\n  int N, E, T, W[300];\n  vector< vector< int > > g[300];\n\n  cin >> N >> E >> T;\n  --T;\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  for(int i = 0; i < E; i++) {\n    int G, C;\n    cin >> G >> C;\n    --G;\n    vector< int > vv;\n    for(int j = 0; j < C; j++) {\n      int S;\n      cin >> S;\n      --S;\n      vv.push_back(S);\n    }\n    g[G].push_back(vv);\n  }\n\n  int dp[300];\n  fill_n(dp, 300, INF);\n  for(int k = 0; k < N; k++) if(W[k] == 1) dp[k] = 0;\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      for(auto &k : g[j]) {\n        int all = 0;\n        bool beet = true;\n        for(auto &l : k) {\n          if(dp[l] == INF) beet = false;\n        }\n        if(!beet) continue;\n        vector< int > vs;\n        for(auto &l : k) {\n          vs.push_back(dp[l]);\n        }\n        sort(vs.rbegin(), vs.rend());\n        for(int l = 0; l < vs.size(); l++) {\n          all = max(all, vs[l] + l);\n        }\n        dp[j] = min(dp[j], all);\n      }\n    }\n  }\n\n  if(dp[T] == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[T] + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1e9;\n\nint main(){\n  int N, E, T;\n  cin >> N >> E >> T;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector<int> G(E), C(E);\n  vector<vector<int>> S(E);\n  for(int i = 0; i < E; ++i){\n    cin >> G[i] >> C[i];\n    --G[i];\n    for(int j = 0; j < C[i]; ++j){\n      int s;\n      cin >> s;\n      S[i].push_back(s-1);\n    }\n  }\n\n  for(int i = 0; i < N; ++i)\n    if(not W[i])\n      W[i] = 1e9;\n  \n  vector<bool> checked(E,false);\n  int c = 0;\n  for(int i = 0; i < E; ++i){\n    int c_ = c;\n    for(int j = 0; j < E; ++j){\n      if(checked[j]) continue;\n      bool f = true;\n      for(int k = 0; k < C[j]; ++k)\n        if(W[S[j][k]] >= INF){\n          f = false;\n          break;\n        }\n      if(not f) continue;\n      vector<int> T;\n      for(int k = 0; k < C[j]; ++k){\n        T.push_back(W[S[j][k]]);\n      }\n      int t = 0;\n      sort(T.rbegin(),T.rend());\n      for(int k = 0; k < C[j]; ++k)\n        t = max(t,k+T[k]);\n      W[G[j]] = min(W[G[j]],t);\n      ++c_;\n      checked[j] = true;\n    }\n    if(c == c_) break;\n    c = c_;\n    if(c == E) break;\n  }\n  if (W[T-1] >= INF) {\n    cout << -1 << endl;\n  } else {\n    cout << W[T-1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 10000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,e,t;\nint dp[301];\nint g[1001],c[1001],s[1001][1001];\nint cost[11];\nint main(void){\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\tt--;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&dp[i]);\n\t\tif(dp[i]==0){\n\t\t\tdp[i]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<e;i++){\n\t\tscanf(\"%d%d\",&g[i],&c[i]);\n\t\tg[i]--;\n\t\tfor(int j=0;j<c[i];j++){\n\t\t\tscanf(\"%d\",&s[i][j]);\n\t\t\ts[i][j]--;\n\t\t}\n\t}\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<e;i++){\n\t\t\tfor(int j=0;j<c[i];j++){\n\t\t\t\tcost[j]=dp[s[i][j]];\n\t\t\t}\n\t\t\tsort(cost,cost+c[i]);\n\t\t\tint maxi=0;\n\t\t\tfor(int j=0;j<c[i];j++){\n\t\t\t\tmaxi=max(maxi,cost[c[i]-j-1]+j);\t\t\t\t\n\t\t\t}\n\t\t\tif(dp[g[i]]>maxi){\n\t\t\t\tdp[g[i]]=maxi;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[t]==INF?-1:dp[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,vector<int> > P;\nconst int MAX_N = 301;\nconst int INF = 1e+8; \n// 入力\nint N, E, T, W[MAX_N];\n\n// dp[k] := 魔女 k をつくるのに必要な最小のグリーグシードの数(つくれないときはINF)\nint dp[MAX_N];\n// G[k][i] := 魔女 k を生成する規則 i を返す.\nvector< vector<int> > G[MAX_N];\n// memo[k] \nint memo[MAX_N];\n\nvoid solve(int k){\n\tmemo[k] = 1;\n\tif( dp[k] == 1 ) return;\n\t\n\tfor(int i=0 ; i < G[k].size() ; i++ ){\n\t\tint m = INF;\n\t\tfor(int j=0 ; j < G[k][i].size() ; j++ ){\n\t\t\tint x = G[k][i][j];\n\t\t\tif( dp[x] == INF && memo[x] == 0 ){\n\t\t\t\tsolve(x);\n\t\t\t}\n\t\t\tm = min( m , dp[x] );\n\t\t}\n\t\tdp[k] = min( dp[k] , m + (int)G[k][i].size() - 1 );\n\t}\n}\n\nint main(){\n\tcin >> N >> E >> T;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tcin >> W[i];\n\t}\n\tfor(int i=0 ; i < E ; i++ ){\n\t\tint g, c, s;\n\t\tcin >> g >> c;\n\t\tvector<int> v;\n\t\tfor(int j=0 ; j < c ; j++ ){\n\t\t\tcin >> s;\n\t\t\tv.push_back(s);\n\t\t}\n\t\tG[g].push_back(v);\n\t}\n\t\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tmemo[i+1] = 0;\n\t\tdp[i+1] = (W[i] == 1)? 1 : INF ;\n\t}\n\tfor(int i=1 ; i <= N ; i++ ){\n\t\tvector<P> v;\n\t\tfor(int j=0 ; j < G[i].size() ; j++ ){\n\t\t\tv.push_back( P(G[i][j].size(),G[i][j]) );\n\t\t}\n\t\tsort( v.rbegin(), v.rend() );\n\t\tvector< vector<int> > v_;\n\t\tfor(int j=0 ; j < v.size() ; j++ ){\n\t\t\tv_.push_back( v[j].second );\n\t\t}\n\t\tG[i] = v_;\n\t}\n\tsolve(T);\n\t\n\tif( dp[T] == INF ) dp[T] = -1;\n\tcout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 330;\nint dist[MN];\nint main() {\n    int n, e, t;\n    cin >> n >> e >> t; t--;\n    fill_n(dist, MN, 100000);\n    for (int i = 0; i < n; i++) {\n        int w;\n        cin >> w;\n        if (w == 1) {\n            dist[i] = 1;\n        }\n    }\n    vector<pair<int, vector<int>>> ed;\n    for (int i = 0; i < e; i++) {\n        int g;\n        cin >> g; g--;\n        int c;\n        cin >> c;\n        vector<int> v;\n        for (int j = 0; j < c; j++) {\n            int d;\n            cin >> d; d--;\n            v.push_back(d);\n        }\n        ed.push_back(pair<int, vector<int>>(g, v));\n    }\n    for (int i = 0; i < n; i++) {\n        for (auto &p: ed) {\n            auto &v = p.second;\n            vector<int> u;\n            for (int d: v) {\n                u.push_back(dist[d]);\n            }\n            sort(u.begin(), u.end(), greater<int>());\n            int res = 0;\n            for (int j = 0; j < (int)u.size(); j++) {\n                res = max(res, u[j]+j);\n            }\n            dist[p.first] = min(dist[p.first], res);\n        }\n    }\n    if (dist[t] == 100000) dist[t] = -1;\n    cout << dist[t] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 300;\nconst int INF = 1 << 29;\n\nint n, m, goal, memo[N];\nvector<vector<int> > mixv[N];\nbool w[N], f[N];\n\nint func(int pos){\n  int res = INF;\n\n  if(w[pos]) return 1;\n  if(memo[pos] != -1) return memo[pos];\n  if(f[pos] || mixv[pos].size() == 0) return INF;\n  \n  for(int i=0;i<mixv[pos].size();i++){\n    int max_next = -1, max_next_num = 1;\n    f[pos] = true;\n    for(int j=0;j<mixv[pos][i].size();j++){\n      int next = func(mixv[pos][i][j]);\n      if(next >= INF){\n        max_next;\n        break;\n      }\n      if(max_next < next){\n        max_next = next;\n        max_next_num = 1;\n      } else if(max_next == next) max_next_num++;\n    }\n    f[pos] = false;\n    res = min(res, max((int)mixv[pos][i].size(), max_next + max_next_num - 1));\n  }\n\n  return memo[pos] = res;\n}\n\nint solve(){\n  int res;\n  fill(f, f+n, false);\n  fill(memo, memo+n, -1);\n  res = func(goal);\n  return res >= INF ? -1 : res;\n}\n\nint main(){\n  int a, b, c;\n  while(cin >> n >> m >> goal){\n    goal--;\n    for(int i=0;i<n;i++) {\n      cin >> w[i];\n      mixv[i].clear();\n    }\n    for(int i=0;i<m;i++){\n      vector<int> v;\n      cin >> a >> b;\n      for(int j=0;j<b;j++){\n        cin >> c;\n        v.push_back(c-1);\n      }\n      mixv[a-1].push_back(v);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint N, E, T;\nvector<int> W;\nvector<int> G;\nvector<vector<int> > S;\n\nint main() {\n  cin >> N >> E >> T;\n  W.resize(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  for(int i = 0; i < N; ++i) if(W[i] == 0) W[i] = INF;\n  S.resize(E);\n  G.resize(E);\n  for(int i = 0; i < E; ++i) {\n    int C;\n    cin >> G[i] >> C;\n    G[i] -= 1;\n    S[i].resize(C);\n    for(int j = 0; j < C; ++j) {\n      cin >> S[i][j];\n      S[i][j] -= 1;\n    }\n  }\n\n  bool update = true;\n  while(update) {\n    update = false;\n    for(int i = 0; i < E; ++i) {\n      int maxi = S[i].size();\n      vector<int> v;\n      for(int j = 0; j < S[i].size(); ++j) v.push_back(W[S[i][j]]);\n      sort(v.begin(), v.end(), greater<int>());\n      for(int j = 0; j < v.size(); ++j) {\n\tmaxi = max(maxi, v[j] + j);\n      }\n      if(W[G[i]] > maxi) {\n\tupdate = true;\n\tW[G[i]] = maxi;\n      }\n    }\n  }\n  if(W[T-1] == INF) cout << -1 << endl;\n  else cout << W[T-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 300;\nconst int INF = 1 << 29;\n\nint n, m, goal, memo[N];\nvector<vector<int> > mixv[N];\nbool w[N], f[N];\n\nint func(int pos){\n  int res = INF;\n\n  if(w[pos]) return 1;\n  if(memo[pos] != -1) return memo[pos];\n  if(f[pos] || mixv[pos].size() == 0) return INF;\n  \n  for(int i=0;i<mixv[pos].size();i++){\n    int max_next = 0, res_max_next = 0;\n    vector<int> nextv;\n    f[pos] = true;\n    for(int j=0;j<mixv[pos][i].size();j++){\n      int next = func(mixv[pos][i][j]);\n      if(next >= INF){\n        max_next = INF;\n        break;\n      }\n      nextv.push_back(next);\n    }    \n    f[pos] = false;\n    if(max_next == INF) continue;\n\n    sort(nextv.begin(), nextv.end());\n    res_max_next = max_next = nextv[nextv.size()-1];\n    for(int j=nextv.size()-1;j>0;j--){\n      if(nextv[j] == nextv[j-1]) {\n        max_next++;\n        res_max_next = max(res_max_next, max_next);\n      } else {\n        //cout << nextv[j] << ' ' << nextv[j-1] << endl;\n        max_next = max(0, max_next - (nextv[j] - nextv[j-1] - 1));\n      }\n    }\n    //max_next = max(max_next, nextv[nextv.size()-1]);\n    res = min(res, res_max_next);\n  }\n\n  return memo[pos] = res;\n}\n\nint solve(){\n  int res;\n  fill(f, f+n, false);\n  fill(memo, memo+n, -1);\n  res = func(goal);\n  return res >= INF ? -1 : res;\n}\n\nint main(){\n  int a, b, c;\n  while(cin >> n >> m >> goal){\n    goal--;\n    for(int i=0;i<n;i++) {\n      cin >> w[i];\n      mixv[i].clear();\n    }\n    for(int i=0;i<m;i++){\n      vector<int> v;\n      cin >> a >> b;\n      for(int j=0;j<b;j++){\n        cin >> c;\n        v.push_back(c-1);\n      }\n      mixv[a-1].push_back(v);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint N, E, T;\nvector<int> W;\nvector<int> G;\nvector<vector<int> > S;\n\nint main() {\n  cin >> N >> E >> T;\n  W.resize(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  for(int i = 0; i < N; ++i) if(W[i] == 0) W[i] = INF;\n  S.resize(E);\n  G.resize(E);\n  for(int i = 0; i < E; ++i) {\n    int C;\n    cin >> G[i] >> C;\n    G[i] -= 1;\n    S[i].resize(C);\n    for(int j = 0; j < C; ++j) {\n      cin >> S[i][j];\n      S[i][j] -= 1;\n    }\n  }\n\n  bool update = true;\n  while(update) {\n    update = false;\n    for(int i = 0; i < E; ++i) {\n      int maxi = S[i].size();\n      vector<int> v;\n      for(int j = 0; j < S[i].size(); ++j) {\n\tv.push_back(W[S[i][j]]);\n      }\n      sort(v.begin(), v.end(), greater<int>());\n      for(int j = 0; j < v.size(); ++j) {\n\tmaxi = max(maxi, W[S[i][j]] + j);\n      }\n      if(W[G[i]] > maxi) {\n\tupdate = true;\n\tW[G[i]] = maxi;\n      }\n    }\n  }\n  if(W[T-1] == INF) cout << -1 << endl;\n  else cout << W[T-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, e, t; cin >> n >> e >> t; t--;\n    vll ret(n, INF);\n    rep(i, n) {\n        ll tmp; cin >> tmp;\n        if (tmp)\n            ret[i] = 1;\n    }\n\n    vvll lows(e);\n    vll lows_target(e);\n    vvll observer(n);\n    rep(i, e) {\n        ll target; cin >> target; target--;\n        ll material_num; cin >> material_num;\n        vll tmp(material_num);\n        rep(j, material_num) {\n            cin >> tmp[j]; tmp[j]--;\n            observer[tmp[j]].pb(i);\n        }\n        lows[i] = tmp;\n        lows_target[i] = target;\n    }\n\n    queue<ll> notification; \n    rep(i, n) if (ret[i] == 1) notification.push(i);\n\n    while (!notification.empty()) {\n        ll updated = notification.front(); notification.pop();\n        for (auto low_index : observer[updated]) {\n            ll target = lows_target[low_index];\n            vll& low = lows[low_index];\n            vll materials_cost;\n            ll m = 0;\n            for (auto material : low) {\n                if (ret[material] == INF) goto skip;\n                materials_cost.pb(ret[material]);\n            }\n            sort(all(materials_cost), greater<ll>());\n            rep(i, materials_cost.size()) {\n                chmax(m, i + materials_cost[i]);\n            }\n\n            if (ret[target] > m) {\n                ret[target] = m;\n                notification.push(target);\n            }\n            skip:;\n        }\n    }\n\n    if (ret[t] != INF) {\n        cout << ret[t] << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\nconst long double epsA=1e-4;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint n,e,t,i,j;cin>>n>>e>>t;t--;\n\tvector<int>cost(n,mod);\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>que;\n\tfor(i=0;i<n;i++){\n\t\tint w;cin>>w;\n\t\tif(w==1){que.push(mp(1,i));}\n\t}\n\tvector<pair<int,vector<int>>>rule(e);\n\tvector<int>zi(e);\n\tvector<vector<int>>gya(n);\n\tfor(i=0;i<e;i++){\n\t\tint g,c;cin>>g>>c;g--;\n\t\trule[i].fir=g;\n\t\tzi[i]=c;\n\t\twhile(c--){\n\t\t\tint s;cin>>s;s--;\n\t\t\tgya[s].pub(i);\n\t\t\trule[i].sec.pub(s);\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tint c,ter;tie(c,ter)=que.top();que.pop();\n\t\tif(ter==t){cout<<c<<endl;return 0;}\n\t\tif(!mineq(cost[ter],c)){continue;}\n\t\tfor(auto it:gya[ter]){\n\t\t\tzi[it]--;\n\t\t\tif(zi[it]==0){\n\t\t\t\t//コスト計算\n\t\t\t\tint r=rule[it].sec.size();\n\t\t\t\tvector<int>aaa(r);\n\t\t\t\tfor(j=0;j<r;j++){aaa[j]=cost[rule[it].sec[j]];}\n\t\t\t\tSO(aaa);REV(aaa);\n\t\t\t\tfor(j=0;j<r;j++){aaa[j]+=j;}\n\t\t\t\tint sor=0;\n\t\t\t\tfor(j=0;j<r;j++){maxeq(sor,aaa[j]);}\n\t\t\t\tque.push(mp(sor,rule[it].fir));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nvvi G[MAX_N];\nint memo[MAX_N];\n\nint dfs(int nw,vector<bool>& flag){\n    if(flag[nw]) return -1;\n    flag[nw] = true;\n    if(memo[nw]){\n        flag[nw] = false;\n        return memo[nw];\n    }\n    int mn = INF;\n    rep(i,len(G[nw])){\n        bool ok = true;\n        vi kekka;\n        int sz = len(G[nw][i]);\n        rep(j,sz){\n            int res = dfs(G[nw][i][j],flag);\n            if(res < 0){\n                ok = false;\n                break;\n            }\n            kekka.pb(res);\n        }\n        if(ok){\n            int val = sz;\n            sort(all(kekka));\n            rep(j,len(kekka)){\n                cmx(val,kekka[j]+sz-1-j);\n            }\n            cmn(mn,val);\n        }\n    }\n    if(mn == INF){\n        memo[nw] = -1;\n    }else{\n        memo[nw] = mn;\n    }\n    flag[nw] = false;\n    return memo[nw];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    vi w(n);\n    rep(i,n){\n        cin >> w[i];\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        G[a-1].pb(hoge);\n    }\n    rep(i,n){\n        if(w[i]) memo[i] = 1;\n    }\n    vector<bool> flag(n,false);\n    cout << dfs(t,flag) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint dp[301];\nint to[1001];\nvector<int> from[1001];\n\nconst int INF=1000000000;\nint main(){\n  int n,e,t;\n  while(cin>>n>>e>>t&&(n|e|t)){\n    for(int i=0;i<1001;i++)from[i].clear();\n    for(int i=1;i<=n;i++){\n      cin>>dp[i];\n      if(dp[i]==0)dp[i]=INF;\n    }\n    for(int i=0;i<e;i++){\n      int g,c;\n      cin>>g>>c;\n      to[i]=g;\n      for(int j=0;j<c;j++){\n\tint s;\n\tcin>>s;\n\tfrom[i].push_back(s);\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<e;j++){\n\tint d[11];\n\t// cost of moving before\n\tfor(int k=0;k<from[j].size();k++)\n\t  d[k]=dp[from[j][k]];\n\t// sort with ordering acending\n\tsort(d,d+(int)from[j].size(),greater<int>());\n\tint maxc=0;\n\tfor(int k=0;k<from[j].size();k++)\n\t  maxc=max(maxc,k+d[k]);\n\tdp[to[j]]=min(dp[to[j]],maxc);\t\n      }\n    }\n    if(dp[t]==INF)cout<<-1<<endl;\n    else cout<<dp[t]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int, int> P;\n#define REP(i, x, n) for(int i = x ; i < n ; ++i)\n#define rep(i, n) for(int i = 0 ; i < n ; ++i)\n#define repr(i, n) for(int i = n - 1 ; i >= 0 ; --i)\n#define ALL(x) (x).begin(), (x).end()\n#define SORT(x) sort((x).begin(), (x).end())\n\nconst int IINF = 1e9 + 10;\nconst long long LLINF = (long long)1e18 + 10;\nconst long long MOD = (long long)1e9 + 7;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nint n, e, t;\nvector<int> w;\nvector< vector< vector<int> > > graph;\nint memo[305];\n\nint solve(int k, int depth){\n    if(depth > e){\n        return IINF;\n    }\n    if(memo[k] >= 0){\n        return memo[k];\n    }\n    int res = IINF;\n    for(auto x : graph[k]){\n        vector<int> tmp;\n        for(auto y : x){\n            tmp.push_back(solve(y, depth + 1));\n        }\n        SORT(tmp);\n        if(tmp.back() == IINF){\n            continue;\n        }\n        int cnt = tmp.back(), cap = tmp.back() - 1;\n        for(int i = (int)tmp.size() - 2 ; i >= 0 ; --i){\n            if(tmp[i] - cap > 0){\n                cnt += tmp[i] - cap;\n                cap += tmp[i] - cap;\n            }\n            --cap;\n        }\n        cnt = max(cnt, (int)tmp.size());\n        res = min(res, cnt);\n    }\n    return memo[k] = res;\n}\n\nint main(){\n    cin >> n >> e >> t;\n    fill(memo, memo + n, -1);\n    --t;\n    w.resize(n);\n    rep(i, n){\n        cin >> w[i];\n        if(w[i] == 1){\n            memo[i] = 1;\n        }\n    }\n    graph.resize(n);\n    rep(i, e){\n        int g, c;\n        cin >> g >> c;\n        --g;\n        vector<int> s(c);\n        rep(j, c){\n            cin >> s[j];\n            --s[j];\n        }\n        graph[g].push_back(s);\n    }\n    int ans = solve(t, 0);\n    if(ans < IINF){\n        cout << ans << endl;\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> cost;\nvector<vector<vector<int>>> g;\n\nvoid calcost(int ind){\n    vector<int> d;\n    for(auto ng:g[ind]){\n        d.clear();\n        for(auto tg:ng){\n            if(cost[tg]==-1)calcost(tg);\n            if(cost[tg]==-1){\n                cost[ind]=-1;\n                return;\n            }\n            d.emplace_back(cost[tg]);\n        }\n        sort(d.rbegin(),d.rend());\n        int ans=0;\n        for (int i = 0; i < d.size(); ++i) {\n            ans=max(ans,i+d[i]);\n        }\n        if(cost[ind]==-1)cost[ind]=ans;\n        else cost[ind]=min(cost[ind],ans);\n    }\n}\n\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    --t;\n    cost.assign(n,-1);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin>>a;\n        if(a==1){\n            cost[i]=1;\n            if(i==t){\n                cout<<1<<endl;\n                return 0;\n            }\n        }\n    }\n    g.resize(n);\n    for (int i = 0; i < e; ++i) {\n        int gn,cn;\n        cin>>gn>>cn;\n        --gn;\n        vector<int> t(cn);\n        for (int j = 0; j < cn; ++j) {\n            cin>>t[j];\n            --t[j];\n        }\n        g[gn].push_back(t);\n    }\n    for (int i = 0; i < n; ++i) {\n        if(cost[i]!=-1)continue;\n        calcost(i);\n    }\n    cout<<cost[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nstatic const int INF = 10000000;\n\npair<vector<int>, bool>\nbellman_ford(const vector<vector<vector<int> > >& rules, const vector<int>& seed)\n{\n  const int N = seed.size();\n  vector<int> dist(N, INF);\n  for (int i = 0; i < N; i++) {\n    if (seed[i]) {\n      dist[i] = 1;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int u = 0; u < N; u++) {\n      for (vector<vector<int> >::const_iterator it = rules[u].begin(); it != rules[u].end(); ++it) {\n        vector<int> v;\n        for (vector<int>::const_iterator jt = it->begin(); jt != it->end(); ++jt) {\n          v.push_back(dist[*jt]);\n        }\n        sort(v.begin(), v.end(), greater<int>());\n        int d = 0;\n        for (vector<int>::const_iterator jt = v.begin(); jt != v.end(); ++jt) {\n          d = max(d, int(*jt + (jt - v.begin())));\n        }\n        dist[u] = min(dist[u], d);\n      }\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    for (vector<vector<int> >::const_iterator it = rules[u].begin(); it != rules[u].end(); ++it) {\n      vector<int> v;\n      for (vector<int>::const_iterator jt = it->begin(); jt != it->end(); ++jt) {\n        v.push_back(dist[*jt]);\n      }\n      sort(v.begin(), v.end(), greater<int>());\n      int d = 0;\n      for (vector<int>::const_iterator jt = v.begin(); jt != v.end(); ++jt) {\n        d = max(d, int(*jt + (jt - v.begin())));\n      }\n      if (d < dist[u]) {\n        return make_pair(dist, false);\n      }\n    }\n  }\n  return make_pair(dist, true);\n}\n\nint main()\n{\n  int N, E, T;\n  cin >> N >> E >> T;\n  --T;\n  vector<int> seed(N);\n  for (int i = 0; i < N; i++) {\n    cin >> seed[i];\n  }\n  vector<vector<vector<int> > > rules(N);\n  for (int i = 0; i < E; i++) {\n    int g, c;\n    cin >> g >> c;\n    --g;\n    vector<int> r(c);\n    for (int j = 0; j < c; j++) {\n      cin >> r[j];\n      --r[j];\n    }\n    rules[g].push_back(r);\n  }\n\n  const pair<vector<int>, bool> r = bellman_ford(rules, seed);\n  if (r.second && r.first[T] < INF) {\n    cout << r.first[T] << endl;\n  } else {\n    cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n,e,t,g[1000],c[1000],d[300],inf=1e8;\nvector<int> s[1000];\nbool w[300],used[300];\nint main(){\n\tcin>>n>>e>>t;\n\tt--;\n\trep(i,n) cin>>w[i];\n\trep(i,e){\n\t\tcin>>g[i]>>c[i];\n\t\tg[i]--;\n\t\trep(j,c[i]){\n\t\t\tint sij;\n\t\t\tcin>>sij;\n\t\t\ts[i].pb(sij-1);\n\t\t}\n\t}\n\trep(i,n) d[i]=(w[i] ? 1 : inf);\n\tbool update=true;\n\twhile(update){\n\t\tupdate=false;\n\t\trep(i,e){\n\t\t\tvector<int> costs;\n\t\t\trep(j,c[i]) costs.pb(d[s[i][j]]);\n\t\t\tsort(all(costs),greater<int>());\n\t\t\tif(costs[0]==inf) continue;\n\t\t\tint mx=0;\n\t\t\trep(j,c[i]) mx=max(mx,costs[j]+j);\n\t\t\tif(mx<d[g[i]]){\n\t\t\t\td[g[i]]=mx;\n\t\t\t\tupdate=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[t]==inf) d[t]=-1;\n\tcout<<d[t]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct howto {\n\tint wit;\n\tvector<int>needs;\n\thowto(const int g) :wit(g), needs() {}\n};\nstruct aa {\n\tint wit;\n\tint need;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.need> r.need;\n\t}\n};\nint main() {\n\tint N, E, T; cin >> N >> E >> T; T--;\n\tvector<int>costs(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint w; cin >> w;\n\t\tif (w)costs[i] = 1;\n\t\telse costs[i] = 1e8;\n\t}\n\tvector<howto>hows;\n\tvector<bool>howuses(E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint g, c; cin >> g >> c;\n\t\tg--;\n\t\thows.push_back(howto(g));\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint s; cin >> s; s--;\n\t\t\thows[i].needs.push_back(s);\n\t\t}\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tfor (int h = 0; h<hows.size(); ++h) {\n\t\tvector<int>neednums;\n\t\tfor (auto n : hows[h].needs) {\n\t\t\tneednums.push_back(costs[n]);\n\t\t}\n\t\tsort(neednums.begin(), neednums.end());\n\t\tint amax = 0;\n\t\tfor (int i = 0; i < neednums.size(); ++i) {\n\t\t\tamax = max(int(neednums[i]+neednums.size() - i - 1), amax);\n\t\t}\n\t\tif (amax < costs[hows[h].wit])que.push(aa{ hows[h].wit,amax });\n\t}\n\tint ans = 1e8;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.need < costs[atop.wit]) {\n\t\t\tcosts[atop.wit] = atop.need;\n\t\t}\n\t\tfor (int h = 0; h<hows.size(); ++h) {\n\t\t\tvector<int>neednums;\n\t\t\tfor (auto n : hows[h].needs) {\n\t\t\t\tneednums.push_back(costs[n]);\n\t\t\t}\n\t\t\tsort(neednums.begin(), neednums.end());\n\t\t\tint amax = 0;\n\t\t\tfor (int i = 0; i < neednums.size(); ++i) {\n\t\t\t\tamax = max(int(neednums[i] + neednums.size() - i - 1), amax);\n\t\t\t}\n\t\t\tif (amax < costs[hows[h].wit])que.push(aa{ hows[h].wit,amax });\n\t\t}\n\t}\n\tif (costs[T]>1e6)costs[T] = -1;\n\tcout << costs[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int v,t;\n  bool operator<(S s)const{\n    return t<s.t;\n  }\n};\n\nint main(){\n  int N,E,T;\n  cin>>N>>E>>T;\n  priority_queue<S> que;\n  for(int i=1;i<=N;i++){\n    int W;\n    cin>>W;\n    if(W){\n      que.push({i,1});\n    }\n  }\n  int G[1234],C[1234],S[1234][12];\n  for(int i=0;i<E;i++){\n    cin>>G[i]>>C[i];\n    for(int j=0;j<C[i];j++){\n      cin>>S[i][j];\n    }\n  }\n  int nn[312]={};\n  while(!que.empty()){\n    auto c=que.top();\n    que.pop();\n    if(nn[c.v])continue;\n    nn[c.v]=c.t;\n    for(int i=0;i<E;i++){\n      bool u=false;\n      bool f=false;\n      vector<int> v(C[i]);\n      for(int j=0;j<C[i];j++){\n\tu|=S[i][j]==c.v;\n\tf|=!nn[S[i][j]];\n\tv[j]=nn[S[i][j]];\n      }\n      if(u&&!f){\n\tsort(begin(v),end(v));\n\tint m=0;\n\tfor(int k=0;k<v.size();k++){\n\t  m=max<int>(m,v.size()-1-k+v[k]);\n\t}\n\tque.push({G[i],m});\n      }\n    }\n  }\n  cout<<(nn[T]?nn[T]:-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nll dp[310];\nvvint vv[310];\nint n;\nint used[310];\nll foo(int x){\n\tif(dp[x]!=INF){\n\t\treturn dp[x];\n\t}\n\tif(used[x]) return -1;\n\t// dump(x+1);\n\tll ret=INF+1;\n\tused[x]=1;\n\tbool f=false;\n\trep(i,vv[x].size()){\n\t\tvll tmp;\n\t\trep(j,vv[x][i].size()){\n\t\t\tll t=foo(vv[x][i][j]);\n\t\t\tif(t==-1) f=true;\n\t\t\ttmp.PB(foo(vv[x][i][j]));\n\t\t}\n\t\tsort(ALL(tmp));\n\t\treverse(ALL(tmp));\n\t\tll t1=0;\n\t\tll t2=0;\n\t\trep(i,tmp.size()){\n\t\t\tif(t2>=tmp[i]){\n\t\t\t\t// t2-=tmp[i];\n\t\t\t\tt2--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt1+=tmp[i]-t2;\n\t\t\t\tt2=tmp[i]-1;\n\t\t\t}\n\t\t}\n\t\tret=min(ret,t1);\n\t}\n\tused[x]=0;\n\tif(f) return INF;\n\tdp[x]=ret;\n\trep(i,vv[x].size()){\n\t\trep(j,vv[x][i].size()){\n\t\t\tfoo(vv[x][i][j]);\n\t\t}\n\t}\n\treturn dp[x];\n}\nvoid mainmain(){\n\tint e,T;\n\tcin>>n>>e>>T;\n\t// dump(n);\n\tT--;\n\tvint w(n);\n\trep(i,n) cin>>w[i];\n\trep(i,e){\n\t\tint a,b;\n\t\t// dump(a);\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tint tt=vv[a].size();\n\t\tvv[a].resize(vv[a].size()+1);\n\t\trep(j,b){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tt--;\n\t\t\tvv[a][tt].PB(t);\n\t\t}\n\t}\n\trep(i,310){\n\t\tdp[i]=INF;\n\t}\n\trep(i,n){\n\t\tif(w[i]) dp[i]=1;\n\t}\n\tbool update=true;\n\twhile(update){\n\t\tupdate=false;\n\t\trep(i,n){\n\t\t\trep(j,vv[i].size()){\n\t\t\t\tll t1=0;\n\t\t\t\tll t2=0;\n\t\t\t\tvll tmp(vv[i][j].size());\n\t\t\t\trep(k,vv[i][j].size()){\n\t\t\t\t\ttmp[k]=dp[vv[i][j][k]];\n\t\t\t\t}\n\t\t\t\tsort(ALL(tmp));\n\t\t\t\treverse(ALL(tmp));\n\t\t\t\trep(k,tmp.size()){\n\t\t\t\t\tif(t2>=tmp[k]){\n\t\t\t\t\t\tt2--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tt1+=tmp[k]-t2;\n\t\t\t\t\t\tt2=tmp[k]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t1<dp[i]){\n\t\t\t\t\tupdate=true;\n\t\t\t\t\tdp[i]=t1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// foo(T);\n\trep(i,n){\n\t\t// cout<<i+1<<\" \"<<dp[i]<<\" \"<<used[i]<<endl;\n\t}\n\tif(dp[T]>=INF) cout<<-1<<endl;\n\telse cout<<dp[T]<<endl;\n}\n\n\nmain() {\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n#define INF 10101010\nint N, E, T, W[303], G[1010];\nvector<int> S[1010];\nint ans[303];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> E >> T; T--;\n    rep(i, 0, N) cin >> W[i];\n    rep(i, 0, E) {\n        int C; cin  >> G[i] >> C; G[i]--;\n        rep(j, 0, C) {\n            int s; cin >> s; s--;\n            S[i].push_back(s);\n        }\n    }\n\n    rep(i, 0, N) {\n        if(W[i] == 1) ans[i] = 1;\n        else ans[i] = INF;\n    }\n\n    rep(a, 0, N * 2) rep(b, 0, E){\n        vector<int> v;\n        for (int i : S[b]) v.push_back(ans[i]);\n        sort(v.begin(), v.end(), greater<int>());\n\n        int a = 0;\n        rep(i, 0, v.size()) a = max(a, i + v[i]);\n\n        ans[G[b]] = min(ans[G[b]], a);\n    }\n\n    if (ans[T] == INF) ans[T] = -1;\n    printf(\"%d\\n\", ans[T]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {\n    int to;\n    vector<int> from;\n};\n\nint main() {\n    constexpr int inf = 1e4;\n\n    int N, E, T;\n    cin >> N >> E >> T;\n    T--;\n    vector<int> w(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> w[i];\n    }\n    vector<edge> es(E);\n    for(int i = 0; i < E; ++i) {\n        int c;\n        cin >> es[i].to >> c;\n        es[i].to--;\n        vector<int> from(c);\n        for(int j = 0; j < c; ++j) {\n            cin >> from[j];\n            from[j]--;\n        }\n        es[i].from = move(from);\n    }\n\n    vector<int> dist(N, inf);\n    for(int i = 0; i < N; ++i) {\n        if(w[i] == 1) dist[i] = 1;\n    }\n    for(int cnt = 0; cnt < N; ++cnt) {\n        for(auto& e : es) {\n            vector<int> costs;\n            for(auto v : e.from) {\n                costs.push_back(dist[v]);\n            }\n            sort(rbegin(costs), rend(costs));\n            int cost = 0;\n            for(int i = 0; i < (int)costs.size(); ++i) {\n                cost = max(cost, costs[i] + i);\n            }\n            dist[e.to] = min(dist[e.to], cost);\n        }\n    }\n\n    cout << (dist[T] == inf ? -1 : dist[T]) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = 1000000;\n\nint main()\n{\n\tint n, e, t;\n\tvector<int> w;\n\tvector<pair<int, vector<int> > > gcs;\n\n\tscanf(\"%d%d%d\", &n, &e, &t);\n\tt -= 1;\n\tw.resize(n);\n\tgcs.resize(e);\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &w[i]);\n\tfor(int i = 0; i < e; ++i) {\n\t\tint size;\n\t\tscanf(\"%d%d\", &gcs[i].first, &size);\n\t\tgcs[i].first -= 1;\n\t\tgcs[i].second.resize(size);\n\t\tfor(int j = 0; j < size; ++j) {\n\t\t\tscanf(\"%d\", &gcs[i].second[j]);\n\t\t\tgcs[i].second[j] -= 1;\n\t\t}\n\t}\n\n\tvector<int> mini(n);\n\n\tfor(int i = 0; i < n; ++i)\n\t\tmini[i] = w[i] == 0 ? inf : 1;\n\n\twhile(true) {\n\n\t\tbool update = false;\n\n\t\tfor(auto &law : gcs) {\n\n\t\t\tint dest = law.first;\n\t\t\tvector<int> &src = law.second;\n\n\t\t\tbool ok = true;\n\t\t\tfor(auto k : src)\n\t\t\t\tok = ok && mini[k] < inf;\n\t\t\tif(!ok)\n\t\t\t\tcontinue;\n\n\t\t\tint ca = 1;\n\t\t\tstatic vector<int> count(n + 1);\n\n\t\t\tfill(count.begin(), count.end(), 0);\n\t\t\tfor(auto k : src)\n\t\t\t\tcount[mini[k]] += 1;\n\t\t\tfor(int i = n; i > 0; --i)\n\t\t\t\tcount[i - 1] += count[i];\n\n\t\t\tfor(auto k : src)\n\t\t\t\tca = max(ca, count[mini[k]] - 1 + mini[k]);\n\n\t\t\tif(mini[dest] > ca) {\n\t\t\t\tmini[dest] = ca;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!update)\n\t\t\tbreak;\n\t}\n\n\tint ans = mini[t] < inf ? mini[t] : -1;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n \n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n \nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n \ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n \nstruct Law {\n\tint G;\n\tvector<int> S;\n};\n \nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N); cin >> W;\n\tvector<Law> law;\n\tREP(i, E) {\n\t\tint G, C; cin >> G >> C; --G;\n\t\tvector<int> S(C); cin >> S;\n\t\tREP(i, C) S[i]--;\n\t\tlaw.pb( (Law){G, S} );\n\t}\n\tvector<int> dp(N, inf);\n\tREP(i, N) {\n\t\tif (W[i] == 1) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t}\n\tREP(i, E) REP(j, E) {\n\t\tint M = 0, m = inf;\n\t\tvector<int> a(law[j].S.size());\n\t\tREP(k, law[j].S.size()) {\n\t\t\tint id = law[j].S[k];\n\t\t\ta[k] = dp[id];\n\t\t}\n\t\tsort( ALL(a), greater<int>() );\n\t\tint c = 1;\n\t\tREP(i, a.size()) {\n\t\t\tc = max(c, a[i]+(int)i);\n\t\t}\n\t\tif (c < dp[law[j].G]) {\n\t\t\tdp[law[j].G] = c;\n\t\t}\n\t}\n\tif (dp[T] == inf) cout << -1 << endl;\n\telse cout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nstruct edge\n{\n    int st;\n    vi vec;\n    edge(){};\n    edge(int a,vi b){\n        st = a,vec = b;\n    }\n};\n\nvector<edge> eda;\nint memo[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    fill(memo,memo+n,INF);\n    rep(i,n){\n        int a;\n        cin >> a;\n        if(a){\n            memo[i] = 1;\n        }\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        eda.emplace_back(a,hoge);\n    }\n    while(1){\n        bool update = false;\n        rep(i,e){\n            edge& e = eda[i];\n            vi hoge;\n            bool ok = true;\n            each(it,e.vec){\n                if(memo[it] == INF){\n                    ok = false;\n                }\n                hoge.pb(memo[it]);\n            }\n            if(ok){\n                int val = len(e.vec);\n                sort(all(hoge));\n                rep(j,len(hoge)){\n                    cmx(val,hoge[j]+len(e.vec)-1-j);\n                }\n                if(val < memo[e.st]){\n                    memo[e.st] = val;\n                    update = true;\n                }\n            }\n        }\n        if(!update) break;\n    }\n    if(memo[t] == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << memo[t] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int MAX = (1 << 20);\n\nint n, e, t;\nint w[300];\nint g[1000];\nint c[1000];\nint s[1000][300];\nint memo[300];\n\nint buff[300];\n\nint main(){\n  scanf(\"%d%d%d\", &n, &e, &t);\n  REP(i,n) scanf(\"%d\", w+i);\n  REP(i,e){\n    scanf(\"%d%d\", g+i, c+i); g[i]--;    \n    REP(j,c[i]){scanf(\"%d\", &s[i][j]); s[i][j]--;}\n  }\n\n  REP(i,n) memo[i] = w[i] == 1 ? 1 : MAX;\n  \n  while(true){\n    bool ok = true;\n\n    REP(i,e){\n      int next = 0;\n      REP(j,c[i]){\n\tbuff[j] = - memo[s[i][j]];\n      }\n      sort(buff, buff + c[i]);\n\n      REP(j,c[i])\n\tnext = max(next, j - buff[j]);\n\n      if(next < memo[g[i]]){\n\tmemo[g[i]] = next;\n\tok = false;\n      }\n    }\n\n    if(ok) break;\n  }\n\n  // REP(i,n) printf(\"%d \", memo[i]); puts(\"\");\n  printf(\"%d\\n\", memo[t-1] == MAX ? -1 : memo[t-1]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nstruct edge\n{\n    int st;\n    vi vec;\n    edge(){};\n    edge(int a,vi b){\n        st = a,vec = b;\n    }\n};\n\nvector<edge> eda;\nint memo[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    fill(memo,memo+n,INF);\n    rep(i,n){\n        int a;\n        cin >> a;\n        if(a){\n            memo[i] = 1;\n        }\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        eda.emplace_back(a-1,hoge);\n    }\n    while(1){\n        bool update = false;\n        rep(i,e){\n            edge& e = eda[i];\n            vi hoge;\n            bool ok = true;\n            each(it,e.vec){\n                if(memo[it] == INF){\n                    ok = false;\n                }\n                hoge.pb(memo[it]);\n            }\n            if(ok){\n                int val = len(hoge);\n                sort(all(hoge));\n                rep(j,len(hoge)){\n                    cmx(val,hoge[j]+len(hoge)-1-j);\n                }\n                if(val < memo[e.st]){\n                    memo[e.st] = val;\n                    update = true;\n                }\n            }\n        }\n        if(!update) break;\n    }\n    if(memo[t] == INF){\n        cout << \"-1\\n\";\n    }else{\n        cout << memo[t] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\nconst int INF=114514;\nint main(){\n    int N,E,T;\n    cin>>N>>E>>T;T--;\n    V dist(N,INF);\n    for(int i=0;i<N;i++){\n        int b;cin>>b;\n        if(b)dist[i]=1;\n    }\n    V G(E);\n    VV edge(E);\n    for(int i=0;i<E;i++){\n        int C;\n        cin>>G[i]>>C;G[i]--;\n        edge[i].resize(C);\n        for(int j=0;j<C;edge[i][j++]--)cin>>edge[i][j];\n    }\n    for(bool update=true;update;){\n        update=false;\n        for(int i=0;i<E;i++){\n            int sz=edge[i].size();\n            V d=edge[i];\n            for(int j=0;j<sz;j++)d[j]=dist[d[j]];\n            sort(d.begin(),d.end());\n            reverse(d.begin(),d.end());\n            int need=0;\n            int space=0;\n            for(auto &v:d){\n                if(space<v){\n                    need+=v-space;\n                    space+=v-space;\n                }\n                space--;\n            }\n            if(need<dist[G[i]]){\n                update=true;\n                dist[G[i]]=need;\n            }\n        }\n    }\n    if(dist[T]==INF)\n        cout<<-1<<endl;\n    else \n        cout<<dist[T]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int INF = 1000000000;\n\nclass Rule : public vector<int>{\n\tpublic:\n\tint parent;\n};\n\n\nint n,e,t;\nvector<int> dp;\nvector<Rule> rule; \n\nbool input(){\n\tcin>>n>>e>>t;\n\tt--;\n\tdp.resize(n);\n\trule.resize(e);\n\t\n\trep(i,n)cin>>dp[i];\n\trep(i,e){\n\t\tcin>>rule[i].parent;\n\t\trule[i].parent--;\n\t\tint a;\n\t\tcin>>a;\n\t\trule[i].resize(a);\n\t\trep(j,a){\n\t\t\tcin>>rule[i][j];\n\t\t\trule[i][j]--;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\n\nint solve(){\n\t\n\twhile(1){\n\t\tint mini = INF;\n\t\tint minp = -1;\n\t\t\n\t\trep(i,e){\n\t\t\tif(dp[rule[i].parent]==0){\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j,rule[i].size())if(dp[rule[i][j]]==0)ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tvector<int> st(rule[i].size());\n\t\t\t\t\trep(j,rule[i].size()) st[j] = dp[rule[i][j]];\n\t\t\t\t\tsort(st.rbegin(), st.rend());\n\t\t\t\t\t\n\t\t\t\t\tint value = 0;\n\t\t\t\t\trep(j,st.size()) value = max(value, j+st[j]);\n\t\t\t\t\t\n\t\t\t\t\tif(mini > value){\n\t\t\t\t\t\tmini = value;\n\t\t\t\t\t\tminp = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minp==-1)break;\n\t\t\n\t\tdp[rule[minp].parent] = mini;\n\t}\n\t/*\n\trep(i,n){\n\t\tprintf(\"%d | %d\\n\",i,dp[i]);\n\t}*/\n\t\n\tif(dp[t]==0)return -1;\n\treturn dp[t];\n}\n\nvoid call(){\n\tcout<<solve()<<endl;\n}\n\nint main(){\n\tinput();call();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct Edge{\n  int src, dest;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest) {\n  g[src].push_back((Edge){src, dest});\n}\n\nstruct Recipe {\n  int g;\n  vector<int> s;\n};\n\nWeight weight(Recipe r, Array& ary) {\n  vector<int> vs;\n  for(int s:r.s) {\n    vs.emplace_back(ary[s]);\n  }\n  sort(ALL(vs),greater<int>());\n  int mx = 0;\n  REP(i,vs.size()) {\n    mx = max(mx, vs[i] + i);\n  }\n  return mx;\n}\n\nint main() {\n  int n,e,t;\n  cin>>n>>e>>t;\n  --t;\n  queue<int> que;\n  Array d(n, INF);\n  Graph graph(n);\n  REP(i,n) {\n    que.push(i);\n    int w;\n    cin>>w;\n    if(w) d[i] = 1;\n  }\n  vector<vector<Recipe>> gr(n);\n  REP(i,e) {\n    Recipe r;\n    int c;\n    cin>>r.g>>c;\n    --r.g;\n    REP(j,c) {\n      int s;\n      cin>>s;\n      --s;\n      add_edge(graph, s, r.g);\n      r.s.push_back(s);\n    }\n    gr[r.g].push_back(r);\n  }\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    bool update = false;\n    for (auto r : gr[v]) {\n      if (weight(r, d) < d[v]) {\n        d[v] = weight(r, d);\n        update = true;\n      }\n    }\n    if (update) {\n      REP(i, graph[v].size()) {\n        que.push(graph[v][i].dest);\n      }\n    }\n  }\n  if (d[t] < INF) {\n    cout << d[t] << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct howto {\n\tint wit;\n\tvector<int>needs;\n\thowto(const int g) :wit(g), needs() {}\n};\nstruct aa {\n\tint wit;\n\tint need;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.need> r.need;\n\t}\n};\nint main() {\n\tint N, E, T; cin >> N >> E >> T; T--;\n\tvector<int>costs(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint w; cin >> w;\n\t\tif (w)costs[i] = 1;\n\t\telse costs[i] = 1e8;\n\t}\n\tvector<howto>hows;\n\tvector<bool>howuses(E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint g, c; cin >> g >> c;\n\t\tg--;\n\t\thows.push_back(howto(g));\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint s; cin >> s; s--;\n\t\t\thows[i].needs.push_back(s);\n\t\t}\n\t}\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tfor (int h = 0; h<hows.size(); ++h) {\n\t\tvector<int>neednums;\n\t\tfor (auto n : hows[h].needs) {\n\t\t\tneednums.push_back(costs[n]);\n\t\t}\n\t\tsort(neednums.begin(), neednums.end());\n\t\tint amax = 0;\n\t\tfor (int i = 0; i < neednums.size(); ++i) {\n\t\t\tamax = max(int(neednums[i]+neednums.size() - i - 1), amax);\n\t\t}\n\t\tif (amax < costs[hows[h].wit])que.push(aa{ hows[h].wit,amax });\n\t}\n\tint ans = 1e8;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.need < costs[atop.wit]) {\n\t\t\tcosts[atop.wit] = atop.need;\n\t\t\tfor (int h = 0; h<hows.size(); ++h) {\n\t\t\t\tvector<int>neednums;\n\t\t\t\tfor (auto n : hows[h].needs) {\n\t\t\t\t\tneednums.push_back(costs[n]);\n\t\t\t\t}\n\t\t\t\tsort(neednums.begin(), neednums.end());\n\t\t\t\tint amax = 0;\n\t\t\t\tfor (int i = 0; i < neednums.size(); ++i) {\n\t\t\t\t\tamax = max(int(neednums[i] + neednums.size() - i - 1), amax);\n\t\t\t\t}\n\n\t\t}\n\t\tif (amax < costs[hows[h].wit])que.push(aa{ hows[h].wit,amax });\n\t\t}\n\t}\n\tif (costs[T]>1e6)costs[T] = -1;\n\tcout << costs[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N,E,T;\nvector<bool> check;\nvector<int> cost;\nvector<vector<vector<int> > > rule;\nconst int NOT=-2;\n\nint calc(int idx){\n\tif(cost[idx]>=0) return cost[idx];\n\tif(cost[idx]==NOT) return NOT;\n\tif(check[idx]){cost[idx]=NOT;return NOT;}\n\tcheck[idx]=true;\n\tif(rule[idx].size()==0){cost[idx]=NOT; return NOT;}\n\tint res=1000000000;\n\tfor(int i=0;i<rule[idx].size();i++){\n\t\tvector<int> C;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<rule[idx][i].size();j++){\n\t\t\tint p=calc(rule[idx][i][j]);\n\t\t\tif(p==NOT){cost[idx]=NOT;ok=false;break;}\n\t\t\tC.push_back(p);\n\t\t}\n\t\tif(ok){\n\t\t\tsort(C.begin(),C.end());\n\t\t\tint a=C.size()-1;\n\t\t\tint num=0;\n\t\t\twhile(a>=0 &&  C[a]==C[C.size()-1]){\n\t\t\t\ta--;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tres=min(res,max(num-1+C[C.size()-1],(int)C.size()+C[0]-1));\n\t\t}\n\t}\n\tif(res==1000000000) return cost[idx]=NOT;\n\treturn cost[idx]=res;\n}\n\n\nint main()\n{\n\tcin>>N>>E>>T;\n\tT--;\n\tcheck.resize(N,false);\n\tcost.resize(N,-1);\n\tfor(int i=0;i<N;i++){\n\t\tint t;cin>>t;\n\t\tif(t==1){cost[i]=1;}\n\t}\n\trule.resize(N);\n\n\tfor(int i=0;i<E;i++){\n\t\tint idx,num; cin>>idx>>num;\n\t\tidx--;\n\t\tvector<int> now;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tint t;cin>>t;t--;\n\t\t\tnow.push_back(t);\n\t\t}\n\t\trule[idx].push_back(now);\n\t}\n\tint res=calc(T);\n\n\tif(res==NOT) cout<<-1<<endl;\n\telse cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N,E,T;\nvector<bool> check;\nvector<int> cost;\nvector<vector<vector<int> > > rule;\nconst int NOT=-2;\n\nint calc(int idx){\n\tif(cost[idx]>=0) return cost[idx];\n\tif(cost[idx]==NOT) return NOT;\n\tif(check[idx]){cost[idx]=NOT;return NOT;}\n\tcheck[idx]=true;\n\tif(rule[idx].size()==0){cost[idx]=NOT; return NOT;}\n\tint res=1000000000;\n\tfor(int i=0;i<rule[idx].size();i++){\n\t\tvector<int> C;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<rule[idx][i].size();j++){\n\t\t\tint p=calc(rule[idx][i][j]);\n\t\t\tif(p==NOT){cost[idx]=NOT;ok=false;break;}\n\t\t\tC.push_back(p);\n\t\t}\n\t\tif(ok){\n\t\t\tsort(C.begin(),C.end());\n\t\t\tint num=0,fill=0;\n\t\t\tfor(int k=C.size()-1;k>=0;k--){\n\t\t\t\tnum=max(num,fill+C[k]);\n\t\t\t\tfill++;\n\t\t\t}\n\t\t\tres=num;\n\t\t}\n\t}\n\tif(res==1000000000) return cost[idx]=NOT;\n\treturn cost[idx]=res;\n}\n\n\nint main()\n{\n\tcin>>N>>E>>T;\n\tT--;\n\tcheck.resize(N,false);\n\tcost.resize(N,-1);\n\tfor(int i=0;i<N;i++){\n\t\tint t;cin>>t;\n\t\tif(t==1){cost[i]=1;}\n\t}\n\trule.resize(N);\n\n\tfor(int i=0;i<E;i++){\n\t\tint idx,num; cin>>idx>>num;\n\t\tidx--;\n\t\tvector<int> now;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tint t;cin>>t;t--;\n\t\t\tnow.push_back(t);\n\t\t}\n\t\trule[idx].push_back(now);\n\t}\n\tint res=calc(T);\n\tif(res==NOT) cout<<-1<<endl;\n\telse cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Law {\n\tint G;\n\tvector<int> S;\n};\n\nvoid update(int pos, int need, vector<int>& dp) {\n\tif (need >= dp[pos]) return;\n\tdp[pos] = min(dp[pos], need);\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N); cin >> W;\n\tvector<Law> law;\n\tREP(i, E) {\n\t\tint G, C; cin >> G >> C; --G;\n\t\tvector<int> S(C); cin >> S;\n\t\tREP(i, C) S[i]--;\n\t\tlaw.pb( (Law){G, S} );\n\t}\n\tvector<int> dp(N, inf);\n\tREP(i, N) {\n\t\tif (W[i] == 1) {\n\t\t\tupdate(i, 1, dp);\n\t\t}\n\t}\n\tREP(t, N) REP(i, N) REP(j, E) {\n\t\tint M = 0, m = inf;\n\t\tREP(k, law[j].S.size()) {\n\t\t\tint id = law[j].S[k];\n\t\t\tM = max(M, dp[id]);\n\t\t\tm = min(m, dp[id]);\n\t\t}\n\t\tdp[law[j].G] = min(dp[law[j].G], max(M, (int)law[j].S.size()-1+m));\n\t}\n\tif (dp[T] == inf) cout << -1 << endl;\n\telse cout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t;\nbool ok[300];\n\nint main(){\n\tmap<int, vector<vi> > mm;\n\t\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint g, k;\n\t\tcin >> g >> k;\n\t\tvi v(k);\n\t\trep(j, k) cin >> v[j], v[j]--;\n\t\tmm[g - 1].pb(v);\n\t}\n\tt--;\n\t\n\tif(ok[t]){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tset<vi> s;\n\tvi v(1, t);\n\tpriority_queue<pair<int, vi> > q;\n\tq.push(mp(-1, v));\n\twhile(!q.empty()){\n\t\tv = q.top().second;\n\t\tint co = q.top().first; q.pop();\n\t\tif(s.count(v)) continue;\n\t\ts.insert(v);\n\t\t\n\t\tif(v.empty()){\n\t\t\tcout << -co << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(i, v.size()) each(j, mm[v[i]]){\n\t\t\tvi nv = v;\n\t\t\teach(k, *j) if(!ok[*k]) nv.pb(*k);\n\t\t\t\n\t\t\tswap(nv[i], nv.back());\n\t\t\tnv.erase(nv.end() - 1);\n\t\t\tsort(all(nv));\n\t\t\tint nco = v.size() + j->size() - 1;\n\t\t\tnco = min(-nco, co);\n\t\t\tif(!s.count(nv)) q.push(mp(nco, nv));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvi w(n);\n\trep(i, n)cin >> w[i];\n\tvector<pair<int, vi>> g(e);\n\trep(i, e) {\n\t\tcin >> g[i].first;\n\t\tg[i].first--;\n\t\tint c;\n\t\tcin >> c;\n\t\tg[i].second.resize(c);\n\t\trep(j, c) {\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tg[i].second[j] = s - 1;\n\t\t}\n\t}\n\tvector<vi> add(n);\n\tvi m(e);\n\tvi cost = w;\n\trep(i, n)if (cost[i] == 0)cost[i] = 1e9;\n\tpriority_queue<pii> q;\n\trep(i, e) {\n\t\tfor (auto x : g[i].second)add[x].push_back(i);\n\t}\n\trep(i, n)if (w[i]) {\n\t\tfor (auto x : add[i]) {\n\t\t\tm[x]++;\n\t\t\tif (m[x] == g[x].second.size())q.emplace(m[x], g[x].first);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tauto a = q.top(); q.pop();\n\t\tif (cost[a.second]<=a.first)continue;\n\t\tcost[a.second] = a.first;\n\t\tfor (auto x : add[a.second]) {\n\t\t\tm[x]++;\n\t\t\tif (m[x] == g[x].second.size()) {\n\t\t\t\tvi cl;\n\t\t\t\tfor (auto y : g[x].second)cl.push_back(cost[y]);\n\t\t\t\tsort(ALL(cl), greater<>());\n\t\t\t\tint c = 0;\n\t\t\t\trep(i, cl.size())cmax(c, i + cl[i]);\n\t\t\t\tq.emplace(c, g[x].first);\n\t\t\t}\n\t\t}\n\t}\n\tt--;\n\tif (cost[t] == 1e9)cout << -1 << endl;\n\telse cout << cost[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int inf=1e9;\n\nint N,E,T;\nbool ok[330];\nint dis[330];\n\nint g[1010];\nvector<int> s[1010];\nint unknown[1010];\n\nvector<int> app[330];\n\npriority_queue<P,vector<P>,greater<P> > que;\n\nint main(){\n\tscanf(\"%d%d%d\",&N,&E,&T);\n\tfor(int i=1;i<=N;i++){\n\t\tint in;\n\t\tscanf(\"%d\",&in);\n\t\tok[i]=in==1;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tif(ok[i]) dis[i]=1;\n\t\telse dis[i]=inf;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tscanf(\"%d\",g+i);\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tfor(int j=0;j<cnt;j++){\n\t\t\tint in;\n\t\t\tscanf(\"%d\",&in);\n\t\t\ts[i].push_back(in);\n\t\t\tapp[in].push_back(i);\n\t\t\tunknown[i]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) if(dis[i]==1) que.push(P(1,i));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint d=p.first;\n\t\tint v=p.second;\n\t\tif(v==T) break;\n\t\tif(dis[v]<d) continue;\n\t\tfor(int i=0;i<app[v].size();i++){\n\t\t\tint e=app[v][i];\n\t\t\tunknown[e]--;\n\t\t\tif(unknown[e]==0){\n\t\t\t\tvector<int> tmp;\n\t\t\t\tfor(int j=0;j<s[e].size();j++){\n\t\t\t\t\ttmp.push_back(dis[s[e][j]]);\n\t\t\t\t}\n\t\t\t\tsort(tmp.begin(),tmp.end());\n\t\t\t\treverse(tmp.begin(),tmp.end());\n\t\t\t\tint res=-1;\n\t\t\t\tfor(int i=0;i<tmp.size();i++) res=max(res,tmp[i]+i);\n\t\t\t\t//dis[g[e]] res\n\t\t\t\tif(dis[g[e]]<=res) continue;\n\t\t\t\telse{\n\t\t\t\t\tdis[g[e]]=res;\n\t\t\t\t\tque.push(P(res,g[e]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dis[T]==inf?-1:dis[T]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e+8;\n\nsigned main(){\n\tint n,e,t,w[310],g[1010],c[1010],s[1010][12];\n\tcin >> n >> e >> t; t--;\n\tint d[310];\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> w[i];\n\t\td[i] = (w[i] ? 1 : INF);\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tcin >> g[i] >> c[i]; g[i]--;\n\t\tfor(int j = 0;j < c[i];j++){\n\t\t\tcin >> s[i][j]; s[i][j]--;\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < e;j++){\n\t\t\tint ma = 0;\n\t\t\tvector<int> vec;\n\t\t\tfor(int k = 0;k < c[j];k++) vec.push_back(d[s[j][k]]);\n\t\t\tsort(vec.begin(),vec.end(),greater<int>());\n\t\t\tfor(int k = 0;k < c[j];k++) ma = max(ma,vec[k] + k);\n\t\t\td[g[j]] = min(d[g[j]],ma);\n\t\t}\n\t}\n\tif(d[t] != INF) cout << d[t] << endl;\n\telse cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint main(){\n\tint N, E, T;\n\tint res[300];\n\tconst int INF = 1000000;\n\twhile(cin >> N >> E >> T){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tint W; cin >> W;\n\t\t\tres[i] = W==1 ? 1 : INF;\n\t\t}\n\t\tvector< vector<int> > vi(E);\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint G, C, S; cin >> G >> C;\n\t\t\tvi[i].push_back(G-1);\n\t\t\tfor(int j=0;j<C;j++){\n\t\t\t\tcin >> S;\n\t\t\t\tvi[i].push_back(S-1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<E;j++){\n\t\t\t\tint cur = vi[j][0];\n\t\t\t\tvector<int> num;\n\t\t\t\tfor(int k=1;k<vi[j].size();k++)\n\t\t\t\t\tnum.push_back(res[vi[j][k]]);\n\t\t\t\tsort(num.begin(), num.end(), greater<int>());\n\t\t\t\tint tmp = 0;\n\t\t\t\tfor(int k=0;k<num.size();k++) tmp = max(tmp, num[k]+k);\n\t\t\t\tres[cur] = min(res[cur], tmp);\n\t\t\t}\n\t\t}\n\t\tcout << (res[T-1]!=INF ? res[T-1] : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t, g[300], dp[300];\nbool ok[300];\nvi s[1000];\n\nint main(){\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint k, a;\n\t\tcin >> g[i] >> k; g[i]--;\n\t\trep(j, k) cin >> a, s[i].pb(a - 1);\n\t}\n\trep(i, n) dp[i] = ok[i] ? 1 : inf;\n\trep(it, n) rep(i, e){\n\t\tint dp2[300], &res = dp[g[i]];\n\t\trep(j, s[i].size()) dp2[j] = dp[s[i][j]];\n\t\tsort(dp2, dp2 + s[i].size(), greater<int>());\n\t\tres = 0;\n\t\trep(j, s[i].size()) res = max(res, j + dp2[j]);\n\t\tres = min(res, inf);\n\t}\n\tcout << (dp[t - 1] >= inf ? -1 : dp[t - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2318.cc: Set-constructing Witch\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n/* global variables */\n\nbool wis[MAX_N], used[MAX_N];\nvvi ss[MAX_N];\nint dp[MAX_N];\n\n/* subroutines */\n\nint rec(int k) {\n  if (dp[k] >= 0) return dp[k];\n  if (wis[k]) return (dp[k] = 1);\n  if (used[k]) return INF;\n  \n  int minn = INF;\n  vvi& ssk = ss[k];\n  used[k] = true;\n\n  for (vvi::iterator vvit = ssk.begin(); vvit != ssk.end(); vvit++) {\n    vi &skv = *vvit, rs;\n    bool ok = true;\n\n    for (vi::iterator vit = skv.begin(); vit != skv.end(); vit++) {\n      int r = rec(*vit);\n      //printf(\"rec(%d)=%d\\n\", *vit, r);\n      if (r >= INF) {\n\tok = false;\n\tbreak;\n      }\n      rs.push_back(r);\n    }\n\n    if (ok) {\n      sort(rs.begin(), rs.end(), greater<int>());\n      int maxn = 0;\n      for (int i = 0; i < rs.size(); i++) {\n\tint sum = rs[i] + i;\n\tif (maxn < sum) maxn = sum;\n      }\n      if (minn > maxn) minn = maxn;\n    }\n  }\n\n  used[k] = false;\n\n  if (minn < INF) dp[k] = minn;\n  return minn;\n}\n\n/* main */\n\nint main() {\n  int n, en, t;\n  cin >> n >> en >> t;\n  t--;\n\n  for (int i = 0; i < n; i++) cin >> wis[i];\n  //for (int i = 0; i < n; i++) printf(\"%d \", wis[i]); putchar('\\n');\n\n  for (int i = 0; i < en; i++) {\n    int gi, ci;\n    cin >> gi >> ci;\n    gi--;\n    ss[gi].push_back(vi(ci));\n    vi &sg = ss[gi][ss[gi].size() - 1];\n    for (int j = 0; j < ci; j++) {\n      cin >> sg[j];\n      sg[j]--;\n    }\n  }\n\n  for (int i = 0; i < n; i++) dp[i] = -1;\n\n  int minn = rec(t);\n  printf(\"%d\\n\", (minn >= INF) ? -1 : minn);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,E,T,W[333],G[1010],C[1010],S[1010][11];\nint d[333],rest[1010];\nvi to[333];\nint used[333];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>E>>T,T--;\n\trep(i,N)cin>>W[i];\n\trep(i,E){\n\t\tcin>>G[i]>>C[i],G[i]--;\n\t\trep(j,C[i]){\n\t\t\tcin>>S[i][j],S[i][j]--;\n\t\t\tto[S[i][j]].pb(i);\n\t\t}\n\t}\n\n\trep(i,N){\n\t\tif(W[i] == 1) d[i] = 1;\n\t\telse d[i] = INF;\n\t}\n\trep(i,E){\n\t\trest[i] = C[i];\n\t}\n\trep(_,N){\n\t\tint cur = -1, best = INF;\n\t\trep(i,N)if(!used[i] && d[i] < best){\n\t\t\tcur = i;\n\t\t\tbest = d[i];\n\t\t}\n\t\tif(cur == T){\n\t\t\treturn cout<<d[cur]<<endl,0;\n\t\t}\n\t\tif(cur == -1){\n\t\t\treturn cout<<-1<<endl,0;\n\t\t}\n\n\t\tused[cur] = 1;\n\t\trep(i,sz(to[cur])){\n\t\t\tint T = to[cur][i];\n\t\t\trest[T]--;\n\t\t\tif(rest[T] == 0){\n\t\t\t\tvi cost;\n\t\t\t\trep(j,C[T]){\n\t\t\t\t\tcost.pb(d[S[T][j]]);\n\t\t\t\t}\n\t\t\t\tsort(cost.begin(),cost.end(),greater<int>());\n\t\t\t\tint c = 0;\n\t\t\t\trep(j,sz(cost)){\n\t\t\t\t\tc = max(c, (int)cost[j] + j);\n\t\t\t\t}\n\t\t\t\td[G[T]] = min(d[G[T]],c);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t, g[300], dp[300];\nbool ok[300];\nvi s[1000];\n\nint main(){\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint k, a;\n\t\tcin >> g[i] >> k; g[i]--;\n\t\trep(j, k) cin >> a, s[i].pb(a - 1);\n\t}\n\trep(i, n) dp[i] = ok[i] ? 1 : inf;\n\trep(it, n) rep(i, e){\n\t\tint dp2[300], &res = dp[g[i]];\n\t\trep(j, s[i].size()) dp2[j] = dp[s[i][j]];\n\t\tsort(dp2, dp2 + s[i].size(), greater<int>());\n\t\tres = 0;\n\t\trep(j, s[i].size()) res = max(res, j + dp2[j]);\n\t\tres = min(res, inf);\n\t}\n\tcout << (dp[t - 1] == inf ? -1 : dp[t - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,e,t;\n  cin>>n>>e>>t;\n  t--;\n  int dp[n];\n  REP(i,n) {\n    bool w;cin>>w;\n    dp[i] = w?1:INF;\n  }\n  vector<vector<int> > v[n];\n  REP(i,e) {\n    int g, c;\n    cin >>g>>c;\n    g--;\n    vector<int> tmpv;\n    REP(j,c) {\n      int s;\n      cin >> s;\n      s--;\n      tmpv.push_back(s);\n    }\n    v[g].push_back(tmpv);\n  }\n  bool update = 1;\n  while(update) {\n    update = 0;\n    REP(i,n) {\n      if (v[i].size()==0)continue;\n      FOR(it, v[i]) {\n        vector<int> tmpv;\n        FOR(jt, *it) {\n          tmpv.push_back(dp[*jt]);\n        }\n        sort(ALL(tmpv), greater<int>());\n        int tmp = 0;\n        REP(j, tmpv.size()) {\n          tmp = max(tmp, j+tmpv[j]);\n        }\n        //printf(\"i=%d tmp=%d\\n\",i,tmp);\n        if (dp[i] > tmp) {\n          update = 1;\n          dp[i] = tmp;\n        }\n      }\n    }\n  }\n  if (dp[t] == INF) cout << -1 << endl;\n  else cout << dp[t-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nvvi G[MAX_N];\nint memo[MAX_N];\n\nint dfs(int nw,vector<bool>& flag,const int foo){\n    if(flag[nw]) return -1;\n    if(memo[nw]) return memo[nw];\n    flag[nw] = true;\n    int mn = INF;\n    rep(i,len(G[nw])){\n        bool ok = true;\n        vi kekka;\n        int sz = len(G[nw][i]);\n        rep(j,sz){\n            int res = dfs(G[nw][i][j],flag,foo);\n            if(res < 0){\n                ok = false;\n                break;\n            }\n            kekka.pb(res);\n        }\n        if(ok){\n            int val = sz;\n            sort(all(kekka));\n            rep(j,len(kekka)){\n                cmx(val,kekka[j]+sz-1-j);\n            }\n            cmn(mn,val);\n        }\n    }\n    if(mn == INF){\n        memo[nw] = foo;\n    }else{\n        memo[nw] = mn;\n    }\n    flag[nw] = false;\n    return memo[nw];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,e,t;\n    cin >> n >> e >> t;\n    --t;\n    rep(i,n){\n        cin >> memo[i];\n    }\n    rep(i,e){\n        int a,b;\n        vi hoge;\n        cin >> a >> b;\n        rep(j,b){\n            int c;\n            cin >> c;\n            hoge.pb(c-1);\n        }\n        G[a-1].pb(hoge);\n    }\n    vector<bool> flag(n,false);\n    rep(id,n){\n        fill(all(flag),false);\n        dfs(t,flag,0);\n    }\n    cout << dfs(t,flag,-1) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> cost;\nvector<vector<vector<int>>> g;\n\nvoid calcost(int ind,set<int> nowuse){\n    if(nowuse.find(ind)!=nowuse.end())return;\n    nowuse.insert(ind);\n    for(auto ng:g[ind]){\n        vector<int> d;\n        for(auto tg:ng){\n            if(cost[tg]==-1)calcost(tg,nowuse);\n            d.emplace_back(cost[tg]);\n        }\n        sort(d.rbegin(),d.rend());\n        int ans=0;\n        for (int i = 0; i < d.size(); ++i) {\n            if(d[i]==-1){\n                ans=-1;\n                break;\n            }\n            ans=max(ans,i+d[i]);\n        }\n        if(cost[ind]==-1)cost[ind]=ans;\n        else cost[ind]=min(cost[ind],ans);\n    }\n}\n\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    --t;\n    cost.assign(n,-1);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin>>a;\n        if(a==1){\n            cost[i]=1;\n            if(i==t){\n                cout<<1<<endl;\n                return 0;\n            }\n        }\n    }\n    g.resize(n);\n    for (int i = 0; i < e; ++i) {\n        int gn,cn;\n        cin>>gn>>cn;\n        --gn;\n        vector<int> t(cn);\n        for (int j = 0; j < cn; ++j) {\n            cin>>t[j];\n            --t[j];\n        }\n        g[gn].push_back(t);\n    }\n    for (int i = 0; i < n; ++i) {\n        if(cost[i]!=-1)continue;\n        set<int> ts;\n        calcost(i,ts);\n    }\n    cout<<cost[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\nint N,E,T;\nint sar[310];\npair<int,vector<int>> gen[310];\n\nsigned main() {\n    cin>>N>>E>>T;\n    minheap<pii> hp;\n    for(int i=1; i<=N; ++i) {\n        int w; cin>>w;\n        if(w) sar[i]=1;\n        else sar[i]=inf<int>;\n    }\n    rep(i,E) {\n        int g,c; cin>>g>>c;\n        gen[i].fir=g;\n        rep(j,c) {\n            int x; cin>>x;\n            gen[i].sec.emplace_back(x);\n        }\n    }\n    for(int t=1; t<=N; ++t) {\n        for(int i=0; i<E; ++i) {\n            int tmp=0;\n            int num=0;\n            priority_queue<int> pq;\n            for(auto &x:gen[i].sec) {\n                pq.emplace(sar[x]);\n            }\n            while(!pq.empty()) {\n                tmp=max(tmp,pq.top()+num);\n                num++;\n                pq.pop();\n            }\n            chmin(sar[gen[i].fir],tmp);\n        }\n    }\n    if(sar[T]>=inf<int>) esc(-1);\n    esc(sar[T]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n    int n,e,t;\n    cin >> n >> e >> t;\n    t--;\n    vector<int> w(n);\n    for(int i=0; i<n; i++){\n        cin >> w[i];\n    }\n    vector<vector<vector<int>>> rule(n);\n    for(int i=0; i<e; i++){\n        int prod,m;\n        cin >> prod >> m;\n        prod--;\n        vector<int> materials(m);\n        for(int &mat: materials){\n            cin >> mat;\n            mat--;\n        }\n        rule[prod].push_back(materials);\n    }\n\n    vector<vector<pair<int,int>>> to(n);\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)rule[i].size(); j++){\n            for(int k: rule[i][j]){\n                to[k].emplace_back(i, j);\n            }\n        }\n    }\n    vector<vector<int>> rulecount(n);\n    for(int i=0; i<n; i++){\n        for(const auto &v: rule[i]){\n            rulecount[i].push_back(v.size());\n        }\n    }\n\n    vector<int> mincost(n, inf);\n    priority_queue<pair<int,int>> wait;\n    for(int i=0; i<n; i++){\n        if(w[i] == 1){\n            mincost[i] = 1;\n            wait.push({-1, i});\n        }\n    }\n    while(!wait.empty()){\n        int c = -wait.top().first;\n        int v = wait.top().second;\n        wait.pop();\n        if(c > mincost[v]) continue;\n        for(auto p: to[v]){\n            int nv = p.first;\n            int rn = p.second;\n            rulecount[nv][rn]--;\n            if(rulecount[nv][rn] == 0){\n                vector<int> cost;\n                for(int mat: rule[nv][rn]){\n                    cost.push_back(mincost[mat]);\n                }\n                sort(cost.begin(), cost.end(), greater<int>());\n                int nc = 0;\n                for(int i=0; i<(int)cost.size(); i++){\n                    nc = max(nc, cost[i] +i);\n                }\n                if(nc < mincost[nv]){\n                    mincost[nv] = nc;\n                    wait.push({-nc, nv});\n                }\n            }\n        }\n    }\n    if(mincost[t] == inf){\n        cout << -1 << endl;\n    }else{\n        cout << mincost[t] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nint main(){\n    int inf = 1000000;\n    int n,e,t;\n    cin >> n >> e >> t;\n    vector<int>dp(n,inf);\n    for(int i=0;i<n;i++){\n        int w;\n        cin >> w;\n        if(w==1){\n            dp[i] = 1;\n        }\n    }\n    vector<pair<int,vector<int> > >rec;\n    for(int i=0;i<e;i++){\n        int g,c;\n        cin >> g >> c;\n        g--;\n        vector<int> v(c);\n        for(int j=0;j<c;j++){\n            cin >> v[j];\n            v[j]--;\n        }\n        rec.push_back(make_pair(g,v));\n    }\n    bool flag =1;\n    while(flag){\n        flag = 0;\n        for(auto& x:rec){\n            bool fflag = 1;\n            vector<int> tt;\n            for(auto& s:x.second){\n                if(dp[s]!=inf){\n                    tt.push_back(dp[s]);\n                }else{\n                    fflag = 0;\n                }\n            }\n            if(fflag){\n                sort(tt.begin(),tt.end(),greater<int>());\n                int tmp =tt[0];\n                int ttmp = 1;\n                for(int i = 1;i<tt.size();i++){\n                    if(tmp-ttmp<tt[i]){\n                        tmp = ttmp+tt[i];\n                        ttmp++;\n                    }else{\n                        ttmp++;\n                    }\n                }\n                if(dp[x.first]>tmp){\n                    flag = 1;\n                    // cout << mx << endl;\n                    // cout << cnt << endl;\n                    dp[x.first] = tmp;\n                    //cout << x.first << \" \" << dp[x.first] << endl;\n                }\n            }\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << dp[i] << \" \";\n    // }\n    // cout << endl;\n    if(dp[t-1]!=inf){\n        cout << dp[t-1] << endl;\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint INF=1e8;\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    t--;\n    vector<int> dp(n,INF);\n    for(int i=0;i<n;i++){\n        int w;\n        cin>>w;\n        if(w){\n            dp[i]=1;\n        }\n    }\n    vector<int> g(e);\n    vector<vector<int>> s(e);\n    for(int i=0;i<e;i++){\n        cin>>g[i];\n        g[i]--;\n        int c;\n        cin>>c;\n        s[i].assign(c,0);\n        for(int j=0;j<c;j++){\n            cin>>s[i][j];\n            s[i][j]--;\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<e;j++){\n            int ma=0;\n            int mi=INF;\n            bool isok=false;\n            for(int k=0;k<s[j].size();k++){\n                mi=min(mi,dp[s[j][k]]);\n                ma=max(ma,dp[s[j][k]]);\n            }\n            dp[g[j]]=min(dp[g[j]],max(int(s[j].size()+mi-1),ma));\n        }\n    }\n    if(dp[t]>=INF){\n        cout<<-1<<endl;\n    }\n    else{\n        cout<<dp[t]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2318.cc: Set-constructing Witch\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n/* global variables */\n\nbool wis[MAX_N], used[MAX_N];\nvvi ss[MAX_N];\nint dp[MAX_N];\n\n/* subroutines */\n\nint rec(int k) {\n  if (dp[k] >= 0) return dp[k];\n  if (wis[k]) return (dp[k] = 1);\n  if (used[k]) return (dp[k] = INF);\n  \n  int minn = INF;\n  vvi& ssk = ss[k];\n  used[k] = true;\n\n  for (vvi::iterator vvit = ssk.begin(); vvit != ssk.end(); vvit++) {\n    vi &skv = *vvit, rs;\n    for (vi::iterator vit = skv.begin(); vit != skv.end(); vit++) {\n      int r = rec(*vit);\n      //printf(\"rec(%d)=%d\\n\", *vit, r);\n      if (r >= INF) {\n\trs.clear();\n\tbreak;\n      }\n      rs.push_back(r);\n    }\n\n    if (! rs.empty()) {\n      sort(rs.begin(), rs.end(), greater<int>());\n      int maxn = 0;\n      for (int i = 0; i < rs.size(); i++) {\n\tint sum = rs[i] + i;\n\tif (maxn < sum) maxn = sum;\n      }\n      if (minn > maxn) minn = maxn;\n    }\n  }\n\n  used[k] = false;\n  return (dp[k] = minn);\n}\n\n/* main */\n\nint main() {\n  int n, en, t;\n  cin >> n >> en >> t;\n  t--;\n\n  for (int i = 0; i < n; i++) cin >> wis[i];\n  //for (int i = 0; i < n; i++) printf(\"%d \", wis[i]); putchar('\\n');\n\n  for (int i = 0; i < en; i++) {\n    int gi, ci;\n    cin >> gi >> ci;\n    gi--;\n    \n    vi si;\n    for (int j = 0; j < ci; j++) {\n      int sj;\n      cin >> sj;\n      sj--;\n      si.push_back(sj);\n    }\n\n    ss[gi].push_back(si);\n  }\n\n  for (int i = 0; i < n; i++) dp[i] = -1;\n\n  int minn = rec(t);\n  printf(\"%d\\n\", (minn >= INF) ? -1 : minn);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t, g[300], dp[300];\nbool ok[300];\nvi s[1000];\n\nint main(){\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint k, a;\n\t\tcin >> g[i] >> k; g[i]--;\n\t\trep(j, k) cin >> a, s[i].pb(a - 1);\n\t}\n\trep(i, n) dp[i] = ok[i] ? 1 : inf;\n\trep(it, n) rep(i, e){\n\t\tint dp2[300], res = 0;\n\t\trep(j, s[i].size()) dp2[j] = dp[s[i][j]];\n\t\tsort(dp2, dp2 + s[i].size(), greater<int>());\n\t\trep(j, s[i].size()) res = max(res, j + dp2[j]);\n\t\tdp[g[i]] = min(dp[g[i]], res);\n\t}\n\tcout << (dp[t - 1] >= inf ? -1 : dp[t - 1]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int INF = 1000000000;\n\nclass Rule : public vector<int>{\n\tpublic:\n\tint parent;\n};\n\n\nint n,e,t;\nvector<int> dp;\nvector<Rule> rule; \n\nbool input(){\n\tcin>>n>>e>>t;\n\tt--;\n\tdp.resize(n);\n\trule.resize(e);\n\t\n\trep(i,n)cin>>dp[i];\n\trep(i,e){\n\t\tcin>>rule[i].parent;\n\t\trule[i].parent--;\n\t\tint a;\n\t\tcin>>a;\n\t\trule[i].resize(a);\n\t\trep(j,a){\n\t\t\tcin>>rule[i][j];\n\t\t\trule[i][j]--;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\n\nint solve(){\n\t\n\twhile(1){\n\t\tint mini = INF;\n\t\tint minp = -1;\n\t\t\n\t\trep(i,e){\n\t\t\tif(dp[rule[i].parent]==0){\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j,rule[i].size())if(dp[rule[i][j]]==0)ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tint valA = 0;\n\t\t\t\t\trep(j,rule[i].size()) valA = max(valA, dp[rule[i][j]]);\n\t\t\t\t\t\n\t\t\t\t\tint valB = INF;\n\t\t\t\t\trep(j,rule[i].size()) valB = min(valB, dp[rule[i][j]]);\n\t\t\t\t\t\n\t\t\t\t\tint value = max(valA, valB + (int)rule[i].size()-1);\n\t\t\t\t\tif(mini > value){\n\t\t\t\t\t\tmini = value;\n\t\t\t\t\t\tminp = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minp==-1)break;\n\t\t\n\t\tdp[rule[minp].parent] = mini;\n\t}\n\t/*\n\trep(i,n){\n\t\tprintf(\"%d | %d\\n\",i,dp[i]);\n\t}*/\n\t\n\tif(dp[t]==0)return -1;\n\treturn dp[t];\n}\n\nvoid call(){\n\tcout<<solve()<<endl;\n}\n\nint main(){\n\tinput();call();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n\nconst int inf = 1<<29;\nint n,e,t;\nint w[301], memo[301];\nbool seen[301];\n\nvector<pair<int,vector<int> > > production;\n\nint main() {\n    ios::sync_with_stdio(false);\n    memset(seen, false, sizeof(seen));\n\n    cin>>n>>e>>t;\n    rep(i,301) memo[i] = -1;\n    rep(i,n) cin>>w[i];\n    rep(i,e) {\n        int g,c;\n        cin>>g>>c;\n        vector<int> v(c);\n        rep(j,c) {\n            cin>>v[j];\n            v[j]--;\n        }\n        production.push_back(make_pair(g-1,v));\n    }\n\n    rep(i,n) if(w[i] == 1) memo[i] = 1;\n\n    while(true) {\n        bool update = false;\n\n        rep(i,production.size()) {\n            bool ok = true;\n            vector<int> &vs = production[i].second, h;\n            rep(j,vs.size()) {\n                if(memo[vs[j]] == -1) {\n                    ok = false;\n                    break;\n                }\n                h.push_back(memo[vs[j]]);\n            }\n\n            if(ok) {\n                sort(h.begin(), h.end(), greater<int>());\n                int r = 0;\n                rep(j,h.size()) r = max(r,j+h[j]);\n\n                if(memo[production[i].first] == -1 ||\n                   memo[production[i].first] > r) {\n                    memo[production[i].first] = r;\n                    update = true;\n                }\n            }\n        }\n\n        if(!update) break;\n    }\n\n    cout<<memo[t-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvi w(n);\n\trep(i, n)cin >> w[i];\n\tvector<pair<int, vi>> g(e);\n\trep(i, e) {\n\t\tcin >> g[i].first;\n\t\tg[i].first--;\n\t\tint c;\n\t\tcin >> c;\n\t\tg[i].second.resize(c);\n\t\trep(j, c) {\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tg[i].second[j] = s - 1;\n\t\t}\n\t}\n\tvector<vi> add(n);\n\tvi m(e);\n\tvi cost = w;\n\trep(i, n)if (cost[i] == 0)cost[i] = 1e9;\n\theap<pii> q;\n\trep(i, e) {\n\t\tfor (auto x : g[i].second)add[x].push_back(i);\n\t}\n\trep(i, n)if (w[i]) {\n\t\tfor (auto x : add[i]) {\n\t\t\tm[x]++;\n\t\t\tif (m[x] == g[x].second.size())q.emplace(m[x], g[x].first);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tauto a = q.top(); q.pop();\n\t\tif (cost[a.second]<=a.first)continue;\n\t\tcost[a.second] = a.first;\n\t\tfor (auto x : add[a.second]) {\n\t\t\tm[x]++;\n\t\t\tif (m[x] == g[x].second.size()) {\n\t\t\t\tvi cl;\n\t\t\t\tfor (auto y : g[x].second)cl.push_back(cost[y]);\n\t\t\t\tsort(ALL(cl), greater<>());\n\t\t\t\tint c = 0;\n\t\t\t\trep(i, cl.size())cmax(c, i + cl[i]);\n\t\t\t\tq.emplace(c, g[x].first);\n\t\t\t}\n\t\t}\n\t}\n\tt--;\n\tif (cost[t] == 1e9)cout << -1 << endl;\n\telse cout << cost[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N);\n\tfor (int i = 0; i < N; ++i) cin >> W[i];\n\tvector<int> G(E);\n\tvector<vector<int> > S(E);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint num;\n\t\tcin >> G[i] >> num; --G[i];\n\t\tS[i].resize(num);\n\t\tfor (int j = 0; j < num; ++j) {\n\t\t\tcin >> S[i][j]; --S[i][j];\n\t\t}\n\t}\n\tvector<int> ans(N, inf);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (W[i] == 1) ans[i] = 1;\n\t}\n\twhile (true) {\n\t\t// at most N loops\n\t\tvector<int> nxt = ans;\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tvector<int> d;\n\t\t\tfor (int j : S[i]) {\n\t\t\t\td.push_back(ans[j]);\n\t\t\t}\n\t\t\tsort(d.begin(), d.end(), greater<int>());\n\t\t\tif (d[0] == inf) continue;\n\t\t\tint sub = 0;\n\t\t\tfor (int j = 0; j < d.size(); ++j) {\n\t\t\t\tsub = max(sub, d[j] + j);\n\t\t\t}\n\t\t\tnxt[G[i]] = min(nxt[G[i]], sub);\n\t\t}\n\t\tif (ans == nxt) break;\n\t\tans = nxt;\n\t}\n\tcout << (ans[T] != inf ? ans[T] : -1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int inf = 1000000;\n    int n,e,t;\n    cin >> n >> e >> t;\n    vector<int>dp(n,inf);\n    for(int i=0;i<n;i++){\n        int w;\n        cin >> w;\n        if(w==1){\n            dp[i] = 1;\n        }\n    }\n    vector<pair<int,vector<int> > >rec;\n    for(int i=0;i<e;i++){\n        int g,c;\n        cin >> g >> c;\n        g--;\n        vector<int> v(c);\n        for(int j=0;j<c;j++){\n            cin >> v[j];\n            v[j]--;\n        }\n        rec.push_back(make_pair(g,v));\n    }\n    bool flag =1;\n    while(flag){\n        flag = 0;\n        for(auto& x:rec){\n            bool fflag = 1;\n            int mx = 0;\n            int cnt = 0;\n            for(auto& s:x.second){\n                if(dp[s]!=inf){\n                    if(mx==dp[s]){\n                        cnt++;\n                    }else if(mx<dp[s]){\n                        cnt = 1;\n                        mx = dp[s];\n                    }\n                }else{\n                    fflag = 0;\n                }\n            }\n            if(fflag){\n                if(dp[x.first]>max(mx+cnt-1,(int)x.second.size())){\n                    flag = 1;\n                    // cout << mx << endl;\n                    // cout << cnt << endl;\n                    dp[x.first] = max(mx+cnt-1,(int)x.second.size());\n                    //cout << x.first << \" \" << dp[x.first] << endl;\n                }\n            }\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << dp[i] << \" \";\n    // }\n    // cout << endl;\n    if(dp[t-1]!=inf){\n        cout << dp[t-1] << endl;\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> cost;\nvector<vector<vector<int>>> g;\nset<int> nowuse;\n\nvoid calcost(int ind){\n    if(nowuse.find(ind)!=nowuse.end())return;\n    nowuse.insert(ind);\n    for(auto ng:g[ind]){\n        vector<int> d;\n        for(auto tg:ng){\n            if(cost[tg]==-1)calcost(tg);\n            d.emplace_back(cost[tg]);\n        }\n        sort(d.rbegin(),d.rend());\n        int ans=0;\n        for (int i = 0; i < d.size(); ++i) {\n            if(d[i]==-1){\n                ans=-1;\n                break;\n            }\n            ans=max(ans,i+d[i]);\n        }\n        if(cost[ind]==-1)cost[ind]=ans;\n        else cost[ind]=min(cost[ind],ans);\n    }\n    nowuse.erase(ind);\n}\n\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    --t;\n    cost.assign(n,-1);\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin>>a;\n        if(a==1){\n            cost[i]=1;\n            if(i==t){\n                cout<<1<<endl;\n                return 0;\n            }\n        }\n    }\n    g.resize(n);\n    for (int i = 0; i < e; ++i) {\n        int gn,cn;\n        cin>>gn>>cn;\n        --gn;\n        vector<int> t(cn);\n        for (int j = 0; j < cn; ++j) {\n            cin>>t[j];\n            --t[j];\n        }\n        g[gn].push_back(t);\n    }\n    for (int i = 0; i < n; ++i) {\n        if(cost[i]!=-1)continue;\n        calcost(i);\n    }\n    cout<<cost[t]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint memo[310];\n\nbool easy[310];\nvector<vi> recipe[310];\n\nint rec(int v){\n\tint& res=memo[v];\n\tif(res!=-2) return res;\n\tif(easy[v]) return res=1;\n\n\tres=-1;\n\tfor(auto &r:recipe[v]){\n\t\tbool ok=true;\n\t\tvi cost;\n\t\tfor(auto &i:r){\n\t\t\tint add=rec(i);\n\t\t\tif(add==-1) ok=false;\n\t\t\tcost.pb(add);\n\t\t}\n\t\tif(!ok) continue;\n\t\tint cur=0,m=cost.size();\n\t\tsort(cost.begin(),cost.end());\n\t\trep(i,m) cur=max(cur,cost[i]+(m-1-i));\n\t\tif(res==-1||res>cur) res=cur;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n,e,t;\n\tcin >> n >> e >> t;\n\trep(i,n) cin >> easy[i];\n\trep(i,e){\n\t\tvi in;\n\t\tint g,c;\n\t\tcin >> g >> c;\n\t\trep(j,c){\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tin.pb(s-1);\n\t\t}\n\t\trecipe[g-1].pb(in);\n\t}\n\trep(i,n) memo[i]=-2;\n\tcout << rec(t-1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 300;\nconst int INF = 1 << 29;\n\nint n, m, goal, memo[N];\nvector<vector<int> > mixv[N];\nbool w[N], f[N];\n\nint func(int pos){\n  int res = INF;\n\n  if(w[pos]) return 1;\n  if(memo[pos] != -1) return memo[pos];\n  if(f[pos]) return INF;\n  \n  for(int i=0;i<mixv[pos].size();i++){\n    int max_next = 0, res_max_next = 0;\n    vector<int> nextv;\n    f[pos] = true;\n    for(int j=0;j<mixv[pos][i].size();j++){\n      int next = func(mixv[pos][i][j]);\n      if(next >= INF){\n        max_next = INF;\n        break;\n      }\n      nextv.push_back(next);\n    }    \n    f[pos] = false;\n    if(max_next == INF) continue;\n\n    sort(nextv.begin(), nextv.end());\n    res_max_next = max_next = nextv[nextv.size()-1];\n    for(int j=nextv.size()-1;j>0;j--){\n      if(nextv[j] == nextv[j-1]) {\n        max_next++;\n        res_max_next = max(res_max_next, max_next);\n      } else {\n        //cout << nextv[j] << ' ' << nextv[j-1] << endl;\n        max_next = max(0, max_next - (nextv[j] - nextv[j-1] - 1));\n      }\n    }\n    //max_next = max(max_next, nextv[nextv.size()-1]);\n    res = min(res, res_max_next);\n  }\n\n  if(res < INF) memo[pos] = res;\n\n  return res;\n}\n\nint solve(){\n  int res;\n  fill(f, f+n, false);\n  fill(memo, memo+n, -1);\n  res = func(goal);\n  return res >= INF ? -1 : res;\n}\n\nint main(){\n  int a, b, c;\n  while(cin >> n >> m >> goal){\n    goal--;\n    for(int i=0;i<n;i++) {\n      cin >> w[i];\n      mixv[i].clear();\n    }\n    for(int i=0;i<m;i++){\n      vector<int> v;\n      cin >> a >> b;\n      for(int j=0;j<b;j++){\n        cin >> c;\n        v.push_back(c-1);\n      }\n      mixv[a-1].push_back(v);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Law {\n\tint G;\n\tvector<int> S;\n};\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, E, T;\n\tcin >> N >> E >> T; --T;\n\tvector<int> W(N); cin >> W;\n\tvector<Law> law;\n\tREP(i, E) {\n\t\tint G, C; cin >> G >> C; --G;\n\t\tvector<int> S(C); cin >> S;\n\t\tREP(i, C) S[i]--;\n\t\tlaw.pb( (Law){G, S} );\n\t}\n\tvector<int> dp(N, inf);\n\tREP(i, N) {\n\t\tif (W[i] == 1) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t}\n\tREP(t, 100) REP(i, N) REP(j, E) {\n\t\tint M = 0, m = inf;\n\t\tvector<int> a(law[j].S.size());\n\t\tREP(k, law[j].S.size()) {\n\t\t\tint id = law[j].S[k];\n\t\t\ta[k] = dp[id];\n\t\t}\n\t\tsort( ALL(a), greater<int>() );\n\t\tint c = 1;\n\t\tREP(i, a.size()) {\n\t\t\tc = max(c, a[i]+(int)i);\n\t\t}\n\t\tif (c < dp[law[j].G]) {\n\t\t\tdp[law[j].G] = c;\n\t\t}\n\t}\n\tif (dp[T] == inf) cout << -1 << endl;\n\telse cout << dp[T] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\n\nint main()\n{\n  int N, E, T, W[300];\n  vector< vector< int > > g[300];\n\n  cin >> N >> E >> T;\n  --T;\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  for(int i = 0; i < E; i++) {\n    int G, C;\n    cin >> G >> C;\n    --G;\n    vector< int > vv;\n    for(int j = 0; j < C; j++) {\n      int S;\n      cin >> S;\n      --S;\n      vv.push_back(S);\n    }\n    g[G].push_back(vv);\n  }\n\n  int dp[300];\n  fill_n(dp, 300, INF);\n  for(int k = 0; k < N; k++) if(W[k] == 1) dp[k] = 0;\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      if(dp[j] != INF) continue;\n      for(auto &k : g[j]) {\n        int all = 0;\n        bool beet = true;\n        for(auto &l : k) {\n          if(dp[l] == INF) beet = false;\n        }\n        if(!beet) continue;\n        vector< int > vs;\n        for(auto &l : k) {\n          vs.push_back(dp[l]);\n        }\n        sort(vs.rbegin(), vs.rend());\n        for(int l = 0; l < vs.size(); l++) {\n          all = max(all, vs[l] + l);\n        }\n        dp[j] = min(dp[j], all);\n      }\n    }\n  }\n\n  if(dp[T] == INF) {\n    cout << -1 << endl;\n  } else {\n    cout << dp[T] + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint INF=1e8;\nint main(){\n    int n,e,t;\n    cin>>n>>e>>t;\n    t--;\n    vector<int> dp(n,INF);\n    for(int i=0;i<n;i++){\n        int w;\n        cin>>w;\n        if(w){\n            dp[i]=1;\n        }\n    }\n    vector<int> g(e);\n    vector<vector<int>> s(e);\n    for(int i=0;i<e;i++){\n        cin>>g[i];\n        g[i]--;\n        int c;\n        cin>>c;\n        s[i].assign(c,0);\n        for(int j=0;j<c;j++){\n            cin>>s[i][j];\n            s[i][j]--;\n        }\n    }\n    bool update=true;\n    while(update){\n        update=false;\n        for(int j=0;j<e;j++){\n            int ma=0;\n            int mi=INF;\n            bool isok=false;\n            for(int k=0;k<s[j].size();k++){\n                mi=min(mi,dp[s[j][k]]);\n                ma=max(ma,dp[s[j][k]]);\n            }\n            int sc=max(int(s[j].size()+mi-1),ma);\n            if(sc<dp[g[j]]){\n                dp[g[j]]=sc;\n                update=true;\n            }\n        }\n    }\n    if(dp[t]>=INF){\n        cout<<-1<<endl;\n    }\n    else{\n        cout<<dp[t]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\n//const int max_n = 1 << 22;\n//modint fact[max_n], factinv[max_n];\n//void init_f() {\n//\tfact[0] = modint(1);\n//\tfor (int i = 0; i < max_n - 1; i++) {\n//\t\tfact[i + 1] = fact[i] * modint(i + 1);\n//\t}\n//\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n//\tfor (int i = max_n - 2; i >= 0; i--) {\n//\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n//\t}\n//}\n//modint comb(int a, int b) {\n//\tif (a < 0 || b < 0 || a < b)return 0;\n//\treturn fact[a] * factinv[b] * factinv[a - b];\n//}\n\nint n, e, t;\nint g[1000];\nint c[1000];\nvector<int> v[1000];\nll dp[300];\nvoid solve() {\n\tcin >> n >> e >> t; t--;\n\tpriority_queue<LP, vector<LP>, greater<LP>>q;\n\tfill(dp, dp + n, mod);\n\trep(i, n) {\n\t\tint w; cin >> w;\n\t\tif (w) {\n\t\t\tdp[i] = 1;\n\t\t\tq.push({ 1,i });\n\t\t}\n\t}\n\trep(i, e) {\n\t\tcin >> g[i]; g[i]--;\n\t\tcin >> c[i];\n\t\trep(j, c[i]) {\n\t\t\tint x; cin >> x; x--;\n\t\t\tv[i].push_back(x);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tLP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\tif (p.first > dp[id])continue;\n\t\trep(i, e) {\n\t\t\tbool exi = false;\n\t\t\tfor (int x : v[i]) {\n\t\t\t\tif (id == x)exi = true;\n\t\t\t}\n\t\t\tif (!exi)continue;\n\t\t\tvector<ll> b;\n\t\t\tfor (int x : v[i])b.push_back(dp[x]);\n\t\t\tsort(all(b), greater<ll>());\n\t\t\tll ma = 0;\n\t\t\trep(j, b.size()) {\n\t\t\t\tma = max(ma, b[j] + j);\n\t\t\t}\n\t\t\tif (ma < dp[g[i]]) {\n\t\t\t\tdp[g[i]] = ma;\n\t\t\t\tq.push({ ma,g[i] });\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, n)cout << dp[i] << endl;\n\tll ans = dp[t];\n\tif (ans == mod)ans = -1;\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, e, t, g[300], dp[300];\nbool ok[300];\nvi s[1000];\n\nint main(){\n\tcin >> n >> e >> t;\n\trep(i, n) cin >> ok[i];\n\trep(i, e){\n\t\tint k, a;\n\t\tcin >> g[i] >> k; g[i]--;\n\t\trep(j, k) cin >> a, s[i].pb(a - 1);\n\t}\n\trep(i, n) dp[i] = ok[i] ? 1 : inf;\n\trep(it, n) rep(i, e){\n\t\tint dp2[300], &res = dp[g[i]];\n\t\trep(j, s[i].size()) dp2[j] = dp[s[i][j]];\n\t\tsort(dp2, dp2 + s[i].size(), greater<int>());\n\t\tres = 0;\n\t\trep(j, s[i].size()) res = max(res, j + dp2[j]);\n\t}\n\tcout << dp[t - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\nint N,E,T;\nint sar[310];\npair<int,vector<int>> gen[1010];\n\nsigned main() {\n    cin>>N>>E>>T;\n    minheap<pii> hp;\n    for(int i=1; i<=N; ++i) {\n        int w; cin>>w;\n        if(w) sar[i]=1;\n        else sar[i]=inf<int>;\n    }\n    rep(i,E) {\n        int g,c; cin>>g>>c;\n        gen[i].fir=g;\n        rep(j,c) {\n            int x; cin>>x;\n            gen[i].sec.emplace_back(x);\n        }\n    }\n    for(int t=1; t<=N; ++t) {\n        for(int i=0; i<E; ++i) {\n            int tmp=0;\n            int num=0;\n            priority_queue<int> pq;\n            for(auto &x:gen[i].sec) {\n                pq.emplace(sar[x]);\n            }\n            while(!pq.empty()) {\n                tmp=max(tmp,pq.top()+num);\n                num++;\n                pq.pop();\n            }\n            chmin(sar[gen[i].fir],tmp);\n        }\n    }\n    if(sar[T]>=inf<int>) esc(-1);\n    esc(sar[T]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,t;\n  cin>>n>>m>>t;\n  t--;\n  vector<Int> w(n);\n  for(Int i=0;i<n;i++) cin>>w[i];\n\n  vector<Int> g(m);\n  vector<vector<Int> > R;\n  for(Int i=0;i<m;i++){\n    Int c;\n    cin>>g[i]>>c;\n    g[i]--;\n    R.emplace_back(vector<Int>(c));\n    for(Int j=0;j<c;j++)\n      cin>>R.back()[j],R.back()[j]--;\n  }\n  const Int INF = 1e9;\n  vector<Int> dp(n,INF);\n  for(Int i=0;i<n;i++) if(w[i]) dp[i]=1;\n\n  auto comp=[&](Int i,Int j){return dp[i]>dp[j];};\n  while(1){\n    Int flg=0;\n    for(Int i=0;i<m;i++){\n      Int ok=1;\n      for(auto x:R[i]) ok&=dp[x]<INF;\n      if(!ok) continue;\n      Int tmp=0;\n      sort(R[i].begin(),R[i].end(),comp);\n      for(Int j=0;j<(Int)R[i].size();j++)\n\tchmax(tmp,j+dp[R[i][j]]);g\n      \n      if(tmp<dp[g[i]]){\n\tdp[g[i]]=tmp;\n\tflg=1;\n      }\n    }\n    if(!flg) break;\n  }\n  \n  if(dp[t]>=INF) dp[t]=-1;\n  cout<<dp[t]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint N, E, T;\nvector<int> W;\nvector<int> C;\nvector<vector<int> > S;\nint main() {\n  cin >> N >> E >> T;\n  W.resize(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  for(int i = 0; i < N; ++i) if(W[i] == 0) W[i] = INF;\n  S.resize(E);\n  C.resize(E);\n  for(int i = 0; i < E; ++i) {\n    int G;\n    cin >> C[i] >> G;\n    C[i] -= 1;\n    S[i].resize(G);\n    for(int j = 0; j < G; ++j) {\n      cin >> S[i][j];\n      S[i][j] -= 1;\n    }\n  }\n\n  bool update = true;\n  while(update) {\n    update = false;\n    for(int i = 0; i < E; ++i) {\n      int maxi = -1;\n      for(int j = 0; j < S[i].size(); ++j) {\n\tmaxi = max(maxi, W[S[i][j]]);\n      }\n      int newvalue = max(maxi, (int)S[i].size());\n      if(W[C[i]] > newvalue) {\n\tupdate = true;\n\tW[C[i]] = newvalue;\n      }\n    }\n  }\n  cout << W[T-1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,t;\n  cin>>n>>m>>t;\n  t--;\n  vector<Int> w(n);\n  for(Int i=0;i<n;i++) cin>>w[i];\n\n  vector<Int> g(m);\n  vector<vector<Int> > R;\n  for(Int i=0;i<m;i++){\n    Int c;\n    cin>>g[i]>>c;\n    g[i]--;\n    R.emplace_back(vector<Int>(c));\n    for(Int j=0;j<c;j++)\n      cin>>R.back()[j],R.back()[j]--;\n  }\n  const Int INF = 1e9;\n  vector<Int> dp(n,INF);\n  for(Int i=0;i<n;i++) if(w[i]) dp[i]=1;\n\n  auto comp=[&](Int i,Int j){return dp[i]>dp[j];};\n  while(1){\n    Int flg=0;\n    for(Int i=0;i<m;i++){\n      Int ok=1;\n      for(auto x:R[i]) ok&=dp[x]<INF;\n      if(!ok) continue;\n      Int tmp=0;\n      sort(R[i].begin(),R[i].end(),comp);\n      for(Int j=0;j<(Int)R[i].size();j++)\n\tchmax(tmp,j+dp[R[i][j]]);\n      \n      if(tmp<dp[g[i]]){\n\tdp[g[i]]=tmp;\n\tflg=1;\n      }\n    }\n    if(!flg) break;\n  }\n  \n  if(dp[t]>=INF) dp[t]=-1;\n  cout<<dp[t]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint N,E,T;\n\nint gen[303];\n\nvector<vector<int>> G[303];\n\nint main(){\n    cin >> N >> E >> T;\n    for(int i = 1;i <= N;i++){\n        cin >> gen[i];\n    }\n    for(int i = 0;i < E;i++){\n        int g,c;\n        cin >> g >> c;\n        G[g].push_back(vector<int>(c,0));\n        for(auto& a : G[g].back()){\n            cin >> a;\n        }\n    }\n\n    vector<i64> dp(N + 1,1e9);\n    for(int i = 1;i <= N;i++){\n        if(gen[i]) dp[i] = 1;\n    }\n\n    for(int i = 0;i < N;i++){\n        for(int v = 1;v <= N;v++){\n            for(auto& g : G[v]){\n                vector<i64> temp;\n                for(int & chi : g){\n                    temp.push_back(dp[chi]);\n                }\n                sort(temp.rbegin(),temp.rend());\n                i64 res = 0;\n                for(int c = 0;c < temp.size();c++){\n                    res = max(res,temp[c] + c);\n                }\n                res = max(res , (i64)g.size());\n                dp[v] = min(dp[v],res);\n            }\n        }\n    }\n    if(dp[T] >= 1e9) dp[T] = -1;\n    cout << dp[T] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 300;\n\nint n,e,t;\nint w[N];\nvector<vector<int>> rule[N];\n\nconst int INF = 19191919;\nint dp[N];\n\nint main(){\n    cin >>n >>e >>t;\n    --t;\n\n    rep(i,n) cin >>w[i];\n\n    rep(i,e){\n        int g,c;\n        cin >>g >>c;\n        --g;\n\n        vector<int> s(c);\n        rep(j,c){\n            cin >>s[j];\n            --s[j];\n        }\n        rule[g].pb(s);\n    }\n\n    fill(dp,dp+N,INF);\n    rep(i,n)if(w[i]==1) dp[i]=1;\n\n    rep(loop,n){\n        rep(i,n){\n            for(vector<int> r:rule[i]){\n                int sz = r.size();\n\n                vector<int> v;\n                for(int nx:r) v.pb(dp[nx]);\n                sort(all(v));\n\n                bool ok = true;\n                rep(j,sz)if(v[j]==INF) ok=false;\n                if(ok){\n                    int tmp = 0;\n                    rep(j,sz) tmp = max(tmp, v[j]+(sz-1-j));\n                    dp[i] = min(dp[i], tmp);\n                }\n            }\n        }\n    }\n\n    int ans = dp[t];\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1e9;\n\nint main()\n{\n\tfor(int n,e,t;cin>>n>>e>>t && n|e|t;){\n\t\tt--;\n\t\tvector<int> obtainable(n);\n\t\tfor(int& x:obtainable) cin>>x;\n\t\tvector<vector<int>> rules(e);\n\t\tfor(int i=0;i<e;i++){\n\t\t\tint v,m; cin>>v>>m; v--;\n\t\t\trules[i].push_back(v);\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin>>v; v--;\n\t\t\t\trules[i].push_back(v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> dp(n,INF);\n\t\tfor(int i=0;i<n;i++) if(obtainable[i]) dp[i]=1;\n\t\tfor(int k=0;k<n-1;k++){\n\t\t\tfor(auto rule:rules){\n\t\t\t\tvector<int> tmp(rule.size()-1);\n\t\t\t\ttransform(begin(rule)+1,end(rule),begin(tmp),[&](int i){return dp[i];});\n\t\t\t\tif(count(begin(tmp),end(tmp),0)) continue;\n\t\t\t\tsort(begin(tmp),end(tmp),greater<int>());\n\t\t\t\tint u=rule[0],mx=0;\n\t\t\t\tfor(int i=0;i<tmp.size();i++)\n\t\t\t\t\tmx=max(mx,i+tmp[i]);\n\t\t\t\tdp[u]=min(dp[u],mx);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<(dp[t]==INF?-1:dp[t])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, e, t;\n\tcin >> n >> e >> t;\n\tvi w(n);\n\trep(i, n)cin >> w[i];\n\tvector<pair<int, vi>> g(n);\n\trep(i, e) {\n\t\tcin >> g[i].first;\n\t\tg[i].first--;\n\t\tint c;\n\t\tcin >> c;\n\t\tg[i].second.resize(c);\n\t\trep(j, c) {\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tg[i].second[j] = s - 1;\n\t\t}\n\t}\n\tvector<vi> add(n);\n\tvi m(e);\n\tvi cost = w;\n\trep(i, n)if (cost[i] == 0)cost[i] = 1e9;\n\tpriority_queue<pii> q;\n\trep(i, e) {\n\t\tfor (auto x : g[i].second)add[x].push_back(i);\n\t}\n\trep(i, n)if (w[i]) {\n\t\tfor (auto x : add[i]) {\n\t\t\tm[x]++;\n\t\t\tif (m[x] == g[x].second.size())q.emplace(m[x], g[x].first);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tauto a = q.top(); q.pop();\n\t\tif (cost[a.second]<=a.first)continue;\n\t\tcost[a.second] = a.first;\n\t\tfor (auto x : add[a.second]) {\n\t\t\tm[x]++;\n\t\t\tif (m[x] == g[x].second.size()) {\n\t\t\t\tvi cl;\n\t\t\t\tfor (auto y : g[x].second)cl.push_back(cost[y]);\n\t\t\t\tsort(ALL(cl), greater<>());\n\t\t\t\tint c = 0;\n\t\t\t\trep(i, cl.size())cmax(c, i + cl[i]);\n\t\t\t\tq.emplace(c, g[x].first);\n\t\t\t}\n\t\t}\n\t}\n\tt--;\n\tif (cost[t] == 1e9)cout << -1 << endl;\n\telse cout << cost[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[310];\nint d[310];\nint b;\nvector<int> g[1100];\nvector<int>h[310];\nint to[1100];\nint calc(int a,int dep){\n\tif(~dp[a])return dp[a];\n\tif(d[a])return dp[a]=1;\n\tif(dep==500)return 999999999;\n\tint ret=999999999;\n\tfor(int i=0;i<h[a].size();i++){\n\t\tvector<int>res;\n\t\tint at=h[a][i];\n\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\tres.push_back(calc(g[at][j],dep+1));\n\t\t}\n\t\tstd::sort(res.begin(),res.end());\n\t\tint t=0;\n\t\tfor(int j=0;j<res.size();j++)t=max(t,res[j]+(int)(res.size()-1-j));\n\t\tret=min(ret,t);\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",d+i);\n\tfor(int i=0;i<a;i++)dp[i]=-1;\n\tfor(int i=0;i<b;i++)g[i].clear();\n\tfor(int i=0;i<a;i++)h[i].clear();\n\tfor(int i=0;i<b;i++){\n\t\tint p;\n\t\tscanf(\"%d%d\",to+i,&p);\n\t\tto[i]--;\n\t\th[to[i]].push_back(i);\n\t\tfor(int j=0;j<p;j++){\n\t\t\tint q;scanf(\"%d\",&q);\n\t\t\tq--;g[i].push_back(q);\n\t\t}\n\t}\n\tint ret=calc(c-1,0);\n\tif(ret>99999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n#define MAX_N 305\n#define MAX_E 1005\nint N,E,T;\nint W[MAX_N];\nint dp[MAX_N];\n\nvector<int> S[MAX_E];\nint G[MAX_E];\n\nvoid init(){\n  for(int i=0;i<MAX_E;i++)S[i].clear();\n}\n\nint solve(){\n  for(int i=0;i<N;i++){\n    if(W[i]==1)dp[i]=1;\n    else dp[i]=INF;\n  }\n  vector<int> vec;\n\n  bool update=true;\n  while(update){\n    update=false;\n    for(int i=0;i<E;i++){\n\n      vec.clear();\n      for(int j=0;j<(int)S[i].size();j++){\n\tint x=S[i][j];\n\tvec.push_back(dp[x]);\n      }\n      sort(vec.begin(),vec.end());\n      reverse(vec.begin(),vec.end());\n\n      int cost=vec[0];\n      for(int j=1;j<(int)vec.size();j++){\n\tcost=max(cost,vec[j]+j);\n      }\n\n      if(dp[G[i]]>cost){\n\tdp[G[i]]=cost;\n\tupdate=true;\n      }\n      \n    }//i\n  }//while\n\n  if(dp[T]==INF)return -1;\n  else return dp[T];\n}\n\nint main(){\n  while(cin>>N>>E>>T){\n    T--;\n    init();\n    for(int i=0;i<N;i++)cin>>W[i];\n    for(int i=0;i<E;i++){\n      int c;\n      cin>>G[i]>>c;\n      G[i]--;\n      S[i].resize(c);\n      for(int j=0;j<c;j++){\n\tcin>>S[i][j];\n\tS[i][j]--;\n      }\n    }\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int N, E, T;\n  cin >> N >> E >> T;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector<int> G(E), C(E);\n  vector<vector<int>> S(E);\n  for(int i = 0; i < E; ++i){\n    cin >> G[i] >> C[i];\n    for(int j = 0; j < C[i]; ++j){\n      int s;\n      cin >> s;\n      S[i].push_back(s);\n    }\n  }\n\n  for(int i = 0; i < N; ++i)\n    if(not W[i])\n      W[i] = 1e9;\n  \n  vector<bool> checked(E,false);\n  int c = 0;\n  for(int i = 0; i < E; ++i){\n    for(int j = 0; j < E; ++j){\n      if(checked[j]) continue;\n      bool f = true;\n      for(int k = 0; k < C[j]; ++k)\n        if(W[S[j][k]] >= INF){\n          f = false;\n          break;\n        }\n      if(not f) continue;\n      vector<int> T;\n      for(int k = 0; k < C[j]; ++k){\n        T.push_back(W[S[j][k]]);\n      }\n      sort(T.begin(),T.end());\n    }\n  }\n}\n#error \"G\"\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint dp[301];\nint to[1001];\nvector<int> from[1001];\n\nconst int INF=1000000000;\nint main(){\n  int n,e,t;\n  while(cin>>n>>e>>t&&(n|e|t)){\n    for(int i=0;i<1001;i++)from[i].clear();\n    for(int i=1;i<=n;i++){\n      cin>>dp[i];\n      if(dp[i]==0)dp[i]=INF;\n    }\n    for(int i=0;i<e;i++){\n      int g,c;\n      cin>>g>>c;\n      to[i]=g;\n      for(int j=0;j<c;j++){\n\tint s;\n\tcin>>s;\n\tfrom[i].push_back(s);\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<e;j++){\n\tint d[11];\n\t// cost of moving before\n\tfor(int k=0;k<from[j].size();k++)\n\t  d[k]=dp[from[j][k]];\n\t// sort with ordering acending\n\tsort(d,d+(int)from[j].size(),greater<int>());\n\tint maxc=0;\n\tfor(int k=0;k<from[j].size();k++)\n\t  maxc=max(maxc,k+d[k]);\n\tdp[to[j]]=min(dp[to[j]],maxc);\t\n      }\n    }\n    if(dp[t]==INF)cout<<-1<<endl;\n    else cout<<dp[t]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\trun();\n\t}\n\n\tstatic void run() {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), e = sc.nextInt(), t = sc.nextInt() - 1;\n\t\tint[] w = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\t\tint[] g = new int[e];\n\t\tint[] c = new int[e];\n\t\tint[][] s = new int[e][];\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tg[i] = sc.nextInt() - 1;\n\t\t\tc[i] = sc.nextInt();\n\t\t\ts[i] = new int[c[i]];\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\ts[i][j] = sc.nextInt() - 1;\n\t\t\t}\n\t\t}\n\t\tlong[] F = new long[n];\n\t\tArrays.fill(F, 1L << 60);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (w[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < e; j++) {\n\t\t\t\tArrayList<Long> v = new ArrayList<>();\n\t\t\t\tfor (int k = 0; k < s[j].length; k++) {\n\t\t\t\t\tv.add(F[s[j][k]]);\n\t\t\t\t}\n\t\t\t\tv.sort(new Comparator<Long>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\t\treturn -Long.compare(o1, o2);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlong d = 1;\n\t\t\t\tfor (int k = 0; k < s[j].length; k++) {\n\t\t\t\t\tif (d < v.get(k) + k) {\n\t\t\t\t\t\td = k + v.get(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (F[g[j]] > d) {\n\t\t\t\t\tF[g[j]] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (F[t] > (1L << 60))\n\t\t\tSystem.out.println(-1);\n\t\telse\n\t\t\tSystem.out.println(F[t]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\trun();\n\t}\n\n\tstatic void run() {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), e = sc.nextInt(), t = sc.nextInt() - 1;\n\t\tint[] w = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\t\tint[] g = new int[e];\n\t\tint[] c = new int[e];\n\t\tint[][] s = new int[e][];\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tg[i] = sc.nextInt() - 1;\n\t\t\tc[i] = sc.nextInt();\n\t\t\ts[i] = new int[c[i]];\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\ts[i][j] = sc.nextInt() - 1;\n\t\t\t}\n\t\t}\n\t\tlong[] F = new long[n];\n\t\tArrays.fill(F, 1L << 30);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (w[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < e; j++) {\n\t\t\t\tArrayList<Long> v = new ArrayList<>();\n\t\t\t\tfor (int k = 0; k < s[j].length; k++) {\n\t\t\t\t\tv.add(F[s[j][k]]);\n\t\t\t\t}\n\t\t\t\tv.sort(new Comparator<Long>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\t\treturn -Long.compare(o1, o2);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlong d = 1;\n\t\t\t\tfor (int k = 0; k < s[j].length; k++) {\n\t\t\t\t\tif (d < v.get(k) + k) {\n\t\t\t\t\t\td = k + v.get(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (F[g[j]] > d) {\n\t\t\t\t\tF[g[j]] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (F[t] >= (1L << 30))\n\t\t\tSystem.out.println(-1);\n\t\telse\n\t\t\tSystem.out.println(F[t]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\trun();\n\t}\n\n\tstatic void run() {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), e = sc.nextInt(), t = sc.nextInt() - 1;\n\t\tint[] w = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\t\tint[] g = new int[e];\n\t\tint[] c = new int[e];\n\t\tint[][] s = new int[e][];\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tg[i] = sc.nextInt() - 1;\n\t\t\tc[i] = sc.nextInt();\n\t\t\ts[i] = new int[c[i]];\n\t\t\tfor (int j = 0; j < c[i]; j++) {\n\t\t\t\ts[i][j] = sc.nextInt() - 1;\n\t\t\t}\n\t\t}\n\t\tlong[] F = new long[n];\n\t\tArrays.fill(F, 1L << 30);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (w[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < e; j++) {\n\t\t\t\tArrayList<Long> v = new ArrayList<>();\n\t\t\t\tfor (int k = 0; k < s[j].length; k++) {\n\t\t\t\t\tv.add(F[s[j][k]]);\n\t\t\t\t}\n\t\t\t\tv.sort(new Comparator<Long>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\t\treturn -Long.compare(o1, o2);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlong d = 1;\n\t\t\t\tfor (int k = 0; k < s[j].length; k++) {\n\t\t\t\t\tif (d < v.get(k) + k) {\n\t\t\t\t\t\td = k + v.get(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (F[g[j]] > d) {\n\t\t\t\t\tF[g[j]] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (F[t] > (1L << 30))\n\t\t\tSystem.out.println(-1);\n\t\telse\n\t\t\tSystem.out.println(F[t]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.typecons;\nimport std.algorithm;\n\nvoid main(){\n\tint n,e,t;\n\tscanf(\"%d%d%d\",&n,&e,&t);\n\t--t;\n\tlong[] cost = new long[n];\n\tstatic immutable int inf = 1145141919;\n\tbool[] used = new bool[n];\n\tforeach(i;0..n){\n\t\tint w;\n\t\tscanf(\"%d\",&w);\n\t\tif(w==1){\n\t\t\tcost[i]=1;\n\t\t\tused[i]=true;\n\t\t}else\n\t\t\tcost[i]=inf;\n\t}\n\talias Tuple!(long,\"cost\",int,\"g\",int[],\"f\") cgf;\n\tcgf[] rec = new cgf[e];\n\tint[][] h = new int[][n];\n\tvoid CalcCost(ref cgf r){\n\t\tsort!((a,b)=>cost[a]<cost[b])(r.f);\n\t\tr.cost=0;\n\t\tforeach(i,v;r.f)\n\t\t\tr.cost=max(r.cost,r.f.length-i-1+cost[v]);\n\t}\n\tforeach(i;0..e){\n\t\tint c;\n\t\tscanf(\"%d%d\",&rec[i].g,&c);\n\t\trec[i].g--;\n\t\trec[i].f=new int[c];\n\t\tforeach(ref v;rec[i].f){\n\t\t\tscanf(\"%d\",&v);\n\t\t\th[--v]~=i;\n\t\t}\n\t\tCalcCost(rec[i]);\n\t}\n\twhile(cost[t]==inf){\n\t\tcgf mn = cgf(cast(long)inf,-1,[]);\n\t\tforeach(r;rec)\n\t\t\tif(!used[r.g]&&r.cost<mn.cost)\n\t\t\t\tmn=r;\n\t\tif(mn.g==-1){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn;\n\t\t}\n\t\tused[mn.g]=true;\n\t\tcost[mn.g]=mn.cost;\n\t\tforeach(j;h[mn.g])\n\t\t\tCalcCost(rec[j]);\n\t}\n\tprintf(\"%lld\\n\",cost[t]);\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, E, T = map(int, readline().split())\n    *W, = map(int, readline().split())\n    G = [[] for i in range(N)]\n    R = [[] for i in range(N)]\n    C = [0]*E\n    Q = [None]*E\n    for i in range(E):\n        g, c, *s = map(int, readline().split())\n        for e in s:\n            R[e-1].append(i)\n        C[i] = c\n        Q[i] = (g, s)\n    que = []\n    INF = 10**9\n    def calc(s):\n        s.sort(key = lambda x: dp[x-1], reverse=1)\n        r = 0\n        for i, j in enumerate(s):\n            r = max(r, i + dp[j-1])\n        return r\n\n    dp = [INF]*N\n    for i in range(N):\n        if W[i]:\n            dp[i] = 1\n            for j in R[i]:\n                C[j] -= 1\n                if C[j] == 0:\n                    g0, s0 = Q[j]\n                    heappush(que, (calc(s0), j))\n    while que:\n        cost, e = heappop(que)\n        g, s = Q[e]\n        if dp[g-1] < cost:\n            continue\n        if cost < dp[g-1]:\n            dp[g-1] = cost\n            for j in R[g-1]:\n                C[j] -= 1\n                if C[j] <= 0:\n                    g0, s0 = Q[j]\n                    heappush(que, (calc(s0), j))\n    if dp[T-1] != INF:\n        write(\"%d\\n\" % dp[T-1])\n    else:\n        write(\"-1\\n\")\nsolve()\n\n"
  }
]