[
  {
    "language": "Crystal",
    "code": "# ModNum.cr by Koki Takahashi\n# Licensed under MIT License https://mit-license.org\n\nrecord ModNum, value : Int64 do\n  @@factorials = Array(ModNum).new(10_000_i64) # Change here to improve performance\n\n  def self.factorial(n)\n    if @@factorials.empty?\n      @@factorials << ModNum.new(1_i64)\n    end\n    @@factorials.size.upto(n) do |i|\n      @@factorials << @@factorials.last * i\n    end\n    @@factorials[n]\n  end\n\n  def self.permutation(n, k)\n    raise ArgumentError.new(\"k cannot be greater than n\") unless n >= k\n    factorial(n) // factorial(n - k)\n  end\n\n  def self.combination(n, k)\n    raise ArgumentError.new(\"k cannot be greater than n\") unless n >= k\n    permutation(n, k) // @@factorials[k]\n  end\n\n  def self.repeated_combination(n, k)\n    combination(n + k - 1, k)\n  end\n\n  def self.extended_gcd(a, b)\n    last_remainder, remainder = a.abs, b.abs\n    x, last_x, y, last_y = 0_i64, 1_i64, 1_i64, 0_i64\n    while remainder != 0\n      new_last_remainder = remainder\n      quotient, remainder = last_remainder.divmod(remainder)\n      last_remainder = new_last_remainder\n      x, last_x = last_x - quotient * x, x\n      y, last_y = last_y - quotient * y, y\n    end\n\n    return last_remainder, last_x * (a < 0 ? -1 : 1)\n  end\n\n  def self.zero\n    ModNum.new(0_i64)\n  end\n\n  def inv\n    g, x = ModNum.extended_gcd(@value, MOD)\n    ModNum.new(x % MOD)\n  end\n\n  def +(value)\n    ModNum.new((@value + value.to_i64 % MOD) % MOD)\n  end\n\n  def -(value)\n    ModNum.new((@value + MOD - value.to_i64 % MOD) % MOD)\n  end\n\n  def *(value)\n    ModNum.new((@value * value.to_i64 % MOD) % MOD)\n  end\n\n  def /(value : ModNum)\n    raise DivisionByZeroError.new if value == 0\n    self * value.inv\n  end\n\n  def /(value)\n    raise DivisionByZeroError.new if value == 0\n    self * ModNum.new(value.to_i64 % MOD).inv\n  end\n\n  def //(value)\n    self./(value)\n  end\n\n  def **(value)\n    b = value > 0 ? self : self.inv\n    e = value.abs\n    ret = ModNum.new(1_i64)\n    while e > 0\n      if e % 2 == 1\n        ret *= b\n      end\n      b *= b\n      e //= 2\n    end\n    ret\n  end\n\n  def <<(value)\n    self * ModNum.new(2_i64) ** value\n  end\n\n  def sqrt\n    z = ModNum.new(1_i64)\n    until z ** ((MOD - 1) // 2) == MOD - 1\n      z += 1\n    end\n    q = MOD - 1\n    m = 0\n    while q % 2 == 0\n      q //= 2\n      m += 1\n    end\n    c = z ** q\n    t = self ** q\n    r = self ** ((q + 1) // 2)\n    m.downto(2) do |i|\n      tmp = t ** (2 ** (i - 2))\n      if tmp != 1\n        r *= c\n        t *= c ** 2\n      end\n      c *= c\n    end\n    if r * r == self\n      r.to_i64 * 2 <= MOD ? r : -r\n    else\n      nil\n    end\n  end\n\n  def to_i64\n    @value\n  end\n\n  def ==(value : ModNum)\n    @value == value.to_i64\n  end\n\n  def ==(value)\n    @value == value\n  end\n\n  def -\n    ModNum.new(0_i64) - self\n  end\n\n  def +\n    self\n  end\n\n  def abs\n    self\n  end\n\n  # ModNum shouldn't be compared\n  def <(value)\n    raise NotImplementedError.new(\"<\")\n  end\n  def <=(value)\n    raise NotImplementedError.new(\"<=\")\n  end\n  def <(value)\n    raise NotImplementedError.new(\"<\")\n  end\n  def >=(value)\n    raise NotImplementedError.new(\">=\")\n  end\n\n  delegate to_s, to: @value\n  delegate inspect, to: @value\nend\n\n\nMOD = 1_000_000_007_i64\nn, a, b = read_line.split.map(&.to_i64)\nif a < b\n  a, b = b, a\nend\n\ncounts00 = Array(ModNum).new(a, ModNum.new(0_i64))\ncounts10 = Array(ModNum).new(a, ModNum.new(0_i64))\ncounts11 = Array(ModNum).new(a, ModNum.new(0_i64))\n\ncnt = 1_i64\n1_i64.upto(a - 1) do |i|\n  j = 1_i64\n  tmp = ModNum.new(0_i64)\n  until j > 1 && i - (j // 2 * (b + 1) - 1) < 0\n    if j == 1\n      counts11[i] += 1\n    else\n      remain = i - (j // 2 * (b + 1) - 1)\n      r = ModNum.repeated_combination(j - 2, remain)\n      counts00[i] += r\n      if remain >= 1\n        r = r // (j - 2) * remain\n        counts10[i] += r\n      end\n      if remain >= 2\n        r = r // (j - 1) * (remain - 1)\n        counts11[i] += r\n      end\n      cnt += 1\n    end\n    j += 2\n  end\nend\n\ndp = { \n  Array(ModNum).new(n + 1, ModNum.new(0_i64)),\n  Array(ModNum).new(n + 1, ModNum.new(0_i64)),\n}\n\n1_i64.upto(a - 1) do |i|\n  dp[1][i] += counts10[i]\n  dp[1][i] += counts11[i]\nend\n1_i64.upto(b - 1) do |i|\n  dp[0][i] += 1\nend\n\n1_i64.upto(n) do |i|\n  1_i64.upto(a - 1) do |j|\n    if i + j <= n\n      dp[1][i + j] += dp[0][i] * counts11[j]\n    end\n    if i + j == n\n      dp[1][i + j] += dp[0][i] * counts10[j]\n    end\n  end\n  1_i64.upto(b - 1) do |j|\n    if i + j <= n\n      dp[0][i + j] += dp[1][i]\n    end\n  end\nend\np ModNum.new(2_i64) ** n - dp[0][n] - dp[1][n]\n"
  },
  {
    "language": "Crystal",
    "code": "# ModNum.cr by Koki Takahashi\n# Licensed under MIT License https://mit-license.org\n\nrecord ModNum, value : Int64 do\n  @@factorials = Array(ModNum).new(10_000_i64) # Change here to improve performance\n\n  def self.factorial(n)\n    if @@factorials.empty?\n      @@factorials << ModNum.new(1_i64)\n    end\n    @@factorials.size.upto(n) do |i|\n      @@factorials << @@factorials.last * i\n    end\n    @@factorials[n]\n  end\n\n  def self.permutation(n, k)\n    raise ArgumentError.new(\"k cannot be greater than n\") unless n >= k\n    factorial(n) // factorial(n - k)\n  end\n\n  def self.combination(n, k)\n    raise ArgumentError.new(\"k cannot be greater than n\") unless n >= k\n    permutation(n, k) // @@factorials[k]\n  end\n\n  def self.repeated_combination(n, k)\n    combination(n + k - 1, k)\n  end\n\n  def self.extended_gcd(a, b)\n    last_remainder, remainder = a.abs, b.abs\n    x, last_x, y, last_y = 0_i64, 1_i64, 1_i64, 0_i64\n    while remainder != 0\n      new_last_remainder = remainder\n      quotient, remainder = last_remainder.divmod(remainder)\n      last_remainder = new_last_remainder\n      x, last_x = last_x - quotient * x, x\n      y, last_y = last_y - quotient * y, y\n    end\n\n    return last_remainder, last_x * (a < 0 ? -1 : 1)\n  end\n\n  def self.zero\n    ModNum.new(0_i64)\n  end\n\n  def inv\n    g, x = ModNum.extended_gcd(@value, MOD)\n    ModNum.new(x % MOD)\n  end\n\n  def +(value)\n    ModNum.new((@value + value.to_i64 % MOD) % MOD)\n  end\n\n  def -(value)\n    ModNum.new((@value + MOD - value.to_i64 % MOD) % MOD)\n  end\n\n  def *(value)\n    ModNum.new((@value * value.to_i64 % MOD) % MOD)\n  end\n\n  def /(value : ModNum)\n    raise DivisionByZeroError.new if value == 0\n    self * value.inv\n  end\n\n  def /(value)\n    raise DivisionByZeroError.new if value == 0\n    self * ModNum.new(value.to_i64 % MOD).inv\n  end\n\n  def //(value)\n    self./(value)\n  end\n\n  def **(value)\n    b = value > 0 ? self : self.inv\n    e = value.abs\n    ret = ModNum.new(1_i64)\n    while e > 0\n      if e % 2 == 1\n        ret *= b\n      end\n      b *= b\n      e //= 2\n    end\n    ret\n  end\n\n  def <<(value)\n    self * ModNum.new(2_i64) ** value\n  end\n\n  def sqrt\n    z = ModNum.new(1_i64)\n    until z ** ((MOD - 1) // 2) == MOD - 1\n      z += 1\n    end\n    q = MOD - 1\n    m = 0\n    while q % 2 == 0\n      q //= 2\n      m += 1\n    end\n    c = z ** q\n    t = self ** q\n    r = self ** ((q + 1) // 2)\n    m.downto(2) do |i|\n      tmp = t ** (2 ** (i - 2))\n      if tmp != 1\n        r *= c\n        t *= c ** 2\n      end\n      c *= c\n    end\n    if r * r == self\n      r.to_i64 * 2 <= MOD ? r : -r\n    else\n      nil\n    end\n  end\n\n  def to_i64\n    @value\n  end\n\n  def ==(value : ModNum)\n    @value == value.to_i64\n  end\n\n  def ==(value)\n    @value == value\n  end\n\n  def -\n    ModNum.new(0_i64) - self\n  end\n\n  def +\n    self\n  end\n\n  def abs\n    self\n  end\n\n  # ModNum shouldn't be compared\n  def <(value)\n    raise NotImplementedError.new(\"<\")\n  end\n  def <=(value)\n    raise NotImplementedError.new(\"<=\")\n  end\n  def <(value)\n    raise NotImplementedError.new(\"<\")\n  end\n  def >=(value)\n    raise NotImplementedError.new(\">=\")\n  end\n\n  delegate to_s, to: @value\n  delegate inspect, to: @value\nend\n\n\nMOD = 1_000_000_007_i64\nn, a, b = read_line.split.map(&.to_i64)\nif a < b\n  a, b = b, a\nend\n\ncounts00 = Array(ModNum).new(a, ModNum.new(1_i64))\ncounts01 = Array(ModNum).new(a, ModNum.new(0_i64))\ncounts10 = Array(ModNum).new(a, ModNum.new(0_i64))\ncounts11 = Array(ModNum).new(a, ModNum.new(1_i64))\n\n1_i64.upto(b - 1) do |i|\n  counts00[i] = ModNum.new(0_i64)\nend\n1_i64.upto(a - 1) do |i|\n  (i + b).upto(a - 1) do |j|\n    counts00[j] += counts01[i]\n    counts10[j] += counts11[i]\n  end\n  (i + 1).upto(a - 1) do |j|\n    counts01[j] += counts00[i]\n    counts11[j] += counts10[i]\n  end\nend\n\ndp = { \n  Array(ModNum).new(n + 1, ModNum.new(0_i64)),\n  Array(ModNum).new(n + 1, ModNum.new(0_i64)),\n}\n\n1_i64.upto(a - 1) do |i|\n  dp[1][i] += counts10[i]\n  dp[1][i] += counts11[i]\nend\n1_i64.upto(b - 1) do |i|\n  dp[0][i] += 1\nend\n\n1_i64.upto(n) do |i|\n  1_i64.upto(a - 1) do |j|\n    if i + j <= n\n      dp[1][i + j] += dp[0][i] * counts11[j]\n    end\n    if i + j == n\n      dp[1][i + j] += dp[0][i] * counts10[j]\n    end\n  end\n  1_i64.upto(b - 1) do |j|\n    if i + j <= n\n      dp[0][i + j] += dp[1][i]\n    end\n  end\nend\np ModNum.new(2_i64) ** n - dp[0][n] - dp[1][n]\n"
  },
  {
    "language": "Crystal",
    "code": "MOD = 1_000_000_007i64\nn, a, b = read_line.split.map(&.to_i)\na, b = b, a if a > b\ndp0 = Array.new(b + 1) { Array.new(b + 1, 0i64) }\ndp0[1][0] = 1i64\n1.upto(b - 1) do |i|\n  (b - 1).times do |j|\n    dp0[i + 1][j + 1] += dp0[i][j]\n    dp0[i + 1][j + 1] %= MOD\n    if j >= a || j == 0\n      dp0[i + 1][0] += dp0[i][j]\n      dp0[i + 1][0] %= MOD\n    end\n  end\nend\ndp0s = Array.new(b + 1) { Array.new(b + 1, 0i64) }\ndp0s[a][a] = 1i64\n1.upto(b - 1) do |i|\n  (b - 1).times do |j|\n    dp0s[i + 1][j + 1] += dp0s[i][j]\n    dp0s[i + 1][j + 1] %= MOD\n    if j >= a || j == 0\n      dp0s[i + 1][0] += dp0s[i][j]\n      dp0s[i + 1][0] %= MOD\n    end\n  end\nend\ndp1 = Array.new(n + 1, 0i64)\ndp2 = Array.new(n + 1, 0i64)\ndp1[0] = 1i64\ndp2[0] = 1i64\na.upto(b - 1) do |i|\n  dp2[i] += dp0s[i][0]\nend\nn.times do |i|\n  1.upto(b - 1) do |j|\n    break if i + j > n\n    dp2[i + j] += dp1[i] * dp0[j][0]\n    dp2[i + j] %= MOD\n  end\n  1.upto(a - 1) do |j|\n    break if i + j > n\n    dp1[i + j] += dp2[i]\n    dp1[i + j] %= MOD\n  end\n  if n - i < b\n    dp2[n] += dp1[i] * dp0s[n - i][0]\n    dp2[n] %= MOD\n  end\nend\nans = 1i64\nn.times do\n  ans *= 2\n  ans %= MOD\nend\nans += MOD - dp1[n]\nans += MOD - dp2[n]\nputs ans % MOD\n"
  },
  {
    "language": "Crystal",
    "code": "# ModNum.cr by Koki Takahashi\n# Licensed under MIT License https://mit-license.org\n\nrecord ModNum, value : Int64 do\n  @@factorials = Array(ModNum).new(10_000_i64) # Change here to improve performance\n\n  def self.factorial(n)\n    if @@factorials.empty?\n      @@factorials << ModNum.new(1_i64)\n    end\n    @@factorials.size.upto(n) do |i|\n      @@factorials << @@factorials.last * i\n    end\n    @@factorials[n]\n  end\n\n  def self.permutation(n, k)\n    raise ArgumentError.new(\"k cannot be greater than n\") unless n >= k\n    factorial(n) // factorial(n - k)\n  end\n\n  def self.combination(n, k)\n    raise ArgumentError.new(\"k cannot be greater than n\") unless n >= k\n    permutation(n, k) // @@factorials[k]\n  end\n\n  def self.repeated_combination(n, k)\n    combination(n + k - 1, k)\n  end\n\n  def self.extended_gcd(a, b)\n    last_remainder, remainder = a.abs, b.abs\n    x, last_x, y, last_y = 0_i64, 1_i64, 1_i64, 0_i64\n    while remainder != 0\n      new_last_remainder = remainder\n      quotient, remainder = last_remainder.divmod(remainder)\n      last_remainder = new_last_remainder\n      x, last_x = last_x - quotient * x, x\n      y, last_y = last_y - quotient * y, y\n    end\n\n    return last_remainder, last_x * (a < 0 ? -1 : 1)\n  end\n\n  def self.zero\n    ModNum.new(0_i64)\n  end\n\n  def inv\n    g, x = ModNum.extended_gcd(@value, MOD)\n    ModNum.new(x % MOD)\n  end\n\n  def +(value)\n    ModNum.new((@value + value.to_i64 % MOD) % MOD)\n  end\n\n  def -(value)\n    ModNum.new((@value + MOD - value.to_i64 % MOD) % MOD)\n  end\n\n  def *(value)\n    ModNum.new((@value * value.to_i64 % MOD) % MOD)\n  end\n\n  def /(value : ModNum)\n    raise DivisionByZeroError.new if value == 0\n    self * value.inv\n  end\n\n  def /(value)\n    raise DivisionByZeroError.new if value == 0\n    self * ModNum.new(value.to_i64 % MOD).inv\n  end\n\n  def //(value)\n    self./(value)\n  end\n\n  def **(value)\n    b = value > 0 ? self : self.inv\n    e = value.abs\n    ret = ModNum.new(1_i64)\n    while e > 0\n      if e % 2 == 1\n        ret *= b\n      end\n      b *= b\n      e //= 2\n    end\n    ret\n  end\n\n  def <<(value)\n    self * ModNum.new(2_i64) ** value\n  end\n\n  def sqrt\n    z = ModNum.new(1_i64)\n    until z ** ((MOD - 1) // 2) == MOD - 1\n      z += 1\n    end\n    q = MOD - 1\n    m = 0\n    while q % 2 == 0\n      q //= 2\n      m += 1\n    end\n    c = z ** q\n    t = self ** q\n    r = self ** ((q + 1) // 2)\n    m.downto(2) do |i|\n      tmp = t ** (2 ** (i - 2))\n      if tmp != 1\n        r *= c\n        t *= c ** 2\n      end\n      c *= c\n    end\n    if r * r == self\n      r.to_i64 * 2 <= MOD ? r : -r\n    else\n      nil\n    end\n  end\n\n  def to_i64\n    @value\n  end\n\n  def ==(value : ModNum)\n    @value == value.to_i64\n  end\n\n  def ==(value)\n    @value == value\n  end\n\n  def -\n    ModNum.new(0_i64) - self\n  end\n\n  def +\n    self\n  end\n\n  def abs\n    self\n  end\n\n  # ModNum shouldn't be compared\n  def <(value)\n    raise NotImplementedError.new(\"<\")\n  end\n  def <=(value)\n    raise NotImplementedError.new(\"<=\")\n  end\n  def <(value)\n    raise NotImplementedError.new(\"<\")\n  end\n  def >=(value)\n    raise NotImplementedError.new(\">=\")\n  end\n\n  delegate to_s, to: @value\n  delegate inspect, to: @value\nend\n\n\nMOD = 1_000_000_007_i64\nn, a, b = read_line.split.map(&.to_i64)\nif a < b\n  a, b = b, a\nend\n\ncounts00 = Array(ModNum).new(a, ModNum.new(0_i64))\ncounts10 = Array(ModNum).new(a, ModNum.new(0_i64))\ncounts11 = Array(ModNum).new(a, ModNum.new(0_i64))\n\n1_i64.upto(a - 1) do |i|\n  j = 1_i64\n  tmp = ModNum.new(0_i64)\n  until j > 1 && i - (j // 2 * (b + 1) - 1) < 0\n    if j == 1\n      counts11[i] += 1\n    else\n      remain = i - (j // 2 * (b + 1) - 1)\n      counts00[i] += ModNum.repeated_combination(j - 2, remain)\n      if remain >= 1\n        counts10[i] += ModNum.repeated_combination(j - 1, remain - 1)\n      end\n      if remain >= 2\n        counts11[i] += ModNum.repeated_combination(j, remain - 2)\n      end\n    end\n    j += 2\n  end\nend\n\ndp = { \n  Array(ModNum).new(n + 1, ModNum.new(0_i64)),\n  Array(ModNum).new(n + 1, ModNum.new(0_i64)),\n}\n\n1_i64.upto(a - 1) do |i|\n  dp[1][i] += counts10[i]\n  dp[1][i] += counts11[i]\nend\n1_i64.upto(b - 1) do |i|\n  dp[0][i] += 1\nend\n\n1_i64.upto(n) do |i|\n  1_i64.upto(a - 1) do |j|\n    if i + j <= n\n      dp[1][i + j] += dp[0][i] * counts11[j]\n    end\n    if i + j == n\n      dp[1][i + j] += dp[0][i] * counts10[j]\n    end\n  end\n  1_i64.upto(b - 1) do |j|\n    if i + j <= n\n      dp[0][i + j] += dp[1][i]\n    end\n  end\nend\np ModNum.new(2_i64) ** n - dp[0][n] - dp[1][n]\n"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  implicit none\n  integer(8), parameter :: modu = 1000000007\n  integer :: n, a, b, i, j\n  integer(8) :: x = 1, f(0:5000, 2) = 0, g(0:5000, 2) = 0\n  read(*,*) n, a, b\n  if (a > b) then\n    i = a\n    a = b\n    b = i\n  end if\n  g(1, 2) = 1\n  do i = 2, b - 1\n    g(i, 2) = mod(sum(g(i - 1, :)), modu)\n    g(i, 1) = mod(sum(g(1:i - a, 2)), modu)\n  end do\n  f(0, :) = 1\n  do i = 1, n\n    x = mod(x * 2, modu)\n    f(i, 1) = mod(sum(f(max(i - a + 1, 0):i - 1, 2)), modu)\n    do j = 1, min(b - 1, i)\n      if (i == n) f(i, 1) = mod(f(i, 1) + f(i - j, 1) * g(j, 1), modu)\n      f(i, 2) = f(i, 2) + merge(sum(g(j, :)), mod(f(i - j, 1) * g(j, 2), modu), j == i)\n    end do\n    f(i, 2) = mod(f(i, 2), modu)\n  end do\n  write(*,'(i0)') modulo(x - sum(f(n, :)), modu)\nend program range_set"
  },
  {
    "language": "Fortran",
    "code": "module mod_modint\n  implicit none\n  integer(8) :: modulus = 10_8**9+7\n  type modint\n    private\n    integer(8) :: num\n  contains\n    procedure :: get => getnum\n  end type\n\n  interface assignment(=)\n    module procedure :: setm, seti64, seti32\n  end interface assignment(=)\n\n  interface operator(+)\n    module procedure :: posm, addmm, addmi64, addmi32, addi64m, addi32m\n  end interface operator(+)\n\n  interface operator(-)\n    module procedure :: negm, submm, submi64, submi32, subi64m, subi32m\n  end interface operator(-)\n\n  interface operator(*)\n    module procedure :: mulmm, mulmi64, mulmi32, muli64m, muli32m\n  end interface operator(*)\n\n  interface operator(/)\n    module procedure :: divmm, divmi64, divmi32, divi64m, divi32m\n  end interface operator(/)\n\n  interface operator(**)\n    module procedure :: powmi64, powmi32\n  end interface operator(**)\n\n  interface inv\n    module procedure :: invm\n  end interface inv\n\ncontains\n\n  integer(8) function getnum(this)\n    class(modint), intent(in) :: this\n    getnum = this%num\n  end\n\n  pure elemental type(modint) function newm()\n    newm%num = 0_8\n  end\n\n  pure elemental subroutine setm(x,y)\n    type(modint), intent(inout) :: x\n    type(modint), intent(in) :: y\n    x%num = y%num\n  end\n\n  pure elemental function posm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    n%num = x%num\n  end\n\n  pure elemental function negm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    n%num = modulus-x%num\n  end\n\n  pure elemental function addmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = x%num+y%num\n    if (n%num >= modulus) n%num = n%num-modulus\n  end\n\n  pure elemental function submm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = x%num-y%num\n    if (n%num < 0_8) n%num = n%num+modulus\n  end\n\n  pure elemental function mulmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = mod(x%num*y%num,modulus)\n  end\n\n  impure elemental function invm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    integer(8) :: a, b, c, q, r, v\n    a = x%num\n    if (a == 0_8) then\n      write(*,'(a)') \"Error: Division by zero (x == 0). (modint, invm)\"\n      stop\n    end if\n    b = modulus\n    c = 0_8\n    v = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      r = mod(a,b)\n      a = b\n      b = r\n      r = c\n      c = v-c*q\n      v = r\n    end do\n    n%num = mod(v,modulus)\n    if (n%num < 0_8) n%num = n%num+modulus\n  end\n\n  impure elemental function divmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n = mulmm(x,invm(y))\n  end\n\n  impure elemental type(modint) function newi(i)\n    class(*), intent(in) :: i\n    select type(i)\n    type is (integer(8))\n      newi%num = i\n    type is (integer)\n      newi%num = int(i,8)\n    type is (integer(2))\n      newi%num = int(i,8)\n    type is (integer(1))\n      newi%num = int(i,8)\n    class default\n      write(*,'(a)') \"Error: Invalid value (i is not integer). (modint, newi)\"\n      stop\n    end select\n    newi%num = mod(newi%num,modulus)\n    if (newi%num < 0_8) newi%num = newi%num+modulus\n  end\n\n  impure elemental subroutine seti64(x,i)\n    type(modint), intent(inout) :: x\n    integer(8), intent(in) :: i\n    call setm(x,newi(i))\n  end\n\n  impure elemental subroutine seti32(x,i)\n    type(modint), intent(inout) :: x\n    integer, intent(in) :: i\n    call setm(x,newi(i))\n  end\n\n  impure elemental function addmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = addmm(x,newi(i))\n  end\n\n  impure elemental function addmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = addmm(x,newi(i))\n  end\n\n  impure elemental function addi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = addmm(newi(i),y)\n  end\n\n  impure elemental function addi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = addmm(newi(i),y)\n  end\n\n  impure elemental function submi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = submm(x,newi(i))\n  end\n\n  impure elemental function submi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = submm(x,newi(i))\n  end\n\n  impure elemental function subi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = submm(newi(i),y)\n  end\n\n  impure elemental function subi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = submm(newi(i),y)\n  end\n\n  impure elemental function mulmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = mulmm(x,newi(i))\n  end\n\n  impure elemental function mulmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = mulmm(x,newi(i))\n  end\n\n  impure elemental function muli64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = mulmm(newi(i),y)\n  end\n\n  impure elemental function muli32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = mulmm(newi(i),y)\n  end\n\n  impure elemental function divmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = divmm(x,newi(i))\n  end\n\n  impure elemental function divmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = divmm(x,newi(i))\n  end\n\n  impure elemental function divi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = divmm(newi(i),y)\n  end\n\n  impure elemental function divi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = divmm(newi(i),y)\n  end\n\n  impure elemental function powmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n, p\n    integer(8) :: m\n    n = newi(1_8)\n    p = x\n    m = i\n    if (i < 0_8) then\n      p = invm(x)\n      m = abs(i)\n    end if\n    do while (m > 0_8)\n      if (btest(m,0)) n = mulmm(p,n)\n      p = mulmm(p,p)\n      m = rshift(m,1)\n    end do\n  end\n\n  impure elemental function powmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n, p\n    integer :: m\n    n = newi(1_8)\n    p = x\n    m = i\n    if (i < 0) then\n      p = invm(x)\n      m = abs(i)\n    end if\n    do while (m > 0)\n      if (btest(m,0)) n = mulmm(p,n)\n      p = mulmm(p,p)\n      m = rshift(m,1)\n    end do\n  end\n\nend module mod_modint\nprogram c\n   use mod_modint\n   implicit none\n   integer::N\n   integer::a,b\n   type(modint),allocatable,dimension(:,:)::f,DP\n   type(modint),allocatable,dimension(:)::g\n   type(modint)::w,ANS,tmp\n   integer::i,j,k\n   read*,N,a,b\n   if(a>b)then\n      a=xor(a,b)\n      b=xor(a,b)\n      a=xor(a,b)\n   endif\n   allocate(f(0:N,2),DP(0:N,2))\n   allocate(g(0:N))\n\n   f=0\n   DP=0\n   ANS=0\n\n   if(b>=2)then\n      f(0,1)=1;f(0,2)=1\n      do i=1,N\n         do j=1,2\n            do k=1,i\n               if(j==1.and.k<a)cycle\n               f(i,j)=f(i,j)+f(i-k,mod(j,2)+1)\n            end do\n         end do\n      end do\n      g(0)=1\n      do i=1,N\n         g(i)=f(i,1)+f(i,2)\n      end do\n      do i=1,N-1\n         if(i<a)dp(i,1)=dp(i,1)+1\n         do j=1,min(i,a)-1\n            dp(i,1)=dp(i,1)+dp(i-j,2)\n         end do\n         if(i<b)dp(i,2)=dp(i,2)+g(i-1)\n         do j=1,min(i,b)-1\n            w=1\n            if(j/=1)w=g(j-2)\n            dp(i,2)=dp(i,2)+dp(i-j,1)*w\n         end do\n         if(n-i<b)ans=ans+dp(i,1)*g(n-i-1)\n         if(n-i<a)ans=ans+dp(i,2)\n      end do\n   endif\n   tmp=2\n   tmp=tmp**N\n   print*,getnum(tmp-ans)\n\nend program c"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  implicit none\n  integer(8), parameter :: modu = 1000000007\n  integer :: n, a, b, i, j\n  integer(8) :: x = 1, f(0:5000, 2) = 0, g(0:5000, 2) = 0\n  read(*,*) n, a, b\n  if (a > b) then\n    i = a\n    a = b\n    b = i\n  end if\n  g(1, 2) = 1\n  do i = 2, b - 1\n    g(i, 2) = mod(g(i - 1, 1) + g(i - 1, 2), modu)\n    do j = a, i - 1\n      g(i, 1) = g(i, 1) + g(i - j, 2)\n    end do\n    g(i, 1) = mod(g(i, 1), modu)\n  end do\n  f(0, :) = 1\n  do i = 1, n\n    x = mod(x * 2, modu)\n    do j = 1, min(a - 1, i)\n      f(i, 1) = f(i, 1) + f(i - j, 2)\n    end do\n    f(i, 1) = mod(f(i, 1), modu)\n    do j = 1, min(b - 1, i)\n      if (i == n) f(i, 1) = mod(f(i, 1) + f(i - j, 1) * g(j, 1), modu)\n      f(i, 2) = f(i, 2) + merge(g(j, 1) + g(j, 2), mod(f(i - j, 1) * g(j, 2), modu), j == i)\n    end do\n    f(i, 2) = mod(f(i, 2), modu)\n  end do\n  write(*,'(i0)') modulo(x - f(n, 1) - f(n, 2), modu)\nend program range_set"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  integer :: n,a,b\n  integer(8) :: modu=1000000007,x=1,f(0:5000,2)=0,g(0:5000,2)=0\n  read(*,*) n,a,b\n  if(a>b)then\n    i=a\n    a=b\n    b=i\n  endif\n  g(1,2)=1\n  do i=2,b-1\n    g(i,2)=mod(sum(g(i-1,:)),modu)\n    g(i,1)=mod(sum(g(1:i-a,2)),modu)\n  enddo\n  f(0,:)=1\n  do i=1,n\n    x=mod(x*2,modu)\n    f(i,1)=mod(sum(f(max(i-a+1,0):i-1,2)),modu)\n    do j=1,min(b-1,i)\n      if(i==n)f(i,1)=mod(f(i,1)+f(i-j,1)*g(j,1),modu)\n      f(i,2)=mod(f(i,2)+merge(sum(g(j,:)),mod(f(i-j,1)*g(j,2),modu),j==i),modu)\n    enddo\n  enddo\n  print'(i0)',modulo(x-sum(f(n,:)),modu)\nend program range_set"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  implicit none\n  integer(8), parameter :: modu = 1000000007\n  integer :: n, a, b, i, j\n  integer(8) :: x = 1, f(0:5000, 2) = 0, g(0:5000, 2) = 0\n  read(*,*) n, a, b\n  if (a > b) then\n    i = a\n    a = b\n    b = i\n  end if\n  g(1, 2) = 1\n  do i = 2, b - 1\n    g(i, 2) = mod(g(i - 1, 1) + g(i - 1, 2), modu)\n    g(i, 1) = mod(sum(g(1:i - a, 2)), modu)\n  end do\n  f(0, :) = 1\n  do i = 1, n - 1\n    x = x + x\n    if (x > modu) x = x - modu\n    f(i, 1) = mod(sum(f(max(i - a + 1, 0):i - 1, 2)), modu)\n    if (i < b) then\n      do j = 1, i - 1\n        f(i, 2) = f(i, 2) + mod(f(i - j, 1) * g(j, 2), modu)\n      end do\n      f(i, 2) = mod(f(i, 2) + g(j, 1) + g(j, 2), modu)\n    else\n      do j = 1, b - 1\n        if (i == n) f(i, 1) = mod(f(i, 1) + f(i - j, 1) * g(j, 1), modu)\n        f(i, 2) = f(i, 2) + mod(f(i - j, 1) * g(j, 2), modu)\n      end do\n      f(i, 2) = mod(f(i, 2), modu)\n    end if\n  end do\n  f(n, 1) = mod(sum(f(n - a + 1:n - 1, 2)), modu)\n  do j = 1, b - 1\n    f(n, 1) = f(n, 1) + mod(f(n - j, 1) * g(j, 1), modu)\n    f(n, 2) = f(n, 2) + mod(f(n - j, 1) * g(j, 2), modu)\n  end do\n  write(*,'(i0)') modulo(x + x - f(n, 1) - f(n, 2), modu)\nend program range_set"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  implicit none\n  integer(8), parameter :: modu = 1000000007\n  integer :: n, a, b, i, j\n  integer(8) :: x = 1, f(0:5000, 2) = 0, g(0:5000, 2) = 0\n  read(*,*) n, a, b\n  if (a > b) then\n    i = a\n    a = b\n    b = i\n  end if\n  g(1, 2) = 1\n  do i = 2, b - 1\n    g(i, 2) = mod(g(i - 1, 1) + g(i - 1, 2), modu)\n    g(i, 1) = mod(sum(g(1:i - a, 2)), modu)\n  end do\n  f(0, :) = 1\n  do i = 1, n - 1\n    x = x + x\n    if (x > modu) x = x - modu\n    f(i, 1) = mod(sum(f(max(i - a + 1, 0):i - 1, 2)), modu)\n    if (i < b) then\n      do j = 1, i - 1\n        f(i, 2) = f(i, 2) + mod(f(i - j, 1) * g(j, 2), modu)\n      end do\n      f(i, 2) = mod(f(i, 2) + g(j, 1) + g(j, 2), modu)\n    else\n      do j = 1, b - 1\n        if (i == n) f(i, 1) = mod(f(i, 1) + f(i - j, 1) * g(j, 1), modu)\n        f(i, 2) = f(i, 2) + mod(f(i - j, 1) * g(j, 2), modu)\n      end do\n      f(i, 2) = mod(f(i, 2), modu)\n    end if\n  end do\n  x = x + x\n  if (x > modu) x = x - modu\n  f(n, 1) = mod(sum(f(n - a + 1:n - 1, 2)), modu)\n  do j = 1, b - 1\n    f(n, 1) = f(n, 1) + mod(f(n - j, 1) * g(j, 1), modu)\n    f(n, 2) = f(n, 2) + mod(f(n - j, 1) * g(j, 2), modu)\n  end do\n  write(*,'(i0)') modulo(x - f(n, 1) - f(n, 2), modu)\nend program range_set"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  implicit none\n  integer(8), parameter :: modu = 1000000007\n  integer :: n, a, b, i, j\n  integer(8) :: x = 1, f(0:5000, 2) = 0, g(0:5000, 2) = 0\n  read(*,*) n, a, b\n  if (a > b) then\n    i = a\n    a = b\n    b = i\n  end if\n  g(1, 2) = 1\n  do i = 2, b - 1\n    g(i, 2) = mod(g(i - 1, 1) + g(i - 1, 2), modu)\n    g(i, 1) = mod(sum(g(1:i - a, 2)), modu)\n  end do\n  f(0, :) = 1\n  do i = 1, n\n    x = mod(x * 2, modu)\n    f(i, 1) = mod(sum(f(max(i - a + 1, 0):i - 1, 2)), modu)\n    do j = 1, min(b - 1, i)\n      if (i == n) f(i, 1) = mod(f(i, 1) + f(i - j, 1) * g(j, 1), modu)\n      f(i, 2) = f(i, 2) + merge(g(j, 1) + g(j, 2), mod(f(i - j, 1) * g(j, 2), modu), j == i)\n    end do\n    f(i, 2) = mod(f(i, 2), modu)\n  end do\n  write(*,'(i0)') modulo(x - f(n, 1) - f(n, 2), modu)\nend program range_set"
  },
  {
    "language": "Fortran",
    "code": "program range_set\n  implicit none\n  integer(8), parameter :: modu = 1000000007\n  integer :: n, a, b, i, j\n  integer(8) :: x = 1, f(0:5000, 2) = 0, g(0:5000, 2) = 0\n  read(*,*) n, a, b\n  if (a > b) then\n    i = a\n    a = b\n    b = i\n  end if\n  g(1, 2) = 1\n  do i = 2, b - 1\n    g(i, 2) = mod(g(i - 1, 1) + g(i - 1, 2), modu)\n    g(i, 1) = mod(sum(g(1:i - a, 2)), modu)\n  end do\n  f(0, :) = 1\n  do i = 1, n - 1\n    x = x + x\n    if (x > modu) x = x - modu\n    f(i, 1) = mod(sum(f(max(i - a + 1, 0):i - 1, 2)), modu)\n    if (i < b) then\n      do j = 1, i - 1\n        f(i, 2) = f(i, 2) + mod(f(i - j, 1) * g(j, 2), modu)\n      end do\n      f(i, 2) = mod(f(i, 2) + g(j, 1) + g(j, 2), modu)\n    else\n      do j = 1, b - 1\n        if (i == n) f(i, 1) = mod(f(i, 1) + f(i - j, 1) * g(j, 1), modu)\n        f(i, 2) = f(i, 2) + mod(f(i - j, 1) * g(j, 2), modu)\n      end do\n      f(i, 2) = mod(f(i, 2), modu)\n    end if\n  end do\n  x = x + x\n  f(n, 1) = mod(sum(f(n - a + 1:n - 1, 2)), modu)\n  do j = 1, b - 1\n    f(n, 1) = f(n, 1) + mod(f(n - j, 1) * g(j, 1), modu)\n    f(n, 2) = f(n, 2) + mod(f(n - j, 1) * g(j, 2), modu)\n  end do\n  write(*,'(i0)') modulo(x - f(n, 1) - f(n, 2), modu)\nend program range_set"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX_N=5010;\nmint dp[MAX_N][MAX_N][2];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,A,B; cin >> N >> A >> B;\n    if (A<B) swap(A,B);\n    if (B==1){\n        cout << pow((mint)2,N) << '\\n';\n        return 0;\n    }\n    dp[0][0][0]=1;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<A;++j){\n            dp[i+1][j+1][0]+=dp[i][j][0];\n            if (j>=B) dp[i+1][j+1][0]+=dp[i][j][1];\n            else dp[i+1][1][0]+=dp[i][j][1];\n            if (j+1!=B) dp[i+1][j+1][1]+=dp[i][j][1];\n            if (i+B<=N) dp[i+B][min(A,j+B)][1]+=dp[i][j][0];\n            dp[i+1][1][1]+=dp[i][j][0];\n        }\n    }\n    mint ans=0,po=1;\n    for (int i=N;i>=0;--i,po*=2){\n        ans+=(dp[i][A][0]+dp[i][A][1])*po;\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD=1000000007;\n\nll n,a,b;\nll x[5002];\nvoid x_init(){\n\tll dp[5002][2];\n\tdp[1][0]=1;\n\tdp[1][1]=0;\n\tfor(int i=1;i<=a;i++){\n\t\tdp[i+1][0]+=dp[i][0];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tif(i+b<=a){\n\t\t\tdp[i+b][1]+=dp[i][0];\n\t\t\tif(dp[i+b][1]>=MOD)dp[i+b][1]-=MOD;\n\t\t}\n\t\tdp[i+1][0]+=dp[i][1];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tdp[i+1][1]+=dp[i][1];\n\t\tif(dp[i+1][1]>=MOD)dp[i+1][1]-=MOD;\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tx[i]=dp[i][0];\n\t\t//cout<<i<<\":\"<<x[i]<<endl;\n\t}\n}\n\nint main(){\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx_init();\n\t\n\tll dp[5002][2]={};\n\tfor(int i=1;i<=a-1;i++){\n\t\tdp[i][0]=x[i+1];\n\t}\n\tfor(int i=1;i<=b-1;i++){\n\t\tdp[i][1]=1;\n\t}\n\tfor(int i=1;i<=n-1;i++){\n\t\tfor(int j=1;j<=b-1;j++){\n\t\t\tdp[i+j][1]+=dp[i][0];\n\t\t\tif(dp[i+j][1]>=MOD)dp[i+j][1]-=MOD;\n\t\t}\n\t\tfor(int j=1;j<=a-1;j++){\n\t\t\tif(i+j<n){\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j+1];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=1;\n\tfor(int i=0;i<n;i++){\n\t\tret*=2;\n\t\tret%=MOD;\n\t}\n\tret+=MOD-dp[n][0];\n\tret+=MOD-dp[n][1];\n\tcout<<ret%MOD<<endl;\n\t//cout<<(dp[n][0]+dp[n][1])%MOD<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nLL dp[5300][5300];\nLL t[5300];\nLL t2[5300];\n\nlong long int pow_mod(long long int p_a,long long int p_n,long long int p_p=1e9+7){\n\t//p_a^p_n mod p_p\n\tlong long int p_b=1,p_t=1;\n\tfor(;p_b<=p_n;p_b<<=1);\n\tfor(p_b>>=1;p_b>0;p_b>>=1){\n\t\tp_t*=p_t;\n\t\tif(p_t>=p_p)p_t%=p_p;\n\t\tif(p_n&p_b)p_t*=p_a;\n\t\tif(p_t>=p_p)p_t%=p_p;\n\t}\n\treturn p_t;\n}\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tLL a,b,c;\n\tLL x,y;\n\tLL s[10]={0};\n\tcin>>n;\n\tcin>>x>>y;\n\tif(x<y)swap(x,y);\n\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(i=0;i<x;i++){\n\t\tdp[i+1][0]=dp[i][0];\n\t\ta=0;\n\t\tfor(j=0;j<x;j++){\n\t\t\tdp[i+1][j+1]=dp[i][j];\n\t\t\tif(j>=y)a+=dp[i][j];\n\t\t}\n\t\ta%=MAX;\n\t\tdp[i+1][0]+=a;\n\t\tif(dp[i+1][0]>=MAX)dp[i+1][0]%=MAX;\n\t}\n\tfor(i=0;i<=x;i++){\n\t\tt[i]=dp[i][0];\n\t}\n\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tif(i+1<x){\n\t\t\tdp[i+1][0]+=t[i+1];\n\t\t\tdp[i+1][0]%=MAX;\n\t\t}\n\t\tfor(j=0;j<y;j++){\n\t\t\tdp[i+1][j+1]=dp[i][j];\n\t\t\tif(j)t2[i]+=dp[i][j];\n\t\t}\n\t\tt2[i]%=MAX;\n\t\ta=0;\n\t\tfor(j=0;j<x-1;j++){\n\t\t\tif(i-j<0)break;\n\t\t\ta+=t2[i-j]*t[j];\n\t\t\tif(a>=MAX)a%=MAX;\n\t\t}\n\t\tdp[i+1][0]+=a;\n\t\tdp[i+1][0]%=MAX;\n\t}\n\tfor(i=1;i<y;i++){\n\t\ts[2]+=dp[n][i];\n\t}\n\tfor(j=1;j<x;j++){\n\t\tif(n-j<0)break;\n\t\ts[2]+=t2[n-j]*t[j];\n\t\tif(s[2]>=MAX)s[2]%=MAX;\n\t}\n\ts[2]%=MAX;\n\ts[0]=pow_mod(2,n)-s[2];\n\tif(s[0]<0)s[0]+=MAX;\n\tcout<<s[0]%MAX<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 5005, md = 1000000007;\n\nvoid calc(int h[MX], int b, int a, int n) {\n\tstatic int dp[MX][MX], add[MX][MX], zero[MX];\n\t\n\tmemset(dp, 0, sizeof dp);\n\tmemset(add, 0, sizeof add);\n\tmemset(zero, 0, sizeof zero);\n\t\n\tfor (int i = 1; i < b; i++) {\n\t\tdp[i][0] = 1;\n\t}\n\t\n\tfor (int i = 0; i <= n; i++) {\n\t\tdp[i][0] += zero[i];\n\t\t\n\t\tzero[i + 1] += zero[i];\n\t\tzero[i + 1] %= md;\n\t\t\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\tdp[i][j] += add[i][j];\n\t\t\tdp[i][j] %= md;\n\t\t\t\n\t\t\tif (j + 1 == a) continue;\n\t\t\t\n\t\t\tadd[i + 1][j + 1] += add[i][j];\n\t\t\tadd[i + 1][j + 1] %= md;\n\t\t\t\n\t\t\tif (i + 1 + b <= n) {\n\t\t\t\tadd[i + 1 + b][j + 1 + b] += dp[i][j];\n\t\t\t\tadd[i + 1 + b][j + 1 + b] %= md;\n\t\t\t}\n\t\t\t\n\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\tdp[i + 1][j + 1] %= md;\n\t\t\t\n\t\t\tzero[i + 2] += dp[i][j];\n\t\t\tzero[i + 2] %= md;\n\t\t\t\n\t\t\tif (i + 1 + b <= n) {\n\t\t\t\tzero[i + 1 + b] += md - dp[i][j];\n\t\t\t\tzero[i + 1 + b] %= md;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i <= n; i++) {\n\t\th[i] = 0;\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\th[i] += dp[i][j];\n\t\t\th[i] %= md;\n\t\t}\n\t}\n}\n\nint f[MX], g[MX], h[MX];\n\nint main() {\n\tint n, a, b;\n\tignore = scanf(\"%d %d %d\", &n, &a, &b);\n\t\n\tif (a < b) swap(a, b);\n\t\n\tf[0] = 1;\n\tfor (int i = b; i <= n; i++) f[i] = 1;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i + 1] += f[i];\n\t\tf[i + 1] %= md;\n\t\t\n\t\tfor (int j = b; i + 1 + j <= n; j++) {\n\t\t\tf[i + 1 + j] += f[i];\n\t\t\tf[i + 1 + j] %= md;\n\t\t}\n\t}\n\t\n\tcalc(g, b, a, n);\n\tcalc(h, b, n + 1, n);\n\t\n\tint ans = f[n];\n\t\n\t// prefix\n\tfor (int len = a - 1; len < n; len++) {\n\t\tans = (ans + f[len] * 1LL * g[n - 1 - len]) % md;\n\t}\n\t\n\t// suffix\n\tfor (int len = a - 1; len < n; len++) {\n\t\tans = (ans + f[len] * 1LL * h[n - 1 - len]) % md;\n\t}\n\t\n\t// middle\n\tfor (int len = a - 2; len + 2 <= n; len++)\n\t\tfor (int L = 0; L + len + 2 <= n; L++) {\n\t\t\tans = (ans + f[len] * 1LL * h[L] % md * g[n - L - len - 2]) % md;\n\t\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint main() {\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  vector dp0(n + 1, vector(b + 1, 0)), dp1(n + 1, vector(b + 1, 0));\n  dp1[0][0] = 1;\n  REP(i, n) REP(j, b + 1) {\n    // 1 -> 0\n    (dp0[i + 1][j == b ? b : 0] += dp1[i][j]) %= MOD;\n    if (i + a <= n) {\n      (dp0[i + a][min(j + a, b)] += dp1[i][j]) %= MOD;\n      (dp0[i + a][j == b ? b : 0] += MOD - dp1[i][j]) %= MOD;\n    }\n    // 0 -> 0\n    if (j >= a) {\n      (dp0[i + 1][min(j + 1, b)] += dp0[i][j]) %= MOD;\n    } else {\n      (dp0[i + 1][j == b ? b : 0] += dp0[i][j]) %= MOD;\n    }\n    // 0 -> 1\n    (dp1[i + 1][min(j + 1, b)] += dp0[i][j]) %= MOD;\n    // 1 -> 1\n    (dp1[i + 1][min(j + 1, b)] += dp1[i][j]) %= MOD;\n  }\n  cout << (dp0[n][b] + dp1[n][b]) % MOD << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 5e3 + 100;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nll C[2];\n\nstring s;\n\nll dp0[maxn][2];\n\nll dp[maxn][2];\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nvoid count_dp0() {\n    ll q, w, e;\n    // dp0[0][0] = dp0[0][1] = 1;\n    for (q = 0; q < n; q++) {\n        /// last are 0s;\n        // dp0[q][0] = 1;\n        for (w = C[0]; w <= q; w++) {\n            dp0[q][0] += dp0[q - w][1];\n            dp0[q][0] %= mod;\n        }\n\n        /// last are 1s;\n        dp0[q][1] = 1;\n        for (w = 1; w <= q; w++) {\n            dp0[q][1] += dp0[q - w][0];\n            dp0[q][1] %= mod;\n        }\n    }\n}\n\n// set <ll> S;\n\nll getcnt(ll len, bool f) {\n    // if (S.find(len) == S.end()) {\n    //     cout << \"DP0 \" << len << \" \" << dp0[len - 1][1] << endl;\n    // }\n    // S.insert(len);\n    ll ans = dp0[len - 1][1];\n    if (f) {\n        ans += dp0[len - 1][0];\n    }\n    return ans;\n}\n\nvoid count_dp() {\n    ll q, w, e;\n    for (q = 0; q < n; q++) {\n        /// last are 0s;\n        if (q + 1 < C[0]) {\n            dp[q][0] = 1;\n        }\n        for (w = 1; w < C[0]; w++) {\n            dp[q][0] += dp[q - w][1];\n            dp[q][0] %= mod;\n        }\n        /// last are pseudo-1s;\n        if (q + 1 < C[1]) {\n            dp[q][1] = getcnt(q + 1, 1);\n        }\n        for (w = 1; w < C[1]; w++) {\n            dp[q][1] += dp[q - w][0] * getcnt(w, q == (n - 1));\n            dp[q][1] %= mod;\n        }\n    }\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    cin >> n >> a >> b;\n    if (a > b) {\n        swap(a, b);\n    }\n    C[0] = a;\n    C[1] = b;\n    count_dp0();\n    count_dp();\n    // cout << dp[n - 1][0] << \" \" << dp[n - 1][1] << \" DPS\" << endl;\n    ll cnt_bad = dp[n - 1][0] + dp[n - 1][1];\n    // cout << \"CNT_BAD \" << cnt_bad << endl;\n    ll ans = (step(2, n) - cnt_bad % mod + mod) % mod;\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\ntypedef long long LL;\nconst int N=5005,P=1e9+7;\nint n,A,B,f[N],g[N][2];\nint fpow(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;\n\treturn k3;\n}\nint main(){\n\tcin>>n>>A>>B;\n\tif(A>B)swap(A,B);\n\tf[1]=1;\n\trep(i,1,B-1){\n\t\t(f[i+1]+=f[i])%=P;\n\t\trep(j,i+A+1,B)(f[j]+=f[i])%=P;\n\t}\n//\tprintf(\">>> %d %d\\n\",A,B);\n//\trep(i,1,B)printf(\"%d \",f[i]);puts(\"\");\n\trep(i,1,B-1)g[i][0]=f[i+1];\n\trep(i,1,A-1)g[i][1]=1;\n\trep(i,1,n){\n\t\trep(j,i+1,min(n,i+B-1))if(j==n)(g[j][0]+=1LL*g[i][1]*f[j-i+1]%P)%=P;else (g[j][0]+=1LL*g[i][1]*f[j-i]%P)%=P;\n\t\trep(j,i+1,min(n,i+A-1))(g[j][1]+=g[i][0])%=P;\n//\t\tprintf(\"g[%d][0]=%d g[%d][1]=%d\\n\",i,g[i][0],i,g[i][1]);\n\t}\n\tprintf(\"%lld\\n\",((LL)fpow(2,n)-g[n][0]-g[n][1]+P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nll modpow_(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct ModInt{\n  int v;\n  ModInt(int v=0):v(v){}\n  ModInt operator+(const ModInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  ModInt operator-(const ModInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  ModInt operator*(const ModInt &n)const{return ll(v)*n.v%mod;}\n  ModInt operator/(const ModInt &n)const{return ll(v)*modpow_(n.v%mod,-1,mod)%mod;}\n  ModInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  ModInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  ModInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  ModInt operator/(const ll &n)const{return ll(v)*modpow_(n%mod,-1,mod)%mod;}\n  ModInt& operator+=(const ModInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ModInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ModInt &n){v=ll(v)*n.v%mod; return *this;}\n  ModInt& operator/=(const ModInt &n){v=ll(v)*modpow_(n.v,-1,mod)%mod; return *this;}\n  ModInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  ModInt& operator/=(const ll &n){v=ll(v)*modpow_(n,-1,mod)%mod; return *this;}\n\tbool operator==(const ModInt &n)const{return v==n.v;};\n\tbool operator!=(const ModInt &n)const{return v!=n.v;};\n\tModInt& operator++(){ return operator+=(1); }\n\tModInt& operator--(){ return operator-=(1); }\n\tModInt operator++(int i){ ModInt tmp(*this); operator++(); return tmp; }\n\tModInt operator--(int i){ ModInt tmp(*this); operator--(); return tmp; }\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow_(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow_(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> ModInt<mod> operator+(const ll &n,const ModInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> ModInt<mod> operator-(const ll &n,const ModInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> ModInt<mod> operator*(const ll &n,const ModInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> ModInt<mod> operator/(const ll &n,const ModInt<mod> &m){return ModInt<mod>(n%mod)/m;}\ntypedef ModInt<MOD> mint;\ntemplate <int mod> ModInt<mod> modpow(ModInt<mod> r,ll n){ ModInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(1123456);\nusing pmm=pair<mint,mint>;\nmint modpow(ll r,ll n){ return modpow_(r,n);}\n\nmint bf(int n,int a,int b){\n\tset<int> st{0};\n\tqueue<int> que; que.emplace(0);\n\tconst int A=(1<<a)-1;\n\tconst int B=(1<<b)-1;\n\twhile(que.size()){\n\t\tint x=que.front(); que.pop();\n\t\trep(i,n-a+1){\n\t\t\tint y=x&~(A<<i);\n\t\t\tif(st.insert(y).Y) que.emplace(y);\n\t\t}\n\t\trep(i,n-b+1){\n\t\t\tint y=x|(B<<i);\n\t\t\tif(st.insert(y).Y) que.emplace(y);\n\t\t}\n\t}\n\t// for(int x:st){rep(i,n) cout<<(x>>i&1); cout NL;}\n\treturn st.size();\n}\n\nmint solve(int n,int a,int b){\n\tif(a>b) swap(a,b);\n\tvector<mint> el(n+1); //1 or long 0 only\n\tel[0]=1;\n\trep(i,n){\n\t\tel[i+1]+=el[i];\n\t\treps(d,a,n)if(i+d+1<=n) el[i+d+1]+=el[i];\n\t}\n\tvector<mint> step(n+1);\n\trep(d,n+1){\n\t\treps(s,1,a){\n\t\t\tint rem=d-(s+1);\n\t\t\tif(rem>=0 && rem+1<b) step[d]+=el[rem];\n\t\t}\n\t}\n\t// out(el,step,1);\n\tvector<mint> dp(n+1);\n\trep(d,n+1){\n\t\treps(s,1,a){\n\t\t\tint rem=d-(s+1);\n\t\t\tif(rem>=0 && rem<b) dp[d]+=el[rem];\n\t\t}\n\t}\n\trep(i,n)reps(j,i+1,n+1) dp[j]+=dp[i]*step[j-i];\n\tvector<mint> last(n+1);\n\trep(i,n+1)rep(j,n+1)if(i+j<=n){\n\t\tint len=i+1;\n\t\tif(j>=a) len+=j;\n\t\tif(len>=b) continue;\n\t\t// out(i,j,el[i],1);\n\t\tlast[i+j]+=el[i];\n\t}\n\tmint re=0;\n\trep(i,n+1)rep(j,n+1)if(i+j==n){\n\t\tint len=i;\n\t\tif(j>=a) len+=j;\n\t\tif(len>=b) continue;\n\t\t// out(i,j,el[i],1);\n\t\tre+=el[i];\n\t}\n\treps(i,1,n+1){\n\t\tre+=dp[i]*last[n-i];\n\t}\n\treturn modpow(2,n)-re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tif(0){\n\treps(n,1,17)reps(a,1,n+1)reps(b,1,n+1){\n\t\tmint exp=bf(n,a,b);\n\t\tmint act=solve(n,a,b);\n\t\tif(exp!=act){\n\t\t\tout(exp,act,n,a,b,1);\n\t\t\t// exit(0);\n\t\t}\n\t}\n\treturn 0;\n\t}\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tcout<<solve(n,a,b) NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n//INSERT ABOVE HERE\nconst int MAX = 5050;\nusing M = Mint<int>;\nM dp[MAX][MAX]={};\nM sm[MAX][MAX]={};\n\nM ac[MAX]={};\nM query(int x,int y){\n  if(x<=0) x=0;\n  return ac[y]-ac[x];\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,a,b;\n  cin>>n>>a>>b;\n  if(!(a<=b)) swap(a,b);\n\n  M ans{0};\n  dp[0][0]=1;\n  sm[0][0]=1;\n  ac[1]=1;\n  for(int i=1;i<=n;i++){\n    // [i-a, i-1)\n    dp[i][1]+=query(i-a,i-1);\n\n    for(int j=0;j<=i;j++){\n      // put '1'\n      if(i>=1 and j>=1)\n        dp[i][j]+=dp[i-1][j-1];\n\n      // put '0'*k '1'\n      if(i>=(a+1) and j>=(a+1))\n        dp[i][j]+=sm[i-(a+1)][j-(a+1)];\n    }\n\n    ac[i+1]=ac[i];\n    for(int j=0;j<b;j++){\n      ac[i+1]+=dp[i][j];\n\n      // put '0' * (n-i)\n      if(i<n and (((n-i)<a) or (j+(n-i)<b))) ans+=dp[i][j];\n\n      // accumulate\n      sm[i][j]=((i-1>=0 and j-1>=0)?sm[i-1][j-1]:M(0))+dp[i][j];\n    }\n\n    // reset\n    for(int j=b;j<=n;j++) dp[i][j]=0;\n  }\n\n  for(int j=0;j<b;j++)\n    ans+=dp[n][j];\n\n  cout<<M(2).pow(n)-ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n\n    vl dp1(b + 1);\n    vl dp2(b + 1);\n    dp1[1] = 1;\n    dp2[1] = 1;\n    for (int i = 1; i < b; i++) {\n        (dp1[i + 1] += dp1[i]) %= MOD;\n        (dp2[i + 1] += dp1[i]) %= MOD;\n        for (int j = a; i + j <= b; j++) {\n            if (i + j + 1 <= b) {\n                (dp1[i + j + 1] += dp1[i]) %= MOD;\n                (dp2[i + j + 1] += dp1[i]) %= MOD;\n            }\n            (dp2[i + j] += dp1[i]) %= MOD;\n        }\n    }\n    // DEBUG_VEC(dp1);\n    // DEBUG_VEC(dp2);\n\n    vll dp(n + 1, vl(2));\n    dp[0][0] = dp[0][1] = 1;\n    rep (i, n) {\n        rep (j, 2) {\n            if (dp[i][j] == 0) continue;\n            if (j == 0) {\n                for (int k = 1; k <= b - 1; k++) {\n                    if (i + k > n) break;\n                    if (i != 0) {\n                        if (i + k < n) {\n                            (dp[i + k][1] += dp[i][j] * dp1[k] % MOD) %= MOD;\n                        }\n                        else if (i + k == n) {\n                            (dp[i + k][1] += dp[i][j] * dp2[k] % MOD) %= MOD;\n                        }\n                    }\n                    else {\n                        (dp[i + k][1] += dp[i][j] * dp2[k] % MOD) %= MOD;\n                    }\n                }\n            }\n            else {\n                for (int k = 1; k <= a - 1; k++) {\n                    if (i + k > n) break;\n                    (dp[i + k][0] += dp[i][j] % MOD) %= MOD;\n                }\n            }\n        }\n    }\n    // DEBUG_MAT(dp);\n    ll ans = mod_pow(2, n) - dp[n][0] - dp[n][1];\n    cout << (ans % MOD + MOD) % MOD << endl;\n\n\n    // int ans2 = 0;\n    // rep (i, 1 << n) {\n    //     int x = i;\n    //     int cnt = 0;\n    //     rep (j, n) {\n    //         if (i & (1 << j)) cnt++;\n    //         else {\n    //             if (cnt >= a) {\n    //                 rep1 (k, cnt) {\n    //                     int m = j - k;\n    //                     x -= 1 << m;\n    //                 }\n    //             }\n    //             cnt = 0;\n    //         }\n    //     }\n    //     if (cnt >= a) {\n    //         rep1 (k, cnt) {\n    //             int m = n - k;\n    //             x -= 1 << m;\n    //         }\n    //     }\n    //     cnt = 0;\n    //     bool flag = false;\n    //     rep (j, n) {\n    //         if ((x & (1 << j)) == 0) {\n    //             cnt++;\n    //             if (cnt >= b) flag = true;\n    //         }\n    //         else cnt = 0;\n    //     }\n    //     if (flag) ans2++;\n    //     else {\n    //         DEBUG(i);\n    //     }\n    // }\n\n    // cout << ans2 << endl;\n}\n\n// signed main() {\n//     int n, a, b;\n//     cin >> n >> a >> b;\n//     // if (a > b) swap(a, b);\n\n//     // int ans2 = 0;\n//     // rep (i, 1 << n) {\n//     //     int x = i;\n//     //     int cnt = 0;\n//     //     rep (j, n) {\n//     //         if (i & (1 << j)) cnt++;\n//     //         else {\n//     //             if (cnt >= a) {\n//     //                 rep1 (k, cnt) {\n//     //                     int m = j - k;\n//     //                     x -= 1 << m;\n//     //                 }\n//     //             }\n//     //             cnt = 0;\n//     //         }\n//     //     }\n//     //     if (cnt >= a) {\n//     //         rep1 (k, cnt) {\n//     //             int m = n - k;\n//     //             x -= 1 << m;\n//     //         }\n//     //     }\n//     //     cnt = 0;\n//     //     bool flag = false;\n//     //     rep (j, n) {\n//     //         if ((x & (1 << j)) == 0) {\n//     //             cnt++;\n//     //             if (cnt >= b) flag = true;\n//     //         }\n//     //         else cnt = 0;\n//     //     }\n//     //     if (flag) ans2++;\n//     // }\n//     // cout << ans2 << endl;\n\n//     vector<vector<vll>> dp(n + 1, vector<vll>(n + 1, vll(n + 1, vl(2))));\n//     dp[0][0][0][0] = 1;\n//     rep (i, n) {\n//         rep (j, n + 1) {\n//             rep (k, n + 1) {\n//                 rep (l, 2) {\n//                     if (dp[i][j][k][l] == 0) continue;\n//                     int nl = l;\n//                     if (k + 1 >= b) nl = 1;\n//                     (dp[i + 1][j + 1][k + 1][nl] += dp[i][j][k][l]) %= MOD;\n//                     nl = l;\n//                     if (j >= a) {\n//                         if (k + 1 >= b) nl = 1;\n//                         (dp[i + 1][0][k + 1][nl] += dp[i][j][k][l]) %= MOD;\n//                     }\n//                     else {\n//                         if (1 >= b) nl = 1;\n//                         (dp[i + 1][0][1][nl] += dp[i][j][k][l]) %= MOD;\n//                     }\n//                 }\n//             }\n//         }\n//     }\n\n//     ll ans = 0;\n//     rep (j, n + 1) rep (k, n + 1) ans += dp[n][j][k][1];\n//     ans %= MOD;\n//     cout << ans << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n  LL dp[5001][5001][2];\nclass Solver2 {\n public:\n  int n, a, b;\n\n\n  Solver2(int n, int a, int b) : n(n), a(a), b(b){};\n\n  void solve() {\n    if (a < b) swap(a, b);\n    dp[0][0][0] = LL(1);\n    dp[2][1][0] = LL(MOD - 1);\n    auto ans = Modint<>(0);\n    for (int i = 0; i <= n; ++i) {\n      if (i > 0) dp[i][1][0] += dp[i - 1][1][0];\n      dp[i][1][0] %= MOD;\n      for (int j = 0; j < a; ++j) {\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] += dp[i][j][0];\n        if (i + 2 <= n) dp[i + 2][1][0] += dp[i][j][0];\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] -= dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] += dp[i][j][1];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][1];\n\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] %= MOD;\n        if (i + 2 <= n) dp[i + 2][1][0] %= MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] += MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] %= MOD;\n      }\n      auto cf = Modint<>(2).mpow(n - i);\n      for (int j = a; j <= n; ++j) {\n        ans += (dp[i][j][0] + dp[i][j][1]) * cf;\n      }\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, a, b;\n  std::cin >> n >> a >> b;\n\n  Problem::Solver2 sol(n, a, b);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    ll dp[n+1][n+1];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    ll sum1[n+1];\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    ll sum2[n+1][n+1];\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,i+1){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    /*rep(i,0,n+1){\n        rep(j,0,n+1)cout<<dp[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(long long i=0; i<(long long)(n); i++)\n#define REP(i, k, n) for(long long i=(long long)(k); i<(long long)(n); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define PQ(T) priority_queue<T>\n#define PQS(T) priority_queue<T, vector<T>, greater<T> >\n#define deci cout << fixed << setprecision(15);\ntypedef long long ll;\nconst ll inf = 1020304050607080910;\nconst int INF = 2000000000;\nconst ll mod = 1000000007;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T> bool chmin(T&x,T y){if(x>y){x=y;return true;}return false;}\ntemplate<class T> bool chmax(T&x,T y){if(x<y){x=y;return true;}return false;}\nll gcd(ll x,ll y){if(x>y)swap(x, y);while(x!=0){y%=x;swap(x, y);}return y;}\nll mpow(ll x,ll r){if(r==0)return 1;if(r%2==1){return x*mpow(x,r-1)%mod;}else{ll aa=mpow(x,r/2);return aa*aa%mod;}}\n\nint main(){\n\tint N, A, B; cin >> N >> A >> B;\n\tif(A<B) swap(A, B);\n\tll dpb[N+1], dp[N+1], sum[N+1], sum2[N+1];\n\trep(i, B) dpb[i] = 1;\n\tfor(int i=B; i<=N; i++){\n\t\tdpb[i] = dpb[i-1];\n\t\tfor(int j=B; j<=i; j++){\n\t\t\tif(j==i) dpb[i] = (dpb[i] + 1) % mod;\n\t\t\telse dpb[i] = (dpb[i] + dpb[i-j-1]) % mod;\n\t\t}\n\t}\n\tsum2[0] = dpb[0];\n\trep(i, N) sum2[i+1] = (sum2[i] + dpb[i+1]) % mod;\n\tdp[0] = 0, sum[0] = 0;\n\tfor(int i=1; i<=N; i++){\n\t\tdp[i] = 0;\n\t\tfor(int j=1; j<=min(i-1, A-1); j++){\n\t\t\tll s, cnt = 0;\n\t\t\tif(j==i-1){ dp[i] = (dp[i] + dpb[max(0, j-2)]) % mod; continue; }\n\t\t\tif(i-(j+B-1)<=A-1){\n\t\t\t\tif(i-j-B+1<=0){\n\t\t\t\t\tint l = min(A-1, i-j-1);\n\t\t\t\t\tcnt = (cnt + sum2[l-1]+1)%mod;\n\t\t\t\t}else{\n\t\t\t\t\tint l = min(i-j-1, A-1);\n\t\t\t\t\tcnt = (cnt + sum2[l-1] + mod - sum2[i-j-B]+dpb[i-j-B])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i-j-B+1 < 0) s = sum[i-j-1];\n\t\t\telse s = (sum[i-j-1] + mod - sum[i-j-B+1] + dp[i-j-B+1]) % mod;\n\t\t\tcnt = (cnt + s) % mod;\n\t\t\tif(j==1) dp[i] = (dp[i] + cnt) % mod;\n\t\t\telse dp[i] = (dp[i] + dpb[j-2]*cnt) % mod;\n\t\t}\n\t\tsum[i] = (sum[i-1] + dp[i]) % mod;\n\t}\n\tll ans = mpow(2, N);\n\tll c = 0;\n\tfor(int i=0; i<=A-1; i++){\n\t\tfor(int j=1; j<=B-1; j++){\n\t\t\tif(i+j>N) continue;\n\t\t\tif(N-i-j<=A-1){\n\t\t\t\tc = (c + dpb[max(0, i-1)]*dpb[max(0, N-i-j-1)]) % mod;\n\t\t\t}\n\t\t\tc = (c + dpb[max(0, i-1)]*dp[N-i-j])%mod;\n\t\t}\n\t}\n\tcout << (ans - c + 2*mod) % mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9) + 7>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nusing ll = long long;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n, a, b;\n\tcin >> n >> a >> b;\n\tif(a > b) swap(a, b);\n\tvector<vector<num> > waysb(n+1, vector<num>(n+1, 0));\n\tvector<vector<num> > waysa(n+1, vector<num>(n+1, 0));\n\twaysb[0][0] = 1;\n\tvector<num> bada(n+1, 0);\n\tfor(int i = 0; i < n; i++){\n\t\tnum totalb = 0;\n\t\tfor(int j = 0; j < b; j++) totalb += waysb[i][j];\n\t\tfor(int j = b; j <= n; j++){\n\t\t\twaysa[i+1][j] += waysa[i][j] * 2;\n\t\t\twaysb[i+1][j] += waysb[i][j] * 2;\n\t\t}\n\t\tfor(int j = 0; j <= i && j < b; j++){\n\t\t\twaysa[i+1][j+1] += waysa[i][j];\n\t\t\twaysb[i+1][j+1] += waysa[i][j];\n\t\t\twaysb[i+1][j+1] += waysb[i][j];\n\t\t}\n\t\twaysb[i+1][1] += bada[i];\n\t\tif(i + a <= n){\n\t\t\tfor(int j = 0; j <= i && j < b; j++){\n\t\t\t\twaysa[i+a][j+a] += waysb[i][j];\n\t\t\t}\t\t\t\n\t\t}\n\t\tfor(int ri = i+1; ri < i+a && ri <= n; ri++){\n\t\t\tbada[ri] += totalb;\n\t\t}\n\t}\n\tnum ans = 0;\n\tfor(int j = b; j <= n; j++){\n\t\tans += waysa[n][j];\n\t\tans += waysb[n][j];\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAX_N = int(5e3) + 10;\nconst int mod = int(1e9) + 7;\n\nint add(int a, int b) {\n\treturn (a + b) >= mod ? a + b - mod : a + b;\n}\n\nint mul(int a, int b) {\n\treturn 1LL * a * b % mod;\n}\n\nint sub(int a, int b) {\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\n\nint n, a, b, g[MAX_N][2], f[MAX_N][2];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tif (a > b) std::swap(a, b);\n\tint ans = 0;\n\tif (b > 1) {\n\t\tf[0][0] = f[0][1] = 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\t\tif (k == 0 && j < a) continue;\n\t\t\t\t\tf[i][k] = add(f[i][k], f[i - j][k ^ 1]);\n\t\t\t\t}\n\t\tf[0][0] = 0;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tif (i < a) g[i][0] = 1;\n\t\t\tfor (int j = 1; j < std::min(i, a); ++j)\n\t\t\t\tg[i][0] = add(g[i][0], g[i - j][1]);\n\t\t\tif (i < b)\n\t\t\t\tg[i][1] = add(f[i - 1][0], f[i - 1][1]);\n\t\t\tfor (int j = 1; j < std::min(i, b); ++j) {\n\t\t\t\tint coef = j == 1 ? 1 : add(f[j - 2][0], f[j - 2][1]);\n\t\t\t\tg[i][1] = add(g[i][1], mul(g[i - j][0], coef));\n\t\t\t}\n\t\t\tif (n - i < b)\n\t\t\t\tans = add(ans, mul(g[i][0], add(f[n - i - 1][0], f[n - i - 1][1])));\n\t\t\tif (n - i < a)\n\t\t\t\tans = add(ans, g[i][1]);\n\t\t}\n\t}\n\tint tot = 1;\n\tfor (int i = 1; i <= n; ++i) tot = add(tot, tot);\n\tprintf(\"%d\\n\", add(tot, mod - ans));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define int long long\n#define P pair<int,int>\n#define all(vec) vec.begin(),vec.end()\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nint kai(int x, int y, int m) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y, int m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst int mod = 1000000007;\n\nint n, a, b;\nint d[5010][5010];\nint cnt[5010];\nint cnt1;\nint ans = 1;\n\nsigned main() {\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)ans = ans * 2 % mod;\n\tif (a == 1 || b == 1) {\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif (a > b)swap(a, b);\n\td[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < b; j++)d[i][j] = d[i - 1][j - 1];\n\t\td[i][1] = (d[i][1] + cnt1) % mod;\n\t\tfor (int j = 1; j < min(i + 1, b); j++)d[i][j] = (d[i][j] + cnt[i - j]) % mod;\n\t\tfor (int j = 0; j < b; j++)cnt1 = (cnt1 + d[i - 1][j]) % mod;\n\t\tif (a <= i) {\n\t\t\tfor (int j = 0; j < min(i + 1 - a, b); j++)cnt[i - a - j] = (cnt[i - a - j] + d[i - a][j]) % mod;\n\t\t\tfor (int j = 0; j < min(i + 1 - a, b); j++)cnt1 = (cnt1 - d[i - a][j] + mod) % mod;\n\t\t}\n\t\tif (b <= i - 1)for (int j = 0; j < min(i - b + 3, b); j++)cnt[i - b + 2 - j] = (cnt[i - b + 2 - j] - d[i - b + 2][j] + mod) % mod;\n\t\tif (b == i - 1)cnt[0] = (cnt[0] - 1 + mod) % mod;\n\t}\n\tfor (int i = n; i > n - a; i--) {\n\t\tfor (int j = 0; j < b; j++)ans = (ans - d[i][j] + mod) % mod;\n\t}\n\tfor (int i = n - a; i > n - b; i--) {\n\t\tfor (int j = 0; j < b - (n - i); j++)ans = (ans - d[i][j] + mod) % mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9+7;\nint dp0[5005][5005], dp1[5005][5005], dp2[5005][5005], sum1[5005][5005];\nint main(){\n    int n, a, b;\n    scanf(\"%d%d%d\", &n, &a, &b);\n    if(a > b) swap(a, b);\n    dp1[0][0] = 1;\n    for(int j=0;j<=n;j++) sum1[0][j] = 1;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=a-1;j++) dp0[i][0] = (dp0[i][0] + sum1[i-j][n])%mod;\n        for(int j=0;j<=b-a-1;j++) dp2[i][j+a] = (dp2[i][j+a] + dp1[i-a][j])%mod;\n\n        for(int j=0;j<b-1;j++){\n            dp2[i][j+1] = (dp2[i][j+1] + dp2[i-1][j])%mod;\n        }\n        for(int j=0;j<b-1;j++){\n            dp1[i][j+1] = (dp1[i][j+1] + dp0[i-1][j])%mod;\n            dp1[i][j+1] = (dp1[i][j+1] + dp1[i-1][j])%mod;\n            dp1[i][j+1] = (dp1[i][j+1] + dp2[i-1][j])%mod;\n        }\n\n        for(int j=0;j<=n;j++){\n            if(j == 0) sum1[i][j] = dp1[i][j];\n            else sum1[i][j] = (sum1[i][j-1] + dp1[i][j])%mod;\n        }\n    }\n    int ans = 1;\n    for(int i=1;i<=n;i++) ans = ans*2%mod;\n    for(int j=0;j<=n;j++){\n        ans = (ans - dp0[n][j] + mod)%mod;\n        ans = (ans - dp1[n][j] + mod)%mod;\n        ans = (ans - dp2[n][j] + mod)%mod;\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nconst int64 MODULO = (int64) 1e9 + 7;\n\nclass TaskC {\n public:\n  void solveOne(istream &in, ostream &out) {\n    int n, a, b;\n    in >> n >> a >> b;\n    if (a > b) {\n      int t = a;\n      a = b;\n      b = t;\n    }\n    vector<vector<int64>> diagSum(n + 1, vector<int64>(b));\n    vector<vector<int64>> d(n + 1, vector<int64>(b));\n    vector<int64> dPrefSum(n + 1);\n    d[0][0] = 1;\n    dPrefSum[0] = 1;\n    diagSum[0][0] = 1;\n    int64 finish = 0;\n    for (int i = 1; i <= n; ++i) {\n      dPrefSum[i] = dPrefSum[i - 1];\n      for (int j = 1; j < b; ++j) {\n        d[i][j] = d[i - 1][j - 1];\n        if (i >= a + 1 && j >= a + 1) {\n          d[i][j] += diagSum[i - a - 1][j - a - 1];\n          if (d[i][j] >= MODULO) d[i][j] -= MODULO;\n        }\n        if (j == 1 && i >= 2) {\n          d[i][j] += dPrefSum[i - 2];\n          if (d[i][j] >= MODULO) d[i][j] -= MODULO;\n          if (i > a) {\n            d[i][j] -= dPrefSum[i - a - 1];\n            if (d[i][j] < 0) d[i][j] += MODULO;\n          }\n        }\n        diagSum[i][j] = d[i][j] + diagSum[i - 1][j - 1];\n        if (diagSum[i][j] >= MODULO) diagSum[i][j] -= MODULO;\n        dPrefSum[i] += d[i][j];\n        if (dPrefSum[i] >= MODULO) dPrefSum[i] -= MODULO;\n        if (n - i < a || j + n - i < b) {\n          finish += d[i][j];\n          if (finish >= MODULO) finish -= MODULO;\n        }\n      }\n    }\n    int64 res = 1;\n    for (int i = 0; i < n; ++i) res = res * 2 % MODULO;\n    res = (res + MODULO - finish) % MODULO;\n    out << res << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskC solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    inline modint &operator ^= (ll b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    inline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e6 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nconst int N = 5e3 + 7;\nint n, a, b;\n\ninline modint F(int n, int m) {\n\treturn binom(n + m - 1, m - 1);\n}\n\nmodint f[N], g[N], h[2][N], w[N];\n\nint main() {\n//\tfl(\"1\");\n\trd(n, a, b), init(1e6);\n\tif (a > b) swap(a, b);\n\tfor (int i = 1; i < a; i++) f[i] = 1;\n\tfor (int i = 1; i < b; i++) {\n\t\tfor (int j = 0; j * (a + 1) < i; j++)\n\t\t\tg[i] += F(i - j * (a + 1) - 1, j * 2 + 1);\n\t\tw[i] = g[i];\n\t\tfor (int j = 0; j * (a + 1) <= i; j++)\n\t\t\tw[i] += F(i - j * (a + 1), j * 2);\n\t}\n\th[0][0] = h[1][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\th[0][i] += h[1][i-j] * f[j], h[1][i] += h[0][i-j] * (i == j ? w[j] : (i == n ? w[j] : g[j]));\n//\t\tdebug(\"%d %d %d\\n\", i, h[0][i].x, h[1][i].x);\n\t}\n\tprint(((modint)2 ^ n) - h[0][n] - h[1][n]);\n\treturn 0;\n}\n\n/*\n0 0 0 1\n0 0 1 0\n0 1 0 0\n0 1 0 1\n1 0 0 0\n1 0 0 1\n1 0 1 0\n1 0 1 1\n1 1 0 1\n*/"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n    //繰り返し二条法\n    auto res = (Arithmetic)(1);\n    while (n > 0) {\n        if (n & 1) res *= bace;\n        bace *= bace;\n        n >>= 1;\n    }\n    return res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n    if (N <= 1) {\n        return false;\n    }\n    for (size_t i = 2; i * i <= N; ++i)\n    {\n        if (N % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n    static constexpr auto MOD = MOD_;\n    static_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n    static_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n    static_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n    constexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n    {\n        auto v = *this;\n        return v += other;\n    }\n    constexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n    {\n        auto v = *this;\n        return v -= other;\n    }\n    constexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n    {\n        auto v = *this;\n        return v *= other;\n    }\n    constexpr auto operator/(const mint_base<MOD>& other)const noexcept\n    {\n        auto v = *this;\n        return v /= other;\n    }\n    constexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n    {\n        a += other.a;\n        if (MOD <= a) { a -= MOD; };\n        return *this;\n    }\n    constexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n    {\n        if (a >= other.a) {\n            a -= other.a;\n        }\n        else {\n            a = (a + MOD) - other.a;\n        }\n        return *this;\n    }\n    constexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n    {\n#if 1\n        a *= other.a;\n        a %= MOD;\n#else\n        //MOD <= (MAXUINT64 / 2)条件下\n        uint64_t b = other.a, v = 0;\n        while (b > 0) {\n            if (b & 1) {\n                v += a;\n                if (v >= MOD)v -= MOD;\n            }\n            a += a;\n            if (MOD <= a)a -= MOD;\n            b >>= 1;\n        }\n        a = v;\n#endif\n        return *this;\n    }\n    constexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n    {\n        return *this *= ~other;\n    }\n    constexpr mint_base<MOD> operator+()const noexcept { return *this; }\n    constexpr mint_base<MOD> operator-()const noexcept\n    {\n        return{ MOD - a, mod_value_tag{} };\n    }\n    constexpr mint_base<MOD>& operator++() noexcept\n    {\n        if (MOD <= ++a) { a = 0; };\n        return *this;\n    }\n    constexpr mint_base<MOD>& operator--() noexcept\n    {\n        if (a <= 0) { a = MOD; };\n        --a;\n        return *this;\n    }\n    constexpr mint_base<MOD> operator++(int) noexcept\n    {\n        auto tmp = *this;\n        ++* this;\n        return tmp;\n    }\n    constexpr mint_base<MOD> operator--(int) noexcept\n    {\n        auto tmp = *this;\n        --* this;\n        return tmp;\n    }\n    constexpr mint_base<MOD> operator~()const noexcept\n    {\n        return ipow(*this, e_phi - 1);\n    }\n    constexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n    {\n        a = other.a;\n        return *this;\n    }\n    constexpr explicit operator uint64_t()const noexcept\n    {\n        return a;\n    }\n    constexpr explicit operator unsigned()const noexcept\n    {\n        return (unsigned)a;\n    }\n    static constexpr uint64_t getmod() noexcept\n    {\n        return MOD;\n    }\n    constexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n    constexpr mint_base()noexcept : a(0) {}\n    struct mod_value_tag {};\n    constexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n    static constexpr uint64_t get_e_phi()noexcept {\n        //オイラー値の導出\n        uint64_t temp = MOD;\n        uint64_t m_ = MOD;\n        for (uint64_t i = 2; i * i <= m_; ++i)\n        {\n            if (m_ % i == 0)\n            {\n                temp = temp / i * (i - 1);\n                for (; m_ % i == 0; m_ /= i);\n            }\n        }\n        if (m_ != 1)temp = temp / m_ * (m_ - 1);\n        return temp;\n    }\n    static constexpr uint64_t e_phi = get_e_phi();//オイラー値\n    uint64_t a;\n};\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n    os << (uint64_t)i;\n    return os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n    uint64_t tmp;\n    is >> tmp;\n    i = tmp;\n    return is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n    constexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n        return mint(x);\n    }\n}\nusing namespace mint_literal;\n\nint32_t N,A,B;\nmint pow2[5100];\n\nmint func(int i, int a_end, bool prev_is_b);\nmint func_sum(int i, int k)\n{\n    static mint dp[5100][5100];\n    static bool used[5100][5100];\n    //for (int k = 1; k < B; k++) {\n    //    res += func(i + k + 1, i + k + A, false);\n    //}\n\n    if (k >= B) {\n        return 0_mi;\n    }\n    auto& memo = dp[i][k];\n    if (used[i][k]) {\n        return memo;\n    }\n    used[i][k] = true;\n\n    memo = func(i + k + 1, i + k + A, false);\n    memo += func_sum(i, k + 1);\n    return memo;\n}\n\n//Aは[a_end-A, a_end)\nmint func(int i, int a_end, bool prev_is_b)\n{\n    static mint dp[5100][5100][2];\n    static bool used[5100][5100][2];\n    if (N < i || N + 1 <= a_end) {\n        return 0_mi;//入りきってない\n    }\n    if (a_end <= i) {\n        return pow2[N - i];//あとは自由\n    }\n\n    auto& memo = dp[i][a_end][prev_is_b ? 0 : 1];\n    if (used[i][a_end][prev_is_b ? 0 : 1]) {\n        return memo;\n    }\n    used[i][a_end][prev_is_b ? 0 : 1] = true;\n\n    mint res = 0;//mintは自動MODの整数型\n\n    if (prev_is_b) {\n        //Bの終わった直後\n        res += func(i + 1, a_end, false);//0を置く\n        res += func(i + 1, a_end, true);//1を置く\n    }\n    else {\n        //Aの中\n        res += func(i + 1, a_end, false);//0を置く\n        //for (int k = 1; k < B; k++) {//1をk個と0を一個置く\n        //    //Bの途中で0を置く\n        //    res += func(i + k + 1, i + k + A, false);\n        //    //↑最後に0を置いたのでAの中にいる\n        //}\n        res += func_sum(i, 1);\n        res += func(i + B, a_end, true);//1をB個\n    }\n    return memo = res;\n}\n\n//Aは[a_end-A, a_end), Bは[b_end-B, b_end)\nmint func_ON3(int i, int a_end, int b_end)\n{\n    static mint dp[100][100][100];\n    static bool used[100][100][100];\n    if (N+1 <= a_end || N + 1 <= b_end) {\n        return 0_mi;//入りきってない\n    }\n    if (a_end <= i && b_end <= i) {\n        return pow2[N - i];//あとは自由\n    }\n\n    auto& memo = dp[i][a_end][b_end];\n    if (used[i][a_end][b_end]) {\n        return memo;\n    }\n    used[i][a_end][b_end] = true;\n\n    mint res = 0;//mintは自動MODの整数型\n    if (i < b_end) {//Bの中\n        res += func_ON3(i + 1, i + A, 0);//0を置く\n        res += func_ON3(i + 1, a_end, b_end);//1を置く\n    }\n    else if (B <= b_end && i == b_end) {//Bの終わった直後\n        res += func_ON3(i + 1, a_end, b_end);//0を置く\n        res += func_ON3(i + 1, a_end, b_end+1);//1を置く\n    }\n    else {//Aの中\n        res += func_ON3(i + 1, a_end, b_end);//0を置く\n        res += func_ON3(i + 1, a_end, i + B);//1を置く\n    }\n    return memo = res;\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n    pow2[0] = 1;\n    for (size_t i = 0; i < 5050; i++)\n    {\n        pow2[i + 1] = pow2[i] + pow2[i];\n    }\n\n    in >> N>>A>>B;\n    if (A < B) {\n        std::swap(A, B);\n    }\n    //if (N < 90) {\n    //    out << func_ON3(0, A, 0) << endl;\n    //    return 0;\n    //}\n\n    out << func(0, A, false) << endl;\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define Mod 1000000007\n\ntypedef struct List {\n\tstruct List *prev, *next;\n\tlong long v;\n} list;\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\tif (A > B) {\n\t\tB += A;\n\t\tA = B - A;\n\t\tB -= A;\n\t}\n\t\n\tint i, j, k;\n\tlist **head = (list**)malloc(sizeof(list*) * B), **tail = (list**)malloc(sizeof(list*) * B), *d = (list*)malloc(sizeof(list) * B * (A + 1)), *p;\n\tlong long ans = 0, dp[2][5001], tmp[2], pow;\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[A%2][A-1] = 2; j >= 1; j--) dp[A%2][j] = dp[A%2][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[1-i%2][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[i%2][1] = dp[1-i%2][A-1]; j >= 1; j--) {\n\t\t\t\tdp[i%2][j+1] = dp[1-i%2][j];\n\t\t\t\tdp[i%2][1] += dp[1-i%2][j];\n\t\t\t}\n\t\t\tdp[i%2][1] %= Mod;\n\t\t}\n\t} else {\n\t\tfor (j = 0; j <= B - 1; j++) {\n\t\t\thead[j] = &(d[j*(A+1)]);\n\t\t\ttail[j] = &(d[j*(A+1)+A]);\n\t\t\td[j*(A+1)].v = 0;\n\t\t\td[j*(A+1)].prev = &(d[j*(A+1)+A]);\n\t\t\td[j*(A+1)+A].next = &(d[j*(A+1)]);\n\t\t\tfor (k = 1; k <= A; k++) {\n\t\t\t\td[j*(A+1)+k].v = 0;\n\t\t\t\td[j*(A+1)+k].prev = &(d[j*(A+1)+k-1]);\n\t\t\t\td[j*(A+1)+k-1].next = &(d[j*(A+1)+k]);\n\t\t\t}\n\t\t}\n\t\td[1].v = 1;\n\t\td[A+1].v = 1;\n\t\tfor (i = 2, pow = 2; i <= N; i++, pow = pow * 2 % Mod) {\n\t\t\tfor (j = 0, tmp[0] = 0; j <= B - 1; j++) tmp[0] += head[j]->v + tail[j]->v;\n\t\t\ttmp[0] = (pow - ans - tmp[0] + tail[B-A]->v) % Mod;\n\t\t\tif (tmp[0] < 0) tmp[0] += Mod;\n\t\t\tans = (ans * 2 + head[B-1]->v + tail[B-A]->prev->v + tail[B-A-1]->v * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 1, tmp[1] = head[B-A]->v; j > B - A; j--) {\n\t\t\t\ttmp[1] += head[j]->v;\n\t\t\t\thead[j]->v = head[j-1]->v;\n\t\t\t\tif (j >= A + 1) head[j]->v = (head[j]->v + tail[j-A-1]->v) % Mod;\n\t\t\t}\n\t\t\thead[B-A]->v = tmp[1] % Mod;\n\t\t\ttail[B-A]->v = head[B-A-1]->v;\n\t\t\tif (B - A >= A + 1) tail[B-A]->v += tail[B-A*2-1]->v;\n\t\t\ttail[B-A]->v %= Mod;\n\t\t\thead[B-A] = tail[B-A];\n\t\t\ttail[B-A] = tail[B-A]->prev;\n\t\t\tfor (j = B - A - 1; j >= A + 1; j--) {\n\t\t\t\ttail[j]->prev->v = (tail[j]->prev->v + tail[j-1]->v) % Mod;\n\t\t\t\ttail[j]->v = (head[j-1]->v + tail[j-A-1]->v) % Mod;\n\t\t\t\thead[j] = tail[j];\n\t\t\t\ttail[j] = tail[j]->prev;\n\t\t\t}\n\t\t\tfor (; j >= 1; j--) {\n\t\t\t\ttail[j]->prev->v = (tail[j]->prev->v + tail[j-1]->v) % Mod;\n\t\t\t\ttail[j]->v = head[j-1]->v;\n\t\t\t\thead[j] = tail[j];\n\t\t\t\ttail[j] = tail[j]->prev;\n\t\t\t}\n\t\t\thead[1]->v = tmp[0];\n\t\t\thead[0] = tail[0];\n\t\t\ttail[0] = tail[0]->prev;\n\t\t\thead[0]->v = 0;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int mod = 1e9 + 7;\nint qpow(int x, int y)\n{\n\tint ret = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ret = 1ll * ret * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nconst int maxn = 5111;\nint dp[maxn][maxn][2], pre1[maxn][maxn][2], pre2[maxn];\nint n, a, b;\n\ninline void add(int &x, int y) { x += y; if(x >= mod) x -= mod; }\nint main()\n{\n\tget3(n, a, b);\n\tif(a > b) std::swap(a, b);\n\tif(a <= b)\n\t{\n\t\tdp[0][0][0] = dp[0][0][1] = 1;\n\t\tfor(int i=0; i<=n; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<=i; j++) for(int tp=0; tp<2; tp++)\n\t\t\t\t{\n\t\t\t\t\tadd(pre1[i][j][tp], pre1[i-1][j][tp]);\n\t\t\t\t\tdp[i][j][tp] = pre1[i][j][tp];\n\t\t\t\t}\n\t\t\t\tadd(pre2[i], pre2[i-1]);\n\t\t\t\tadd(dp[i][i][0], pre2[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0; j<=i; j++) for(int tp=0; tp<2; tp++) if(dp[i][j][tp])\n\t\t\t{\n\t\t\t\t// dp[i][j][tp] -> dp[i+k][j][tp ^ 1]\n\t\t\t\tint lb = i + (tp == 1 ? a : 1), rb = std::min(n, j + b - 1);\n\t\t\t\t// printf(\"i= %d j= %d tp= %d dp= %d\\n\", i, j, tp, dp[i][j][tp]);\n\t\t\t\tif(lb <= rb)\n\t\t\t\t{\n\t\t\t\t\tadd(pre1[lb][j][tp^1], dp[i][j][tp]);\n\t\t\t\t\tadd(pre1[rb+1][j][tp^1], mod - dp[i][j][tp]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(tp == 1)\n\t\t\t\t{\n\t\t\t\t\tint lb = i + 1, rb = std::min(n, i + a - 1);\n\t\t\t\t\t// if(i == 2) printf(\"j= %d tp= %d lb= %d rb= %d\\n\", j, tp, lb, rb);\n\t\t\t\t\tif(lb <= rb)\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(pre2[lb], dp[i][j][tp]);\n\t\t\t\t\t\tadd(pre2[rb+1], mod - dp[i][j][tp]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=1; i<=n; i++) for(int j=0; j<2; j++) add(ans, dp[n][i][j]);\n\t\tans = (qpow(2, n) + mod - ans) % mod;\n\t\tprintendl(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\ntemplate<long long Mod>\nstruct mint{\n    long long x;\n    mint(long long x=0) :x((x% Mod+Mod)%Mod){}\n\n    mint operator-() const { return mint(-x); }\n\n    mint& operator+=(const mint a) {\n        if((x += a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if((x += Mod-a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= Mod;\n        return *this;\n    }\n\n    mint operator^(long long t) const {\n        mint ret(1);\n        mint a = *this;\n        while(t){\n            if(t&1){\n                ret *= a;\n            }\n            a *= a;\n            t >>= 1;\n        }\n        return ret;\n    }\n    mint inv() const { return *this ^ (Mod-2); }\n    mint& operator/=(const mint a) { return *this *= a.inv(); }\n\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n\n    friend istream& operator>>(istream& is, mint& a) { return is >> a.x; }\n    friend ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n};\n\nint N, A, B;\n\nbool visA[5001][2];\nmint<MOD> dpA[5001][2];\nmint<MOD> countA(int L, int k=0){\n    if(L == 0){\n        if(k) return 1;\n        else return -1;\n    }\n    if(L < A) return 0;\n    if(visA[L][k]) return dpA[L][k];\n    visA[L][k] = true;\n    mint<MOD> ret = 0;\n    for(int i=1; i<=A && L-i>=0; i++){\n        ret += countA(L-i, k^1);\n    }\n    return dpA[L][k] = ret;\n}\n\nbool visB[5001];\nmint<MOD> dpB[5001];\nmint<MOD> countB(int L){\n    if(L <= 0){\n        return 1;\n    }\n    if(visB[L]) return dpB[L];\n    visB[L] = true;\n    mint<MOD> ret = countB(L-1);\n    for(int i=B; L-i>=0; i++){\n        ret += countB(L-i-1);\n    }\n    return dpB[L] = ret;\n}\n\nbool vis[5001][2];\nmint<MOD> dp[5001][2];\nmint<MOD> solve(int l, int a){\n    if(l == N){\n        if(a == 0) return 0;\n        return mint<MOD>(-1);\n    }\n    if(vis[l][a]) return dp[l][a];\n    vis[l][a] = true;\n    mint<MOD> ret = solve(l+1, a)*2;\n    for(int i=A; l+i<=N; i++){\n        ret -= solve(l+i, 1)*countA(i)*countB(i);\n    }\n    return dp[l][a] = ret;\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    if(B == 1){\n        cout << (mint<MOD>(2)^N) << endl;\n    }\n    else{\n        cout << solve(0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, a, b;\nint dp1[5001][2];\t//dp1[len][nowChar] : 1個以上の1, A個以上の0を交互に配置(1スタート)\nint dp2[5001][2];\t//dp2[len][nowChar] : nowChar = 0 : A個未満0, 1 : __(dp1を利用)\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n >> a >> b;\n\tif (a > b) swap(a, b);\n\t\n\tdp1[0][1] = 1;\n\tfor (i = 0; i < b; i++) {\n\t\t//dp1[i][0] -> dp1[i + a以上][1]\n\t\tfor (j = i + a; j < b; j++) {\n\t\t\tdp1[j][1] += dp1[i][0];\n\t\t\tdp1[j][1] %= mod;\n\t\t}\n\t\t//dp1[i][1] -> dp1[i + 1以上][0]\n\t\tfor (j = i + 1; j < b; j++) {\n\t\t\tdp1[j][0] += dp1[i][1];\n\t\t\tdp1[j][0] %= mod;\n\t\t}\n\t}\n\t\n\tdp2[0][0] = 1;\n\tdp2[0][1] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\t//dp2[i][0] -> dp2[i + a未満][1]\n\t\tfor (j = i + 1; j < i + a && j <= n; j++) {\n\t\t\tdp2[j][1] += dp2[i][0];\n\t\t\tdp2[j][1] %= mod;\n\t\t}\n\t\t//dp2[i][1] -> dp2[i + b未満][0]\n\t\tfor (j = i + 1; j < i + b && j <= n; j++) {\n\t\t\tdp2[j][0] += dp2[i][1] * dp1[j - i][0] % mod;\n\t\t\tdp2[j][0] %= mod;\n\t\t\tif (i == 0 || j == n) {\n\t\t\t\tdp2[j][0] += dp2[i][1] * dp1[j - i][1] % mod;\n\t\t\t\tdp2[j][0] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//余事象の個数はdp2[n][0] + dp2[n][1];\n\tint ng = (dp2[n][0] + dp2[n][1]) % mod;\n\n\t//全体2^N個から引けば答え\n\tint p2 = 1;\n\tfor (i = 0; i < n; i++) { p2 *= 2; p2 %= mod; }\n\t\n\tcout << (p2 + mod - ng) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9+7;\nint dp0[5005][5005], dp1[5005][5005], dp2[5005][5005], sum1[5005][5005];\nint main(){\n    int n, a, b;\n    scanf(\"%d%d%d\", &n, &a, &b);\n    if(a > b) swap(a, b);\n    dp1[0][0] = 1;\n    for(int j=0;j<=n;j++) sum1[0][j] = 1;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=a-1;j++) if(i-j >= 0) dp0[i][0] = (dp0[i][0] + sum1[i-j][n])%mod;\n        if(i >= a) for(int j=0;j<=b-a-1;j++) dp2[i][j+a] = (dp2[i][j+a] + dp1[i-a][j])%mod;\n\n        for(int j=0;j<b-1;j++){\n            dp2[i][j+1] = (dp2[i][j+1] + dp2[i-1][j])%mod;\n        }\n        for(int j=0;j<b-1;j++){\n            dp1[i][j+1] = (dp1[i][j+1] + dp0[i-1][j])%mod;\n            dp1[i][j+1] = (dp1[i][j+1] + dp1[i-1][j])%mod;\n            dp1[i][j+1] = (dp1[i][j+1] + dp2[i-1][j])%mod;\n        }\n\n        for(int j=0;j<=n;j++){\n            if(j == 0) sum1[i][j] = dp1[i][j];\n            else sum1[i][j] = (sum1[i][j-1] + dp1[i][j])%mod;\n        }\n    }\n    int ans = 1;\n    for(int i=1;i<=n;i++) ans = ans*2%mod;\n    for(int j=0;j<=n;j++){\n        ans = (ans - dp0[n][j] + mod)%mod;\n        ans = (ans - dp1[n][j] + mod)%mod;\n        ans = (ans - dp2[n][j] + mod)%mod;\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define all(a) (a).begin(),(a).end()\n#define SZ(a) ((int)((a).size()))\n\ntypedef long long ll;\ntypedef long double lf;\n\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst lf pi=acosl(-1);\n/* Source code starts here */\n\nint n,a,b;\nconst int jt=1000000007;\nint dp[5005][5005][2],qzh1[5005],qzh2[5005][5005];\nvoid inline add(int &a,int b){a+=b;if(a>=jt)a-=jt;if(a<0)a+=jt;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a<b)swap(a,b);\n\tdp[0][0][1]=1;\n\tloop(i,n+1){\n\t\tif(i)add(qzh1[i],qzh1[i-1]);\n\t\tadd(dp[i][0][0],qzh1[i]);\n\t\tloop(j,i+1){\n\t\t\tif(i)add(qzh2[i-j][i],qzh2[i-j][i-1]);\n\t\t\tadd(dp[i][j][0],qzh2[i-j][i]);\n\t\t\tif(j==a){\n\t\t\t\tadd(dp[i][j][1],dp[i][j][0]);dp[i][j][0]=0;\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][0]);\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][1]);\n\t\t\tadd(qzh1[i+1],dp[i][j][1]);\n\t\t\tif(i+b<=n){\n\t\t\t\tadd(qzh1[i+b],-dp[i][j][1]);\n\t\t\t\tif(j+b<=a)add(qzh2[i-j][i+b],dp[i][j][1]);\n\t\t\t\telse add(dp[i+b][a][1],dp[i][j][1]);\n\t\t\t}\n\t\t}\n\t}\n\tadd(dp[n][a][1],dp[n][a][0]);\n\tprintf(\"%d\\n\",dp[n][a][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=5005,INF=1<<30;\n\nll dp[MAX][MAX];\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nll sum[MAX];\nll naname[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,A,B;cin>>N>>A>>B;\n    if(A>B) swap(A,B);\n    if(A==1){\n        cout<<rui(2,N)<<endl;\n        return 0;\n    }\n    dp[0][0]=1;\n    sum[0]=1;\n    naname[0][0]=1;\n    \n    for(int i=1;i<=N;i++){\n        for(int j=0;j<B;j++){\n            if(j) dp[i][j]+=dp[i-1][j-1];\n            \n            if(j==1){\n                //dp[i][j]+=(mod+sum[max(0,i-2)]-sum[max(0,i-A)]);\n                //dp[i][j]%=mod;\n                \n                if(i-2>=0) dp[i][j]+=sum[i-2];\n                if(i-(A+1)>=0) dp[i][j]+=mod-sum[i-(A+1)];\n                dp[i][j]%=mod;\n                /*for(int k=2;k<=A;k++){\n                    for(int l=0;l<=B-1;l++){\n                        if(i-k>=0) dp[i][j]+=dp[i-k][l];\n                        dp[i][j]%=mod;\n                    }\n                }*/\n            }\n            \n            if(i-(A+1)>=0&&j-(A+1)>=0) dp[i][j]+=naname[i-(A+1)][j-(A+1)];\n            dp[i][j]%=mod;\n            //dp[i][j]+=mod-naname[max(0,i-(A+1))][max(0,j-(A+1))]-naname[max(0,i-N)][max(0,j-N)];\n            //dp[i][j]%=mod;\n            \n            /*for(int k=A+1;k<=N;k++){\n                if(i-k>=0&&j-k>=0) dp[i][j]+=dp[i-k][j-k];\n                dp[i][j]%=mod;\n            }*/\n        }\n        \n        ll S=0;\n        for(int l=0;l<=B-1;l++){\n            S+=dp[i][l];\n            //S%=mod;\n            if(S>=mod) S-=mod;\n        }\n        sum[i]=sum[i-1]+S;\n        //sum[i]%=mod;\n        if(sum[i]>=mod) sum[i]-=mod;\n        \n        naname[i][0]=dp[i][0];\n        for(int j=1;j<=N;j++){\n            naname[i][j]=naname[i-1][j-1]+dp[i][j];\n            //naname[i][j]%=mod;\n            if(naname[i][j]>=mod) naname[i][j]-=mod;\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=1;i<N;i++){\n        for(int j=1;j<B;j++){\n            if(N-i<A||j+N-i<B){\n                ans+=dp[i][j];\n                //ans%=mod;\n                if(ans>=mod) ans-=mod;\n            }\n        }\n    }\n    \n    for(int j=0;j<B;j++){\n        ans+=dp[N][j];\n        ans%=mod;\n    }\n    \n    cout<<(mod+rui(2,N)-ans)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#include <set>\n#include <math.h>\n#define pai arccos(-1);\n#define keta(n) cout << fixed << setprecision((n));\n#define ll long long;\nint main()\n{\n  string t;\n  cin >> t;\n  int ans = 0;\n\n  for (int i = 0; i < t.size(); i++) {\n    if (t[i] == '?') {\n      t[i] = 'P';\n    }\n\n    if (t[i] == 'P' && t[i + 1] == 'D' || t[i] == 'D' && t[i + 1] == 'D') {\n      ans++;\n    }\n  }\n\n  cout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,mod=1e9+7;\nint n,a,b;\nll f[N],c[N][N],dp[N][2];\nll C(int n,int m)\n{\n    if(m==0||n==m) return 1;\n    if(m==1) return n;\n    if(c[n][m]) return c[n][m];\n    return c[n][m]=(C(n-1,m-1)+C(n-1,m))%mod;\n}\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    for(;n;n>>=1,a=a*a%mod)if(n&1) ans=ans*a%mod;\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b) swap(a,b);\n    f[1]=1;\n    for(int i=1;i<b;i++)\n    {\n        f[i+1]=(f[i+1]+f[i])%mod;\n        for(int j=a;i+j+1<=b;j++)\n                f[i+j+1]=(f[i+j+1]+f[i])%mod;\n    }\n    dp[0][0]=dp[0][1]=1;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=i+1;j<i+a&&j<=n;j++)\n            (dp[j][0]+=dp[i][1])%=mod;\n        for(int j=i+1;j<i+b&&j<=n;j++)\n            (dp[j][1]+=dp[i][0]*f[j-i+(i==0||j==n)])%=mod;\n    }\n    ll ans=qpow(2,n);\n    ans=(ans-dp[n][0]-dp[n][1])%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1000000000000000000\n\nvoid get(int N,int A,int B){\n\tint a=0,b=0;\n\tfor(int i=0;i<(1<<N);i++){\n\t\tstring s = \"\";\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i>>j)&1)s += '0';\n\t\t\telse s += '1';\n\t\t}\n\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(j+A-1>=N)break;\n\t\t\tbool f = true;\n\t\t\tfor(int k=0;k<A;k++){\n\t\t\t\tif(s[j+k]!='0'){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tfor(int k=j;k<N;k++){\n\t\t\t\t\tif(s[k]=='0')s[k]='1';\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(j+B-1>=N)break;\n\t\t\tbool F = true;\n\t\t\tfor(int k=0;k<B;k++){\n\t\t\t\tif(s[j+k]!='1'){\n\t\t\t\t\tF=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(F)f=true;\n\t\t}\n\t\tif(!f){\n\t\t\tif(i%2==0)a++;\n\t\t\telse b++;\n\t\t}\n\t}\n\t\n\tcout<<a<<','<<b<<endl;\n}\n\nint main(){\n\t\n\tint N,A,B;\n\tcin>>N>>A>>B;\n\tif(A>B)swap(A,B);\n\t\n\tint t = 1;\n\tfor(int i=0;i<N;i++)t = mod(t*2);\n\t\n\tvector<vector<int>> cnt(N+1,vector<int>(2,0));\n\tcnt[0][1] = 1;\n\tfor(int i=0;i<N;i++){\n\t\tcnt[i+1][1] = mod(cnt[i+1][1] + cnt[i][1]);\n\t\t\n\t\tfor(int j=A;true;j++){\n\t\t\tif(i+j>N)break;\n\t\t\tcnt[i+j][0] = mod(cnt[i+j][0] + cnt[i][1]);\n\t\t}\n\t\t\n\t\tfor(int j=A+1;true;j++){\n\t\t\tif(i+j>N)break;\n\t\t\tcnt[i+j][1] = mod(cnt[i+j][1] + cnt[i][1]);\n\t\t}\n\t}\n\t\n\tvector<vector<int>> dp(N+1,vector<int>(2,0));\n\tdp[0][0] = 1;\n\tdp[0][1] = 1;\n\t\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=1;j<A;j++){\n\t\t\tif(i+j<=N)dp[i+j][0] = mod(dp[i+j][0] + dp[i][1]);\n\t\t}\n\t\tif(i!=0){\n\t\t\tfor(int j=1;j<B;j++){\n\t\t\t\tif(i+j<N)dp[i+j][1] = mod(dp[i+j][1] + mod(cnt[j-1][1]*dp[i][0]));\n\t\t\t\tif(i+j==N){\n\t\t\t\t\tdp[i+j][1] = mod(dp[i+j][1] + mod((cnt[j-1][0]+cnt[j-1][1])*dp[i][0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=1;j<B;j++){\n\t\t\t\tif(i+j<N)dp[i+j][1] = mod(dp[i+j][1] + mod(cnt[j][1]*dp[i][0]));\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tint ans = 0;\n\tans = mod(ans + dp.back()[0] + dp.back()[1]);\n\tans = mod(t-ans);\n\t\n\t//get(N,A,B);\n\t\n\t//t = mod(t-mod(dp.back()[0]+dp.back()[1]));\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (ll i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nll modpow(ll a,ll n) {\n  ll res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * a % mod;\n    a = a * a % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  ll n, a, b;\n  cin >> n >> a >> b;\n\n  ll ans = 0;\n  if (a > b) swap(a, b);\n  vector<vector<ll>> f(n + 1, vector<ll>(2, 0));\n  if (b >= 2) {\n    f[0][0] = 1;\n    f[0][1] = 1;\n    FOR(i, 1, n + 1) {\n      rep(k, 2) {\n        FOR(j, 1, i + 1) {\n          if (k == 0 && j < a) continue;\n          f[i][k] = (f[i][k] + f[i - j][k ^ 1]) % mod;\n        }\n      }\n    }\n    vector<ll> g(n + 1);\n    g[0] = 1;\n    FOR(i, 1, n + 1) g[i] = (f[i][0] + f[i][1]) % mod;\n    //rep(i, n + 1) cout << g[i]<< '\\n';\n    vector<vector<ll>> dp(n, vector<ll>(2, 0));\n    FOR(i, 1, n) {\n      if (i < a) dp[i][0] = (dp[i][0] + 1) % mod;\n      FOR(j, 1, min(i, a)) dp[i][0] = (dp[i][0] + dp[i - j][1]) % mod;\n      if (i < b) dp[i][1] = (dp[i][1] + g[i - 1]) % mod;\n      FOR(j, 1, min(i, b)) dp[i][1] = (dp[i][1] + dp[i - j][0] * g[max(0LL, j - 2)]) % mod;\n      if (n - i < b) ans = (ans + dp[i][0] * g[n - i - 1]) % mod;\n      if (n - i < a) ans = (ans + dp[i][1]) % mod;\n    }\n  }\n  ans = (modpow(2, n) - ans + mod) % mod;\n  cout << ans << '\\n';\n\n\n  \n\n\n\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define eps 1e-8\nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,a,b,i,j,f[5005][5005][2],sum[5005][5005][2],sum2[5005],sum3[5005],flag[5005],ans;\nint main(){\n\tn=read();a=read();b=read();\n\tif(a<b)\n\t\tswap(a,b);\n\tsum[0][0][0]=1;\n\tsum[0][0][1]=1;\n\tsum2[0]=1;\n\tflag[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(i>=b)\n\t\t\tf[i][0][1]=(sum2[i-1]-sum2[i-b]+mo)%mo;\n\t\telse\n\t\t\tf[i][0][1]=sum2[i-1];\n\t\tsum[i][0][1]=f[i][0][1];\n\t\tfor(j=1;j<a;j++){\n\t\t\tf[i][j][0]=sum[i-1][j-1][1];\n\t\t\tif(j>=b)\n\t\t\t\tf[i][j][1]=sum[i-b][j-b][0];\n\t\t\tsum[i][j][0]=(sum[i-1][j-1][0]+f[i][j][0])%mo;\n\t\t\tsum[i][j][1]=(sum[i-1][j-1][1]+f[i][j][1])%mo;\n\t\t\tsum2[i]=(sum2[i]+f[i][j][0])%mo;\n\t\t}\n\t\tsum2[i]=(sum2[i]+sum2[i-1])%mo;\n\t\tflag[i]=f[i][0][1];\n\t}\n\tsum3[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(i>=b)\n\t\t\tf[i][0][1]=(sum3[i-1]-sum3[i-b]+mo)%mo;\n\t\telse\n\t\t\tf[i][0][1]=sum3[i-1];\n\t\tsum[i][0][1]=f[i][0][1];\n\t\tfor(j=1;j<=i;j++){\n\t\t\tf[i][j][0]=sum[i-1][j-1][1];\n\t\t\tif(j>=b)\n\t\t\t\tf[i][j][1]=sum[i-b][j-b][0];\n\t\t\tif(j>=a){\n\t\t\t\tans=(1LL*f[i][j][0]*flag[n-i]+ans)%mo;\n\t\t\t\tif(i==n)\n\t\t\t\t\tans=(f[i][j][1]+ans)%mo;\n\t\t\t}\n\t\t\tsum[i][j][0]=(sum[i-1][j-1][0]+f[i][j][0])%mo;\n\t\t\tsum[i][j][1]=(sum[i-1][j-1][1]+f[i][j][1])%mo;\n\t\t\tsum3[i]=(sum3[i]+f[i][j][0])%mo;\n\t\t}\n\t\tsum3[i]=(sum3[i]+sum3[i-1])%mo;\n\t}\n\tpus(ans,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nll dp[5050][2];\nll dp2[5050][2];\nll dp3[5050][2];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\t\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tif (a > b)swap(a, b);\n\tif (a == 1) {\n\t\tcout << mod_pow(2, n, MOD) << \"\\n\";\n\t\treturn 0;\n\t}\n\t\n\tll ans = mod_pow(2, n, MOD);\n\tdp2[1][0] = 1;\n\trep(i, 1, n) {\n\t\t(dp2[i + 1][0] += dp2[i][1] + dp2[i][0]) %= MOD;\n\t\trep(j, a, n)(dp2[i + j][1] += dp2[i][0]) %= MOD;\n\t}\n\tdp3[0][0] = 1;\n\tREP(i, n) {\n\t\t(dp3[i + 1][0] += dp3[i][1] + dp3[i][0]) %= MOD;\n\t\trep(j, a, n + 1)(dp3[i + j][1] += dp3[i][0]) %= MOD;\n\t}\n\n\tdp[0][0] = 1;\n\tdp[0][1] = 1;\n\tREP(i, n) {\n\t\trep(j, 1, a) (dp[i + j][1] += dp[i][0]) %= MOD;\n\t\trep(j, 1, b) {\n\t\t\tif (i == 0) {\n\t\t\t\t(dp[i + j][0] += dp[i][1] * dp3[j][0] % MOD) %= MOD;\n\t\t\t\tif (i + j == n)(dp[i + j][1] += dp[i][1] * dp3[j][1] % MOD) %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(dp[i + j][0] += dp[i][1] * dp2[j][0] % MOD) %= MOD;\n\t\t\t\tif (i + j == n)(dp[i + j][1] += dp[i][1] * dp2[j][1] % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << (ans + 2*MOD - dp[n][0]-dp[n][1])%MOD  << \"\\n\";\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"}\"; return os; }\n\n\n// 剰余演算クラス\nstruct ModInt{\n    static const LL MOD = 1e+9 + 7;\n    LL v;\n    ModInt():v(0){}\n    ModInt(LL op):v(op){}\n    ModInt operator+(ModInt op) const{ return (v + op) % MOD; }\n    ModInt operator-(ModInt op) const{ return (v - op + MOD) % MOD; }\n    ModInt operator*(ModInt op) const{ return (v * op) % MOD; }\n    ModInt operator/(ModInt op) const{ return (v * op.inverse()) % MOD; }\n    ModInt operator%(LL op) = delete;\n    ModInt operator+=(ModInt op){ return v = (v + op) % MOD; }\n    ModInt operator-=(ModInt op){ return v = (v - op + MOD) % MOD; }\n    ModInt operator*=(ModInt op){ return v = (v * op) % MOD; }\n    ModInt operator/=(ModInt op){ return v = (v * op.inverse()) % MOD; }\n    ModInt operator-() const{ return MOD - v; }\n    bool operator==(ModInt op) const{ return v == op.v; }\n    bool operator!=(ModInt op) const{ return v != op.v; }\n    ModInt inverse() const{ return pow(MOD-2); }\n    ModInt pow(LL n) const{\n        if(n < 0) return pow(MOD-1 + n);\n        if(n == 0) return 1;\n        ModInt res = pow(n/2);\n        return res * res * ((n&1)?ModInt(v): ModInt(1));\n    }\n    LL get() const{ return v; }\nprivate:\n    operator LL() const{ return v; }\n};\nistream& operator>>(istream& st, ModInt& m){ st>>m.v; return st; }\nostream& operator<<(ostream& st, const ModInt& m){ st<<m.v; return st; }\n\n\nvector<ModInt> factorial(LL n){\n    vector<ModInt> res(n, 1);\n    for(LL i = 2; i < n; ++i) res[i] = res[i-1] * ModInt(i);\n    return res;\n}\n\nModInt permutation(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m);\n}\n\nModInt combination(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m) / factorial.at(m);\n}\n\n\nint main(){\n    LL n, a, b;\n    cin >> n >> a >> b;\n    if(a > b) swap(a, b);\n    vector<ModInt> part_cnt(b+1);\n    vector<ModInt> inv(b+1);\n    for(LL i = 1; i < b+1; ++i){\n        inv[i] = ModInt(i).inverse();\n    }\n    for(LL a_cnt = 0; a_cnt <= b; ++a_cnt){\n        ModInt cnt = 1;\n        LL base = 1 + (a+1)*a_cnt;\n        for(LL len = base; len <= b; ++len){\n            part_cnt[len] += cnt;\n            cnt *= ModInt(a_cnt*2 + 1 + len - base);\n            cnt *= inv[1 + len - base];\n        }\n    }\n    //cerr << part_cnt << endl;\n    vector<ModInt> dp_b(n+1), dp_a(n+1);\n    dp_a[0] = ModInt(1);\n    dp_b[0] = ModInt(1);\n    for(LL i = 0; i < n; ++i){\n        for(LL len = 1; len < a; ++len){\n            if(i+len >= n+1) break;\n            dp_a[i+len] += dp_b[i];\n        }\n        for(LL len = 1; len < b; ++len){\n            if(i+len >= n+1) break;\n            if(i == 0 || i+len == n){\n                dp_b[i+len] += part_cnt[len+1] * dp_a[i];\n            }else{\n                dp_b[i+len] += part_cnt[len] * dp_a[i];\n            }\n        }\n    }\n    cout << ModInt(2).pow(n) - dp_a[n] - dp_b[n] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint sz[2], N, s00p[5009][2], dp[2][5009][2][2], s[5009][5009][2][2];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[2000009], inv[2000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=0; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){if (K > N || N < 0 || K < 0) return 0; int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nvoid addDiag (int i, int j, int k, int p, int l, int r, int val)\n{\n    if (l < 1)\n        l = 1;\n    if (l > r) return ;\n    //if (i == j && p == 1 && k == 0)\n      //  printf (\"%d+, %d+, %d, %d    +%d on [%d, %d]\\n\", i, j, k, p, val, l, r);\n    adto (s[i + l][j + l][k][p], val);\n    s[i + r + 1][j + r + 1][k][p] = subtract (s[i + r + 1][j + r + 1][k][p], val);\n}\n\nvoid add00p (int i, int l, int r, int p, int val)\n{\n    if (l > r) return ;\n    adto (s00p[i + l][p], val);\n    s00p[i + r + 1][p] = subtract (s00p[i + r + 1][p], val);\n}\n\nint bruteDp[20][20][2][2];\nvoid brute (int dp[20][20][2][2])\n{\n    for (int i=1; i<=N; i++)\n    {\n        adto (dp[i][i * (i >= sz[0])][0][(i * (i >= sz[0])) >= sz[1]], 1);\n        adto (dp[i][i][1][i >= sz[1]], 1);\n        for (int j=0; j<=i; j++)\n            for (int k=0; k<2; k++)\n                for (int p=0; p<2; p++)\n                    if (dp[i][j][k][p])\n                        for (int j2=1; i + j2 <= N; j2++)\n                        {\n                            int newJ = j + j2;\n                            if (k == 1 && j2 < sz[0])\n                                newJ = 0;\n                            adto (dp[i + j2][newJ][k ^ 1][p | (newJ >= sz[1])], dp[i][j][k][p]);\n                        }\n    }\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &sz[0], &sz[1]);\nif (sz[0] > sz[1])\n    swap (sz[0], sz[1]);\n//if (N < 15)\n  //  brute (bruteDp);\nfor (int i=1; i<=N; i++)\n{\n    memset (dp[i & 1], 0, sizeof (dp[i & 1]));\n    adto (dp[i & 1][i * (i >= sz[0])][0][(i * (i >= sz[0])) >= sz[1]], 1);\n    adto (dp[i & 1][i][1][i >= sz[1]], 1);\n    for (int p=0; p<2; p++)\n        adto (s00p[i][p], s00p[i - 1][p]),\n        adto (dp[i & 1][0][0][p], s00p[i][p]);\n    for (int j=0; j<=i; j++)\n        for (int k=0; k<2; k++)\n            for (int p=0; p<2; p++)\n            {\n                if (i > 0 && j > 0)\n                    adto (s[i][j][k][p], s[i - 1][j - 1][k][p]);\n                adto (dp[i & 1][j][k][p], s[i][j][k][p]);\n                //if (dp[i][j][k][p] != bruteDp[i][j][k][p])\n                  //  printf (\"wa (%d, %d, %d, %d) -> %d instead of %d\\n\", i, j, k, p, dp[i][j][k][p], bruteDp[i][j][k][p]);\n                if (dp[i & 1][j][k][p])\n                {\n                    //if (i == 2 && j == 2 && k == 1)\n                      //  k = 1;\n                    int curr = dp[i & 1][j][k][p];\n                    if (k == 1)\n                    {\n                        add00p (i, 1, sz[0] - 1, p, curr);\n                        addDiag (i, j, 0, p, sz[0], sz[1] - j - 1, curr);\n                        addDiag (i, j, 0, 1, max (sz[1] - j, sz[0]), N - i, curr);\n                    }\n                    else\n                    {\n                        addDiag (i, j, 1, p, 1, sz[1] - j - 1, curr);\n                        addDiag (i, j, 1, 1, sz[1] - j, N - i, curr);\n                    }\n/*                    for (int j2=1; i + j2 <= N; j2++)\n                    {\n                        int newJ = j + j2;\n                        if (k == 1 && j2 < sz[0])\n                            newJ = 0;\n                        adto (dp[i + j2][newJ][k ^ 1][p | (newJ >= sz[1])], dp[i][j][k][p]);\n                    }*/\n                }\n            }\n}\nint ans = 0;\nfor (int j=0; j<=N; j++)\n    for (int k=0; k<2; k++)\n        adto (ans, dp[N & 1][j][k][1]);\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n     signed main(){\n         cout << std::fixed << std::setprecision(15);\nint n,a,b;\ncin>>n>>a>>b;\nif(a<b)swap(a,b);\nint x[a+1];\nx[0]=1;\n\nfor(int i=1;i<a+1;i++){\n     x[i]=x[i-1];\n     for(int j=0;j+b+1<=i;j++){\n          x[i]=(x[i]+x[j])%MOD;\n     }\n}\nint y[2][n+1];\ny[1][0]=1;y[0][0]=1;\nfor(int i=1;i<n+1;i++){\n     y[1][i]=0;y[0][i]=0;\n     for(int j=i-1;j>=0&&i-j<b;j--){\n          y[0][i]=(y[0][i]+y[1][j])%MOD;\n     }\n     if(i!=n){\n     for(int j=i-1;j>=0&&i-j<a;j--){\n        if(j!=0) y[1][i]=(y[1][i]+y[0][j]*x[i-j-1]%MOD)%MOD;\n         else  y[1][i]=(y[1][i]+x[i-j]%MOD)%MOD;\n     }\n     }else{\n          for(int j=i-1;j>=0&&i-j<a;j--){\n        if(j!=0) y[1][i]=(y[1][i]+y[0][j]*x[i-j]%MOD)%MOD;\n         else y[1][i]=(y[1][i]+x[i-j+1]%MOD)%MOD;\n     }\n     }\n}\n\n//for(int i=0;i<=n;i++)cerr<<y[0][i]<<' ';\n//cerr<<endl;\n////for(int i=0;i<=n;i++)cerr<<y[1][i]<<' ';\n//cerr<<endl;\n//for(int i=0;i<a-1;i++)cerr<<x[i]<<' ';\n//cerr<<endl;\ncout<<(modpow(2,n,MOD)+MOD-y[0][n]+MOD-y[1][n])%MOD<<endl;\n\n\n     }\n\n \n\n\n \n\n\n\n\n\n\n    \n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  Modint pow(u64 t) const {\n    if (!t) return 1;\n    Modint x = pow(t>>1);\n    x *= x;\n    if (t&1) x *= *this;\n    return x;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\nvoid solve() {\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  if (a == 1) {\n    cout << modpow(2, n) << endl;\n    return;\n  }\n\n  vector<mint> s(b, 1);\n  rep1(i,b) {\n    REP(j,a+1,b-i-1) {\n      s[i+j] += s[i] * (j - a);\n    }\n  }\n\n  vector<mint> ss(b, 0);\n  REP(i,a+1,b-1) {\n    ss[i] = ss[i-1] + s[i-a];\n  }\n\n  Graph<mint> dp(n+1, vector<mint>(2, 0));\n  rep(i,b) {\n    dp[i][0] = s[i] + ss[i];\n  }\n\n  rep(i,n) {\n    rep1(j,a) {\n      if (i+j > n) break;\n      dp[i+j][1] += dp[i][0];\n    }\n    rep1(j,b) {\n      if (i+j > n) break;\n      dp[i+j][0] += dp[i][1] * s[j];\n    }\n  }\n\n  mint ans = mint(2).pow(n);\n  rep(i,b) {\n    ans -= dp[n-i][1] * (s[i] + ss[i]);\n  }\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint add(int a, int b)\n{\n\tint c=a+b;\n\tif(c>=mod)c-=mod;\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c=a-b;\n\tif(c<0)c+=mod;\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tlong long c=a*1LL*b;\n\treturn c%mod;\n}\nint bp(int a, int b)\n{\n\tif(b==0)return 1;\n\tif(b%2==0)\n\t{\n\t\tint val=bp(a, b/2);\n\t\treturn mlt(val, val);\n\t}\n\tif(b%2==1)\n\t{\n\t\tint val=bp(a, b-1);\n\t\treturn mlt(val, a);\n\t}\n}\nint inv(int a)\n{\n\treturn bp(a, mod-2);\n}\nvoid outp(vector<vector<int>>&v)\n{\n\tfor(int i=0; i<v.size(); i++)\n\t{\n\t\tfor(int j=0; j<v[i].size(); j++)cout<<v[i][j]<<' ';\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n}\nint main()\n{\n\tint n, a, b;\n\tcin >> n >> a >> b;\n\tif (a > b)\n\t{\n\t\tint c = a;\n\t\ta = b;\n\t\tb = c;\n\t}\n\tvector<vector<int>> dpa(n + 1, vector<int>(n + 1)),\n\t\t\tdpb(n + 1, vector<int>(n + 1));\n\tdpb[0][0]=1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=max(0, i-b+1); j<i; j++)\n\t\t{\n\t\t\tif(i>=j+a)\n\t\t\t{\n\t\t\t\tif (i >= a)\n\t\t\t\t{\n\t\t\t\t\tdpa[i][j] = add(dpa[i - 1][j], dpb[i - a][j]);\n\t\t\t\t}\n\t\t\t\telse dpa[i][j] = dpa[i - 1][j];\n\t\t\t}\n\t\t\tdpb[i][j] = add(dpa[i - 1][j], dpb[i - 1][j]);\n\t\t}\n\t\tdpa[i][i]=dpa[i-1][i-1];\n\t\tfor(int j=i-1; j>=0; j--)dpa[i][i]=add(dpa[i][i], dpb[i-1][j]);\n\t\tif(i>=a)\n\t\t{\n\t\t\tfor (int j = i - a; j >= 0; j--)\n\t\t\t{\n\t\t\t\tdpa[i][i] = dif(dpa[i][i], dpb[i - a][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t//\t\tcout<<i<<' '<<j<<' '<<dpa[i][j]<<' '<<dpb[i][j]<<endl;\n\t\t}\n\t}\n\tint ans=bp(2, n);\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tans=dif(ans, dpa[n][i]);\n\t\tans=dif(ans, dpb[n][i]);\n\t}\n\tif(a>1)\n\t{\n\t\tcout << ans << endl;\n\t}\n\telse cout<<bp(2,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 5000;\nconst llong P = 1e9+7;\nllong f[mxN+3][2],g[mxN+3][2],h[mxN+3][2];\nint n,A,B;\n\nvoid updsum(llong &x,llong y) {x+=y-P,x+=(x>>31)&P;}\n\nint main()\n{\n\tn = read(),A = read(),B = read(); if(A>B) {swap(A,B);}\n\tg[0][0] = 1ll;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=A; j<=i; j++)\n\t\t{\n\t\t\tupdsum(g[i][0],g[i-j][1]);\n\t\t}\n\t\tfor(int j=1; j<=i; j++)\n\t\t{\n\t\t\tupdsum(g[i][1],g[i-j][0]);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tif(i<A) {f[i][0] = 1ll;}\n\t\tif(i<B) {f[i][1] = (g[i][0]+g[i][1])%P;}\n\t\tfor(int j=1; j<i&&j<B; j++)\n\t\t{\n\t\t\tupdsum(f[i][1],f[i-j][0]*g[j][1]%P);\n\t\t}\n\t\tfor(int j=1; j<i&&j<A; j++)\n\t\t{\n\t\t\tupdsum(f[i][0],f[i-j][1]);\n\t\t}\n\t}\n\tllong tot = 1ll,ans = f[n][0];\n\tfor(int i=1; i<=n; i++) {tot = tot*2ll%P;}\n\tfor(int i=1; i<B; i++)\n\t{\n\t\tupdsum(ans,f[n-i][0]*(g[i][0]+g[i][1])%P);\n\t}\n\tprintf(\"%lld\\n\",(tot-ans+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long dp[5100];\nlong long ks1[5100];\nlong long ks2[5100];\n\nlong long dp2[2][5100];\n\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\n\tif(b<c)swap(b,c);\n\tdp2[0][0]=1;\n\tfor(int i=0;i<a;i++){\n\t\tdp2[0][i+1]=(dp2[0][i+1]+dp2[0][i])%mod;\n\t\tdp2[0][i+1]=(dp2[0][i+1]+dp2[1][i])%mod;\n\t\t\n\t\tfor(int j=c;i+j<=a;j++){\n\t\t\tdp2[1][i+j]=(dp2[1][i+j]+dp2[0][i])%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tfor(int j=1;j<c;j++){\n\t\t\tif(i-j<=0)continue;\n\t\t\tif(i-j>=b)continue;\n\t\t\tks1[i]=(ks1[i]+dp2[0][i-j-1])%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tfor(int j=1;j<c;j++){\n\t\t\tif(i-j<0)continue;\n\t\t\tif(i-j>=b)continue;\n\t\t\tks2[i]=(ks2[i]+dp2[0][i-j])%mod;\n\t\t}\n\t}\n\t// for(int i=1;i<=a;i++)printf(\"%d: %lld %lld\\n\",i,ks1[i],ks2[i]);\n\tdp[0]=1;\n\tfor(int i=0;i<a;i++){\n\t\t// printf(\"%d: %lld\\n\",i,dp[i]);\n\t\tfor(int j=i+1;j<=a&&j-i<=b+c-2;j++){\n\t\t\tif(i)dp[j]=(dp[j]+dp[i]*ks1[j-i])%mod;\n\t\t\telse{\n\t\t\t\tdp[j]=(dp[j]+dp[i]*ks2[j-i])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=pw(2,a);\n\tfor(int i=0;i<b;i++){\n\t\t// printf(\"%d: %lld %lld\\n\",i,dp[a-i],i==0?1LL:(dp2[0][i-1]+dp2[1][i-1]));\n\t\tif(i==0)ret=(ret+mod-dp[a-i]%mod)%mod;\n\t\telse ret=(ret+mod-dp[a-i]*(dp2[0][i-1]+dp2[1][i-1])%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nint n, a, b;\n\nvector<string> moves(string s, int a, int b) {\n\tvector<string> rez;\n\t// for (int i = 0; i <= le(s) - a; i++) {\n\t\tfor (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < a; k++) {\n\t\t\t// \tt[i + k] = '0';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\tt[j + k] = '1';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t}\n\t// }\n\tfor (int i = 0; i <= le(s) - a; i++) {\n\t\t// for (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < b; k++) {\n\t\t\t// \tt[j + k] = '1';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tt[i + k] = '0';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t// }\n\t}\n\treturn rez;\n}\n\nint bfs(int n, int a, int b) {\n\tdeque<string> deq{string(n, '0')};\n\tset<string> used;\n\twhile (!deq.empty()) {\n\t\tstring s = deq[0];\n\t\tdeq.pop_front();\n\t\tif (used.count(s)) continue;\n\t\tused.insert(s);\n\t\tfor (string t : moves(s, a, b)) {\n\t\t\tdeq.pb(t);\n\t\t}\n\t}\n\t// for (string s : used) {\n\t// \tif (s.back() == '1' && s[le(s) - 2] == '0') {\n\t// \t\tprint s;\n\t// \t}\n\t// }\n\t// print used;\n\treturn le(used);\n}\n\nint mem[2][5010][5010];\nint smem[5010][5010];\nnum dp(int, int, bool);\nnum dpsum(int n, int l) {\n\tif (n < 0) return 0;\n\tif (smem[n][l] != -1) return smem[n][l];\n\tsmem[n][l] = (dp(n, l, false) + dpsum(n - 1, l + 1)).value;\n\treturn smem[n][l];\n}\nnum dp(int n, int l, bool can_one) {\n\tif (n < 0) return 0;\n\tif (n == 0) return l >= a;\n\tif (mem[can_one][n][l] != -1) return mem[can_one][n][l];\n\tnum rez = 0;\n\tif (l >= a) {\n\t\trez = num(2).pow(n + can_one - 1);\n\t} else {\n\t\tif (can_one) {\n\t\t\tfor (int ones = 1; ones < b; ones++) {\n\t\t\t\trez += dp(n - ones, 0, false);\n\t\t\t}\n\t\t\trez += dpsum(n - b, l + b);\n\t\t}\n\t\trez += dp(n - 1, l + 1, true);\n\t}\n\tmem[can_one][n][l] = rez.value;\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tmemset(smem, -1, sizeof smem);\n\tscan n, a, b;\n\tif (a < b) swap(a, b);\n\tprint dp(n, 0, true);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nint N, A, B;\n\nbool vis[5001][5001][2][2];\nint dp[5001][5001][2][2];\n\nint sum1(short, short, bool, bool);\nint sum2(short, short, bool, bool);\n\nint solve(short n, short k, bool b, bool a){\n    if(n == N){\n        if(a == 1 || k >= A) return 1;\n        else return 0;\n    }\n    if(vis[n][k][b][a]) return dp[n][k][b][a];\n    vis[n][k][b][a] = true;\n    bool a2 = a;\n    if(k >= A) a2 = true;\n    ll ret = solve(n+1, k+1, 0, a2);\n    if(b == 0){\n        ret += sum1(n+1, 0, 1, a2) - sum1(n+min(B,N-n+1), 0, 1, a2);\n        ret += sum2(n+min(B, N-n+1), k+min(B, N-n+1), 1, a2) - sum2(N+1, k+N-n+1, 1, a2);\n    }\n    if(ret < 0) ret += MOD;\n    if(ret < 0) ret += MOD;\n    if(ret >= MOD) ret -= MOD;\n    if(ret >= MOD) ret -= MOD;\n    return dp[n][k][b][a] = ret;\n}\n\nbool vis1[5001][5001][2];\nint dp1[5001][5001][2];\nint sum1(short n, short k, bool b, bool a){\n    if(n > N) return 0;\n    if(vis1[n][k][a]) return dp1[n][k][a];\n    vis1[n][k][a] = true;\n    ll ret = solve(n, k, b, a) + sum1(n+1, k, b, a);\n    if(ret >= MOD) ret -= MOD;\n    return dp1[n][k][a] = ret;\n}\n\nbool vis2[5001][5001][2];\nint dp2[5001][5001][2];\nint sum2(short n, short k, bool b, bool a){\n    if(n > N) return 0;\n    if(vis2[n][k][a]) return dp2[n][k][a];\n    vis2[n][k][a] = true;\n    ll ret = solve(n, k, b, a) + sum2(n+1, k+1, b, a);\n    if(ret >= MOD) ret -= MOD;\n    return dp2[n][k][a] = ret;\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    cout << solve(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acosl(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define MAXN 205\n//#define N 262144\n#define ULL unsigned long long\n#define ll long long\nint dp[5005][5005][3];\nint mod=1e9+7;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint main(){\n    int n,a,b;\n    scanf(\"%d %d %d\",&n,&a,&b);\n    if(a>b)swap(a,b);\n    dp[1][1][1]=1;\n    dp[1][1][0]=1;\n    dp[0][0][1]=1;\n   // dp2[0][0]=1;\n   // dp2[1][1]=2;\n    LL ans=0;\n    for(int i = 2;i<=n;i++){\n        for(int j=2;j<=i;j++){\n           // if(j<=b){\n                dp[i][j][1]+=(dp[i-1][j-1][1]+dp[i-1][j-1][2])%mod;\n                dp[i][j][1]%=mod;\n                dp[i][j][2]+=dp[i-1][j-1][2];\n                dp[i][j][2]%=mod;\n                if(j>=a){\n                    dp[i][j][2]+=dp[i-a][j-a][1];\n                    dp[i][j][2]%=mod;\n                }\n           // }\n            if(j<a){\n                dp[i][j][0]+=dp[i-1][j-1][0];\n                dp[i][j][0]%=mod;\n            }\n        }\n        for(int j=1;j<a;j++){\n            dp[i][1][1]+=dp[i-1][j][0];\n            dp[i][1][1]%=mod;\n        }\n        for(int j=1;j<b;j++){\n            dp[i][1][0]+=dp[i-1][j][1];\n            dp[i][1][0]%=mod;\n        }\n      /*  for(int j = 1;j<=i;j++){\n            printf(\"%d %d %d %d %d\\n\",i,j,dp[i][j][0],dp[i][j][1],dp[i][j][2]);\n        }*/\n        ans+=(dp[i][b][1]+dp[i][b][2])*1ll*f_pow(2,n-i)%mod;\n        if(i>=b)\n        for(int j = b-a+1;j<b;j++){\n            ans+=(dp[i-a][j][1])*1ll*f_pow(2,n-i)%mod;\n        }\n        ans%=mod;\n    }\n    printf(\"%d\\n\",ans);\n}\n/*\n1000000000000000000\n1000000000000000000 1 1 1 1000000000\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\n\nint inv(int a, int n) {\n  int x, y;\n  exgcd(a, n, x, y);\n  return (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 1e9 + 7;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n  public:\n    int v;\n\n    Z() : v(0) {\t}\n    Z(int x) : v(x){\t}\n    Z(ll x) : v(x % Mod) {\t}\n\n    friend Z operator + (const Z& a, const Z& b) {\n      int x;\n      return Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n    }\n    friend Z operator - (const Z& a, const Z& b) {\n      int x;\n      return Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n    }\n    friend Z operator * (const Z& a, const Z& b) {\n      return Z(a.v * 1ll * b.v);\n    }\n    friend Z operator ~(const Z& a) {\n      return inv(a.v, Mod);\n    }\n    friend Z operator - (const Z& a) {\n      return Z(0) - a;\n    }\n    Z& operator += (Z b) {\n      return *this = *this + b;\n    }\n    Z& operator -= (Z b) {\n      return *this = *this - b;\n    }\n    Z& operator *= (Z b) {\n      return *this = *this * b;\n    }\n};\n\nZ<> qpow(Z<> a, int p) {\n  Z<> rt = Z<>(1), pa = a;\n  for ( ; p; p >>= 1, pa = pa * pa) {\n    if (p & 1) {\n      rt = rt * pa;\n    }\n  }\n  return rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 5005;\n\nint n, A, B;\nZi f[N], g[N][2];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  if (A > B) {\n    swap(A, B);\n  }\n  f[0] = 1;\n  for (int i = 1; i <= B; i++) {\n    f[i] = f[i - 1];\n    for (int j = A; j <= i; j++) {\n      if (j == i) {\n        f[i] += 1;\n      } else {\n        f[i] += f[i - j - 1];\n      }\n    }\n  }\n  g[0][0] = 1;\n  for (int i = 1; i < B; i++) {\n    g[i][0] = f[i - 1]; \n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < B && j <= i; j++) {\n      g[i][0] += g[i - j][1] * ((j == 1) ? 1 : f[j - 2]);\n    }\n    for (int j = 1; j < A && j <= i; j++) {\n      g[i][1] += g[i - j][0];\n    }\n  }\n  Zi ans = g[n][1];\n  for (int i = 1; i < B; i++) {\n    ans += g[n - i][1] * f[i - 1];\n  }\n  ans = qpow(2, n) - ans;\n  printf(\"%d\\n\", ans.v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 5000;\nconst int MOD = 1000000007;\nvoid inc(int& a, int b) { if ((a += b) >= MOD) a -= MOD; }\nvoid dec(int& a, int b) { if ((a -= b) < 0) a += MOD; }\n\nint n, alen, blen;\n\n// dp[i][j][k] = number of ways to select a block of i characters ending with less than alen zeroes (or empty) with no valid subsequence, followed by a block of length j starting with 1 (or at beginning of string) in which all subsequences of zeroes have length at least alen, ending with k\nint dp[MAXN + 1][MAXN + 1][2]; \nint dpsum[MAXN + 1][MAXN + 2];\nint p2[MAXN + 1];\n\nint solve() {\n\tp2[0] = 1; FORE(i, 1, n) p2[i] = (ll)p2[i - 1] * 2 % MOD;\n\tif (alen > blen) swap(alen, blen);\n\tREPE(i, n) dpsum[i][0] = dpsum[i][1] = 0;\n\tREPE(i, n) FORE(j, 1, blen) {\n\t\tdp[i][j][0] = dp[i][j][1] = 0;\n\t\tFORE(k, alen, j - 1) inc(dp[i][j][0], dp[i][j - k][1]);\n\t\tif (i == 0 && j >= alen) inc(dp[i][j][0], 1);\n\t\tif (j == 1) {\n\t\t\tif (i < alen) inc(dp[i][j][1], 1);\n\t\t\t//FORE(k, 1, min(i, alen - 1)) FORE(l, 1, min(blen - 1, i - k)) inc(dp[i][j][1], dp[i - k - l][l][1]);\n\t\t\t//FORE(z, 2, i) FORE(k, max(1, z - blen + 1), min(min(i, alen - 1), z - 1)) { int l = z - k; inc(dp[i][j][1], dp[i - z][l][1]); }\n\t\t\tFORE(z, 2, i) {\n\t\t\t\tint lo = z - min(min(i, alen - 1), z - 1), hi = z - max(1, z - blen + 1); lo = min(lo, blen);  hi = min(hi, blen);\n\t\t\t\t//FORE(l, lo, hi) inc(dp[i][j][1], dp[i - z][l][1]);\n\t\t\t\t//{ int chk = 0; FORE(l, 0, hi) inc(chk, dp[i - z][l][1]); if (!(chk == dpsum[i - z][hi + 1])) { printf(\"err i-z=%d hi+1=%d: %d vs %d\\n\", i - z, hi + 1, chk, dpsum[i - z][hi + 1]); exit(0); } }\n\t\t\t\t//{ int chk = 0; FORE(l, 0, lo - 1) inc(chk, dp[i - z][l][1]); if (!(chk == dpsum[i - z][lo])) { printf(\"err i-z=%d lo=%d: %d vs %d [i=%d]\\n\", i - z, lo, chk, dpsum[i - z][lo],i); exit(0); } }\n\t\t\t\tinc(dp[i][j][1], dpsum[i - z][hi + 1]);\n\t\t\t\tdec(dp[i][j][1], dpsum[i - z][lo]);\n\t\t\t}\n\t\t} else {\n\t\t\tinc(dp[i][j][1], dp[i][j - 1][0]);\n\t\t\tinc(dp[i][j][1], dp[i][j - 1][1]);\n\t\t}\n\t\t//printf(\"dp[%d][%d]: %d / %d\\n\", i, j, dp[i][j][0], dp[i][j][1]);\n\t\tdpsum[i][j + 1] = dpsum[i][j]; inc(dpsum[i][j + 1], dp[i][j][1]);\n\t\t//if (i == 1) printf(\"dpsum[%d][%d]=%d dp[%d][%d][1]=%d -> dpsum[%d][%d]=%d\\n\", i, j, dpsum[i][j], i, j, dp[i][j][1], i, j + 1, dpsum[i][j + 1]);\n\t}\n\tint ret = 0;\n\tREPE(i, n - blen) {\n\t\tint cur = 0; REP(k, 2) inc(cur, dp[i][blen][k]);\n\t\t//printf(\"%d: (%d+%d)*%d\\n\", i, dp[i][blen][0], dp[i][blen][1], p2[n - i - blen]);\n\t\tcur = (ll)cur * p2[n - i - blen] % MOD;\n\t\tinc(ret, cur);\n\t}\n\tREPE(i, n - blen) FORE(j, 1, blen - 1) if (i + j + alen <= n && j + alen > blen) {\n\t\tint cur = dp[i][j][1];\n\t\t//printf(\"%d %d: %d * %d\\n\", i, j, cur, p2[n - i - j - alen]);\n\t\tcur = (ll)cur * p2[n - i - j - alen] % MOD;\n\t\tinc(ret, cur);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\", &n, &alen, &blen);\n\tprintf(\"%d\\n\", solve());\n}\n\nint solvestupid() {\n\tint ret = 0;\n\tassert(alen <= blen);\n\tREP(mask, 1 << n) {\n\t\tbool ok = false;\n\t\tREPE(offset, n - blen) {\n\t\t\tint nzero = 0;\n\t\t\tREP(i, n - offset) {\n\t\t\t\tint cur = (mask >> (offset + i)) & 1;\n\t\t\t\tif (cur == 0) ++nzero;\n\t\t\t\tif (cur == 1) { if (nzero != 0 && nzero < alen) break; nzero = 0; }\n\t\t\t\tif ((nzero == 0 || nzero >= alen) && i + 1 >= blen) ok = true;\n\t\t\t}\n\t\t}\n\t\tif (ok) ++ret;\n\t}\n\treturn ret;\n}\n\nvoid stress() {\n\tfor (n = 1; n <= 15; ++n) for (alen = 1; alen <= n; ++alen) for (blen = alen; blen <= n; ++blen) {\n\t\tint have = solve();\n\t\tint want = solvestupid();\n\t\tif (have == want) { printf(\".\"); continue; }\n\t\tprintf(\"err %d %d %d: have=%d want=%d\\n\", n, alen, blen, have, want);\n\t}\n}\n\nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\t\nint f[5555]; //1s and consecutive 0s of length >= a, ending at 1\nint g[5555][2];\nint f2[5555];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(5555);\n\tint n,a,b; cin>>n>>a>>b;\n\tif(a>b) swap(a,b);\n\tf[1]=1; \n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1]; \n\t\tfor(int j=a;j<=i;j++)\n\t\t{\n\t\t\tif(i>=j+1) \n\t\t\t{\n\t\t\t\tradd(f[i],f[i-j-1]);\n\t\t\t}\n\t\t\tif(i>=j) radd(f2[i],f[i-j]); //end with j 0s\n\t\t}\n\t\t//cerr<<i<<' '<<f[i]<<' '<<f2[i]<<'\\n';\n\t}\n\t\t\n\tg[0][0]=g[0][1]=1;\n\t//start with run of 1s, but with 0\n\tfor(int i=1;i<b;i++)\n\t{\n\t\tg[i][1]=f2[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t//run of small 0s\n\t\tfor(int j=1;j<a;j++)\n\t\t{\n\t\t\tif(i>=j) radd(g[i][0],g[i-j][1]);\n\t\t}\n\t\t//run of 1s\n\t\tfor(int j=1;j<min(i+1,b);j++)\n\t\t{\n\t\t\tradd(g[i][1],mult(g[i-j][0],f[j]));\n\t\t}\n\t\t//cerr<<i<<' '<<g[i][0]<<' '<<g[i][1]<<'\\n';\n\t}\n\tint ans = add(g[n][0],g[n][1]);\n\t//end with run of 1s, but with 0\n\tfor(int i=1;i<b;i++)\n\t{\n\t\t//cerr<<i<<' '<<f2[i]<<'\\n';\n\t\tif(n>=i) radd(ans,mult(g[n-i][0],f2[i]));\n\t}\n\tcout<<add(pow2[n],MOD-ans)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 5007, MOD = 1000 * 1000 * 1000 + 7;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N][N][2];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (b < a)\n        swap(a, b);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int t = 0; t < 2; ++t) {\n            int to = i;\n            if (t == 0 && i < a)\n                to = 0;\n            dp[i][to][t] = 1;\n        }   \n    }   \n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < b; ++j) {\n            for (int t = 0; t < 2; ++t) {\n                if (!dp[i][j][t])\n                    continue;\n\n                int x = dp[i][j][t];\n                for (int k = 1; i + k <= n; ++k) {\n                    if (t && k < a)\n                        add(dp[i + k][0][t^1], x);\n                    else if (j + k < b)\n                        add(dp[i + k][j + k][t^1], x);\n                }   \n            }   \n        }   \n    }   \n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) \n        ans = (ans << 1) % MOD;\n    for (int i = 0; i < b; ++i)\n        for (int t = 0; t < 2; ++t)\n            ans = mod(ans - dp[n][i][t]);\n    cout << ans << endl;            \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver2 {\n public:\n  int n, a, b;\n  vector<vector<vector<Modint<>>>> dp;\n  Solver2(int n, int a, int b) : n(n), a(a), b(b), dp(max(100, n + 1), vector<vector<Modint<>>>(max(100, n + 1), vector<Modint<>>(2))){};\n\n  void solve() {\n    if (a < b) swap(a, b);\n    dp[0][0][0] = Modint<>(1);\n    dp[2][1][0] = Modint<>(-1);\n    auto ans = Modint<>(0);\n    for (int i = 0; i <= n; ++i) {\n      if (i > 0) dp[i][1][0] += dp[i - 1][1][0];\n      for (int j = 0; j < a; ++j) {\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] += dp[i][j][0];\n        if (i + 2 <= n) dp[i + 2][1][0] += dp[i][j][0];\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] -= dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] += dp[i][j][1];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][1];\n      }\n      auto cf = Modint<>(2).mpow(n - i);\n      for (int j = a; j <= n; ++j) {\n        ans += (dp[i][j][0] + dp[i][j][1]) * cf;\n      }\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, a, b;\n  std::cin >> n >> a >> b;\n\n  Problem::Solver2 sol(n, a, b);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// =========== Template ========== //\n#include <bits/stdc++.h>\nusing namespace std;\nint fastio() { ios_base::sync_with_stdio(false); cout << fixed << setprecision(10); cin.tie(nullptr); return 0; }\nint __fastio = fastio();\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p);\ntemplate<typename A> ostream& operator<<(ostream &os, const set<A> &m) { os << \"{\"; string sep = \"\"; for (auto e: m) os << sep << e, sep = \", \"; return os << \"}\"; }\ntemplate<typename A> ostream& operator<<(ostream &os, const multiset<A> &m) { os << \"{\"; string sep = \"\"; for (auto e: m) os << sep << e, sep = \", \"; return os << \"}\"; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const map<A, B> &m) { os << \"{\"; string sep = \"\"; for (auto e: m) os << sep << e.first << \": \" << e.second, sep = \", \"; return os << \"}\"; }\ntemplate<typename T>ostream& operator<<(ostream& os, const vector<T>& v) { os << \"[\"; string sep = \"\"; for (auto e: v) os << sep << e, sep = \", \"; return os << \"]\"; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef STEVEN\n#define pp(...) cerr << \"\\t[\" << #__VA_ARGS__ << \"]:\\t\", dbg_out(__VA_ARGS__)\n#define ppp(x) cerr << x << \"\\n\"\n#else\n#define pp(...)\n#define ppp(...)\n#endif\ntemplate<class Fun> class y_combinator_result { Fun fun_; public: template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {} template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); } };\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define fi first\n#define se second\n#define sz(x) (int((x).size()))\n#define data _data\n// =========== Book ============ //\n\nconst int inf = 1000 << 20;\nconst ll infl = 1LL << 60;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n  private:\n  using ll = long long;\n  int v;\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n  public:\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\n\n// ============= Solution ============= //\n\n// state: len, cnt, last\n// last = 1 ->\n//   len + 1, cnt + 1, 1\n//   len + 1, cnt + 1, 0\n// last = 0 ->\n//   len + A, cnt + A, 1\n//   len + 1, cnt + 1, 0\n//   len + k + 1, 1, 0 for k = 1...A - 1\n\ntypedef modnum<int(1E9 + 7)> mint;\nmint dp[5010][5010][2];\nint main() {\n  int n, a, b;\n  cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  for (int i = 0; i < b; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      dp[n][i][j] = 1;\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    mint val = 0;\n    for (int c = 1; c <= a - 1; ++c) {\n      if (i + c + 1 <= n) {\n        val += dp[i + c + 1][1][0];\n      }\n    }\n    if (n - i < a) {\n      val += dp[n][1][0];\n    }\n\n    for (int j = 0; j < b; ++j) {\n      for (int k = 0; k < 2; ++k) {\n        if (k == 1) {\n          if (j + 1 < b) {\n            dp[i][j][k] += dp[i + 1][j + 1][1];\n            dp[i][j][k] += dp[i + 1][j + 1][0];\n          }\n        } else {\n          if (i + a <= n && j + a < b) {\n            dp[i][j][k] += dp[i + a][j + a][1];\n          }\n          if (j + 1 < b) {\n            dp[i][j][k] += dp[i + 1][j + 1][0];\n          }\n          dp[i][j][k] += val;\n        }\n      }\n    }\n  }\n  mint ans = 1;\n  for (int i = 0; i < n; ++i) ans *= 2;\n  ans -= dp[0][0][0];\n  cout << ans << \"\\n\";\n}\n\n// ============== Notes =============== //\n// common bugs\n// - fastio\n// - int overflow (especially intermediate expressionns)\n// - array bounds (indices bigger than MAXN?)\n// - special cases (n=1? graph not connected?)\n// - re-initialize efficiently between test cases\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nint main(){\n  int n, a, b; long long ans = 1, mod = 1e9+7; cin >> n >> a >> b; if(a > b) swap(a, b);\n  rep(i, n){ans *= 2; ans %= mod;}\n  vector<vector<long long>> dp(n+1, vector<long long>(a+b, 0)), f(n+1, vector<long long>(2, 0)); dp[1][1] = 1; dp[1][a+1] = 1; f[0][1] = 1;\n  rep(i, n+1){\n    rep(k, 2){\n      rep(j, i+1){\n        if(k == 0 && j < a) continue;\n\t\tf[i][k] += f[i-j][k^1];\n        f[i][k] %= mod;\n      }\n    }\n  }\n  if(a > 1){\n  \trep(i, n){\n      rep(j, a+b){\n        if(j < a-1){\n          dp[i+1][a+1] += dp[i][j];\n          dp[i+1][a+1] %= mod;\n          dp[i+1][j+1] += dp[i][j];\n          dp[i+1][j+1] %= mod;\n        }\n        else if(j == a-1){\n          dp[i+1][a+1] += dp[i][j];\n          dp[i+1][a+1] %= mod;\n        }\n        else if(j < a+b-1){\n          dp[i+1][1] += dp[i][j] * (f[max(0, j-a-2)][0] + f[max(0, j-a-2)][1]);\n          dp[i+1][1] %= mod;\n          dp[i+1][j+1] += dp[i][j];\n          dp[i+1][j+1] %= mod;\n        }\n        else{\n          dp[i+1][1] += dp[i][j] * (f[max(0, j-a-2)][0] + f[max(0, j-a-2)][1]);;\n          dp[i+1][1] %= mod;\n        }\n      }\n    }\n  }\n  rep(i, a+b){\n    ans += mod; ans -= dp[n][i] * (f[max(0, i-a-2)][0] + f[max(0, i-a-2)][1]) % mod; ans %= mod;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,A,B,dp[N][2],f[N],s[N],g[N],gg[N];\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\nint main(){\n\tn=read();A=read();B=read();\n\tif (A>B) swap(A,B);\n\t\n\tf[0]=1;\n\tfor (int i=1;i<B;i++){\n\t\tmemcpy(s,f,sizeof(s));\n\t\tfor (int j=0;i+j<B;j++){\n\t\t\tcheck(g[i+j],f[j]);\n\t\t\tcheck(s[j+1],s[j]);\n\t\t\tif (j>=A) check(f[j],s[j-A]);\n\t\t}\n\t}\n\tmemcpy(s,g,sizeof(s));\n\tfor (int i=1;i<B;i++){\n\t\tgg[i]=g[i];\n\t\tcheck(s[i],s[i-1]);\n\t\tif (i>=A) check(gg[i],s[i-A]);\n\t}\n\tfor (int i=1;i<A;i++) dp[i][0]=1;\n\tfor (int i=1;i<B;i++) dp[i][1]=gg[i];\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;(j<A)&&(i+j<=n);j++) check(dp[i+j][0],dp[i][1]);\n\t\tfor (int j=1;(j<B)&&(i+j<=n);j++) check(dp[i+j][1],(ll)dp[i][0]*((i+j==n) ? gg[j] : g[j])%p);\n\t}\n\tint ans=qpow(2,n);\n\tcheck(ans,p-dp[n][0]);\n\tcheck(ans,p-dp[n][1]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 5e3 + 5;\n\nModint dp [MAX_N][MAX_N];\nModint isum [MAX_N];\nModint dsum [MAX_N][MAX_N];\n\nModint irange (int l, int r) {\n  l = max(0, l);\n  if (r < l) return Modint(0);\n  if (l == 0) return isum[r];\n  return isum[r] - isum[l - 1];\n}\n\nModint dget (int diag, int idx) {\n  if (diag < 0 || idx < 0) return Modint(0);\n  return dsum[diag][idx];\n}\n\nModint tpow [MAX_N];\n\nint main () {\n  tpow[0] = Modint(1);\n  for (int i = 1; i < MAX_N; i++) {\n    tpow[i] = Modint(2) * tpow[i - 1];\n  }\n  \n  int n, A, B;\n  cin >> n >> A >> B;\n\n  if (A > B) swap(A, B);\n  if (A == 1) {\n    cout << exp(Modint(2), n) << endl;\n    return 0;\n  }\n\n  dp[0][0] = Modint(1);\n  dsum[0][0] = Modint(1);\n  isum[0] = Modint(1);\n  for (int i = 1; i <= n + 1; i++) {\n    for (int b = 1; b <= i; b++) {\n      if (b == 1) {\n        if (i == 1) {\n          dp[i][b] = 1;\n        } else {\n          dp[i][b] = irange(i - A, i - 2);\n        }\n      } else {\n        dp[i][b] = dget(i - b, i - A - 1);\n        if (b - 1 < B) {\n          dp[i][b] += dp[i - 1][b - 1];\n        }\n      }\n\n      if (b < B) {\n        isum[i] += dp[i][b];\n        dsum[i - b][i] += dp[i][b];\n      }\n      dsum[i - b][i] += dsum[i - b][i - 1];\n    }\n\n    isum[i] += isum[i - 1];\n  }\n\n  /*\n  for (int i = 1; i <= n + 1; i++) {\n    for (int b = 1; b <= n + 1; b++) {\n      cout << dp[i][b] << \" \";\n    }\n    cout << endl;\n  }\n  */\n  \n  Modint ans (0);\n  for (int i = 1; i <= n + 1; i++) {\n    for (int b = B; b <= n + 1; b++) {\n      if (i == n + 1) {\n        if (b != B) {\n          ans += dp[i][b];\n        }\n      } else {\n        ans += dp[i][b] * tpow[n - i];\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int N=5005,mod=1e9+7;\nint f[N][2],g[N][2],n,A,B,ans;\n\nsigned main(){\n\tread(n,A,B);\n\tif(A>B) swap(A,B);\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<B;i++){\n\t\tfor(int j=A;j<=i;j++) f[i][0]=(f[i][0]+f[i-j][1])%mod;\n\t\tfor(int j=1;j<=i;j++) f[i][1]=(f[i][1]+f[i-j][0])%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(i<A) g[i][0]=1;\n\t\tfor(int j=1;j<A&&j<i;j++) g[i][0]=(g[i][0]+g[i-j][1])%mod;\n\t\tif(i<B) g[i][1]=f[i][1];\n\t\tfor(int j=1;j<B&&j<i;j++) g[i][1]=(g[i][1]+1ll*g[i-j][0]*f[j-1][1]%mod)%mod;\n\t\tif(n-i<A) ans=(ans+g[i][1])%mod;\n\t\tif(n-i<B) ans=(ans+1ll*g[i][0]*f[n-i][1]%mod)%mod;\n\t}\n\tint pw2=1;\n\tfor(int i=1;i<=n;i++) pw2=(pw2+pw2)%mod;\n\twrite((pw2+mod-ans)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5005;\nconst int MOD = 1000000007;\n\nint n,A,B,ans;\nint pw[MAXN];\nint f[MAXN][MAXN];\nint g[MAXN][MAXN];\nint lazg[MAXN][MAXN];\nint lazf[MAXN][MAXN];\nint sumg[MAXN];\nint sumf[MAXN];\nint spec[MAXN];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif (A > B)\n\t\tswap(A,B);\n\tpw[0] = 1;\n\tfor (int i = 1;i <= n;i++)\n\t\tpw[i] = pw[i - 1] * 2 % MOD;\n\tf[0][0] = g[0][0] = 1;\n\tint all = 0;\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= i;j++)\n\t\t{\n\t\t\tif (i || j)\n\t\t\t{\n\t\t\t\t(sumf[j] += lazf[i][j]) %= MOD;\n\t\t\t\tf[i][j] = sumf[j];\n\t\t\t}\n\t\t\tif (f[i][j])\n\t\t\t{\n\t\t\t\t(spec[i + 1] += f[i][j]) %= MOD;\n\t\t\t\t(spec[min(n + 1,i + A)] -= f[i][j]) %= MOD;\n\t\t\t//\tfor (int k = i + 1;k < i + A;k++)\n\t\t\t//\t\t(g[k][k] += f[i][j]) %= MOD;\n\t\t\t\t(lazg[min(i + A,n + 1)][j] += f[i][j]) %= MOD;\n\t\t\t//\tfor (int k = i + A;k <= n;k++)\n\t\t\t//\t\t(g[k][j] += f[i][j]) %= MOD;\n\t\t\t}\n\t\t\tif (i || j)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\t(all += spec[i]) %= MOD;\n\t\t\t\t\tg[i][j] = all;\n\t\t\t\t}\n\t\t\t\t(sumg[j] += lazg[i][j]) %= MOD;\n\t\t\t\t(g[i][j] += sumg[j]) %= MOD;\n\t\t\t}\n\t\t\tif (g[i][j])\n\t\t\t{\n\t\t\t\tif (j + B <= n)\n\t\t\t\t\t(ans += (ll)g[i][j] * pw[n - max(j + B,i) - (i < n ? max(j + B,i) == i : 0)] % MOD) %= MOD;\n\t\t\t\t(lazf[min(i + 1,min(j + B - 1,n) + 1)][j] += g[i][j]) %= MOD;\n\t\t\t\t(lazf[min(j + B - 1,n) + 1][j] -= g[i][j]) %= MOD;\n\t\t\t//\tfor (int k = i + 1;k <= min(j + B - 1,n);k++)\n\t\t\t//\t\t(f[k][j] += g[i][j]) %= MOD;\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",(ans + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 5e3 + 100;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nll C[2];\n\nstring s;\n\nll dp0[maxn][2];\n\nll dp[maxn][2];\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nvoid count_dp0() {\n    ll q, w, e;\n    // dp0[0][0] = dp0[0][1] = 1;\n    for (q = 0; q < n; q++) {\n        /// last are 0s;\n        // dp0[q][0] = 1;\n        for (w = C[0]; w <= q; w++) {\n            dp0[q][0] += dp0[q - w][1];\n            dp0[q][0] %= mod;\n        }\n\n        /// last are 1s;\n        dp0[q][1] = 1;\n        for (w = 1; w <= q; w++) {\n            dp0[q][1] += dp0[q - w][0];\n            dp0[q][1] %= mod;\n        }\n    }\n}\n\n// set <ll> S;\n\nll getcnt(ll len, bool f) {\n    // if (S.find(len) == S.end()) {\n    //     cout << \"DP0 \" << len << \" \" << dp0[len - 1][1] << endl;\n    // }\n    // S.insert(len);\n    ll ans = dp0[len - 1][1];\n    if (f) {\n        ans += dp0[len - 1][0];\n    }\n    ans %= mod;\n    return ans;\n}\n\nvoid count_dp() {\n    ll q, w, e;\n    for (q = 0; q < n; q++) {\n        /// last are 0s;\n        if (q + 1 < C[0]) {\n            dp[q][0] = 1;\n        }\n        for (w = 1; w < C[0] && w <= q; w++) {\n            dp[q][0] += dp[q - w][1];\n            dp[q][0] %= mod;\n        }\n        /// last are pseudo-1s;\n        if (q + 1 < C[1]) {\n            dp[q][1] = getcnt(q + 1, 1);\n        }\n        for (w = 1; w < C[1] && w <= q; w++) {\n            dp[q][1] += dp[q - w][0] * getcnt(w, q == (n - 1));\n            dp[q][1] %= mod;\n        }\n    }\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    cin >> n >> a >> b;\n    if (a > b) {\n        swap(a, b);\n    }\n    C[0] = a;\n    C[1] = b;\n    count_dp0();\n    count_dp();\n    // cout << dp[n - 1][0] << \" \" << dp[n - 1][1] << \" DPS\" << endl;\n    ll cnt_bad = dp[n - 1][0] + dp[n - 1][1];\n    // cout << \"CNT_BAD \" << cnt_bad << endl;\n    ll ans = (step(2, n) - cnt_bad % mod + mod) % mod;\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2.1;\n\nauto chmin = [](auto&& a, auto b) { return b < a ? a = b, 1 : 0; };\nauto chmax = [](auto&& a, auto b) { return a < b ? a = b, 1 : 0; };\n\npair<int, int> f(const string& s) {\n  int mn = 0, mx = 0;\n  int t = 0, mnt = 0, mxt = 0;\n  for (auto c : s) {\n    if (c == '0') {\n      ++t;\n    } else {\n      --t;\n    }\n    mn = min(mn, t - mxt);\n    mx = max(mx, t - mnt);\n    mnt = min(mnt, t);\n    mxt = max(mxt, t);\n  }\n  return {mn, mx};\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int n = size(s);\n  auto s0 = s;\n  for (auto&& e : s0) {\n    if (e == '?') {\n      e = '0';\n    }\n  }\n  int a = -f(s0).first;\n  auto s1 = s;\n  for (auto&& e : s1) {\n    if (e == '?') {\n      e = '1';\n    }\n  }\n  int b = f(s1).second;\n  int x = max(a, b);\n  vector<bool> need0(n);\n  {\n    vector<int> mn(n + 1), mx(n + 1);\n    for (int i = n; i--; ) {\n      if (s0[i] == '0') {\n        chmin(mn[i], mn[i + 1] + 1);\n      } else {\n        chmin(mn[i], mn[i + 1] - 1);\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      if (s0[i] == '0') {\n        chmax(mx[i + 1], mx[i] - 1);\n      } else {\n        chmax(mx[i + 1], mx[i] + 1);\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      if (s[i] != '?') continue;\n      need0[i] = mx[i] - mn[i + 1] + 1 > x;\n    }\n  }\n  vector<bool> need1(n);\n  {\n    vector<int> mn(n + 1), mx(n + 1);\n    for (int i = n; i--; ) {\n      if (s1[i] == '0') {\n        chmax(mx[i], mx[i + 1] + 1);\n      } else {\n        chmax(mx[i], mx[i + 1] - 1);\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      if (s1[i] == '0') {\n        chmin(mn[i + 1], mn[i] - 1);\n      } else {\n        chmin(mn[i + 1], mn[i] + 1);\n      }\n    }\n    for (int i = 0; i < n; ++i) {\n      if (s[i] != '?') continue;\n      need1[i] = mx[i + 1] - mn[i] + 1 > x;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (need0[i] and need1[i]) {\n      cout << x + 1 << '\\n';\n      exit(0);\n    }\n    if (need0[i]) {\n      s[i] = '0';\n    }\n    if (need1[i]) {\n      s[i] = '1';\n    }\n  }\n  if (s.find('?') == string::npos) {\n    auto [mn, mx] = f(s);\n    cout << max(-mn, mx) << endl;\n    exit(0);\n  }\n  vector<int> h(n + 1);\n  for (int i = 0; i < n; ++i) {\n    h[i + 1] = h[i];\n    h[i + 1] += s[i] == '0';\n    h[i + 1] -= s[i] == '1';\n  }\n  DEBUG(s);\n  int mi = min_element(begin(h), end(h)) - begin(h);\n  int res = 0;\n  {\n    int mn = 0, mx = 0;\n    int t = 0, mnt = 0, mxt = 0;\n    for (int i = mi; i < n; ++i) {\n      if (s[i] == '0') {\n        ++t;\n      } else if (s[i] == '1') {\n        --t;\n      } else {\n        if (t == mn) {\n          ++t;\n        } else {\n          --t;\n        }\n      }\n      chmin(mn, t - mxt);\n      chmax(mx, t - mnt);\n      chmin(mnt, t);\n      chmax(mxt, t);\n    }\n    chmax(res, mx);\n  }\n  {\n    int mn = 0, mx = 0;\n    int t = 0, mnt = 0, mxt = 0;\n    for (int i = mi; i--; ) { \n      if (s[i] == '0') {\n        ++t;\n      } else if (s[i] == '1') {\n        --t;\n      } else {\n        if (t == mn) {\n          ++t;\n        } else {\n          --t;\n        }\n      }\n      chmin(mn, t - mxt);\n      chmax(mx, t - mnt);\n      chmin(mnt, t);\n      chmax(mxt, t);\n    }\n    chmax(res, mx);\n  }\n  cout << res << endl;\n  DEBUG(s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i = a; i <= b; ++i)\n#define PER(i,a,b) for(int i = a; i >= b; --i)\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef long double LD;\n\nconst int maxn = 5000;\nconst int P = 1e9+7;\n\nvoid Add(int &a, int b) { a+=b; if(a>=P) a-=P; }\nvoid Sub(int &a, int b) { a-=b; if(a<0) a+=P; }\nLL PowMod(LL a, LL b) { LL r=1; while(b) { if(b&1) r=r*a%P; a=a*a%P, b>>=1; } return r; }\n\nint n, A, B;\nint f[maxn+5][maxn+5][2], ss[maxn+5];\nint two[maxn+5];\n\nint main() {\n    two[0] = 1;\n    REP(i,1,maxn) two[i] = two[i-1]*2 % P; \n\n    scanf(\"%d%d%d\", &n, &A, &B);\n    if(A>B) swap(A,B);\n\n    f[0][1][0] = f[0][1][1] = 1;\n    ss[0] = 1;\n    int ans = 0;\n    for(int i = 1; i <= n; ++i) {\n        ss[i] = ss[i-1];\n        for(int t = 1; t <= i; ++t) {\n            int tmp = f[i-1][t][0];\n            if(i-t+1 >= B) {\n                if(i < n) tmp = LL(tmp) * two[n-i-1] % P;\n                Add(ans, tmp);\n            }\n            else {\n                f[i][t][1] = tmp;\n                Add(ss[i], f[i][t][1]);\n            }\n            Add(f[i][t][1], f[i-1][t][1]);\n        }\n\n        Add(f[i][i+1][0], ss[i-1]);\n        if(i-A >= 0) Sub(f[i][i+1][0], ss[i-A]);\n\n        for(int t = 1; t <= i; ++t) {\n            int tmp = 0;\n            if(i-A >= 0) tmp = f[i-A][t][1];\n            if(i-t+1 >= B) {\n                if(i < n) tmp = LL(tmp) * two[n-i-1] % P;\n                Add(ans, tmp);\n            }\n            else {\n                f[i][t][0] = tmp;\n            }\n            Add(f[i][t][0], f[i-1][t][0]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nll sum1[5020];\nll sum2[5020][5020];\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n  ll dp[5020][5020];\n    rep(i,0,n+10)rep(j,0,n+10)dp[i][j]=0;\n    dp[0][0]=1;\n    \n    rep(i,0,n+10)sum1[i]=0;\n    sum1[0]=1;\n    \n    rep(i,0,n+10)rep(j,0,n+10)sum2[i][j]=0;\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n//#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define DB double\n#define LD long double\n#define ST string\n#define BS bitset\n#define PA pair<LL,LL>\n#define VE vector\n#define VL vector<LL>\n#define VP vector<pair<LL,LL>>\n#define VVL vector<vector<LL>>\n#define PQ priority_queue\n#define PQS priority_queue<LL,vector<LL>,greater<LL>>\n#define PB push_back\n#define POB pop_back\n#define PF push_front\n#define POF pop_front\n#define EB emplace_back\n#define MP make_pair\n#define TS to_string\n#define TU to_ullong\n#define BPL __builtin_popcountll\n#define FOR(i,a,n) for(i=a;i<n;++i)\n#define FORR(i,a,n) for(i=n-1;i>=a;--i)\n#define rep(i,n) FOR(i,0,n)\n#define repr(i,n) FORR(i,0,n)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define SORT(a) sort(ALL(a))\n#define REV(a) reverse(ALL(a))\n#define UB(a,n) *upper_bound(ALL(a),n)\n#define UBn(a,n) upper_bound(ALL(a),n)-a.begin()\n#define LB(a,n) *lower_bound(ALL(a),n)\n#define LBn(a,n) lower_bound(ALL(a),n)-a.begin()\n#define INF 1145141919810364364LL\n#define PI 3.14159265358979\n#define MOD 1000000007\n//#define MOD 998244353\n#define ERR 0.00000001\n#define FAST cin.tie(0);ios::sync_with_stdio(false)\n\nvoid Yn(LL a){if(a)printf(\"Yes\\n\");else printf(\"No\\n\");}\nvoid YN(LL a){if(a)printf(\"YES\\n\");else printf(\"NO\\n\");}\nLL pwmn(LL a,LL n){LL ans=1;while(ans<a)ans*=n;return ans;}\nLL dig(LL n){LL ret=0;while(n)n/=10,ret++;return ret;}\nLL GCD(LL a,LL b){LL c=1,tmp=max(a,b);b=min(a,b);a=tmp;while(c!=0){c=a%b;a=b;b=c;}return a;}\nLL LCM(LL a,LL b){return a*b/GCD(a,b);}\nint lcmp(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return 1;if(*(LL*)a<*(LL*)b)return -1;return 0;}\nint lcmpr(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return -1;if(*(LL*)a<*(LL*)b)return 1;return 0;}\nint ccmp(const void* a,const void* b){return *(char*)a-*(char*)b;}\nint ccmpr(const void* a,const void* b){return *(char*)b-*(char*)a;}\nint scmp(const void* a,const void* b){return strcmp((char*)a,(char*)b);}\nint scmpr(const void* a,const void* b){return strcmp((char*)b,(char*)a);}\nLL cmod(LL a,LL m){if(a%m<0)return a%m+abs(m);else return a%m;}\nLL DIV(LL a,LL d,LL m){LL l=m,x=1,y=0,k;while(l){k=d/l;d-=k*l;swap(l,d);x-=k*y;swap(x,y);}return cmod(a*cmod(x,m),m);}\nLL POW(LL a,LL n,LL m){LL ans=1;while(n>0){if(n&1)ans=ans*a%m;a=a*a%m;n>>=1;}return ans;}\nVL fact,finv,inv;\nvoid comi(LL n){LL i;fact.resize(max(2LL,n+1));finv.resize(max(2LL,n+1));inv.resize(max(2LL,n+1));fact[0]=fact[1]=1;finv[0]=finv[1]=1;inv[1]=1;FOR(i,2,n+1){fact[i]=fact[i-1]*i%MOD;inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;finv[i]=finv[i-1]*inv[i]%MOD;}}\nLL com(LL n,LL k){if(n<k||n<0||k<0)return 0;return fact[n]*(finv[k]*finv[n-k]%MOD)%MOD;}\nbool cmps(pair<LL,LL> a,pair<LL,LL> b){if(a.second!=b.second)return a.second<b.second;return a.first<b.first;}\ntemplate<typename T>bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\n#define MI modint<MOD>\ntemplate<int mod>struct modint{\n\tint x;\n\tmodint():x(0){}\n\tmodint(LL n):x(n>=0?n%mod:(mod-(-n)%mod)%mod){}\n\tmodint &operator+=(const modint &n){if((x+=n.x)>=mod)x-=mod;return *this;}\n\tmodint &operator-=(const modint &n){if((x+=mod-n.x)>=mod)x-=mod;return *this;}\n\tmodint &operator++(){*this+=1;return *this;}\n  modint &operator--(){*this-=1;return *this;}\n\tmodint &operator*=(const modint &n){x=(int)((LL)x*n.x%mod);return *this;}\n\tmodint &operator/=(const modint &n){*this*=n.inv();return *this;}\n\tmodint operator-()const{return modint(-x);}\n\tmodint operator+(const modint &n)const{return modint(*this)+=n;}\n\tmodint operator-(const modint &n)const{return modint(*this)-=n;}\n\tmodint operator++(int){modint ret(*this);*this+=1;return ret;}\n  modint operator--(int){modint ret(*this);*this-=1;return ret;}\n\tmodint operator*(const modint &n)const{return modint(*this)*=n;}\n\tmodint operator/(const modint &n)const{return modint(*this)/=n;}\n\tbool operator<(const modint &n)const{return x<n.x;}\n\tbool operator>(const modint &n)const{return x>n.x;}\n\tbool operator<=(const modint &n)const{return x<=n.x;}\n\tbool operator>=(const modint &n)const{return x>=n.x;}\n\tbool operator!=(const modint &n)const{return x!=n.x;}\n\tbool operator==(const modint &n)const{return x==n.x;}\n\tfriend istream &operator>>(istream &is,modint &n){LL l;is>>l;n=modint<mod>(l);return is;}\n\tfriend ostream &operator<<(ostream &os,const modint &n){return os<<n.x;}\n\tint getmod(){return mod;}\n\tmodint inv()const{int a=x,b=mod,c=1,d=0,n;while(b){n=a/b;swap(a-=n*b,b);swap(c-=n*d,d);}return modint(c);}\n\tmodint pow(LL n)const{modint ret(1),m(x);while(n){if(n&1)ret*=m;m*=m;n>>=1;}return ret;}\n};\n\nint main(){\n  FAST;\n  LL i,j,N,A,B;\n  cin>>N>>A>>B;\n\tVE<VE<MI>> dp(N+1);\n\trep(i,N+1)dp[i].resize(2);\n\tVL v(N+1);\n\trep(i,B)v[i]=max(B,A+i);\n\tFOR(i,B,N+1)v[i]=i;\n\tdp[0][0]=1;\n\tFOR(i,1,N+1){\n\t\tdp[i][0]=dp[i-1][0]+dp[i-1][1];\n\t\trep(j,i){\n\t\t\tif(N-j>v[i-j]-1){\n\t\t\t\tdp[i][1]+=dp[j][0];\n\t\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\t}\n\t\t\t/*if(i-j>=v[1]){\n\t\t\t\t//cout<<\"!\"<<v[1]<<endl;\n\t\t\t\tdp[i][1]+=dp[j][0]+dp[j][1];\n\t\t\t}*/\n\t\t\t//cout<<v[1]<<endl;\n\t\t}\n\t\tif(i>=N-v[B-1]&&i-v[1]>=0){\n\t\t\tdp[i][1]+=dp[i-v[1]][1]+dp[i-v[1]][0];\n\t\t}\n\t}\n\trep(i,N)cout<<v[i+1]<<\" \";\n\tcout<<endl;\n\trep(i,N)cout<<dp[i+1][0]<<\" \"<<dp[i+1][1]<<\" \";\n\tcout<<endl;\n\tcout<<dp[N][0]+dp[N][1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nll sum1[5020];\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n  ll dp[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)dp[i][j]=0;\n    dp[0][0]=1;\n    \n    rep(i,0,n+10)sum1[i]=0;\n    sum1[0]=1;\n    ll sum2[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)sum2[i][j]=0;\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5010, P = 1000000007;\nint n, A, B, ans, pw[maxn], f[maxn][maxn][2], pre[maxn][maxn][2], h[maxn];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &A, &B);\n    if (A < B) swap(A, B);\n    pw[0] = pw[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        pw[i] = (pw[i - 1] + pw[i - 1]) % P;\n    }\n    f[0][0][0] = f[0][0][1] = 1, h[0] = 1;\n    pre[0][0][0] = pre[0][0][1] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            (f[i][j][0] += pre[i - 1][i - j][1]) %= P;\n            (f[i][j][1] += pre[i - B][i - j][0]) %= P;\n        }\n        for (int j = i - B + 1; j < i; j++) {\n            (f[i][0][1] += h[j]) %= P;\n        }\n        for (int j = A; j <= i; j++) {\n            int s = 1LL * (f[i][j][0] + f[i][j][1]) * pw[n - i] % P;\n            (ans += s) %= P, f[i][j][0] = f[i][j][1] = 0;\n        }\n        for (int j = 0; j <= i; j++) {\n            (h[i] += f[i][j][0]) %= P;\n            pre[i][i - j][0] = (pre[i - 1][i - j][0] + f[i][j][0]) % P;\n            pre[i][i - j][1] = (pre[i - 1][i - j][1] + f[i][j][1]) % P;\n        }\n    }\n    printf(\"%d\\n\", (ans + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int N, A, B; cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n\n    mvec dq(N + 5, 0);\n    dq[0] = 1;\n    FOR(i, 1, N + 5){\n        dq[i] += dq[i - 1];\n        FOR(j, i + B, N + 5) dq[j] += dq[i - 1];\n    }\n\n    mvec dp(N, 0);\n    REP(i, N){\n        mint t = 0;\n        if(i < A) t += dq[i];\n        \n        FOR(j, 2, A + 1) if(i - j >= 0) t += dp[i - j] * dq[j - 2]; \n        FOR(j, 0, B - 1) if(i + j < N) dp[i + j] += t;\n    }\n    //vdebug(dq);\n    //vdebug(dp);\n\n    mint ans = dp[N - 1];\n    FOR(j, 1, A) ans += dp[N - 1 - j] * dq[j];\n\n    ans = pow((mint)2, N) - ans;\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,mod=1e9+7;\nint n,a,b;\nll f[N],c[N][N],dp[N][2];\nll C(int n,int m)\n{\n    if(m==0||n==m) return 1;\n    if(m==1) return n;\n    if(c[n][m]) return c[n][m];\n    return c[n][m]=(C(n-1,m-1)+C(n-1,m))%mod;\n}\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    for(;n;n>>=1,a=a*a%mod)if(n&1) ans=ans*a%mod;\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b) swap(a,b);\n    f[1]=1;\n    for(int i=1;i<b;i++)\n    {\n        f[i+1]=(f[i+1]+f[i])%mod;\n        for(int j=a;i+j+1<=b;j++)\n                f[i+j+1]=(f[i+j+1]+f[i])%mod;\n    }\n    dp[0][0]=dp[0][1]=1;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=i+1;j<i+a&&j<=n;j++)\n            (dp[j][0]+=dp[i][1])%=mod;\n        for(int j=i+1;j<i+b&&j<=n;j++)\n            (dp[j][1]+=dp[i][0]*f[j-i+(i==0||j==n)])%=mod;\n    }\n    ll ans=qpow(2,n);\n    ans=(ans-dp[n][0]-dp[n][1])%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n//    #include <boost/multiprecision/cpp_int.hpp>\n  //  using namespace boost::multiprecision;\n #define int  long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n  #define PI 3.14159265358979323846\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[1000100];\n                int inv[1000110];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n               \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\n\nint dp[5020][2]={};\n\nint w[5020]={};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a<b) swap(a,b);\n\tdp[0][0]=1;\n\tdp[0][1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i][0]+=dp[i-j][1];\n\t\t\tif(j>=b)dp[i][1]+=dp[i-j][0];\n\t\t}\n\t\tdp[i][0]%=inf;\n\t\tdp[i][1]%=inf;\n\t\tw[i]=(dp[i][0]+dp[i][1])%inf;\n\t}\n\tw[0]=1;\n\tdp[0][0]=1;\n\tdp[0][1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][0]=0;\n\t\tdp[i][1]=0;\n\t\tfor(int j=1;j<=min(a-1,i);j++)dp[i][0]+=dp[i-j][1]*w[max(0ll,j-(j!=i)-(i!=n))]%inf;\n\t\tfor(int j=1;j<=min(b-1,i);j++)dp[i][1]+=dp[i-j][0];\n\t\tdp[i][0]%=inf;\n\t\tdp[i][1]%=inf;\n\t}\n\t\n\tcout<<(beki(2,n,inf)+inf-(dp[n][0]+dp[n][1])%inf)%inf<<endl;\n\treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <set>\n#include <iomanip>\n#include <utility>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nll mod=1000000007, dp[5010][5010], sum[5010], ds[5010][5010];\n\nint main() {\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif(A<B) swap(A, B);\n\tdp[0][0]=1;\n\tfor(int i=1; i<A; ++i) dp[0][i]=0;\n\tsum[0]=0;\n\tsum[1]=1;\n\tds[0][1]=1;\n\tfor(int i=0; i<=N; ++i) ds[i][0]=0;\n\tfor(int i=0; i<N; ++i){\n\t\tfor(int j=1; j<A; ++j) dp[i+1][j]=dp[i][j-1];\n\t\t(dp[i+1][1] += sum[i]+mod-sum[max(0, i-B+1)]) %= mod;\n\t\tfor(int j=B+1; j<A; ++j){\n\t\t\t(dp[i+1][j] += ds[i+1-j][j-B]) %= mod;\n\t\t}\n\t\tsum[i+2]=sum[i+1];\n\t\tfor(int j=0; j<A; ++j) (sum[i+2] += dp[i+1][j]) %= mod;\n\t\tfor(int j=0; j<min(A, i+1); ++j){\n\t\t\tds[i+1-j][j+1]=(ds[i+1-j][j]+dp[i+1][j])%mod;\n\t\t}\n\t}\n\tll ans=(sum[N+1]+mod-sum[N-B+1])%mod, mult=1;\n\tfor(int i=0; i<N; ++i) (mult *= 2) %= mod;\n\tfor(int i=B+1; i>=A-1; --i){\n\t\tfor(int j=0; j<A-i; ++j){\n\t\t\t(ans += dp[N-i][j]) %= mod;\n\t\t}\n\t}\n\tcout << (mult+mod-ans)%mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << (x) << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << ((a)[qwq]);\\\n\t\telse cerr << \", \" << ((a)[qwq]);\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\ntemplate<typename A, typename B>\nostream& operator << (ostream& out, const pair<A, B> &p) {\n\treturn out << '(' << p.first << \", \" << p.second << ')';\n}\n\nconst LL P = 1000000007;\nconst int maxN = 5000 + 5;\nint n, A, B;\nLL f[maxN][2], f2[maxN][2], g[maxN], g2[maxN], h[maxN][2][2], p2[maxN];\n\n#define bin(a) for(int a = 0; a < 2; ++a)\n\nint main() {\n\tcin >> n >> A >> B;\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; ++i) p2[i] = p2[i - 1] * 2 % P;\n\t\n\tif(A > B) swap(A, B);\n\tif(A == 1) {\n\t\tcout << p2[n] << endl;\n\t\treturn 0;\n\t}\n\t\n\tmemset(h, 0, sizeof(h));\n\tfor(int i = A; i <= B; ++i) h[i][0][0]++;\n\tfor(int i = 1; i <= B; ++i) h[i][1][1]++;\n\tfor(int i = 1; i < B; ++i) {\n\t\tfor(int j = 1; i + j <= B; ++j)\n\t\t\tbin(a) (h[i + j][a][1] += h[i][a][0]) %= P;\n\t\tbin(a) (h[i + A][a][0] += h[i][a][1]) %= P;\n\t\tfor(int j = A + 1; i + j <= B; ++j)\n\t\t\tbin(a) (h[i + j][a][0] += h[i][a][1]) %= P;\n\t}\n//\tfor(int i = 1; i <= n; ++i)\n//\t\teprintf(\"%lld %lld %lld %lld\\n\", h[i][0][0], h[i][0][1], h[i][1][0], h[i][1][1]);\n\tfor(int i = 1; i < B; ++i) memset(h[i], 0, sizeof(h[i]));\n\t\n\tmemset(f, 0, sizeof(f));\n\tmemset(g, 0, sizeof(g));\n\tmemset(g2, 0, sizeof(g2));\n\tmemset(f2, 0, sizeof(f2));\n\t\n\tfor(int i = 1; i <= n; ++i) bin(a) bin(b)\n\t\t(f[i][b] += h[i][a][b]) %= P;\n\tfor(int i = 1; i < A; ++i) g2[i]++;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tbin(a) (f2[i][a] += f[i][a]) %= P;\n\t\tfor(int j = 1; i + j <= n; ++j)\n\t\t\tbin(a) bin(b) (f2[i + j][b] += f[i][a] * p2[j - 1]) %= P;\n\t\tg[i] = (P + p2[i - 1] - f2[i][1]) % P;\n\t\tfor(int j = 1; j < A && i + j <= n; ++j) (g2[i + j] += g[i]) %= P;\n\t\t\n\t\tfor(int j = 1; i + j <= n; ++j) bin(b)\n\t\t\t(f[i + j][b] += g2[i] * h[j][1][b]) %= P;\n\t}\n//\tdisplaya(g, 1, n);\n//\tdisplaya(g2, 1, n);\n\tcout << ((f2[n][0] + f2[n][1]) % P) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass CRangeSet {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        int A, B; cin >> A >> B;\n        if (A > B) swap(A, B);\n\n        vector<FieldMod> BVal(B+2, 0);\n        BVal[0] = 1;\n        for (int i = 1; i < B+2; ++i) {\n            BVal[i] += BVal[i-1];\n            for (int j = A; j + i + 1 < B+2; ++j) BVal[i+j+1] += BVal[i];\n        }\n\n        vector2<FieldMod> D(N+2, 2, 0);\n        D[0][0] = D[0][1] = 1;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 1; j < A && i + j <= N; ++j) D[i+j][0] += D[i][1];\n            for (int j = 1; j < B && i + j <= N; ++j) D[i+j][1] += D[i][0] * BVal[j + (i == 0) + (i+j==N)];\n        }\n\n        FieldMod ans = FieldMod{2}.pow(N) - (D[N][0] + D[N][1]);\n        cout << ans << '\\n';\n    }\n};\n\n\n\nint main() {\n\t// ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tCRangeSet solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 5e3 + 5;\nconst double eps = 1e-9;\n\nint dp[N][N][2][2];\n\ninline int add(int& x, int y) { return x = x+y < mod ? x+y : x+y-mod; }\ninline int sub(int& x, int y) { return x = x-y >= 0 ? x-y : x-y+mod; }\ninline int mul(int x, int y) { return x * 1ll * y % mod; }\ninline int pw(int x, int y) {\n  int r = 1;\n  for (; y; y /= 2, x = mul(x, x))\n    if (y & 1)\n      r = mul(r, x);\n  return r;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b)\n    swap(a, b);\n  if (a == 1) {\n    printf(\"%d\\n\", pw(2, n));\n    return 0;\n  }\n  dp[0][0][0][0] = 1;\n  dp[0][0][0][1] = 1;\n\n  dp[1][1][0][0] = mod-1;\n  dp[1][1][0][1] = mod-1;\n  for (int i = 0; i <= n; i++) {\n    int sm[2] = {0, 0};\n    for (int j = 0; j <= i; j++) {\n      if (i > 0 && j > 0)\n        for (int ii = 0; ii < 2; ii++)\n   for (int jj = 0; jj < 2; jj++)\n            add(dp[i][j][ii][jj], dp[i-1][j-1][ii][jj]);\n      if (a + i <= n) {\n        if (j+a >= b) {\n          add(dp[i+a][j+a][1][0], dp[i][j][0][1]);\n          sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][0][1]);\n        } else {\n          add(dp[i+a][j+a][0][0], dp[i][j][0][1]);\n          sub(dp[min(N-1,i+b-j)][j+b-j][0][0], dp[i][j][0][1]);\n          add(dp[min(N-1,i+b-j)][j+b-j][1][0], dp[i][j][0][1]);\n          sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][0][1]);\n        }\n        add(dp[i+a][j+a][1][0], dp[i][j][1][1]);\n        sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][1][1]);\n      }\n      if (j+1 >= b) {\n        add(dp[i+1][j+1][1][1], dp[i][j][0][0]);\n        sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][0][0]);\n      } else {\n        add(dp[i+1][j+1][0][1], dp[i][j][0][0]);\n        sub(dp[min(N-1,i+b-j)][j+b-j][0][1], dp[i][j][0][0]);\n        add(dp[min(N-1,i+b-j)][j+b-j][1][1], dp[i][j][0][0]);\n        sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][0][0]);\n      }\n      add(dp[i+1][j+1][1][1], dp[i][j][1][0]);\n      sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][1][0]);\n      for (int k = 0; k < 2; k++)\n        add(sm[k], dp[i][j][k][1]);\n    }\n    for (int nj = 1; nj + i <= n && nj < a; nj++) {\n      for (int k = 0; k < 2; k++) {\n        add(dp[i+nj][0][k][0], sm[k]);\n        sub(dp[i+nj+1][1][k][0], sm[k]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j < 2; j++)\n      add(ans, dp[n][i][1][j]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 5e3 + 5;\nconst double eps = 1e-9;\n\nint dp[N][N][2][2];\n\ninline int add(int& x, int y) { return x = x+y < mod ? x+y : x+y-mod; }\ninline int sub(int& x, int y) { return x = x-y >= 0 ? x-y : x-y+mod; }\ninline int mul(int x, int y) { return x * 1ll * y % mod; }\ninline int pw(int x, int y) {\n  int r = 1;\n  for (; y; y /= 2, x = mul(x, x))\n    if (y & 1)\n      r = mul(r, x);\n  return r;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b)\n    swap(a, b);\n  if (a == 1) {\n    printf(\"%d\\n\", pw(2, n));\n    return 0;\n  }\n  dp[0][0][0][0] = 1;\n  dp[0][0][0][1] = 1;\n\n  dp[1][1][0][0] = mod-1;\n  dp[1][1][0][1] = mod-1;\n  for (int i = 0; i <= n; i++) {\n    int sm[2] = {0, 0};\n    for (int j = 0; j <= i; j++) {\n      if (i > 0 && j > 0)\n        for (int ii = 0; ii < 2; ii++)\n          for (int jj = 0; jj < 2; jj++)\n            add(dp[i][j][ii][jj], dp[i-1][j-1][ii][jj]);\n      if (a + i <= n) {\n        if (j+a >= b) {\n          add(dp[i+a][j+a][1][0], dp[i][j][0][1]);\n          sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][0][1]);\n        } else {\n          add(dp[i+a][j+a][0][0], dp[i][j][0][1]);\n          sub(dp[min(N-1,i+b-j)][j+b-j][0][0], dp[i][j][0][1]);\n          add(dp[min(N-1,i+b-j)][j+b-j][1][0], dp[i][j][0][1]);\n          sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][0][1]);\n        }\n        add(dp[i+a][j+a][1][0], dp[i][j][1][1]);\n        sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][1][1]);\n      }\n      if (j+1 >= b) {\n        add(dp[i+1][j+1][1][1], dp[i][j][0][0]);\n        sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][0][0]);\n      } else {\n        add(dp[i+1][j+1][0][1], dp[i][j][0][0]);\n        sub(dp[min(N-1,i+b-j)][j+b-j][0][1], dp[i][j][0][0]);\n        add(dp[min(N-1,i+b-j)][j+b-j][1][1], dp[i][j][0][0]);\n        sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][0][0]);\n      }\n      add(dp[i+1][j+1][1][1], dp[i][j][1][0]);\n      sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][1][0]);\n      for (int k = 0; k < 2; k++)\n        add(sm[k], dp[i][j][k][1]);\n    }\n    for (int nj = 1; nj + i <= n && nj < a; nj++) {\n      for (int k = 0; k < 2; k++) {\n        add(dp[i+nj][0][k][0], sm[k]);\n        sub(dp[i+nj+1][1][k][0], sm[k]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j < 2; j++)\n      add(ans, dp[n][i][1][j]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\n\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\n\nll N,A,B;\nll Fa[5454], iFa[5454];\nll mk[5050],dpa[5050],dpb[5050];\nll i, j, k;\n\nvoid init(){\n    ll i;\n    Fa[0] = 1;\n    fornum(i,0,5050){\n        Fa[i + 1] = Fa[i] * (i + 1) % MOD;\n    }\n    iFa[5050] = moddiv(1, Fa[5050]);\n    for (i = 5050; i > 0;--i){\n        iFa[i - 1] = iFa[i] * i % MOD;\n    }\n}\nll C(ll a,ll b){\n    if(a<b)\n        return 0;\n    return Fa[a] * iFa[a - b] % MOD * iFa[b] % MOD;\n}\nll inv(ll a){\n    return iFa[a - 1] * Fa[a] % MOD;\n}\n\nint main(){\n    scanf(\"%lld%lld%lld\", &N,&A,&B);\n    if(A<B)\n        swap(A, B);\n    mk[0] = 1;\n    fornum(i,1,A+1){\n        mk[i] = mk[i-1];\n        fornum(j,1,i){\n            if(B+1<=i-j){\n            //printf(\"%lld \", j);\n                (mk[i] += mk[j]) %= MOD;\n            }\n        }\n        //printf(\"%lld,%lld\\n\",i, mk[i]);\n    }\n\n    ll ans = 1;\n    dpa[0] = 1;\n    dpb[0] = 1;\n    fornum(i,0,N){\n        ans = ans * 2 % MOD;\n        fornum(j,i+1,N+1){\n            if (j - i < A){\n                if(i==0||j==N)\n                    (dpa[j] += dpb[i] * mk[j - i + 1]) %= MOD;\n                else\n                    (dpa[j] += dpb[i] * mk[j - i]) %= MOD;\n            }\n            if (j - i < B)\n                (dpb[j] += dpa[i]) %= MOD;\n        }\n        //printf(\"%lld:%lld,%lld\\n\", i, dpa[i], dpb[i]);\n    }\n    //printf(\"%lld,%lld\\n\", dpa[N], dpb[N]);\n    (ans += -dpa[N] - dpb[N] + MOD * 2) %= MOD;\n    printf(\"%lld\\n\", ans);\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 107, MOD = 1000 * 1000 * 1000 + 7;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N][N][N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (n > 100)\n        exit(1);\n\n    if (b < a)\n        swap(a, b);\n\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int ca = 0; ca <= i; ++ca) {\n            for (int cb = 0; cb < b; ++cb) {\n                if (!dp[i][ca][cb])\n                        continue;\n\n                int x = dp[i][ca][cb];\n\n                #ifdef HOME\n                cout << \"dp \" << i << ' ' << ca << ' ' << cb << \" : \" << x << endl;\n                #endif\n\n                add(dp[i + 1][ca + 1][cb], x);\n\n                if (ca == 0) {\n                    add(dp[i + 1][0][cb + 1], x);\n                }\n                else if (ca < a) {\n                    add(dp[i + 1][0][1], x);\n                }   \n                else if (cb + ca + 1 < b) {                                \n                    add(dp[i + 1][0][cb + ca + 1], x);\n                }\n            }\n        }   \n    }\n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) \n        ans = (ans << 1) % MOD;\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < b; ++j) {\n            int rb = j;\n            if (i >= a)\n                rb += i;\n            if (rb < b) {\n                ans = mod(ans - dp[n][i][j]);        \n\n                #ifdef HOME\n                if (dp[n][i][j]) {\n                    cout << i << ' ' << j << \" : \" << dp[n][i][j] << endl;\n                }   \n                #endif\n            }\n        }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n//    #include <boost/multiprecision/cpp_int.hpp>\n  //  using namespace boost::multiprecision;\n #define int  long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n  #define PI 3.14159265358979323846\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[1000100];\n                int inv[1000110];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n               \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\n\nint dp[5020][2]={};\nint dp2[5020][2]={};\n\nint w[5020]={};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a<b) swap(a,b);\n\tdp[0][0]=1;\n\tdp[0][1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tdp[i][0]+=dp[i-j][1];\n\t\t\tif(j>=b)dp[i][1]+=dp[i-j][0];\n\t\t}\n\t\tdp[i][0]%=inf;\n\t\tdp[i][1]%=inf;\n\t\tw[i]=dp[i][0]+dp[i][1];\n\t\tw[i]%=inf;\n\t}\n\tw[0]=1;\n//\tfor(int i=0;i<=n;i++)cout<<w[i]<<\" \";\n//\tcout<<endl;\n\tdp2[0][0]=1;\n\tdp2[0][1]=1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=min(a-1,i);j++){\n\t\t\tint co;\n\t\t\tif(j==i && i==n)co=n;\n\t\t\telse if(j==i)co=i-1;\n\t\t\telse if(i==n)co=j-1;\n\t\t\telse co=j-2;\n\t\t\tco=max(co,0ll);\n\t\t\tdp2[i][0]+=dp2[i-j][1]*w[co]%inf;\n\t\t}\n\t\tfor(int j=1;j<=min(b-1,i);j++){\n\t\t\tdp2[i][1]+=dp2[i-j][0];\n\t\t}\n\t\tdp2[i][0]%=inf;\n\t\tdp2[i][1]%=inf;\n\t}\n\t\n\tcout<<(beki(2,n,inf)+inf-(dp2[n][0]+dp2[n][1])%inf)%inf<<endl;\n\treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ll long long\nusing namespace std;\nll dp[100010],d1[100010][2],n,A,B;\nvoid add(ll &x,ll y){x=(x+y)%mo;}\nll po(ll y){ll z=1;for (int i=1;i<=y;i++)z=z*2%mo;return z;}\nint main(){\n\tcin>>n>>A>>B;\n\tif (A<B) swap(A,B);\n\tdp[1]=1;\n\tfor (int i=1;i<A;i++){add(dp[i+1],dp[i]);for (int j=i+B+1;j<=A;j++)add(dp[j],dp[i]);}\n\tfor (int i=1;i<A;i++)d1[i][0]=dp[i+1];\n\tfor (int i=1;i<B;i++)d1[i][1]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=i+1;j<i+A;j++)if (j==n)add(d1[j][0],d1[i][1]*dp[j-i+1]);else add(d1[j][0],d1[i][1]*dp[j-i]);\n\t\tfor (int j=i+1;j<i+B;j++)add(d1[j][1],d1[i][0]);\n\t}\n\tcout<<(po(n)-d1[n][0]-d1[n][1]+mo+mo)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region preprocessor\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n    #define mesg(str) std::cerr << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]  \" << str << \"\\n\"\n#else\n    #define dump(...) ((void)0)\n    #define mesg(str) ((void)0)\n#endif\n#pragma endregion // preprocessor\n\n#pragma region std-overload\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#pragma endregion // std-overload\n\n#pragma region executive-setting\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#pragma endregion // executive-setting\n\n#pragma region fucntion-utility\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n// #define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    assert(__ok != __ng);\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    assert(__ok != __ng);\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type __first, iter_type __last, comp_type comp)\n{\n    assert(__first < __last);\n    std::ptrdiff_t dist(__last - __first);\n    while(dist > 2)\n    {\n        iter_type __left(__first + dist / 3), __right = (__first + dist * 2 / 3);\n        if(comp(__left, __right)) __last = __right, dist = dist * 2 / 3;\n        else __first = __left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(next(__first), __first)) ++__first;\n    return __first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double __first, long double __last, const long double eps, comp_type comp)\n{\n    assert(__first < __last);\n    while(__last - __first > eps)\n    {\n        long double __left{(__first * 2 + __last) / 3}, __right{(__first + __last * 2) / 3};\n        if(comp(__left, __right)) __last = __right;\n        else __first = __left;\n    }\n    return __first;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n#pragma endregion // function-utility\n\n#pragma region using-alias\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n#pragma endregion // using-alias\n\n#pragma region library\n\n#ifndef modint_hpp\n#define modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    static constexpr modint identity() noexcept { return 1; }\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    static constexpr modint identity() noexcept { return 1; }\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // modint_hpp\n\n#pragma endregion // library\n\n#pragma region main-code\nstruct solver; template <class> void main_(); int main() { main_<solver>(); }\ntemplate <class solver> void main_()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n        using mint=modint<(int)1e9+7>;\n\n        int n; cin>>n;\n        int a,b; cin>>a>>b;\n        if(b>a) swap(b,a);\n\n        vector<mint> dp2(1+a);\n        dp2[0]=1;\n        for(int i=1; i<=a; i++)\n        {\n            dp2[i]+=dp2[i-1];\n            for(int j=0; i-j>b; ++j)\n            {\n                dp2[i]+=dp2[j];\n            }\n        }\n\n        vector<mint> dp0(n+1);\n        vector<mint> dp1(n+1);\n        dp0[0]=1;\n        dp1[0]=1;\n        for(int i=0; i<n; ++i)\n        {\n            for(int j=1; j<a and i+j<=n; ++j)\n            {\n                if(i and i+j<n) dp1[i+j]+=dp0[i]*dp2[j-1];\n                else dp1[i+j]+=dp0[i]*dp2[j];\n            }\n            for(int j=1; j<b and i+j<=n; ++j)\n            {\n                if(i and i+j<n) dp0[i+j]+=dp1[i]*dp2[j-1];\n                else dp0[i+j]+=dp1[i]*dp2[j];\n            }\n        }\n        cout << mint::pow(2,n)-dp0[n]-dp1[n] << \"\\n\";\n\n    }\n};\n#pragma endregion // main-code\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 5007, MOD = 1000 * 1000 * 1000 + 7;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N][N][2];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (b < a)\n        swap(a, b);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int t = 0; t < 2; ++t) {\n            int to = i;\n            if (t == 0 && i < a)\n                to = 0;\n            dp[i][to][t] = 1;\n        }   \n    }   \n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < b; ++j) {\n            for (int t = 0; t < 2; ++t) {\n                if (!dp[i][j][t])\n                    continue;\n\n                int x = dp[i][j][t];\n\n                if (t) {\n                    for (int k = 1; k < a; ++k)\n                        add(dp[i + k][0][t^1], x);\n                    for (int k = a; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);\n                }   \n                else {\n                    for (int k = 1; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);                        \n                }   \n            }   \n        }   \n    }   \n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) \n        ans = (ans << 1) % MOD;\n    for (int i = 0; i < b; ++i)\n        for (int t = 0; t < 2; ++t)\n            ans = mod(ans - dp[n][i][t]);\n    cout << ans << endl;            \n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nmint dp[5050][5050][2][2][3];\n\nvoid solve() {\n\tint n, a, b; cin >> n >> a >> b;\n    if(a == 1 || b == 1) {\n        cout << modpow((mint)2, n) << endl;\n        return;\n    }\n    if(a < b) swap(a, b);\n    rep(i, 5050) {\n        rep(j, 5050) {\n            rep(k, 2) {\n                rep(l, 2) {\n                    rep(m, 2) {\n                        dp[i][j][k][l][m] = 0;\n                    }\n                }\n            }\n        }\n    }\n    dp[0][0][0][0][0] = 1;\n    rep(i, n) {\n        rep(j, n + 1) {\n                rep(l, 2) {\n                    rep(m, 3) {\n                        int nl, nm;\n                        nl = (l || (j + 1 >= a)), nm = m;\n                        dp[i + 1][j + 1][0][nl][nm] += dp[i][j][0][l][m];\n                        nl = l, nm = m;\n                        dp[i + 1][1][1][nl][nm] += dp[i][j][0][l][m];\n                        nl = l, nm = m;\n                        dp[i + 1][j + 1][1][nl][nm] += dp[i][j][1][l][m];\n                        nl = l;\n                        if(i - j >= a && j <= b - 1) nm = (m == 0 ? 1 : 2);\n                        else if(n - i >= a && j <= b - 1) nm = (m == 0 ? 1 : 2);\n                        else if(j <= b - 1) nm = 2;\n                        else nm = m;\n                        dp[i + 1][1][0][nl][nm] += dp[i][j][1][l][m];\n                    }\n                }\n        }\n    }\n    mint ans = 0;\n    rep(j, n + 1) {\n        rep(m, 2) {\n            rep(k, 2) {\n                ans += dp[n][j][k][1][m];\n            }\n            ans += dp[n][j][0][0][m];\n        }\n        if(j >= b) {\n            ans += dp[n][j][1][0][0] + dp[n][j][1][0][1];\n        }\n        else {\n            if(n - j >= a) ans += dp[n][j][1][0][0];\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i = a; i <= b; ++i)\n#define PER(i,a,b) for(int i = a; i >= b; --i)\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef long double LD;\n\nconst int maxn = 5000;\nconst int P = 1e9+7;\n\nvoid Add(int &a, int b) { a+=b; if(a>=P) a-=P; }\nvoid Sub(int &a, int b) { a-=b; if(a<0) a+=P; }\nLL PowMod(LL a, LL b) { LL r=1; while(b) { if(b&1) r=r*a%P; a=a*a%P, b>>=1; } return r; }\n\nint n, A, B;\nint f[maxn+5][maxn+5][2], ss[maxn+5];\nint two[maxn+5];\n\nint main() {\n    two[0] = 1;\n    REP(i,1,maxn) two[i] = two[i-1]*2 % P; \n\n    scanf(\"%d%d%d\", &n, &A, &B);\n    if(A>B) swap(A,B);\n\n    f[0][1][0] = f[0][1][1] = 1;\n    ss[0] = 1;\n    int ans = 0;\n    for(int i = 1; i <= n; ++i) {\n        ss[i] = ss[i-1];\n        for(int t = 1; t <= i; ++t) {\n            int tmp = f[i-1][t][0];\n            if(i-t+1 >= B) {\n                if(i < n) tmp = LL(tmp) * two[n-i-1] % P;\n                Add(ans, tmp);\n            }\n            else {\n                f[i][t][1] = tmp;\n                Add(ss[i], f[i][t][1]);\n            }\n            Add(f[i][t][1], f[i-1][t][1]);\n        }\n\n        Add(f[i][i+1][0], ss[i-1]);\n        if(i-A >= 0) Sub(f[i][i+1][0], ss[i-A]);\n\n        for(int t = 1; t <= i; ++t) {\n            int tmp = 0;\n            if(i-A >= 0) tmp = f[i-A][t][1];\n            if(i-t+1 >= B) {\n                if(i < n) tmp = LL(tmp) * two[n-i-1] % P;\n                Add(ans, tmp);\n            }\n            else {\n                f[i][t][0] = tmp;\n            }\n            Add(f[i][t][0], f[i-1][t][0]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tint n,a,b;\n\tcin >> n >> a >> b;\n\t\n\tlong long mod=1000000007;\n\t\n\t//a<=b\n\tif(a>b) swap(a,b);\n\t\n\t//連続するa以上の0を全て1にしたとき，連続するbが存在するか．\n\tvector<vector<long long>> dp(n+1,vector<long long>(n+1));\n\tvector<vector<long long>> dp2(n+1,vector<long long>(n+1));\n\tvector<long long> res(n+1),res2(n+1);\n\tdp[0][0]=1;\n\tdp2[0][0]=0;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tres[i+1]+=(res[i]*2+res2[i])%mod;\n\t\tres[i+1]%=mod;\n\t\t\n\t\t//add 1\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((j+1)<b){\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\tdp[i+1][j+1]+=dp2[i][j];\n\t\t\t\tdp[i+1][j+1]%=mod;\n\t\t\t}\n\t\t}\n\t\tres[i+1]+=dp[i][b-1];\n\t\tres[i+1]+=dp2[i][b-1];\n\t\tres[i+1]%=mod;\n\t\t\n\t\tfor(int j=1;(i+j)<=n;j++){\n\t\t\t//add j 0's\n\t\t\tif(j<a){\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tdp2[i+j][0]+=dp[i][k];\n\t\t\t\t\tdp2[i+j][0]%=mod;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\t\tif((j+k)<b){\n\t\t\t\t\t\tdp2[i+j][j+k]+=dp[i][k];\n\t\t\t\t\t\tdp2[i+j][j+k]%=mod;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tres2[i+j]+=dp[i][k];\n\t\t\t\t\t\tres2[i+j]%=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (res[n]+res2[n])%mod << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\n//vector<vector<ll>> dp0, dp1;\nll dp0[5005][5005];\nll dp1[5005][5005];\nll dp0sub0[5005][5005];\nll dp0sub1[5005][5005];\n\nint main() {\n    //dp1.resize(5005, vector<ll>(5005));\n    //dp0 = dp1;\n    ll N, A, B;\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    dp0[1][A-1] = 1;\n    dp1[1][B-1] = 1;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 0; j <= N; j++) {\n            dp0[i][j] += dp0sub0[i][j];\n            dp0[i][j] += dp0sub1[i][j];\n            dp0[i][j] %= mod;\n            if(j) {\n                dp0sub0[i+1][j-1] += dp0sub0[i][j];\n                dp0sub0[i+1][j-1] %= mod;\n            }\n            dp0sub1[i+1][j] += dp0sub1[i][j];\n            dp0sub1[i+1][j] %= mod;\n        }\n        for(int j = 1; j <= N; j++) {\n            dp0[i+1][j-1] += dp0[i][j];\n            dp1[i+1][j-1] += dp1[i][j];\n            dp0[i+1][j-1] %= mod;\n            dp1[i+1][j-1] %= mod;\n            /*\n            for(int k = 1; k < B; k++) {\n                dp0[i+k+1][A-1] += dp0[i][j];\n                dp0[i+k+1][A-1] %= mod;\n            }\n            */\n            if(j >= B) {\n                /*\n                for(int k = B; k < j; k++) {\n                    dp0[i+k+1][j-k-1] += dp0[i][j];\n                    dp0[i+k+1][j-k-1] %= mod;\n                }\n                */\n                dp1[i+j][0] += dp0[i][j];\n                if(i+B+1 <= N) {\n                    dp0sub0[i+B+1][j-B-1] += dp0[i][j];\n                    dp0sub0[i+B+1][j-B-1] %= mod;\n                }\n                dp1[i+j][0] %= mod;\n                /*\n                for(int k = 1; k < B; k++) {\n                    dp0[i+k+1][A-1] += dp0[i][j];\n                    dp0[i+k+1][A-1] %= mod;\n                }\n                */\n               if(i+2 <= N) {\n                    dp0sub1[i+2][A-1] += dp0[i][j];\n                    dp0sub1[i+2][A-1] %= mod;\n               }\n               if(i + B + 1 <= N) {\n                    dp0sub1[i+B+1][A-1] += mod - dp0[i][j];\n                    dp0sub1[i+B+1][A-1] %= mod;\n               }\n            } else {\n                dp1[i+1][B-1] += dp0[i][j];\n                dp1[i+1][B-1] %= mod;\n            }\n            dp0[i+1][A-1] += dp1[i][j];\n            dp0[i+1][A-1] %= mod;\n        }\n        dp1[i+1][0] += dp0[i][0];\n        dp1[i+1][0] += dp1[i][0];\n        dp1[i+1][0] %= mod;\n        int idx = A - i - 1;\n        chmax(idx, 0);\n        dp0[i+1][idx] += dp0[i][0];\n        dp0[i+1][idx] += dp1[i][0];\n        dp0[i+1][idx] %= mod;\n    }\n    /*\n    for(int i = 0; i <= N; i++) {\n        for(int j = 0; j <= N; j++) {\n            if(dp0[i][j] == 0 and dp1[i][j] == 0) continue;\n            cerr<< i << \" \" << j << \" \" << dp0[i][j] << \" \" << dp1[i][j] << endl;\n        }\n        //cerr << i << \" \" << dp0[i][0] << \" \" << dp1[i][0] << endl;\n    }\n    */\n    ll ans = dp0[N][0] + dp1[N][0];\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 5005;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint N, A, B;\nint f1[MN], f2[MN], f3[MN], f4[MN];\nint g1[MN], g2[MN];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tif (A > B) std::swap(A, B);\n\tif (A == 1) return printf(\"%d\\n\", qPow(2, N)), 0;\n\tf1[1] = 1;\n\tfor (int i = 2; i < B; ++i) {\n\t\tf1[i] = 1;\n\t\tfor (int j = 1; j <= i - 1; ++j)\n\t\t\tf1[i] = (f1[i] + f2[i - j]) % Mod;\n\t\tfor (int j = A; j <= i - 1; ++j)\n\t\t\tf2[i] = (f2[i] + f1[i - j]) % Mod;\n\t\tfor (int j = 1; j <= i - 1; ++j)\n\t\t\tf3[i] = (f3[i] + f4[i - j]) % Mod;\n\t\tif (i >= A) f4[i] = 1;\n\t\tfor (int j = A; j <= i - 1; ++j)\n\t\t\tf4[i] = (f4[i] + f3[i - j]) % Mod;\n\t}\n//\tfor (int i = 1; i < B; ++i) printf(\"(f1, f2, f3, f4)[%d] = (%d, %d, %d, %d)\\n\", i, f1[i], f2[i], f3[i], f4[i]);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (i < B) g1[i] = (f1[i] + f3[i]) % Mod;\n\t\tfor (int j = 1; j < B && j <= i - 1; ++j)\n\t\t\tg1[i] = (g1[i] + (LL)g2[i - j] * f1[j]) % Mod;\n\t\tif (i < A) g2[i] = 1;\n\t\tfor (int j = 1; j < A && j <= i - 1; ++j)\n\t\t\tg2[i] = (g2[i] + g1[i - j]) % Mod;\n//\t\tprintf(\"(g1, g2)[%d] = (%d, %d)\\n\", i, g1[i], g2[i]);\n\t}\n\tint Ans = (g1[N] + g2[N]) % Mod;\n\tfor (int j = 1; j <= N - 1; ++j)\n\t\tAns = (Ans + (LL)g2[N - j] * f2[j]) % Mod;\n\tprintf(\"%d\\n\", (qPow(2, N) - Ans + Mod) % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\ntypedef ModInt<1000000007> mint;\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\n\nint main() {\n\t// TODO : a == b\n\tint n = ri();\n\t\n\tint a = ri(), b = ri();\n\tif (a > b) std::swap(a, b);\n\t\n\tstatic mint dp[5001][5001][2]; // pos, len, flag\n\tdp[0][0][1] = 1;\n\t\n\tmint diff[n + 1];\n\tmint cur = 0;\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tcur += diff[i];\n\t\tdp[i][1][1] += cur;\n\t\t\n\t\tmint beki2 = mint(2) ^ (n - i);\n\t\tfor (int j = b; j <= n; j++) res += beki2 * (dp[i][j][0] + dp[i][j][1]);\n\t\tif (i == n) break;\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tdp[i + 1][j + 1][0] += dp[i][j][0];\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][0];\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][1];\n\t\t\tif (i + a <= n) dp[i + a][j + a][0] += dp[i][j][1];\n\t\t\t// for (int k = i + 2; k <= n && k <= i + a; k++) dp[k][1][1] += dp[i][j][1];\n\t\t\tif (i + 2 <= n) {\n\t\t\t\tdiff[i + 2] += dp[i][j][1];\n\t\t\t\tif (i + a + 1 <= n) diff[i + a + 1] -= dp[i][j][1];\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k < 2; k++) if (dp[i][j][k] != 0) {\n\t\tstd::cerr << \"pos:\" << i << \" len:\" << j << \" next:\" << k << \" : \" << dp[i][j][k] << std::endl;\n\t}*/\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static constexpr unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconstexpr LL MOD = 1000000007;\nusing Mint = ModInt<MOD>;\n\nint N;\nint A, B;\n\nMint aFa[10011];\nMint aFb[10011];\nMint bFb[10011];\n\nMint dp0[10011];\nMint dp1[10011];\nMint dp2[10011];\nMint dp3[10011];\nMint dp4[10011];\n\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &A, &B);\n    if (A > B) swap(A, B);\n    aFa[A] = 1;\n    for (int i=A; i<N; i++) {\n\t// b;\n\taFa[i+1] += aFa[i];\n\t// baaaaa;\n\tfor (int a=A; a+i<=N; a++) aFa[i+a+1] += aFa[i];\n    }\n\n    for (int a=A; a<N; a++) aFb[a+1] = 1;\n    for (int i=A+1; i<N; i++) {\n\t// b;\n\taFb[i+1] += aFb[i];\n\t// aaaaab;\n\tfor (int a=A; a+i<=N; a++) aFb[i+a+1] += aFb[i];\n    }\n\n    bFb[1] = 1;\n    for (int i=1; i<N; i++) {\n\t// b;\n\tbFb[i+1] += bFb[i];\n\t// aaaaab;\n\tfor (int a=A; a+i<=N; a++) bFb[i+a+1] += bFb[i];\n    }\n\n\n    Mint ans = 0;\n\n    for (int a=1; a<A; a++) {\n\tdp0[a] += 1;\n    }\n    for (int b=1; b<B; b++) {\n\tdp1[b] += bFb[b];\n\tdp1[b] += aFb[b];\n    }\n    for (int b=B; b<N; b++) {\n\tdp2[b] += bFb[b];\n\tdp2[b] += aFb[b];\n    }\n\n    ans += aFa[N];\n    ans += aFb[N] * 2;\n    ans += bFb[N];\n\n    //eprintf(\"%d\\n\", aFa[N].geti());\n    //eprintf(\"%d\\n\", aFb[N].geti());\n    //eprintf(\"%d\\n\", bFb[N].geti());\n    //eprintf(\"%d\\n\", ans.geti());\n\n    for (int i=1; i<N; i++) {\n\tfor (int a=1; a<A; a++) {\n\t    dp0[i+a] += dp1[i];\n\t}\n\n\tfor (int b=1; b<B; b++) {\n\t    dp1[i+b] += dp0[i] * bFb[b];\n\t}\n\n\tfor (int b=B; b+i<N; b++) {\n\t    dp2[i+b] += dp0[i] * bFb[b];\n\t}\n\n\tif (N-i >= B) {\n\t    ans += dp0[i] * bFb[N-i];\n\t    ans += dp0[i] * aFb[N-i]; // bFa;\n\t}\n\n\tfor (int a=1; a<A; a++) {\n\t    dp3[i+a] += dp2[i];\n\t}\n\n\t// b;\n\tdp4[i+1] += dp3[i];\n\t// a or b;\n\tdp4[i+1] += dp4[i] * 2;\n    }\n\n    ans += dp3[N] + dp4[N];\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 5010;\nLL f[MAXN][MAXN];\nint pot[MAXN];\nconst LL mod = 1e9 + 7;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    pot[0] = 1;\n    for (int i = 1; i < MAXN; i++) pot[i] = 2*pot[i-1] % mod;\n\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n    if (A == 1) {\n        cout << pot[MAXN] << \"\\n\";\n        return 0;\n    }\n    vector<LL> pref(MAXN, 0);\n    vector<vector<LL>> hardpref(MAXN, vector<LL>(MAXN, 0));\n    for (int n = 1; n <= N; n++) {\n        for (int k = 0; k < B; k++) {\n            f[n][k] += f[n-1][k+1];\n            if (k == B-1) f[n][k] += pot[n-1];\n            if (k + n >= B and n >= A) f[n][k]++;\n            f[n][k] += pref[n-1] - ((n-A >= 0)?pref[n-A]:0);\n            // n-1-A, 1+k+A\n            // n-z, k+z\n            int low = 1+A;\n            int high = min(n, B-k-1);\n            if (low <= high) f[n][k] += hardpref[n-low][k+low];\n            if (high != n) f[n][k] -= hardpref[n-high-1][k+high+1];\n            // for (int t = A; 1+t <= min(n, B-k-1); t++) {\n                // f[n][k] += f[n-1-t][1+k+t];\n            // }\n            int z = max(B-k, A+1);\n            if (n-z+1 >= 0) f[n][k] += pot[n-z+1]-1;\n            f[n][k] %= mod;\n            hardpref[n][k] = (hardpref[n-1][k+1] + f[n][k]) % mod;\n        }\n        pref[n+1] = (pref[n] + f[n][1]) % mod;\n    }   \n    // dbg(f[1][2]);\n    if (f[N][0] < 0) f[N][0] += mod;\n    cout << f[N][0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint brute(int N,int A,int B){\n    int res=0;\n    for (int mask=0;mask<(1<<N);++mask){\n        auto d=[&](int i){return (mask&1<<i)>>i;};\n        vector<pair<int,int>> v;\n        int cnt=1;\n        for (int i=0;i+1<N;++i){\n            if (d(i)!=d(i+1)){\n                v.emplace_back(d(i),cnt);\n                cnt=1;\n            } else ++cnt;\n        }\n        v.emplace_back(d(N-1),cnt);\n        for (auto &p:v){\n            if (p.first==1&&p.second>=B){\n                p.first=0;\n            }\n        }\n        int now=0,ok=0;\n        for (auto p:v){\n            if (p.first==1) now=0;\n            else {\n                now+=p.second;\n                if (now>=A) ok=1;\n            }\n        }\n        // debug(mask,ok,v);\n        res+=ok;\n    }\n    return res;\n}\n\nconst int MAX_N=5010;\n\nmint dp[MAX_N][MAX_N][2];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,A,B; cin >> N >> A >> B;\n    if (A<B) swap(A,B);\n    if (B==1){\n        cout << pow((mint)2,N) << '\\n';\n        return 0;\n    }\n    dp[0][0][0]=1;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<A;++j){\n            dp[i+1][j+1][0]+=dp[i][j][0];\n            if (j>=B) dp[i+1][j+1][0]+=dp[i][j][1];\n            else dp[i+1][1][0]+=dp[i][j][1];\n            if (j+1!=B) dp[i+1][j+1][1]+=dp[i][j][1];\n            if (i+B<=N) dp[i+B][min(A,j+B)][1]+=dp[i][j][0];\n            dp[i+1][1][1]+=dp[i][j][0];\n        }\n        /*\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][0] << (j==A?'\\n':' ');\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][1] << (j==A?'\\n':' ');\n        cerr << '\\n';\n        */\n    }\n    mint ans=0,po=1;\n    for (int i=N;i>=0;--i){\n        ans+=(dp[i][A][0]+dp[i][A][1])*po;\n        po*=2;\n    }\n    cout << ans << '\\n';\n    // cout << brute(N,A,B) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nll mod_pow(ll x, ll n, ll mod){ // x ^ n % mod\n    ll res = 1;\n    while(n > 0){\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    ll MOD = 1e9+7;\n    ll n, a, b;\n    cin >> n >> a >> b;\n    if(a > b)swap(a,b);\n\n    if(a == 1){\n        cout << mod_pow(2, n, MOD) << endl;\n        return 0;\n    }\n\n    ll dp[n*2+10][n+1][2];\n    rep(i,n+1)rep(j,n+1)rep(k,2)dp[i][j][k] = 0;\n\n\n    srep(i,1,b+1){\n        if(i == 1){\n            dp[i][i][0] = 1;\n            dp[i+a-1][i][1] = 1;\n        }else{\n            srep(j,1,i){\n                dp[i+a-1][j][1] = dp[i-1+a-1][j][1];\n            }\n            dp[i+a-1][i][1] = dp[i-1][i-1][0];\n            dp[i][i][0] = dp[i-1][i-1][0];\n            rep(j,n+1)dp[i][i][0] = (dp[i][i][0] + dp[i-1][j][1]) % MOD;\n        }\n    }\n\n    ll sum[n+1] = {};\n    rep(i,n+1){\n        rep(j,n+1){\n            sum[i] = (sum[i] + dp[i][j][1]) % MOD;\n        }\n    }\n\n    ll ans = 0;\n\n    ans = dp[b][b][0] * mod_pow(2,n-b,MOD) % MOD;\n\n    srep(i,b,n+1){\n        ans += sum[i] * mod_pow(2,n-i,MOD) % MOD;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 5000;\nconst int MOD = 1000000007;\nvoid inc(int& a, int b) { if ((a += b) >= MOD) a -= MOD; }\nvoid dec(int& a, int b) { if ((a -= b) < 0) a += MOD; }\n\nint n, alen, blen;\n\n// dp[i][j][k] = number of ways to select a block of i characters ending with less than alen zeroes (or empty) with no valid subsequence, followed by a block of length j starting with 1 (or at beginning of string) in which all subsequences of zeroes have length at least alen, ending with k\nint dp[MAXN + 1][MAXN + 1][2]; \nint dpsum[MAXN + 1][MAXN + 2];\nint p2[MAXN + 1];\n\nint solve() {\n\tp2[0] = 1; FORE(i, 1, n) p2[i] = (ll)p2[i - 1] * 2 % MOD;\n\tif (alen > blen) swap(alen, blen);\n\tREPE(i, n) dpsum[i][0] = dpsum[i][1] = 0;\n\tREPE(i, n) FORE(j, 1, blen) {\n\t\tdp[i][j][0] = dp[i][j][1] = 0;\n\t\tif (alen <= j - 1) {\n\t\t\tint lo = 1, hi = j - alen;\n\t\t\t//FORE(k, alen, j - 1) inc(dp[i][j][0], dp[i][j - k][1]);\n\t\t\tinc(dp[i][j][0], dpsum[i][hi + 1]);\n\t\t\tdec(dp[i][j][0], dpsum[i][lo]);\n\t\t}\n\t\tif (i == 0 && j >= alen) inc(dp[i][j][0], 1);\n\t\tif (j == 1) {\n\t\t\tif (i < alen) inc(dp[i][j][1], 1);\n\t\t\t//FORE(k, 1, min(i, alen - 1)) FORE(l, 1, min(blen - 1, i - k)) inc(dp[i][j][1], dp[i - k - l][l][1]);\n\t\t\t//FORE(z, 2, i) FORE(k, max(1, z - blen + 1), min(min(i, alen - 1), z - 1)) { int l = z - k; inc(dp[i][j][1], dp[i - z][l][1]); }\n\t\t\tFORE(z, 2, i) {\n\t\t\t\tint lo = z - min(min(i, alen - 1), z - 1), hi = z - max(1, z - blen + 1); lo = min(lo, blen);  hi = min(hi, blen);\n\t\t\t\t//FORE(l, lo, hi) inc(dp[i][j][1], dp[i - z][l][1]);\n\t\t\t\t//{ int chk = 0; FORE(l, 0, hi) inc(chk, dp[i - z][l][1]); if (!(chk == dpsum[i - z][hi + 1])) { printf(\"err i-z=%d hi+1=%d: %d vs %d\\n\", i - z, hi + 1, chk, dpsum[i - z][hi + 1]); exit(0); } }\n\t\t\t\t//{ int chk = 0; FORE(l, 0, lo - 1) inc(chk, dp[i - z][l][1]); if (!(chk == dpsum[i - z][lo])) { printf(\"err i-z=%d lo=%d: %d vs %d [i=%d]\\n\", i - z, lo, chk, dpsum[i - z][lo],i); exit(0); } }\n\t\t\t\tinc(dp[i][j][1], dpsum[i - z][hi + 1]);\n\t\t\t\tdec(dp[i][j][1], dpsum[i - z][lo]);\n\t\t\t}\n\t\t} else {\n\t\t\tinc(dp[i][j][1], dp[i][j - 1][0]);\n\t\t\tinc(dp[i][j][1], dp[i][j - 1][1]);\n\t\t}\n\t\t//printf(\"dp[%d][%d]: %d / %d\\n\", i, j, dp[i][j][0], dp[i][j][1]);\n\t\tdpsum[i][j + 1] = dpsum[i][j]; inc(dpsum[i][j + 1], dp[i][j][1]);\n\t\t//if (i == 1) printf(\"dpsum[%d][%d]=%d dp[%d][%d][1]=%d -> dpsum[%d][%d]=%d\\n\", i, j, dpsum[i][j], i, j, dp[i][j][1], i, j + 1, dpsum[i][j + 1]);\n\t}\n\tint ret = 0;\n\tREPE(i, n - blen) {\n\t\tint cur = 0; REP(k, 2) inc(cur, dp[i][blen][k]);\n\t\t//printf(\"%d: (%d+%d)*%d\\n\", i, dp[i][blen][0], dp[i][blen][1], p2[n - i - blen]);\n\t\tcur = (ll)cur * p2[n - i - blen] % MOD;\n\t\tinc(ret, cur);\n\t}\n\tREPE(i, n - blen) FORE(j, 1, blen - 1) if (i + j + alen <= n && j + alen > blen) {\n\t\tint cur = dp[i][j][1];\n\t\t//printf(\"%d %d: %d * %d\\n\", i, j, cur, p2[n - i - j - alen]);\n\t\tcur = (ll)cur * p2[n - i - j - alen] % MOD;\n\t\tinc(ret, cur);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\", &n, &alen, &blen);\n\tprintf(\"%d\\n\", solve());\n}\n\nint solvestupid() {\n\tint ret = 0;\n\tassert(alen <= blen);\n\tREP(mask, 1 << n) {\n\t\tbool ok = false;\n\t\tREPE(offset, n - blen) {\n\t\t\tint nzero = 0;\n\t\t\tREP(i, n - offset) {\n\t\t\t\tint cur = (mask >> (offset + i)) & 1;\n\t\t\t\tif (cur == 0) ++nzero;\n\t\t\t\tif (cur == 1) { if (nzero != 0 && nzero < alen) break; nzero = 0; }\n\t\t\t\tif ((nzero == 0 || nzero >= alen) && i + 1 >= blen) ok = true;\n\t\t\t}\n\t\t}\n\t\tif (ok) ++ret;\n\t}\n\treturn ret;\n}\n\nvoid stress() {\n\tfor (n = 1; n <= 15; ++n) for (alen = 1; alen <= n; ++alen) for (blen = alen; blen <= n; ++blen) {\n\t\tint have = solve();\n\t\tint want = solvestupid();\n\t\tif (have == want) { printf(\".\"); continue; }\n\t\tprintf(\"err %d %d %d: have=%d want=%d\\n\", n, alen, blen, have, want);\n\t}\n}\n\nint main() {\n\t//stress();\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pii;\nconst int mn=5e3+10;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nconst ll mod=1e9+7;\nll dp[mn][mn],p1[mn][mn],p2[mn][mn];\nint main(){\n    cin.tie(0);\n    cin.sync_with_stdio(0);\n    int n,a[2];\n    cin>>n>>a[0]>>a[1];\n    if(a[0]>a[1])swap(a[0],a[1]);\n    dp[0][0]=p1[0][0]=p2[0][0]=1;\n    ll ans=1;\n    for(int i=1;i<=n;i++){\n        ans*=2,ans%=mod;\n        for(int j=0;j<=min(i,a[1]-1);j++){\n            if(j==1){\n                for(int k=0;k<=i;k++){\n                    dp[i][j]+=(i>=2?p1[i-2][k]:0)-(i>=a[0]+1?p1[i-a[0]-1][k]:0);\n                }\n                dp[i][j]%=mod;\n            }\n            dp[i][j]+=(i>=a[0]+1?p2[i-a[0]-1][i-j]:0);\n            dp[i][j]+=j?dp[i-1][j-1]:0;\n            dp[i][j]%=mod;\n            p1[i][j]=(p1[i-1][j]+dp[i][j])%mod;\n            p2[i][i-j]=(p2[i-1][i-j]+dp[i][j])%mod;\n        }\n    }\n    for(int i=0;i<=n;i++){\n        int na=n-i;\n        if(na<a[0]){\n            for(int j=0;j<=i;j++)ans-=dp[i][j],ans%=mod;\n        }\n        else{\n            for(int j=0;j+na<a[1];j++)ans-=dp[i][j],ans%=mod;\n        }\n    }\n    if(ans<0)ans+=mod;\n    printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 6000\n\nconst LL mod=1000000007;\nLL n,a,b,ans,f[N],g[N],pre[N];\n\nvoid upd(LL &x,LL y){\n\tx=(x+y)%mod;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tif (a<b) swap(a,b);\n\tg[0]=1;\n\tfor (LL i=1;i<=n;++i){\n\t\tg[i]=g[i-1];\n\t\tif (i>=b){\n\t\t\t++g[i];\n\t\t\tfor (LL j=b;i-j-1>=0;++j){\n\t\t\t\tupd(g[i],g[i-j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tans=1; for (LL i=1;i<=n;++i) ans=ans*2%mod;\n\tpre[0]=g[0]; for (LL i=1;i<=n;++i) pre[i]=(pre[i-1]+g[i])%mod;\n\tfor (LL i=1;i<=n;++i){\n\t\tfor (LL j=1;j<i-1;++j){\n\t\t\tLL l=max(i-j-2-b+1,0LL),r=min(a-2,i-j-2)-1;\n\t\t\tif (l<=r){\n\t\t\t\tupd(f[i],f[j]*(pre[r]-(l?pre[l-1]:0)));\n\t\t\t}\n\t\t\tif (a>1&&i-j-1<b){\n\t\t\t\tupd(f[i],f[j]);\n\t\t\t}\n\t\t}\n\t\tLL l=max(i-1-b+1,0LL),r=min(a-1,i-1)-1;\n\t\tif (l<=r) upd(f[i],pre[r]-(l?pre[l-1]:0));\n\t\tif (i<b) upd(f[i],1);\n\t\tif (i<n&&n-i<a) upd(ans,-f[i]*g[n-i-1]);\n\t\tif (i==n) upd(ans,-f[i]);\n\t}\n\tupd(ans,mod);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\n        Code by a weak man who named CYJian, and he hopes the code can get more points.\n\n        Algorithm:\n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s \"in\", \"r\", stdin), freopen(s \"out\", \"w\", stdout)\n\ntemplate <typename T> inline void read(T &x) {\n    char ch, t = 0;\n    x = 0;\n    while (!isdigit(ch = ge))\n        t |= ch == '-';\n    while (isdigit(ch))\n        x = x * 10 + (ch ^ 48), ch = ge;\n    x = t ? -x : x;\n}\ninline int read_int() {\n    int x;\n    return read(x), x;\n}\ninline ll read_ll() {\n    ll x;\n    return read(x), x;\n}\n\ntemplate <typename T> inline void chkmin(T &a, T b) { a = a < b ? a : b; }\ntemplate <typename T> inline void chkmax(T &a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int mod = 1e9 + 7;\n\ninline int Mod(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\n\nint f[5010];\nint g[5010];\nint P[5010];\nint M[5010];\nint F[2][5010];\n\nint main() {\n#ifdef LOCAL\n    FILE(\"\");\n#endif\n\n    int n = ri, A = ri, B = ri, res = 1;\n    for (int i = 1; i <= n; i++)\n        res = Mod(res << 1);\n    if (A == 1 || B == 1)\n        return printf(\"%d\\n\", res), 0;\n    if (A > B)\n        swap(A, B);\n    f[0] = 1, g[0] = 1;\n    for (int i = A; i < B; i++) {\n        f[i] = Mod(f[i - 1] + g[i - 1]);\n        for (int j = A; j <= i; j++)\n            Add(g[i], f[i - j]);\n    }\n\n    for (int i = 1; i < B; i++)\n        for (int j = 1; j <= i; j++)\n            P[i] = (P[i] + 1LL * g[i - j] * (i == j ? 1 : j)) % mod;\n    for (int i = 1; i < B; i++)\n        for (int j = 1; j <= i; j++)\n            M[i] = (M[i] + 1LL * g[i - j] * (i == j ? 1 : j - 1)) % mod;\n\n    F[0][0] = F[1][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j < B; j++) {\n            if (i == j || i == n) {\n                F[1][i] = (F[1][i] + 1LL * F[0][i - j] * P[j]) % mod;\n                if (i == j)\n                    break;\n            } else\n                F[1][i] = (F[1][i] + 1LL * F[0][i - j] * M[j]) % mod;\n        }\n        for (int j = 1; j < A; j++) {\n            Add(F[0][i], F[1][i - j]);\n            if (i == j)\n                break;\n        }\n    }\n\n    cout << Mod(res + mod - Mod(F[0][n] + F[1][n])) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, a, b;\nllint dp[5005][5005][2];\nllint dp2[5005][2];\nllint num[5005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> a >> b;\n\tif(a > b) swap(a, b);\n\t\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tfor(int l = 0; l < 2; l++){\n\t\t\t\t\tllint nj = j+1;\n\t\t\t\t\tif(k != l) nj = 1;\n\t\t\t\t\tif(k == 1 && l == 0 && j < a) continue;\n\t\t\t\t\tif(k == 0 && nj >= b) continue;\n\t\t\t\t\tdp[i+1][nj][l] += dp[i][j][k], dp[i+1][nj][l] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tif(k == 1 && j < a) continue;\n\t\t\t\tnum[i] += dp[i][j][k], num[i] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp2[0][0] = dp2[0][1] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tif(j == 1){\n\t\t\t\tfor(int k = 1; k < a; k++){\n\t\t\t\t\tif(i+k > n) break;\n\t\t\t\t\tdp2[i+k][1-j] += dp2[i][j];\n\t\t\t\t\tdp2[i+k][1-j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int k = 1; k < b; k++){\n\t\t\t\t\tif(i+k > n) break;\n\t\t\t\t\tllint len = k;\n\t\t\t\t\tif(i+k < n) len--;\n\t\t\t\t\tif(i > 0) len--;\n\t\t\t\t\tlen = max(len, 0LL);\n\t\t\t\t\t\n\t\t\t\t\tdp2[i+k][1-j] += dp2[i][j] * num[len] % mod;\n\t\t\t\t\tdp2[i+k][1-j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tllint ans = dp2[n][0] + dp2[n][1]; ans %= mod;\n\tans = modpow(2, n) - ans + mod, ans %= mod;\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n  ll dp[5020][5020];\n    rep(i,0,n+10)rep(j,0,n+10)dp[i][j]=0;\n    dp[0][0]=1;\n    ll sum1[n+10];\n    rep(i,0,n+10)sum1[i]=0;\n    sum1[0]=1;\n    ll sum2[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)sum2[i][j]=0;\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=b-1LL;i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nll dp[5050][2];\n\nlong long modpow(long long a, long long b){ \n  long long r = 1LL;\n  while(b){\n    if(b & 1LL)r *= a;\n    if(r >= MOD)r %= MOD;\n    a *= a;\n    if(a >= MOD)a %= MOD;\n    b >>= 1LL;\n  }\n  return r%MOD;\n}\n\nint main(){\n  ll n,a,b;\n  cin>>n>>a>>b;\n  ll all = pow(2,n);\n  if(a==1||b==1){\n    cout << all%MOD << endl;\n    return 0;\n  }\n  clr(dp,0);\n  dp[0][0]=1;\n  dp[0][1]=1;\n  rep(i,1,n){\n    rep(j,0,a-1){\n      if(i+j<5050){\n        dp[i+j][0] += dp[i-1][1];\n        dp[i+j][0] %= MOD;\n      }\n    }\n    rep(j,0,b-1){\n      if(i+j<5050){\n        dp[i+j][1] += dp[i-1][0];\n        dp[i+j][1] %= MOD;\n      }\n    }\n  }\n  ll ans1 = 0;\n  rep(i,0,n){\n    ll d = n-i;\n    if(d<a){\n      ans1 += dp[i][1];\n      ans1 %= MOD;\n    }\n    if(d<b){\n      ans1 += dp[i][0];\n      ans1 %= MOD;\n    }    \n  }\n  cout << dp[2][1] << endl;\n  cout << (all+MOD-ans1)%MOD << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#define int long long\n#define pb push_back\n#define x first\n#define y second\n#define mk(a,b) make_pair(a,b)\n#define rr return 0\n#define sqr(a) ((a)*(a))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate<class value, class cmp = less<value> >\nusing ordered_set = tree<value, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<class value, class cmp = less_equal<value> >\nusing ordered_multiset = tree<value, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<class key, class value, class cmp = less<key> >\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n\n/// find_by_order()\n/// order_of_key()\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int randll(int l = INT_MIN, int r = INT_MAX) {\n    return uniform_int_distribution<int>(l, r)(rng);\n}\nconst int INF = 1e9, MOD = 1e9 + 7; /// think\nconst ll LINF = 1e18;\n\n\nconst int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\ninline bool inside (int x, int y, int n, int m) {\n    return 0 <= x && 0 <= y && x < n && y < m;\n}\n\ntemplate<class T> bool umin (T &a, T b) {return a > b ? (a = b, true) : false; }\ntemplate<class T> bool umax (T &a, T b) {return a < b ? (a = b, true) : false; }\n\ninline int mul (int a, int b, int m = MOD) {\n    return ((ll)a * b) % m;\n}\n\ninline int binpow (int a, int n, int m = MOD) {\n    int ans = 1;\n    for (; n; n >>= 1) {\n        if (n & 1) ans = mul(ans, a, m);\n        a = mul(a, a, m);\n    }\n    return ans;\n}\n\ninline void add (int &a, int x, int m = MOD) {\n    a += x;\n    if (a >= m) a -= m;\n    if (a < 0) a += m;\n}\n\ninline int sum (int a, int b, int m = MOD) {\n    a += b;\n    if (a >= m) a -= m;\n    if (a < 0) a += m;\n    return a;\n}\n\ninline int inv (int x, int m = MOD) {\n    return binpow(x, m - 2, m); /// only if m is prime\n}\n\nint n, a, b;\nconst int N = 5001;\nint dp[N][N][2][2] = {};\n\nmain()\n{\n    ios::sync_with_stdio(0);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n    dp[0][0][0][1] = 1;\n    dp[0][0][0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            for (int k = 1; i + k <= n; k++) {\n                add(dp[i + k][j + k][1][1], dp[i][j][1][0]);\n                if (j < b) {\n                    add(dp[i + k][j + k][j + k >= b][1], dp[i][j][0][0]);\n                }\n                if (k >= a) {\n                    if (j < b) {\n                        add(dp[i + k][j + k][j + k >= b][0], dp[i][j][0][1]);\n                    }\n                    add(dp[i + k][j + k][1][0], dp[i][j][1][1]);\n                }\n                else {\n                    add(dp[i + k][0][1][0], dp[i][j][1][1]);\n                    add(dp[i + k][0][0][0], dp[i][j][0][1]);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int j = 0; j <= n; j++) {\n        add(ans, dp[n][j][1][0]);\n        add(ans, dp[n][j][1][1]);\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  static constexpr unsigned mod = M;\n  unsigned v;\n  modular(long long x = 0) : v((x %= mod) < 0 ? x + mod : x) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m b) { if ((int)(v += b.v - mod) < 0) v += mod; return *this; }\n  m& operator-=(m b) { if ((int)(v -= b.v) < 0) v += mod; return *this; }\n  m& operator*=(m b) { v = (uint64_t)v * b.v % mod; return *this; }\n  m& operator/=(m b) { return *this *= power(b, mod - 2); }\n  friend m operator+(m a, m b) { return a += b; }\n  friend m operator-(m a, m b) { return a -= b; }\n  friend m operator*(m a, m b) { return a *= b; }\n  friend m operator/(m a, m b) { return a /= b; }\n  friend bool operator==(m a, m b) { return a.v == b.v; }\n};\n\nusing mint = modular<power(10, 9) + 7>;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, a, b;\n  cin >> n >> a >> b;\n  if (a > b) {\n    swap(a, b);\n  }\n  vector f0(n + 1, vector<mint>(b));\n  vector f1(n + 1, vector<mint>(b));\n  vector<mint> g(n + 1);\n  f1[n][0] = 1;\n  g[n] = 1;\n  vector cum(n + 1, vector<mint>(n + 1));\n  for (int i = n; i--; ) {\n    for (int x = a; x <= min(b - 1, n - i); ++x) {\n      f0[i][x] += cum[i + x][i + a] - cum[i + x][i + x];\n      f0[i][x] += x == n - i;\n    }\n    for (int x = 1; x <= min(b - 1, n - i); ++x) {\n      if (x == 1) {\n        f1[i][x] = g[i + 1];\n      } else {\n        f1[i][x] = f0[i + 1][x - 1] + f1[i + 1][x - 1];\n      }\n      f1[i][0] += f1[i][x];\n      cum[i + x][i] = f1[i][x] + cum[i + x][i + 1];\n    }\n    for (int j = 1; j <= min(a - 1, n - i); ++j) {\n      g[i] += f1[i + j][0];\n    }\n  }\n  mint res = f1[0][0] + g[0];\n  for (int x = 1; x < b; ++x) {\n    res += f0[0][x];\n  }\n  res = power<mint>(2, n) - res;\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n\n};\n\nint a,b,c,d,i,n,m,e,k,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[2][5010];\nlong long l[5010];\nlong long s[5010];\nlong long x,y,z,mod=1000000007,hf=(mod+1)/2;\n\n//string r,r1;\nchar r[361];\nvector<int> v[200101];\nP u[1];\nqueue<int> q;\n//set<int> s[2];\n//stack<int> s;\nmap<int,int> p;\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//rng()\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nlong long g(int n)\n{\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(s[n]>=0) return s[n];\n  long long k=g(n-1);\n  for(int t=b+1;t<=n;t++)\n    k=(k+g(n-t))%mod;\n  return s[n]=k;\n}\n\nlong long f(int i,int n)\n{\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(o[i][n]>=0) return o[i][n];\n  long long k=0;\n  if(i)\n  {\n    for(int t=1;t<b;t++)\n      k=(k+f(0,n-t))%mod;\n  }\n  else\n  {\n    //k=f(1,n-1);\n    for(int t=1;t<c;t++)\n    {\n      int e=1;\n      if(n==a) e--;\n      if(n-t==0) e--;\n      k=(k+f(1,n-t)*g(t-e)%mod)%mod;\n    }\n    \n  }\n  return o[i][n]=k;\n}\n\nint main()\n{\n  memset(s,-1,sizeof(s));\n  memset(o,-1,sizeof(o));\n  l[1]=l[2]=1;\n  scanf(\"%d %d %d\",&a,&b,&c);\n  if(b>c) swap(b,c);\n  /*for(int t=3;t<c;t++)\n  {\n    l[t]=g(t-1);\n    printf(\"%lld\\n\",l[t]);\n  }*/\n  x=1;\n  for(int t=1;t<=a;t++)\n    x*=2,x%=mod;\n  printf(\"%lld\",(x-f(0,a)-f(1,a)+mod*2)%mod);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod = 1000000007;\nll f[5010][2] = {},g[5010][2] = {},dp[5010][2] = {};\nint main(){\n    int i,j,n,a,b;\n    cin >> n >> a >> b;\n    if(a<b) swap(a,b);\n    for(i=0;i<b;i++) f[i][0] = 1;\n    for(i=b;i<=n;i++){\n        f[i][0] += (f[i - 1][0] + f[i - 1][1]);\n        for(j=i - b;j>=0;j--){\n            (f[i][1] += f[j][0]) %= mod;\n        }\n    }\n    for(i=0;i<=n;i++){\n        for(j=max(a,i - b + 1);j<=i - 1;j++) (g[i][1] += f[j - 1][0]) %= mod;\n        for(j=max(1,i - b + 1);j<=min(i - 1,a - 1);j++) (g[i][0] += f[j - 1][0]) %= mod;\n    }\n    dp[0][0] = 1;\n    for(i=1;i<=n;i++){\n        for(j=i - 1;j>=1;j--){\n            (dp[i][1] += (g[i - j][1]*dp[j][0] + (g[i - j][1] + g[i - j][0])*dp[j][1])%mod) %= mod;\n            (dp[i][0] += (g[i - j][0]*dp[j][0])%mod) %= mod;\n        }\n        for(j=1;j<b;j++){\n            if(j<=i && i - j>=a) (dp[i][1] += f[i - j][0]) %= mod;\n            if(j<=i && i - j<a) (dp[i][0] += f[i - j][0]) %= mod;\n        }\n    }\n    ll ans = 0;\n    (ans += dp[n][1] + f[n][0] + f[n][1]) %= mod;\n    for(i=1;i<n;i++){\n        (ans += (f[n - i - 1][0] + f[n - i - 1][1])*dp[i][1]%mod) %= mod;\n        if(n - i>=a) (ans += (f[n - i - 1][0] + f[n - i - 1][1])*dp[i][0]%mod) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 5005;\n\n// Mod int\nconst int mod = 1000000007;\n// const int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\n//\n\nmint dp[MX][MX][2];\nmint d1[MX];\nmint d0[MX][MX];\n\nint main() {\n  int n,a,b;\n  scanf(\"%d%d%d\",&n,&a,&b);\n  if (a > b) swap(a,b);\n  dp[0][0][0] = 1;\n  dp[0][0][1] = 1;\n\n  rep(i,n+1) {\n    rep(j,n+1) {\n      // rep(l,i) {\n      //   // if (i-a < l) dp[i][i][1] += dp[l][j][0];\n      //   // else dp[i][j][1] += dp[l][j][0];\n      //   // dp[i][j][0] += dp[l][j][1];\n      // }\n\n      dp[i][i][1] += d0[i][j];\n      if (i-a+1 >= 0) dp[i][i][1] -= d0[i-a+1][j];\n      if (i-a+1 >= 0) dp[i][j][1] += d0[i-a+1][j];\n      dp[i][j][0] += d1[j];\n    }\n    rep(j,n+1) if (i-j >= b) dp[i][j][0] = dp[i][j][1] = 0;\n    rep(j,n+1) d1[j] += dp[i][j][1];\n    rep(j,n+1) d0[i+1][j] += d0[i][j]+dp[i][j][0];\n  }\n\n\n  mint ans = 1;\n  rep(i,n) ans *= 2;\n  rep(i,n+1)rep(j,2) ans -= dp[n][i][j];\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 5010\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 1000000007\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nint n, a, b;\nll dp[maxn][maxn]; // \nll pw[maxn];\nll s[maxn][maxn]; // 第二维固定的和 \nll tt[maxn];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> a >> b;\n\tif (a > b) swap(a, b);\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * 2 % mod;\n\tfor (int i = n + 1; i >= 0; i--) {\n\t\t//当前1的位置\n\t\tfor (int j = 1; j <= i + 1; j++) {\n\t\t\tint nl = i - j + 1;\n\t\t\tif (i == n + 1) nl--;\n\t\t\tif (nl >= b) dp[i][j] = pw[max(0, n - i)];\n\t\t\telse {\n\t\t\t\tdp[i][j] = (s[i + a + 1][j] + dp[i + 1][j]);\n\t\t\t\tdp[i][j] += tt[i + 2] - tt[i + a + 1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t\tif (dp[i][j] < 0) dp[i][j] += mod;\n\t\t\t}\n\t\t\ts[i][j] = (s[i + 1][j] + dp[i][j]) % mod;\n\t\t\tif (i == j) \n\t\t\t\ttt[i] = (tt[i + 1] + dp[i][i]) % mod; \n\t\t}\n\t} \n\tcout << dp[0][1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=5005,P=1e9+7,oo=P;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b){ a=add(a,b); }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n,a,b,f[N][2],g[N][2],g2[N][2],ans;\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\",\"r\",stdin); \n#endif\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a>b)swap(a,b); \n\tg[0][0]=1;\n\tlop(i,0,b-1){\n\t\t//add1\n\t\trep(j,1,b-1-i)upd(g[i+j][1],g[i][0]);\n\t\t//add0\n\t\trep(j,a,b-1-i)upd(g[i+j][0],g[i][1]); \n\t}\n\tg2[0][1]=1;\n\tlop(i,0,b-1){\n\t\t//add1\n\t\trep(j,1,b-1-i)upd(g2[i+j][1],g2[i][0]);\n\t\t//add0\n\t\trep(j,a,b-1-i)upd(g2[i+j][0],g2[i][1]); \n\t}\n\tf[0][0]=1,f[0][1]=1;\n\trep(j,a,n-1)f[j][1]=g2[j][1];\n\tf[n][1]=g2[n][1]; \n\tf[n][0]=g2[n][0];\n\tlop(i,0,n){\n\t\t//add0\n\t\tlop(j,1,min(a,n-i+1)){\n\t\t\tupd(f[i+j][0],f[i][1]);\n\t\t}\n\t\tlop(j,1,min(b,n-i+1)){\n\t\t\tupd(f[i+j][1],mul(g[j][1],f[i][0])); \n\t\t}\n\t\tupd(f[n][0],mul(g[n-i][0],f[i][0])); \n\t}\n\tans=1; \n\trep(i,1,n)ans=mul(ans,2); \n\tans=sub(ans,add(f[n][1],f[n][0])); \n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,A,B;\nconst ll mo=1000000007;\n\nll dp[5050][5050][2];\nll add[15050];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A>>B;\n\tif(A>B) swap(A,B);\n\t\n\tdp[0][0][0]=1;\n\tFOR(i,N) {\n\t\tif(i) {\n\t\t\t(add[i]+=add[i-1])%=mo;\n\t\t\t(dp[i][1][0]+=add[i])%=mo;\n\t\t}\n\t\tFOR(j,N+1) {\n\t\t\tif(j>=B) {\n\t\t\t\t(dp[i+1][B][0]+=dp[i][j][0]*2)%=mo;\n\t\t\t\t(dp[i+1][B][0]+=dp[i][j][1]*2)%=mo;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(dp[i+1][j+1][0]+=dp[i][j][1])%=mo;\n\t\t\t\t(dp[i+1][j+1][1]+=dp[i][j][1])%=mo;\n\t\t\t\t// B\n\t\t\t\t(dp[i+1][j+1][0]+=dp[i][j][0])%=mo;\n\t\t\t\t// A\n\t\t\t\tif(dp[i][j][0]) {\n\t\t\t\t\t(add[i+2]+=dp[i][j][0])%=mo;\n\t\t\t\t\t(add[i+A+1]+=mo-dp[i][j][0])%=mo;\n\t\t\t\t\t/*\n\t\t\t\t\tfor(x=1;i+x+1<=N&&x<A;x++) if(dp[i][j][0]) {\n\t\t\t\t\t\t(dp[i+x+1][1][0]+=dp[i][j][0])%=mo;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tif(i+A<=N) (dp[i+A][min(B,j+A)][1]+=dp[i][j][0])%=mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<(dp[N][B][0]+dp[N][B][1])%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acosl(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define MAXN 205\n//#define N 262144\n#define ULL unsigned long long\n#define ll long long\nint dp[5005][5005][3];\nint mod=1e9+7;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint main(){\n    int n,a,b;\n    scanf(\"%d %d %d\",&n,&a,&b);\n    if(a>b)swap(a,b);\n    if(a==1){\n        printf(\"%lld\\n\",f_pow(2,n));\n        return 0;\n    }\n    dp[1][1][1]=1;\n    dp[1][1][0]=1;\n    dp[0][0][1]=1;\n   // dp2[0][0]=1;\n   // dp2[1][1]=2;\n    LL ans=0;\n    for(int i = 2;i<=n;i++){\n        for(int j=2;j<=i;j++){\n           // if(j<=b){\n                dp[i][j][1]+=(dp[i-1][j-1][1]+dp[i-1][j-1][2])%mod;\n                dp[i][j][1]%=mod;\n                dp[i][j][2]+=dp[i-1][j-1][2];\n                dp[i][j][2]%=mod;\n                if(j>=a){\n                    dp[i][j][2]+=dp[i-a][j-a][1];\n                    dp[i][j][2]%=mod;\n                }\n           // }\n            if(j<a){\n                dp[i][j][0]+=dp[i-1][j-1][0];\n                dp[i][j][0]%=mod;\n            }\n        }\n        for(int j=1;j<a;j++){\n            dp[i][1][1]+=dp[i-1][j][0];\n            dp[i][1][1]%=mod;\n        }\n        for(int j=1;j<b;j++){\n            dp[i][1][0]+=dp[i-1][j][1];\n            dp[i][1][0]%=mod;\n        }\n      /*  for(int j = 1;j<=i;j++){\n            printf(\"%d %d %d %d %d\\n\",i,j,dp[i][j][0],dp[i][j][1],dp[i][j][2]);\n        }*/\n        ans+=(dp[i][b][1]+dp[i][b][2])*1ll*f_pow(2,n-i)%mod;\n        if(i>=b)\n        for(int j = b-a+1;j<b;j++){\n            ans+=(dp[i-a][j][1])*1ll*f_pow(2,n-i)%mod;\n        }\n        ans%=mod;\n    }\n    printf(\"%d\\n\",ans);\n}\n/*\n1000000000000000000\n1000000000000000000 1 1 1 1000000000\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  int n = (*this).size();\n\n  P operator-() const {\n    P res(n);\n    rep(i, n) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, n) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, n) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) { // dense\n    drep(i, n) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += (*this)[i-j] * q[j];\n    }\n    return *this;\n  }\n  template<typename T2>\n  P &operator*=(map<int, T2> q) { // sparse\n    drep(i, n) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b] : q) if (j > 0 && j <= i) (*this)[i] += (*this)[i-j] * b;\n    }\n    return *this;\n  }\n  P &operator/=(const P q) { // dense\n    rep(i, n) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= (*this)[i-j] * q[j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  template<typename T2>\n  P &operator/=(map<int, T2> q) { // sparse\n    rep(i, n) {\n      for (auto &[j, b] : q) if (j > 0 && j <= i) (*this)[i] -= (*this)[i-j] * b;\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  template<typename T2> P operator+(const T2 q) const { return P(*this) += q; }\n  template<typename T2> P operator-(const T2 q) const { return P(*this) -= q; }\n  template<typename T2> P operator*(const T2 q) const { return P(*this) *= q; }\n  template<typename T2> P operator/(const T2 q) const { return P(*this) /= q; }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  map<int, mint> d({{0, 1}, {1, -1}});\n  p[a] = 1;\n  p /= d;\n  q[1] = 1;\n  q /= d;\n  f[1] = 1;\n  f[a] -= 1;\n  f /= d;\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+1) g0[i] = 0;\n  rep2(i, b, n+1) g1[i] = 0;\n  rep2(i, b, n+1) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\ntypedef ModInt<1000000007> mint;\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\n\nint main() {\n\t// TODO : a == b\n\tint n = ri();\n\t\n\tint a = ri(), b = ri();\n\tif (a > b) std::swap(a, b);\n\t\n\tmint dp[n + 1][n + 1][2]; // pos, len, flag\n\tdp[0][0][1] = 1;\n\t\n\tmint diff[n + 1];\n\tmint cur = 0;\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tcur += diff[i];\n\t\tdp[i][1][1] += cur;\n\t\t\n\t\tmint beki2 = mint(2) ^ (n - i);\n\t\tfor (int j = b; j <= n; j++) res += beki2 * (dp[i][j][0] + dp[i][j][1]);\n\t\tif (i == n) break;\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tdp[i + 1][j + 1][0] += dp[i][j][0];\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][0];\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][1];\n\t\t\tif (i + a <= n) dp[i + a][j + a][0] += dp[i][j][1];\n\t\t\t// for (int k = i + 2; k <= n && k <= i + a; k++) dp[k][1][1] += dp[i][j][1];\n\t\t\tif (i + 2 <= n) {\n\t\t\t\tdiff[i + 2] += dp[i][j][1];\n\t\t\t\tif (i + a + 1 <= n) diff[i + a + 1] -= dp[i][j][1];\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k < 2; k++) if (dp[i][j][k] != 0) {\n\t\tstd::cerr << \"pos:\" << i << \" len:\" << j << \" next:\" << k << \" : \" << dp[i][j][k] << std::endl;\n\t}*/\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T> void print(set<T> &x){for(auto e:x)print(e),cout<<\" \";cout<<endl;}\ntemplate<class T> void print(multiset<T> &x){for(auto e:x)print(e),cout<<\" \";cout<<endl;}\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n-1)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n\nstruct Setup_io{ Setup_io(){ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);}}setup_io;\n#pragma endregion\n\n\n// _______ここから編集！_______________\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nostream& operator<<(ostream& os, mint a){\n    os << a.a ;\n    return os;\n}\n\nmint dp[5100][5100];\nmint dp2[5100][5100];\nmint rui[5100][5100];\nmint rui2[5100][5100];\nmint r[5100];\nmint r2[5100];\n\nsigned main(){\n    INT(n,a,b);\n    if(a<b) swap(a,b);\n    dp[0][0] = 1;\n    rep(i,n+2){\n        r[i+1] += r[i];\n        r2[i+1] += r2[i];\n        dp[i][1] += r[i];\n        dp2[i][1] += r2[i];\n        rep(j,n+2) rui[i+1][j+1] += rui[i][j];\n        rep(j,n+2) rui2[i+1][j+1] += rui2[i][j];\n        rep(j,n+2) dp[i][j] += rui[i][j];\n        rep(j,n+2) dp2[i][j] += rui2[i][j];\n        rep(j,n+2){\n            if(j>=a+(i==n+1)) dp[i][j] += dp2[i][j], dp2[i][j] = 0;\n            else{\n                // b未満をつける\n                r2[i+2] += dp2[i][j];\n                if(i+b < 5099)r2[i+b+1] -= dp2[i][j];\n                // b以上をつける\n                if(i+b<=5099)rui2[i+b+1][j+b+1] += dp2[i][j];\n            }\n            dp2[i+1][j+1] += dp2[i][j];\n        }\n        rep(j,n+2){\n            if(j<a){\n                // dp2[i+2 ~ i+b][1] に += dp[i][j]\n                r2[i+2] += dp[i][j];\n                if(i+b<=5099) r2[i+b+1] -=dp[i][j];\n            }\n            else {\n                // dp[i+1][0] ~ dp[i+b-1][0] に\n                rui[i+2][j+2] += dp[i][j];\n                if(i+b <= 5099) rui[i+b+1][j+b+1] -= dp[i][j];\n            }\n            // dp[i+b ~ ] に\n            if(i+b <= 5099) rui[i+b+1][j+b+1] += dp[i][j];\n            dp[i+1][j+1] += dp[i][j];\n        }\n    }\n    // rep(i,n+2){\n    //     rep(j,n+2) cout<<dp[i][j]<<\" \";cout<<endl;\n    // }\n    // rep(i,n+2){\n    //     rep(j,n+2)cout<<dp2[i][j]<<\" \";cout<<endl;\n    // }\n    mint ans = 0;\n    rep(i,n+2) ans += dp[n+1][i];\n    cout<<ans<<endl;\n}\n                    \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nll dp[5010][5010];\nll sum1[5010];\nll sum2[5010][5010];\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\n\nint f[10101][2];\nint g[10101][2];\nint dp[5050][2];\n\nint _2[5050];\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\t\n\tif(A > B)\n\t\tswap(A, B);\n\t\n\t_2[0] = 1;\n\tfor(int i = 1; i <= 5000; i++)\n\t\t_2[i] = _2[i - 1] * 2 % mod;\n\tf[0][0] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tf[i][0] += f[i - j][1];\n\t\t\tif(f[i][0] >= mod)\n\t\t\t\tf[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tf[i][1] += f[i-j][0];\n\t\t\t\tif(f[i][1] >= mod)\n\t\t\t\t\tf[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tg[0][1] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tg[i][0] += g[i - j][1];\n\t\t\tif(g[i][0] >= mod)\n\t\t\t\tg[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tg[i][1] += g[i - j][0];\n\t\t\t\tif(g[i][1] >= mod)\n\t\t\t\t\tg[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0] = dp[0][1] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tif(i < B)\n\t\t{\n\t\t\tdp[i][1] += g[i][1];\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < B; j++)\n\t\t{\n\t\t\tdp[i][1] += 1ll * f[j][1] * dp[i - j][0] % mod;\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < A; j++)\n\t\t{\n\t\t\tdp[i][0] += dp[i - j][1];\n\t\t\tif(dp[i][0] >= mod)\n\t\t\t\tdp[i][0] -= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= N; i++)\n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\tfor(int j = B; j < A + B; j++)\n\t\t\t{\n\t\t\t\tans += 1ll * dp[i][1] * (g[j][0] + g[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\t\tif(ans >= mod)\n\t\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j = B; j < A + B; j++)\n\t\tif(i + j <= N)\n\t\t{\n\t\t\tans += 1ll * dp[i][0] * (f[j][0] + f[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\tif(ans >= mod)\n\t\t\t\tans -= mod; \n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nlong long naive(int N, int A, int B)\n{\n    set<string> S;\n    S.insert(string(N, '0'));\n\n    while (true)\n    {\n        bool up = false;\n        for (string s: S)\n        {\n            for (int i=0; i<=N-A; i++)\n            {\n                for (int j=0; j+A<=N; j++)\n                {\n                    string t = s;\n                    for (int k=0; k<A; k++)\n                        t[j+k] = '0';\n                    if (S.count(t)==0)\n                    {\n                        up = true;\n                        S.insert(t);\n                    }\n                }\n            }\n            for (int i=0; i<=N-B; i++)\n            {\n                for (int j=0; j+B<=N; j++)\n                {\n                    string t = s;\n                    for (int k=0; k<B; k++)\n                        t[j+k] = '1';\n                    if (S.count(t)==0)\n                    {\n                        up = true;\n                        S.insert(t);\n                    }\n                }\n            }\n        }\n        if (!up)\n            break;\n    }\n    //for (string s: S)\n    //    cout<<s<<endl;\n    return S.size();\n}\n\nlong long solve(int N, int A, int B)\n{\n    long long M = 1000000007;\n\n    if (A<B)\n        swap(A, B);\n\n    if (B==1)\n    {\n        long long ans = 1;\n        for (int i=0; i<N; i++)\n            ans = ans*2%M;\n        return ans;\n    }\n\n    vector<long long> T1(B);\n    vector<long long> S1(N+1);\n    T1[0] = 1;\n    S1[0] = 1;\n    for (int i=0; i<N; i++)\n    {\n        vector<long long> P(B);\n        T1.swap(P);\n        for (int j=0; j<B; j++)\n        {\n            T1[0] += P[j];\n            T1[0] %= M;\n            if (j+1<B)\n            {\n                T1[j+1] += P[j];\n                T1[j+1] %= M;\n            }\n        }\n        for (int j=0; j<=B-2; j++)\n        {\n            S1[i+1] += T1[j];\n            S1[i+1] %= M;\n        }\n    }\n\n    vector<long long> T2(N+1);\n    vector<long long> S2(N+1);\n    T2[0] = 1;\n    S2[0] = 1;\n    for (int i=0; i<N; i++)\n    {\n        vector<long long> P(N+1);\n        T2.swap(P);\n        for (int j=0; j<=N; j++)\n        {\n            if (j>=B || j==0)\n            {\n                T2[0] += P[j];\n                T2[0] %= M;\n            }\n            if (j<N)\n            {\n                T2[j+1] += P[j];\n                T2[j+1] %= M;\n            }\n        }\n        for (int j=B; j<=N; j++)\n        {\n            S2[i+1] += T2[j]+T2[0];\n            S2[i+1] %= M;\n        }\n    }\n\n    long long ans = 0;\n    for (int l=A; l<=N; l++)\n    {\n        for (int a=0; a+l+4<=N; a++)\n        {\n            ans += S2[l]*S1[a]%M*S1[N-l-a-4]%M;\n            ans %= M;\n        }\n        if (l+2<=N)\n        {\n            ans += S2[l]*S1[N-l-2]*2%M;\n            ans %= M;\n        }\n        if (l==N)\n        {\n            ans += S2[l];\n            ans %= M;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int N, A, B;\n    cin>>N>>A>>B;\n    //cout<<naive(N, A, B)<<endl;\n    cout<<solve(N, A, B)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n#define int ll\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nint is_ok(int now) {\n    int cnts[10] = {};\n    while (now != 0) {\n        cnts[now % 10]++;\n        if (cnts[now % 10] == 2) return false;\n        now /= 10;\n    }\n    return true;\n}\nint is_Prime(int now) {\n    if (now == 1) return false;\n    for (int i = 2; i * i <= now; ++i) {\n        if (now % i == 0) return false;\n    }\n    return true;\n}\nclass EllysDifferentPrimes {\npublic:static int getClosest(int n) {\n    REP(q, 1e9) {\n        if (n - q > 0 and is_ok(n - q) == 1 and is_Prime(n - q) == 1) {\n            return n - q;\n        }\n        if (is_ok(n + q) == 1 and is_Prime(n + q) == 1) {\n            return n + q;\n        }\n    }\n    return -1;\n}\n};\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = ((this->data[i][0]) * (obj.data[0][q]));\n                for (int t = 1; t < obj.data.size(); ++t) {\n                    hoge += ((this->data[i][t]) * obj.data[t][q]);\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back(edge{ to, cap, cost, (int)graph[to].size(), false });\n        graph[to].emplace_back(edge{ from, 0, -cost, (int)graph[from].size() - 1, true });\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int)graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge& e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge& e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto& e : graph[i]) {\n                if (e.isrev) continue;\n                auto& rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\n\n#define int ll\nmodint<MAX_MOD> dp[10005];\nmodint<MAX_MOD> two[10000];\nvoid solve(){\n    two[0] = 1;\n    for (int q = 1; q < 10000; ++q) {\n        two[q] = two[q - 1] * 2;\n    }\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n\n    dp[0] = 1;\n    dp[1] = MAX_MOD - 1;\n    modint<MAX_MOD> ans = 0;\n    REP(i, n) {\n        dp[i + 1] += dp[i];\n        modint<MAX_MOD> geko[10005] = {};\n        geko[i] += dp[i];\n        geko[i + 1] -= dp[i];\n        for (int q = i; q <= n+1; ++q) {\n            geko[q + 1] += geko[q];\n            if (min(q,n) - max(i - 1LL, 0LL) >= b) {\n                ans += geko[q] * two[max(n - q, 0LL)];\n                continue;\n            }\n            if (q != n) {\n                //next -> white\n                geko[q + 1] += geko[q];\n                geko[q + 2] -= geko[q];\n            }\n            dp[q + 1 + 1] += geko[q];\n            dp[q + a + 1] -= geko[q];\n            /*\n            for (int red = 1; red < a; ++red) {\n                dp[q + red + 1] += geko[q];\n            }\n            */\n            geko[q + a + 1] += geko[q];\n        }\n    }\n    cout << ans << endl;\n}\n#undef int \nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=5005;\nconst int MOD=1000000007;\nint n,a,b;\nlong long f[N][2];\nlong long g[N];\nlong long dp[N][2];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a>b) swap(a,b);\n\tif(b==1)\n\t{\n\t\tprintf(\"2\\n\");\n\t\treturn 0;\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t\tf[i][1]=(f[i][1]+f[j][0])%MOD;\n\t\tfor(int j=0;j+a<=i;j++)\n\t\t\tf[i][0]=(f[i][0]+f[j][1])%MOD;\n\t}\n\tg[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tg[i]=(f[i][0]+f[i][1])%MOD;\n\tlong long ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<a) dp[i][0]=(dp[i][0]+1)%MOD;\n\t\tfor(int j=i-a+1;j<i;j++)\n\t\t\tif(j>0) dp[i][0]=(dp[i][0]+dp[j][1])%MOD;\n\t\tif(i<b) dp[i][1]=(dp[i][1]+g[i-1])%MOD;\n\t\tfor(int j=i-b+1;j<i;j++)\n\t\t\tif(j>0) dp[i][1]=(dp[i][1]+dp[j][0]*(i-j==1?1:g[i-j-2])%MOD)%MOD;\n\t\tif(i+b-1>=n) ans=(ans+dp[i][0]*g[n-i-1]%MOD)%MOD;\n\t\tif(i+a-1>=n) ans=(ans+dp[i][1])%MOD;\n\t}\n\tprintf(\"%lld\",(ksm(2,n)-ans+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver2 {\n public:\n  int n, a, b;\n  LL dp[5001][5001][2];\n\n  Solver2(int n, int a, int b) : n(n), a(a), b(b){};\n\n  void solve() {\n    if (a < b) swap(a, b);\n    dp[0][0][0] = LL(1);\n    dp[2][1][0] = LL(MOD - 1);\n    auto ans = Modint<>(0);\n    for (int i = 0; i <= n; ++i) {\n      if (i > 0) dp[i][1][0] += dp[i - 1][1][0];\n      dp[i][1][0] %= MOD;\n      for (int j = 0; j < a; ++j) {\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] += dp[i][j][0];\n        if (i + 2 <= n) dp[i + 2][1][0] += dp[i][j][0];\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] -= dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] += dp[i][j][1];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][1];\n\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] %= MOD;\n        if (i + 2 <= n) dp[i + 2][1][0] %= MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] += MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] %= MOD;\n      }\n      auto cf = Modint<>(2).mpow(n - i);\n      for (int j = a; j <= n; ++j) {\n        ans += (dp[i][j][0] + dp[i][j][1]) * cf;\n      }\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, a, b;\n  std::cin >> n >> a >> b;\n\n  Problem::Solver2 sol(n, a, b);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\nconstexpr ll MAX=1e6;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Segment_tree{\n    ll N;\n    vector<pii> node;\n    Segment_tree(ll sz){\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mp(INF,INF));\n        per(i,N-2,0){\n            node[i]=std::min(node[i*2+1],node[i*2+1]);\n        }\n    }\n    void update(ll X,pii val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=std::min(node[X*2+1],node[X*2+2]);\n        }\n    }\n    pii RMQ(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mp(INF,INF);\n        if(a<=l&&r<=b) return node[now];\n        auto vl=RMQ(a,b,now*2+1,l,(l+r)/2),vr=RMQ(a,b,now*2+2,(l+r)/2,r);\n        return std::min(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    A--,B--;\n    if(A<B) std::swap(A,B);\n    vi memo(A+2,1);\n    vii ap(A,vi(A));\n    ap[0][0]=1;\n    rep(j,0,A-1){\n        rep(k,0,A-1){\n            ap[j+1][k+1]+=ap[j][k];\n            ap[j+1][k+1]%=MOD;\n        }\n        ap[j+1][0]+=ap[j][0];\n        ap[j+1][0]%=MOD;\n        rep(k,B+1,A-1){\n            ap[j+1][0]+=ap[j][k];\n            ap[j+1][0]%=MOD;\n        }\n    }\n    rep(i,0,A){\n        memo[i+2]=0;\n        REP(j,B+1,i){\n            memo[i+2]+=ap[i][j];\n            memo[i+2]%=MOD;\n        }\n        memo[i+2]+=ap[i][0];\n        memo[i+2]%=MOD;\n    }\n    vii dp(N+1,vi(A+1)),cp(N+1,vi(B+1));\n    ll ans=modpow(2,N,MOD);\n    dp[0][0]=1;\n    rep(i,0,N){\n        rep(j,0,A){\n            dp[i+1][j+1]+=dp[i][j];\n            dp[i+1][j+1]%=MOD;\n            if(i==j) cp[i+1][1]+=dp[i][j]*memo[j+1]%MOD;\n            else cp[i+1][1]+=dp[i][j]*memo[j]%MOD;\n            cp[i+1][1]%=MOD;\n        }\n        rep(j,0,B){\n            cp[i+1][j+1]+=cp[i][j];\n            cp[i+1][j+1]%=MOD;\n            dp[i+1][1]+=cp[i][j];\n            dp[i+1][1]%=MOD;\n        }\n        dp[i+1][1]+=cp[i][B];\n        dp[i+1][1]%=MOD;\n        if(i==A) cp[i+1][1]+=dp[i][A]*memo[A+1]%MOD;\n        else cp[i+1][1]+=dp[i][A]*memo[A]%MOD;\n        cp[i+1][1]%=MOD;\n    }\n    REP(i,0,A){\n        ans-=dp[N][i]*memo[i+1]%MOD;\n        ans%=MOD;\n        if(ans<0) ans+=MOD;\n    }\n    REP(i,0,B){\n        ans-=cp[N][i];\n        ans%=MOD;\n        if(ans<0) ans+=MOD;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tint n,a,b;\n\tcin >> n >> a >> b;\n\t\n\tlong long mod=1000000007;\n\t\n\t//a<=b\n\tif(a>b) swap(a,b);\n\t\n\tvector<vector<long long>> dp(n+1,vector<long long>(b));\n\tvector<vector<long long>> dp2(n+1,vector<long long>(b));\n\tvector<long long> res(n+1);\n\tdp[0][0]=1;\n\tdp2[0][0]=0;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tres[i+1]+=(res[i]*2)%mod;\n\t\tres[i+1]%=mod;\n\t\t\n\t\t//add 1\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((j+1)<b){\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\tdp[i+1][j+1]+=dp2[i][j];\n\t\t\t\tdp[i+1][j+1]%=mod;\n\t\t\t}\n\t\t}\n\t\tres[i+1]+=dp[i][b-1];\n\t\tres[i+1]+=dp2[i][b-1]*2;\n\t\tres[i+1]%=mod;\n\t\t\n\t\t//add 0\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((j+1)<b){\n\t\t\t\tdp2[i+1][j+1]+=dp2[i][j];\n\t\t\t\tdp2[i+1][j+1]%=mod;\n\t\t\t}\n\t\t\tif(j<b){\n\t\t\t\tdp[i+1][0]+=dp[i][j];\n\t\t\t\tdp[i+1][0]%=mod;\n\t\t\t}\n\t\t}\n\t\tif((i+1-a)>=0){\n\t\t\tfor(int j=1;j<b;j++){\n\t\t\t\tdp[i+1][0]=(dp[i+1][0]+mod-dp[i+1-a][j])%mod;\n\t\t\t}\n\t\t\tif((i+1-a)==0) dp[i+1][0]=(dp[i+1][0]+mod-1)%mod;\n\t\t}\n\t\t\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif((i+a)>n) continue;\n\t\t\tif((j+a)<b){\n\t\t\t\tdp2[i+a][j+a]+=dp[i][j];\n\t\t\t\tdp2[i+a][j+a]%=mod;\n\t\t\t}else if(j<b){\n\t\t\t\tres[i+a]+=dp[i][j];\n\t\t\t\tres[i+a]%=mod;\n\t\t\t}\n\t\t}\n\t\tif(i==0){\n\t\t\tif(a<b){\n\t\t\t\tdp2[i+a][a]+=dp[i][0];\n\t\t\t\tdp2[i+a][a]%=mod;\n\t\t\t}else{\n\t\t\t\tres[i+a]+=dp[i][0];\n\t\t\t\tres[i+a]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res[n] << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y>a.y;\n  };\n\n};\n\nint a,b,c,d,i,n,m,e,k,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[2][5010];\nlong long l[5010];\nlong long s[5010];\nlong long x,y,z,mod=1000000007,hf=(mod+1)/2;\n\n//string r,r1;\nchar r[361];\nvector<int> v[200101];\nP u[1];\nqueue<int> q;\n//set<int> s[2];\n//stack<int> s;\nmap<int,int> p;\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//rng()\nbool as(P a,P b)\n{\n  return a.x<b.x;\n}\n\nlong long g(int n)\n{\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(s[n]>=0) return s[n];\n  long long k=g(n-1);\n  for(int t=b+1;t<=n;t++)\n    k=(k+g(n-t))%mod;\n  return s[n]=k;\n}\n\nlong long f(int i,int n)\n{\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(o[i][n]>=0) return o[i][n];\n  long long k=0;\n  if(i)\n  {\n    for(int t=1;t<b;t++)\n      k=(k+f(0,n-t))%mod;\n  }\n  else\n  {\n    k=f(1,n-1);\n    for(int t=2;t<c;t++)\n    {\n      int e=1;\n      if(n==a) e--;\n      if(n-t==0) e--;\n      k=(k+f(1,n-t)*g(t-e)%mod)%mod;\n    }\n    \n  }\n  return o[i][n]=k;\n}\n\nint main()\n{\n  memset(s,-1,sizeof(s));\n  memset(o,-1,sizeof(o));\n  l[1]=l[2]=1;\n  scanf(\"%d %d %d\",&a,&b,&c);\n  if(b>c) swap(b,c);\n  /*for(int t=3;t<c;t++)\n  {\n    l[t]=g(t-1);\n    printf(\"%lld\\n\",l[t]);\n  }*/\n  x=1;\n  for(int t=1;t<=a;t++)\n    x*=2,x%=mod;\n  printf(\"%lld\",(x-f(0,a)-f(1,a)+mod*2)%mod);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst ll MOD=1e9+7;\nvoid add(ll& lhs,ll rhs){\n    lhs=(lhs+rhs)%MOD;\n}\nint main(){\n    int n,a,b;\n    cin>>n>>a>>b;\n    if(b<a) swap(a,b);\n    if(a==1 || b==1){\n        \n        assert(false);\n    }\n    vector<vector<ll>> Adp(n+1,vector<ll>(b));\n    vector<vector<ll>> Bdp(n+1,vector<ll>(b));\n    vector<vector<ll>> Cdp(n+1,vector<ll>(b));\n    vector<ll> ok(n+1);\n    Adp[0][0] = 1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<a;j++){\n            if(j+1<a){\n                add(Adp[i+1][j+1],Adp[i][j]);\n            }\n            add(Bdp[i+1][1],Adp[i][j]);\n            if(i==0 && j==0){\n                if(a==b){\n                    add(ok[i+a],Adp[i][0]);\n                }\n                else{\n                    add(Cdp[i+a][a],Adp[i][0]);\n                }\n            }\n        }\n        for(int j=0;j<b;j++){\n            add(Adp[i+1][1],Bdp[i][j]);\n            if(j+1<b){\n                add(Bdp[i+1][j+1],Bdp[i][j]);\n            }\n            else{\n                add(ok[i+1],Bdp[i][j]);\n            }\n            if(i+a<=n){\n                if(j+a<b){\n                    add(Cdp[i+a][j+a],Bdp[i][j]);\n                }\n                else{\n                    add(ok[i+a],Bdp[i][j]);\n                }\n            }\n        }        \n        for(int j=0;j<b;j++){\n            if(j+1<b){\n                add(Bdp[i+1][j+1],Cdp[i][j]);\n                add(Cdp[i+1][j+1],Cdp[i][j]);\n            }\n            else{\n                add(ok[i+1],Cdp[i][j]);\n                add(ok[i+1],Cdp[i][j]);\n            }\n        }\n        add(ok[i+1],ok[i]);\n        add(ok[i+1],ok[i]);\n    }\n\n    cout<<ok[n]<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\nstruct range {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr itr operator * () const { return i; }\n    constexpr bool operator != (iterator x) const { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr range(itr l_, itr r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr iterator begin() const { return l; }\n  constexpr iterator end() const { return r; }\n};\n\nstruct revrange {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr itr operator * () const { return i; }\n    constexpr bool operator != (iterator x) const { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr revrange(itr l_, itr r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr iterator begin() const { return r; }\n  constexpr iterator end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type get_mod() { return mod; }\n  static_assert(mod >= 2, \"invalid mod :: smaller than 2\");\n  static_assert(mod < (value_type(1) << 31), \"invalid mod :: over 2^31\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type get() const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing m32 = modular<1000000007>;\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\n// template <class T, size_t N, size_t I = 0>\n// decltype(auto) gen_vec(const size_t (&list)[N], typename std::enable_if<(I == N), const T&>::type value = T()) { \n//   return value; \n// }\n\n// template <class T, size_t N, size_t I = 0>\n// decltype(auto) gen_vec(const size_t (&list)[N], typename std::enable_if<(I != N), const T&>::type value = T()) { \n//   return std::vector(list[I], gen_vec<T, N, I + 1>(list, value)); \n// }\n\nint main() {\n  i32 N, A, B;\n  std::cin >> N >> A >> B;\n  N += 2;\n  if (A > B) {\n    std::swap(A, B);\n  }\n  std::vector<std::array<m32, 2>> dp1(N + 1);\n  for (auto i: range(0, N + 1)) {\n    for (auto j: range(0, 2)) {\n      dp1[i][j] = (m32) 0;\n    }\n  }\n  dp1[0][1] = (m32) 1;\n  for (auto i: range(0, N + 1)) {\n    { // extend 0 (greater than or equal to A)\n      for (auto j: range(A, N + 1)) {\n        if (i + j <= N) {\n          dp1[i + j][1] += dp1[i][0];\n        }\n      }\n    }\n    { // extend 1 (any length)\n      for (auto j: range(1, N + 1)) {\n        if (i + j <= N) {\n          dp1[i + j][0] += dp1[i][1];\n        }\n      }\n    }\n  }\n  // std::cout << dp1[N][0] << '\\n';\n  /*\n  std::vector<std::array<m32, 2>> dp1a(N + 1);\n  for (auto i: range(0, N + 1)) {\n    for (auto j: range(0, 2)) {\n      dp1a[i][j] = (m32) 0;\n    }\n  }\n  dp1a[0][0] = (m32) 1;\n  for (auto i: range(0, N + 1)) {\n    { // extend 0 (greater than or equal to A)\n      for (auto j: range(A, N + 1)) {\n        if (i + j <= N) {\n          dp1a[i + j][1] += dp1a[i][0];\n        }\n      }\n    }\n    { // extend 1 (any length)\n      for (auto j: range(1, N + 1)) {\n        if (i + j <= N) {\n          dp1a[i + j][0] += dp1a[i][1];\n        }\n      }\n    }\n  }\n  // */\n  std::vector<std::array<std::array<m32, 2>, 2>> dp2(N + 1);\n  for (auto i: range(0, N + 1)) {\n    for (auto j: range(0, 2)) {\n      for (auto k: range(0, 2)) {\n        dp2[i][j][k] = (m32) 0;\n      }\n    }\n  }\n  dp2[0][1][0] = (m32) 1;\n  for (auto i: range(0, N + 1)) {\n    for (auto k: range(0, 2)) {\n      { // extend 0 (less than A)\n        for (auto j: range(1, A)) {\n          if (i + j <= N) {\n            dp2[i + j][1][k] += dp2[i][0][k];\n          }\n        }\n      }\n      { // extend 1 (any length)\n        for (auto j: range(1, N + 1)) {\n          if (i + j <= N) {\n            auto len = j;\n            if (i == 0) --len;\n            if (i + j == N) --len;\n            if (len >= B) {\n              dp2[i + j][0][1] += dp2[i][1][k] * dp1[j][0];\n              /*\n              if (i == 0) dp2[i + j][0][1] += dp2[i][1][k] * dp1a[j][0];\n              if (i + j == N) dp2[i + j][0][1] += dp2[i][1][k] * dp1[j][1];\n              if (i == 0 && i + j == N) dp2[i + j][0][1] += dp2[i][1][k] * dp1a[j][1];\n              // */\n            }\n            else {\n              dp2[i + j][0][k] += dp2[i][1][k] * dp1[j][0];\n              /* \n              if (i == 0) dp2[i + j][0][k] += dp2[i][1][k] * dp1a[j][0];\n              if (i + j == N) dp2[i + j][0][k] += dp2[i][1][k] * dp1[j][1];\n              if (i == 0 && i + j == N) dp2[i + j][0][k] += dp2[i][1][k] * dp1a[j][1];\n              // */\n            }\n          }\n        }\n      }\n    }\n  }\n  // for (auto i: range(0, N + 1)) {\n  //   std::cout << dp2[i][0][0] << ' ' << dp2[i][0][1] << ' ' << dp2[i][1][0] << ' ' << dp2[i][1][1] << '\\n';\n  // }\n  // std::cout << dp2[N][0][0] << '\\n';\n  std::cout << dp2[N][0][1] << '\\n';\n  // std::cout << dp2[N][1][0] << '\\n';\n  // std::cout << dp2[N][1][1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <chrono>\n#include <random>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <iomanip>\n#define dibs reserve\n#define OVER9000 1234567890\n#define tisic 47\n#define soclose 1e-8\n#define patkan 9\n#define ff first\n#define ss second\nusing uint = unsigned int;\nusing cat = long long;\nusing dbl = long double;\nconstexpr dbl pi = 3.14159265358979323846;\nusing namespace std;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ntemplate <typename T>\nT abs(T x) {return (x < 0) ? -x : x;}\n\ncat pw(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2, mod);\n\tx = x * x % mod;\n\treturn (e&1) ? x * a % mod : x;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcout << fixed << setprecision(10);\n\tcat mod = 1000000007;\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif(A > B) swap(A, B);\n\tif(A == 1) {\n\t\tcat ans = 1;\n\t\tfor(int i = 0; i < N; i++) ans = 2 * ans % mod;\n\t\tcout << ans << \"\\n\";\n\t\treturn 0;\n\t}\n\tvector<cat> cnt_segB(B, 0);\n\tcnt_segB[1] = 1;\n\tfor(int i = 2; i < B; i++) {\n\t\tcnt_segB[i] = cnt_segB[i-1];\n\t\tfor(int j = A; j <= i-2; j++) cnt_segB[i] += cnt_segB[i-1-j];\n\t\tcnt_segB[i] %= mod;\n\t}\n\tvector<cat> cnt_segB_bor(B, 0);\n\tcnt_segB_bor[0] = 1;\n\tfor(int i = 1; i < B; i++) {\n\t\tcnt_segB_bor[i] = cnt_segB_bor[i-1];\n\t\tfor(int j = A; j <= i-1; j++) cnt_segB_bor[i] += cnt_segB_bor[i-1-j];\n\t\tcnt_segB_bor[i] %= mod;\n\t}\n\tvector<cat> dp_segA(N+1, 0), dp_segB(N+1, 0);\n\tdp_segB[0] = dp_segA[0] = 1;\n\tfor(int i = 1; i <= N; i++) {\n\t\tfor(int j = 1; j <= min(i, A-1); j++) dp_segA[i] += dp_segB[i-j];\n\t\tdp_segA[i] %= mod;\n\t\tcat mod2 = mod * mod * 4;\n\t\tfor(int j = 1; j <= min(i-1, B-1); j++) {\n\t\t\tdp_segB[i] += dp_segA[i-j] * cnt_segB[j];\n\t\t\tif(dp_segB[i] >= mod2) dp_segB[i] -= mod2;\n\t\t}\n\t\tif(i < B) dp_segB[i] += cnt_segB_bor[i];\n\t\tdp_segB[i] %= mod;\n\t}\n\tcat ans = 1;\n\tfor(int i = 0; i < N; i++) ans = 2 * ans % mod;\n\tans -= dp_segA[N] + dp_segB[N];\n\tfor(int i = 1; i < B; i++) ans -= dp_segA[N-i] * (cnt_segB_bor[i] - cnt_segB[i]) % mod;\n\tans %= mod;\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\nusing Mint = ModInt<TEN(9) + 7>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nconst int MN = 5050;\n\nint n, a, b;\n\nbool used[MN][MN];\nMint dp[MN][MN];\nMint solve(int p, int q);\n\n\nbool used1[MN];\nMint dp1[MN];\nMint solve1(int p) {\n    if (n + 1 <= p) return Mint(0);\n    if (used1[p]) return dp1[p];\n    used1[p] = true;\n    return dp1[p] = solve(p, 1) + solve1(p + 1);\n}\n\nbool used2[MN][MN];\nMint dp2[MN][MN];\nMint solve2(int p, int q) {\n    if (n + 1 <= p) return Mint(0);\n    if (q >= b) return Mint(0);\n\n    if (used2[p][q]) return dp2[p][q];\n    used2[p][q] = true;\n    return dp2[p][q] = solve(p, q) + solve2(p + 1, q + 1);\n}\n\nMint solve(int p, int q) {\n    if (q >= b) return Mint(0);\n    if (p == n) return Mint(1);\n    if (used[p][q]) return dp[p][q];\n    used[p][q] = true;\n\n    Mint ans = Mint(0);\n\n    // 000\n    if (n - p < a || q + (n - p) < b) ans += 1;\n\n    // 1\n    ans += solve(p + 1, q + 1);\n\n    // 01, 001, ...\n    /*for (int r = p + 1; r < min(n, p + a); r++) {\n        ans += solve(r + 1, 1);\n    }*/\n    ans += solve1(p + 2) - solve1(p + a + 1);\n\n\n/*    for (int r = p + a; r < n; r++) {\n        int nq = q + r - p + 1;\n        ans += solve(r + 1, nq);\n    }*/\n    ans += solve2(p + a + 1, q + a + 1);\n\n    return dp[p][q] = ans;\n};\n\nint main() {\n    sc.read(n, a, b);\n    if (a > b) swap(a, b);\n\n\n    pr.writeln((Mint(2).pow(n) - solve(0, 0)).v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5005;\nconst int MOD = 1000000007;\n\nint n,A,B,ans;\nint pw[MAXN];\nint f[MAXN][MAXN];\nint g[MAXN][MAXN];\nint lazg[MAXN][MAXN];\nint lazf[MAXN][MAXN];\nint sumg[MAXN];\nint sumf[MAXN];\nint spec[MAXN];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif (A > B)\n\t\tswap(A,B);\n\tpw[0] = 1;\n\tfor (int i = 1;i <= n;i++)\n\t\tpw[i] = pw[i - 1] * 2 % MOD;\n\tf[0][0] = g[0][0] = 1;\n\tint all = 0;\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= i;j++)\n\t\t{\n\t\t\tif (i || j)\n\t\t\t{\n\t\t\t\t(sumf[j] += lazf[i][j]) %= MOD;\n\t\t\t\tf[i][j] = sumf[j];\n\t\t\t}\n\t\t\tif (f[i][j])\n\t\t\t{\n\t\t\t\t(spec[i + 1] += f[i][j]) %= MOD;\n\t\t\t\t(spec[min(n + 1,i + A)] -= f[i][j]) %= MOD;\n\t\t\t//\tfor (int k = i + 1;k < i + A;k++)\n\t\t\t//\t\t(g[k][k] += f[i][j]) %= MOD;\n\t\t\t\t(lazg[min(i + A,n + 1)][j] += f[i][j]) %= MOD;\n\t\t\t//\tfor (int k = i + A;k <= n;k++)\n\t\t\t//\t\t(g[k][j] += f[i][j]) %= MOD;\n\t\t\t}\n\t\t\tif (i || j)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\t(all += spec[i]) %= MOD;\n\t\t\t\t\tg[i][j] = all;\n\t\t\t\t}\n\t\t\t\t(sumg[j] += lazg[i][j]) %= MOD;\n\t\t\t\t(g[i][j] += sumg[j]) %= MOD;\n\t\t\t}\n\t\t\tif (g[i][j])\n\t\t\t{\n\t\t\t\tif (j + B <= n)\n\t\t\t\t\t(ans += (ll)g[i][j] * pw[n - max(j + B,i) - (i < n ? max(j + B,i) == i : 0)] % MOD) %= MOD;\n\t\t\t\t(lazf[min(i + 1,min(j + B - 1,n) + 1)][j] += g[i][j]) %= MOD;\n\t\t\t\t(lazf[min(j + B - 1,n) + 1][j] -= g[i][j]) %= MOD;\n\t\t\t//\tfor (int k = i + 1;k <= min(j + B - 1,n);k++)\n\t\t\t//\t\t(f[k][j] += g[i][j]) %= MOD;\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint add(int a,int b) {\n\treturn a+b>=mod?a+b-mod:a+b;\n}\n\nint n,a,b,f[N][N][2],g[N],sum[N][N][2];\n\nint getsum(int i,int j,int k) {\n\tif(i<0||j<0) return 0;\n\tif(sum[i][j][k]!=-1) return sum[i][j][k];\n\treturn sum[i][j][k]=add(f[i][j][k],getsum(i-1,j-1,k));\n}\n\nint main() {\n\tcin>>n>>a>>b;if(a>b) swap(a,b);\n\tmemset(sum,-1,sizeof(sum));\n\tf[0][0][0]=f[0][0][1]=g[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<b;j++) {\n\t\t\tf[i][j][1]=getsum(i-1,j-1,0);\n\t\t\tif(j) f[i][j][0]=getsum(i-a,j-a,1);\n\t\t\telse for(int k=0;k<a&&k<=i;k++) f[i][j][0]=add(f[i][j][0],g[i-k]);\n\t\t\tg[i]=add(g[i],f[i][j][1]);\n\t\t}\n\tint ans=0;\n\tfor(int i=0;i<b;i++) ans=(0ll+ans+f[n][i][0]+f[n][i][1])%mod;\n\tint bin=1;\n\tfor(int i=1;i<=n;i++) bin=2ll*bin%mod;\n\tcout<<(bin-ans+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n//    #include <boost/multiprecision/cpp_int.hpp>\n  //  using namespace boost::multiprecision;\n #define int  long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n  #define PI 3.14159265358979323846\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[1000100];\n                int inv[1000110];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n               \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\nint dp[5010*2][5010]={};\nint rui[5010*2][5010]={};\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint a,b;\n\tint n;\n\tcin>>n;\n\tcin>>a>>b;\n\t\n\tif(a<b)swap(a,b);\n\t\n\tdp[n+1][a]++;\n\tdp[n+1][a-1]++;\n\trui[n+1][a]++;\n\trui[n+1][a-1]+=2;\n\tfor(int i=n-1;i>=1;i--){\n\t\t/*\n\t\tfor(int j=i+1;j<=i+a+1;j++){\n\t\t\tfor(int k=0;k<=a;k++)cout<<dp[j][k]<<\" \";\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n*/\n\t\t\n\t\tfor(int j=i+a;j>i;j--){\n\t\t\tint y=dp[j][i+a+1-j]+(i+a+b+1-j<=a?rui[j][i+a+b+1-j]:0);\n\t\t\ty%=inf;\n\t\t\tdp[j][i+a-j]=y;\n\t\t\trui[j][i+a-j]=(y+rui[j][i+a+1-j])%inf;\n\t\t\t\n\t\t}\n\t\t\n\t\tint cnt=2;\n\t\tint cnt2=b+1;\n\t\tint wa=0;\n\t\tfor(int j=i+a;j>=i+2;j--){\n\t\t\twa+=rui[j][cnt]+inf-(cnt2<=a?rui[j][cnt2]:0);\n\t\t\t//wa+=dp[j][cnt];\n\t\t\t//cout<<rui[j][cnt]<<\" \"<<(cnt2<=a?rui[j][cnt2]:0)<<\"    \"<<rui[j][cnt]-(cnt2<=a?rui[j][cnt2]:0)<<\" \"<<dp[j][cnt]<<endl;\n\t\t\t//cout<<wa<<endl;\n\t\t\tcnt++;\n\t\t\tcnt2++;\n\t\t}\n\t\tfor(int j=1;j<b;j++){\n\t\t\twa+=dp[i+a+1][j];\n\t\t\tdp[i+a][j+1]+=dp[i+a+1][j];\n\t\t\tdp[i+a][j+1]%=inf;\n\t\t}\n\t\twa%=inf;\n\t\tfor(int j=0;j<=a;j++)if(j==0||j>=b){\n\t\t\tdp[i+a][j]+=2*dp[i+a+1][j];\n\t\t\tdp[i+a][j]%=inf;\n\t\t}\n\t\tdp[i+1][a-1]=wa;\n\t//\tcout<<wa<<endl;\n\t\trui[i+1][a-1]=(dp[i+1][a-1]+rui[i+1][a])%inf;\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=a;j++)if(j==0||j>=b)ans+=dp[a+1][j];\n\tcout<<ans%inf<<endl;\n\t\n\treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=5005,mod=1e9+7;\nint f[N][N][2],g[N][N],h[N],n,A,B;\n\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint main(){\n\tread(n),read(A),read(B);\n\tif(A<B) swap(A,B);\n\n\tadd(f[1][1][0],1);\n\trep(i,1,n){\n\t\tif(i<B) add(f[i][0][1],1);\n\t\telse add(f[i][i][1],1);\n\t}\n\n\trep(i,1,n){\n\t\tadd(h[i],h[i-1]);\n\t\tadd(f[i][0][1],h[i]);\n\n\t\tadd(f[i+1][1][0],f[i][0][1]);\n\t\t\n\t\trep(j,1,A-1){\n\t\t\tadd(g[i][j],g[i-1][j-1]);\n\t\t\tadd(f[i][j][1],g[i][j]);\n\n\t\t\tadd(h[i+1],f[i][j][0]);\n\t\t\tadd(h[min(n+1,i+B)],mod-f[i][j][0]);\n\t\t\tadd(f[i+1][j+1][0],f[i][j][0]);\n\t\t\tif(i+B<=n){\n\t\t\t\tadd(g[i+B][j+B],f[i][j][0]);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tadd(f[i+1][j+1][0],f[i][j][1]);\n\t\t}\n\t}\n\n\tint ans=0,tot=1;\n\trep(i,1,n){\n\t\ttot=2ll*tot%mod;\n\t}\n\trep(j,0,A-1){\n\t\tadd(ans,f[n][j][0]);\n\t\tadd(ans,f[n][j][1]);\n\t}\n\tans=((tot+mod-ans)%mod+mod)%mod;\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define M1 1000000007\n#define M2 998244353\n#define ll long long\n#define pll pair<ll,ll>\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define REPI(i,a,b) for(ll i=b-1;i>=a;i--)\n#define F first\n#define S second\n#define PB push_back\n#define DB pop_back\n#define MP make_pair\n#define MT make_tuple\n#define G(a,b) get<a>(b)\n#define V(a) vector<a>\n\ntemplate<typename T>\n#define o_set(T) tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>\n//member functions :\n//1. order_of_key(k) : number of elements strictly lesser than k\n//2. find_by_order(k) : k-th element in the set\n\npll Egcd(ll,ll);\npll Egcd(ll x,ll y)\n{\n    if(x==0) return MP(0,1);\n    pll t=Egcd(y%x,x);\n    return MP(t.S-t.F*(y/x),t.F);\n}\n\nll powM(ll x,ll y,ll m)\n{\n    ll ans=1,r=1;\n    x%=m;\n    while(r>0&&r<=y)\n    {\n        if(r&y)\n        {\n            ans*=x;\n            ans%=m;\n        }\n        r<<=1;\n        x*=x;\n        x%=m;\n    }\n    return ans;\n}\n\nll modI(ll a, ll m)\n{\n    ll m0=m,y=0,x=1;\n    if(m==1) return 0;\n    while(a>1)\n    {\n        ll q=a/m;\n        ll t=m;\n        m=a%m;\n        a=t;\n        t=y;\n        y=x-q*y;\n        x=t;\n    }\n    if(x<0) x+=m0;\n    return x;\n}\n\nvoid Miden(ll **p1,ll n)\n{\n    ll (*x)[n]=(ll(*)[n]) p1;\n    REP(i,0,n)\n    {\n        REP(j,0,n)\n        {\n            x[i][j]=0;\n        }\n        x[i][i]=1;\n    }\n    return;\n}\n\nvoid Mmult(ll **p1,ll **p2,ll **ans,ll x,ll y,ll z,ll m)\n{\n    ll (*a)[y]=(ll (*)[y])p1;\n    ll (*b)[z]=(ll (*)[z])p2;\n    ll (*c)[z]=(ll (*)[z])ans;\n    REP(i,0,x)\n    {\n        REP(j,0,z)\n        {\n            c[i][j]=0;\n            REP(k,0,y)\n            {\n                c[i][j]+=a[i][k]*b[k][j];\n                c[i][j]%=m;\n            }\n        }\n    }\n    return;\n}\n\nvoid Mpow(ll **p1,ll **ans,ll n,ll y,ll m)\n{\n    if(y==0)\n    {\n        Miden(ans,n);\n        return;\n    }\n    ll t[n][n];\n    Mpow(p1,(ll **)t,n,y/2,m);\n    ll z[n][n];\n    Mmult((ll **)t,(ll **)t,(ll **)z,n,n,n,m);\n    if(y%2)\n    {\n        Mmult((ll **)z,p1,ans,n,n,n,m);\n    }\n    else\n    {\n        Miden((ll **)t,n);\n        Mmult((ll **)z,(ll **)t,ans,n,n,n,m);\n    }\n    return;\n}\n\nbool isprime(ll n)\n{\n    if(n<2)\n        return false;\n    for(ll x:{2,3,5,7,11,13,17,19,23,29,31,37})\n    {\n        if(n==x)\n            return true;\n        bool flag=true;\n        ll r=1;\n        ll t=1;\n        while(r<=((n-1)>>__builtin_ctzll(n-1)))\n        {\n            if(r&((n-1)>>__builtin_ctzll(n-1)))\n                t=((__int128)t*x)%n;\n            x=((__int128)x*x)%n;\n            r<<=1;\n        }\n        if(t==1||t==n-1)\n            flag=false;\n        for(r=0;r<__builtin_ctzll(n-1);r++)\n        {\n            t=((__int128)t*t)%n;\n            if(t==n-1)\n                flag=false;\n        }\n        if(flag)\n            return false;\n    }\n    return true;\n}\n\nll PrimRoot(ll p,ll x)\n{\n    //finds primitive root of prime p greater than x(If it doesnt exist, returns 0)\n    V(ll) v;\n    ll t=p-1;\n    REP(i,2,t+1)\n    {\n        if(i*i>t) break;\n        if(t%i==0)\n        {\n            v.PB((p-1)/i);\n            while(t%i==0)\n            {\n                t/=i;\n            }\n        }\n    }\n    if(t>1) v.PB((p-1)/t);\n    REP(i,x+1,p)\n    {\n        ll flag=0;\n        REP(j,0,((ll)v.size()))\n        {\n            if(powM(i,v[j],p)==1)\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n            return i;\n        }\n    }\n\n    return 0;\n}\n\nvoid fft(V(ll) &a,ll n,bool invert,ll m,ll x)\n{\n    REP(i,0,n)\n    {\n        ll y=0;\n        REP(j,0,__builtin_ctzll(n))\n        {\n            if((1LL<<j)&i)\n            {\n                y|=(1LL<<(__builtin_ctzll(n)-j-1));\n            }\n        }\n        if(y>i)\n        {\n            swap(a[i],a[y]);\n        }\n    }\n    if(invert) x=modI(x,m);\n    REP(s,1,__builtin_ctzll(n)+1)\n    {\n        ll y=powM(x,(n/(1LL<<s)),m);\n        REP(j,0,(n/(1LL<<s)))\n        {\n            ll r=1;\n            REP(i,0,(1LL<<(s-1)))\n            {\n                ll u=a[i+j*(1LL<<s)];\n                ll v=(r*a[i+j*(1LL<<s)+(1LL<<(s-1))])%m;\n                a[i+j*(1LL<<s)]=u+v;\n                if(a[i+j*(1LL<<s)]>m) a[i+j*(1LL<<s)]-=m;\n                a[i+j*(1LL<<s)+(1LL<<(s-1))]=u-v;\n                if(a[i+j*(1LL<<s)+(1LL<<(s-1))]<0) a[i+j*(1LL<<s)+(1LL<<(s-1))]+=m;\n                r*=y;\n                r%=m;\n            }\n        }\n    }\n    if(invert)\n    {\n        ll invn=modI(n,m);\n        REP(i,0,n)\n        {\n            a[i]=(a[i]*invn)%m;\n        }\n    }\n    return;\n}\n\nvoid PolyMult(V(ll) &a,V(ll) &b,V(ll) &v,ll m,ll x)\n{\n    ll n=1;\n    while(n<((ll)a.size())+((ll)b.size()))\n    { \n        n<<=1;\n    }\n    V(ll) fa(a.begin(),a.end());\n    fa.resize(n,0);\n    V(ll) fb(b.begin(),b.end());\n    fb.resize(n,0);\n    ll y=powM(x,(m-1)/n,m);\n    fft(fa,n,false,m,y);\n    fft(fb,n,false,m,y);\n    v.resize(n,0);\n    REP(i,0,n)\n    {\n        v[i]=((fa[i]*fb[i])%m);\n    }\n    fft(v,n,true,m,y);\n    return;\n}\n\nll fn(ll x,ll rn[])\n{\n    if(x==rn[x])\n        return x;\n    else\n        return rn[x]=fn(rn[x],rn);\n}\n\nbool un(ll x,ll y,ll rn[],ll sz[])\n{\n    x=fn(x,rn);\n    y=fn(y,rn);\n    if(x==y)\n        return false;\n    if(sz[x]<sz[y])\n        swap(x,y);\n    sz[x]+=sz[y];\n    rn[y]=x;\n    return true;\n}\n\nvoid build(ll v,ll tl,ll tr,ll st[],ll lz[],bool f[],ll a[])\n{\n    if(tl==tr)\n    {\n        st[v]=a[tl];\n        lz[v]=0LL;\n        f[v]=false;\n        return;\n    }\n    build((v<<1),tl,((tl+tr)>>1),st,lz,f,a);\n    build((v<<1)|1,((tl+tr)>>1)+1,tr,st,lz,f,a);\n    //operation\n    st[v]=st[(v<<1)]+st[(v<<1)|1];\n    lz[v]=0LL;\n    f[v]=false;\n    return;\n}\n\nvoid push(ll v,ll tl,ll tr,ll st[],ll lz[],bool f[])\n{\n    if(f[v])\n    {\n        //operation\n        st[(v<<1)]=lz[(v<<1)]=st[(v<<1)|1]=lz[(v<<1)|1]=0LL;\n        f[(v<<1)]=f[(v<<1)|1]=true;\n        f[v]=false;\n    }\n    //operation\n    st[(v<<1)]+=lz[v]*(((tl+tr)>>1)-tl+1);\n    //operation\n    lz[(v<<1)]+=lz[v];\n    //operation\n    st[(v<<1)|1]+=lz[v]*(tr-((tl+tr)>>1));\n    //operation\n    lz[(v<<1)|1]+=lz[v];\n    lz[v]=0LL;\n    return;\n}\n\nvoid update(ll v,ll tl,ll tr,ll l,ll r,ll val,bool set,ll st[],ll lz[],bool f[])\n{\n    if(l>r)\n    {\n        return;\n    }\n    if(l==tl&&tr==r)\n    {\n        if(set)\n        {\n            //operation\n            st[v]=lz[v]=0LL;\n            f[v]=true;\n        }\n        //operation\n        st[v]+=val*(tr-tl+1);\n        //operation\n        lz[v]+=val;\n        return;\n    }\n    push(v,tl,tr,st,lz,f);\n    update((v<<1),tl,((tl+tr)>>1),l,min(r,((tl+tr)>>1)),val,set,st,lz,f);\n    update((v<<1)|1,((tl+tr)>>1)+1,tr,max(l,((tl+tr)>>1)+1),r,val,set,st,lz,f);\n    //operation\n    st[v]=st[(v<<1)]+st[(v<<1)|1];\n    return;\n}\n\nll query(ll v,ll tl,ll tr,ll l,ll r,ll st[],ll lz[],bool f[])\n{\n    if(l>r)\n    {\n        return 0LL;\n    }\n    if(l==tl&&tr==r)\n    {\n        return st[v];\n    }\n    push(v,tl,tr,st,lz,f);\n    //operation\n    return query((v<<1),tl,((tl+tr)>>1),l,min(r,((tl+tr)>>1)),st,lz,f)+query((v<<1)|1,((tl+tr)>>1)+1,tr,max(l,((tl+tr)>>1)+1),r,st,lz,f);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    /*\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    */\n\n    ll ntc=1;\n    //cin>>ntc;\n    REP(tc,1,ntc+1)\n    {\n        //cout<<\"Case #\"<<tc<<\": \";\n\n        ll n,a,b;\n        cin>>n>>a>>b;\n        if(a<b)\n            swap(a,b);\n        ll dp[n+1];\n        ll ad1[n+1][2],ad0[n+1][2];\n        REP(j,0,n+1)\n        {\n            dp[j]=0;\n            ad1[j][0]=0;\n            ad1[j][1]=0;\n        }\n        dp[1]=1;\n        REP(i,1,n+1)\n        {\n            REP(j,1,b)\n            {\n                ad1[i][0]+=dp[j];\n                ad1[i][0]%=M1;\n            }\n            if(i>=a)\n            {\n                REP(j,b,n+1)\n                {\n                    ad1[i][1]+=dp[j];\n                    ad1[i][1]%=M1;\n                    dp[j]=0;\n                }\n                ad1[i][1]+=dp[0];\n                ad1[i][1]%=M1;\n                dp[0]=0;\n            }\n            ll sm=0;\n            if(i<a) sm+=dp[0];\n            REPI(j,1,n+1)\n            {\n                if(!((j<b)||(i>=a&&j>=b))) sm+=dp[j];\n                sm%=M1;\n                if(!(i>=a&&j-1>=b)) dp[j]=dp[j-1];\n                else dp[j]=0;\n            }\n            dp[0]=sm;\n        }\n        REP(j,0,n+1)\n        {\n            dp[j]=0;\n            ad0[j][0]=0;\n            ad0[j][1]=0;\n        }\n        dp[0]=1;\n        REP(i,1,n+1)\n        {\n            REP(j,1,b)\n            {\n                ad0[i][0]+=dp[j];\n                ad0[i][0]%=M1;\n            }\n            if(i>=a)\n            {\n                REP(j,b,n+1)\n                {\n                    ad0[i][1]+=dp[j];\n                    ad0[i][1]%=M1;\n                    dp[j]=0;\n                }\n                ad0[i][1]+=dp[0];\n                ad0[i][1]%=M1;\n                dp[0]=0;\n            }\n            ll sm=0;\n            if(i<a) sm+=dp[0];\n            REPI(j,1,n+1)\n            {\n                if(!((j<b)||(i>=a&&j>=b))) sm+=dp[j];\n                sm%=M1;\n                if(!(i>=a&&j-1>=b)) dp[j]=dp[j-1];\n                else dp[j]=0;\n            }\n            dp[0]=sm;\n        }\n        ll ans=0;\n        ll st[n+1],cmp[n+1];\n        REP(j,0,n+1)\n        {\n            st[j]=0;\n            cmp[j]=0;\n        }\n        st[0]=1;\n        REP(i,0,n+1)\n        {\n            ans<<=1;\n            ans+=cmp[i];\n            ans%=M1;\n            if(i==0)\n            {\n                REP(j,1,n+1-i)\n                {\n                    st[i+j]+=((ad1[j][0]*1)%M1);\n                    st[i+j]%=M1;\n                    cmp[i+j]+=((ad1[j][1]*1)%M1);\n                    cmp[i+j]%=M1;\n                }\n            }\n            REP(j,1,n+1-i)\n            {\n                st[i+j]+=((ad0[j][0]*st[i])%M1);\n                st[i+j]%=M1;\n                cmp[i+j]+=((ad0[j][1]*st[i])%M1);\n                cmp[i+j]%=M1;\n            }\n        }\n        cout<<ans;\n\n        cout<<'\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\ntemplate<unsigned mod=1000000007>struct fp {\n   unsigned v;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=v,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0){x+=mod;} return x;\n   }\n   fp():v(0){}\n   fp(ll x):v(x>=0?x%mod:mod+(x%mod)){}\n   fp operator-()const{return fp(-v);}\n   fp pow(ll t){fp res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;} return res;}\n   fp& operator+=(const fp& x){if((v+=x.v)>=mod)v-=mod; return *this;}\n   fp& operator-=(const fp& x){if((v+=mod-x.v)>=mod)v-=mod; return *this;}\n   fp& operator*=(const fp& x){v=ll(v)*x.v%mod; return *this;}\n   fp& operator/=(const fp& x){v=ll(v)*x.inv()%mod; return *this;}\n   fp operator+(const fp& x)const{return fp(*this)+=x;}\n   fp operator-(const fp& x)const{return fp(*this)-=x;}\n   fp operator*(const fp& x)const{return fp(*this)*=x;}\n   fp operator/(const fp& x)const{return fp(*this)/=x;}\n   bool operator==(const fp& x)const{return v==x.v;}\n   bool operator!=(const fp& x)const{return v!=x.v;}\n}; using Fp=fp<>;\n\nFp dp[5010][2][2],sub[5010][2];\n\nint main(){\n   int n,a,b; cin>>n>>a>>b; n+=2;\n   if(a>b)swap(a,b);\n   sub[0][0]=1;\n   rep(i,0,n){\n      for(int add=1;i+add<=n;add++)sub[i+add][1]+=sub[i][0];\n      for(int add=a;i+add<=n;add++)sub[i+add][0]+=sub[i][1];\n   }\n   dp[0][0][0]=1;\n   rep(i,0,n)rep(k,0,2){\n      for(int add=1;i+add<=n and add<a;add++)dp[i+add][0][k]+=dp[i][1][k];\n      for(int add=1;i+add<=n;add++){\n         int cur=add; if(i==0)cur--; if(i+add==n)cur--;\n         dp[i+add][1][cur>=b?1:k]+=dp[i][0][k]*sub[add][1];\n      }\n   }\n   cout<<dp[n][1][1].v<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long mod=1000000007;\nlong long quick(long long x,long long n){\n    long long res=1;\n    x%=mod;\n    while(n>0){\n        if(n&1)\n            res=res*x%mod;\n            x=x*x%mod;\n            n>>=1;\n    }\n    return res%mod;\n}\nint main(){\n    long long n,res;\n    cin>>n;\n    res=quick(2,n);\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define X first\n#define Y second\n#define PB push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair < int, int > pii;\ntypedef vector < int > vi;\n\nconst int N = 5050;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\n\nint n, a, b, dp[N][N][2][2], pref[N][N][2][2], pos_pref[N][2][2];\n\ninline int add(int A,int B){\n\tif(A + B >= MOD) \n\t\treturn A + B - MOD;\n\treturn A + B;\n}\n\ninline int sub(int A, int B){\n\tif(A - B < 0)\n\t\treturn A - B + MOD;\n\treturn A - B;\n}\n\nvoid dinamika(){\n\tfor(int k = 0;k <= n;k++){\n\t\tfor(int fl = 0;fl < 2;fl++){\n\t\t\tfor(int lst = 0;lst < 2;lst++){\n\t\t\t\tdp[n][k][fl][lst] = (n - k) >= b || fl;\n\t\t\t\tpref[n][k][fl][lst] = dp[n][k][fl][lst];\n\t\t\t\tif(n == k){\n\t\t\t\t\tpos_pref[n][fl][lst] = dp[n][n][fl][lst];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = n - 1;i >= 0;i--){\n\t\tfor(int k = i;k >= 0;k--){\n\t\t\tfor(int lst = 0;lst < 2;lst++){\n\t\t\t\tfor(int fl = 0;fl < 2;fl++){\n\t\t\t\t\tint ret = 0, tfl = fl || (i - k) >= b;\n\t\t\t\t\tif(!lst){\n\t\t\t\t\t\tret = pref[i + 1][k][tfl][1];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(a + i <= n){\n\t\t\t\t\t\t\tret = pref[a + i][k][tfl][0];\n\t\t\t\t\t\t\tret = add(ret, sub(pos_pref[i + 1][tfl][0], pos_pref[a + i][tfl][0]));\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tret = pos_pref[i + 1][tfl][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][k][fl][lst] = ret;\n\t\t\t\t\tpref[i][k][fl][lst] = add(pref[i + 1][k][fl][lst], dp[i][k][fl][lst]);\n\t\t\t\t\tif(i == k){\n\t\t\t\t\t\tpos_pref[i][fl][lst] = add(dp[i][i][fl][lst], pos_pref[i + 1][fl][lst]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tif(a > b) swap(a, b);\n\tdinamika();\n\tprintf(\"%d\\n\", add(dp[0][0][0][0], dp[0][0][0][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//快速幂2（数字较大）：\n#include<bits/stdc++.h>\nusing namespace std;\nlong long k=1000000007;\nlong long f(long long n,long long m)\n{\n    if(m==0)return 1;\n    else if(m==1)return n%k;\n    else if(m%2==0)return f((n%k)*(n%k),m/2)%k;//偶数时的降幂\n    return f((n%k)*(n%k),m/2)*(n%k)%k;//奇数时的降幂\n}\nint main()\n{\n    long long n,m;\n    cin>>m;\n    cout<<f(2,m);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 5100;\nconst ll MOD = 1e9 + 7;\n\nint N;\nint A, B;\n\nll dmod[2][MAXN];\nll dp[2][MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> A >> B;\n    if (A > B) swap (A, B);\n\n    for (int i = 1; i < A; i++)\n        dmod[0][i] = 1;\n\n    dmod[1][1] = 1;\n    for (int i = 2; i <= B; i++)\n    {\n        dmod[1][i] = dmod[1][i-1];\n        for (int j = i - (A + 1); j >= 1; j--)\n            dmod[1][i] = (dmod[1][i] + dmod[1][j]) % MOD;\n    }\n    for (int i = 0; i < B; i++)\n        dp[0][i] = dmod[1][i+1];\n    ll v = dmod[1][B];\n    dmod[1][B] = 0;\n\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = i + 1; j <= N; j++)\n        {\n            for (int k = 0; k < 2; k++)\n            {\n                dp[1-k][j] = (dp[1-k][j] + dp[k][i] * dmod[k][j-i]) % MOD;\n            }\n        }\n    }\n\n    dmod[1][B] = v;\n    for (int i = 0; i <= N; i++)\n        dp[1][N+1] = (dp[1][N+1] + dp[1][i] * dmod[1][N+1-i]) % MOD;\n\n    /*for (int i = 0; i < N; i++)\n    {\n        cout << dp[0][i] << \" \" << dp[1][i] << \"\\n\";\n    }*/\n    ll res = 1;\n    for (int i = 0; i < N; i++)\n        res = (res * 2) % MOD;\n\n    if (B > 1)\n        res = (res - dp[1][N+1] + 2 * MOD) % MOD;\n    cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    ll dp[n+10][n+10];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    ll sum1[n+10];\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    ll sum2[n+10][n+10];\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#include <functional>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<ll, ll, ll, ll> tlglglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<1000000007>;\n\nMint f[5010][2];\nMint dp[5010][2];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, A, B;\n    cin >> N >> A >> B;\n    if (A > B) {\n        swap(A, B);\n    }\n    Mint ans = 0;\n    if (B >= 2) {\n        f[0][0] = 1;\n        f[0][1] = 1;\n        REP(i, 1, N + 1) {\n            REP(k, 0, 2) {\n                REP(j, 1, i + 1) {\n                    if (k == 0 && j < A) {\n                        continue;\n                    }\n                    f[i][k] += f[i - j][k ^ 1];\n                }\n            }\n        }\n        V<Mint> g(N + 1);\n        g[0] = 1;\n        REP(i, 1, N + 1) {\n            g[i] = f[i][0] + f[i][1];\n        }\n\n        REP(i, 1, N) {\n            if (i < A) {\n                dp[i][0] += 1;\n            }\n            REP(j, 1, min(i, A)) {\n                dp[i][0] += dp[i - j][1];\n            }\n            if (i < B) {\n                dp[i][1] += g[i - 1];\n            }\n            REP(j, 1, min(i, B)) {\n                Mint w = (j == 1)? 1: g[j - 2];\n                dp[i][1] += dp[i - j][0] * w;\n            }\n            if (N - i < B) {\n                ans += dp[i][0] * g[N - i - 1];\n            }\n            if (N - i < A) {\n                ans += dp[i][1];\n            }\n        }\n    }\n\n    cout << Mint(2).pow(N) - ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define ktya(x) sort(all(x))\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 1e18\n#define INFLL 1000000000000000007LL\n#define SIZE 200105\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define PI (acos(-1))\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\ntypedef pair<pill,int> PA;\nll MOD = 1000000007;\n// ll MOD=998244353;\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tll weight;\n};\nint N,A,B;\nll dp[5010][2][5010]={0};\n\nll DP0[5050]={0};\nll DP1[5050]={0};\nll  nums[5050]={0};\nll numshashi[5050]={0};\nll powMod(ll x, ll k, ll m) {//x^k (mod n)\n\tif (k == 0)     return 1;\n\tif (k % 2 == 0) return powMod(x*x % m, k/2, m);\n\telse            return x*powMod(x, k-1, m) % m;\n}\n\n\nint main(){\n\tcin>>N>>A>>B;\n\tif(A>B)swap(A,B);\n\t//できないやつをカウント 2^Nから引く\n\tdp[1][0][1]=1;\n\tdp[1][1][1]=1;\n\t//1 k個の中にl個の0が並ぶ場合の数 nums\n\t// numeach[i][j] iまでのj個\n\tnums[1]=1;\n\tnumshashi[1]=1;\n\tfor(int i=2;i<B;i++){\n\t\tnums[i]=nums[i-1];\n\t\t/*for(int j=A;j<=i-1;j++){\n\t\t\tnums[i]+=nums[i-j];\n\t\t\tnums[i]%=MOD;\n\t\t}*/\n\t\tfor(int j=A;j<=i-2;j++){\n\t\t\tnums[i]+=nums[i-j-1];\n\t\t}\n\t\t//cout<<nums[i]<<endl;\n\t}\n\n\n\tfor(int i=2;i<B;i++){\n\t\tnumshashi[i]=numshashi[i-1];\n\t\tfor(int j=A;j<=i-1;j++){\n\t\t\tnumshashi[i]+=nums[i-j];\n\t\t\tnumshashi[i]%=MOD;\n\t\t}\n\t\t//cout<<numshashi[i]<<endl;\n\t}\n\n\t//後ろに並んでいる連続する文字ごとにDP\n\tDP0[0]=1;\n\tDP0[1]=1;\n\tDP1[0]=1;\n\tDP1[1]=1;\n\t// vector<string> hoge[5000][2][5000];\n\t// hoge[1][0][1].pb('(0start)1');\n\t// hoge[1][1][1].pb('(1start)1');\n\tfor(int i=1;i<=N-1;i++){\n\n\t\tfor(int j=1;j<A;j++){\n\t\t\tif(i+1<j)continue;\n\t\t\tdp[i+1][0][j]=DP1[i+1-j];\n\t\t}\n\t\tif(i!=N-1){\n\t\t\tfor(int j=1;j<B;j++){\n\t\t\t\tif(i+1<j)continue;\n\t\t\t\tif(i+1==j){\n\t\t\t\t\tdp[i+1][1][j]=numshashi[i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][1][j]=(DP0[i+1-j]*nums[j])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=1;j<B;j++){\n\t\t\t\tif(i+1<j)continue;\n\t\t\t\tif(i+1==j){\n\t\t\t\t\tdp[i+1][1][j]=numshashi[i+1];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][1][j]=(DP0[i+1-j]*numshashi[j])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=i+1;j++){\n\t\t\tif(j<A)DP0[i+1]+=dp[i+1][0][j];\n\t\t\tDP0[i+1]%=MOD;\n\t\t}\n\t\n\t\tfor(int j=1;j<=i+1;j++){\n\t\t\tif(j<B)DP1[i+1]+=dp[i+1][1][j];\n\t\t\tDP1[i+1]%=MOD;\n\t\t}\n\t}\n\n\tll sum=powMod(2,N,MOD);\n\tll ans=0;\n\tfor(int i=1;i<=N;i++){\n\t\tans+=dp[N][0][i];\n\t\tans+=dp[N][1][i];\n\t\tans%=MOD;\n\t}\n\tans=(sum-ans+MOD)%MOD;\n\tcout<<ans<<endl;\n\t/*for(int k=1;k<=N;k++){\n\t\tll ans=0;\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tans+=dp[k][0][i];\n\t\t\tans+=dp[k][1][i];\n\t\t\tans%=MOD;\n\t\t\t//cout<<k<<\" \"<<i<<\" \"<<dp[k][0][i]<<\" \"<<dp[k][1][i]<<endl;\n\t\t}\n\t\t//cout<<k<<\" \"<<DP0[k]<<\" \"<<DP1[k]<<\" \"<<ans<<endl;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tcout<<i;\n\t\tfor(int j=1;j<A;j++){\n\t\t\tcout<<\" \"<<dp[i][0][j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\tfor(int i=1;i<=N;i++){\n\t\tcout<<i<<\":\";\n\t\tfor(int j=1;j<B;j++){\n\t\t\tcout<<\" \"<<dp[i][1][j];\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\nconstexpr ll MAX=1e6;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Segment_tree{\n    ll N;\n    vector<pii> node;\n    Segment_tree(ll sz){\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mp(INF,INF));\n        per(i,N-2,0){\n            node[i]=std::min(node[i*2+1],node[i*2+1]);\n        }\n    }\n    void update(ll X,pii val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=std::min(node[X*2+1],node[X*2+2]);\n        }\n    }\n    pii RMQ(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mp(INF,INF);\n        if(a<=l&&r<=b) return node[now];\n        auto vl=RMQ(a,b,now*2+1,l,(l+r)/2),vr=RMQ(a,b,now*2+2,(l+r)/2,r);\n        return std::min(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    A--,B--;\n    if(A<B) std::swap(A,B);\n    vi memo(A+2,1);\n    vii ap(A+1,vi(A+1));\n    ap[0][0]=1;\n    rep(j,0,A-1){\n        rep(k,0,A-1){\n            ap[j+1][k+1]+=ap[j][k];\n            ap[j+1][k+1]%=MOD;\n        }\n        ap[j+1][0]+=ap[j][0];\n        ap[j+1][0]%=MOD;\n        rep(k,B+1,A-1){\n            ap[j+1][0]+=ap[j][k];\n            ap[j+1][0]%=MOD;\n        }\n    }\n    rep(i,0,A){\n        memo[i+2]=0;\n        REP(j,B+1,i){\n            memo[i+2]+=ap[i][j];\n            memo[i+2]%=MOD;\n        }\n        memo[i+2]+=ap[i][0];\n        memo[i+2]%=MOD;\n    }\n    vii dp(N+1,vi(A+1)),cp(N+1,vi(B+1));\n    ll ans=modpow(2,N,MOD);\n    dp[0][0]=1;\n    rep(i,0,N){\n        rep(j,0,A){\n            dp[i+1][j+1]+=dp[i][j];\n            dp[i+1][j+1]%=MOD;\n            if(i==j) cp[i+1][1]+=dp[i][j]*memo[j+1]%MOD;\n            else cp[i+1][1]+=dp[i][j]*memo[j]%MOD;\n            cp[i+1][1]%=MOD;\n        }\n        rep(j,0,B){\n            cp[i+1][j+1]+=cp[i][j];\n            cp[i+1][j+1]%=MOD;\n            dp[i+1][1]+=cp[i][j];\n            dp[i+1][1]%=MOD;\n        }\n        dp[i+1][1]+=cp[i][B];\n        dp[i+1][1]%=MOD;\n        if(i==A) cp[i+1][1]+=dp[i][A]*memo[A+1]%MOD;\n        else cp[i+1][1]+=dp[i][A]*memo[A]%MOD;\n        cp[i+1][1]%=MOD;\n    }\n    REP(i,0,A){\n        ans-=dp[N][i]*memo[i+1]%MOD;\n        ans%=MOD;\n        if(ans<0) ans+=MOD;\n    }\n    REP(i,0,B){\n        ans-=cp[N][i];\n        ans%=MOD;\n        if(ans<0) ans+=MOD;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 5005, mod = 1000000007;\nint n, a, b, mem[MX][MX][2], mem2[MX][MX];\n\nll pot (ll b, int p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n\nvoid sum (int &a, int b) {\n\ta += b;\n\tif (a >= mod) a -= mod;\n}\n\nint dp (int i, int j, int f);\n\nint dp2 (int i, int j) {\n\tif (i < 0) return 0;\n\n\tint &res = mem2[i][j];\n\tif (res != -1) return res;\n\tres = 0;\n\n\tsum(res, dp(i, j, 1));\n\tsum(res, dp2(i - 1, j + 1));\n\n\treturn res;\n}\n\nint dp (int i, int j, int f) {\n\tif (f == 0 && j >= a) return 0;\n\tif (f == 1 && j >= b) return 0;\n\tif (!i) return 1;\n\n\tint &res = mem[i][j][f];\n\tif (res != -1) return res;\n\tres = 0;\n\n\tsum(res, dp(i - 1, j + 1, f));\n\tsum(res, dp(i - 1, 1, f ^ 1));\n\n\tif (i == n || (j && f)) {\n\t\tsum(res, dp2(i - a - 1, j + a + 1));\n\n\t\tif (j && f && i >= a)\n\t\t\tsum(res, dp(0, j + i, f));\n\t}\n\n\treturn res;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(mem, -1, sizeof(mem));\n\tmemset(mem2, -1, sizeof(mem2));\n\n\tcin >> n >> a >> b;\n\tif (a > b) swap(a, b);\n\tcout << MOD(pot(2, n) - dp(n, 0, 0), mod) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=b-1LL;i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nll dp[5050][2];\n\nlong long modpow(long long a, long long b){ \n  long long r = 1LL;\n  while(b){\n    if(b & 1LL)r *= a;\n    if(r >= MOD)r %= MOD;\n    a *= a;\n    if(a >= MOD)a %= MOD;\n    b >>= 1LL;\n  }\n  return r%MOD;\n}\n\nint main(){\n  ll n,a,b;\n  cin>>n>>a>>b;\n  ll all = pow(2,n);\n  if(a==1||b==1){\n    cout << all%MOD << endl;\n    return 0;\n  }\n  clr(dp,0);\n  dp[0][0]=1;\n  dp[0][1]=1;\n  rep(i,1,n){\n    rep(j,0,a-1){\n      if(i+j<5050){\n        dp[i+j][0] += dp[i-1][1];\n        dp[i+j][0] %= MOD;\n      }\n    }\n    rep(j,0,b-1){\n      if(i+j<5050){\n        dp[i+j][1] += dp[i-1][0];\n        dp[i+j][1] %= MOD;\n      }\n    }\n  }\n  ll ans1 = 0;\n  rep(i,0,n){\n    ll d = n-i;\n    if(d<a){\n      ans1 += dp[i][1];\n      ans1 %= MOD;\n    }\n    if(d<b){\n      ans1 += dp[i][0];\n      ans1 %= MOD;\n    }    \n  }\n  cout << (all+MOD-ans1)%MOD << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    ll dp[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)dp[i][j]=0;\n    dp[0][0]=1;\n    ll sum1[n+10];\n    rep(i,0,n+10)sum1[i]=0;\n    sum1[0]=1;\n    ll sum2[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)sum2[i][j]=0;\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint mod = 1000000007;\n\nstruct mint {\n    int value;\n    constexpr mint() : value() {}\n    mint(const long &x) {\n        value = normalize(x);\n    }\n    static long normalize(const long &x) {\n        long v = x % mod;\n        if (v < 0) v += mod;\n        return v;\n    }\n    bool operator==(const mint &x) { return value == x.value; };\n    mint operator+(const mint &x) { return value + x.value; };\n    mint operator*(const mint &x) { return (long)value * x.value; };\n    void operator+=(const mint &x) { value = normalize(value + x.value);};\n    void operator-=(const mint &x) { value = normalize(value - x.value);};\n};\n\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a < b) swap(a, b);\n    vector<vector<mint>> d(n + 1, vector<mint>(n + 1));\n    vector<vector<mint>> d2(n + 3, vector<mint>(n + 3));\n    vector<vector<mint>> d3(n + 3, vector<mint>(n + 3));\n    d[0][0] = 1;\n    vector<mint> p2(n + 1);\n    p2[0] = 1;\n    for (int i = 0; i < n; i++) {\n        p2[i + 1] = p2[i] * 2;\n    }\n    mint res = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n//            cout << i << \" \" << j << \" \" << d[i][j].value << \"\\n\";\n            d2[i + 1][j] += d2[i][j];\n            d3[i + 1][j + 1] += d3[i][j];\n            d[i][j] += d2[i][j];\n            d[i][j] += d3[i][j];\n            if (d[i][j] == 0) continue;\n            if (j >= a) {\n                res += d[i][j] * p2[n - i];\n                continue;\n            } else {\n                if ((n - i) >= b && j + (n - i) >= a) {\n                    res += d[i][j];\n                }\n            }\n            if (i < n) {\n                d[i + 1][j + 1] += d[i][j];\n            }\n            {\n                int l = 1;\n                int r = min(b, n - i);\n                if (r > l) {\n                    d2[i + l + 1][1] += d[i][j];\n                    d2[i + r + 1][1] -= d[i][j];\n                }\n            }\n            {\n                int l = b;\n                int r = n - i;\n                if (r > l) {\n                    d3[i + l + 1][j + l + 1] += d[i][j];\n                    d3[i + r + 1][j + r + 1] -= d[i][j];\n                }\n            }\n        }\n    }\n    cout << res.value << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nconst int mod = 1e9 + 7;\nint n, l[2], p[5100], dp[3][5100][5100], ps[5100];\n\nint add(int a, int b) {\n  a += b;\n  if (a >= mod)\n    a -= mod;\n  return a;\n}\n\nint sub(int a, int b) {\n  a -= b;\n  if (a < 0)\n    a += mod;\n  return a;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n >> l[0] >> l[1];\n  p[0] = 1;\n  for (int i = 0; i < n; i++)\n    p[i + 1] = add(p[i], p[i]);\n  if (l[0] < l[1])\n    swap(l[0], l[1]);\n  int res = 0;\n  dp[0][0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    ps[i + 1] = add(ps[i + 1], ps[i]);\n    dp[1][i][0] = add(dp[1][i][0], ps[i]);\n    for (int j = 0; j <= i && j < l[0]; j++) {\n      dp[0][i + 1][j + 1] = add(dp[0][i + 1][j + 1], dp[0][i][j]);\n      dp[0][i + 1][j + 1] = add(dp[0][i + 1][j + 1], dp[1][i][j]);\n      dp[0][i + 1][j + 1] = add(dp[0][i + 1][j + 1], dp[2][i][j]);\n      dp[2][i + 1][j + 1] = add(dp[2][i + 1][j + 1], dp[2][i][j]);\n      if (i + l[1] <= n)\n        dp[2][i + l[1]][j + l[1]] = add(dp[2][i + l[1]][j + l[1]], dp[0][i][j]);\n      ps[i + 1] = add(ps[i + 1], dp[0][i][j]);\n      if (i + l[1] <= n)\n        ps[i + l[1]] = sub(ps[i + l[1]], dp[0][i][j]);\n    }\n  }\n  for (int k = 0; k < 3; k++)\n    for (int i = 0; i <= n; i++)\n      for (int j = l[0]; j <= n; j++)\n        res = add(res, ((ll) dp[k][i][j] * p[n - i]) % mod);\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 5005;\n\nconst int MOD = 1000000007;\n\ninline int sub(int a, int b)\n{\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nconst int OK = 0;\n\ninline int RUN(int last, int tlen)\n{\n\treturn 1 + (last * maxn + tlen);\n}\n\nint dp[maxn][2 * maxn + 100];\nint n, A, B;\n\ninline void upd(int &a, int b)\n{\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tA = min(A, n);\n\tif (A > B) swap(A, B);\n\tdp[0][RUN(1, 0)] = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int last = 0; last < 2; last++)\n\t\t{\n\t\t\tfor (int tlen = 0; tlen <= n; tlen++)\n\t\t\t{\n\t\t\t\tint curans = dp[i][RUN(last, tlen)];\n\t\t\t\t//cout << i << ' ' << last << ' ' << tlen << ' ' << curans << endl;\n\t\t\t\tif (tlen >= B)\n\t\t\t\t{\n\t\t\t\t\tupd(dp[i][OK], curans);\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif (last == 0 && tlen == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tupd(dp[i + 1][RUN(0, 0)], curans);\n\t\t\t\t\t\tupd(dp[i + 1][RUN(1, 1)], curans);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tupd(dp[i + 1][RUN(last, tlen + 1)], curans);\n\t\t\t\t\t\tif (last == 0) upd(dp[i + 1][RUN(1, tlen + 1)], curans);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (i + A <= n)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tupd(dp[i + A][RUN(0, tlen + A)], curans);\n\t\t\t\t\t\t\t\tupd(dp[i + 1][RUN(0, 0)], curans);\n\t\t\t\t\t\t\t\tupd(dp[i + A][RUN(0, 0)], sub(MOD, curans));\n\t\t\t\t\t\t\t} else // does not fit anyway\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tupd(dp[i + 1][RUN(1, 0)], curans);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << dp[3][RUN(0, 2)] << endl;\n\t\t\t}\n\t\t}\n\n\t\t//cout << i << \" OK \" << dp[i][OK] << endl;\n\n\t\tupd(dp[i + 1][OK], dp[i][OK]);\n\t\tupd(dp[i + 1][OK], dp[i][OK]);\n\t}\n\t\n\tprintf(\"%d\\n\", dp[n][OK]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAX=5005,mod=1e9+7,inf=0x3f3f3f3f;\n\ntypedef pair < ll, ll > ii;\nint f[MAX][MAX][2],F[MAX][MAX][2],cnt[MAX];\n#define X first\n#define Y second\n#define pb push_back\n//vector < int > pr[MAX];\nint n,m;\n//ll a[MAX];\nint A,B;\nint get(int a,int b){\n    a+=b;if(a>=mod) a-=mod;return a;\n}\nint main()\n{\n    //memset(ST,0,sizeof ST);\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"45C.inp\",\"r\",stdin);freopen(\"45C.out\",\"w\",stdout);\n    cin>>n;\n    cin>>A>>B;\n    //cout<<mod*2;\n    if(A>B) swap(A,B);\n    ll ans=1;\n    f[0][0][1]=1;\n    f[0][0][0]=1;\n    cnt[0]=1;\n    F[0][0][0]=1;\n    F[0][0][1]=1;\n    for(int i=1;i<=n;i++){ans=ans<<1;if(ans>=mod) ans-=mod;}\n    for(int i=1;i<=n;i++){\n        if(i>=A) f[i][0][0]=(cnt[i-1]-cnt[i-A]+mod)%mod;\n        else f[i][0][0]=cnt[i-1];\n        F[i][i][0]=get( F[i-1][i][0],f[i][0][0] );\n        for(int j=1,ma=min(B-1,i);j<=ma;j++){\n            //for(int u=A;u<j;u++) f[i][j][0]+=f[i-u][j-u][1];\n            if(i>=A) f[i][j][0]=F[i-A][i-j][1];\n\n            F[i][i-j][0]=get( F[i-1][i-j][0],f[i][j][0] );\n        }\n        for(int j=1,ma=min(B-1,i);j<=ma;j++){\n            //for(int u=1;u<=j;u++) f[i][j][1]+=f[i-u][j-u][0];\n\n            f[i][j][1]=F[i-1][i-j][0];\n\n            F[i][i-j][1]=get(F[i-1][i-j][1],f[i][j][1]);\n            cnt[i]=get(f[i][j][1],cnt[i]);\n        }\n        cnt[i]=get(cnt[i-1],cnt[i]);\n    }\n    ll temp=0;\n    for(int j=0;j<B;j++){\n        temp=(temp+f[n][j][1]+f[n][j][0])%mod;\n        //cout<<j<<' '<<f[n][j][1]<<' '<<f[n][j][0]<<'\\n';\n    }\n    cout<<(ans-temp+mod)%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5050, mod = 1e9 + 7;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint dp[N], dp2[N][2], cnt[N], ujung[N];\n\nint a, b;\n\nvoid upd(int & var, int val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  memset(dp, 0, sizeof dp);\n  int n;\n  scanf(\"%d %d %d\", &n, &a, &b);\n  if (a > b)\n    swap(a, b);\n  dp[0] = 2;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j <= n && j - i < b; ++j) {\n      upd(dp[j], dp[i]);\n    }\n  }\n  long long ans = (powmod(2, n) - dp[n]) % mod;\n  if (a < b) {\n    for (int i = 1; i < b; ++i) {\n      upd(cnt[i], 1);\n    }\n    for (int i = 1; i < b; ++i) {\n      for (int j = i+a+1; j < b; ++j) {\n        int add = j - i;\n        upd(cnt[j], 1LL * (add - a) * cnt[i] % mod);\n      }\n    }\n    for (int i = a+1; i < b; ++i) {\n      for (int j = a; j < i; ++j)\n        upd(ujung[i], cnt[i-j]);\n    }\n    for (int i = 1; i < b; ++i) {\n      upd(ujung[i], cnt[i]);\n    }\n    dp2[0][0] = dp2[0][1] = 1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = i+1; j <= n && j - i < a; ++j) {\n        upd(dp2[j][1], dp2[i][0]);\n      }\n      for (int j = i+1; j <= n && j - i < b; ++j) {\n        int cost = (j == n || i == 0) ? ujung[j-i] : cnt[j-i];\n        upd(dp2[j][0], 1LL * cost *  dp2[i][1] % mod);\n      }\n    }\n    ans = (ans + dp[n] - dp2[n][1] - dp2[n][0]) % mod;\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef CLASS_MODINT\n#define CLASS_MODINT\n\n#include <cstdint>\n\ntemplate <std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};\n\tstatic constexpr std::uint32_t get_mod() { return mod; }\n\tstd::uint32_t get() const { return n; }\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint inv() const { return (*this).pow(mod - 2); }\n\tmodint pow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n#endif // CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nusing mint = modint<1000000007>;\nint main() {\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif (A < B) swap(A, B);\n\tvector<vector<mint> > dp(N + 1, vector<mint>(2 * N + 1)); // (pos, cont)\n\tfor (int i = 0; i <= N; ++i) {\n\t\tmint g = mint(2).pow(N - i);\n\t\tfor (int j = A; j <= 2 * N; ++j) {\n\t\t\tdp[i][j] = g;\n\t\t}\n\t}\n\tvector<mint> sum_line1(N + 2);\n\tsum_line1[N] = dp[N][1];\n\tvector<vector<mint> > sum_line45(N + 2, vector<mint>(2 * N + 2));\n\tfor (int i = N; i >= 0; --i) {\n\t\tfor (int j = 2 * N; j >= A; --j) {\n\t\t\tsum_line45[i][j] = sum_line45[i + 1][j + 1] + dp[i][j];\n\t\t}\n\t}\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\tfor (int j = 0; j < A; ++j) {\n\t\t\t// next = A\n\t\t\tdp[i][j] += dp[i + 1][j + 1];\n\t\t\t// next = BA, BBA, BBBA, ...\n\t\t\tif (min(N - i, B) >= 2) {\n\t\t\t\tdp[i][j] += sum_line1[i + 2] - sum_line1[i + min(N - i, B) + 1];\n\t\t\t}\n\t\t\tif (N - i >= B + 1) {\n\t\t\t\tdp[i][j] += sum_line45[i + (B + 1)][j + (B + 1)] - sum_line45[i + (N - i) + 1][j + (N - i) + 1];\n\t\t\t}\n\t\t\t// next = BBBBB...\n\t\t\tif (N - i >= B && j + N - i >= A) {\n\t\t\t\tdp[i][j] += 1;\n\t\t\t}\n\t\t\tsum_line45[i][j] = sum_line45[i + 1][j + 1] + dp[i][j];\n\t\t}\n\t\tsum_line1[i] = sum_line1[i + 1] + dp[i][1];\n\t}\n\tcout << dp[0][0].get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=5e3+7;\nconst int mod=1e9+7;\nint f[maxn][2];\nint dp[maxn][2];\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint a,b;\n\tcin>>a>>b;\n\tif(a>b) swap(a,b);\n\tdp[0][0]=dp[0][1]=1;\n\tf[0][1]=1;\n\tfor(int i=0;i<=b+1;i++)\n\t{\n\t\tfor(int j=a;i+j<=b+1;j++)\n\t\t\tf[i+j][1]=(f[i+j][1]+f[i][0])%mod;\n\t\tfor(int j=1;i+j<=b+1;j++)\n\t\t\tf[i+j][0]=(f[i+j][0]+f[i][1])%mod;\n\t\t//dbg(i,f[i][0],f[i][1]);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=1;j<a&&i+j<=n;j++)\n\t\t\tdp[i+j][0]=(dp[i+j][0]+dp[i][1])%mod;\n\t\tfor(int j=1;j<b&&i+j<=n;j++)\n\t\t{\n\t\t\tdp[i+j][1]=(dp[i+j][1]+(ll)dp[i][0]*f[j+(i==0)+(i+j==n)][0]%mod)%mod;\n\t\t}\n\t//\tdbg(i,dp[i][0],dp[i][1]);\n\t}\n\tint tot=1;\n\tfor(int i=1;i<=n;i++) tot=tot*2%mod;\n\tprint((tot-(dp[n][0]+dp[n][1])%mod+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nint n, a, b;\n\nvector<string> moves(string s, int a, int b) {\n\tvector<string> rez;\n\t// for (int i = 0; i <= le(s) - a; i++) {\n\t\tfor (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < a; k++) {\n\t\t\t// \tt[i + k] = '0';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\tt[j + k] = '1';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t}\n\t// }\n\tfor (int i = 0; i <= le(s) - a; i++) {\n\t\t// for (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < b; k++) {\n\t\t\t// \tt[j + k] = '1';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tt[i + k] = '0';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t// }\n\t}\n\treturn rez;\n}\n\nint bfs(int n, int a, int b) {\n\tdeque<string> deq{string(n, '0')};\n\tset<string> used;\n\twhile (!deq.empty()) {\n\t\tstring s = deq[0];\n\t\tdeq.pop_front();\n\t\tif (used.count(s)) continue;\n\t\tused.insert(s);\n\t\tfor (string t : moves(s, a, b)) {\n\t\t\tdeq.pb(t);\n\t\t}\n\t}\n\t// for (string s : used) {\n\t// \tif (s.back() == '1' && s[le(s) - 2] == '0') {\n\t// \t\tprint s;\n\t// \t}\n\t// }\n\t// print used;\n\treturn le(used);\n}\n\nint mem[2][5010][5010];\nint smem[5010][5010];\nnum dp(int, int, bool);\nnum dpsum(int n, int l) {\n\tif (n < 0) return 0;\n\tif (smem[n][l] != -1) return smem[n][l];\n\tsmem[n][l] = (dp(n, l, false) + dpsum(n - 1, l + 1)).value;\n\treturn smem[n][l];\n}\nint md[5010];\nnum dpref(int n) {\n\tif (n < 0) return 0;\n\tif (md[n] != -1) return md[n];\n\tmd[n] = (dp(n, 0, false) + dpref(n - 1)).value;\n\treturn md[n];\n}\nnum dp(int n, int l, bool can_one) {\n\tif (n < 0) return 0;\n\tif (n == 0) return l >= a;\n\tif (mem[can_one][n][l] != -1) return mem[can_one][n][l];\n\tnum rez = 0;\n\tif (l >= a) {\n\t\trez = num(2).pow(n + can_one - 1);\n\t} else {\n\t\tif (can_one) {\n\t\t\trez += dpref(n - 1) - dpref(n - b);\n\t\t\trez += dpsum(n - b, l + b);\n\t\t}\n\t\trez += dp(n - 1, l + 1, true);\n\t}\n\tmem[can_one][n][l] = rez.value;\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tmemset(smem, -1, sizeof smem);\n\tmemset(md, -1, sizeof md);\n\tscan n, a, b;\n\tif (a < b) swap(a, b);\n\tprint dp(n, 0, true);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const ll mod=1000000007;\nll modpow(ll x,ll y){\nif(y==0){\nreturn 1;\n}else if(y%2==0){\nll z=modpow(x,y/2);\n  return (z*z)%mod;\n}else{\nll z=modpow(x,y/2);\n  return (x*((z*z)%mod))%mod;\n}\n}\nll N,A,B;\nll dp[2][5005][5005];\nll sum[5005];\nint main(){\n  cin>>N>>A>>B;\n  if(A<B)swap(A,B);\n  dp[1][0][0]=1;dp[0][0][0]=0;sum[0]=1;\n  for(ll i=1;i<=N;i++){\n    for(ll j=0;j<=min(i,A-1);j++){\n    if(j!=0){\n    dp[1][i][j]=(dp[1][i-1][j-1]+dp[0][i-1][j-1])%mod;\n      if(B<j)\n      dp[0][i][j]=dp[0][i-1][j-1];\n      if(0<=j-B)\n        dp[0][i][j]=(dp[0][i][j]+dp[1][i-B][j-B])%mod;\n     \n    }else{\n   dp[0][i][0]=(sum[i-1]+dp[0][i-1][0])%mod;\n      if(0<=i-B)\n        dp[0][i][0]=(dp[0][i][0]-sum[i-B]+mod)%mod;\n    \n    }\n    \n    \n    }ll a=0;\n    for(ll j=0;j<=A-1;j++)\n      a=(a+dp[1][i][j])%mod;\n    sum[i]=a;\n  }ll ans=0;\n  for(ll j=0;j<=A-1;j++)\n    ans=(ans+dp[1][N][j]+dp[0][N][j])%mod;\n  ans=(mod-ans)%mod;\n  ans+=modpow(2,N);ans%=mod;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntemplate<typename T1,typename T2> bool chmin(T1 &a,T2 b){if(a<=b)return 0; a=b; return 1;}\ntemplate<typename T1,typename T2> bool chmax(T1 &a,T2 b){if(a>=b)return 0; a=b; return 1;}\nint dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};\nlong double eps = 1e-9;\nlong double pi = acos(-1);\n\nint dp[5001][2][5001][2];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int mod = 1e9+7;\n    int n,a,b;\n    cin>>n>>a>>b;\n    if(a<b)swap(a,b);\n    if(a==1||b==1){\n        ll ans = 1;\n        for(int i=0;i<n;i++){\n            ans *= 2LL;\n            ans %= mod;\n        }\n        cout << ans << endl;\n        return 0;\n    }\n    dp[0][0][1][0]=1;\n    dp[0][1][1][0]=1;\n    for(int i=1;i<n;i++){\n        for(int j=1;j<=i;j++){\n            // 0 -> 0\n            dp[i][0][j+1][1] += dp[i-1][0][j][1];\n            dp[i][0][j+1][1] %= mod;\n            if(j+1<a){\n                dp[i][0][j+1][0] += dp[i-1][0][j][0];\n                dp[i][0][j+1][0] %= mod;\n            }\n            else if(j+1==a){\n                dp[i][0][j+1][1] += dp[i-1][0][j][0];\n                dp[i][0][j+1][1] %= mod;\n            }\n\n            // 1 -> 1\n            dp[i][1][j+1][1] += dp[i-1][1][j][1];\n            dp[i][1][j+1][1] %= mod;\n            if(j+1<b){\n                dp[i][1][j+1][0] += dp[i-1][1][j][0];\n                dp[i][1][j+1][0] %= mod;\n            }\n            else if(j+1==b){\n                dp[i][1][j+1][1] += dp[i-1][1][j][0];\n                dp[i][1][j+1][1] %= mod;\n            }\n\n            // 1 -> 0\n            if(j>=b || i-j>=a || n-i>=a){\n                dp[i][0][1][1] += dp[i-1][1][j][1];\n                dp[i][0][1][1] %= mod;\n                if(j<b){\n                    dp[i][0][1][0] += dp[i-1][1][j][0];\n                    dp[i][0][1][0] %= mod;\n                }\n            }\n\n            // 0 -> 1\n            if(j>=a || i-j>=b || n-i>=b){\n                dp[i][1][1][1] += dp[i-1][0][j][1];\n                dp[i][1][1][1] %= mod;\n                if(j<a){\n                    dp[i][1][1][0] += dp[i-1][0][j][0];\n                    dp[i][1][1][0] %= mod;\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    ll rem = 0;\n    for(int i=1;i<=n;i++){\n        ans += dp[n-1][1][i][1];\n        ans %= mod;\n        ans += dp[n-1][0][i][1];\n        ans %= mod;\n\n        rem += dp[n-1][1][i][0];\n        rem += dp[n-1][0][i][0];\n        rem %= mod;\n    }\n    // できないものも数えている。\n    // \n\n    cout << ans << endl;\n    cerr << rem << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// C.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 5050, mod = 1e9 + 7;\n\nint n, A, B, bin[MAX_N], dp[MAX_N][MAX_N], f[MAX_N][MAX_N], pre[MAX_N];\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &A, &B);\n    for (int i = bin[0] = 1; i <= n; i++)\n        bin[i] = 2LL * bin[i - 1] % mod;\n    if (A < B)\n        swap(A, B);\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i++)\n    {\n        if (i != 0)\n            pre[i] = (0LL + pre[i] + pre[i - 1]) % mod;\n        dp[i][1] = (0LL + dp[i][1] + pre[i]) % mod;\n        for (int j = 1; j <= A; j++)\n        {\n            dp[i][j] = (0LL + dp[i][j] + f[i][j]) % mod;\n            f[i + 1][min(j + 1, A)] = (0LL + f[i + 1][min(j + 1, A)] + f[i][j]) % mod;\n        }\n        if (i == n)\n            break;\n        for (int j = 0; j <= A - 1; j++)\n        {\n            dp[i + 1][j + 1] = (0LL + dp[i + 1][j + 1] + dp[i][j]) % mod;\n            pre[i + 2] = (0LL + pre[i + 2] + dp[i][j]) % mod;\n            if (i + B + 1 <= n)\n            {\n                pre[i + B + 1] = (0LL + pre[i + B + 1] + mod - dp[i][j]) % mod;\n                f[i + B + 1][min(j + B + 1, A)] = (0LL + f[i + B + 1][min(j + B + 1, A)] + dp[i][j]) % mod;\n            }\n            if (n - i >= B)\n                dp[n][min(j + n - i, A)] = (0LL + dp[n][min(j + n - i, A)] + dp[i][j]) % mod;\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n        ans = (0LL + ans + 1LL * dp[i][A] * bin[n - i] % mod) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept {\n        lint v;\n        is >> v;\n        x = v;\n        return is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\nconstexpr int MOD = 1000000007;\nusing mint = ModInt<MOD>;\n\nvoid solve() {\n    int n, a, b;\n    std::cin >> n >> a >> b;\n\n    if (a > b) std::swap(a, b);\n    // a <= b\n\n    // the previous digit is 0?\n    // index\n    // the number of continuous 1s\n    auto dp = vec(2, vec(n + 1, vec(b, mint(0))));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int o = 0; o < b; ++o) {\n            // don't put any 0s\n            for (int zp = 0; zp < 2; ++zp) {\n                if (o + 1 < b) dp[0][i + 1][o + 1] += dp[zp][i][o];\n            }\n\n            // put z 0s\n            for (int z = 1; i + z <= n; ++z) {\n                int no = (z < a ? 0 : o + z);\n                if (no >= b) continue;\n                dp[1][i + z][no] += dp[0][i][o];\n            }\n        }\n    }\n\n    mint out = 0;\n    for (int zp = 0; zp < 2; ++zp) {\n        for (int o = 0; o < b; ++o) {\n            out += dp[zp][n][o];\n        }\n    }\n\n    std::cout << mint(2).pow(n) - out << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"}\"; return os; }\n\n\n// 剰余演算クラス\nstruct ModInt{\n    static const LL MOD = 1e+9 + 7;\n    LL v;\n    ModInt():v(0){}\n    ModInt(LL op):v(op){}\n    ModInt operator+(ModInt op) const{ return (v + op) % MOD; }\n    ModInt operator-(ModInt op) const{ return (v - op + MOD) % MOD; }\n    ModInt operator*(ModInt op) const{ return (v * op) % MOD; }\n    ModInt operator/(ModInt op) const{ return (v * op.inverse()) % MOD; }\n    ModInt operator%(LL op) = delete;\n    ModInt operator+=(ModInt op){ return v = (v + op) % MOD; }\n    ModInt operator-=(ModInt op){ return v = (v - op + MOD) % MOD; }\n    ModInt operator*=(ModInt op){ return v = (v * op) % MOD; }\n    ModInt operator/=(ModInt op){ return v = (v * op.inverse()) % MOD; }\n    ModInt operator-() const{ return MOD - v; }\n    bool operator==(ModInt op) const{ return v == op.v; }\n    bool operator!=(ModInt op) const{ return v != op.v; }\n    ModInt inverse() const{ return pow(MOD-2); }\n    ModInt pow(LL n) const{\n        if(n < 0) return pow(MOD-1 + n);\n        if(n == 0) return 1;\n        ModInt res = pow(n/2);\n        return res * res * ((n&1)?ModInt(v): ModInt(1));\n    }\n    LL get() const{ return v; }\nprivate:\n    operator LL() const{ return v; }\n};\nistream& operator>>(istream& st, ModInt& m){ st>>m.v; return st; }\nostream& operator<<(ostream& st, const ModInt& m){ st<<m.v; return st; }\n\n\nvector<ModInt> factorial(LL n){\n    vector<ModInt> res(n, 1);\n    for(LL i = 2; i < n; ++i) res[i] = res[i-1] * ModInt(i);\n    return res;\n}\n\nModInt permutation(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m);\n}\n\nModInt combination(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m) / factorial.at(m);\n}\n\n\nint main(){\n    LL n, a, b;\n    cin >> n >> a >> b;\n    if(a > b) swap(a, b);\n    vector<ModInt> part_cnt(b+1);\n    for(LL a_cnt = 0; a_cnt <= b; ++a_cnt){\n        ModInt cnt = 1;\n        LL base = 1 + (a+1)*a_cnt;\n        for(LL len = base; len <= b; ++len){\n            part_cnt[len] += cnt;\n            cnt *= ModInt(a_cnt*2 + 1 + len - base);\n            cnt /= ModInt(1 + len - base);\n        }\n    }\n    //cerr << part_cnt << endl;\n    vector<ModInt> dp_b(n+1), dp_a(n+1);\n    dp_a[0] = ModInt(1);\n    dp_b[0] = ModInt(1);\n    for(LL i = 0; i < n; ++i){\n        for(LL len = 1; len < a; ++len){\n            if(i+len >= n+1) break;\n            dp_a[i+len] += dp_b[i];\n        }\n        for(LL len = 1; len < b; ++len){\n            if(i+len >= n+1) break;\n            if(i == 0 || i+len == n){\n                dp_b[i+len] += part_cnt[len+1] * dp_a[i];\n            }else{\n                dp_b[i+len] += part_cnt[len] * dp_a[i];\n            }\n        }\n    }\n    cout << ModInt(2).pow(n) - dp_a[n] - dp_b[n] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5050, mod = 1e9 + 7;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint dp[N], dp2[N][2], cnt[N], ujung[N];\n\nint a, b;\n\nvoid upd(int & var, int val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  memset(dp, 0, sizeof dp);\n  int n;\n  scanf(\"%d %d %d\", &n, &a, &b);\n  if (a > b)\n    swap(a, b);\n  dp[0] = 2;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j <= n && j - i < b; ++j) {\n      upd(dp[j], dp[i]);\n    }\n  }\n  long long ans = (powmod(2, n) - dp[n]) % mod;\n  // cerr << ans << endl;\n  if (a < b) {\n    for (int i = 1; i < b; ++i) {\n      upd(cnt[i], 1);\n    }\n    for (int i = 1; i < b; ++i) {\n      for (int j = i+a+1; j < b; ++j) {\n        int add = j - i;\n        upd(cnt[j], 1LL * (add - a) * cnt[i] % mod);\n      }\n      // cerr << i << \" cnt \" << cnt[i] << endl;\n    }\n    for (int i = a+1; i < b; ++i) {\n      for (int j = a; j < i; ++j)\n        upd(ujung[i], cnt[i-j]);\n    }\n    for (int i = 1; i < b; ++i) {\n      upd(ujung[i], cnt[i]);\n      // cerr << \" ujung \" << i << \" \" << ujung[i] << endl;\n    }\n    dp2[0][0] = dp2[0][1] = 1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = i+1; j <= n && j - i < a; ++j) {\n        upd(dp2[j][1], dp2[i][0]);\n      }\n      for (int j = i+1; j <= n && j - i < b; ++j) {\n        int cost = (j == n || i == 0) ? ujung[j-i] : cnt[j-i];\n        upd(dp2[j][0], 1LL * cost *  dp2[i][1] % mod);\n      }\n      // cerr << dp2[i][0] << \" \" << dp2[i][1] << endl;\n    }\n    // cerr << dp2[n][0] << \" \" << dp2[n][1] << endl;\n    ans = (ans + dp[n] - dp2[n][1] - dp2[n][0]) % mod;\n    // for (int i = a+1; i < b; ++i) {\n    //   upd(ujung[n-i], mod - cnt[n-i]);\n    //   ans = (ans - ujung[n-i]) % mod;\n    // }\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,A,B;\n\nconst ll mo=1000000007;\nll p2[5050];\n\nll from[5050];\nll to[5050];\n\nll dp[5050][5050][2];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,5010) p2[i+1]=p2[i]*2%mo;\n\t\n\t\n\tcin>>N>>A>>B;\n\tif(A>B) swap(A,B);\n\t\n\tdp[0][0][0]=1;\n\tFOR(i,N) {\n\t\tFOR(j,N+1) {\n\t\t\tif(j>=B) {\n\t\t\t\t(dp[i+1][B][0]+=dp[i][j][0]*2)%=mo;\n\t\t\t\t(dp[i+1][B][0]+=dp[i][j][1]*2)%=mo;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(dp[i+1][j+1][0]+=dp[i][j][1])%=mo;\n\t\t\t\t(dp[i+1][j+1][1]+=dp[i][j][1])%=mo;\n\t\t\t\t// B\n\t\t\t\t(dp[i+1][j+1][0]+=dp[i][j][0])%=mo;\n\t\t\t\t// A\n\t\t\t\tif(dp[i][j][0]) {\n\t\t\t\t\tfor(x=1;i+x+1<=N&&x<A;x++) if(dp[i][j][0]) {\n\t\t\t\t\t\t(dp[i+x+1][1][0]+=dp[i][j][0])%=mo;\n\t\t\t\t\t}\n\t\t\t\t\tif(i+A<=N) (dp[i+A][min(B,j+A)][1]+=dp[i][j][0])%=mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<(dp[N][B][0]+dp[N][B][1])%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n\nint main(){\n\t// ごめんなさい、nosub撤退はしないと誓ったんです\n\t// なんかぎりぎりレートが上がりそうだったし、ほんの出来心だったんです\n\t// 上位の人のパフォを上げるためだと思って現実逃避します\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int mod = 1e9 + 7;\n\ninline int Mod(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\n\nint f[5010];\nint g[5010];\nint P[5010];\nint M[5010];\nint F[2][5010];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tint n = ri, A = ri, B = ri, res = 1;\n\tfor(int i = 1; i <= n; i++) res = Mod(res << 1);\n\tif(A == 1 || B == 1) return printf(\"%d\\n\", res), 0;\n\tif(A > B) swap(A, B);\n\tf[0] = 1, g[0] = 1;\n\tfor(int i = A; i < B; i++) {\n\t\tf[i] = Mod(f[i - 1] + g[i - 1]);\n\t\tfor(int j = A; j <= i; j++)\n\t\t\tAdd(g[i], f[i - j]);\n\t}\n\n\tfor(int i = 1; i < B; i++)\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tP[i] = (P[i] + 1LL * g[i - j] * (i == j ? 1 : j)) % mod;\n\tfor(int i = 1; i < B; i++)\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tM[i] = (M[i] + 1LL * g[i - j] * (i == j ? 1 : j - 1)) % mod;\n\n\tF[0][0] = F[1][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j < B; j++) {\n\t\t\tif(i == j || i == n) {\n\t\t\t\tF[1][i] = (F[1][i] + 1LL * F[0][i - j] * P[j]) % mod;\n\t\t\t\tif(i == j) break;\n\t\t\t} else F[1][i] = (F[1][i] + 1LL * F[0][i - j] * M[j]) % mod;\n\t\t}\n\t\tfor(int j = 1; j < A; j++) {\n\t\t\tAdd(F[0][i], F[1][i - j]);\n\t\t\tif(i == j) break;\n\t\t}\n\t}\n\n\tcout << Mod(res + mod - Mod(F[0][n] + F[1][n])) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst int kMaxN = 6000;\nconst int mod = 1e9 + 7;\n\ninline void Add(int &x, int y) {\n\tx += y;\n\tif (x >= mod) { x -= mod; }\n}\ninline void Sub(int &x, int y) {\n\tx -= y;\n\tif (x < 0) { x += mod; }\n}\ninline void Mul(int &x, int y) {\n\tx = (ll)x * y % mod;\n}\n\nint PowMod(int a, int n) {\n\tint r = 1;\n\twhile (n) {\n\t\tif (n & 1) { r = (ll)r * a % mod; }\n\t\tn >>= 1;\n\t\ta = (ll)a * a % mod;\n\t}\n\treturn r;\n}\n\nint dp0[kMaxN][kMaxN];\nint dp1[kMaxN][kMaxN];\nint sum_dp0[kMaxN];\nint sum_dp1[kMaxN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif (A > B) { swap(A, B); }\n\n\tdebug() << imie(A) <<imie(B);\n\n\tdp0[0][0] = 1;\n\tsum_dp0[0] = 1;\n\tfor (int n = 1; n <= N; ++n) {\n\t\tfor (int g = 0; g < B && g <= n; ++g) {\n\t\t\tif (n && g) {\n\t\t\t\tAdd(dp0[n][g], dp0[n-1][g-1]);\n\t\t\t\tAdd(dp0[n][g], dp1[n-1][g-1]);\n\t\t\t}\n\t\t\tif (g == 0) {\n\t\t\t\tfor (int k = 1; k < A && n - k >= 0; ++k) {\n\t\t\t\t\tAdd(dp1[n][0], sum_dp0[n - k]);\n\t\t\t\t}\n\t\t\t} else if (g == A) {\n\t\t\t\tdp1[n][A] = dp0[n - A][0];\n\t\t\t} else if (g > A) {\n\t\t\t\tdp1[n][g] = dp1[n - 1][g - 1];\n\t\t\t\tAdd(dp1[n][g], dp0[n - A][g - A]);\n\t\t\t}\n\n\t\t\tdebug() << imie(n) << imie(g) << imie(dp0[n][g]) << imie(dp1[n][g]);\n\n\t\t\tAdd(sum_dp0[n], dp0[n][g]);\n\t\t\tAdd(sum_dp1[n], dp1[n][g]);\n\t\t}\n\t}\n\n\tint res = PowMod(2, N);\n\tSub(res, sum_dp0[N]);\n\tSub(res, sum_dp1[N]);\n\tcout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 5010;\nLL f[MAXN][MAXN];\nLL pot[MAXN];\nconst LL mod = 1e9 + 7;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    pot[0] = 1;\n    for (int i = 1; i < MAXN; i++) pot[i] = 2*pot[i-1] % mod;\n\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n    if (A == 1) {\n        cout << pot[MAXN] << \"\\n\";\n        return 0;\n    }\n    vector<LL> pref(MAXN, 0);\n    vector<vector<LL>> hardpref(MAXN, vector<LL>(MAXN, 0));\n    for (int n = 1; n <= N; n++) {\n        for (int k = 0; k < B; k++) {\n            f[n][k] += f[n-1][k+1];\n            if (k == B-1) f[n][k] += pot[n-1];\n            if (k + n >= B and n >= A) f[n][k]++;\n            f[n][k] += pref[n-1] - ((n-A >= 0)?pref[n-A]:0);\n            // n-1-A, 1+k+A\n            // n-z, k+z\n            int low = 1+A;\n            int high = min(n, B-k-1);\n            if (low <= high) {\n                f[n][k] += hardpref[n-low][k+low];\n                if (high != n) f[n][k] -= hardpref[n-high-1][k+high+1];\n            }\n            // for (int t = A; 1+t <= min(n, B-k-1); t++) {\n                // f[n][k] += f[n-1-t][1+k+t];\n            // }\n            int z = max(B-k, A+1);\n            if (n-z+1 >= 0) f[n][k] += pot[n-z+1]-1;\n            f[n][k] %= mod;\n            hardpref[n][k] = (hardpref[n-1][k+1] + f[n][k]) % mod;\n        }\n        pref[n+1] = (pref[n] + f[n][1]) % mod;\n    }   \n    // dbg(f[1][2]);\n    if (f[N][0] < 0) f[N][0] += mod;\n    cout << f[N][0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int M = 1e9 + 7;\n\nint sum(int a, int b) {\n  int c = a + b;\n  if (c >= M) c -= M;\n  if (c < 0) c += M;\n  return c;\n}\n\nvoid add(int &a, int b) {\n  a = sum(a, b);\n}\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nconst int N = 5000 + 7;\n\nint ans[N][2];\nint fans[N][2];\nint bad_block[N][2][2];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, a, b;\n  cin >> n >> a >> b;\n  if (a < b) swap(a, b);\n  ans[0][0] = ans[0][1] = 1;\n  fans[0][0] = fans[0][1] = 1;\n  bad_block[0][0][1] = 1;\n  bad_block[0][1][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    if (i >= a) {\n      for (int t = 0; t < 2; t++) {\n        for (int z = 0; z < 2; z++) {\n          bad_block[i][t][z] = 0;\n        }\n      }\n    } else {\n      for (int fir = 0; fir < 2; fir++) {\n        for (int last = 0; last < 2; last++) {\n          if (last) {\n            for (int bl = b; bl <= i; bl++) {\n              add(bad_block[i][fir][last], bad_block[i - bl][fir][last ^ 1]);\n            }\n          } else {\n            for (int bl = 1; bl <= i; bl++) {\n              add(bad_block[i][fir][last], bad_block[i - bl][fir][last ^ 1]);\n            }\n          }\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int bl = 1; bl < b && bl <= i; bl++) {\n      add(ans[i][1], ans[i - bl][0]);\n      add(fans[i][1], ans[i - bl][0]);\n    }\n    for (int j = 1; j <= i; j++) {\n      for (int x = 0; x < 2; x++) {\n        for (int y = 0; y < 2; y++) {\n          add(ans[i][y], mul(bad_block[j][x][y], fans[i - j][x ^ 1]));\n        }\n      }\n    }\n  }\n  int tot = 1;\n  for (int i= 1; i <= n; i++)\n    tot = mul(tot, 2);\n  add(tot, -ans[n][0]);\n  add(tot, -ans[n][1]);\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend str ts(mi a) { return ts(a.v); }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nmi ok[5001];\nmi dp[5001][2];\nint N,A,B;\n\nint gen(int len) {\n\tint ans = 0;\n\tF0R(i,1<<len) {\n\t\tvi v;\n\t\tF0R(j,len) {\n\t\t\tif (i&(1<<j)) v.pb(0);\n\t\t\telse v.pb(1);\n\t\t}\n\t\tif (v[0] != 0 || v.bk != 0) continue;\n\t\tbool bad = 0;\n\t\tfor (int j = 0; j < sz(v); ) if (v[j]) {\n\t\t\tint J = j;\n\t\t\twhile (j < sz(v) && v[j]) j ++;\n\t\t\tif (j-J < B) bad = 1;\n\t\t} else j ++;\n\t\tans += !bad;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tsetIO(); re(N,A,B); if (A < B) swap(A,B);\n\tdbg(\"HUH\",A,B);\n\tvmi tmp(5001); tmp[0] = 1;\n\tFOR(i,1,5001) {\n\t\ttmp[i] = tmp[i-1]; // white\n\t\tFOR(j,B,i) tmp[i] += tmp[i-j-1]; // black\n\t}\n\t// FOR(i,1,5001) ok[i] = tmp[i-1];\n\t// FOR(i,1,1001) dbg(ok[i],gen(i));\n\tF0R(i,A) dp[i][1] = tmp[i];\n\tFOR(i,1,N+1) {\n\t\tFOR(j,1,B) if (i >= j) dp[i][0] += dp[i-j][1];\n\t\tFOR(j,1,A) if (i >= j) dp[i][1] += tmp[j-1]*dp[i-j][0];\n\t}\n\tmi tot = pow(mi(2),N); // tot -= dp[N][0]+dp[N][1];\n\tF0R(i,A) tot -= dp[N-i][0]*tmp[i];\n\tps(tot);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver2 {\n public:\n  int n, a, b;\n  vector<vector<vector<LL>>> dp;\n  Solver2(int n, int a, int b) : n(n), a(a), b(b), dp(max(100, n + 1), vector<vector<LL>>(max(100, n + 1), vector<LL>(2))){};\n\n  void solve() {\n    if (a < b) swap(a, b);\n    dp[0][0][0] = LL(1);\n    dp[2][1][0] = LL(MOD - 1);\n    auto ans = Modint<>(0);\n    for (int i = 0; i <= n; ++i) {\n      if (i > 0) dp[i][1][0] += dp[i - 1][1][0];\n      dp[i][1][0] %= MOD;\n      for (int j = 0; j < a; ++j) {\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] += dp[i][j][0];\n        if (i + 2 <= n) dp[i + 2][1][0] += dp[i][j][0];\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] -= dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] += dp[i][j][1];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][1];\n\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] %= MOD;\n        if (i + 2 <= n) dp[i + 2][1][0] %= MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] += MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] %= MOD;\n      }\n      auto cf = Modint<>(2).mpow(n - i);\n      for (int j = a; j <= n; ++j) {\n        ans += (dp[i][j][0] + dp[i][j][1]) * cf;\n      }\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, a, b;\n  std::cin >> n >> a >> b;\n\n  Problem::Solver2 sol(n, a, b);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005,mod=1e9+7;\nint n,a,b;\nll f[N],dp[N][2];\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    for(;n;n>>=1,a=a*a%mod)if(n&1) ans=ans*a%mod;\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b) swap(a,b);\n    f[1]=1;\n    for(int i=1;i<b;i++)\n    {\n        f[i+1]=(f[i+1]+f[i])%mod;\n        for(int j=a;i+j+1<=b;j++)\n                f[i+j+1]=(f[i+j+1]+f[i])%mod;\n    }\n    dp[0][0]=dp[0][1]=1;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=i+1;j<i+a&&j<=n;j++)\n            (dp[j][0]+=dp[i][1])%=mod;\n        for(int j=i+1;j<i+b&&j<=n;j++)\n            (dp[j][1]+=dp[i][0]*f[j-i+(i==0||j==n)])%=mod;\n    }\n    ll ans=qpow(2,n);\n    ans=(ans-dp[n][0]-dp[n][1])%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nconst int N = 5200;\nconst int MOD = 1e9 + 7;\n\nint dp[N][N][2];\nint summover[N][2];\n\nint main()\n{\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n    dp[0][0][1] = 1;\n    summover[0][1] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j < a && j <= i; j++)\n        {\n            dp[i][0][0] = (dp[i][0][0] + summover[i - j][1]) % MOD;\n        }\n        for (int j = a; j <= b && j <= i; j++)\n        {\n            for (int h = 0; h < b; h++)\n            {\n                dp[i][h + j][0] = (dp[i][h + j][0] + dp[i - j][h][1]) % MOD;\n            }\n        }\n        for (int j = 1; j <= b; j++)\n        {\n            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j - 1][1]) % MOD;\n            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j - 1][0]) % MOD;\n        }\n        for (int j = 0; j < b; j++) summover[i][0] = (summover[i][0] + dp[i][j][0]) % MOD;\n        for (int j = 0; j < b; j++) summover[i][1] = (summover[i][1] + dp[i][j][1]) % MOD;\n    }\n    int ans = 1;\n    for (int i = 0; i < n; i++) ans = (ans + ans) % MOD;\n    cout << (1ll * ans + 2ll * MOD - (summover[n][0] + summover[n][1])) % MOD;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  struct rep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  struct revrep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) noexcept {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> void chmin(T& a, const T& b) noexcept {\n    if (b < a)\n      a = b;\n  }\n  template <class T> void chmax(T& a, const T& b) noexcept {\n    if (a < b)\n      a = b;\n  }\n  template <class F> class rec_lambda {\n    F f;\n\n  public:\n    rec_lambda(F&& f) : f(std::move(f)) {}\n    template <class... Args> auto operator()(Args&&... args) const {\n      return f(*this, std::forward<Args>(args)...);\n    }\n  };\n  template <class F> auto make_rec(F&& f) { return rec_lambda<F>(std::move(f)); }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n  constexpr char eoln = '\\n';\n  template <class T> T ceildiv(const T& l, const T& r) {\n    return l / r + (l % r != 0 ? 1 : 0);\n  }\n\n} // namespace n91\n#include <cstdint>\n\ntemplate <std::uint_fast64_t mod> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 v;\n\n  constexpr modint(const u64 x = 0) noexcept : v(x% mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint& operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint rhs) noexcept {\n    v = v * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint& operator/=(modint rhs) noexcept {\n    u64 exp = mod - 2;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        *this *= rhs;\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nnamespace n91 {\n\n  void main_() {\n    /*\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    //*/\n    using mint = modint<1000000007>;\n\n    const usize n = scan<usize>();\n    usize a = scan<usize>();\n    usize b = scan<usize>();\n    if (a < b) {\n      std::swap(a, b);\n    }\n\n    std::vector<mint> coef(n + 2, 0);\n    coef[1] = 1;\n    for (const usize i : rep(2, n + 2)) {\n      coef[i] = coef[i - 1];\n      for (const usize j : rep(b + 1, n + 2)) {\n        if (i < j)\n          break;\n        coef[i] += coef[i - j];\n      }\n    }\n\n    std::vector<mint> ze(n + 1, 0), on(n + 1, 0);\n    ze[0] = 1;\n    on[0] = 1;\n    for (const usize i : rep(1, n + 1)) {\n      for (const usize j : rep(1, std::min(a, i+1))) {\n        if (i == j) {\n          ze[i] += coef[j + 1];\n        }\n        else {\n          ze[i] += on[i - j] * coef[j];\n        }\n      }\n      for (const usize j : rep(1, std::min(b, i+1))) {\n        on[i] += ze[i - j];\n      }\n    }\n\n    mint ans = 1;\n    for (const usize i : rep(0, n)) {\n      ans *= 2;\n    }\n\n    ans -= on[n];\n\n    for (const auto i : rep(1,a)) {\n      ans -= on[n - i] * coef[i + 1];\n    }\n\n    std::cout << ans.v << eoln;\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n\nint32_t N,A,B;\nmint pow2[5100];\n\nmint func(int i, int a_end, bool prev_is_b);\n//Aは[, a_end)\nmint func_sum(int i, int k)\n{\n\tstatic mint dp[5100][5100];\n\tstatic bool used[5100][5100];\n\t//for (int k = 1; k < B; k++) {\n\t//\tres += func(i + k + 1, i + k + A, false);\n\t//}\n\n\tif (k >= B) {\n\t\treturn 0_mi;\n\t}\n\tauto& memo = dp[i][k];\n\tif (used[i][k]) {\n\t\treturn memo;\n\t}\n\tused[i][k] = true;\n\n\tmemo = func(i + k + 1, i + k + A, false);\n\tmemo += func_sum(i, k + 1);\n\treturn memo;\n}\n\n//Aは[a_end-A, a_end)\nmint func(int i, int a_end, bool prev_is_b)\n{\n\tstatic mint dp[5100][5100][2];\n\tstatic bool used[5100][5100][2];\n\tif (N < i || N + 1 <= a_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][prev_is_b ? 0 : 1];\n\tif (used[i][a_end][prev_is_b ? 0 : 1]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][prev_is_b ? 0 : 1] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\n\tif (prev_is_b) {\n\t\t//Bの終わった直後\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\tres += func(i + 1, a_end, true);//1を置く\n\t}\n\telse {\n\t\t//Aの中\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\t//for (int k = 1; k < B; k++) {//1をk個と0を一個置く\n\t\t//\t//Bの途中で0を置く\n\t\t//\tres += func(i + k + 1, i + k + A, false);\n\t\t//\t//↑最後に0を置いたのでAの中にいる\n\t\t//}\n\t\tres += func_sum(i, 1);\n\t\tres += func(i + B, a_end, true);//1をB個\n\t}\n\treturn memo = res;\n}\n\n//Aは[a_end-A, a_end), Bは[b_end-B, b_end)\nmint func_ON3(int i, int a_end, int b_end)\n{\n\tstatic mint dp[100][100][100];\n\tstatic bool used[100][100][100];\n\tif (N+1 <= a_end || N + 1 <= b_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i && b_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][b_end];\n\tif (used[i][a_end][b_end]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][b_end] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\tif (i < b_end) {//Bの中\n\t\tres += func_ON3(i + 1, i + A, 0);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end);//1を置く\n\t}\n\telse if (B <= b_end && i == b_end) {//Bの終わった直後\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end+1);//1を置く\n\t}\n\telse {//Aの中\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, i + B);//1を置く\n\t}\n\treturn memo = res;\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\t//if (A == 1) {\n\t//\tout << pow2[N] << endl;\n\t//\treturn 0;\n\t//}\n\t//if (N < 90) {\n\t//\tout << func_ON3(0, A, 0) << endl;\n\t//\treturn 0;\n\t//}\n\n\tout << func(0, A, false) << endl;\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define mod 1000000007\n#define pl(a,b) a=(a+b)%mod;\n#define N 5010\nll dpb[N][N],dpr[N][N];\nll cs1[N][N],cs2[N];\nint main(){\n\tll n,a,b;\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\trep(i,N)rep(j,N)dpb[i][j]=dpr[i][j]=0;\n\trep(i,N)rep(j,N)cs1[i][j]=0;\n\trep(i,N)cs2[i]=0;\n\tdpb[0][1]=1;\n\tll ans=0;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n+1;j++){\n\t\tif(i-j+1>=b)continue;\n\t\tif(i)pl(cs1[j][i],cs1[j][i-1]);\n\t\tpl(dpr[i][j],cs1[j][i]);\n\t\tif(i+1==j){\n\t\t\tpl(cs2[i],cs2[i-1]);\n\t\t\tpl(dpr[i][j],cs2[i]);\n\t\t}\n\t\tif(i==n){\n\t\t\tpl(ans,dpb[i][j]);\n\t\t\tpl(ans,dpr[i][j]);\n\t\t\tcontinue;\n\t\t}\n\t\tpl(dpb[i+1][j],dpb[i][j]);\n\t\tpl(dpb[i+1][j],dpr[i][j]);\n\t\tpl(cs1[j][i+a],dpb[i][j]);\n\t\tpl(cs2[i+1],dpb[i][j]);\n\t\tpl(cs2[i+a],-dpb[i][j]);\n\t\t/*\n\t\tfor(int k=1;i+k<=n;k++){\n\t\t\tif(k>=a)pl(dpr[i+k][j],dpb[i][j]);\n\t\t\tif(k<a)pl(dpr[i+k][i+k+1],dpb[i][j]);\n\t\t}*/\n\t}\n\tll c=1;\n\trep(i,n)c=c*2%mod;\n\tans=c-ans;\n\tans%=mod;\n\tif(ans<0)ans+=mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=5005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint coef[MAXN],encoef[MAXN],n,A,B;\n//end is 0\nvoid getcoef()\n{\n\tcoef[1]=1;\n\tfor(int i=1;i<A;i++)\n\t{\n\t\tad(coef[i+1],coef[i]); \n\t\tfor(int j=B;i+j<=A;j++)ad(coef[i+j+1],coef[i]),ad(encoef[i+j],coef[i]);\n\t}\n}\nint f[MAXN][2];//end with 0/1\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tn=read();A=read();B=read();if(A<B)swap(A,B);\n\tgetcoef();\n\tfor(int i=0;i<B;i++)f[i][1]=1;\n\tfor(int i=1;i<A;i++)f[i][0]=encoef[i];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=1;j<A&&i+j<=n;j++)\n\t\t{\n\t\t\tad(f[i+j][0],1LL*f[i][1]*coef[j]%mod);\n\t\t\tif(i+j==n)ad(f[i+j][1],1LL*f[i][1]*encoef[j]%mod);\n\t\t}\n\t\tfor(int j=1;j<B&&i+j<=n;j++)\n\t\t\tad(f[i+j][1],f[i][0]);\n\t}\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)ans=2LL*ans%mod;\n\tdl(ans,f[n][0]);dl(ans,f[n][1]);\n\tpr2(ans);\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N,A,B;\n\nmint dp1[7100][7100][2];\nbool used1[7100][7100][2];\n//mint func1(int i, int a_len, int fin)\n//{\n//\tif (a_len >= A) {\n//\t\tfin = 1;\n//\t}\n//\tif (fin != 0) {\n//\t\ta_len = 0;\n//\t}\n//\tif (i == N) {\n//\t\tif (fin != 0) {\n//\t\t\treturn 1_mi;\n//\t\t}\n//\t\treturn 0_mi;\n//\t}\n//\n//\tauto& memo = dp1[i][a_len][fin];\n//\tif (used1[i][a_len][fin]) {\n//\t\treturn memo;\n//\t}\n//\tused1[i][a_len][fin] = true;\n//\n//\treturn memo = func1(i + 1, a_len + 1, fin) + func1(i + 1, 0, fin);\n//}\n\n\n\nmint pow2[7100];\nmint dp5[7100][7100];\nbool used5[7100][7100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[7100][7100][2];\nbool used4[7100][7100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\tif (i >= N) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, i + B);\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\tif (A == 1) {\n\t\tout << pow2[N] << endl;\n\t\treturn 0;\n\t}\n\n\n\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\n\nint f[10101][2];\nint g[10101][2];\nint dp[5050][2];\n\nint _2[5050];\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\t\n\tif(A > B)\n\t\tswap(A, B);\n\t\n\t_2[0] = 1;\n\tfor(int i = 1; i <= 5000; i++)\n\t\t_2[i] = _2[i - 1] * 2 % mod;\n\tf[0][0] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tf[i][0] += f[i - j][1];\n\t\t\tif(f[i][0] >= mod)\n\t\t\t\tf[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tf[i][1] += f[i-j][0];\n\t\t\t\tif(f[i][1] >= mod)\n\t\t\t\t\tf[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tg[0][1] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tg[i][0] += g[i - j][1];\n\t\t\tif(g[i][0] >= mod)\n\t\t\t\tg[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tg[i][1] += g[i - j][0];\n\t\t\t\tif(g[i][1] >= mod)\n\t\t\t\t\tg[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0] = dp[0][1] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tif(i < B)\n\t\t{\n\t\t\tdp[i][1] += g[i][1];\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < min(i + 1, B); j++)\n\t\t{\n\t\t\tdp[i][1] += 1ll * f[j][1] * dp[i - j][0] % mod;\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < min(i + 1, A); j++)\n\t\t{\n\t\t\tdp[i][0] += dp[i - j][1];\n\t\t\tif(dp[i][0] >= mod)\n\t\t\t\tdp[i][0] -= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= N; i++)\n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\tfor(int j = B; j < A + B; j++)\n\t\t\tif(i + j <= N)\n\t\t\t{\n\t\t\t\tans += 1ll * dp[i][1] * (g[j][0] + g[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\t\tif(ans >= mod)\n\t\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j = B; j < A + B; j++)\n\t\tif(i + j <= N)\n\t\t{\n\t\t\tans += 1ll * dp[i][0] * (f[j][0] + f[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\tif(ans >= mod)\n\t\t\t\tans -= mod; \n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define upd(a,b) a=add(a+b)\nusing namespace std;\ninline char nc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=5000+5;\nint n,A,B;\nint f[maxn][2],g[maxn][2];\nint dp[maxn][2][2];\ninline int add(int x) {return x>=mod?x-mod:x;}\nvoid DP(int dp[maxn][2]) {\n\tfor(int i=0;i<n;++i) {\n\t\tupd(dp[i+1][1],dp[i][0]);\n\t\tupd(dp[i+1][1],dp[i][1]);\n\t\tfor(int k=A;i+k<=n;++k) upd(dp[i+k][0],dp[i][1]);\n\t}\n}\nint main() {\n\tread(n),read(A),read(B);\n\tif(A>B) swap(A,B);\n\tf[0][0]=1,DP(f);\n\tg[0][0]=1;\n\tfor(int i=A;i<=n;++i) g[i][0]=1;\n\tDP(g);\n\tdp[n][1][0]=g[n][0];\n\tfor(int i=1;i<=n;++i) dp[i][i>=B][1]=g[i][1];\n\tfor(int i=1;i<A;++i) dp[i][0][0]=1;\n\tfor(int i=1;i<=n;++i) for(int k=0;k<2;++k) {\n\t\tfor(int j=1;j<A;++j) upd(dp[i+j][k][0],dp[i][k][1]);\n\t\tfor(int j=1;i+j<=n;++j) {\n\t\t\tint r=f[j][1]; if(i+j==n) upd(r,f[j][0]);\n\t\t\tupd(dp[i+j][k||j>=B][1],(ll)dp[i][k][0]*r%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",add(dp[n][1][0]+dp[n][1][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\n\n#include<vector>\n\nnamespace ProconLib{\n    \n    template<class MUStruct>\n    class LazySegmentTree{\n        public:\n        using Monoid=typename MUStruct::Monoid;\n        using Update=typename MUStruct::Update;\n        using value_t=typename Monoid::value_t;\n        using update_t=typename Update::update_t;\n\n        protected:\n\n        int N;\n        std::vector<value_t> dat;\n        std::vector<update_t> lazy;\n        std::vector<char> flag;\n\n        static int calcN(int n){int res=1; while(res<n) res*=2; return res;};\n        void propagate(int node);\n        void applyLazy(int node,update_t x);\n        void applyImpl(int l,int r,int k,int lb,int ub,update_t f);\n        void updateImpl(int pos,int k,int lb,int ub,value_t x);\n        value_t queryImpl(int l,int r,int k,int lb,int ub);\n        value_t getValue(int node){return flag[node] ? MUStruct::evaluate(dat[node],lazy[node]) : dat[node];}\n        \n        public:\n        LazySegmentTree(int N);\n        void apply(int l,int r,update_t f);\n        void updateALL(std::vector<value_t> x);\n        void update(int pos,value_t v);\n        value_t query(int a,int b);\n    };\n\n    // struct MUStructExample{\n    //     struct Monoid{\n    //         using value_t=int;\n    //         static constexpr value_t E(){return 1e9;}\n    //         static value_t op(value_t lhs,value_t rhs){ return min(lhs,rhs);}\n    //     };\n    //     struct Update{\n    //         using update_t = int;\n    //         static update_t op(update_t lhs,update_t rhs){ return lhs+rhs;}\n    //     };\n    //     static Monoid::value_t evaluate(Monoid::value_t v,Update::update_t u){ return v+u;}\n    // };\n\n    template<class MUStruct>\n    LazySegmentTree<MUStruct>::LazySegmentTree(int n):N(calcN(n)),dat(N*2-1,Monoid::E()),lazy(N*2-1),flag(N*2-1,false){}\n    \n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::propagate(int node){\n        if(flag[node]){\n            flag[node]=false;\n            applyLazy(node*2+1,lazy[node]);\n            applyLazy(node*2+2,lazy[node]);\n            dat[node]=Monoid::op(getValue(node*2+1),getValue(node*2+2));\n        }\n    }\n\n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::applyLazy(int node,update_t x){\n        if(flag[node]){\n            lazy[node]=Update::op(lazy[node],x);\n        }\n        else{\n            flag[node]=true;\n            lazy[node]=x;\n        }\n    }\n\n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::applyImpl(int l,int r,int k,int lb,int ub,update_t x){\n        if(r<=lb || ub<=l) return;\n        if(l<=lb && ub<=r){\n            applyLazy(k,x);\n            return;\n        }\n        propagate(k);\n        int mid=(lb+ub)/2;\n        applyImpl(l,r,k*2+1,lb,mid,x);\n        applyImpl(l,r,k*2+2,mid,ub,x);\n        dat[k]=Monoid::op(getValue(k*2+1),getValue(k*2+2));\n    }\n\n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::updateImpl(int pos,int k,int lb,int ub,value_t x){\n        if(!(lb<=pos && pos<ub))return;\n        if(pos==lb && pos==ub-1){\n            flag[k]=false;\n            dat[k]=x;\n            return;\n        }\n        propagate(k);\n        int mid=(lb+ub)/2;\n        updateImpl(pos,k*2+1,lb,mid,x);\n        updateImpl(pos,k*2+2,mid,ub,x);\n        dat[k]=Monoid::op(getValue(k*2+1),getValue(k*2+2));\n    }\n\n    template<class MUStruct>\n    typename LazySegmentTree<MUStruct>::value_t LazySegmentTree<MUStruct>::queryImpl(int l,int r,int k,int lb,int ub){\n        if(r<=lb || ub<=l) return Monoid::E();\n        if(l<=lb && ub<=r){\n            return getValue(k);\n        }\n        propagate(k);\n        int mid=(lb+ub)/2;\n        value_t lhs=queryImpl(l,r,k*2+1,lb,mid);\n        value_t rhs=queryImpl(l,r,k*2+2,mid,ub);\n        return Monoid::op(lhs,rhs);\n    }\n    \n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::apply(int l,int r,update_t x){\n        applyImpl(l,r,0,0,N,x);\n    }\n\n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::update(int pos,value_t x){\n        updateImpl(pos,0,0,N,x);\n    }\n\n    template<class MUStruct>\n    void LazySegmentTree<MUStruct>::updateALL(std::vector<value_t> xs){\n        for(int i=0;i<xs.size();i++){\n            dat[i+N-1]=xs[i];\n        }\n        for(int i=xs.size();i<N;i++) dat[i+N-1]=Monoid::E(),flag[i+N-1]=false;\n        for(int i=N-2;i>=0;i--){\n            flag[i]=false;\n            value_t c1v=dat[i*2+1],c2v=dat[i*2+2];\n            dat[i]=Monoid::op(c1v,c2v);\n        }\n    }\n\n    template<class MUStruct>\n    typename LazySegmentTree<MUStruct>::value_t LazySegmentTree<MUStruct>::query(int l,int r){\n        return queryImpl(l,r,0,0,N);\n    }\n};\nusing namespace ProconLib;\n\nconst int INF = 1e9;\nstruct MUStructMax{\n    struct Monoid{\n        using value_t=pair<int,int>;\n        static constexpr value_t E(){return make_pair(-INF,-INF);}\n        static value_t op(value_t lhs,value_t rhs){ return max(lhs,rhs);}\n    };\n    struct Update{\n        using update_t = int;\n        static update_t op(update_t lhs,update_t rhs){ return lhs+rhs;}\n    };\n    static Monoid::value_t evaluate(Monoid::value_t v,Update::update_t u){ return make_pair(v.first+u,v.second);}\n};\n\nstruct MUStructMin{\n    struct Monoid{\n        using value_t=pair<int,int>;\n        static constexpr value_t E(){return make_pair(INF,INF);}\n        static value_t op(value_t lhs,value_t rhs){ return min(lhs,rhs);}\n    };\n    struct Update{\n        using update_t = int;\n        static update_t op(update_t lhs,update_t rhs){ return lhs+rhs;}\n    };\n    static Monoid::value_t evaluate(Monoid::value_t v,Update::update_t u){ return make_pair(v.first+u,v.second);};\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    cin>>s;\n    int n = s.size();\n    LazySegmentTree<MUStructMax> maxSeg(n);\n    LazySegmentTree<MUStructMin> minSeg(n);\n    for(int i=0;i<n;i++){\n        maxSeg.update(i,{0,i});\n        minSeg.update(i,{0,i});\n    }\n    for(int i=0;i<n;i++){\n        if(s[i]=='1'){\n            maxSeg.apply(i,n,1);\n            minSeg.apply(i,n,1);\n        }\n        else{\n            maxSeg.apply(i,n,-1);\n            minSeg.apply(i,n,-1);\n        }\n    }\n\n    set<int> q_set;\n    for(int i=0;i<n;i++){\n        if(s[i]=='?') q_set.insert(i);\n    }\n    int pre = -1;\n    int res = INF;\n    int start = min(minSeg.query(0,n).first,0);\n    for(int lb=start;lb<=1e6+1;lb++){\n        auto ret = minSeg.query(0,n);\n        // cerr<<\"$$\"<<lb<<endl;\n        // cerr<<\"$\"<<endl;\n        // for(int i=0;i<n;i++){\n        //     auto ret = maxSeg.query(i,i+1);\n        //     cerr<<ret.first<<\" \";\n        // }\n        // cerr<<endl;\n        if(ret.first<lb){\n            int id = ret.second;\n            auto it = q_set.upper_bound(id);\n            if(it==q_set.begin()){\n                break;\n            }\n            it--;\n            int pos = *it;\n            minSeg.apply(pos,n,2);\n            maxSeg.apply(pos,n,2);\n            q_set.erase(pos);\n            if(pre!=-1){\n                auto ret = minSeg.query(pre,n);\n                if(lb+2<=ret.first){\n                    minSeg.apply(pre,n,-2);\n                    maxSeg.apply(pre,n,-2);\n                    q_set.insert(pre);\n                }\n            }\n            pre=pos;\n        }\n        // cerr<<\"#\"<<endl;\n        // for(int i=0;i<n;i++){\n        //     auto ret = maxSeg.query(i,i+1);\n        //     cerr<<ret.first<<\" \";\n        // }\n        // cerr<<endl;\n        auto retmin = minSeg.query(0,n);\n        auto retmax = maxSeg.query(0,n);\n        // assert(retmin.first>=lb);\n        res = min(res,max(retmax.first,0)-min(retmin.first,0));\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 5000 + 7;\nconst int M = (int) 1e9 + 7;\nint streak[N][2][2], dp_streak[N], dp_0[N];\n\nint add(int a, int b) {\n        a += b;\n        if (a >= M) return a - M;\n        if (a < 0) return a + M;\n        return a;\n}\n\nint mul(int a, int b) {\n        return a * (ll) b % M;\n}\n\nint pw(int a, int b) {\n        int r = 1;\n        while (b) {\n                if (b & 1)\n                        r = mul(r, a);\n                a = mul(a, a);\n                b /= 2;\n        }\n        return r;\n}\n\nint dv(int a, int b) {\n        return mul(a, pw(b, M - 2));\n}\n\nint n, a, b;\nset<string> st;\n\nvoid bkt(string s) {\n        if (st.count(s)) return;\n        st.insert(s);\n        for (int i = 0; i + a - 1 < n; i++) {\n                string t = s;\n                for (int j = i; j <= i + a - 1; j++)\n                        t[j] = '0';\n                bkt(t);\n        }\n        for (int i = 0; i + b - 1 < n; i++) {\n                string t = s;\n                for (int j = i; j <= i + b - 1; j++)\n                        t[j] = '1';\n                bkt(t);\n        }\n}\n\nint dm(int _n, int _a, int _b) {\n        n = _n;\n        a = _a;\n        b = _b;\n        st.clear();\n        string base;\n        for (int i = 1; i <= n; i++)\n                base += \"0\";\n        bkt(base);\n        return (int) st.size();\n}\n\nint sm(int _n, int _a, int _b) {\n        n = _n;\n        a = _a;\n        b = _b;\n        if (a > b)\n                swap(a, b);\n        for (int i = 0; i <= n; i++) {\n                for (int f = 0; f <= 1; f++)\n                        for (int s = 0; s <= 1; s++)\n                                streak[i][f][s] = 0;\n                dp_streak[i] = dp_0[i] = 0;\n        }\n        for (int l0 = a; l0 <= n; l0++)\n                streak[l0][0][0] = 1;\n        for (int l1 = 1; l1 <= n; l1++)\n                streak[l1][1][1] = 1;\n        for (int l = 0; l <= n; l++) {\n                for (int f = 0; f <= 1; f++) {\n                        /// s = 0, now = 1\n                        for (int l1 = 1; l + l1 <= n; l1++)\n                                streak[l + l1][f][1] = add(streak[l + l1][f][1], streak[l][f][0]);\n                        /// s = 1, now = 0\n                        for (int l0 = a; l + l0 <= n; l0++)\n                                streak[l + l0][f][0] = add(streak[l + l0][f][0], streak[l][f][1]);\n                }\n        }\n        /// streak 0 streak 0 streak 0 streak\n        /// streak 0 streak 0 streak 0 streak 0\n        /// 0 streak 0 streak 0 streak 0 streak\n        /// 0 streak 0 streak 0 streak 0 streak 0\n        int bad = 0;\n        /// stars with streak\n        for (int ls = 1; ls < b; ls++)\n                dp_streak[ls] = add(streak[ls][0][1], streak[ls][1][1]);\n        /// starts with 0\n        for (int l0 = 1; l0 < a; l0++)\n                dp_0[l0] = add(dp_0[l0], 1);\n        for (int l = 1; l <= n; l++) {\n                /// streak, 0\n                for (int l0 = 1; l + l0 <= n && l0 < a; l0++) {\n                        dp_0[l + l0] = add(dp_0[l + l0], dp_streak[l]);\n                }\n                /// 0, streak\n                for (int ls = 1; l + ls <= n && ls < b; ls++) {\n                        if (l + ls == n) {\n                                dp_streak[l + ls] = add(dp_streak[l + ls], mul(dp_0[l], streak[ls][1][0]));\n                                dp_streak[l + ls] = add(dp_streak[l + ls], mul(dp_0[l], streak[ls][1][1]));\n                        } else {\n                                dp_streak[l + ls] = add(dp_streak[l + ls], mul(dp_0[l], streak[ls][1][1]));\n                        }\n                }\n        }\n        bad = add(bad, dp_streak[n]);\n        bad = add(bad, dp_0[n]);\n        return add(pw(2, n), -bad);\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        int n, a, b;\n        cin >> n >> a >> b;\n        cout << sm(n, a, b) << \"\\n\";\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const p=1e9+7;\nint f[5005][2],g[5005][2];\nint mod(int x){return x>=p?x-p:x;}\nint main()\n{\n    int n,a,b;\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b)swap(a,b);\n    g[1][1]=1;\n    for(int i=2;i<b;i++)\n    {\n        for(int j=1;j<=i-a;j++)\n            g[i][0]=mod(g[i][0]+g[j][1]);\n        g[i][1]=mod(g[i-1][0]+g[i-1][1]);\n    }\n    f[0][0]=f[0][1]=1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=max(i-a+1,0);j<i;j++)f[i][0]=mod(f[i][0]+f[j][1]);\n        for(int j=max(i-b+1,0);j<i;j++)\n        {\n            if(i==n)f[i][0]=(f[i][0]+1ll*f[j][0]*g[i-j][0])%p;\n            if(j==0)f[i][1]=(1ll*f[i][1]+g[i][0]+g[i][1])%p;\n            else f[i][1]=(f[i][1]+1ll*f[j][0]*g[i-j][1])%p;\n        }\n    }\n    int pw=1;\n    for(int i=1;i<=n;i++)pw=mod(pw+pw);\n    printf(\"%lld\",(1ll*pw+p+p-f[n][0]-f[n][1])%p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\nstruct range {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr itr operator * () const { return i; }\n    constexpr bool operator != (iterator x) const { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr range(itr l_, itr r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr iterator begin() const { return l; }\n  constexpr iterator end() const { return r; }\n};\n\nstruct revrange {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr itr operator * () const { return i; }\n    constexpr bool operator != (iterator x) const { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr revrange(itr l_, itr r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr iterator begin() const { return r; }\n  constexpr iterator end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type get_mod() { return mod; }\n  static_assert(mod >= 2, \"invalid mod :: smaller than 2\");\n  static_assert(mod < (value_type(1) << 31), \"invalid mod :: over 2^31\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type get() const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing m32 = modular<1000000007>;\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nint main() {\n  i32 N, A, B;\n  std::cin >> N >> A >> B;\n  N += 2;\n  if (A > B) {\n    std::swap(A, B);\n  }\n  std::vector<std::array<m32, 2>> dp1(N + 1);\n  for (auto i: range(0, N + 1)) {\n    for (auto j: range(0, 2)) {\n      dp1[i][j] = (m32) 0;\n    }\n  }\n  dp1[0][1] = (m32) 1;\n  for (auto i: range(0, N + 1)) {\n    { // extend 0 (greater than or equal to A)\n      for (auto j: range(A, N + 1)) {\n        if (i + j <= N) {\n          dp1[i + j][1] += dp1[i][0];\n        }\n      }\n    }\n    { // extend 1 (any length)\n      for (auto j: range(1, N + 1)) {\n        if (i + j <= N) {\n          dp1[i + j][0] += dp1[i][1];\n        }\n      }\n    }\n  }\n  std::vector<std::array<std::array<m32, 2>, 2>> dp2(N + 1);\n  for (auto i: range(0, N + 1)) {\n    for (auto j: range(0, 2)) {\n      for (auto k: range(0, 2)) {\n        dp2[i][j][k] = (m32) 0;\n      }\n    }\n  }\n  dp2[0][1][0] = (m32) 1;\n  for (auto i: range(0, N + 1)) {\n    for (auto k: range(0, 2)) {\n      { // extend 0 (less than A)\n        for (auto j: range(1, A)) {\n          if (i + j <= N) {\n            dp2[i + j][1][k] += dp2[i][0][k];\n          }\n        }\n      }\n      { // extend 1 (any length)\n        for (auto j: range(1, N + 1)) {\n          if (i + j <= N) {\n            auto len = j;\n            if (i == 0) --len;\n            if (i + j == N) --len;\n            if (len >= B) {\n              dp2[i + j][0][1] += dp2[i][1][k] * dp1[j][0];\n            }\n            else {\n              dp2[i + j][0][k] += dp2[i][1][k] * dp1[j][0];\n            }\n          }\n        }\n      }\n    }\n  }\n  std::cout << dp2[N][0][1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 5000, md = 1e9 + 7;\nint dp[2][N + 1][N + 1], s[2][N + 1][N + 1], p2[N + 1];\n\nvoid ad(int &x, int y) { if ((x += y) >= md)x -= md; }\n\nint gt(int tp, int a, int b) { return b >= 0 ? s[tp][a][b] : 0; }\n\nint sm(int tp, int a, int b, int l, int r){\n\tint an = gt(tp, a - l, b - l) - gt(tp, a - r - 1, b - r - 1);\n\tad(an, md);\n\treturn an;\n}\n\nint main(){\n\tint n, a, b;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tp2[0] = 1;\n\tf(i, 1, n + 1)ad(p2[i] = p2[i - 1], p2[i - 1]);\n\tif (a < b)swap(a, b);\n\t\n\tf(tp, 0, 2)dp[tp][0][0] = s[tp][0][0] = 1;\n\tf(i, 1, n + 1)f(j, 0, i + 1)f(tp, 0, 2){\n\t\tif (j < a){\n\t\t\tif (tp == 0)dp[tp][i][j] = sm(1, i, j, 1, j);\n\t\t\telse {\n\t\t\t\tdp[tp][i][j] = sm(0, i, j, min(j + 1, b), j);\n\t\t\t\tif (j == 0)f(k, 0, i + 1)ad(dp[tp][i][j], sm(0, i, k, 1, min(b - 1, k)));\n\t\t\t}\n\t\t}\n\t\tad(s[tp][i][j] = dp[tp][i][j], j == 0 ? 0 : s[tp][i - 1][j - 1]);\n\t}\n\tint an = 0;\n\tf(i, 0, 2)f(j, 0, a)ad(an, dp[i][n][j]);\n\tan = p2[n] - an;\n\tad(an, md);\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\ntypedef ModInt<1000000007> mint;\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\n\nint main() {\n\t// TODO : a == b\n\tint n = ri();\n\t\n\tint a = ri(), b = ri();\n\tif (a > b) std::swap(a, b);\n\t\n\tstatic mint dp[5001][5001][2]; // pos, len, flag\n\tdp[0][0][1] = 1;\n\t\n\tmint diff[n + 1];\n\tmint cur = 0;\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tcur += diff[i];\n\t\tdp[i][1][1] += cur;\n\t\t\n\t\tmint beki2 = mint(2) ^ (n - i);\n\t\tfor (int j = b; j <= n; j++) res += beki2 * (dp[i][j][0] + dp[i][j][1]);\n\t\tif (i == n) break;\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tif (dp[i][j][0] != 0) {\n\t\t\t\tdp[i + 1][j + 1][0] += dp[i][j][0];\n\t\t\t\tdp[i + 1][j + 1][1] += dp[i][j][0];\n\t\t\t}\n\t\t\tif (dp[i][j][1] != 0) {\n\t\t\t\tdp[i + 1][j + 1][1] += dp[i][j][1];\n\t\t\t\tif (i + a <= n) dp[i + a][j + a][0] += dp[i][j][1];\n\t\t\t\t// for (int k = i + 2; k <= n && k <= i + a; k++) dp[k][1][1] += dp[i][j][1];\n\t\t\t\tif (i + 2 <= n) {\n\t\t\t\t\tdiff[i + 2] += dp[i][j][1];\n\t\t\t\t\tif (i + a + 1 <= n) diff[i + a + 1] -= dp[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k < 2; k++) if (dp[i][j][k] != 0) {\n\t\tstd::cerr << \"pos:\" << i << \" len:\" << j << \" next:\" << k << \" : \" << dp[i][j][k] << std::endl;\n\t}*/\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 0\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint operator--(int) { mint this_=*this; --*this; return this_; }\n    mint operator-() const { return 0 - *this; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) const { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) const { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) const { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) const { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       const { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) const { return pow(*this, y); }\n    mint square(mint x) const { return *this * *this; }\n    mint cube(mint x) const { return *this * *this * *this; }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\ntemplate <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x) {\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\ntemplate <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x) {\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i64, 1'000'000'007>>;\ntemplate <usize N, class T, class... Args, std::enable_if_t<N==0, int> = 0>\nauto mkvec(Args... args) {\n    return T(args...);\n}\ntemplate <usize N, class T, class... Args, std::enable_if_t<N!=0, int> = 0>\nauto mkvec(usize sz, Args... args) {\n    using value_type = std::decay_t<decltype(mkvec<N-1, T>(args...))>;\n    return vec<value_type>(sz, mkvec<N-1, T>(args...));\n}\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n, a, b;\n    std::cin >> n >> a >> b;\n    if (a>b) std::swap(a, b);\n\n    auto fp = mkvec<2, mint>(2, b);\n    fp.at(0).at(0) = 1;\n    fp.at(1).at(0) = 1;\n    for (usize i=0; i<b; i++) {\n        for (usize j=a; i+j<b; j++) fp.at(0).at(i+j) += fp.at(1).at(i);\n        for (usize j=1; i+j<b; j++) fp.at(1).at(i+j) += fp.at(0).at(i);\n    }\n    DEBUG(matrix_style(fp));\n\n    vec<mint> ep(b);\n    ep.at(0) = 1;\n    for (usize i=1; i<b; i++) {\n        ep.at(i) = fp.at(0).at(i) + fp.at(1).at(i);\n    }\n    DEBUG(ep);\n\n    auto dp = mkvec<2, mint>(2, n);\n    for (usize j=1; j<a; j++) dp.at(0).at(j) += 1;\n    for (usize j=1; j<b; j++) dp.at(1).at(j) += ep.at(j-1);\n    DEBUG(matrix_style(dp));\n\n    for (usize i=1; i<n; i++) {\n        for (usize j=1; j<a && i+j<n; j++) dp.at(0).at(i+j) += dp.at(1).at(i);\n        for (usize j=1; j<b && i+j<n; j++) dp.at(1).at(i+j) += dp.at(0).at(i) * ep.at(j==1?1:j-2);\n    }\n    DEBUG(matrix_style(dp));\n\n    mint ans = 0;\n    for (usize j=1; j<b; j++) ans += dp.at(0).at(n-j) * ep.at(j-1);\n    for (usize j=1; j<a; j++) ans += dp.at(1).at(n-j);\n    DEBUG(ans);\n    ans = mint::pow(2, n) - ans;\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll C(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\nint N, A, B;\nll dp[5010][2];\nll fp[5010]; //one side\n\nvoid solve() {\n\tcin >> N >> A >> B;\n\tif(A < B) swap(A, B);\n\tfp[0] = 1;\n\trep(i, 1, N + 1) {\n\t\tADD(fp[i], fp[i - 1]);\n\t\trep(j, 0, N + 1) {\n\t\t\tif(i - j >= B + 1) ADD(fp[i], fp[j]);\n\t\t}\n\t}\n\n\t// debug(vl(fp, fp + N + 1));\n\tll res = 0;\n\tdp[0][0] = 1;\n\tdp[0][1] = 1;\n\trep(i, 0, N + 1) {\n\t\trep(j, i + 1, N + 1) {\n\t\t\tint jump = j - i;\n\t\t\tif(jump < A) ADD(dp[j][1], dp[i][0] * fp[jump - (i != 0)] % mod);\n\t\t\tif(jump < B) ADD(dp[j][0], dp[i][1]);\n\t\t}\n\t\t// debug(i, dp[i][0], dp[i][1], dp[i][1] * fp[N - i]);\n\t\tif(N - i < A) {\n\t\t\tADD(res, dp[i][0] * fp[N - i] % mod);\n\t\t\t// debug(dp[i][0] * fp[N - i] % mod);\n\t\t}\n\t}\n\t// debug(res);\n\tcout << (mod + mod_pow(2, N) - res) % mod << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define int long long\n//#define int __int128\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst int N = 5005, MOD = 1e9 + 7;\n\nint dp[N][3];\nint D[N][2];\nint ans;\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b)\n        swap (a, b);\n    ans = 1;\n    for (int i = 0; i < n; i++)\n        ans = ans * 2 % MOD;\n    if (a == 1){\n        cout << ans << endl;\n        return 0;\n    }\n    D[1][1] = 1;\n    for (int i = 2; i <= n+1; i++){\n        D[i][1] = (D[i-1][1] + D[i-1][0]) % MOD;\n        for (int j = 1; j <= i - a; j++)\n            D[i][0] += D[j][1];\n        D[i][0] %= MOD;\n        //cout << i << \" \" << D[i][0] << \" \" << D[i][1] << endl;\n    }\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n    dp[0][2] = 1;\n    for (int i = 1; i <= n; i++){\n        for (int j = max (0ll, i-b+1); j < i; j++){\n            dp[i][2] += dp[j][0] * D[i-j+1][1];\n            dp[i][1] += dp[j][0] * D[i-j][1];\n            dp[i][1] %= MOD;\n            dp[i][2] %= MOD;\n        }\n        for (int j = max (0ll, i-a+1); j < i; j++)\n            dp[i][0] += dp[j][1];\n        dp[i][0] %= MOD;\n        dp[i][2] += dp[i][0];\n        dp[i][2] %= MOD;\n        //cout << i << \" \" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << endl;\n    }\n    //cout << dp[n][2] << endl;\n    cout << (ans - dp[n][2] + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N,A,B;\n\n\nmint pow2[5100];\nmint dp5[5100][5100];\nbool used5[5100][5100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[5100][5100][2];\nbool used4[5100][5100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\tif (i >= N) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, i + B);\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\tif (A == 1) {\n\t\tout << pow2[N] << endl;\n\t\treturn 0;\n\t}\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int MOD = 1000000007;\nvoid add(int &a, const int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, const int b) {\n\ta -= b;\n\tif (a < 0) a += MOD;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif (A > B) swap(A, B);\n\tvector<vector<vector<int> > > dp(N + 1, vector<vector<int> >(N + 1, vector<int>(2, 0)));\n\tvector<vector<vector<int> > > XX(N + 1, vector<vector<int> >(N + 1, vector<int>(2, 0)));\n\tvector<int> YY(N + 1, 0);\n\tdp[0][0][0] = 1;\n\tdp[0][0][1] = 1;\n\tint p2[100005];\n\tp2[0] = 1;\n\tfor (int i = 1; i < 100005; i++) {\n\t\tp2[i] = p2[i - 1] * 2 % MOD;\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t// for (int x = i + 1; x <= min(N, j + B - 1); x++) {\n\t\t\t// \tadd(dp[x][j][1], dp[i][j][0]);\n\t\t\t// }\n\t\t\tif (i > 0) add(XX[i][j][0], XX[i - 1][j][0]);\n\t\t\tif (i > 0) add(XX[i][j][1], XX[i - 1][j][1]);\n\t\t\tadd(dp[i][j][0], XX[i][j][0]);\n\t\t\tadd(dp[i][j][1], XX[i][j][1]);\n\t\t\tif (i == j && i > 0) {\n\t\t\t\tadd(YY[i], YY[i - 1]);\n\t\t\t\tadd(dp[i][j][0], YY[i]);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint mn = i + 1;\n\t\t\t\tint mx = min(N, j + B - 1);\n\t\t\t\tif (mn <= mx) {\n\t\t\t\t\tadd(XX[mn][j][1], dp[i][j][0]);\n\t\t\t\t\tif (mx + 1 <= N) {\n\t\t\t\t\t\tsub(XX[mx + 1][j][1], dp[i][j][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j + B <= N) {\n\t\t\t\tadd(res, dp[i][j][0] * p2[N - (j + B)] % MOD);\n\t\t\t}\n\t\t\t// for (int x = i + 1; x <= min(N, i + A - 1); x++) {\n\t\t\t// \t//cerr << i << \" \" << j << \" \" << x << endl;\n\t\t\t// \tadd(dp[x][x][0], dp[i][j][1]);\n\t\t\t// }\n\t\t\t{\n\t\t\t\tint mn = i + 1;\n\t\t\t\tint mx = min(N, i + A - 1);\n\t\t\t\tif (mn <= mx) {\n\t\t\t\t\tadd(YY[mn], dp[i][j][1]);\n\t\t\t\t\tif (mx + 1 <= N) {\n\t\t\t\t\t\tsub(YY[mx + 1], dp[i][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for (int x = i + A; x <= min(N, j + B - 1); x++) {\n\t\t\t// \t//cerr << i << \" \" << j << \" \" << x << endl;\n\t\t\t// \tadd(dp[x][j][0], dp[i][j][1]);\n\t\t\t// }\n\n\t\t\t{\n\t\t\t\tint mn = i + A;\n\t\t\t\tint mx = min(N, j + B - 1);\n\t\t\t\tif (mn <= mx) {\n\t\t\t\t\tadd(XX[mn][j][0], dp[i][j][1]);\n\t\t\t\t\tif (mx + 1 <= N) {\n\t\t\t\t\t\tsub(XX[mx + 1][j][0], dp[i][j][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint x = max(i + A, j + B);\n\t\t\t\tif (x <= N) {\n\t\t\t\t\tadd(res, dp[i][j][1] * p2[N - x] % MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, a, b;\nint dp[5001][2][2][5001];\t//dp[index][nowChar][flag(1:既に条件を満たす)][len] = 何通り？\n\nsigned main() {\n\tint i, j, k, l, m;\n\t\n\tcin >> n >> a >> b;\n\tif (a > b) { swap(a, b); }\n\t\n\t//最初1文字以上の0からスタート\n\tfor (i = 1; i <= n; i++) {\n\t\tif (i < a) {\n\t\t\tdp[i][1][0][0] += 1;\n\t\t}\n\t\telse if (i < b) {\n\t\t\tdp[i][1][0][i] += 1;\n\t\t}\n\t\telse {\n\t\t\tdp[i][1][1][i] += 1;\n\t\t}\n\t}\n\t\n\t//最初1文字以上の1からスタート\n\tfor (i = 1; i <= n; i++) {\n\t\tif (i < b) {\n\t\t\tdp[i][0][0][i] += 1;\n\t\t}\n\t\telse {\n\t\t\tdp[i][0][1][i] += 1;\n\t\t}\n\t}\n\t\n\t//i文字使った状態\n\tfor (i = 1; i < n; i++) {\n\t\t//今から1文字以上のj(=0,1)で埋める\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\t//k=0:未成功, k=1:成功\n\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\t//l文字利用できる\n\t\t\t\tfor (l = 0; l <= i; l++) {\n\t\t\t\t\tif (dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t//m文字連続でjを埋める\n\t\t\t\t\tfor (m = 1; i + m <= n; m++) {\n\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\tdp[i + m][!j][k || (l + m >= b)][l + m] += dp[i][j][k][l];\n\t\t\t\t\t\t\tif (dp[i + m][!j][k || (l + m >= b)][l + m] >= mod) dp[i + m][!j][k || (l + m >= b)][l + m] -= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (m < a) {\n\t\t\t\t\t\t\t\tdp[i + m][!j][k][0] += dp[i][j][k][l];\n\t\t\t\t\t\t\t\tif (dp[i + m][!j][k][0] >= mod) dp[i + m][!j][k][0] -= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t(dp[i + m][!j][k || (l + m >= b)][l + m] += dp[i][j][k][l]);\n\t\t\t\t\t\t\t\tif (dp[i + m][!j][k || (l + m >= b)][l + m] >= mod) dp[i + m][!j][k || (l + m >= b)][l + m] -= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t//i文字使った状態\n\tfor (i = n; i <= n; i++) {\n\t\t//今から1文字以上のj(=0,1)で埋める\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tfor (l = 0; l <= i; l++) {\n\t\t\t\tans += dp[i][j][1][l];\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Etavioxy\n#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define il inline\n#define ll long long\n#define rep(i,s,t) for(register int i=(s);i<=(t);i++)\n#define rev_rep(i,s,t) for(register int i=(s);i>=(t);i--)\n#define each(i,u) for(int i=head[u];i;i=bow[i].nxt)\n#define file(s) freopen(s\".in\" ,\"r\",stdin),freopen(s\".out\",\"w\",stdout)\n#define pt(x) putchar(x)\nusing namespace std;\nil int ci(){\n\tregister char ch;int f=1;\n\twhile(!isdigit(ch=getchar()))f=ch=='-'?-1:1;\n\tregister int x=ch^'0';\n\twhile(isdigit(ch=getchar()))x=(x*10)+(ch^'0');\n\treturn f*x;\n}\n\nconst int mod = 1e9+7;\nenum{N=5003};\nil ll qpow(ll a,ll b){\n\tll ans= 1;\n\tfor(; b; b>>=1,a=a*a%mod) if( b&1 ){\n\t\tans= ans*a%mod;\n\t} return ans;\n}\n\nll f[N][2],g[N][2];\nll f2[N][2];\nll w[N];\n\nint main(){\n\tint n = ci(), a = ci(), b = ci();\n\tif( a>b ) swap(a,b);\n\tif( b==1 ){\n\t\tprintf(\"%lld\\n\",qpow(2,n));\n\t\treturn 0;\n\t}\n\tf[0][0] = 1;\n\trep(i,1,b-1){\n\t\trep(j,1,i){\n\t\t\tif( j>=a ) f[i][0] = (f[i][0]+f[i-j][1])%mod;\n\t\t\tf[i][1] = (f[i][1]+f[i-j][0])%mod;\n\t\t}\n\t}\n\tf2[0][1] = 1;\n\trep(i,1,b-1){\n\t\trep(j,1,i){\n\t\t\tif( j>=a ) f2[i][0] = (f2[i][0]+f2[i-j][1])%mod;\n\t\t\tf2[i][1] = (f2[i][1]+f2[i-j][0])%mod;\n\t\t}\n\t}\n\tg[0][1] = g[0][0] = 1;\n\tll ans = qpow(2,n);\n\trep(i,1,n){\n\t\tif( i<b ){\n\t\t\tg[i][1] = (g[i][1]+f2[i][1])%mod;\n\t\t}\n\t\trep(j,1,min(i,b-1)){\n\t\t\tif( j<a ) g[i][0] = (g[i][0]+g[i-j][1])%mod;\n\t\t\tg[i][1] = (g[i][1]+g[i-j][0]*f[j][1])%mod;\n\t\t}\n\t\tif( i!=n && n-i<b ){\n\t\t\tans = (ans-g[i][0]*f[n-i][0])%mod;\n\t\t}\n\t}\n\tans = (ans-g[n][1]-g[n][0])%mod;\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tint n, a, b; cin >> n >> a >> b;\n    if(a == 1 || b == 1) {\n        cout << modpow((mint)2, n) << endl;\n        return;\n    }\n    if(a < b) swap(a, b);\n    static mint dp[5050][5050][2][2][3];\n    rep(i, 5050) {\n        rep(j, 5050) {\n            rep(k, 2) {\n                rep(l, 2) {\n                    rep(m, 2) {\n                        dp[i][j][k][l][m] = 0;\n                    }\n                }\n            }\n        }\n    }\n    dp[0][0][0][0][0] = 1;\n    rep(i, n) {\n        rep(j, n + 1) {\n                rep(l, 2) {\n                    rep(m, 3) {\n                        int nl, nm;\n                        nl = (l || (j + 1 >= a)), nm = m;\n                        dp[i + 1][j + 1][0][nl][nm] += dp[i][j][0][l][m];\n                        nl = l, nm = m;\n                        dp[i + 1][1][1][nl][nm] += dp[i][j][0][l][m];\n                        nl = l, nm = m;\n                        dp[i + 1][j + 1][1][nl][nm] += dp[i][j][1][l][m];\n                        nl = l;\n                        if(i - j >= a && j <= b - 1) nm = (m == 0 ? 1 : 2);\n                        else if(n - i >= a && j <= b - 1) nm = (m == 0 ? 1 : 2);\n                        else if(j <= b - 1) nm = 2;\n                        else nm = m;\n                        dp[i + 1][1][0][nl][nm] += dp[i][j][1][l][m];\n                    }\n                }\n        }\n    }\n    mint ans = 0;\n    rep(j, n + 1) {\n        rep(m, 2) {\n            rep(k, 2) {\n                ans += dp[n][j][k][1][m];\n            }\n            ans += dp[n][j][0][0][m];\n        }\n        if(j >= b) {\n            ans += dp[n][j][1][0][0] + dp[n][j][1][0][1];\n        }\n        else {\n            if(n - j >= a) ans += dp[n][j][1][0][0];\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 5010\nlong long ddp[N];\nlong long ddpb;\nlong long ddp2[N];\nlong long ddp2b;\nlong long dp[N];\nlong long dpb;\nlong long dp2[N];\nlong long dp2b;\nlong long ff[N];\nlong long rf[N];\n\nint main() {\n\tbool cc[70];\n\tlong long a, b, n;\n\tlong long x, y, z;\n\tlong long s, ans;\n\tx = MOD - 2;\n\tf(i, 70) {\n\t\tif (x % 2 == 1)cc[i] = true;\n\t\telse cc[i] = false;\n\t\tx /= 2;\n\t}\n\tscanf(\"%lld %lld %lld\", &n, &a, &b);\n\tif (a < b)swap(a, b);\n\tf(i, N)dp[i] = 0;\n\tdp[0] = 1;\n\tdpb = 1;\n\tff[0] = 1;\n\tf(i, a) {\n\t\tdp[i + 1] = dpb;\n\t\tf(j, i + 2 - b)dpb = (dpb + dp[j]) % MOD;\n\t\tff[i + 1] = dpb;\n\t\trf[i + 1] = 1;\n\t\tx = ff[i + 1];\n\t\tf(j, 70) {\n\t\t\tif (cc[j])rf[i + 1] = (rf[i + 1] * x) % MOD;\n\t\t\tx = (x*x) % MOD;\n\t\t}\n\t}\n\tfor (long long i = a + 1; i <= n; i++) {\n\t\tff[i] = 0;\n\t\tif ((2 * a - i - b - b) >= 0) {\n\t\t\tx = ((i - a)*(i - a)*ff[2 * a - i - b - b]) % MOD;\n\t\t\tff[i] = (ff[i] + x) % MOD;\n\t\t}\n\t\tif ((2 * a - i - b) >= 0) {\n\t\t\tx = (2 * (i - a)*ff[2 * a - i - b]) % MOD;\n\t\t\tff[i] = (ff[i] + x) % MOD;\n\t\t}\n\t\tif ((2 * a - i) >= 0) {\n\t\t\tx = ff[2 * a - i] % MOD;\n\t\t\tff[i] = (ff[i] + x) % MOD;\n\t\t}\n\n\n\n\t\trf[i] = 1;\n\t\tx = ff[i];\n\t\tf(j, 70) {\n\t\t\tif (cc[j])rf[i] = (rf[i] * x) % MOD;\n\t\t\tx = (x*x) % MOD;\n\t\t}\n\t}\n\tf(i, N) {\n\t\tdp[i] = 0;\n\t\tddp[i] = 0;\n\t\tdp2[i] = 0;\n\t\tddp2[i] = 0;\n\t}\n\tdpb = 0;\n\tddpb = 0;\n\tdp2b = 0;\n\tddp2b = 0;\n\tif (a == 1)ddp[0] = ff[1];\n\telse dp[0] = ff[1];\n\tdpb = 2;\n\tf(i, n) {\n\t\tf(j, i + 1) {\n\t\t\tif (i - j + 2 < a) {\n\t\t\t\tx = (dp[j] * rf[i - j + 1]) % MOD;\n\t\t\t\tdp2[j] = (x * ff[i - j + 2]) % MOD;\n\t\t\t\tx = (ddp[j] * rf[i - j + 1]) % MOD;\n\t\t\t\tddp2[j] = (x * ff[i - j + 2]) % MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = (dp[j] * rf[i - j + 1]) % MOD;\n\t\t\t\tddp2[j] = (x * ff[i - j + 2]) % MOD;\n\t\t\t\tx = (ddp[j] * rf[i - j + 1]) % MOD;\n\t\t\t\tdp2[j] = (x * ff[i - j + 2]) % MOD;\n\t\t\t}\n\t\t}\n\t\tif (a == 1) {\n\t\t\tdp2[i + 1] = (ddpb*ff[1]) % MOD;\n\t\t\tddp2[i + 1] = (dpb*ff[1]) % MOD;\n\t\t}\n\t\telse {\n\t\t\tdp2[i + 1] = (dpb*ff[1]) % MOD;\n\t\t\tddp2[i + 1] = (ddpb*ff[1]) % MOD;\n\t\t}\n\t\tdp2b = dpb;\n\t\tf(j, i + 2 - a)dp2b = (dp2b + dp[j]) % MOD;\n\t\tdp2b = (dp2b * 2) % MOD;\n\t\tddp2b = ddpb;\n\t\tf(j, i + 2 - a)ddp2b = (ddp2b + ddp[j]) % MOD;\n\t\tddp2b = (ddp2b * 2) % MOD;\n\t\tf(j, i + 2) {\n\t\t\tdp[j] = dp2[j];\n\t\t\tddp[j] = ddp2[j];\n\t\t\tdp2[j] = 0;\n\t\t\tddp2[j] = 0;\n\t\t}\n\t\tdpb = dp2b;\n\t\tdp2b = 0;\n\t\tddpb = ddp2b;\n\t\tddp2b = 0;\n\t}\n\tdpb = (ddpb - dpb + MOD) % MOD;\n  x=1;\n  f(i,n)x=(x*2)%MOD;\n  dpb=(dpb+x)%MOD;\n\tprintf(\"%lld\\n\", dpb);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n\n    inline ModInt fac() const {\n        static std::vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? ModInt(1) : facs[i - 1] * ModInt(i));\n        return facs[this->val];\n    }\n\n    ModInt doublefac() const {\n        lint k = (this->val + 1) / 2;\n        if (this->val & 1) return ModInt(k * 2).fac() / ModInt(2).power(k) / ModInt(k).fac();\n        else return ModInt(k).fac() * ModInt(2).power(k);\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n\n    ModInt sqrt() const {\n        if (val == 0) return 0;\n        if (mod == 2) return val;\n        if (power((mod - 1) / 2) != 1) return 0;\n        ModInt b = 1;\n        while (b.power((mod - 1) / 2) == 1) b += 1;\n        int e = 0, m = mod - 1;\n        while (m % 2 == 0) m >>= 1, e++;\n        ModInt x = power((m - 1) / 2), y = (*this) * x * x;\n        x *= (*this);\n        ModInt z = b.power(m);\n        while (y != 1) {\n            int j = 0;\n            ModInt t = y;\n            while (t != 1) j++, t *= t;\n            z = z.power(1LL << (e - j - 1));\n            x *= z, z *= z, y *= z;\n            e = j;\n        }\n        return ModInt(std::min(x.val, mod - x.val));\n    }\n};\nusing mint = ModInt<1000000007>;\n\nint main()\n{\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (A < B) swap(A, B);\n\n    vector<vector<mint>> dp0(N + 3, vector<mint>(A + 1));\n    vector<vector<mint>> dpbsuc(N + 2, vector<mint>(A + 1));\n    vector<mint> dp1(N + 1, 0);\n    dp0[0][0] = 1;\n    dp0[1][0] = -1;\n    REP(i, N)\n    {\n        REP(a, A + 1) dp0[i + 1][a] += dp0[i][a];\n        dp1[i + 1] += dp1[i] * 2;\n        REP(a, A)\n        {\n            // aをつける\n            if (a == A - 1)\n            {\n                dp1[i + 1] += dp0[i][a] + dpbsuc[i][a];\n            }\n            else\n            {\n                dp0[i + 1][a + 1] += dp0[i][a] + dpbsuc[i][a];\n                dp0[i + 2][a + 1] -= dp0[i][a] + dpbsuc[i][a];\n            }\n\n        }\n        // bをつける\n        REP(a, A)\n        {\n            if (a == A - 1)\n            {\n                dp1[i + 1] += dpbsuc[i][a];\n            }\n            else\n            {\n                dpbsuc[i + 1][a + 1] += dpbsuc[i][a];\n            }\n\n            if (i + B <= N)\n            {\n                if (a + B < A) dpbsuc[i + B][a + B] += dp0[i][a];\n                else\n                {\n                    dp1[i + B] += dp0[i][a];\n                }\n            }\n\n            if (i + B + 1 <= N) dp0[i + B + 1][1] -= dp0[i][a];\n            dp0[i + 2][1] += dp0[i][a];\n\n            // FOR(j, i + 2, i + B + 1) if (j <= N) dp0[j][1] += dp0[i][a];\n        }\n    }\n    cout << dp1[N] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(ll x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(ll exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &x) { if((val += x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &x) { if((val += mod - x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &x) { val = static_cast<unsigned long long>(val) * x.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &x) {\n    // assert(__gcd(static_cast<int>(x.val), mod) == 1);\n    unsigned a = x.val, b = mod; int u = 1, v = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(u -= tmp * v, v);\n    }\n    return *this *= u;\n  }\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return val != x.val; }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator<=(const ModInt &x) const { return val <= x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return val >= x.val; }\n  ModInt &operator++() { if (++val == mod) val = 0; return *this; }\n  ModInt operator++(int) { ModInt res = *this; ++*this; return res; }\n  ModInt &operator--() { val = (val == 0 ? mod : val) - 1; return *this; }\n  ModInt operator--(int) { ModInt res = *this; --*this; return res; }\n  ModInt operator+() const { return *this; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend ostream &operator<<(ostream &os, const ModInt &x) { return os << x.val; }\n  friend istream &operator>>(istream &is, ModInt &x) { ll val; is >> val; x = ModInt(val); return is; }\n};\nModInt abs(const ModInt &x) { return x; }\nstruct Combinatorics {\n  int val; // \"val!\" and \"mod\" must be disjoint.\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\nint main() {\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  vector dp(n + 1, vector(b + 1, vector(2, ModInt(0))));\n  dp[0][0][1] = 1;\n  REP(i, n) REP(j, b + 1) REP(k, 2) {\n    // 0\n    if (k == 1) {\n      dp[i + 1][j == b ? b : 0][0] += dp[i][j][k];\n      if (i + a <= n) {\n        dp[i + a][min(j + a, b)][0] += dp[i][j][k];\n        dp[i + a][j == b ? b : 0][0] -= dp[i][j][k];\n      }\n    } else {\n      if (j >= a) {\n        dp[i + 1][min(j + 1, b)][0] += dp[i][j][k];\n      } else {\n        dp[i + 1][j == b ? b : 0][0] += dp[i][j][k];\n      }\n    }\n    // 1\n    dp[i + 1][min(j + 1, b)][1] += dp[i][j][k];\n  }\n  cout << accumulate(ALL(dp[n][b]), ModInt(0)) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string (string s) { return '\"' + s + '\"'; }\n\nstring to_string (const char *s) { return to_string ((string) s); }\n\nstring to_string (bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string (pair<A, B> p) { return \"(\" + to_string (p.first) + \", \" + to_string (p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string (A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string (x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out () { cerr<<endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out (Head H, Tail... T) {\n    cerr<<\" \"<<to_string (H);\n    debug_out (T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin (T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax (T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop (ll x) { return 1ULL<<x; }\n\nll MOD (ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse (ll a, ll m) {\n    a = MOD (a, m);\n    if (a <= 1)return a;\n    return MOD ((1 - inverse (m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr (T x) { return x * x; }\n\nll gcd (ll a, ll b) {\n    a = abs (a), b = abs (b);\n    while (b != 0) {\n        a %= b;\n        swap (a, b);\n    }\n    return a;\n}\n\nll fast (ll a, ll b, ll mod) {\n    a %= mod;\n    if (b < 0)a = inverse (a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\n\nnamespace SOLVE {\n    const ll N = 5010;\n    ll n, a, b;\n    ll trans[N][2];\n    ll dp[N][2];\n    \n    void preprocess () {\n        trans[0][1] = 1;\n        REP(len, 1, b) {\n            trans[len][1] = trans[len - 1][0] + trans[len - 1][1];\n            REP(j, a, len + 1) {\n                trans[len][0] += trans[len - j][1];\n            }\n            trans[len][0] %= mod;\n            trans[len][1] %= mod;\n            dbg(trans[len][0], trans[len][1]);\n        }\n    }\n    \n    \n    void main () {\n        cin>>n>>a>>b;\n        if (a > b)swap (a, b);\n        preprocess ();\n        dp[0][0] = dp[0][1] = 1;\n        REP(len, 1, n + 1) {\n            REP(j, 1, min (len, a - 1) + 1) {\n                // 0\n                dp[len][0] += dp[len - j][1];\n                dp[len][0] %= mod;\n            }\n            REP(j, 1, min (len, b - 1) + 1) {\n                // 1\n                dp[len][1] += dp[len - j][0] * (j == 1 ? 1 : (trans[j - 2][1] + trans[j - 2][0])) % mod;\n                dp[len][1] %= mod;\n                if (len == n) {\n                    dp[len][1] += (trans[j - 1][0]) * dp[len - j][0];\n                }\n            }\n            if (len < b) {\n                dp[len][1] += trans[len - 1][0];\n            }\n        }\n        ll tot = dp[n][0] + dp[n][1];\n        tot = fast (2, n, mod) - tot;\n        cout<<MOD (tot, mod);\n    }\n}\n\n\nsigned main () {\n#ifdef LOCAL\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    ios::sync_with_stdio (false);\n    cin.tie (nullptr);\n    cout.tie (nullptr);\n    \n    \n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main ();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5005;\n\nint n, A, B;\n\nint dp1[N][2];\nint dp2[N][2][2];\nint dp3[N][2][2];\nint mod = 1e9 + 7;\n\nint solve1(int baki, int ki) {\n    if(baki < 0) return 0;\n    if(baki == 0) return ki == 1;\n    if(dp1[baki][ki] != -1) return dp1[baki][ki];\n    int ans = 0;\n    if(ki == 0) {\n        for(int x = 1; x < A && x <= baki; x++) {\n            ans += solve1(baki - x, ki ^ 1);\n            ans %= mod;\n        }\n    }\n    else {\n        for(int x = B; x <= baki; x++) {\n            ans += solve1(baki - x, ki ^ 1);\n            ans %= mod;\n        }\n    }\n    return dp1[baki][ki] = ans;\n}\n\nint solve2(int baki, int ki, bool nichi) {\n    if(baki < 0) return 0;\n    if(baki == 0) return nichi;\n    if(dp2[baki][ki][nichi] != -1) return dp2[baki][ki][nichi];\n    int ans = 0;\n    if(ki == 1) {\n        for(int x = 1; x <= baki; x++) {\n            ans += solve2(baki - x, ki ^ 1, nichi);\n            ans %= mod;\n        }\n    }\n    else {\n        for(int x = 1; x <= baki; x++) {\n            ans += solve2(baki - x, ki ^ 1, nichi|(x >= A));\n            ans %= mod;\n        }\n    }\n    return dp2[baki][ki][nichi] = ans;\n}\n\nint solve3(int baki, int ki, bool nichi) {\n    if(baki < 0) return 0;\n    if(baki == 0) return nichi;\n    if(dp3[baki][ki][nichi] != -1) return dp3[baki][ki][nichi];\n    int ans = 0;\n    if(ki == 1) {\n        for(int x = 1; x < B; x++) {\n            ans += solve3(baki - x, ki ^ 1, nichi);\n            ans %= mod;\n        }\n    }\n    else {\n        for(int x = 1; x <= baki; x++) {\n            int t = solve3(baki - x, ki ^ 1, nichi|(x >= A));\n            if(t >= A) {\n                t = 1ll*t*solve1(x, 0)%mod;\n            }\n            ans += t;\n            ans %= mod;\n        }\n    }\n    return dp3[baki][ki][nichi] = ans;\n}\n\nint main() {\n    // freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    memset(dp1, -1, sizeof dp1);\n    memset(dp2, -1, sizeof dp2);\n    memset(dp3, -1, sizeof dp3);\n\n    cin >> n >> A >> B;\n    if(B > A) swap(A, B);\n    int ans = solve2(n,0,0) + solve2(n,1,0);\n    ans %= mod;\n    ans += solve3(n,0,0);\n    ans %= mod;\n    ans += solve3(n,1,0);\n    ans %= mod;\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nMint x[5005][5005],ans,s[5005],pw[5005];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx[0][0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=pw[i-1]*2;\n\tfor(int l=0;l<=n;l++){\n\t\tfor(int j=0;j+l<=n;j++)s[j]=0;\n\t\tfor(int j=0;j+l<=n;j++){\n\t\t\tif(j>=a){\n\t\t\t\tans+=x[l][j]*pw[n-(l+j)];\n\t\t\t\tx[l][j]=0;\n\t\t\t}\n\t\t\tif(j==a){\n\t\t\t\tfor(int k=b;k<=l+j;k++){\n\t\t\t\t\tans+=x[l][j-k]*pw[n-(l+j)];\n\t\t\t\t\tx[l][j-k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j>a){\n\t\t\t\tans+=x[l][j-b]*Mint(2).pow(n-(l+j));\n\t\t\t\tx[l][j-b]=0;\n\t\t\t}\n\t\t\ts[j]+=x[l][j];\n\t\t\tif(j>0)s[j]+=s[j-1];\n\t\t\tif(j>0){\n\t\t\t\tx[l+j][1]+=s[j-1];\n\t\t\t\tif(j-b>=0)x[l+j][1]-=s[j-b];\n\t\t\t}\n\t\t\tif(j-b>=0&&j<a){\n\t\t\t\tx[l][j+1]+=s[j-b];\n\t\t\t}\n\t\t\tx[l][j+1]+=x[l][j];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long A[205];\nchar S[205];\n\nint B[205][64];\n\nint memo[205][4];\n\nbool forbidden[205][2];\nint lastBit[65];\n\nint N;\nint dp(int i, int j, int k){\n    if(i == N){\n        return j != 0;\n    }else if(memo[i][j] != -1){\n        return memo[i][j];\n    }else{\n        int move1 = dp(i+1, j, k);\n        int move2 = dp(i+1, j^A[i], k);\n        int ans;\n        if(S[i] == '0'){\n            if(move1 == 0 || move2 == 0){\n                ans = 0;\n            }else{\n                ans = 1;\n            }\n        }\n        if(S[i] == '1'){\n            if(move1 == 1 || move2 == 1){\n                ans = 1;\n            }else{\n                ans = 0;\n            }\n        }\n        return memo[i][j] = ans;\n    }\n}\n\nint main(){\n    int T;\n    scanf(\"%d\", &T);\n\n    while(T --){\n        scanf(\"%d\", &N);\n\n        for(int i = 0; i < N; i ++){\n            scanf(\"%lld\", &A[i]);\n        }\n\n        memset(lastBit, 0, sizeof(lastBit));\n        for(int i = 0; i < N; i ++){\n            for(int j = 0; j < 61; j ++){\n                B[i][j] = (A[i]&(1LL<<j)) >> j;\n                /*if(j < 4){\n                    printf(\"B[%d][%d]=%d\\n\", i, j, B[i][j]);\n                }*/\n            }\n        }\n\n        scanf(\" %s\", S);\n\n        memset(memo, -1, sizeof(memo));\n        printf(\"%d\\n\", dp(0, 0, 0));\n\n        /*int ans = 0;\n        memset(forbidden, 0, sizeof(forbidden));\n        for(int k = 0; k < 61; k ++){\n            memset(memo, -1, sizeof(memo));\n            if(dp(0, 0, k) == 1){\n                ans = 1;\n                break;\n            }\n            for(int i = 0; i <= N; i ++){\n                for(int j = 0; j < 2; j ++){\n                    if(dp(i, j, k) == 1){\n                        forbidden[i][j] = true;\n                        if(k<4){\n                            printf(\"forbidden(%d, %d, %d)\\n\", i, j, k);\n                        }\n                    }\n                }\n            }\n        }\n\n        printf(\"%d\\n\", ans);*/\n        /*if(S[N-1] == '1'){\n            printf(\"1\\n\");\n            continue;\n        }*/\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint n,a,b,dp[5555][5555][2],sum[5555][5555][2],sm[5555],ans,pw;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif (a>b) swap(a,b);\n\tdp[0][0][0]=dp[0][0][1]=1;\n\tsum[0][0][0]=sum[0][0][1]=1;\n\tsm[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=max(0,i-b+1);j<=i;j++)\n\t\t{\n\t\t\tfor (int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tif (!k && i==j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k]=sm[i-1];\n\t\t\t\t\tif (i-a>=0) dp[i][j][k]=(dp[i][j][k]-sm[i-a])%mod;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!k)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i-a<0) dp[i][j][k]=0;\n\t\t\t\t\t\telse dp[i][j][k]=sum[i-a][j][1];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=sum[i-1][j][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsm[i]=sm[i-1];\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tfor (int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tsum[i][j][k]=(sum[i-1][j][k]+dp[i][j][k])%mod;\n\t\t\t\tif (k==1) sm[i]=(sm[i]+dp[i][j][k])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n-b+1;i<=n;i++)\n\t{\n\t\tans=(ans+dp[n][i][0])%mod;\n\t\tans=(ans+dp[n][i][1])%mod;\n\t}\n\tpw=1;\n\tfor (int i=1;i<=n;i++) pw=(pw+pw)%mod;\n\tans=(pw-ans)%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,a,b,dp[2][2][5005],dp2[2][2][5005],ans=0;\nconst int mod=1e9+7;\nint M(int x){return x>=mod?x-mod:x;}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a>b)swap(a,b);\n\tfor(int i=a;i<=n;i++)dp[0][0][i]=1;\n\tfor(int i=1;i<=n;i++)dp[1][1][i]=1;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tfor(int u=0;u<2;u++)\n\t\t{\n\t\t\tfor(int j=a;j<=n-i;j++)dp[u][0][i+j]=M(dp[u][0][i+j]+dp[u][1][i]);\n\t\t\tfor(int j=1;j<=n-i;j++)dp[u][1][i+j]=M(dp[u][1][i+j]+dp[u][0][i]);\n\t\t}\n\t}\n\tfor(int i=1;i<a;i++)dp2[0][0][i]=1;\n\tfor(int i=1;i<b;i++)dp2[0][1][i]=M(dp[0][1][i]+dp[1][1][i]);\n\tfor(int i=b;i<n;i++)dp2[1][1][i]=M(dp[0][1][i]+dp[1][1][i]);\n\tdp2[1][1][n]=M(M(dp[0][1][n]+dp[0][0][n])+M(dp[1][0][n]+dp[1][1][n]));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int u=0;u<2;u++)\n\t\t{\n\t\t\tfor(int j=1;j<=n-i&&j<b;j++)\n\t\t\t{\n\t\t\t\tdp2[u][1][i+j]=(1ll*dp2[u][1][i+j]+1ll*dp[1][1][j]*dp2[u][0][i])%mod;\n\t\t\t\tif(i+j==n)dp2[u][0][i+j]=(1ll*dp2[u][0][i+j]+1ll*dp[1][0][j]*dp2[u][0][i])%mod;\n\t\t\t}\n\t\t\tfor(int j=b;j<=n-i;j++)\n\t\t\t{\n\t\t\t\tdp2[1][1][i+j]=(1ll*dp2[1][1][i+j]+1ll*dp[1][1][j]*dp2[u][0][i])%mod;\n\t\t\t\tif(i+j==n)dp2[1][0][i+j]=(1ll*dp2[1][0][i+j]+1ll*dp[1][0][j]*dp2[u][0][i])%mod;\n\t\t\t}\n\t\t\tfor(int j=1;j<a&&j<=n-i;j++)dp2[u][0][i+j]=M(dp2[u][0][i+j]+dp2[u][1][i]);\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++)ans=M(ans+dp2[1][i][n]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end()))\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\nmint dp0[5500][2], dp1[5500][3][2];\nsigned main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (B > A) { swap(A, B); }\n    if (B == 1) { fin(mint(2).pow(N)); }\n    dp0[0][0] = 1, dp0[0][1] = 1;\n    rep(i, N) {\n        for (int j = 1; i + j <= N; j++) { dp0[i + j][0] += dp0[i][1]; }\n        for (int j = B; i + j <= N; j++) { dp0[i + j][1] += dp0[i][0]; }\n    }\n    dp1[0][0][0] = 1, dp1[0][1][0] = 1;\n    rep(i, N) {\n        for (int j = 1; j < A && i + j <= N; j++) {\n            dp1[i + j][0][0] += dp1[i][1][0];\n            dp1[i + j][0][1] += dp1[i][1][1];\n        }\n        for (int j = 1; j < B && i + j <= N; j++) {\n            dp1[i + j][1][0] += dp1[i][0][0];\n            dp1[i + j][1][1] += dp1[i][0][1];\n            dp1[i + j][1][0] += dp1[i][2][0];\n            dp1[i + j][1][1] += dp1[i][2][1];\n        }\n        for (int j = A; i + j <= N; j++) {\n            if (i != 0 && i + j != N) {\n                dp1[i + j][2][1] += dp1[i][1][0] * dp0[j - 1][0];\n                dp1[i + j][2][1] += dp1[i][1][1] * dp0[j - 1][0];\n            } else if (j != N) {\n                dp1[i + j][2][1] += dp1[i][1][0] * dp0[j][0];\n                dp1[i + j][2][1] += dp1[i][1][1] * dp0[j][0];\n            } else {\n                dp1[i + j][2][1] += dp1[i][1][0] * (dp0[j][0] + dp0[j][1]);\n                dp1[i + j][2][1] += dp1[i][1][1] * (dp0[j][0] + dp0[j][1]);\n            }\n        }\n    }\n    cout << dp1[N][0][1] + dp1[N][1][1] + dp1[N][2][1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\nsize_t strlen(const char* s);\n#define rep(i,n) for(long long int i=0;i<n;i++)\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\nstruct ToUpper {\n\tchar operator()(char c) { return toupper(c); }\n};\nstruct ToLower {\n\tchar operator()(char c) { return tolower(c); }\n};\nconst int N = 200010;\nconst int P = 1000000007;\nusing ll = long long;\n\n//絶対値\nint ze(int a, int b) {\n\tif (a > b) {\n\t\treturn a - b;\n\t}\n\telse {\n\t\treturn b - a;\n\t}\n}\n//小さい方\nlong long int min(long long int a, long long int b) {\n\tif (a > b) {\n\t\treturn b;\n\t}\n\telse {\n\t\treturn a;\n\t}\n}\n//大きい方\nlong long int max(long long int a, long long int b) {\n\tif (a > b) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n// a^n mod \nlong long modpow(long long a, long long n, long long mod) {\n\tlong long res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n// a^{-1} mod \nlong long modinv(long long a, long long mod) {\n\treturn modpow(a, mod - 2, mod);\n}\n\n//mod掛け算\nlong long mt(long long a, long long b, long long mod) {\n\treturn (a * b) % mod;\n}\n\n//メモ\n\n/*\n\tmemset(b, '\\0', sizeof(b));\n初期化*/\n\n/*\n\tchar s[N];\n\tstrlen(s)\n*/\n\n/*\n\tif(  <  )puts(\"Yes\");\n\telse puts(\"No\");\n*/\n\n/*文字列比較\nif(strcmp(name[i],s)==0)\n*/\n\n/*\n\tgraph[a].push_back(b);//graph[a][i番目に入れた]==b\n\tgraph[j].size()\t//forで回すときとか\n\n*/\n\n/*添字1がa個、2がb個\n  vector<vector<ll>> map(a,vector<ll>(b));\n*/\nint main() {\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tif (a > b) {\n\t\tll k = a;\n\t\ta = b;\n\t\tb = k;\n\t}\n\tvector < vector<ll>> dp1(b+1, vector<ll>(b+1));\n\tvector<vector<ll>> dp2(n, vector<ll>(n));//dame owari\n\tvector<vector<ll>> dp3(n, vector<ll>(n));\n\trep(i, b+1) {\n\t\trep(j, b+1) {\n\t\t\tif (i == 0) {\n\t\t\t\tdp1.at(i).at(j)++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (j > i + a+1) {\n\t\t\t\t\tdp1.at(i).at(j) = (dp1.at(i).at(j)+dp1.at(i - 1).at(i))%P;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tdp2.at(i).at(j)++;\n\t\t\t\t\tdp3.at(i).at(j)++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdp2.at(i).at(j) = dp2.at(i - 1).at(j);\n\t\t\t\t\tdp3.at(i).at(j) = dp3.at(i - 1).at(j);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trep(k, b) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tdp2.at(i).at(j) = (dp3.at(i).at(j) + mt(dp3.at(i - 1).at(j - k), dp1.at(b).at(k), P)) % P;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trep(k, a) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tdp3.at(i).at(j) = (dp2.at(i).at(j) + mt(dp2.at(i - 1).at(j - k), 1, P)) % P;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1;\n\trep(i, n) {\n\t\tans = mt(ans, 2, P);\n\t}\n\tcout << (ans-dp2.at(n).at(n)- dp2.at(n).at(n))%P << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nint dp[5001];\nint dp2[5001];\nint dp3[5001][2];\n\nint main() {\n    int n, a, b, ans, i, j, k;\n    \n    scanf(\"%d %d %d\", &n, &a, &b);\n    \n    if (a > b) swap(a, b);\n    \n    dp[1] = 1;\n    \n    for (i = 1; i < n; i++) {\n        dp[i + 1] += dp[i];\n        if (dp[i + 1] >= mod) dp[i + 1] -= mod;\n        \n        for (j = a + 1; i + j <= n; j++) {\n            dp[i + j] += dp[i];\n            if (dp[i + j] >= mod) dp[i + j] -= mod;\n        }\n    }\n    \n    dp2[0] = 1;\n    \n    for (i = 0; i < n; i++) {\n        dp2[i + 1] += dp2[i];\n        if (dp2[i + 1] >= mod) dp2[i + 1] -= mod;\n        \n        for (j = a + 1; i + j <= n; j++) {\n            dp2[i + j] += dp2[i];\n            if (dp2[i + j] >= mod) dp2[i + j] -= mod;\n        }\n    }\n    \n    for (i = 0; i < b; i++) dp3[i][1] = dp2[i];\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < 2; j++) {\n            if (dp3[i][j] == 0) continue;\n            \n            if (j != 0) {\n                for (k = 1; k < a && i + k <= n; k++) {\n                    dp3[i + k][0] += dp3[i][j];\n                    if (dp3[i + k][0] >= mod) dp3[i + k][0] -= mod;\n                }\n            }\n            \n            if (j != 1) {\n                for (k = 1; k < b && i + k < n; k++) {\n                    dp3[i + k][1] += (long long)dp3[i][j] * dp[k] % mod;\n                    if (dp3[i + k][1] >= mod) dp3[i + k][1] -= mod;\n                }\n                \n                if (n - i < b) {\n                    dp3[n][1] += (long long)dp3[i][j] * dp2[n - i] % mod;\n                    if (dp3[n][1] >= mod) dp3[n][1] -= mod;\n                }\n            }\n        }\n    }\n    \n    ans = 1;\n    for (i = 0; i < n; i++) ans = ans * 2 % mod;\n    \n    for (i = 0; i < 2; i++) {\n        ans -= dp3[n][i];\n        if (ans < 0) ans += mod;\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5020;\nconst int mod=1e9+7;\ntypedef long long ll;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n\nint g[N][2];\nint f[N][2];\nint ans=0, n, a, b;\n\nint main()\n{\n\tcin >> n >> a >> b;\n\tif(a>b)swap(a,b);\n\tif(b>1){\n\t\tf[0][0]=f[0][1]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\t\tif(k==0&&j<a)continue;\n\t\t\t\t\tf[i][k]=add(f[i][k],f[i-j][k^1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[0][0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(i<a)g[i][0]=add(g[i][0],1);\n\t\t\tfor(int j=1;j<min(i,a);j++){\n\t\t\t\tg[i][0]=add(g[i][0], g[i-j][1]);\n\t\t\t}\n\t\t\tif(i<b)g[i][1]=add(g[i][1], add(f[i-1][0],f[i-1][1]));\n\t\t\tfor(int j=1;j<min(i,b);j++){\n\t\t\t\tint w=j==1?1:add(f[j-2][0],f[j-2][1]);\n\t\t\t\tg[i][1]=add(g[i][1],1ll*g[i-j][0]*w%mod);\n\t\t\t}\n\t\t\tif(n-i<b)ans=add(ans, mul(g[i][0], add(f[n-i-1][0],f[n-i-1][1])));\n\t\t\tif(n-i<a)ans=add(ans, g[i][1]);\n\t\t}\n\t}\n\tcout << sub(qpow(2,n), ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define mod 1000000007\n#define maxn 5010\n\nint n,a,b;\nint ksm(int x,int y){int re=1;for(;(y&1?re=1ll*re*x%mod:0),y;y>>=1,x=1ll*x*x%mod);return re;}\nint g[maxn][2],f[maxn][2];\nvoid add(int &x,int y){x=(x+y>=mod?x+y-mod:x+y);}\n\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tif(a>b)swap(a,b); g[1][1]=1;\n\tfor(int i=2;i<b;i++)\n\t{\n\t\tg[i][1]=(g[i-1][0]+g[i-1][1])%mod;\n\t\tfor(int j=a;j<i;j++)add(g[i][0],g[i-j][1]);\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<min(a,i+1);j++)add(f[i][0],f[i-j][1]);\n\t\tfor(int j=1;j<min(b,i+1);j++)\n\t\t{\n\t\t\tif(i==n)add(f[i][0],1ll*f[i-j][0]*g[j][0]%mod);\n\t\t\tif(i==j)add(f[i][1],(g[j][0]+g[j][1])%mod);\n\t\t\telse add(f[i][1],1ll*f[i-j][0]*g[j][1]%mod);\n\t\t}\n\t}\n\tprintf(\"%d\",(ksm(2,n)-(f[n][0]+f[n][1])%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) static_cast<int>((x).size())\n\nusing LL = long long;\ntemplate<class T, size_t D>\nstruct vec : vector<vec<T, D - 1>> {\n  template<class... Args>\n  vec(size_t n = 0, Args... args)\n    : vector<vec<T, D - 1>>(n, vec<T, D - 1>(args...)) {}\n};\ntemplate<class T>\nstruct vec<T, 1> : vector<T> {\n  template<class... Args>\n  vec(Args... args)\n    : vector<T>(args...) {}\n};\n\ntemplate<class T>\ninline bool asMn(T& a, const T& b) { return a > b ? a = b, true : false; }\ntemplate<class T>\ninline bool asMx(T& a, const T& b) { return a < b ? a = b, true : false; }\ninline int nex(int i, int n) { return i == n - 1 ? 0 : i + 1; }\ninline int pre(int i, int n) { return !i ? n - 1 : i - 1; }\n\nconst int mod = 1e9 + 7;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nstruct ModInt {\n  int a;\n  ModInt(int _a = 0)\n    : a(_a) {}\n  friend istream& operator>>(istream& in, ModInt& _) {\n    in >> _.a;\n    return in;\n  }\n  friend ostream& operator<<(ostream& out, const ModInt& _) {\n    out << _.a;\n    return out;\n  }\n\n  bool operator<(const ModInt& _) const { return a < _.a; }\n  bool operator>(const ModInt& _) const { return a > _.a; }\n  bool operator<=(const ModInt& _) const { return a <= _.a; }\n  bool operator>=(const ModInt& _) const { return a >= _.a; }\n  bool operator==(const ModInt& _) const { return a == _.a; }\n  bool operator!=(const ModInt& _) const { return a != _.a; }\n  bool operator!() const { return !a; }\n\n  ModInt operator+(const ModInt& _) const {\n    int ret = a + _.a;\n    return ret < mod ? ModInt(ret) : ModInt(ret - mod);\n  }\n  ModInt operator-(const ModInt& _) const { return *this + ModInt(mod - _.a); }\n  ModInt operator*(const ModInt& _) const { return ModInt((int)((LL)a * _.a % mod)); }\n  ModInt operator/(const ModInt& _) const { return *this * _.binPow(mod - 2); }\n  ModInt& operator+=(const ModInt& _) { return *this = *this + _; }\n  ModInt& operator-=(const ModInt& _) { return *this = *this - _; }\n  ModInt& operator*=(const ModInt& _) { return *this = *this * _; }\n  ModInt& operator/=(const ModInt& _) { return *this = *this / _; }\n  ModInt& operator++() { return *this = *this + ModInt(1); }\n  ModInt& operator--() { return *this = *this - ModInt(1); }\n  ModInt operator-() const { return ModInt() - *this; }\n\n  template<class T>\n  ModInt binPow(T exponent) const {\n    ModInt ret(1), c = *this;\n    for (; exponent; exponent >>= 1, c *= c) if (exponent & 1) ret *= c;\n    return ret;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) {\n    swap(a, b);\n  }\n\n  vec<ModInt, 1> pw2(n + 1);\n  pw2[0] = ModInt(1);\n  for (int i = 1; i < sz(pw2); ++i) {\n    pw2[i] = pw2[i - 1] + pw2[i - 1];\n  }\n\n  ModInt ans;\n\n  array<array<array<ModInt, 2>, 5001>, 5001> f;\n  vec<ModInt, 1> g(n + 1);\n  f[0][0][1] = g[0] = ModInt(1);\n  for (int i = 1; i <= n; ++i) {\n    f[i][1][1] += (i >= 2 ? g[i - 2] : ModInt()) - (i >= a + 1 ? g[i - a - 1] : ModInt());\n\n    for (int j = 0; j <= n; ++j) {\n      if (i >= a && j >= a) {\n        f[i][j][0] += f[i - a][j - a][1];\n      }\n\n      if (j) {\n        f[i][j][0] += f[i - 1][j - 1][0];\n\n        f[i][j][1] += f[i - 1][j - 1][0];\n        f[i][j][1] += f[i - 1][j - 1][1];\n      }\n    }\n\n    for (int j = 0; j < b; ++j) {\n      g[i] += f[i][j][1];\n    }\n    g[i] += g[i - 1];\n  }\n\n  for (int i = 1; i < n; ++i) {\n    ModInt sum;\n    for (int j = b; j <= n; ++j) {\n      sum += f[i][j][1];\n    }\n\n    for (int j = i + 1; j <= n && j - i < a; ++j) {\n      ans += sum * pw2[max(0, n - j - 1)];\n    }\n  }\n  for (int j = b; j <= n; ++j) {\n    ans += f[n][j][0] + f[n][j][1];\n  }\n\n  cout << ans << '\\n';\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define all(a) (a).begin(),(a).end()\n#define SZ(a) ((int)((a).size()))\n\ntypedef long long ll;\ntypedef long double lf;\n\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst lf pi=acosl(-1);\n/* Source code starts here */\n\nll lb[64],flb[64];\nint n;\nll a[205];\nchar s[205];\n\nbool add(ll lb[],ll x){\n\tpool(i,63){\n\t\tif(!Bit(x,i))continue;\n\t\tif(!lb[i])return (lb[i]=x),1;\n\t\tx^=lb[i];\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tmemset(lb,0,sizeof(lb));\n\tscanf(\"%d\",&n);\n\tcont(i,n)scanf(\"%lld\",a+i);\n\tscanf(\"%s\",s+1);\n\ttnoc(i,n){\n\t\tif(s[i]=='0')add(lb,a[i]);\n\t\telse{\n\t\t\tmemcpy(flb,lb,sizeof(lb));\n\t\t\tif(add(flb,a[i]))return void(puts(\"1\"));\n\t\t}\n\t}\n\tputs(\"0\");\n}\n\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--)solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <string>\nusing namespace std;\ntypedef long long int ll;\n\nconstexpr ll mod=1e9+7;\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nll dp[5050][5050][2];\nll sum0[5050];\nll sum1[5050];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n    /*int q; cin >> q;\n    while(q--){\n        int n; cin >> n;\n        vector<ll> a(n);\n        for(int i=0;i<n;i++){\n            cin >> a[i];\n        }\n        string s; cin >> s;\n        if(s[n-1]=='1'){\n            printf(\"1\\n\");\n        }\n        else{\n            //reverse(s.begin(), s.end());\n            bool one=0;\n            for(int i=0;i<n;i++){\n                if(s[i]=='1')one=1;\n            }\n            if(one){\n\n            }\n            else{\n                printf(\"0\\n\");\n            }\n        }\n    }*/\n    int n,a,b; cin >> n >> a >> b;\n    if(a==1||b==1){\n        printf(\"%lld\\n\",mod_pow(2,n));\n        return 0;\n    }\n    ll res=0;\n    dp[0][0][0]=dp[0][0][1]=1;\n    dp[1][1][0]=dp[1][1][1]=1;\n    for(int i=1;i<n;i++){\n        for(int j=1;j<=max(a,b);j++){\n            for(int k=0;k<2;k++){\n                if(k==0){\n                    if(j==a-1){\n\n                    }\n                    else if(j<a-1){\n                        (dp[i+1][j+1][0]+=dp[i][j][0])%=mod;\n                    }\n                    (dp[i+1][1][1]+=dp[i][j][k])%=mod;\n                }\n                else{\n                    if(j==b-1){\n\n                    }\n                    else if(j<b-1){\n                        (dp[i+1][j+1][1]+=dp[i][j][k])%=mod;\n                    }\n                    (dp[i+1][1][0]+=dp[i][j][k])%=mod;\n                }\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=max(a,b);j++){\n            (sum0[i]+=dp[i][j][0])%=mod;\n            (sum1[i]+=dp[i][j][1])%=mod;\n        }\n    }\n    /*for(int i=1;i<=n;i++){\n        cout << i << \" \" << 0 << \" \" << sum0[i] << endl;\n        cout << i << \" \" << 1 << \" \" << sum1[i] << endl;\n    }*/\n    sum1[0]=1;\n    sum0[0]=1;\n    if(a==b){\n        for(int i=1;i<=n;i++){\n            if(i+a-1<=n){\n                res+=sum1[i-1]*mod_pow(2,n-(i+a)+1)%mod;\n                //cout << sum1[i-1]*mod_pow(2,n-(i+a)+1) << endl;\n                //cout << sum1[i-1] << \" \" << mod_pow(2,n-(i+a)+1) << endl;\n                res%=mod;\n            }\n            if(i+b-1<=n){\n                res+=sum0[i-1]*mod_pow(2,n-(i+b)+1)%mod;\n                //cout << sum0[i-1]*mod_pow(2,n-(i+b)+1) << endl;\n                res%=mod;\n            }\n        }\n    }\n    else{\n        return 1;\n        for(int i=1;i<=n;i++){\n            if(i+a-1<=n&&a>b){\n                res+=sum1[i-1]*mod_pow(2,n-(i+a)+1)%mod;\n                //cout << sum1[i-1]*mod_pow(2,n-(i+a)+1) << endl;\n                //cout << sum1[i-1] << \" \" << mod_pow(2,n-(i+a)+1) << endl;\n                res%=mod;\n            }\n            if(i+b-1<=n&&b>a){\n                res+=sum0[i-1]*mod_pow(2,n-(i+b)+1)%mod;\n                //cout << sum0[i-1]*mod_pow(2,n-(i+b)+1) << endl;\n                res%=mod;\n            }\n        }\n    }\n    \n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nconst int nmax=5010;\nmint f[nmax][2];\nmint dp[nmax][2];\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,a,b;cin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\t\n\tmint ans;\n\t\n\tif(b>=2){\n\t\tf[0][0]=1;\n\t\tf[0][1]=1;\n\t\trng(i,1,n+1){\n\t\t\trep(k,2){\n\t\t\t\trng(j,1,i+1){\n\t\t\t\t\tif(k==0&&j<a)continue;\n\t\t\t\t\tf[i][k]+=f[i-j][k^1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvc<mint> g(n+1);\n\t\tg[0]=1;\n\t\trng(i,1,n+1)g[i]=f[i][0]+f[i][1];\n\t\t\n\t\trng(i,1,n){\n\t\t\tif(i<a)dp[i][0]+=1;\n\t\t\trng(j,1,min(i,a))dp[i][0]+=dp[i-j][1];\n\t\t\tif(i<b)dp[i][1]+=g[i-1];\n\t\t\trng(j,1,min(i,b)){\n\t\t\t\tmint w=j==1?1:g[j-2];\n\t\t\t\tdp[i][1]+=dp[i-j][0]*w;\n\t\t\t}\n\t\t\tif(n-i<b)ans+=dp[i][0]*g[n-i-1];\n\t\t\tif(n-i<a)ans+=dp[i][1];\n\t\t}\n\t}\n\t\n\tcout<<mint(2).pow(n)-ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int mod=(1e9)+7;\nconst int maxn=5010;\nint n,a,b,dp[maxn][2],f[maxn][2],g[maxn],ans,tmp;\nint ksm(int x,int y) {\n\tint res=1;\n\twhile (y) {\n\t\tif (y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod; y>>=1;\n\t} return res;\n}\nvoid update(int &x,int y) {\n\tx+=y; if (x>=mod) x-=mod;\n}\nint main() {\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(a); read(b);\n\tif (a>b) swap(a,b);\n\tif (b==1) { printf(\"%d\\n\",ksm(2,n)); return 0; }\n\tf[0][0]=f[0][1]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int k=0;k<=1;k++)\n\tfor (int j=1;j<=i;j++) {\n\t\tif (!k&&j<a) continue;\n\t\tupdate(f[i][k],f[i-j][k^1]);\n\t}\n\tg[0]=1;\n\tfor (int i=1;i<=n;i++) g[i]=(f[i][0]+f[i][1])%mod;\n\t//for (int i=1;i<=n;i++) printf(\"%d \",g[i]); printf(\"\\n\");\n\tfor (int i=1;i<n;i++) {\n\t\tif (i<a) update(dp[i][0],1);\n\t\tfor (int j=1;j<min(i,a);j++) update(dp[i][0],dp[i-j][1]);\n\t\t\n\t\tif (i<b) update(dp[i][1],g[i-1]);\n\t\tfor (int j=1;j<min(i,b);j++) {\n\t\t\tif (j==1) update(dp[i][1],dp[i-j][0]);\n\t\t\telse update(dp[i][1],(ll)dp[i-j][0]*g[j-2]%mod);\n\t\t}\n\t\t\n\t\tif (n-i<b) update(ans,(ll)dp[i][0]*g[n-i-1]%mod);\n\t\tif (n-i<a) update(ans,(ll)dp[i][1]);\n\t//\tprintf(\"%d %d %d\\n\",i,dp[i][0],dp[i][1],ans);\n\t}\n//\tprintf(\"%d %d\\n\",ksm(2,n),ans);\n\tprintf(\"%d\\n\",(ksm(2,n)-ans+mod)%mod);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui long long\n#define ull unsigned long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline ll rd()\n{\n\tll x=0,w=1;char c=gc();while(!isdigit(c)&&c!='-')c=gc();\n\tif(c=='-')c=gc(),w=-1;while(isdigit(c))x=x*10+c-48,c=gc();return x*w;\n}\nconst int N=5005,P=1e9+7;\nint n,a,b,f[N],g[N],F[N],G[N],sf[N],sg[N],sF[N],sG[N];\nint main()\n{\n\tn=rd();a=rd();b=rd();if(a>b)swap(a,b);\n\tf[1]=1;g[1]=0;sf[1]=1;sg[1]=0;\n\trep(i,2,b)\n\t{\n\t\tf[i]=sg[i-1]+1;g[i]=i>=a?sf[i-a]:0;\n\t\tsf[i]=(sf[i-1]+f[i])%P;sg[i]=(sg[i-1]+g[i])%P;\n\t}\n\tF[0]=1;sF[0]=1;G[0]=1;sG[0]=1;\n\trep(i,1,n)\n\t{\n\t\tF[i]=(sG[i-1]+P-(i>=a?sG[i-a]:0))%P;\n\t\trep(j,1,b-1)if(i-j>=0)G[i]=(G[i]+1ll*F[i-j]*f[j])%P;\n\t\tif(i<b)rep(j,a,i-1)G[i]=(G[i]+f[i-j])%P;\n\t\tsF[i]=(sF[i-1]+F[i])%P;sG[i]=(sG[i-1]+G[i])%P;\n\t}\n//\trep(i,1,b-1)cout<<f[i]<<\" \";cout<<endl;\n//\trep(i,1,b-1)cout<<g[i]<<\" \";cout<<endl;\n//\trep(i,0,n)cout<<F[i]<<\" \";cout<<endl;\n//\trep(i,0,n)cout<<G[i]<<\" \";cout<<endl;\n\tint ans=(F[n]+G[n])%P;//cout<<ans<<endl;\n\trep(i,1,b-1)rep(j,a,i-1)ans=(ans+1ll*F[n-i]*f[i-j])%P;\n\tint t=1;rep(i,1,n)t=2ll*t%P;\n\tprintf(\"%d\\n\",(t+P-ans)%P);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 5007;\nconst int MX = 1e9 + 7;\nconst LL INF = 1LL * MX * MX;\n\nint n, a, b;\nint dp[N][N][3];\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MX)\n\t\ta -= MX;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &a, &b);\n\tif(a > b)\n\t\tswap(a, b);\n\n\tif(a == 1){\n\t\tint ans = 1;\n\t\twhile(n--)\n\t\t\tadd(ans, ans);\n\t\tprintf(\"%d\\n\", ans);\n\t\texit(0);\n\t}\n\n\tdp[1][a - 1][0] = 1;\n\tdp[1][b - 1][1] = 1;\n\tdp[a][0][2] = 1;\n\t\n\tfor(int i = 1; i < n; ++i){\n\t\tfor(int c = 0; c < 3; ++c)\n\t\t\tadd(dp[i + 1][0][2], dp[i][0][c]);\n\t\t\n\t\tfor(int c = 0; c < 3; ++c)\n\t\t\tif(i + 1 < b)\n\t\t\t\tadd(dp[i + 1][b - i - 1][1], dp[i][0][c]);\n\t\t\telse\n\t\t\t\tadd(dp[i + 1][0][2], dp[i][0][c]);\n\t\t\n\t\tfor(int j = 1; j < b && n - i >= j; ++j){\n\t\t\t{\t//c = 0\n\t\t\t\tif(j > 1)\n\t\t\t\t\tadd(dp[i + 1][j - 1][0], dp[i][j][0]);\n\t\t\t\tadd(dp[i + 1][b - 1][1], dp[i][j][0]);\n\t\t\t}\n\t\t\t\n\t\t\t{\t//c = 1\n\t\t\t\tadd(dp[i + 1][j - 1][1], dp[i][j][1]);\n\t\t\t\tif(i + a <= n)\n\t\t\t\t\tadd(dp[i + a][max(j - a, 0)][2], dp[i][j][1]);\n\t\t\t\tadd(dp[i + 1][a - 1][0], dp[i][j][1]);\n\t\t\t}\n\t\t\t\n\t\t\t{\t//c = 2\n\t\t\t\tadd(dp[i + 1][j - 1][2], dp[i][j][2]);\n\t\t\t\tadd(dp[i + 1][j - 1][1], dp[i][j][2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int c = 0; c < 3; ++c)\n\t\tadd(ans, dp[n][0][c]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint main() {\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  vector dp(n + 1, vector(b + 1, vector(2, 0)));\n  dp[0][0][1] = 1;\n  REP(i, n) REP(j, b + 1) REP(k, 2) {\n    // 0\n    if (k == 1) {\n      (dp[i + 1][j == b ? b : 0][0] += dp[i][j][k]) %= MOD;\n      if (i + a <= n) {\n        (dp[i + a][min(j + a, b)][0] += dp[i][j][k]) %= MOD;\n        (dp[i + a][j == b ? b : 0][0] += MOD - dp[i][j][k]) %= MOD;\n      }\n    } else {\n      if (j >= a) {\n        (dp[i + 1][min(j + 1, b)][0] += dp[i][j][k]) %= MOD;\n      } else {\n        (dp[i + 1][j == b ? b : 0][0] += dp[i][j][k]) %= MOD;\n      }\n    }\n    // 1\n    (dp[i + 1][min(j + 1, b)][1] += dp[i][j][k]) %= MOD;\n  }\n  cout << (dp[n][b][true] + dp[n][b][false]) % MOD << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nint n, a, b;\n\nvector<string> moves(string s, int a, int b) {\n\tvector<string> rez;\n\t// for (int i = 0; i <= le(s) - a; i++) {\n\t\tfor (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < a; k++) {\n\t\t\t// \tt[i + k] = '0';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\tt[j + k] = '1';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t}\n\t// }\n\tfor (int i = 0; i <= le(s) - a; i++) {\n\t\t// for (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < b; k++) {\n\t\t\t// \tt[j + k] = '1';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tt[i + k] = '0';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t// }\n\t}\n\treturn rez;\n}\n\nint bfs(int n, int a, int b) {\n\tdeque<string> deq{string(n, '0')};\n\tset<string> used;\n\twhile (!deq.empty()) {\n\t\tstring s = deq[0];\n\t\tdeq.pop_front();\n\t\tif (used.count(s)) continue;\n\t\tused.insert(s);\n\t\tfor (string t : moves(s, a, b)) {\n\t\t\tdeq.pb(t);\n\t\t}\n\t}\n\t// for (string s : used) {\n\t// \tif (s.back() == '1' && s[le(s) - 2] == '0') {\n\t// \t\tprint s;\n\t// \t}\n\t// }\n\t// print used;\n\treturn le(used);\n}\n\nint mem[2][5010][5010];\nnum dp(int n, int l, bool can_one) {\n\tif (n < 0) return 0;\n\tif (n == 0) return l >= a;\n\tif (mem[can_one][n][l] != -1) return mem[can_one][n][l];\n\tnum rez = 0;\n\tif (l >= a) {\n\t\trez = num(2).pow(n + can_one - 1);\n\t} else {\n\t\tif (can_one) {\n\t\t\tfor (int ones = 1; ones <= n; ones++) {\n\t\t\t\tif (ones < b) {\n\t\t\t\t\trez += dp(n - ones, 0, false);\n\t\t\t\t} else {\n\t\t\t\t\trez += dp(n - ones, l + ones, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trez += dp(n - 1, l + 1, true);\n\t}\n\tmem[can_one][n][l] = rez.value;\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tscan n, a, b;\n\tif (a < b) swap(a, b);\n\tprint dp(n, 0, true);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 5000\n#define X 1000000007\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\n#define swap(x,y) (x^=y^=x^=y)\nusing namespace std;\nint n,a,b,f[N+5][2],g[N+5],w[N+5][2];\nI int QP(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nint main()\n{\n\tRI i,j,t;if(scanf(\"%d%d%d\",&n,&a,&b),t=QP(2,n),a>b&&swap(a,b),a==1) return printf(\"%d\\n\",t),0;\n\tfor(f[0][0]=f[0][1]=i=1;i<=n;++i) for(j=1;j<=i;++j) j>=a&&Inc(f[i][0],f[i-j][1]),Inc(f[i][1],f[i-j][0]);\n\tfor(g[0]=i=1;i<=n;++i) g[i]=(f[i][0]+f[i][1])%X;for(i=1;i^n;++i)\n\t{\n\t\tfor(i<a&&(w[i][0]=1),j=1;j^min(i,a);++j) Inc(w[i][0],w[i-j][1]);\n\t\tfor(i<b&&(w[i][1]=g[i-1]),j=1;j^min(i,b);++j) Inc(w[i][1],(j<=2?1LL:1LL*g[j-2])*w[i-j][0]%X);\n\t\tn-i<a&&Inc(t,X-w[i][1]),n-i<b&&Inc(t,X-1LL*w[i][0]*g[n-i-1]%X);\n\t}return printf(\"%d\\n\",t),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=10009,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\tint g[2][N],f[N],h[N],n,a,b;\n\tint main(){\n\t\tn=read<int>(),a=read<int>(),b=read<int>();\n\t\tif(a<b) swap(a,b);\n\n\t\tg[1][0]=1;\n\t\tfor(int i=1;i<a;i++){\n\t\t\tfor(int j=b;j<i;j++) g[1][i]=add(g[1][i],g[0][i-j]);\n\t\t\tfor(int j=1;j<=i;j++) g[0][i]=add(g[0][i],g[1][i-j]);\n\t\t//\tcout<<i<<\" \"<<g[0][i]<<\" \"<<g[1][i]<<endl;\n\t\t\tfor(int j=1;j<b;j++) h[i+j]=add(h[i+j],g[0][i]);\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<h[i]<<\" \";cout<<endl;\n\t\tfor(int i=0;i<b;i++) f[i]=1;\n\t\tfor(int i=1;i<a;i++)\n\t\t\tfor(int j=1;j<b;j++) f[i+j]=add(f[i+j],g[1][i]);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<min(i+1,a+b-1);j++) f[i]=add(f[i],1LL*f[i-j]*h[j]%mod);\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";\n\t//\tcout<<endl;\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=n-a+1;i<=n;i++) ans=add(ans,1LL*f[i]*add(g[0][n-i],g[1][n-i])%mod);\n\t\tprintf(\"%d\\n\",sub(qpow(2,n),ans));\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint M(int x) { return x >= mod ? x - mod : x; }\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getchar();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getchar();\n    }\n    return x * f;\n}\nint n, A, B;\nint f[5003][5003], g[5003][5003];\nint pf[10004][5003], pg[10004][5003];\n\nint S(int *p, int l, int r) { return M(p[r] - (l > 0 ? p[l - 1] : 0) + mod); }\n\nint main() {\n    n = read(), A = read(), B = read();\n    if (A > B) swap(A, B);\n    int res = 1;\n    for (int i = 1; i <= n; ++i) res = M(res << 1);\n    if (A == 1) return printf(\"%d\\n\", res), 0;\n\n    for (int i = 1; i <= B; ++i)\n        f[0][i] = pf[i + n][0] = g[0][i] = pg[i + n][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        int s = 0;\n        for (int x = 1; x <= min(A - 1, i); ++x) Add(s, g[i - x][B]);\n        for (int j = 1; j <= B; ++j) {\n            f[i][j] = pf[j - i + n][i] = M(s + S(pg[j - i + n], i - j, i - A));\n            g[i][j] = pg[j - i + n][i] = S(pf[j - i + n], i - j, i - 1);\n        }\n        // cerr << \"##\" << i << endl;\n        // for (int j = 1; j <= B; ++j) cerr << f[i][j] << ' ';\n        // cerr << endl;\n        // for (int j = 1; j <= B; ++j) cerr << g[i][j] << ' ';\n        // cerr << endl;\n\n        for (int j = 1; j <= B + n; ++j)\n            Add(pf[j][i], pf[j][i - 1]), Add(pg[j][i], pg[j][i - 1]);\n    }\n    printf(\"%d\\n\", M(res + mod - M(g[n][B] + f[n][B])));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N,A,B;\n\nmint dp1[5100][5100][2];\nbool used1[5100][5100][2];\nmint func1(int i, int a_len, int fin)\n{\n\tif (a_len >= A) {\n\t\tfin = 1;\n\t}\n\tif (fin != 0) {\n\t\ta_len = 0;\n\t}\n\tif (i == N) {\n\t\tif (fin != 0) {\n\t\t\treturn 1_mi;\n\t\t}\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp1[i][a_len][fin];\n\tif (used1[i][a_len][fin]) {\n\t\treturn memo;\n\t}\n\tused1[i][a_len][fin] = true;\n\n\treturn memo = func1(i + 1, a_len + 1, fin) + func1(i + 1, 0, fin);\n}\n\nmint dp2[5100][5100][2];\nbool used2[5100][5100][2];\nmint func2(int i, int a_len, int fin)\n{\n\tif (a_len >= A) {\n\t\tif (fin != 0) { return 0_mi; }\n\t\tfin = 1;\n\t}\n\tif (fin != 0) {\n\t\ta_len = 0;\n\t}\n\tif (i == N) {\n\t\tif (fin != 0) {\n\t\t\treturn 1_mi;\n\t\t}\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp2[i][a_len][fin];\n\tif (used2[i][a_len][fin]) {\n\t\treturn memo;\n\t}\n\tused2[i][a_len][fin] = true;\n\n\treturn memo = func2(i + 1, a_len + 1, fin) + func2(i + 1, 0, fin);\n}\n\nmint dp3[5100];\nbool used3[5100];\nmint func3(int n)\n{\n\tif (n <= 0) {\n\t\treturn 1_mi;\n\t}\n\n\tauto& memo = dp3[n];\n\tif (used3[n]) {\n\t\treturn memo;\n\t}\n\tused3[n] = true;\n\n\tmemo = func3(n - 1);\n\tfor (int c = B; c <= n; c++)\n\t{\n\t\tmemo += func3(n - c - 1);\n\t}\n\treturn memo;\n}\n\n\nmint pow2[5100];\nmint dp5[5100][5100];\nbool used5[5100][5100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[5100][5100][2];\nbool used4[5100][5100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\tif (i >= N) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, i + B);\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\n\tmint res1 = func1(0, 0, 0);\n\tmint res2 = func2(0, 0, 0);\n\tmint res3 = func3(A);\n\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \nconst int mod=1e9+7;\nint f[5005][2],g[5005],dp[5005][2];\nsigned main(){\n\tint sum=0,ans=1;\n\tint n,A,B;\n\tcin>>n>>A>>B;\n\tif(A>B) swap(A,B);\n\tf[0][0]=f[0][1]=1;g[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=A;j<=i;++j)\n\t\t\tf[i][0]=(f[i][0]+f[i-j][1])%mod;\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tf[i][1]=(f[i][1]+f[i-j][0])%mod;\n\t\tg[i]=(f[i][0]+f[i][1])%mod;\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tif(i<A) dp[i][0]=1;\n\t\tif(i<B) dp[i][1]=f[i][1];\n\t\tfor(int j=1;j<min(i,A);++j)\n\t\t\tdp[i][0]=(dp[i][0]+dp[i-j][1])%mod;\n\t\tfor(int j=1;j<min(i,B);++j)\n\t\t\tdp[i][1]=(dp[i][1]+dp[i-j][0]*((j<2)?1:g[j-2])%mod)%mod;\n\t\tif(n-i<A) sum=(sum+dp[i][1])%mod; //后面全是0\n\t\tif(n-i<B) sum=(sum+dp[i][0]*g[n-i-1]%mod)%mod; //后面是方案，防止重复往后面加一个 1 的分隔符 \n\t}\n\tfor(int i=1;i<=n;++i) ans=ans*2ll%mod;\n\tans=(ans-sum+mod)%mod;\n\tcout<<ans;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <bits/stdc++.h>\n \nusing namespace std;\n\ntypedef long long ll;\n\n\n\nint main(){\n    int a,b,n;\n    ;\n    cin>>n;\n    cout<<'\\n';\n    cin>>a;\n    cout<<'\\n';\n    cin>>b;\n    cout<<'\\n';\n    \n    if(n<a||n<b)cout<<\"error\";\n    if(a>b)cout<<\"error\";\n   \n   if(n==1)ver=2;\n   if(n==2&&a==1)ver=4;\n   if(n==2&&a==2&&b==2)ver=2;\n   if(n==3&&a==1)ver=8;\n   if(n==3&&a==2)ver=4;\n   if(n==3&&a==3&&b==3)ver=2;\n   \n　std::string (int)str[n];\n　for(int i=0;i<n;i++){\n　    str[i]=0;\n　}\n　\n　\n \n   \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 5005\nconst int mod=1e9+7;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,f[N][2],dp[N][2],A,B,ans;\n#define ck(x) (x>=mod?x-mod:x) \nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read(),A=read(),B=read();\n\tif(A>B)swap(A,B);\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<B;++i){\n\t\tfor(int j=A;j<=i;++j){\n\t\t\tf[i][0]=ck(f[i][0]+f[i-j][1]);\n\t\t}\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tf[i][1]=ck(f[i][1]+f[i-j][0]);\n\t\t}\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tdp[i][0]+=(i<A);\n\t\tdp[i][1]+=(i<B?f[i][1]:0);\n\t\tfor(int j=1;j<min(i,A);++j){\n\t\t\tdp[i][0]=ck(dp[i][0]+dp[i-j][1]);\n\t\t}\n\t\tfor(int j=1;j<min(i,B);++j){\n\t\t\tdp[i][1]=(dp[i][1]+1LL*dp[i-j][0]*f[j-1][1])%mod;\n\t\t}\n\t\tif(n-i<A)ans=ck(ans+dp[i][1]);\n\t\tif(n-i<B)ans=(ans+1LL*dp[i][0]*f[n-i][1])%mod;\n\t}\n\tprintf(\"%d\\n\",(qpow(2,n)-ans+mod)%mod);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long N, A, B;\nlong long dp[6009][6009][2];\nlong long ru[6009][6009];\nlong long power[6009];\nlong long Answer;\n\nvoid init() {\n\tpower[0] = 1;\n\tfor (int i = 1; i <= 5000; i++) power[i] = (2LL * power[i - 1]) % mod;\n}\n\nvoid solve(int pos) {\n\t// 累積和を取る\n\tfor (int i = 0; i <= N; i++) {\n\t\tru[pos][i] = ru[pos - 1][i];\n\t\tru[pos][i] += dp[pos - 1][i][0];\n\t\tru[pos][i] %= mod;\n\t}\n\n\t// 長い方を使う場合\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[pos][i][0] += dp[pos - 1][i][1];\n\t\tdp[pos][i][0] += dp[pos - 1][i][0];\n\t\tdp[pos][i][0] %= mod;\n\t\tif ((pos - i) >= A) {\n\t\t\tAnswer += dp[pos][i][0] * power[N - pos];\n\t\t\tAnswer %= mod;\n\t\t\tdp[pos][i][0] = 0;\n\t\t}\n\t}\n\n\t// 短い方を使う場合（そして失敗する場合）\n\tlong long rem = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tint cl = max(0LL, pos - B + 1), cr = max(-1, pos - 1);\n\t\trem += (ru[cr + 1][i] - ru[cl][i] + mod) % mod;\n\t\trem %= mod;\n\t}\n\tdp[pos][pos][1] = rem;\n\n\t// 短い方を使う場合（そして成功する場合）\n\tfor (int i = 0; i <= N; i++) {\n\t\tint cr = max(-1LL, pos - B);\n\t\tlong long val = ru[cr + 1][i];\n\t\tdp[pos][i][1] += val;\n\t\tif ((pos - i) >= A) {\n\t\t\tAnswer += dp[pos][i][1] * power[max(0LL, N - pos - 1)];\n\t\t\tAnswer %= mod;\n\t\t\tdp[pos][i][1] = 0;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> A >> B;\n\tif (A < B) swap(A, B);\n\tinit();\n\n\tdp[0][0][0] = 1;\n\tfor (int i = 1; i <= N; i++) solve(i);\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tint n, a, b; cin >> n >> a >> b;\n    if(a > b) swap(a, b);\n    static mint dp[5050][5050][2][2];\n    rep(i, 5050) {\n        rep(j, 5050) {\n            rep(k, 2) {\n                rep(l, 2) {\n                    dp[i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    dp[0][0][1][0] = 1;\n    rep(i, n) {\n        for(int j = 0; j <= i; ++ j) {\n            //0\n            if(j + 1 < a) dp[i + 1][j + 1][0][0] += dp[i][j][0][0];\n            \n            if(j + 1 < b && j >= a) dp[i + 1][j + 1][0][1] += dp[i][j][0][1];\n\n            if(j < b && 1 < a) dp[i + 1][1][0][0] += dp[i][j][1][0];\n            if(j < b && j + a < b && i + a <= n) dp[i + a][j + a][0][1] += dp[i][j][1][0];\n            //1\n            if(j < a && 1 < b) dp[i + 1][1][1][0] += dp[i][j][0][0];\n            if(j + 1 < b) dp[i + 1][j + 1][1][0] += dp[i][j][0][1];\n            if(j + 1 < b) dp[i + 1][j + 1][1][0] += dp[i][j][1][0];\n        }\n    }\n    mint ans = modpow((mint)2, n);\n    for(int i = 0; i <= n; ++ i) {\n        rep(j, 2) {\n            rep(k, 2) {\n                ans -= dp[n][i][j][k];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <numeric>\n#include <iostream>\nusing namespace std;\n\nint M = 1000000007;\n\nint main() {\n    int n, a, b; cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n\n    long long ans = 1;\n    for (int i = 0; i < n; i++) ans = ans * 2 % M;\n    if (a > 1) {\n        long long dp[n][3][b];\n        memset(dp, 0, sizeof dp);\n        dp[0][0][1] = 1;\n        dp[0][1][1] = 0;\n        dp[0][2][1] = 1;\n        for (int i = 1; i < n; i++) {\n            dp[i][0][1] = accumulate(dp[i-1][2]+1, dp[i-1][2]+b, 0LL) % M;\n            for (int j = 2; j < a; j++) dp[i][0][j] = dp[i-1][0][j-1];\n            if (i+1 == a) dp[i][1][a] = 1;\n            for (int j = a+1; j < b; j++)\n                dp[i][1][j] = (dp[i-1][1][j-1] + (i >= a ? dp[i-a][2][j-a] : 0)) % M;\n            dp[i][2][1] = accumulate(dp[i-1][0]+1, dp[i-1][0]+a, 0LL) % M;\n            for (int j = 2; j < b; j++)\n                dp[i][2][j] = (dp[i-1][1][j-1] + dp[i-1][2][j-1]) % M;\n        }\n        ans -= accumulate(dp[n-1][0]+1, dp[n-1][0]+a, 0LL) % M;\n        ans -= accumulate(dp[n-1][1]+1, dp[n-1][1]+b, 0LL) % M;\n        ans -= accumulate(dp[n-1][2]+1, dp[n-1][2]+b, 0LL) % M;\n    }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp make_pair\n\ntypedef tree<\n        pair<int, int>,\n        null_type,\n        less<pair<int, int>>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n\nconst int p = 1e9 + 7;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\nmt19937 rnd(time(0));\n\nstruct DSU {\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU(int n) {\n        sz.resize(n);\n        parent.resize(n);\n        for (int i = 0; i < n; i++) make_set(i);\n    }\n};\n\n/*\nconst int N = 1200000;\n\nvector<int> facs(N), invfacs(N);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n*/\n\nvoid solve()\n{\n    int n;\n    cin>>n;\n    int a, b;\n    cin>>a>>b;\n    if (a>b) swap(a, b);\n\n    vector<vector<vector<int>>> block(2, vector<vector<int>>(2, vector<int>(b)));\n\n    for (int len = 1; len<b; len++)\n    {\n        for (int last = 0; last<2; last++)\n            for (int first = 0; first<2; first++)\n            {\n                if (first == last)\n                {\n                    if (last ==1|| len>=a) block[first][last][len] = 1;\n                }\n                if (last == 0)\n                {\n                    for (int lenlast = a; lenlast<len; lenlast++) block[first][last][len] = add(block[first][last][len], block[first][1-last][len - lenlast]);\n                }\n                else\n                {\n                    for (int lenlast = 1; lenlast<len; lenlast++) block[first][last][len] = add(block[first][last][len], block[first][1-last][len - lenlast]);\n                }\n            }\n    }\n\n\n    //cout<<\"Here\"<<endl;\n\n    vector<int> dp1(n+1); //start with white\n    vector<int> dp2(n+1); //start with block\n    for (int i = 1; i<=n; i++)\n    {\n        if (i<a) dp1[i] = 1;\n        for (int j = 1; j<min(a, i); j++) dp1[i] = add(dp1[i], dp2[i-j]);\n        for (int j = 1; j<min(b, i); j++) dp2[i] = add(dp2[i], mul(block[1][1][j], dp1[i-j]));\n    }\n\n    ll res = 0;\n    for (int pref = 0; pref<b; pref++)\n        for (int suf = 0; suf<b; suf++) if (pref+suf<n)\n        {\n            int P, S;\n            if (pref==0) P = 1;\n            else P = add(block[0][1][pref], block[1][1][pref]);\n            if (suf==0) S = 1;\n            else S = add(block[1][0][suf], block[1][1][suf]);\n            res = add(res, mul(mul(P, S), dp1[n-pref-suf] ));\n        }\n\n    cout<<sub(po(2, n), res);\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t = 1;\n    //cin>>t;\n    while(t--) solve();\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=5005;\nconst int mod=1e9+7;\nint n,a,b;\nint f[maxn][maxn],sum[maxn],sf[maxn][maxn];\n\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)ans=2LL*ans%mod;\n\tif(a<b)swap(a,b);\n\tf[0][0]=sf[0][0]=sum[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tsum[i]=sum[i-1];\n\t\tfor(int j=0;j<=i&&j<a;j++){\n\t\t\tif(j==0){\n\t\t\t\tf[i][j]=(i<b);\n\t\t\t\tif(i>=2)Add(f[i][j],(sum[i-2]-(i-b-1<0?0:sum[i-b-1])+mod)%mod);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf[i][j]=f[i-1][j-1];\n\t\t\t\tif(i==j&&i>=b)Add(f[i][j],1);\n\t\t\t\tif(j>=b+1)Add(f[i][j],sf[i-j][j-(b+1)]);\n\t\t\t} \n\t\t\tsf[i-j][j]=(!j?0:sf[i-j][j-1]);\n\t\t\tAdd(sf[i-j][j],f[i][j]);\n\t\t\tif(j+1<a)Add(sum[i],f[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)ans=(ans+mod-f[n][i])%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n//    #include <boost/multiprecision/cpp_int.hpp>\n  //  using namespace boost::multiprecision;\n #define int  long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n  #define PI 3.14159265358979323846\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[1000100];\n                int inv[1000110];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n               \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\nint dp[5010*2][5010]={};\nint rui[5010*2][5010]={};\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint a,b;\n\tint n;\n\tcin>>n;\n\tcin>>a>>b;\n\t\n\tif(a<b)swap(a,b);\n\t\n\tdp[n+1][a]++;\n\tdp[n+1][a-1]++;\n\trui[n+1][a]++;\n\trui[n+1][a-1]+=2;\n\tfor(int i=n-1;i>=0;i--){\n\t\t/*\n\t\tfor(int j=i+1;j<=i+a+1;j++){\n\t\t\tfor(int k=0;k<=a;k++)cout<<dp[j][k]<<\" \";\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t\t*/\n\t\tif(i==0)break;\n\t\t\n\t\tfor(int j=i+a;j>i;j--){\n\t\t\tint y=dp[j][i+a+1-j]+(i+a+b+1-j<=a?rui[j][i+a+b+1-j]:0);\n\t\t\ty%=inf;\n\t\t\tdp[j][i+a-j]=y;\n\t\t\trui[j][i+a-j]=(y+rui[j][i+a+1-j])%inf;\n\t\t\t\n\t\t}\n\t\t\n\t\tint cnt=2;\n\t\tint cnt2=b+1;\n\t\tint wa=0;\n\t\tfor(int j=i+a;j>=i+2;j--){\n\t\t\twa+=rui[j][cnt]+inf-(cnt2<=a?rui[j][cnt2]:0);\n\t\t\t//wa+=dp[j][cnt];\n\t\t\t//cout<<rui[j][cnt]<<\" \"<<(cnt2<=a?rui[j][cnt2]:0)<<\"    \"<<rui[j][cnt]-(cnt2<=a?rui[j][cnt2]:0)<<\" \"<<dp[j][cnt]<<endl;\n\t\t\t//cout<<wa<<endl;\n\t\t\tcnt++;\n\t\t\tcnt2++;\n\t\t}\n\t\tfor(int j=1;j<b;j++){\n\t\t\twa+=dp[i+a+1][j];\n\t\t\tdp[i+a][j+1]+=dp[i+a+1][j];\n\t\t\tdp[i+a][j+1]%=inf;\n\t\t}\n\t\twa%=inf;\n\t\tfor(int j=0;j<=a;j++)if(j==0||j>=b){\n\t\t\tdp[i+a][j]+=2*dp[i+a+1][j];\n\t\t\tdp[i+a][j]%=inf;\n\t//\t\tcout<<\" \"<<dp[i+a][j]<<endl;\n\t\t}\n\t\tif(a>1)\t{\tdp[i+1][a-1]=wa;\n\t//\tcout<<wa<<endl;\n\t\trui[i+1][a-1]=(dp[i+1][a-1]+rui[i+1][a])%inf;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=a;j++)if(j==0||j>=b)ans+=dp[a+1][j];\n\tcout<<ans%inf<<endl;\n\t\n\treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define Mod 1000000007\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\tif (A > B) {\n\t\tB += A;\n\t\tA = B - A;\n\t\tB -= A;\n\t}\n\n\tint i, j, k;\n\tlong long ans = 0, **dp[2];\n\tdp[0] = (long long**)malloc(sizeof(long long*) * B);\n\tdp[1] = (long long**)malloc(sizeof(long long*) * B);\n\tfor (i = 0; i <= B - 1; i++) {\n\t\tdp[0][i] = (long long*)malloc(sizeof(long long) * (A + 1));\n\t\tdp[1][i] = (long long*)malloc(sizeof(long long) * (A + 1));\n\t}\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[0][A%2][A-1] = 2; j >= 1; j--) dp[0][A%2][j] = dp[0][A%2][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[0][1-i%2][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[0][i%2][1] = dp[0][1-i%2][A-1]; j >= 1; j--) {\n\t\t\t\tdp[0][i%2][j+1] = dp[0][1-i%2][j];\n\t\t\t\tdp[0][i%2][1] += dp[0][1-i%2][j];\n\t\t\t}\n\t\t\tdp[0][i%2][1] %= Mod;\n\t\t}\n\t} else {\n\t\tdp[1][1][0] = 1;\n\t\tdp[1][0][1] = 1;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tdp[i%2][0][1] = 0;\n\t\t\tans = (ans * 2 + dp[1-i%2][B-1][0] + dp[1-i%2][B-A][A-1] + dp[1-i%2][B-A-1][A] * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 2; j >= 1; j--) dp[i%2][j+1][0] = dp[1-i%2][j][0];\n\t\t\tfor (j = B - 1, dp[i%2][B-A][1] = 0; j >= B - A; j--) dp[i%2][B-A][1] += dp[1-i%2][j][0];\n\t\t\tdp[i%2][B-A][1] %= Mod;\n\t\t\tfor (; j >= 1; j--) dp[i%2][j][1] = dp[1-i%2][j][0];\n\t\t\t\n\t\t\tfor (k = A - 1, dp[i%2][1][0] = 0; k >= 1; k--) {\n\t\t\t\tfor (j = 0; j <= B - A; j++) {\n\t\t\t\t\tdp[i%2][j][k+1] = dp[1-i%2][j][k];\n\t\t\t\t\tdp[i%2][1][0] += dp[1-i%2][j][k];\n\t\t\t\t}\n\t\t\t\tdp[i%2][1][0] %= Mod;\n\t\t\t}\n\t\t\tfor (j = 0; j <= B - A - 2; j++) {\n\t\t\t\tdp[i%2][j+1][A] = (dp[i%2][j+1][A] + dp[1-i%2][j][A]) % Mod;\n\t\t\t\tdp[i%2][j+A+1][0] = (dp[i%2][j+A+1][0] + dp[1-i%2][j][A]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem C by cookiedoth\nGenerated 07 Jun 2020 at 04.29 PM\n\n\n──────▄▌▐▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▌\n───▄▄██▌█░ВЕЗЁМ▄▀▀▀▄░ГУСЕЙ░░░░░░░\n───████▌█▄███▀░◐░▄▀▀▀▄░░РАБОТЯГИ░\n──██░░█▌█░░▄███▀░◐░░▄▀▀▀▄░░░░░░░\n─██░░░█▌█░░░░▐░▄▀▀▀▌░░░░◐░▀███▄░\n▄██████▌█▄███▀░◐░░░▌░░░░░▐░░░░░░\n███████▌█░░░░▌░░░░░▌░░░░░▐░░░░░░\n███████▌█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▌\n▀(@)▀▀▀▀▀▀▀(@)(@)▀▀▀▀▀▀▀▀▀▀▀▀▀(@)▀(@)\n\no_O\n-_-\nz_z\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\nint mul(int a, int b) {\n\treturn (1LL * a * b) % MOD;\n}\n\nconst int mx = 5010;\nint n, a, b, dp1[mx][2][2], dp2[mx][3][2];\n\nvoid read() {\n\tcin >> n >> a >> b;\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n}\n\nvoid calc_dp1() {\n\tfor (int d1 = 0; d1 < 2; ++d1) {\n\t\tfor (int d2 = 0; d2 < 2; ++d2) {\n\t\t\tdp1[0][d1][d2] = (d1 != d2);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int d1 = 0; d1 < 2; ++d1) {\n\t\t\tfor (int d2 = 0; d2 < 2; ++d2) {\n\t\t\t\tint low_sz = (d1 == 0 ? a : 1);\n\t\t\t\tfor (int j = low_sz; j <= i; ++j) {\n\t\t\t\t\tadd(dp1[i][d1][d2], dp1[i - j][d1 ^ 1][d2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// cerr << \"dp1\" << endl;\n\t// for (int i = 1; i <= n; ++i) {\n\t// \tfor (int d1 = 0; d1 < 2; ++d1) {\n\t// \t\tfor (int d2 = 0; d2 < 2; ++d2) {\n\t// \t\t\tcerr << i << \" \" << d1 << \" \" << d2 << \" \" << dp1[i][d1][d2] << endl;\n\t// \t\t}\n\t// \t}\n\t// }\n}\n\nvoid calc_dp2() {\n\tfor (int it = 0; it < 3; ++it) {\n\t\tdp2[0][it][0] = 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int d1 = 0; d1 < 3; ++d1) {\n\t\t\tfor (int need = 0; need < 2; ++need) {\n\t\t\t\tif (d1 == 2) {\n\t\t\t\t\tfor (int j = 1; j < min(i + 1, a); ++j) {\n\t\t\t\t\t\tadd(dp2[i][d1][need], dp2[i - j][1][need]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\t\t\tint new_need = (j >= b ? 0 : need);\n\t\t\t\t\t\tint val = dp1[j][d1][1];\n\t\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\t\tadd(val, dp1[j][d1][0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tadd(dp2[i][d1][need], mul(dp2[i - j][2][new_need], val));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_ans() {\n\tint ans = 0;\n\tfor (int it = 0; it < 3; ++it) {\n\t\tadd(ans, dp2[n][it][1]);\n\t}\n\tcout << ans << '\\n';\n}\n\nsigned main() {\n\tfast_io();\n\tread();\n\tcalc_dp1();\n\tcalc_dp2();\n\tprint_ans();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\ntemplate <int32_t P>\nstruct ModInt_t {\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<1000000007>;\n\nconst int MAX = 5050;\n\nModInt f[MAX][MAX][2];\n\nModInt solve(int N, int A, int B) {\n  if (A > B) swap(A, B);\n  // A <= B\n\n  f[0][0][0] = ModInt{1};\n  for (int i = 0; i <= N; ++i) {\n    for (int c = 0; c <= B; ++c) {\n      if (i == N) continue;\n\n      if (c == B) {\n        f[i + 1][c][0] += ModInt{2} * f[i][c][0];\n        f[i + 1][c][1] += ModInt{2} * f[i][c][1];\n        continue;\n      }\n\n      f[i + 1][c + 1][0] += f[i][c][0] + f[i][c][1];\n\n      f[i + 1][c + 1][1] += f[i][c][1];\n\n      f[i + 1][0][0] += f[i][c][0];\n\n      if (i + A <= N && (i == 0 || c > 0)) {\n        int rc = min(B, c + A);\n        f[i + A][0][0] -= f[i][c][0];\n        f[i + A][rc][1] += f[i][c][0];\n      }\n    }\n  }\n  return f[N][B][0] + f[N][B][1];\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int N, A, B;\n  cin >> N >> A >> B;\n\n  auto ret = solve(N, A, B);\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) { return std::vector<T>(n, std::forward<T>(val)); }\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\ntemplate<class Cond> struct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  template<class T> bool operator()(T& a, const T& b) const { if(cond(a, b)) { a = b; return true; } return false; }\n};\ntemplate<class Cond> chain<Cond> make_chain(Cond cond) { return chain<Cond>(cond); }\n\n#include <iostream>\nusing i64 = long long;\ntemplate<i64 M> struct modint { i64 a;\n  constexpr modint(const i64 x = 0): a((x%M+M)%M){}\n  constexpr i64 value() const { return a; }\n  constexpr modint inv() const { return this->pow(M-2); }\n  constexpr modint pow(i64 r) const {\n    modint ans(1); modint aa = *this;\n    while(r) { if(r & 1) ans *= aa; aa *= aa; r >>= 1; }\n    return ans;\n  }\n  constexpr modint& operator=(const i64 r) { a = (r % M + M) % M; return *this; }\n  constexpr modint& operator+=(const modint r) { a += r.a; if(a >= M) a -= M; return *this; }\n  constexpr modint& operator-=(const modint r) { a -= r.a; if(a < 0) a += M; return *this; }\n  constexpr modint& operator*=(const modint r) { a = a * r.a % M; return *this; }\n  constexpr modint& operator/=(const modint r) { (*this) *= r.inv(); return *this; }\n  constexpr modint operator+(const modint r) const { return modint(*this) += r; }\n  constexpr modint operator-(const modint r) const { return modint(*this) -= r; }\n  constexpr modint operator*(const modint r) const { return modint(*this) *= r; }\n  constexpr modint operator/(const modint r) const { return modint(*this) /= r; }\n  constexpr bool operator!=(const modint r) const { return this->value() != r.value(); }\n};\n\ntemplate<const i64 M> std::ostream& operator<<(std::ostream& os, const modint<M>& m) { os << m.value(); return os; }\n\nusing fp = modint<(i64)(1e9 + 7)>;\n\nint main() {\n  i64 N, A, B;\n  cin >> N >> A >> B;\n  if(A > B) swap(A, B);\n  // A <= B\n  vector<fp> res(N + 2);\n  {\n    vector<fp> dp(N + 2);\n    vector<fp> add(N + 2);\n    dp[0] = fp(1);\n    for(int i = 0;i < N; i++) {\n      dp[i] += add[i];\n      add[i + 1] += add[i];\n      res[i + 1] += res[i];\n      res[i] += dp[i];\n\n      dp[i + 1] += dp[i];\n      // +A\n      if(i + A <= N){\n        res[i + A] += dp[i];\n        add[i + A + 1] += dp[i];\n      }\n    }\n    dp[N] += add[N];\n    res[N] += dp[N];\n  }\n\n  fp ans(0);\n  {\n    auto dp = ndvec(N + 1, 2, fp());\n    rep(i,1,N) {\n      // 0\n      if(i < A) dp[i][0] += fp(1);\n      rep(j,1,min(i, A)) dp[i][0] += dp[i - j][1];\n\n      // 1\n      if(i < B) dp[i][1] += res[i - 1];\n      rep(j,1,min(i, B)) {\n        fp w = (j == 1 ? 1 : res[j - 2]);\n        dp[i][1] += dp[i - j][0] * w;\n      }\n      if(N - i < B) ans += dp[i][0] * res[N - i - 1];\n      if(N - i < A) ans += dp[i][1];\n    }\n  }\n  cout << fp(2).pow(N) - ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5010, P = 1000000007;\nint n, A, B, ans, pw[maxn], f[maxn][maxn][2], pre[maxn][maxn][2], h[maxn];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &A, &B);\n    if (A < B) swap(A, B);\n    pw[0] = pw[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        pw[i] = (pw[i - 1] + pw[i - 1]) % P;\n    }\n    f[0][0][0] = f[0][0][1] = 1, h[0] = 1;\n    pre[0][0][0] = pre[0][0][1] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            (f[i][j][0] += pre[i - 1][i - j][1]) %= P;\n            (f[i][j][1] += pre[i - B][i - j][0]) %= P;\n        }\n        for (int j = max(0, i - B + 1); j < i; j++) {\n            (f[i][0][1] += h[j]) %= P;\n        }\n        for (int j = A; j <= i; j++) {\n            int s = 1LL * (f[i][j][0] + f[i][j][1]) * pw[n - i] % P;\n            (ans += s) %= P, f[i][j][0] = f[i][j][1] = 0;\n        }\n        for (int j = 0; j <= i; j++) {\n            (h[i] += f[i][j][0]) %= P;\n            pre[i][i - j][0] = (pre[i - 1][i - j][0] + f[i][j][0]) % P;\n            pre[i][i - j][1] = (pre[i - 1][i - j][1] + f[i][j][1]) % P;\n        }\n    }\n    printf(\"%d\\n\", (ans + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int mod = (int) 1e9 + 7;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = 5005;\nint n, a, b;\n\nbool read() {\n  if (scanf(\"%d%d%d\", &n, &a, &b) < 3) {\n    return false;\n  }\n  return true;\n}\n\nint dp[maxn][maxn][2];\nint dp0[maxn][2];\n\nvoid solve() {\n  if (a < b) {\n    swap(a, b);\n  }\n  memset(dp, 0, sizeof(dp));\n  memset(dp0, 0, sizeof(dp0));\n  add(dp[0][0][1], 1);\n  add(dp[1][0][1], mod - 1);\n  add(dp0[0][0], 1);\n  add(dp0[1][0], mod - 1);\n  add(dp0[0][1], 1);\n  add(dp0[1][1], mod - 1);\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      for (int t = 0; t < 2; t++) {\n        auto &cur = dp[i][j][t];\n        if (i) {\n          add(cur, dp[i - 1][j][t]);\n        }\n        //eprintf(\"%d %d %d: %d\\n\", i, j, t, cur);\n        if (!cur || i >= n) {\n          continue;\n        }\n        int l = i + 1, r = n;\n        if (t) {\n          l = min(r, i + b);\n        }\n        add(dp[l][j][!t], cur);\n        add(dp[r][j][!t], mod - cur);\n        if (t && i + b <= n) {\n          if (j + a > n) {\n            add(dp0[n][!t], cur);\n            add(dp0[n + 1][!t], mod - cur);\n          }\n        }\n        if (!t) {\n          int l = i + 1, r = n + 1;\n          int m = j + a;\n          if (l < m) {\n            add(dp0[l][!t], cur);\n            add(dp0[min(r, m)][!t], mod - cur);\n          }\n        }\n      }\n    }\n    for (int t = 0; t < 2; t++) {\n      auto &cur = dp0[i][t];\n      if (i) {\n        add(cur, dp0[i - 1][t]);\n      }\n      //eprintf(\"%d %d: %d\\n\", i, t, cur);\n      if (!cur || i >= n) {\n        continue;\n      }\n      int l = i + 1, r = n + 1;\n      if (t) {\n        r = min(r, i + b);\n      } else {\n        r = min(r, i + a);\n      }\n      add(dp0[l][!t], cur);\n      add(dp0[r][!t], mod - cur);\n      if (!t) {\n        int l = i + 1, r = n + 1;\n        add(dp[l][i][!t], cur);\n        add(dp[r][i][!t], mod - cur);\n      }\n    }\n  }\n  int res = 1;\n  for (int i = 0; i < n; i++) {\n    res = mul(res, 2);\n  }\n  add(res, mod - dp0[n][0]);\n  add(res, mod - dp0[n][1]);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD=1000000007;\n\nll n,a,b;\nll x[5002];\nvoid x_init(){\n\tll dp[5005][2];\n\tdp[1][0]=1;\n\tdp[1][1]=0;\n\tfor(int i=1;i<=a;i++){\n\t\tdp[i+1][0]+=dp[i][0];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tif(i+b<=a){\n\t\t\tdp[i+b][1]+=dp[i][0];\n\t\t\tif(dp[i+b][1]>=MOD)dp[i+b][1]-=MOD;\n\t\t}\n\t\tdp[i+1][0]+=dp[i][1];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tdp[i+1][1]+=dp[i][1];\n\t\tif(dp[i+1][1]>=MOD)dp[i+1][1]-=MOD;\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tx[i]=dp[i][0];\n\t\t//cout<<i<<\":\"<<x[i]<<endl;\n\t}\n}\n\nint main(){\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx_init();\n\t\n\tll dp[5002][2]={};\n\tfor(int i=1;i<=a-1;i++){\n\t\tdp[i][0]=x[i+1];\n\t}\n\tfor(int i=1;i<=b-1;i++){\n\t\tdp[i][1]=1;\n\t}\n\tfor(int i=1;i<=n-1;i++){\n\t\tfor(int j=1;j<=b-1;j++){\n\t\t\tif(i+j<=n){\n\t\t\t\tdp[i+j][1]+=dp[i][0];\n\t\t\t\tif(dp[i+j][1]>=MOD)dp[i+j][1]-=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=a-1;j++){\n\t\t\tif(i+j<n){\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j+1];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=1;\n\tfor(int i=0;i<n;i++){\n\t\tret*=2;\n\t\tret%=MOD;\n\t}\n\tret+=MOD-dp[n][0];\n\tret+=MOD-dp[n][1];\n\tcout<<ret%MOD<<endl;\n\t//cout<<(dp[n][0]+dp[n][1])%MOD<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007;\nconst int Maxn = 5005;\n\nint res;\nint pw2[Maxn];\nint n, a, b;\nint ind[Maxn];\nint delt[Maxn][Maxn];\n\nvoid Add(int &res, int x) { res = (res + x) % mod; }\n\nvoid Sub(int &res, int x) { res = (res - x + mod) % mod; }\n\nint main()\n{\n    pw2[0] = 1;\n    for (int i = 1; i < Maxn; i++)\n        pw2[i] = 2ll * pw2[i - 1] % mod;\n    scanf(\"%d %d %d\", &n, &a, &b);\n    if (a > b) swap(a, b);\n    Add(delt[0][1], 1);\n    Sub(delt[0][2], 1);\n    for (int i = 0; i <= n; i++) {\n        for (int j = i + 1; j <= n + 1; j++) {\n            int cur = 0;\n            if (j > 0) Add(delt[i][j], delt[i][j - 1]);\n            Add(cur, delt[i][j]);\n            if (j == i + 2) {\n                if (i > 0) Add(ind[i], ind[i - 1]);\n                Add(cur, ind[i]);\n            }\n            if (j - 1 - i >= b) { Add(res, ll(cur) * pw2[n + 1 - j] % mod); continue; }\n            Add(delt[i][j + 1], cur);\n            Sub(delt[i][j + 2], cur);\n            int lim = min(a, n + 1 - j);\n            Add(ind[j], cur);\n            Sub(ind[j + lim - 1], cur);\n            if (j + a <= n + 1) {\n                if (j - 1 - i + a >= b) {\n                    Add(delt[i][j + a], cur);\n                    Sub(delt[i][j + a + 1], cur);\n                } else {\n                    Add(delt[i][j + a + 1], cur);\n                    Add(delt[i][n + 1], cur);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\tll n, a, b;  cin >> n >> a >> b;\n\tif (a<b) swap(a, b);\n\tmll all = POW(mll(2), n);\n\tif (b==1) bye(all);\n\n\t//iでj=0,1が終わりj=1,0に変わる組合せ\n\t//1は必ずB文字以上続く\n\tvvmll dq(a-1, vmll(2));\n\tauto Dq = [&](ll i, ll j)->mll&{\n\t\treturn dq[i][j];\n\t};\n\n\trep(i, 0, a-2) Dq(i, 0)=1;\n\n\trep(i, 0, a-3){\n\t\t//0から配る\n\t\trep(ii, i+b, a-2){\n\t\t\tDq(ii, 1) += Dq(i, 0);\n\t\t}\n\t\t//1から配る\n\t\trep(ii, i+1, a-2){\n\t\t\tDq(ii, 0)+= Dq(i, 1);\n\t\t}\n\t}\n\t\n\t//dqの先頭1バージョン 端でのみ使う\n\tvvmll dqq(a-1, vmll(2));\n\tauto Dqq = [&](ll i, ll j)->mll&{\n\t\treturn dqq[i][j];\n\t};\n\n\trep(i, b-1, a-3) Dqq(i, 1)=1;\n\n\trep(i, 0, a-3){\n\t\t//0から配る\n\t\trep(ii, i+b, a-2){\n\t\t\tDqq(ii, 1) += Dqq(i, 0);\n\t\t}\n\t\t//1から配る\n\t\trep(ii, i+1, a-2){\n\t\t\tDqq(ii, 0)+= Dqq(i, 1);\n\t\t}\n\t}\n\n\n\t//iでj=0,1が終わりj=1,0に変わる組合せ\n\t//j=1に変わった後はB-1文字以下しか続かない\n\t//j=0に変わった後次にj=1に変わるまでA-1文字以内\n\tvvmll dp(n+1, vmll(2));\n\tauto Dp = [&](ll i, ll j)->mll&{\n\t\treturn dp[i+1][j];\n\t};\n\tDp(-1, 0)=1;\n\tDp(-1, 1)=1;\n\trep(i, 0, a-2){\n\t\tDp(i, 0)+=Dqq(i, 0);\n\t}\n\n\trep(i, -1, n-2){\n\t\t//0から配る\n\t\trep(ii, i+1, min(i+b-1,n-1)){\n\t\t\tDp(ii, 1) += Dp(i, 0);\n\t\t}\n\t\t//1から配る\n\t\trep(iii, 1, a-1){\n\t\t\tll ii=i+iii;\n\t\t\tif (ii>=n)break;\n\t\t\tDp(ii, 0) += Dp(i, 1)*Dq(iii-1, 0);\n\t\t}\n\t}\n\n\trep(iii, 0, a-2){\n\t\tDp(n-1, 1) += Dp(n-1-iii-1,1)*Dqq(iii, 0);\n\t}\n\n\tmll ans = all - Dp(n-1, 0) - Dp(n-1, 1);\n\tcout << ans << '\\n';\n\n#if 0\n\tll n, a, b;  cin >> n >> a >> b;\n\tmll all = POW(mll(2), n);\n\tif (a==1 or b==1) bye(all);\n\n\tll c=max(a, b);\n\n\tvvvmll dp(n, vvmll(c, vmll(2)));\n\tauto Dp = [&](ll i, ll j, ll k)->mll&{\n\t\tstatic mll dmy=0;\n\t\tif (j==a and k==0) return dmy;\n\t\tif (j==b and k==1) return dmy;\n\t\treturn dp[i][j][k];\n\t};\n\tDp(0, 1, 0)=1;\n\tDp(0, 1, 1)=1;\n\n\trep(i, 0, n-2){\n\t\tll ii=i+1;\n\t\trep(k, 0, 1){\n\t\t\trep(j, 1, c-1){\n\t\t\t\tif (k==0 and j>=a) break;\n\t\t\t\tif (k==1 and j>=b) break;\n\n\t\t\t\trep(kk, 0, 1){\n\t\t\t\t\tif (k==kk){\n\t\t\t\t\t\tDp(ii, j+1, kk)+=Dp(i, j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tDp(ii, 1, kk)+=Dp(i, j, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmll ans=0;\n\trep(j, 1, a-1){\n\t\tans+=Dp(n-1, j, 0);\n\t}\n\trep(j, 1, b-1){\n\t\tans+=Dp(n-1, j, 1);\n\t}\n\tans=all-ans;\n\tcout << ans << '\\n';\n#endif\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll M = 1e9+7;\nconst int MN = 5010;\nll dp[2][2][MN];\nll ew[MN];\nint main() {\n\tll n,a,b;\n\tcin >> n >> a >> b;\n\tif(a > b) {swap(a,b);}\n\tint cu = 0;\n\tmemset(dp,0,sizeof(dp));\n\tdp[cu][0][0] = 1;\n\tmemset(ew,0,sizeof(ew));\n\tew[0] = 1;\n\tfor(int i=0;i<=n;i++) {\n\t\tew[i+1] += ew[i];\n\t\tif(ew[i+1] >= M) {ew[i+1] -= M;}\n\t\tfor(int j=a;j+i+1<=n;j++) {\n\t\t\tew[i+j+1] += ew[i];\n\t\t\tif(ew[i+j+1] >= M) {ew[i+j+1] -= M;}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) {\n\t\tint nu = 1-cu;\n\t\tmemset(dp[nu],0,sizeof(dp[nu]));\n\t\tfor(int j=0;j<a;j++) {\n\t\t\tdp[nu][0][j+1] += dp[cu][0][j];\n\t\t\tif(dp[nu][0][j+1] >= M) {dp[nu][0][j+1] -= M;}\n\t\t\tdp[nu][1][1] += dp[cu][0][j];\n\t\t\tif(dp[nu][1][1] >= M) {dp[nu][1][1] -= M;}\n\t\t}\n\t\tfor(int j=0;j<b;j++) {\n\t\t\tdp[nu][1][j+1] += dp[cu][1][j];\n\t\t\tif(dp[nu][1][j+1] >= M) {dp[nu][1][j+1] -= M;}\n\t\t\tll tr = dp[cu][1][j];\n\t\t\tif(j == i) {\n\t\t\t\ttr = tr*ew[max(j,0)]%M;\n\t\t\t} else {\n\t\t\t\ttr = tr*ew[max(j-1,0)]%M;\n\t\t\t}\n\t\t\tdp[nu][0][1] += tr;\n\t\t\tif(dp[nu][0][1] >= M) {dp[nu][0][1] -= M;}\n\t\t}\n\t\tcu = nu;\n\t}\n\tll res = 0;\n\tfor(int i=0;i<a;i++) {\n\t\tres += dp[cu][0][i];\n\t}\n\tfor(int i=0;i<b;i++) {\n\t\tll tr = dp[cu][1][i];\n\t\ttr = tr*ew[max(i,0)]%M;\n\t\tres += tr;\n\t}\n\tres %= M;\n\tll go = 1;\n\tfor(int i=0;i<n;i++) {\n\t\tgo *= 2;\n\t\tif(go >= M) {go -= M;}\n\t}\n\tres = go-res;\n\tres = ((res%M)+M)%M;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=b-1LL;i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nll dp[5050][2];\n\nlong long modpow(long long a, long long b){ \n  long long r = 1LL;\n  while(b){\n    if(b & 1LL)r *= a;\n    if(r >= MOD)r %= MOD;\n    a *= a;\n    if(a >= MOD)a %= MOD;\n    b >>= 1LL;\n  }\n  return r%MOD;\n}\n\nint main(){\n  ll n,a,b;\n  cin>>n>>a>>b;\n  ll all = pow(2,n);\n  all %= MOD;\n  if(a==1||b==1){\n    cout << all << endl;\n    return 0;\n  }\n  swap(a,b);\n  clr(dp,0);\n  dp[0][0]=1;\n  dp[0][1]=1;\n  rep(i,1,n){\n    rep(j,0,a-1){\n      if(i+j<5050){\n        dp[i+j][0] += dp[i-1][0];\n        dp[i+j][0] %= MOD;\n      }\n    }\n    rep(j,0,b-1){\n      if(i+j<5050){\n        dp[i+j][1] += dp[i-1][1];\n        dp[i+j][1] %= MOD;\n      }\n    }\n  }\n  ll ans1 = 0;\n  rep(i,0,n){\n    ll d = n-i;\n    if(d<a){\n      ans1 += dp[i][0];\n      ans1 %= MOD;\n    }\n    if(d<b){\n      ans1 += dp[i][1];\n      ans1 %= MOD;\n    }    \n  }\n  cout << (all+2LL+MOD+MOD-ans1)%MOD << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 5005, mod = 1e9 + 7;\n\nint n, A, B;\nint f[maxN + 1][2], g[maxN + 1][2], h[maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int SUB(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &A, &B);\n\n\tif(A > B) swap(A, B);\n\n\tg[1][1] = 1;\n\tfor(int i = 2; i <= B - 1; i++)\n\t{\n\t\tg[i][1] = ADD(g[i - 1][0], g[i - 1][1]);\n\t\tfor(int j = A; j <= i; j++)\n\t\t\tg[i][0] = ADD(g[i][0], g[i - j][1]);\n\t}\n\n\tfor(int i = A + 1; i <= B - 1; i++) h[i] = ADD(h[i - 1], g[i - A][1]);\n\n\tf[0][0] = f[0][1] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= min(i, A - 1); j++) f[i][0] = ADD(f[i][0], f[i - j][1]);\n\t\tfor(int j = 1; j <= min(i, B - 1); j++)\n\t\t{\n\t\t\tif(i == n) f[i][1] = ADD(f[i][1], 1ll * f[i - j][0] * g[j][0] % mod);\n\t\t\tif(j == i) f[i][1] = ADD(f[i][1], 1ll * f[i - j][0] * h[j] % mod); \n\t\t\tf[i][1] = ADD(f[i][1], 1ll * f[i - j][0] * g[j][1] % mod);\n\t\t}\n\t}\n\n\tint ans = 1;\n\tfor(int i = 1; i <= n; i++) ans = 2ll * ans % mod;\n\tans = SUB(ans, ADD(f[n][0], f[n][1]));\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 5000;\nconst int MOD = int(1E9) + 7;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return 1LL * x * y % MOD;}\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=mul(b,b))\n\t\tif( i & 1 ) ret = mul(ret, b);\n\treturn ret;\n}\n\nint f[MAXN + 5], g[2][MAXN + 5], N, A, B;\nint main() {\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tif( A < B ) swap(A, B);\n\t\n\tf[0] = 1;\n\tfor(int i=1;i<A;i++) {\n\t\tf[i] = add(f[i - 1], i >= B);\n\t\tfor(int j=B;i>j;j++)\n\t\t\tf[i] = add(f[i], f[i - j - 1]);\n\t}\n\t\n\tg[0][0] = g[1][0] = 1;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<=i&&j<B;j++)\n\t\t\tg[0][i] = add(g[0][i], g[1][i - j]);\n\t\t\n\t\tif( i != 1 ) g[1][i] = add(g[1][i], g[0][i - 1]);\n\t\tfor(int j=2;j<i&&j<A;j++)\n\t\t\tg[1][i] = add(g[1][i], mul(f[j - 2], g[0][i - j]));\n\t\tif( i < A ) g[1][i] = add(g[1][i], f[i - 1]);\n\t}\n\t\n\tint ans = sub(pow_mod(2, N), g[0][N]);\n\tfor(int i=1;i<A;i++)\n\t\tans = sub(ans, mul(f[i - 1], g[0][N - i]));\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\n\nconst int N = 5200;\nconst int MOD = 1e9 + 7;\n\nint dp[N][2];\nint dp1[N][2];\n\nint main()\n{\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n    dp1[0][0] = 1;\n    for (int i = 1; i < b; i++)\n    {\n        for (int j = a; j <= i; j++)\n        {\n            dp1[i][0] = (dp1[i][0] + dp1[i - j][1]) % MOD;\n        }\n        dp1[i][1] = (dp1[i - 1][0] + dp1[i - 1][1]) % MOD;\n    }\n\n    dp[0][1] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j < a && j <= i; j++)\n        {\n            dp[i][0] = (dp[i][0] + dp[i - j][1]) % MOD;\n        }\n        for (int j = 1; j < b && j <= i; j++)\n        {\n            dp[i][1] = (dp[i][1] + 1ll * dp[i - j][0] * dp1[j][1]) % MOD;\n        }\n        //cout << i << \" \" << dp[i][0] << \" \" << dp[i][1] << \"\\n\";\n    }\n    int ans = 1;\n    for (int i = 0; i < n; i++) ans = (ans + ans) % MOD;\n\n    for (int p = 0; p < b; p++)\n    {\n        for (int s = 0; s < b && s + p < n; s++)\n        {\n            ans = (ans - 1ll * (dp1[p][1] + dp1[p][0]) * (dp1[s][1] + dp1[s][0]) % MOD * dp[n - p - s][0]) % MOD;\n            ans = (ans + MOD) % MOD;\n        }\n    }\n\n    cout << ans;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#define int long long\n#define pb push_back\n#define x first\n#define y second\n#define mk(a,b) make_pair(a,b)\n#define rr return 0\n#define sqr(a) ((a)*(a))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate<class value, class cmp = less<value> >\nusing ordered_set = tree<value, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<class value, class cmp = less_equal<value> >\nusing ordered_multiset = tree<value, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<class key, class value, class cmp = less<key> >\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n\n/// find_by_order()\n/// order_of_key()\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int randll(int l = INT_MIN, int r = INT_MAX) {\n    return uniform_int_distribution<int>(l, r)(rng);\n}\nconst int INF = 1e9, MOD = 1e9 + 7; /// think\nconst ll LINF = 1e18;\n\n\nconst int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\ninline bool inside (int x, int y, int n, int m) {\n    return 0 <= x && 0 <= y && x < n && y < m;\n}\n\ntemplate<class T> bool umin (T &a, T b) {return a > b ? (a = b, true) : false; }\ntemplate<class T> bool umax (T &a, T b) {return a < b ? (a = b, true) : false; }\n\ninline int mul (int a, int b, int m = MOD) {\n    return ((ll)a * b) % m;\n}\n\ninline int binpow (int a, int n, int m = MOD) {\n    int ans = 1;\n    for (; n; n >>= 1) {\n        if (n & 1) ans = mul(ans, a, m);\n        a = mul(a, a, m);\n    }\n    return ans;\n}\n\ninline void add (int &a, int x, int m = MOD) {\n    a += x;\n    if (a >= m) a -= m;\n    if (a < 0) a += m;\n}\n\ninline int sum (int a, int b, int m = MOD) {\n    a += b;\n    if (a >= m) a -= m;\n    if (a < 0) a += m;\n    return a;\n}\n\ninline int inv (int x, int m = MOD) {\n    return binpow(x, m - 2, m); /// only if m is prime\n}\n\nint n, a, b;\nconst int N = 5001;\nint dp[N][N][2][2] = {}, pref[N][2] = {};\nint pr[N][N][2][2] = {};\n\nmain()\n{\n    ios::sync_with_stdio(0);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n    dp[0][0][0][1] = 1;\n    dp[0][0][0][0] = 1;\n    pr[0][0][0][0] = 1;\n    pr[0][0][0][1] = 1;\n    pref[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int t1 = 0; t1 < 2; t1++) {\n            pref[i][t1] = pref[i - 1][t1];\n            add(dp[i][0][t1][0], pref[i - 1][t1]);\n            if (i - a >= 0) {\n                add(dp[i][0][t1][0], -pref[i - a][t1]);\n            }\n        }\n        for (int j = 0; j <= i; j++) {\n            if (j) {\n                add(dp[i][j][1][1], pr[i - 1][j - 1][1][0]);\n            }\n            int mnk = max(1, j - b + 1);\n            if (i >= mnk && j >= mnk) {\n                add(dp[i][j][j >= b][1], pr[i - mnk][j - mnk][0][0]);\n            }\n            if (i >= a && j >= a) {\n                add(dp[i][j][1][0], pr[i - a][j - a][1][1]);\n            }\n            mnk = max(a, j - b + 1);\n            if (i >= mnk && j >= mnk) {\n                add(dp[i][j][j >= b][0], pr[i - mnk][j - mnk][0][1]);\n            }\n        }\n        for (int j = 0; j <= i; j++) {\n            for (int t1 = 0; t1 < 2; t1++) {\n                add(pref[i][t1], dp[i][j][t1][1]);\n                for (int t2 = 0; t2 < 2; t2++) {\n                    if (j) {\n                        pr[i][j][t1][t2] = pr[i - 1][j - 1][t1][t2];\n                    }\n                    add(pr[i][j][t1][t2], dp[i][j][t1][t2]);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int j = 0; j <= n; j++) {\n        add(ans, dp[n][j][1][0]);\n        add(ans, dp[n][j][1][1]);\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define m_p make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rnf(2106);\nconst int N = 1000006;\n\nint n;\nchar a[N];\n\nbool stg1()\n{\n    bool z = true;\n    for (int i = 0; i < n; ++i)\n    {\n        if (i % 2 == 0)\n        {\n            if (a[i] == '1')\n            {\n                z = false;\n                break;\n            }\n        }\n        else\n        {\n            if (a[i] == '0')\n            {\n                z = false;\n                break;\n            }\n        }\n    }\n    if (z)\n        return true;\n    z = true;\n    for (int i = 0; i < n; ++i)\n    {\n        if (i % 2 == 1)\n        {\n            if (a[i] == '1')\n            {\n                z = false;\n                break;\n            }\n        }\n        else\n        {\n            if (a[i] == '0')\n            {\n                z = false;\n                break;\n            }\n        }\n    }\n    return z;\n}\n\nvoid solv()\n{\n    scanf(\" %s\", a);\n    n = strlen(a);\n    if (stg1())\n    {\n        printf(\"1\\n\");\n        return;\n    }\n    int minu = 0, maxu = 0;\n    int ans = 1;\n    for (int i = 0; i < n; ++i)\n    {\n        if (a[i] == '0')\n        {\n            --minu;\n            --maxu;\n        }\n        else if (a[i] == '1')\n        {\n            ++minu;\n            ++maxu;\n        }\n        else\n        {\n            ++minu;\n            --maxu;\n            minu = min(0, minu);\n            maxu = max(0, maxu);\n        }\n        ans = max(ans, max(abs(minu), abs(maxu)));\n    }\n    ans = max(ans, 2);\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n    #ifdef SOMETHING\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #endif // SOMETHING\n    //ios_base::sync_with_stdio(false), cin.tie(0);\n    solv();\n    return 0;\n}\n\n//while ((double)clock() / CLOCKS_PER_SEC <= 0.9){}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    int val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(int v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        int a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            int t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, int n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nmint dp[5050][5050][2][2];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,a,b;\n  cin >> n >> a >> b;\n\n  if(a>b) swap(a,b); // a<b\n\n  dp[0][0][1][0] = 1;\n  REP(i,n){\n    REP(j,i+1){\n      dp[i+1][0][0][0] += dp[i][j][0][0]; // 0\n      if(j+1 < b) dp[i+1][j+1][1][0] += dp[i][j][0][0]; // 1\n\n      if(j+1 < b) dp[i+1][j+1][0][1] += dp[i][j][0][1]; // 0\n      if(j+1 < b) dp[i+1][j+1][1][0] += dp[i][j][0][1]; // 1\n\n      dp[i+1][0][0][0] += dp[i][j][1][0]; // 0\n      if(j+1 < b) dp[i+1][j+1][1][0] += dp[i][j][1][0]; // 1\n\n      if(i+a <= n){\n        if(j+a < b) dp[i+a][j+a][0][1] += dp[i][j][1][0]; // A個の0\n        dp[i+a][0][0][0] -= dp[i][j][1][0];\n      }\n    }\n  }\n\n  mint ans = 1;\n  REP(_,n) ans *= 2;\n  REP(i,n+1) REP(j,2) REP(k,2) ans -= dp[n][i][j][k];\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint brute(int N,int A,int B){\n    int res=0;\n    for (int mask=0;mask<(1<<N);++mask){\n        auto d=[&](int i){return (mask&1<<i)>>i;};\n        vector<pair<int,int>> v;\n        int cnt=1;\n        for (int i=0;i+1<N;++i){\n            if (d(i)!=d(i+1)){\n                v.emplace_back(d(i),cnt);\n                cnt=1;\n            } else ++cnt;\n        }\n        v.emplace_back(d(N-1),cnt);\n        for (auto &p:v){\n            if (p.first==1&&p.second>=B){\n                p.first=0;\n            }\n        }\n        int now=0,ok=0;\n        for (auto p:v){\n            if (p.first==1) now=0;\n            else {\n                now+=p.second;\n                if (now>=A) ok=1;\n            }\n        }\n        // debug(mask,ok,v);\n        res+=ok;\n    }\n    return res;\n}\n\nconst int MAX_N=5010;\n\nmint dp[MAX_N][MAX_N][2];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,A,B; cin >> N >> A >> B;\n    if (A<B) swap(A,B);\n    dp[0][0][0]=1;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<A;++j){\n            dp[i+1][j+1][0]+=dp[i][j][0];\n            if (j>=B) dp[i+1][j+1][0]+=dp[i][j][1];\n            if (j+1!=B) dp[i+1][j+1][1]+=dp[i][j][1];\n            dp[i+B][min(A,j+B)][1]+=dp[i][j][0];\n            dp[i+1][1][1]+=dp[i][j][0];\n            if (j<B) dp[i+1][1][0]+=dp[i][j][1];\n        }\n        /*\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][0] << (j==B?'\\n':' ');\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][1] << (j==B?'\\n':' ');\n        cerr << '\\n';\n        */\n    }\n    mint ans=0,po=1;\n    for (int i=N;i>=0;--i){\n        ans+=(dp[i][A][0]+dp[i][A][1])*po;\n        po*=2;\n    }\n    cout << ans << '\\n';\n    // cout << brute(N,A,B) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "."
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n\nint32_t N,A,B;\n\n\n\nmint pow2[5100];\nmint dp5[5100][5100];\nbool used5[5100][5100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[5100][5100][2];\nbool used4[5100][5100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\tif (i >= N) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, std::min(i + B,N));\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n//Aは[a_end-A, a_end)\nmint func(int i, int a_end, bool prev_is_b)\n{\n\tstatic mint dp[5100][5100][2];\n\tstatic bool used[5100][5100][2];\n\tif (N < i || N + 1 <= a_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\tassert(i <= N);\n\n\tauto& memo = dp[i][a_end][prev_is_b?0:1];\n\tif (used[i][a_end][prev_is_b ? 0 : 1]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][prev_is_b ? 0 : 1] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\n\tif (prev_is_b) {\n\t\t//Bの終わった直後\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\tres += func(i + 1, a_end, true);//1を置く\n\t}\n\telse {\n\t\t//Aの中\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\tfor (int k = 1; k < B; k++) {//1をk個と0を一個置く\n\t\t\t//Bの途中で0を置く\n\t\t\tres += func(i + k + 1, i + k + A, false);\n\t\t\t//↑最後に0を置いたのでAの中にいる\n\t\t}\n\t\tres += func(i + B, a_end, true);//1をB個\n\t}\n\treturn memo = res;\n}\n\n//Aは[a_end-A, a_end), Bは[b_end-B, b_end)\nmint func_ON3(int i, int a_end, int b_end)\n{\n\tstatic mint dp[100][100][100];\n\tstatic bool used[100][100][100];\n\tif (N+1 <= a_end || N + 1 <= b_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i && b_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][b_end];\n\tif (used[i][a_end][b_end]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][b_end] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\tif (i < b_end) {//Bの中\n\t\tres += func_ON3(i + 1, i + A, 0);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end);//1を置く\n\t}\n\telse if (B <= b_end && i == b_end) {//Bの終わった直後\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end+1);//1を置く\n\t}\n\telse {//Aの中\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, i + B);//1を置く\n\t}\n\treturn memo = res;\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\tif (A == 1) {\n\t\tout << pow2[N] << endl;\n\t\treturn 0;\n\t}\n\tif (N < 90) {\n\t\tout << func(0, A, false) << endl;\n\t\treturn 0;\n\t}\n\n\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int MOD = 1000000007;\nvoid add(int &a, const int &b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, const int &b) {\n\ta -= b;\n\tif (a < 0) a += MOD;\n}\nint dp[5001][5001][2];\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif (A > B) swap(A, B);\n\t//vector<vector<vector<int> > > dp(N + 1, vector<vector<int> >(N + 1, vector<int>(2, 0)));\n\tdp[0][0][0] = 1;\n\tdp[0][0][1] = 1;\n\tint p2[100005];\n\tp2[0] = 1;\n\tfor (int i = 1; i < 100005; i++) {\n\t\tp2[i] = p2[i - 1] * 2 % MOD;\n\t}\n\tint res = 0;\n\tfor (int j = 0; j < N; j++) {\n\t\tfor (int i = j; i < N; i++) {\n\t\t\t// for (int x = i + 1; x <= min(N, j + B - 1); x++) {\n\t\t\t// \tadd(dp[x][j][1], dp[i][j][0]);\n\t\t\t// }\n\n\t\t\tif (i == j) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tadd(dp[j + 1][i + 1][0], dp[j][i][0]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tadd(dp[j][i + 1][0], dp[j][i][0]);\n\t\t\t\tadd(dp[j][i + 1][1], dp[j][i][1]);\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint mn = i + 1;\n\t\t\t\tint mx = min(N, j + B - 1) + 1;\n\t\t\t\tif (mn < mx) {\n\t\t\t\t\tadd(dp[j][mn][1], dp[j][i][0]);\n\t\t\t\t\tif (mx <= N) {\n\t\t\t\t\t\tsub(dp[j][mx][1], dp[j][i][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j + B <= N) {\n\t\t\t\tadd(res, dp[j][i][0] * p2[N - (j + B)] % MOD);\n\t\t\t}\n\t\t\t// for (int x = i + 1; x <= min(N, i + A - 1); x++) {\n\t\t\t// \t//cerr << i << \" \" << j << \" \" << x << endl;\n\t\t\t// \tadd(dp[x][x][0], dp[i][j][1]);\n\t\t\t// }\n\t\t\t{\n\t\t\t\tint mn = i + 1;\n\t\t\t\tint mx = min(N, i + A - 1) + 1;\n\t\t\t\tif (mn < mx) {\n\t\t\t\t\tadd(dp[mn][mn][0], dp[j][i][1]);\n\t\t\t\t\tif (mx <= N) {\n\t\t\t\t\t\tsub(dp[mx][mx][0], dp[j][i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for (int x = i + A; x <= min(N, j + B - 1); x++) {\n\t\t\t// \t//cerr << i << \" \" << j << \" \" << x << endl;\n\t\t\t// \tadd(dp[x][j][0], dp[i][j][1]);\n\t\t\t// }\n\n\t\t\t{\n\t\t\t\tint mn = i + A;\n\t\t\t\tint mx = min(N, j + B - 1) + 1;\n\t\t\t\tif (mn < mx) {\n\t\t\t\t\tadd(dp[j][mn][0], dp[j][i][1]);\n\t\t\t\t\tif (mx <= N) {\n\t\t\t\t\t\tsub(dp[j][mx][0], dp[j][i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tint x = max(i + A, j + B);\n\t\t\t\tif (x <= N) {\n\t\t\t\t\tadd(res, dp[j][i][1] * p2[N - x] % MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize (\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\") // codeforces\n//#pragma GCC target(\"avx,avx2,fma\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\") // yandex\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define rf(i, a, b) for(int i = a; i >= b; i--)\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)x.size()\n#define lb lower_bound\n#define ub upper_bound\n\ntypedef long long ll;\ntypedef long double f80;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint pct(int x) { return __builtin_popcount(x); }\nint pct(ll x) { return __builtin_popcountll(x); }\nint bt(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\nint bt(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x))\nint cdiv(int a, int b) { return a / b + !(a < 0 || a % b == 0); }\nll cdiv(ll a, ll b) { return a / b + !(a < 0 || a % b == 0); }\nint nxt_C(int x) { int c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\nll nxt_C(ll x) { ll c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\n\nvector<int> get_bits(int mask) {\n\tvector<int> bb;\n\twhile(mask) { int b = bt(mask); bb.pb(b); mask ^= (1 << b); }\n\treverse(all(bb));\n\treturn bb;\n}\n\nint get_mask(vector<int> v) {\n\tint mask = 0;\n\tfor(int x : v) { mask ^= (1 << x); }\n\treturn mask;\n}\n\ntemplate<typename T>\nvoid uniq(vector<T> &v) { sort(all(v)); v.resize(unique(all(v)) - v.begin()); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll rand(ll l, ll r){\n\tuniform_int_distribution<ll> uid(l, r);\n\treturn uid(rng);\n}\n\nvoid sc() {}\n\ntemplate <typename Head, typename... Tail>\nvoid sc(Head &H, Tail &... T) { cin >> H; sc(T...); }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[L:\" << __LINE__ << \"][\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// #ifndef LOCAL\n// string to_string(__int128 x) {\n// \tstring s = \"\";\n// \tbool neg = 0;\n// \tif(x < 0) { s += \"-\"; neg = 1; x = -x; }\n// \tif(!x) s += '0';\n// \twhile(x) {\n// \t\tint rem = x % 10;\n// \t\ts += to_string(rem);\n// \t\tx /= 10;\n// \t}\n// \treverse(s.begin() + neg, s.end());\n// \treturn s;\n// }\n// #endif\n\nconst int mod = 1e9 + 7; // 998244353;\n\nint pwr(int a,ll b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans * 1LL * a) % mod;\n\t\ta = (a * 1LL * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\n/*\n\tLookout for overflows!!\n\tCheck array sizes!!\n\tClear before test cases!!\n\tUse the correct modulo!!\n\tCheck for corner cases!!\n\tAre you forgetting something?!\n\tRead problem statement carefully!!!\n*/\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n*/\n\nconstexpr int md = 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint pwr(Mint a, ll k) {\n\tMint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = ans * a;\n\t\ta = a * a;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 5005;\nMint dp[N][N][2][2];\nMint diag_dp[N][2];\n\nvoid solve() {\n\tint n, A, B;\n    sc(n, A, B);\n    if(A < B) swap(A, B);\n    dp[0][0][0][0] = 1;\n    dp[0][0][1][0] = 1;\n    dp[1][0][0][0] = -1;\n    dp[1][0][1][0] = -1;\n    fr(i, 0, n) {\n        if(i) {\n            diag_dp[i][0] += diag_dp[i - 1][0];\n            diag_dp[i][1] += diag_dp[i - 1][1];\n        }\n        fr(j, 0, i) {\n            fr(k, 0, 1) {\n                fr(l, 0, 1) {\n                    Mint &val = dp[i][j][k][l];\n                    if(i)\n                        val += dp[i - 1][j][k][l];\n                    if(i == j && k) {\n                        val += diag_dp[i][l];\n                        dp[i + 1][j][k][l] -= diag_dp[i][l];\n                    }\n                    if(!val) continue; // speed up\n                    if(k) {\n                        dp[i + 1][j][0][l] += val; // good\n                    }\n                    else {\n                        diag_dp[i + 1][(l | (i - j) >= A)] += val;\n                        if(i + B <= n) {\n                            diag_dp[i + B][(l | (i - j) >= A)] -= val;\n                            dp[i + B][j][1][l] += val;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    Mint ans = 0;\n    fr(j, 0, n) {\n        ans += dp[n][j][0][1] + dp[n][j][1][1];\n        if(n - j >= A) ans += dp[n][j][0][0] + dp[n][j][1][0];\n    }\n    cout << ans;\n}\n\nint main() {\n\tios :: sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t = 1;\n\t// cin >> t;\n\tfor(int tt = 1; tt <= t; tt++) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep_range(i, s, e) for (int i = (s); i < (int)(e); i++)\n#define rep_rev(i, s, e) for (int i = (s)-1; i >= (int)(e); i--)\n#define sort_vec(v) sort((v).begin(),(v).end())\ntypedef int64_t lint;\n// lint mod = 998244353;\nlint mod = 1000000007;\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint app() {\n  int n,a,b;\n  cin>>n>>a>>b;\n\n  if(a<b) swap(a,b);\n\n  vector<vector<lint>>\n  dp(n+1,vector<lint>(n+1,0)),\n  // dp[la][lb]: 1がlbからkまで続き、長さb以上の1の連続を0にすると0がlaからkまで続く場合の数\n  sumdpb(n+1,vector<lint>(n+1,0));  // sum(dp[la][0...lb])\n  dp[0][0]=1;\n  sumdpb[0][0]=1;\n  rep_range(k,1,n+1){\n    rep_range(la,max(0,k-a-b),k){\n      dp[la][k]+=dp[la][k-1];  // ***0.0\n      // ****.1 は変わらない\n      dp[k-1][k]+=(k>=2?sumdpb[la][k-2]:0)-(k>=b+1?sumdpb[la][k-b-1]:0);  // ***1.0\n      dp[la][k]+=(k>=b+1?sumdpb[la][k-b-1]:0);  // **11.0\n      if(la<=k-a) dp[la][k]=0;\n      else dp[la][k]%=mod;\n      dp[k-1][k]%=mod;\n      sumdpb[la][k]=(sumdpb[la][k-1]+dp[la][k])%mod;\n    }\n  }\n\n  lint ans=0;\n  rep(k,n+1){\n    rep(la,n+1){\n      if(k==n||n-k>=b){\n        if(n-la<a) ans+=dp[la][k];\n      }else{\n        if(k-la<a) ans+=dp[la][k];\n      }\n      ans%=mod;\n    }\n  }\n\n  lint all=1;\n  rep(_,n) all=all*2%mod;\n  return (all-ans+mod)%mod;\n}\n\nint main(){cout<<app()<<endl;return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\n\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n\nconst int N = 5100;\n\nint n, a, b;\n\nll dp[N][2];\nll dp2[N][2];\n\nvoid add(ll& a, ll b) {\n\ta = (a + b) % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tcin >> n >> a >> b;\n\tif (a < b) {\n\t\tswap(a, b);\n\t}\n\n\tdp2[0][0] = 1;\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tadd(dp2[i + 1][0], dp2[i][0]);\n\t\tadd(dp2[i + 1][0], dp2[i][1]);\n\t\tadd(dp2[i + 1][1], dp2[i][1]);\n\t\tif (i + b <= n) {\n\t\t\tadd(dp2[i + b][1], dp2[i][0]);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tdp[0][1] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 1; j <= b - 1 && i + j <= n; ++j) {\n\t\t\tadd(dp[i + j][1], dp[i][0]);\n\t\t}\n\n\t\tfor (int j = 1; j < a && i + j <= n; ++j) {\n\t\t\tint len = j;\n\t\t\tif (i != 0) {\n\t\t\t\tlen -= 1;\n\t\t\t}\n\t\t\tif (i + j != n) {\n\t\t\t\tlen -= 1;\n\t\t\t}\n\t\t\tlen = max(len, 0);\n\n\t\t\tadd(dp[i + j][0], dp[i][1] * (dp2[len][0] + dp2[len][1]));\n\t\t}\n\t}\n\n\tll sm = (dp[n][0] + dp[n][1]) % MOD;\n\tll ans = pw(2, n) - sm;\n\tans %= MOD;\n\tif (ans < 0) {\n\t\tans += MOD;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = (int) 1e9 + 7;\n\nint dp[5005][5005][5], dps[5005][5];\nint answer[5005][5], step[5005];\n\nint main()\n{\n \t//freopen(\"input.txt\", \"r\", stdin);\n \t//freopen(\"output.txt\", \"w\", stdout);\n \tios_base::sync_with_stdio(0); cin.tie(0);\n \tint n, A, B;\n \tcin >> n >> A >> B;\n \tif (A > B) swap(A, B);\n\n \tstep[0] = 1;\n \tfor (int i = 1; i <= n; i++) step[i] = 2 * step[i - 1] % MOD;\n \tif (A == 1) cout << step[n] << '\\n', exit(0);\n\n \tdp[1][1][0] = 1, dp[1][1][3] = 1;\n \tfor (int i = 1; i < B; i++)\n \t\tfor (int j = 1; j <= i; j++)\n \t\t{\n \t\t \tdp[i + 1][j + 1][0] = (dp[i + 1][j + 1][0] + dp[i][j][0]) % MOD;\n \t\t \tif (j >= A) dp[i + 1][1][1] = (dp[i + 1][1][1] + dp[i][j][0]) % MOD;\n \t\t \tdp[i + 1][1][0] = (dp[i + 1][1][0] + dp[i][j][1]) % MOD;\n \t\t \tdp[i + 1][j + 1][1] = (dp[i + 1][j + 1][1] + dp[i][j][1]) % MOD;\n \t\t \tdp[i + 1][j + 1][2] = (dp[i + 1][j + 1][2] + dp[i][j][2]) % MOD;\n \t\t \tif (j >= A) dp[i + 1][1][3] = (dp[i + 1][1][3] + dp[i][j][2]) % MOD;\n \t\t \tdp[i + 1][1][2] = (dp[i + 1][1][2] + dp[i][j][3]) % MOD;\n \t\t \tdp[i + 1][j + 1][3] = (dp[i + 1][j + 1][3] + dp[i][j][3]) % MOD;\n \t\t}\n \tfor (int i = 1; i < B; i++)\n \t\tfor (int j = 1; j <= i; j++)\n \t\t{\n \t\t \tif (j >= A) answer[i][0] = (answer[i][0] + dp[i][j][0]) % MOD;\n \t\t \tanswer[i][1] = (answer[i][1] + dp[i][j][1]) % MOD;\n \t\t \tif (j >= A) answer[i][2] = (answer[i][2] + dp[i][j][2]) % MOD;\n \t\t \tanswer[i][3] = (answer[i][3] + dp[i][j][3]) % MOD;\n \t\t}\n\n \tfor (int i = 1; i < A; i++) dps[i][0] = 1;\n \tfor (int i = 1; i < B; i++) dps[i][1] = (answer[i][1] + answer[i][3]) % MOD;\n\n \tfor (int i = 1; i <= n; i++)\n \t{\n \t \tfor (int j = 1; j < min(B, n - i + 1); j++)\n \t \t{\n \t \t \tint c = answer[j][3];\n \t \t \tif (j == n - i) c = (c + answer[j][2]) % MOD;\n \t \t \tdps[i + j][1] = ((ll) dps[i + j][1] + (ll) dps[i][0] * (ll) c) % (ll) MOD;\n \t \t}\n \t \tfor (int j = 1; j < min(A, n - i + 1); j++)\n \t \t\tdps[i + j][0] = (dps[i + j][0] + dps[i][1]) % MOD;\n \t}\n \tint ans = ((ll) step[n] - (ll) dps[n][0] - (ll) dps[n][1] + (ll) 2 * MOD) % (ll) MOD;\n \tcout << ans << '\\n';\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint n,A,B;\nLL f[5555][2][2],g[5555][2],ANS,ans;\nint main(){\n\tcin>>n>>A>>B;\n\tif (A>B) swap(A,B);\n\tFOR(i,1,B-1){\n\t\tf[i][0][0]=(i>=A);\n\t\tFOR(j,A,i-1) (f[i][0][0]+=f[i-j][0][1])%=MO;\n\t\tf[i][0][1]=0;\n\t\tFOR(j,1,i-1) (f[i][0][1]+=f[i-j][0][0])%=MO;\n\t\tf[i][1][0]=0;\n\t\tFOR(j,A,i-1) (f[i][1][0]+=f[i-j][1][1])%=MO;\n\t\tf[i][1][1]=1;\n\t\tFOR(j,1,i-1) (f[i][1][1]+=f[i-j][1][0])%=MO;\n\t}\n\tFOR(i,1,n){\n\t\tg[i][0]=(f[i][0][1]+f[i][1][1])%MO;\n\t\tFOR(j,1,min(B-1,i-1)) (g[i][0]+=g[i-j][1]*f[j][1][1])%=MO;\n\t\tg[i][1]=(i<A);\n\t\tFOR(j,1,min(A-1,i-1)) (g[i][1]+=g[i-j][0])%=MO;\n\t}\n\tans=(f[n][0][0]+f[n][0][1]+f[n][1][0]+f[n][1][1])%MO;\n\tFOR(i,1,n-1) (ans+=g[i][1]*(f[n-i][1][0]+f[n-i][1][1]))%=MO;\n\t(ans+=g[n][1])%=MO;\n\tANS=1;\n\tFOR(i,1,n) ANS=ANS*2%MO;\n\t(ANS-=ans)%=MO;\n\tANS=(ANS%MO+MO)%MO;\n\tcout<<ANS<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define upd(a,b) a=add(a+b)\nusing namespace std;\ninline char nc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=5000+5;\nint n,A,B;\nint f[maxn][2],g[maxn][2];\nint dp[maxn][2][2];\ninline int add(int x) {return x>=mod?x-mod:x;}\nvoid DP(int dp[maxn][2]) {\n\tfor(int i=0;i<n;++i) {\n\t\tupd(dp[i+1][1],dp[i][0]);\n\t\tupd(dp[i+1][1],dp[i][1]);\n\t\tfor(int k=A;i+k<=n;++k) upd(dp[i+k][0],dp[i][1]);\n\t}\n}\nint main() {\n\tread(n),read(A),read(B);\n\tif(A>B) swap(A,B);\n\tf[0][0]=1,DP(f);\n\tg[0][0]=1;\n\tfor(int i=A;i<=n;++i) g[i][0]=1;\n\tDP(g);\n\tdp[n][1][0]=g[n][0];\n\tfor(int i=1;i<=n;++i) dp[i][i>=B][1]=g[i][1];\n\tfor(int i=1;i<A;++i) dp[i][0][0]=1;\n\tfor(int i=1;i<=n;++i) for(int k=0;k<2;++k) {\n\t\tfor(int j=1;j<A&&i+j<=n;++j) upd(dp[i+j][k][0],dp[i][k][1]);\n\t\tfor(int j=1;i+j<=n;++j) {\n\t\t\tint r=f[j][1]; if(i+j==n) upd(r,f[j][0]);\n\t\t\tupd(dp[i+j][k||j>=B][1],(ll)dp[i][k][0]*r%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",add(dp[n][1][0]+dp[n][1][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const nax = 3e5 + 10;\nconstexpr int mod = 1e9 + 7;//\nvoid plusle (int &a, int b) {\n    if (( a += b) >= mod ) a -= mod ;\n}\nvoid minun (int &a, int b) {\n    if ((a -= b) < 0) a += mod ;\n}\nint add (int a, int b) {\n    return (( a += b ) >= mod ) ? a - mod  : a;\n}\nint sub (int a, int b) {\n    return (( a -= b) < 0) ? a + mod : a;\n}\nint mul (int a, int b) {\n    return 1LL * a * b % mod;\n}\nint power (int a, int b) {\n    int res = 1;\n    for (; b > 0 ; b >>= 1 , a = mul(a, a))\n        if (b & 1) res = mul(res, a);\n    return res ;\n}\n#define fprintf(...) 42\n\nint dp[nax];\nint a, b;\nint n;\nint f[nax];\nint pref[nax];\n\nint rec (int sz) {\n\n    if (sz == 0) return 1;\n    if (dp[sz] != -1) return dp[sz];\n    /// the number of different substring of this size\n\n    for (int i = 1 ; i < sz ; ++ i) f[i] = rec(i);\n    pref[0] = 1;\n\n    for (int i = 1 ; i < sz ; ++ i) {\n        pref[i] = add(pref[i - 1], f[i]);\n    }\n\n    dp[sz] = 1; /// all 0\n\n    for (int i = a ; i <= sz ; ++ i) {\n        int res = sz - i;\n        plusle(dp[sz], pref[res]);\n        if (sz == 4) {\n            fprintf(stderr, \"add %d\\n\", pref[res]);\n        }\n    }\n\n    for (int st = 2 ; st <= sz ; ++ st) {\n     //   if (st + a - 1 > sz) break; /// necessary\n        if (st - 1 < b) {\n            /// we cannot use 0 move on left\n            int to = st + a - 1;\n            if (to > sz) continue;\n            int first_one = min(to - 1, sz - b);\n            if (first_one < st) continue;\n            int l = sz - first_one;\n            int r = sz - st;\n            plusle(dp[sz], sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            if (sz == 4) {\n                fprintf(stderr, \"%d\\n\", st);\n                fprintf(stderr, \"%d %d\\n\", l, r);\n                fprintf(stderr, \"st - 1 < b add %d\\n\", sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            }\n        } else if (st - 1 >= b) {\n            /// if we apply b from both side\n            int last_one = sz - b;\n            int first_one = st;\n            int l = sz - last_one;\n            int r = sz - first_one;\n            if (first_one <= last_one ) {\n                plusle(dp[sz], sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            }\n\n            /// if we apply from left only\n            int to = min(sz, st + a - 1);\n            int from = max(st, a);\n            l = sz - to;\n            r = sz - from;\n            if (l <= r) {\n                fprintf(stderr, \"Add %d\\n\", sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n\n                plusle(dp[sz], sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            }\n        }\n    }\n\n    return dp[sz];\n}\n\n\n\n\nint main () {\n    scanf(\"%d %d %d\", &n, &a, &b);\n    swap(a, b);\n    memset(dp, -1, sizeof(dp));\n    rec(n);\n    for (int i = 1; i <= n ; ++ i) {\n        fprintf(stderr, \"i %d dp[i] %d\\n\", i, dp[i]);\n    }\n    printf(\"%d\\n\", rec(n));\n}\n/*\n    Good Luck\n        -Lucina\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define ll long long\n//#define cccgift\n#define lowbit(x) ((x)&-(x))\n#define rep(i,l,r) for(res i=l,_r=r;i<=_r;++i)\n#define per(i,r,l) for(res i=r,_l=l;i>=_l;--i)\n#define mkp make_pair\n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem0n(a,n) memset(a,0,n*sizeof(a[0]))\n#define iter(x,v) for(res v,_p=head[x];v=ver[_p],_p;_p=nxt[_p])\n#ifdef cccgift //by lqh\n#define SHOW(x) cerr<<#x\"=\"<<(x)<<endl\n#else\n#define SHOW(x) 0\n#endif\n//#define getchar()(ip1==ip2&&(ip2=(ip1=ibuf)+fread(ibuf,1,1<<21,stdin),ip1==ip2)?EOF:*ip1++)\n//char ibuf[1<<21],*ip1=ibuf,*ip2=ibuf;\ntemplate<typename T>\ninline void read(T &x)\n{\n    static char ch;bool f=1;\n    for(x=0,ch=getchar();!isdigit(ch);ch=getchar()) if(ch=='-') f=0;\n    for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());x=f?x:-x;\n}\ntemplate<typename T>\nvoid print(T x)\n{\n    if (x<0) x=-x,putchar('-');\n    if (x>9) print(x/10);\n    putchar(x%10+48);\n}\ntemplate<typename T>\ninline void print(T x,char ap) {print(x);if (ap) putchar(ap);}\ntemplate<typename T>\ninline void chkmax(T &x,const T &y) {x=x<y?y:x;}\ntemplate<typename T>\ninline void chkmin(T &x,const T &y) {x=x<y?x:y;}\nconst int mod=1e9+7;\nint n,a,b,f[5010][2],g[5001][2],h[5001];\n#define inc(x,y) x+=y,x>=mod?x-=mod:0\ninline int kuai(int p,int q,int mod) {int tot=1;for(;q;p=(ll)p*p%mod,q>>=1) if(q&1) tot=(ll)tot*p%mod;return tot;}\nint main()\n{\n\tread(n),read(a),read(b);if(a>b) swap(a,b);\n\tg[0][0]=g[0][1]=h[0]=1;\n\trep(i,1,b) {\n\t\trep(j,0,i-1) {\n\t\t\tif(i-j>=a) inc(g[i][0],g[j][1]);\n\t\t\tinc(g[i][1],g[j][0]);\n\t\t}\n\t\th[i]=(g[i][0]+g[i][1])%mod;\n\t}\n\tf[0][0]=f[0][1]=1;\n\trep(i,1,n) {\n\t\trep(j,max(i-a+1,0),i-1) inc(f[i][0],f[j][1]);\n\t\tif(i<n) {\n\t\t\trep(j,max(i-b+1,0),i-1) {\n\t\t\t\tint now=(j==i-1)?1:h[j?(i-j-2):(i-1)];\n\t\t\t\tinc(f[i][1],(ll)f[j][0]*now%mod);\n\t\t\t}\t\n\t\t}\n\t\telse {\n\t\t\trep(j,max(i-b+1,0),i-1) inc(f[i][1],(ll)f[j][0]*h[i-j-1]%mod);\n\t\t}\n\t}\n\tint now=(f[n][0]+f[n][1])%mod;\n\tprint((kuai(2,n,mod)-now+mod)%mod,'\\n');\n\treturn 0;\n}\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do something instead of nothing and stay organized\n*/ "
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint dp[5001][2][5001][2];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tif (L > R)swap(L, R);\n\tdp[0][1][0][0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\tif (k + 1 < L) {\n\t\t\t\t\t\t\tdp[i + 1][j][k + 1][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\tdp[i + 1][j][k + 1][l] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k < L) {\n\t\t\t\t\t\t\tdp[i + 1][j ^ 1][1][l] += dp[i][j][k][l];\n\t\t\t\t\t\t\tdp[i + 1][j ^ 1][1][l] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k >= L) {\n\t\t\t\t\t\t\tint nx = l;\n\t\t\t\t\t\t\tif (k + 1 >= R)nx = 1;\n\t\t\t\t\t\t\tdp[i + 1][j][k + 1][nx] += dp[i][j][k][l];\n\t\t\t\t\t\t\tdp[i + 1][j][k + 1][nx] %= MOD;\n\t\t\t\t\t\t\tdp[i + 1][j ^ 1][k + 1][nx] += dp[i][j][k][l];\n\t\t\t\t\t\t\tdp[i + 1][j ^ 1][k + 1][nx] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\tint nx = l;\n\t\t\t\t\t\tif (k + 1 == R)nx = 1;\n\t\t\t\t\t\tdp[i + 1][j][k + 1][nx] += dp[i][j][k][l];\n\t\t\t\t\t\tdp[i + 1][j][k + 1][nx] %= MOD;\n\t\t\t\t\t\tnx = l;\n\t\t\t\t\t\tif (L > 1) {\n\t\t\t\t\t\t\tdp[i + 1][j ^ 1][1][nx] += dp[i][j][k][l];\n\t\t\t\t\t\t\tdp[i + 1][j ^ 1][1][nx] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k + L >= R)nx = 1;\n\t\t\t\t\t\tif (i + L <= N) {\n\t\t\t\t\t\t\tdp[i + L][j ^ 1][k + L][nx] += dp[i][j][k][l];\n\t\t\t\t\t\t\tdp[i + L][j ^ 1][k + L][nx] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\tcout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << dp[i][j][k][l] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint ans = 0;\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tans += dp[N][i][j][1];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 07.06.2020 16:29:53       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, a, b;\n  cin >> n >> a >> b;\n  if (a > b) {\n    swap(a, b);\n  }\n  vector<vector<Mint>> aux(n + 1, vector<Mint>(n + 1, 0));\n  aux[0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= i; j++) {\n      aux[i + 1][j + 1] += aux[i][j];\n      if (j == 0 || j >= a) {\n        aux[i + 1][0] += aux[i][j];\n      }\n    }\n  }\n  vector<Mint> help(n + 1);\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0 || j >= a) {\n        help[i] += aux[i][j];\n      }\n    }\n  }\n  vector<Mint> dp(n);\n  Mint ans = 0;\n  for (int L = 0; L < n; L++) {\n    for (int R = L; R < n && R - L + 1 < a; R++) {\n      if (L < b) {\n        dp[R] += help[max(L - 1, 0)];\n      }\n    }\n  }\n  vector<Mint> add(n + 1, 0);\n  Mint delta = 0;\n  for (int i = 0; i < n; i++) {\n    delta += add[i];\n    dp[i] += delta;\n    for (int L = i + 2; L < n; L++) {\n      if (L - i - 1 < b) {\n        int from = L;\n        int to = min(n - 1, a - 2 + L);\n        Mint val = dp[i] * help[max(L - i - 3, 0)];\n        add[from] += val;\n        add[to + 1] -= val;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (n - 1 - i < b) {\n      ans += dp[i] * help[max(n - 2 - i, 0)];\n    }\n  }\n  ans = power(Mint(2), n) - ans;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(int i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 5e3 + 1;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI LL read() {\n\tLL x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nint f[N][2], bin[N], T[N], g[N], q[N][2], z[N];\n\nint main() {\n\treg n = read(), A = read(), B = read();\n\tif(A < B) swap(A, B);\n\tq[0][1] = 1;\n\tfo(i, 0, A - 1) {\n\t\tfo(k, 0, 1) if(q[i][k]) {\n\t\t\tfo(h, 1, A - 1 - i) {\n\t\t\t\tif(k == 1) {\n\t\t\t\t\tq[i + h][k ^ 1] = (q[i + h][k ^ 1] + q[i][k]) % mod;\n\t\t\t\t} else {\n\t\t\t\t\tif(h < B) continue;\n\t\t\t\t\tq[i + h][k ^ 1] = (q[i + h][k ^ 1] + q[i][k]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} fo(i, 1, A - 1) T[i] = q[i][0];\n\tfo(i, 1, A - 1) {\n\t\tfo(j, 1, i - B) g[i] = (g[i] + T[j]) % mod;\n\t\tg[i] = (g[i] + T[i]) % mod;\n\t} fo(i, 1, A - 1) {\n\t\tfo(j, 1, i - B) z[i] = (z[i] + g[j]) % mod;\n\t\tz[i] = (z[i] + g[i]) % mod;\n\t}\n\tf[0][0] = f[0][1] = 1;\n\tfo(i, 0, n) {\n\t\tfo(k, 0, 1) if(f[i][k]){\n\t\t\tfo(h, 1, n - i) {\n\t\t\t\treg lim = k == 0 ? B : A;\n\t\t\t\treg p = h >= lim;\n\t\t\t\tif(p) continue;\n\t\t\t\tif(k == 0) f[i + h][k ^ 1] = (f[i + h][k ^ 1] + f[i][k]) % mod;\n\t\t\t\telse {\n\t\t\t\t\tif(i == 0 && i + h == n) f[i + h][k ^ 1] = (f[i + h][k ^ 1] + (LL)f[i][k] * z[h]) % mod;\n\t\t\t\t\telse if(i == 0 || i + h == n) f[i + h][k ^ 1] = (f[i + h][k ^ 1] + (LL)f[i][k] * g[h]) % mod;\n\t\t\t\t\telse f[i + h][k ^ 1] = (f[i + h][k ^ 1] + (LL)f[i][k] * T[h]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} bin[0] = 1; fo(i, 1, n) bin[i] = bin[i - 1] << 1, bin[i] = bin[i] >= mod ? bin[i] - mod : bin[i];\n\treg ans = bin[n];\n\tans = ((LL)ans - f[n][0] - f[n][1]) % mod;\n\tpr2(ans < 0 ? ans + mod : ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream> \n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=5005,mod=1e9+7;\nint n,a,b,f[N][2],g[N],dp[N][2],ans;\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\ninline int sub(CI x,CI y)\n{\n\tint t=x-y; return t<0?t+mod:t;\n}\ninline int quick_pow(int x,int p,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\nint main()\n{\n\tRI i,j; scanf(\"%d%d%d\",&n,&a,&b); if (a>b) swap(a,b);\n\tif (b==1) return printf(\"%d\",quick_pow(2,n)),0;\n\tfor (f[0][0]=f[0][1]=i=1;i<=n;++i) for (j=1;j<=i;++j)\n\t{\n\t\tif (j>=a) inc(f[i][0],f[i-j][1]); inc(f[i][1],f[i-j][0]);\n\t}\n\tfor (g[0]=i=1;i<=n;++i) g[i]=sum(f[i][0],f[i][1]);\n\tfor (i=1;i<n;++i) \n\t{\n\t\tif (i<a) dp[i][0]=1; for (j=1;j<min(i,a);++j) inc(dp[i][0],dp[i-j][1]);\n\t\tif (i<b) dp[i][1]=g[i-1]; for (j=1;j<min(i,b);++j)\n\t\tinc(dp[i][1],1LL*dp[i-j][0]*(j<=2?1:g[j-2])%mod);\n\t\tif (n-i<a) inc(ans,dp[i][1]); if (n-i<b) inc(ans,1LL*dp[i][0]*g[n-i-1]%mod);\n\t}\n\treturn printf(\"%d\",sub(quick_pow(2,n),ans)),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define mt make_tuple\n#define ldb double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\ntemplate<typename T>void ckmn(T &a,T b){a=min(a,b);}\ntemplate<typename T>void ckmx(T &a,T b){a=max(a,b);}\nint ri(){int x;scanf(\"%i\",&x);return x;}\nvoid rd(){}\ntemplate<typename...T>void rd(int &x,T&...args){scanf(\"%i\",&x);rd(args...);}\ntemplate<typename...T>void rd(ll &x,T&...args){scanf(\"%lld\",&x);rd(args...);}\ntemplate<typename...T>void rd(ldb &x,T&...args){scanf(\"%lf\",&x);rd(args...);}\ntemplate<typename...T>void rd(pii &x,T&...args){scanf(\"%i %i\",&x.first,&x.second);rd(args...);}\nconst int mod=1e9+7;//998244353\nint add(int a,int b){a+=b;return a>=mod?a-mod:a;}\nvoid ckadd(int&a,int b){a=add(a,b);}\nint sub(int a,int b){a-=b;return a<0?a+mod:a;}\nvoid cksub(int&a,int b){a=sub(a,b);}\nint mul(int a,int b){return (ll)a*b%mod;}\nvoid ckmul(int&a,int b){a=mul(a,b);}\nint powmod(int x,int k){int ans=1;for(;k;k>>=1,ckmul(x,x))if(k&1)ckmul(ans,x);return ans;}\nint inv(int x){return powmod(x,mod-2);}\nconst int N=5005;\nstruct SUM{\n\tint sum[N*2];\n\tvoid Add(int i,int x){ckadd(sum[i+N],x);}\n\tint Get(int i){return sum[i+N];}\n}SM;\nint dp[N][N],res[N],sum_dp[N];\nint main(){\n\tint n,A,B;\n\trd(n,A,B);\n\tif(A>B)swap(A,B);\n\tdp[0][0]=1;\n\tsum_dp[0]=1;\n\tfor(int i=1;i<=n+1;i++){\n\t\tres[i]=mul(2,res[i-1]);\n\t\tfor(int suf=0;suf<=i;++suf){\n\t\t\tif(suf>0)dp[i][suf]=dp[i-1][suf-1];\n\t\t\tckadd(dp[i][suf],SM.Get(i-suf));\n\t\t\t//printf(\"%i \",dp[i][suf]);\n\t\t}\n\t\tfor(int j=2;j<=A;j++){\n\t\t\tif(i-j>=0)ckadd(dp[i][1],sum_dp[i-j]);\n\t\t}\n\t\tfor(int suf=0;suf<=i;suf++){\n\t\t\tif(i<=n&&suf>=B){\n\t\t\t\tckadd(res[i],dp[i][suf]);\n\t\t\t\tdp[i][suf]=0;\n\t\t\t}else ckadd(sum_dp[i],dp[i][suf]);\n\t\t}\n\t\t//printf(\"%i\\n\",res[i]);\n\t\tif(i>=A){\n\t\t\tfor(int suf=0;suf<=i-A;++suf){\n\t\t\t\t//if(dp[i-A][suf])printf(\"%i %i\\n\",i-A-suf,dp[i-A][suf]);\n\t\t\t\tSM.Add(i-A-suf,dp[i-A][suf]);\n\t\t\t}\n\t\t}\n\n\t\t//for(int suf=0;suf<=i;suf++)printf(\"%i \",dp[i][suf]);\n\t\t//printf(\"%i\\n\",res[i]);\n\t}\n\tint ans=res[n];\n\tfor(int i=B+1;i<=n+1;i++)ckadd(ans,dp[n+1][i]);\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    ll dp[n+1][n+1];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    ll sum1[n+1];\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    ll sum2[n+1][n+1];\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 0\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T, class U> using pair = std::pair<U, T>;\ntemplate <class T> using diag_pair = std::pair<T, T>;\ntemplate <class... Args> using tuple = std::tuple<Args...>;\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint operator--(int) { mint this_=*this; --*this; return this_; }\n    mint operator-() const { return 0 - *this; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) const { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) const { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) const { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) const { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       const { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) const { return pow(*this, y); }\n    mint square(mint x) const { return *this * *this; }\n    mint cube(mint x) const { return *this * *this * *this; }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\ntemplate <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x) {\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\ntemplate <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x) {\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i64, 1'000'000'007>>;\ntemplate <usize N, class T, class... Args, std::enable_if_t<N==0, int> = 0>\nauto mkvec(Args... args) {\n    return T(args...);\n}\ntemplate <usize N, class T, class... Args, std::enable_if_t<N!=0, int> = 0>\nauto mkvec(usize sz, Args... args) {\n    using value_type = std::decay_t<decltype(mkvec<N-1, T>(args...))>;\n    return vec<value_type>(sz, mkvec<N-1, T>(args...));\n}\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n, a, b;\n    std::cin >> n >> a >> b;\n    if (a>b) std::swap(a, b);\n\n    auto fp = mkvec<2, mint>(2, b);\n    fp.at(0).at(0) = 1;\n    fp.at(1).at(0) = 1;\n    for (usize i=0; i<b; i++) {\n        for (usize j=a; i+j<b; j++) fp.at(0).at(i+j) += fp.at(1).at(i);\n        for (usize j=1; i+j<b; j++) fp.at(1).at(i+j) += fp.at(0).at(i);\n    }\n\n    vec<mint> ep(b);\n    ep.at(0) = 1;\n    for (usize i=1; i<b; i++) {\n        ep.at(i) = fp.at(0).at(i) + fp.at(1).at(i);\n    }\n\n    auto dp = mkvec<2, mint>(2, n);\n    for (usize j=1; j<a; j++) dp.at(0).at(j) += 1;\n    for (usize j=1; j<b; j++) dp.at(1).at(j) += ep.at(j-1);\n\n    for (usize i=1; i<n; i++) {\n        for (usize j=1; j<a && i+j<n; j++) dp.at(0).at(i+j) += dp.at(1).at(i);\n        for (usize j=1; j<b && i+j<n; j++) dp.at(1).at(i+j) += dp.at(0).at(i) * ep.at(j==1?1:j-2);\n    }\n\n    mint ans = 0;\n    for (usize j=1; j<b; j++) ans += dp.at(0).at(n-j) * ep.at(j-1);\n    for (usize j=1; j<a; j++) ans += dp.at(1).at(n-j);\n    ans = mint::pow(2, n) - ans;\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=5007;\nconst ll mod=1000*1000*1000+7;\n\nint n, a, b;\n\nvoid dod(ll &a, ll b)\n{\n\tif ((a+=b)>=mod)\n\t\ta-=mod;\n}\n\nvoid sdod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nll dpjuz[nax];\nll dpzer[nax][nax];\nll dpjed[nax][nax];\n\nll pch[nax];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tif (a>b)\n\t\tswap(a, b);\n\tif (b==1)\n\t{\n\t\tll ret=1;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tret=(ret*2)%mod;\n\t\tprintf(\"%lld\\n\", ret);\n\t\treturn 0;\n\t}\n\tdpjed[0][0]=1;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tdod(pch[i+1], pch[i]);\n\t\tdod(dpjed[i+1][1], pch[i]);\n\t\tfor (int j=0; j<b; j++)\n\t\t{\n\t\t\t//~ debug() << \"robie \" << i << \" \" << j;\n\t\t\t{//dok 1\n\t\t\t\tif (j+1==b)\n\t\t\t\t\tdod(dpjuz[i+1], dpjed[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdod(dpjed[i+1][j+1], dpjed[i][j]);\n\t\t\t}\n\t\t\t\n\t\t\t{//dok 0\n\t\t\t\t//~ dod(dpjed[i+1][0], dpjed[i][j]);\n\t\t\t\t//~ if (i+a<=n)\n\t\t\t\t\t//~ dod(dpjed[i+a][0], mod-dpjed[i][j]);\n\t\t\t\t\t\n\t\t\t\tdod(pch[i+1], dpjed[i][j]);\n\t\t\t\tif (i+a<=n)\n\t\t\t\t\tdod(pch[i+a], mod-dpjed[i][j]);\n\t\t\t}\n\t\t\t\n\t\t\t{//dok a 0\n\t\t\t\tif (i+a<=n)\n\t\t\t\t{\n\t\t\t\t\tif (j+a>=b)\n\t\t\t\t\t\tdod(dpjuz[i+a], dpjed[i][j]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdod(dpzer[i+a][j+a], dpjed[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (j+1==b)\n\t\t\t{\n\t\t\t\tdod(dpjuz[i+1], dpzer[i][j]);\n\t\t\t\tdod(dpjuz[i+1], dpzer[i][j]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdod(dpzer[i+1][j+1], dpzer[i][j]);\n\t\t\t\tdod(dpjed[i+1][j+1], dpzer[i][j]);\n\t\t\t}\n\t\t\t//~ debug() << i << \" \" << j << \" \" << imie(dpjed[i][j]) << imie(dpzer[i][j]);\n\t\t\t//~ debug();\n\t\t}\n\t}\n\t//~ debug() << range(dpjuz+1, dpjuz+1+n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tdod(dpjuz[i], dpjuz[i-1]);\n\t\tdod(dpjuz[i], dpjuz[i-1]);\n\t}\n\tprintf(\"%lld\\n\", dpjuz[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iterator>\n#include <cassert>\n#include <numeric>\n#include <functional>\n//#include <numeric>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF  9223300000000000000\n#define LINF2 1223300000000000000\n#define LINF3 1000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\n//const long long MOD = 998244353;\n\nusing namespace std;\n\n\nll mpow(ll x, ll n){ //x^n(mod M)\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % MOD;\n        x = x*x % MOD;\n        n = n >> 1;\n    }\n    return ans;\n}\n\nll minv(ll x){\n    return mpow( x, MOD-2 );\n}\n\n\nll dp[5005][5005][2];\n\nvoid solve()\n{\n    int n, a, b;\n    scanf(\"%d%d%d\", &n, &a, &b);\n\n    if (a < b) swap(a, b);\n\n    if (a >= b) {\n        dp[0][0][0] = dp[0][0][1] = 1;\n        int i, j, k;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < a; j++) {\n                for (k = 0; k < 2; k++) {\n                    if(dp[i][j][k]) {\n                        int m;\n                        for (m = 1; m < MIN(a,n-i+1); m++) {\n                            int i2 = i + m;\n                            assert(i2 <= n);\n                            int j2 = m + j;\n                            if (k == 0) {\n                                ;\n                            }\n                            else {\n                                if (m < b) j2 = 0;\n                                else       j2 = j + m;\n                            }\n                            if (j2 >= a) continue;\n\n                            dp[i2][j2][1 - k] = (dp[i2][j2][1 - k] + dp[i][j][k]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        ll ans = 0;\n        for (j = 0; j < a; j++) {\n            for (k = 0; k < 2; k++) {\n                ans = (ans + dp[n][j][k]) % MOD;\n            }\n        }\n        ans = (mpow(2, n) - ans + MOD) % MOD;\n        printf(\"%lld\\n\", ans);\n    }\n    return;\n}\n\n\nint main(int argc, char* argv[])\n{\n#if 1\n    solve();\n#else\n    int T;\n    scanf(\"%d\", &T);\n    int t;\n    for(t=0; t<T; t++) {\n        //printf(\"Case #%d: \", t+1);\n        solve();\n    }\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\n\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void add(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] = (dat[k] + x)%P;\n    while(k>0) k = (k-1)/2, dat[k] = (dat[k*2+1] + dat[k*2+2])%P;\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] = x;\n    while(k>0) k = (k-1)/2, dat[k] = (dat[k*2+1] + dat[k*2+2])%P;\n  }\n\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return (A + B)%P;\n  }\n};\n\nint main(int argc, char const *argv[]) {\n  vll t(5001, 1);\n  for(int i=1;i<=5000;i++) t[i] = (t[i-1]*2)%P;\n  ll n, a, b;std::cin >> n >> a >> b;\n  if(a<b) swap(a, b);\n  ll ans = 0;\n\n  vvl dp = VV(n+1, n+1, 0, ll);\n  dp[0][0] = 1;\n  vvl accum = VV(n+1, n+1, 0, ll);\n  accum[0][0] = 1;\n  segtree seg(n+1, 0);\n  vll ad(n+1, 0);\n  seg.add(1, 0);\n  // dp[i][j] = dp[i-b][j-b] + dp[i-b-1][j-b-1] .....\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<=i;j++){\n      // 11111111...0 (ok)\n      if(j>b) dp[i][j] = accum[i-b-1][j-b-1];\n      if(i==n && j>=b) dp[i][j] = (dp[i][j] + accum[i-b][j-b])%P;\n\n      // 11..0 (error)\n      ll m = max((ll)0, i-b);\n      if(j==1){\n        ll q = seg.query(m, i-1);\n        dp[i][j] = (dp[i][j] + q)%P;\n      }\n      //0\n      if(j>0) dp[i][j] = (dp[i][j] + dp[i-1][j-1])%P;\n    }\n    // okなものは答えに参入して削除\n    for(int j=a;j<=n;j++) {\n      ans = (ans + (t[n-i]*dp[i][j])%P)%P;\n      dp[i][j] = 0;\n    }\n\n    for(int j=0;j<=n;j++) seg.add(ad[j], j), ad[j] = 0;\n    for(int j=0;j<=i;j++) ad[i] = (ad[i] + dp[i][j])%P;\n\n    //accum\n    for(int j=0;j<=n;j++){\n      accum[i][j] = ((j==0?0:accum[i-1][j-1]) + dp[i][j])%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N,A,B;\n\nmint dp1[5100][5100][2];\nbool used1[5100][5100][2];\n//mint func1(int i, int a_len, int fin)\n//{\n//\tif (a_len >= A) {\n//\t\tfin = 1;\n//\t}\n//\tif (fin != 0) {\n//\t\ta_len = 0;\n//\t}\n//\tif (i == N) {\n//\t\tif (fin != 0) {\n//\t\t\treturn 1_mi;\n//\t\t}\n//\t\treturn 0_mi;\n//\t}\n//\n//\tauto& memo = dp1[i][a_len][fin];\n//\tif (used1[i][a_len][fin]) {\n//\t\treturn memo;\n//\t}\n//\tused1[i][a_len][fin] = true;\n//\n//\treturn memo = func1(i + 1, a_len + 1, fin) + func1(i + 1, 0, fin);\n//}\n\n\n\nmint pow2[5100];\nmint dp5[5100][5100];\nbool used5[5100][5100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[5100][5100][2];\nbool used4[5100][5100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\tif (i >= N) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, std::min(i + B,N));\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\tif (A == 1) {\n\t\tout << pow2[N] << endl;\n\t\treturn 0;\n\t}\n\n\n\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 1\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 1000000007\n\nLLI dp[5001][2],dp2[5001][2];\nint main() {\n    int N,A,B;\n    scanf(\"%d %d %d\",&N,&A,&B);\n    if (A > B) swap(A,B);\n    if (A == 1) {\n        int i,p = 1;\n        for (i = 0; i < N; i++) p *= 2,p %= MOD;\n        printf(\"%d\\n\",p);\n        return 0;\n    }\n\n    int i,j;\n    dp[1][1] = 1;\n    for (i = 2; i <= N; i++) {\n        dp[i][1] = dp[i-1][0]+dp[i-1][1];\n        for (j = A; j < i; j++) dp[i][0] += dp[i-j][1];\n        dp[i][0] %= MOD,dp[i][1] %= MOD;\n    }\n    dp2[0][0] = dp2[0][1] = 1;\n    for (i = 1; i <= N; i++) {\n        for (j = 1; j <= i; j++) {\n            if (j < A) dp2[i][0] += dp2[i-j][1];\n            if (j < B) {\n                dp2[i][1] += (dp2[i-j][0]*dp[j][1]) % MOD;\n                if (i == N) dp2[i][1] += (dp2[i-j][0]*dp[j][0]) % MOD;\n                if (j == i) dp2[i][1] += dp[j][0];\n            }\n        }\n        dp2[i][0] %= MOD,dp2[i][1] %= MOD;\n    }\n    int p = 1;\n    for (i = 0; i < N; i++) p *= 2,p %= MOD;\n    printf(\"%lld\\n\",(p-(dp2[N][0]+dp2[N][1])+2*MOD) % MOD);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nvoid chmin(int &a, int b) {\n\ta = min(a, b);\n}\nvoid chmax(int &a, int b) {\n\ta = max(a, b);\n}\nll mod_pow(ll a, ll n, ll m = mod) {\n\ta %= m;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nmodint dp[5002][5002][2];\nmodint rdp[5002][5002];\nmodint rdp2[5002][5002];\nmodint rdp3[5002];\n\n\nvoid solve2(int n,int k) {\n\trdp[1][1] = 2;\n\trep1(i, n-1) {\n\t\trep(j, k) {\n\t\t\tif (j + 1 < k) {\n\t\t\t\trdp[i + 1][j + 1] += rdp[i][j];\n\t\t\t}\n\t\t\trdp[i + 1][1] += rdp[i][j];\n\t\t}\n\t}\n\tmodint ans = mod_pow(2, n);\n\trep(j, k)ans -= rdp[n][j];\n\tcout << ans << \"\\n\";\n}\nvoid solve() {\n\tint n, a, b; cin >> n >> a >> b;\n\tif (a == b) {\n\t\tsolve2(n, a); return;\n\t}\n\tif (a > b)swap(a, b);\n\tdp[0][0][0] = dp[0][0][1] = 1;\n\n\trdp3[1] = 1;\n\trdp2[1][1] = 1;\n\trdp[1][1] = 1;\n\n\trep1(i, n) {\n\t\trdp3[i + 1] = rdp3[i];\n\t\trep(j, min(b,i+1)) {\n\t\t\t//cout << \"?? \" << i << \" \" << j << \" \" << rdp[i - j][b - j] << \"\\n\";\n\t\t\tdp[i][j][0] = rdp[i][j];\n\t\t\tint l1 = i - a + 1;\n\t\t\tint l2 = j - a + 1;\n\t\t\tif (l2 < 0) {\n\t\t\t\tl1 += -l2; l2 = 0;\n\t\t\t}\n\t\t\tint s1 = i - b + 1;\n\t\t\tint s2 = j - b + 1;\n\t\t\tif (s2 < 0) {\n\t\t\t\ts1 += -s2; s2 = 0;\n\t\t\t}\n\t\t\tint ri = i;\n\t\t\tdp[i][j][1] = rdp2[l1][l2]-rdp2[s1][s2];\n\t\t\tif (j == 0) {\n\t\t\t\tint le = i - a + 1; if (le < 0)le = 0;\n\t\t\t\tdp[i][j][1] += rdp3[i] - rdp3[le];\n\t\t\t}\n\n\t\t\trdp2[i + 1][j + 1] = rdp2[i][j]+dp[i][j][0];\n\t\t\trdp[i+1][j + 1] = rdp[i][j]+dp[i][j][1];\n\t\t\trdp3[i + 1] += dp[i][j][0];\n\t\t}\n\t}\n\t/*rep1(i, n) {\n\t\trep(j, b) {\n\t\t\trep(k, 2) {\n\t\t\t\tcout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << \"\\n\";\n\t\t\t}\n\t\t}\n\t}*/\n\tmodint ans = mod_pow(2,n);\n\trep(j, b) {\n\t\trep(k, 2) {\n\t\t\tans -= dp[n][j][k];\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init_f();\n\t//init();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 5010;\n\nll N, A, B;\nll dp1[maxn]; // B blocks starting and ending at b\nll dp2[maxn]; // complement strings ending at b\nll ps[maxn];\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n\n    dp1[1] = 1;\n    for (ll i = 2; i <= B; ++i) {\n        dp1[i] = dp1[i - 1];\n        for (ll j = A; i - 1 - j >= 1; ++j) Add(dp1[i], dp1[i - 1 - j]);\n    }\n    dp2[0] = 1;\n    ps[1] = 1;\n    for (ll i = 1; i <= N; ++i) {\n        for (ll j = 1; j < min(B, i + 1); ++j) {\n            if (i == j) {\n                Add(dp2[i], dp1[j + 1]);\n            } else {\n                ll s = (ps[i - j] - ps[max(0, i - j - A + 1)] + MOD) % MOD;\n                Add(dp2[i], 1LL * dp1[j] * s);\n            }\n        }\n        ps[i + 1] = (ps[i] + dp2[i]) % MOD;\n    }\n\n    ll sum = 0;\n    for (ll i = N; i > N - A; --i) Add(sum, dp2[i]);\n    for (ll i = N - A; i - 1 > N - B; --i) {\n        for (ll j = i; j - 1 > N - B; --j) {\n            ll s = (ps[j - 1] - ps[max(0, j - A)] + MOD) % MOD;\n            Add(sum, 1LL * dp1[i - j + 1] * s);\n        }\n    }\n\n    ll all = 1;\n    for (ll i = 1; i <= N; ++i) Add(all, all);\n\n    ll ans = (all + MOD - sum) % MOD;\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 1000000007;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, a, b;\n  cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  auto dp1 = Make2DVector<FiniteField>(n + 1, b, 0);\n  dp1[0][0] = 1;\n  auto dp2 = vector<FiniteField>(n + 1, 0);\n  dp2[0] = 1;\n  auto dp3 = Make2DVector<FiniteField>(n + 1, b, 0);\n  dp3[0][0] = 1;\n\n  for (int i = 1; i <= n; i++) {\n    if (i >= 2) {\n      dp1[i][1] += dp2[i - 2];\n      if (i - a - 1 >= 0) dp1[i][1] -= dp2[i - a - 1];\n    }\n\n    for (int j = 1; j < b; j++) {\n      dp1[i][j] += dp1[i - 1][j - 1];\n\n      if (i - a - 1 >= 0 && j - a - 1 >= 0) {\n        dp1[i][j] += dp3[i - a - 1][j - a - 1];\n      }\n    }\n\n    dp2[i] = dp2[i - 1];\n    for (int j = 1; j < b; j++) {\n      dp2[i] += dp1[i][j];\n    }\n\n    for (int j = 1; j < b; j++) {\n      dp3[i][j] = dp3[i - 1][j - 1] + dp1[i][j];\n    }\n  }\n\n  FiniteField r = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < b; j++) {\n      int l = j;\n      if (n - i >= a) {\n        l += n - i;\n      }\n      if (l < b) {\n        r += dp1[i][j];\n      }\n    }\n  }\n\n  FiniteField ans = 1;\n  for (int i = 0; i < n; i++) ans *= 2;\n  ans -= r;\n  cout << ans.Value() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=5e3+7;\nconst int mod=1e9+7;\nint f[maxn][2];\nint dp[maxn][2];\nint main()\n{\n    int n;\n    cin>>n;\n    int a,b;\n    cin>>a>>b;\n    if(a>b) swap(a,b);\n    dp[0][0]=dp[0][1]=1;\n    f[0][1]=1;\n    for(int i=0;i<=b+1;i++)\n    {\n        for(int j=a;i+j<=b+1;j++)\n            f[i+j][1]=(f[i+j][1]+f[i][0])%mod;\n        for(int j=1;i+j<=b+1;j++)\n            f[i+j][0]=(f[i+j][0]+f[i][1])%mod;\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=1;j<a&&i+j<=n;j++)\n            dp[i+j][0]=(dp[i+j][0]+dp[i][1])%mod;\n        for(int j=1;j<b&&i+j<=n;j++)\n        {\n            dp[i+j][1]=(dp[i+j][1]+(ll)dp[i][0]*f[j+(i==0)+(i+j==n)][0]%mod)%mod;\n        }\n    }\n    int tot=1;\n    for(int i=1;i<=n;i++) tot=tot*2%mod;\n    print((tot-(dp[n][0]+dp[n][1])%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define Mod 1000000007\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\n\tint i, j, k;\n\tlong long ans = 0, dp[2][1001][1001] = {};\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[0][A][A-1] = 2; j >= 1; j--) dp[0][A][j] = dp[0][A][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[0][i-1][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[0][i][1] = dp[0][i-1][A-1]; j >= 1; j--) {\n\t\t\t\tdp[0][i][j+1] = dp[0][i-1][j];\n\t\t\t\tdp[0][i][1] += dp[0][i-1][j];\n\t\t\t}\n\t\t\tdp[0][i][1] %= Mod;\n\t\t}\n\t} else {\n\t\tif (A > B) {\n\t\t\tB += A;\n\t\t\tA = B - A;\n\t\t\tB -= A;\n\t\t}\n\t\tdp[1][1][0] = 1;\n\t\tdp[1][0][1] = 1;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tdp[i%2][0][1] = 0;\n\t\t\tans = (ans * 2 + dp[1-i%2][B-1][0] + dp[1-i%2][B-A][A-1] + dp[1-i%2][B-A-1][A] * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 2; j >= 1; j--) dp[i%2][j+1][0] = dp[1-i%2][j][0];\n\t\t\tfor (j = B - 1, dp[i%2][B-A][1] = 0; j >= B - A; j--) dp[i%2][B-A][1] += dp[1-i%2][j][0];\n\t\t\tdp[i%2][B-A][1] %= Mod;\n\t\t\tfor (; j >= 1; j--) dp[i%2][j][1] = dp[1-i%2][j][0];\n\t\t\t\n\t\t\tfor (k = A - 1, dp[i%2][1][0] = 0; k >= 1; k--) {\n\t\t\t\tfor (j = 0; j <= B - A; j++) {\n\t\t\t\t\tdp[i%2][j][k+1] = dp[1-i%2][j][k];\n\t\t\t\t\tdp[i%2][1][0] += dp[1-i%2][j][k];\n\t\t\t\t}\n\t\t\t\tdp[i%2][1][0] %= Mod;\n\t\t\t}\n\t\t\tfor (j = 0; j <= B - A - 2; j++) {\n\t\t\t\tdp[i%2][j+1][A] = (dp[i%2][j+1][A] + dp[1-i%2][j][A]) % Mod;\n\t\t\t\tdp[i%2][j+A+1][0] = (dp[i%2][j+A+1][0] + dp[1-i%2][j][A]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconstexpr auto MOD = (long long)1e9+7;\nconstexpr auto MAXN = 6000;\n\nlong long Pow(long long a,long long b){\n    long long ans = 1LL;\n    for(;b;b>>=1,(a*=a)%=MOD)\n        if(b&1) (ans *= a) %= MOD;\n    return ans;\n}\n\nlong long f[4][MAXN];\nlong long g[MAXN][2];\n\nsigned main(void)\n{\n    int len,a,b;\n    long long ans=0;\n\n    std::cin>>len>>a>>b;\n    if(a > b) std::swap(a,b);\n    if(b<2) goto OP;\n\n    f[0][1] = 1LL;\n    for(int i=2;i<b;++i){\n        f[0][i] = 1;\n        for(int j=1;j<i;++j) (f[0][i] += f[1][i-j]) %= MOD;\n        for(int j=i-a;j>=0;--j) (f[1][i] += f[0][j]) %= MOD;\n\n        for(int j=1;j<i;++j) (f[2][i] += f[3][j]) %= MOD;\n        if(i >= a) f[3][i] = 1;\n        for(int j=i-a;j>=0;--j) (f[3][i] += f[2][j]) %= MOD;\n    }\n    for(int i=1;i<=len;++i){\n        if(i < b) g[i][1] = f[0][i] + f[2][i];\n        for(int j=1; j<b&&i-j>0; ++j)\n            (g[i][1] += g[i-j][0]*f[0][j]) %= MOD;\n\n        if(i < a) g[i][0] = 1LL;\n        for(int j=1; j<a&&i-j>0; ++j)\n            (g[i][0] += g[i-j][1]) %= MOD;\n    }\n\n    ans = (g[len][0]+g[len][1]) % MOD;\n    for(int i=1;i<len;++i) (ans += g[i][0]*f[1][len-i]) %= MOD;\n    \n OP:\n    std::cout<< (Pow(2LL,len)-ans+MOD)%MOD <<std::endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  P operator-() const {\n    P res((*this).size());\n    rep(i, (*this).size()) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, (*this).size()) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q) {\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  // P &div(map<int, T> q) {\n  //   rep(i, (*this).size()) {\n  //     for (auto &b : q) if (b.first != 0 && b.first <= i) (*this)[i] -= b.second * (*this)[i-b.first];\n  //     (*this)[i] /= q[0];\n  //   }\n  //   return *this;\n  // }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div({{0, 1}, {1, -1}});\n  q[1] = 1;\n  q.div({{0, 1}, {1, -1}});\n  f[1] = 1;\n  f[a] -= 1;\n  f.div({{0, 1}, {1, -1}});\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+1) g0[i] = 0;\n  rep2(i, b, n+1) g1[i] = 0;\n  rep2(i, b, n+1) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// =========== Template ========== //\n#include <bits/stdc++.h>\nusing namespace std;\nint fastio() { ios_base::sync_with_stdio(false); cout << fixed << setprecision(10); cin.tie(nullptr); return 0; }\nint __fastio = fastio();\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p);\ntemplate<typename A> ostream& operator<<(ostream &os, const set<A> &m) { os << \"{\"; string sep = \"\"; for (auto e: m) os << sep << e, sep = \", \"; return os << \"}\"; }\ntemplate<typename A> ostream& operator<<(ostream &os, const multiset<A> &m) { os << \"{\"; string sep = \"\"; for (auto e: m) os << sep << e, sep = \", \"; return os << \"}\"; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const map<A, B> &m) { os << \"{\"; string sep = \"\"; for (auto e: m) os << sep << e.first << \": \" << e.second, sep = \", \"; return os << \"}\"; }\ntemplate<typename T>ostream& operator<<(ostream& os, const vector<T>& v) { os << \"[\"; string sep = \"\"; for (auto e: v) os << sep << e, sep = \", \"; return os << \"]\"; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef STEVEN\n#define pp(...) cerr << \"\\t[\" << #__VA_ARGS__ << \"]:\\t\", dbg_out(__VA_ARGS__)\n#define ppp(x) cerr << x << \"\\n\"\n#else\n#define pp(...)\n#define ppp(...)\n#endif\ntemplate<class Fun> class y_combinator_result { Fun fun_; public: template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {} template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); } };\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define fi first\n#define se second\n#define sz(x) (int((x).size()))\n#define data _data\n// =========== Book ============ //\n\nconst int inf = 1000 << 20;\nconst ll infl = 1LL << 60;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n  private:\n  using ll = long long;\n  int v;\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n  public:\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\n\n// ============= Solution ============= //\n\n// state: len, cnt, last\n// last = 1 ->\n//   len + 1, cnt + 1, 1\n//   len + 1, cnt + 1, 0\n// last = 0 ->\n//   len + A, cnt + A, 1\n//   len + 1, cnt + 1, 0\n//   len + k + 1, 1, 0 for k = 1...A - 1\n\ntypedef modnum<int(1E9 + 7)> mint;\nint main() {\n  int n, a, b;\n  cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  vector<vector<vector<mint>>> dp(n + 1, vector<vector<mint>>(b + 1, vector<mint>(2)));\n  for (int i = 0; i < b; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      dp[n][i][j] = 1;\n    }\n  }\n\n  for (int i = n - 1; i >= 0; --i) {\n    mint val = 0;\n    for (int c = 1; c <= a - 1; ++c) {\n      if (i + c + 1 <= n) {\n        val += dp[i + c + 1][1][0];\n      }\n    }\n    if (n - i < a) {\n      val += dp[n][1][0];\n    }\n\n    for (int j = 0; j < b; ++j) {\n      for (int k = 0; k < 2; ++k) {\n        if (k == 1) {\n          if (j + 1 < b) {\n            dp[i][j][k] += dp[i + 1][j + 1][1];\n            dp[i][j][k] += dp[i + 1][j + 1][0];\n          }\n        } else {\n          if (i + a <= n && j + a < b) {\n            dp[i][j][k] += dp[i + a][j + a][1];\n          }\n          if (j + 1 < b) {\n            dp[i][j][k] += dp[i + 1][j + 1][0];\n          }\n          dp[i][j][k] += val;\n        }\n      }\n    }\n  }\n  mint ans = 1;\n  for (int i = 0; i < n; ++i) ans *= 2;\n  ans -= dp[0][0][0];\n  cout << ans << \"\\n\";\n}\n\n// ============== Notes =============== //\n// common bugs\n// - fastio\n// - int overflow (especially intermediate expressionns)\n// - array bounds (indices bigger than MAXN?)\n// - special cases (n=1? graph not connected?)\n// - re-initialize efficiently between test cases\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=5005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint coef[MAXN],encoef[MAXN],n,A,B;\n//end is 0\nvoid getcoef()\n{\n\tcoef[1]=1;\n\tfor(int i=1;i<A;i++)\n\t{\n\t\tad(coef[i+1],coef[i]); \n\t\tfor(int j=B;i+j<=A;j++)ad(coef[i+j+1],coef[i]),ad(encoef[i+j],coef[i]);\n\t}\n}\nint f[MAXN][2];//end with 0/1\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tn=read();A=read();B=read();if(A<B)swap(A,B);\n\tgetcoef();\n\tfor(int i=0;i<B;i++)f[i][1]=1;\n\tfor(int i=1;i<A;i++)f[i][0]=encoef[i];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=1;j<A;j++)\n\t\t{\n\t\t\tad(f[i+j][0],1LL*f[i][1]*coef[j]%mod);\n\t\t\tif(i+j==n)ad(f[i+j][1],1LL*f[i][1]*encoef[j]%mod);\n\t\t}\n\t\tfor(int j=1;j<B;j++)\n\t\t\tad(f[i+j][1],f[i][0]);\n\t}\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)ans=2LL*ans%mod;\n\tdl(ans,f[n][0]);dl(ans,f[n][1]);\n\tpr2(ans);\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10010,mod=1e9+7;\nint n,a,b,f[N],g[N],h[N],hh[N],ans;\nint power(int x,int y){\n    int z=1;\n    for(;y;y>>=1,x=1ll*x*x%mod)if(y&1)z=1ll*z*x%mod;\n    return z;\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b)swap(a,b);g[a]=g[0]=1;\n    for(int i=a+1;i<=b-2;i++){\n        g[i]=g[i-1];\n        for(int j=i-a-1;~j;j--)(g[i]+=g[j])%=mod;\n    }\n    f[0]=g[0]=1;for(int i=1;i<=b-2;i++)(g[i]+=g[i-1])%=mod;\n    for(int i=1;i<a;i++)\n        for(int j=0;j<b;j++)\n            j?(h[i+j]+=j>1?g[j-2]:1)%=mod:0,\n            (hh[i+j]+=j?g[j-1]:1)%=mod;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=i;j++)\n            f[i]=(f[i]+1ll*f[i-j]*(i-j?h[j]:hh[j]))%mod;\n    for(int i=n;i>n-b;i--)ans=(ans+1ll*f[i]*(i<n?g[n-i-1]:1))%mod;\n    cout<<((power(2,n)-ans)%mod+mod)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define f first\n#define s second\n\nconst int mod = 1000000007;\nconst int mxn = 5002;\nint n, x, y;\nint dp2[mxn];\nint dp[mxn][2];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> x >> y;\n\tif(x > y) swap(x, y);\n\t\n\tint ret = 1;\n\tdp[0][0] = dp[0][1] = dp2[0] = dp2[1] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tdp2[i + 1] = (dp2[i] + (i >= x)) % mod;\n\t\tfor(int j = x; j < i; j++) (dp2[i + 1] += dp2[i - j]) %= mod;\n\t\t\n\t\tfor(int j = 1; j <= min(i, x - 1); j++){\n\t\t\t(dp[i][0] += dp[i - j][1]) %= mod;\n\t\t}\n\t\tfor(int j = 1; j <= min(i, y - 1); j++){\n\t\t\t(dp[i][1] += (ll)dp2[1 + j - (i != n) - (j != i)] * dp[i - j][0] % mod) %= mod;\n\t\t}\n\t\t\n\t\t(ret *= 2) %= mod;\n\t}\n\t(ret += (mod - (dp[n][0] + dp[n][1]) % mod)) %= mod;\n\t\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nint N, A, B;\n\nint dp[5001][5001][2][2];\nint dp1[5002][5002][2];\nint dp2[5002][5002][2];\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    for(short n=N; n>=0; n--){\n        for(short k=N; k>=0; k--){\n            for(short b=0; b<2; b++){\n                for(short a=0; a<2; a++){\n                    if(n == N){\n                        if(a == 1 || k >= A) dp[n][k][b][a] = 1;\n                        else dp[n][k][b][a] =  0;\n                        continue;\n                    }\n                    bool a2 = a;\n                    if(k >= A) a2 = true;\n                    ll ret = dp[n+1][k+1][0][a2];\n                    if(b == 0){\n                        ret += dp1[n+1][0][a2] - dp1[n+min(B, N-n+1)][0][a2];\n                        ret += dp2[n+min(B, N-n+1)][k+min(B, N-n+1)][a2] - dp2[N+1][k+N-n+1][a2];\n                    }\n                    if(ret < 0) ret += MOD;\n                    if(ret < 0) ret += MOD;\n                    if(ret >= MOD) ret -= MOD;\n                    if(ret >= MOD) ret -= MOD;\n                    dp[n][k][b][a] = ret;\n                }\n            }\n\n            for(short a=0; a<2; a++){\n                int ret = dp[n][k][1][a] + dp1[n+1][k][a];\n                if(ret >= MOD) ret -= MOD;\n                dp1[n][k][a] = ret;\n            }\n\n            for(short a=0; a<2; a++){\n                int ret = dp[n][k][1][a] + dp2[n+1][k+1][a];\n                if(ret >= MOD) ret -= MOD;\n                dp2[n][k][a] = ret;\n            }\n        }\n    }\n    cout << dp[0][0][0][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAX=5005,mod=1e9+7,inf=0x3f3f3f3f;\n\ntypedef pair < ll, ll > ii;\nll f[MAX][MAX][2],F[MAX][MAX][2],cnt[MAX];\n#define X first\n#define Y second\n#define pb push_back\n//vector < int > pr[MAX];\nint n,m;\n//ll a[MAX];\nint A,B;\nint get(int a,int b){\n    a+=b;if(a>=mod) a-=mod;return a;\n}\nint main()\n{\n    //memset(ST,0,sizeof ST);\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"45C.inp\",\"r\",stdin);freopen(\"45C.out\",\"w\",stdout);\n    cin>>n;\n    cin>>A>>B;\n    //cout<<mod*2;\n    if(A>B) swap(A,B);\n    ll ans=1;\n    f[0][0][1]=1;\n    f[0][0][0]=1;\n    cnt[0]=1;\n    F[0][0][0]=1;\n    F[0][0][1]=1;\n    for(int i=1;i<=n;i++){ans=ans<<1;if(ans>=mod) ans-=mod;}\n    for(int i=1;i<=n;i++){\n        if(i>=A) f[i][0][0]=cnt[i-1]-cnt[i-A];\n        else f[i][0][0]=cnt[i-1];\n        F[i][i][0]=get( F[i-1][i][0],f[i][0][0] );\n        for(int j=1,ma=min(B-1,i);j<=ma;j++){\n            //for(int u=A;u<j;u++) f[i][j][0]+=f[i-u][j-u][1];\n            if(i>=A) f[i][j][0]=F[i-A][i-j][1];\n\n            F[i][i-j][0]=get( F[i-1][i-j][0],f[i][j][0] );\n        }\n        for(int j=1,ma=min(B-1,i);j<=ma;j++){\n            //for(int u=1;u<=j;u++) f[i][j][1]+=f[i-u][j-u][0];\n\n            f[i][j][1]=F[i-1][i-j][0];\n\n            F[i][i-j][1]=get(F[i-1][i-j][1],f[i][j][1]);\n            cnt[i]=get(f[i][j][1],cnt[i]);\n        }\n        cnt[i]=get(cnt[i-1],cnt[i]);\n    }\n    ll temp=0;\n    for(int j=0;j<B;j++){\n        temp=(temp+f[n][j][1]+f[n][j][0])%mod;\n        //cout<<j<<' '<<f[n][j][1]<<' '<<f[n][j][0]<<'\\n';\n    }\n    cout<<(ans-temp+mod)%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 5000 + 10;\ntypedef long long LL;\nconst LL MOD = 1e9 + 7;\nint n, A, B;\nLL f[N][N][2];\nLL g[N][N][2], w[N][2];\nvoid add(LL & x, LL y) {\n\tx += y;\n\tif (x > MOD) x -= MOD;\n}\nint main() {\n\tcin >> n >> A >> B;\n\tif (A < B) swap(A, B);\n\tLL tot = 1;\n\tfor (int i = 1; i <= n; i ++) tot = tot * 2 % MOD;\n\t\n\tf[0][0][0] = 1; g[0][0][0] = 1; w[0][0] = 1;\n\tf[0][0][1] = 1; g[0][0][1] = 1; w[0][1] = 1;\n\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < A; j ++) {\n\t\t\tif (i>=1 && j>=1) {\n\t\t\t\tadd(f[i][j][0], g[i-1][j-1][1]);\n\t\t\t}\n\t\t\tif (i-B>=0 && j-B>=0) {\n\t\t\t\tadd(f[i][j][1], g[i-B][j-B][0]);\n\t\t\t}\n\t\t}\n\t\tfor (int t = 1; t <= min(i, B - 1); t ++) {\n\t\t\tadd(f[i][0][1], w[i-t][0]);\n\t\t}\n\t\tg[i][0][1] = f[i][0][1];\n\t\tfor (int j = 1; j < A; j ++) {\n\t\t\tg[i][j][0]=(g[i-1][j-1][0]+f[i][j][0])%MOD;\n\t\t\tg[i][j][1]=(g[i-1][j-1][1]+f[i][j][1])%MOD;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < A; j ++) {\n\t\t\tadd(w[i][0], f[i][j][0]);\n\t\t\tadd(w[i][1], f[i][j][1]);\n\t\t}\n\t}\n\tfor (int j = 0; j < A; j ++) {\n\t\tfor (int k = 0; k < 2; k ++) {\n\t\t\ttot = tot - f[n][j][k];\n\t\t\ttot = (tot % MOD + MOD)\t% MOD;\t\n\t\t}\n\t}\n\tcout << tot << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 5e3 + 5;\n\nModint dp [MAX_N][MAX_N];\nModint isum [MAX_N];\nModint dsum [MAX_N][MAX_N];\n\nModint irange (int l, int r) {\n  l = max(0, l);\n  if (r < l) return Modint(0);\n  if (l == 0) return isum[r];\n  return isum[r] - isum[l - 1];\n}\n\nModint dget (int diag, int idx) {\n  if (diag < 0 || idx < 0) return Modint(0);\n  return dsum[diag][idx];\n}\n\nint main () {\n  int n, A, B;\n  cin >> n >> A >> B;\n\n  if (A > B) swap(A, B);\n  if (A == 1) {\n    cout << exp(Modint(2), n) << endl;\n    return 0;\n  }\n\n  dp[0][0] = Modint(1);\n  dsum[0][0] = Modint(1);\n  isum[0] = Modint(1);\n  for (int i = 1; i <= n + 1; i++) {\n    for (int b = 1; b <= i; b++) {\n      if (b == 1) {\n        if (i == 1) {\n          dp[i][b] = 1;\n        } else {\n          dp[i][b] = irange(i - A, i - 2);\n        }\n      } else {\n        dp[i][b] = dget(i - b, i - A - 1);\n        if (b - 1 < B) {\n          dp[i][b] += dp[i - 1][b - 1];\n        }\n      }\n\n      if (b < B) {\n        isum[i] += dp[i][b];\n        dsum[i - b][i] += dp[i][b];\n      }\n      dsum[i - b][i] += dsum[i - b][i - 1];\n    }\n\n    isum[i] += isum[i - 1];\n  }\n\n  /*\n  for (int i = 1; i <= n + 1; i++) {\n    for (int b = 1; b <= n + 1; b++) {\n      cout << dp[i][b] << \" \";\n    }\n    cout << endl;\n  }\n  */\n  \n  Modint ans (0);\n  for (int i = 1; i <= n + 1; i++) {\n    for (int b = B; b <= n + 1; b++) {\n      if (i == n + 1) {\n        if (b != B) {\n          ans += dp[i][b];\n        }\n      } else {\n        ans += dp[i][b] * exp(Modint(2), n - i);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define i64 long long int\n#define ui64 unsigned long long int\n#define eps (1e-10)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\n#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL)\n\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int,int> pii;\n\n#define log 20\n#define mod 1000000007LL\n#define maxn 2000005\n#define INF 1000000000000000000LL\n\ni64 dp[2][5005][5005] ;\ni64 sum[5005] ;\n\ni64 p2[5005] ;\n\nint main()\n{\n    int n , a , b ;\n\n    scanf(\"%d %d %d\",&n,&a,&b) ;\n\n    if( a<b ) swap(a,b) ;\n\n    p2[0] = 1 ;\n    for(int i=1 ; i<=n ; i++)\n    {\n        p2[i] = (2LL*p2[i-1])%mod ;\n    }\n\n    if(b==1)\n    {\n        printf(\"%lld\\n\",p2[n]) ;\n        return 0 ;\n    }\n\n    for(int j=a ; j<=n ; j++)\n    {\n        dp[0][0][j] = 1 ;\n        dp[1][0][j] = 1 ;\n    }\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=0 ; j<a ; j++)\n        {\n            if( i>=2 )\n            {\n                int mx = min( i , b ) ;\n                dp[0][i][j] = sum[i-2] ;\n                if( i-mx-1 >=0 ) dp[0][i][j] -= sum[ i-mx-1  ] ;\n            }\n\n            dp[0][i][j] += dp[0][i-1][j+1] ;\n            if( b<=i ) dp[0][i][j] += dp[1][i-b][ j+b ] ;\n\n            dp[0][i][j] %= mod ;\n\n            dp[1][i][j] = ( dp[1][i-1][j+1] + dp[0][i-1][j+1] )%mod ;\n        }\n        for(int j=a ; j<=n ; j++)\n        {\n            dp[0][i][j] = dp[1][i][j] = p2[i] ;\n        }\n        sum[i] = (sum[i-1] + dp[0][i][1])%mod ;\n    }\n\n    printf(\"%lld\\n\" , (dp[0][n][0]%mod + mod)%mod ) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr Gwj\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define debug_pair(A) cerr<<A.FIR<<\" \"<<A.SEC<<endl;\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nint n,a,b;\nLL g[10050][2],allsum,sum[5005],f[5005][5005][2];\nconst int MOD=1e9+7,base=5010;\t\nint main(){\n\tfastio;\n\tcin>>n>>a>>b;\n\tif(a<b) swap(a,b);\n\tf[0][0][1]=1;\n\tg[0+base][1]=1;\n\tf[0][0][0]=1;\n\tsum[0]=1;\n\tallsum=1;\n\trb(i,1,n){\n\t\tif(i>=b){\n\t\t\tallsum-=sum[i-b];\n\t\t\tallsum+=MOD;\n\t\t\tallsum%=MOD;\n\t\t\trb(j,0,a-1){\n\t\t\t\tif(j>=b)\n\t\t\t\tg[j-i+base][0]+=f[i-b][j-b][0];\n\t\t\t\tg[j-i+base][0]%=MOD;\n\t\t\t}\n\t\t}\n\t\trb(j,0,a-1){\n\t\t\tif(j<=i)\n\t\t\trep(k,2){\n\t\t\t\tif(j==0){\n\t\t\t\t\tif(k==1){\n\t\t\t\t\t\tf[i][j][1]=allsum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(!k){\n\t\t\t\t\t\tf[i][j][k]=g[j-i+base][1];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tf[i][j][k]=g[j-i+base][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=f[i][j][0];\n\t\t\tsum[i]%=MOD;\n\t\t\tg[j-i+base][1]+=f[i][j][1];\n\t\t\tg[j-i+base][1]%=MOD;\n\t\t}\n\t\tallsum+=sum[i];\n\t\tallsum%=MOD;\n\t}\n\tLL res=1;\n\trb(i,1,n) res<<=1,res%=MOD;\n//\tcout<<f[1][0][1]<<endl;\n\trb(j,0,a-1){\n\t\trep(k,2){\n\t\t\tres-=f[n][j][k];\n//\t\t\tcout<<j<<\" \"<<k<<\" \"<<f[n][j][k]<<endl;\n\t\t\tres+=MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\t\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5e3 + 5;\nconst int mod = 1e9 + 7;\ninline int pls( int a , int b ) { a += b - mod; return a + ( a >> 31 & mod ); }\ninline int mns( int a , int b ) { a -= b; return a + ( a >> 31 & mod ); }\ninline void inc( int & a , int b ) { a += b - mod; a += a >> 31 & mod; }\ninline void dec( int & a , int b ) { a -= b; a += a >> 31 & mod; }\n\nint A , B , n , ans;\nint f[N] , g[N][2];\n\nint main( void ) {\n  cin >> n >> A >> B; \n  if( A > B ) swap( A , B );\n  ans = 1;\n  for( int i = 1 ; i <= n ; ++i ) ans = pls( ans , ans );\n  if( B == 1 ) return printf(\"%d\",ans) , 0;\n  f[0] = 1;\n  for( int i = 1 ; i <= B ; ++i ) {\n    f[i] = f[i - 1];\n    for( int j = A ; j <= i ; ++j ) {\n      if( j ^ i ) inc( f[i] , f[i - j - 1] );\n      else inc( f[i] , 1 );\n    }\n  }\n  g[0][0] = 1;\n  for( int i = 1 ; i < B ; ++i )\n    g[i][0] = f[i - 1];\n  for( int i = 1 ; i <= n ; ++i ) {\n    for( int j = 1 ; j < B && j <= i ; ++j )\n      inc( g[i][0] , 1LL * g[i - j][1] * ( j == 1 ? 1 : f[j - 2] ) % mod );\n    for( int j = 1 ; j < A && j <= i ; ++j )\n      inc( g[i][1] , g[i - j][0] );\n  }\n  dec( ans , g[n][1] );\n  for( int i = 1 ; i < B && i <= n ; ++i )\n    dec( ans , 1LL * g[n - i][1] * f[i - 1] % mod );\n  printf(\"%d\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\ntypedef long long LL;\nconst int N=5005,P=1e9+7;\nint n,A,B,f[N],g[N][2];\nint fpow(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;\n\treturn k3;\n}\nint main(){\n\tcin>>n>>A>>B;\n\tif(A>B)swap(A,B);\n\tf[1]=1;\n\trep(i,1,B-1){\n\t\t(f[i+1]+=f[i])%=P;\n\t\trep(j,i+A+1,B)(f[j]+=f[i])%=P;\n\t}\n//\tprintf(\">>> %d %d\\n\",A,B);\n//\trep(i,1,B)printf(\"%d \",f[i]);puts(\"\");\n\trep(i,1,B-1)g[i][0]=f[i+1];\n\trep(i,1,A-1)g[i][1]=1;\n\trep(i,1,n){\n\t\trep(j,i+1,i+B-1)if(j==n)(g[j][0]+=1LL*g[i][1]*f[j-i+1]%P)%=P;else (g[j][0]+=1LL*g[i][1]*f[j-i]%P)%=P;\n\t\trep(j,i+1,i+A-1)(g[j][1]+=g[i][0])%=P;\n//\t\tprintf(\"g[%d][0]=%d g[%d][1]=%d\\n\",i,g[i][0],i,g[i][1]);\n\t}\n\tprintf(\"%lld\\n\",((LL)fpow(2,n)-g[n][0]-g[n][1]+P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint n,a,b;\nint dp[5005][5005][2],sum[5005][5005][2];\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\ninline void sub(int &x,int y){\n\tx-=y;if(x<0)x+=mod;\n}\ninline int Add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int Sub(int x,int y){\n\treturn x>=y?x-y:x-y+mod;\n}\nint main(){\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\tdp[1][0][0]=1;\n\tdp[1][0][1]=1;\n\tadd(sum[1][0][1],dp[1][0][1]);\n\tadd(sum[1][0][0],dp[1][0][0]); \n\tfor(int i=2;i<=n+1;i++){\n\t\tfor(int j=0;j<=5000;j++){\n\t\t\tif(j)add(sum[i][j][1],sum[i-1][j-1][1]);\n\t\t\tif(j)add(sum[i][j][0],sum[i-1][j-1][0]);\n\t\t\tif(j)add(dp[i][0][1],Sub(sum[i-1][j-1][0],(i>=a&&j>=a?sum[i-a][j-a][0]:0)));\n\t\t\tif(j>=b)continue;\n\t\t\tif(j)add(dp[i][j][0],sum[i-1][j-1][1]);\n\t\t\tadd(dp[i][j][1],(i>=a&&j>=a?sum[i-a][j-a][0]:0));\n\t\t}\n\t\tfor(int j=0;j<b;j++){\n\t\t\tadd(sum[i][j][1],dp[i][j][1]);\n\t\t\tadd(sum[i][j][0],dp[i][j][0]);\n//\t\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[i][j][0]<<\" \"<<dp[i][j][1]<<endl;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<b;i++){\n\t\tadd(ans,dp[n+1][i][0]);\n\t\tadd(ans,dp[n+1][i][1]);\n\t}\n\tans=Sub(modpow(2,n,mod),ans);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 5000 + 10;\nconstexpr int mod = 1000000007;\nint N, A, B;\nvoid add(int& x, int y){\n    x += y;\n    if(x >= mod) x -= mod;\n}\nint dp[maxn + 1][maxn + 1];\nint sumh[maxn + 1][maxn + 1];\nint shit[maxn + 1][maxn + 1];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    dp[0][0] = 1;\n    for(int i = 0; i <= N; i += 1)\n        for(int j = 0; j <= i; j += 1){\n            add(dp[i][j], shit[i][j]);\n            add(dp[i][j], sumh[i][j]);\n            add(shit[i + 1][j + 1], shit[i][j]);\n            add(sumh[i + 1][j], sumh[i][j]);\n            {\n                int ni = i + 1;\n                int nj = j + 1;\n                add(dp[ni][nj], dp[i][j]);\n            }\n            {\n                int ni = i + B + 1;\n                int nj = j + B + 1;\n                add(shit[ni][nj], dp[i][j]);\n            }\n            {\n                int ni1 = i + 2;\n                int ni2 = i + B + 1;\n                int nj = j >= A ? j : 1;\n                add(sumh[ni1][nj], dp[i][j]);\n                add(sumh[ni2][nj], (mod - dp[i][j]) % mod);\n            }\n            int ni = N;\n            int nj = j >= A ? j : (N - i >= B ? j + N - i : 0);\n            add(dp[ni][nj], dp[i][j]);\n        }\n    int ans = 0;\n    for(int i = A; i <= N; i += 1) add(ans, dp[N][i]);\n    cout << (LL)ans * (mod + 1) / 2 % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 5010;\nconst int P = 1e9 + 7;\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P) a-= P;\n}\nint mul(int a,int b){\n  return a * b % P;\n}\nint n,a,b;\nint p2[MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> a >> b;\n  p2[0] = 1;\n  R(i,MAX-1){\n    p2[i+1] = p2[i];\n    add(p2[i+1], p2[i]);\n  }\n  if(a < b)swap(a, b);\n  if(a == 1 || b == 1){\n    cout << p2[n] << \"\\n\";\n    return 0;\n  }\n  vector<vector<int>> dpa(n+1,vector<int>(n+1));\n  vector<vector<int>> dpb(n+1,vector<int>(n+1));\n  dpa[0][0] = 1;\n  int res = 0;\n  for(int i = 0; i < n; i++){\n    int sum = 0;\n    for(int j = 0; j < a; j++){\n      add(sum, dpa[i][j]);\n      if(i + b <= n){\n        if(j + b >= a){\n          add(res, mul(p2[n-i-b], dpa[i][j]));\n        }else{\n          add(dpb[i + b][j + b], dpa[i][j]);\n        }\n      }\n      if(j != a-1){\n        add(dpa[i+1][j+1], dpa[i][j]);\n        add(dpa[i+1][j+1], dpb[i][j]);\n        add(dpb[i+1][j+1], dpb[i][j]);\n      }else{\n        int mn = 0;\n        add(mn, dpa[i][j]);\n        add(mn, dpb[i][j]);\n        add(mn, dpb[i][j]);\n        add(res, mul(mn, p2[n-i-1]));\n      }\n    }\n    for(int j = 1; j < b; j++){\n      if(i + j + 1 < n){\n        add(dpa[i + j + 1][1], sum);\n      }\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint sz[2], N, s00p[5009][2], dp[2][5009][2][2], s[5009][5009][2][2];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[2000009], inv[2000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=0; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){if (K > N || N < 0 || K < 0) return 0; int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nvoid addDiag (int i, int j, int k, int p, int l, int r, int val)\n{\n    r = min (r, N - i);\n    if (l < 1)\n        l = 1;\n    if (l > r) return ;\n    //if (i == j && p == 1 && k == 0)\n      //  printf (\"%d+, %d+, %d, %d    +%d on [%d, %d]\\n\", i, j, k, p, val, l, r);\n    adto (s[i + l][j + l][k][p], val);\n    s[i + r + 1][j + r + 1][k][p] = subtract (s[i + r + 1][j + r + 1][k][p], val);\n}\n\nvoid add00p (int i, int l, int r, int p, int val)\n{\n    r = min (r, N - i);\n    if (l > r) return ;\n    adto (s00p[i + l][p], val);\n    s00p[i + r + 1][p] = subtract (s00p[i + r + 1][p], val);\n}\n\nint bruteDp[20][20][2][2];\nvoid brute (int dp[20][20][2][2])\n{\n    for (int i=1; i<=N; i++)\n    {\n        adto (dp[i][i * (i >= sz[0])][0][(i * (i >= sz[0])) >= sz[1]], 1);\n        adto (dp[i][i][1][i >= sz[1]], 1);\n        for (int j=0; j<=i; j++)\n            for (int k=0; k<2; k++)\n                for (int p=0; p<2; p++)\n                    if (dp[i][j][k][p])\n                        for (int j2=1; i + j2 <= N; j2++)\n                        {\n                            int newJ = j + j2;\n                            if (k == 1 && j2 < sz[0])\n                                newJ = 0;\n                            adto (dp[i + j2][newJ][k ^ 1][p | (newJ >= sz[1])], dp[i][j][k][p]);\n                        }\n    }\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &sz[0], &sz[1]);\nif (sz[0] > sz[1])\n    swap (sz[0], sz[1]);\n//if (N < 15)\n  //  brute (bruteDp);\nfor (int i=1; i<=N; i++)\n{\n    memset (dp[i & 1], 0, sizeof (dp[i & 1]));\n    adto (dp[i & 1][i * (i >= sz[0])][0][(i * (i >= sz[0])) >= sz[1]], 1);\n    adto (dp[i & 1][i][1][i >= sz[1]], 1);\n    for (int p=0; p<2; p++)\n        adto (s00p[i][p], s00p[i - 1][p]),\n        adto (dp[i & 1][0][0][p], s00p[i][p]);\n    for (int j=0; j<=i; j++)\n        for (int k=0; k<2; k++)\n            for (int p=0; p<2; p++)\n            {\n                if (i > 0 && j > 0)\n                    adto (s[i][j][k][p], s[i - 1][j - 1][k][p]);\n                adto (dp[i & 1][j][k][p], s[i][j][k][p]);\n                //if (dp[i][j][k][p] != bruteDp[i][j][k][p])\n                  //  printf (\"wa (%d, %d, %d, %d) -> %d instead of %d\\n\", i, j, k, p, dp[i][j][k][p], bruteDp[i][j][k][p]);\n                if (dp[i & 1][j][k][p])\n                {\n                    //if (i == 2 && j == 2 && k == 1)\n                      //  k = 1;\n                    int curr = dp[i & 1][j][k][p];\n                    if (k == 1)\n                    {\n                        add00p (i, 1, sz[0] - 1, p, curr);\n                        addDiag (i, j, 0, p, sz[0], sz[1] - j - 1, curr);\n                        addDiag (i, j, 0, 1, max (sz[1] - j, sz[0]), N - i, curr);\n                    }\n                    else\n                    {\n                        addDiag (i, j, 1, p, 1, sz[1] - j - 1, curr);\n                        addDiag (i, j, 1, 1, sz[1] - j, N - i, curr);\n                    }\n/*                    for (int j2=1; i + j2 <= N; j2++)\n                    {\n                        int newJ = j + j2;\n                        if (k == 1 && j2 < sz[0])\n                            newJ = 0;\n                        adto (dp[i + j2][newJ][k ^ 1][p | (newJ >= sz[1])], dp[i][j][k][p]);\n                    }*/\n                }\n            }\n}\nint ans = 0;\nfor (int j=0; j<=N; j++)\n    for (int k=0; k<2; k++)\n        adto (ans, dp[N & 1][j][k][1]);\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define Mod 1000000007\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\n\tint i, j, k;\n\tlong long ans = 0, dp[2][2001][2001] = {};\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[0][A][A-1] = 2; j >= 1; j--) dp[0][A][j] = dp[0][A][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[0][i-1][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[0][i][1] = dp[0][i-1][A-1]; j >= 1; j--) {\n\t\t\t\tdp[0][i][j+1] = dp[0][i-1][j];\n\t\t\t\tdp[0][i][1] += dp[0][i-1][j];\n\t\t\t}\n\t\t\tdp[0][i][1] %= Mod;\n\t\t}\n\t} else {\n\t\tif (A > B) {\n\t\t\tB += A;\n\t\t\tA = B - A;\n\t\t\tB -= A;\n\t\t}\n\t\tdp[1][1][0] = 1;\n\t\tdp[1][0][1] = 1;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tdp[i%2][0][1] = 0;\n\t\t\tans = (ans * 2 + dp[1-i%2][B-1][0] + dp[1-i%2][B-A][A-1] + dp[1-i%2][B-A-1][A] * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 2; j >= 1; j--) dp[i%2][j+1][0] = dp[1-i%2][j][0];\n\t\t\tfor (j = B - 1, dp[i%2][B-A][1] = 0; j >= B - A; j--) dp[i%2][B-A][1] += dp[1-i%2][j][0];\n\t\t\tdp[i%2][B-A][1] %= Mod;\n\t\t\tfor (; j >= 1; j--) dp[i%2][j][1] = dp[1-i%2][j][0];\n\t\t\t\n\t\t\tfor (k = A - 1, dp[i%2][1][0] = 0; k >= 1; k--) {\n\t\t\t\tfor (j = 0; j <= B - A; j++) {\n\t\t\t\t\tdp[i%2][j][k+1] = dp[1-i%2][j][k];\n\t\t\t\t\tdp[i%2][1][0] += dp[1-i%2][j][k];\n\t\t\t\t}\n\t\t\t\tdp[i%2][1][0] %= Mod;\n\t\t\t}\n\t\t\tfor (j = 0; j <= B - A - 2; j++) {\n\t\t\t\tdp[i%2][j+1][A] = (dp[i%2][j+1][A] + dp[1-i%2][j][A]) % Mod;\n\t\t\t\tdp[i%2][j+A+1][0] = (dp[i%2][j+A+1][0] + dp[1-i%2][j][A]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint A,B;\nint f[5010][5010];\nint g[5010][5010];\nint sumg[5010];\nint sumg2[5010][5010];\nint F(int n,int x);\nint G(int n,int x);\nint SumG(int n);\nint SumG2(int n,int x);\nint F(int n,int x)\n{\n\tif(n<=0||x<0)return 0;\n\tif(f[n][x]!=-1)\n\t\treturn f[n][x];\n\tf[n][x]=(SumG(n-1)-SumG(n-B)+Mod)%Mod;\n\tif(x>=B)f[n][x]=(f[n][x]+SumG2(n-B,x-B))%Mod;\n\treturn f[n][x];\n}\nint G(int n,int x)\n{\n\tif(n<0||x<0)return 0;\n\tif(n==0)return 1;\n\tif(g[n][x]!=-1)\n\t\treturn g[n][x];\n\treturn g[n][x]=(G(n-1,x-1)+F(n-1,x-1))%Mod;\n}\nint SumG(int n)\n{\n\tif(n<0)return 0;\n\tif(sumg[n]!=-1)\n\t\treturn sumg[n];\n\treturn sumg[n]=(SumG(n-1)+G(n,A-1))%Mod;\n}\nint SumG2(int n,int x)\n{\n\tif(n<0||x<0)return 0;\n\tif(sumg2[n][x]!=-1)\n\t\treturn sumg2[n][x];\n\treturn sumg2[n][x]=(SumG2(n-1,x-1)+G(n,x))%Mod;\n}\nint main()\n{\n\tmemset(f,-1,sizeof(f));\n\tmemset(g,-1,sizeof(g));\n\tmemset(sumg,-1,sizeof(sumg));\n\tmemset(sumg2,-1,sizeof(sumg2));\n\tint n;scanf(\"%d %d %d\",&n,&A,&B);\n\tif(A<B)swap(A,B);\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)\n\t\tans=ans*2ll%Mod;\n\tans=(ans-F(n,A-1)+Mod)%Mod;\n\tans=(ans-G(n,A-1)+Mod)%Mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nconst int X = 5010;\nmint f0[X][X];\nmint f1[X][X];\nmint p[X][X];\nmint q[X];\nmint r[X][X];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N,A,B; cin >> N >> A >> B;\n\tif(A>B) swap(A,B);\n\tf0[0][0] = f1[0][0] = 1;\n\trep(i,N+1) rep(j,i+1){\n\t\t{\n\t\t\tf1[i][j] += p[i][j]; p[i+1][j+1] += p[i][j];\n\t\t\tif(j == 0){\n\t\t\t\tf0[i][0] += q[i]; q[i+1] += q[i];\n\t\t\t}\n\t\t\tf0[i][j] += r[i][j]; r[i+1][j+1] += r[i][j];\n\t\t}\n\t\tif(i==N || j>=B) continue;\n\n\t\t// rep1(k,N-i) f1[i+k][j+k] += f0[i][j];\n\t\tp[i+1][j+1] += f0[i][j];\n\t\tp[N+1][j+N-i+1] -= f0[i][j];\n\n\t\t// for(int k=1;k<=min(N-i,A-1);k++) f0[i+k][0] += f1[i][j];\n\t\t// for(int k=A;k<=N-i;k++) f0[i+k][j+k] += f1[i][j];\n\n\t\tq[i+1] += f1[i][j];\n\t\tq[i+min(N-i,A-1)+1] -= f1[i][j];\n\n\t\tif(A <= N-i){\n\t\t\tr[i+A][j+A] += f1[i][j];\n\t\t\tr[N+1][j+N-i+1] -= f1[i][j];\n\t\t}\n\t}\n\tmint res = 0;\n\tV<mint> p2(X); rep(i,X) p2[i] = mint(2).pow(i);\n\trep1(i,N) for(int j=B;j<=N;j++){\n\t\tres += (f0[i][j]+f1[i][j]) * p2[max(N-i-1,0)];\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define MN 5010\n#define mod 1000000007\n\nint f[MN][MN][2], s[MN];\nint sum[MN][2], mi[MN];\n\nint inc(int a, int b) {return (a += b) >= mod ? a - mod : a;}\n\nint main()\n{\n\tint n, a, b; scanf(\"%d%d%d\", &n, &a, &b);\n\tif(a > b) std::swap(a, b);\n\tmi[0] = 1; for(int i = 1; i <= n; i++) mi[i] = mi[i - 1] * 2 % mod;\n\tf[0][0][0] = f[0][0][1] = s[0] = 1;\n\tsum[0][1] = 1;\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 0; j <= std::min(b, i); j++)\n\t\t{\n\t\t\tif(j == b)\n\t\t\t\tans = (ans + 1ll * mi[n - i] * (sum[i - j][0] + sum[i - j][1])) % mod;\n\t\t\telse\n\t\t\t{\n\t\t\t\tf[i][j][0] = sum[i - j][1];\n\t\t\t\tf[i][j][1] = sum[i - j][0];\n\t\t\t\ts[i] = inc(s[i], f[i][j][0]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = std::max(i - a + 1, 0); j < i; j++)\n\t\t\tf[i][0][1] = inc(f[i][0][1], s[j]);\n\t\tif(i - a >= 0)\n\t\t{\n\t\t\tfor(int j = 0; j <= i - a; j++)\n\t\t\t{\n\t\t\t\tif(j + a < b)\n\t\t\t\t\tf[i][j + a][1] = inc(f[i][j + a][1], f[i - a][j][0]);\n\t\t\t\telse \n\t\t\t\t\tans = (ans + 1ll * mi[n - i] * f[i - a][j][0]) % mod;\n\t\t\t\t\n\t\t\t\tsum[i - a - j][0] = inc(sum[i - a - j][0], f[i - a][j][0]);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tsum[i - j][1] = inc(sum[i - j][1], f[i][j][1]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n/*考虑检查一种方案是否合法\n倒推，相当于把A个0或B个1替换成任意数字\n假设 A<=B ，否则相当于初始全为1，然后交换A，B\n序列合法当且仅当把所有>=A的0连续段给替换为1后存在>=B的1连续段\n充分性就是存在>=B的1连续段后把这个段给全部赋值成0与左右两段0合并\n由于B>=A，所以新的0段也可以全部赋成1然后继续搞\n必要性就是如果不存在，那除了那些0段可以随便填以外无法进行任何操作，从而无解，逆否命题可知必要性成立\nf[i][j + i - k][0] = sigma f[k][j][1]\nj + i - k > B 的状态不转移 (=B的状态单独处理，直接对答案贡献)\n\nf[i][0][1] = sigma f[i - A + 1 ~ i][j][0] 长度不够\n\nf[i][j + i - k][1] = sigma f[k][j][0] k < i - A (k = i - A 单独处理，直接对答案贡献)\nj + i - k > B 的状态不转移 (=B的状态单独处理，直接对答案贡献)\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const nax = 3e5 + 10;\nconstexpr int mod = 1e9 + 7;//\nvoid plusle (int &a, int b) {\n    if (( a += b) >= mod ) a -= mod ;\n}\nvoid minun (int &a, int b) {\n    if ((a -= b) < 0) a += mod ;\n}\nint add (int a, int b) {\n    return (( a += b ) >= mod ) ? a - mod  : a;\n}\nint sub (int a, int b) {\n    return (( a -= b) < 0) ? a + mod : a;\n}\nint mul (int a, int b) {\n    return 1LL * a * b % mod;\n}\nint power (int a, int b) {\n    int res = 1;\n    for (; b > 0 ; b >>= 1 , a = mul(a, a))\n        if (b & 1) res = mul(res, a);\n    return res ;\n}\n\nint dp[nax];\nint a, b;\nint n;\nint f[nax];\nint pref[nax];\n\nint rec (int sz) {\n\n    if (sz == 0) return 1;\n    if (dp[sz] != -1) return dp[sz];\n    /// the number of different substring of this size\n\n    for (int i = 1 ; i < sz ; ++ i) f[i] = rec(i);\n    pref[0] = 1;\n\n    for (int i = 1 ; i < sz ; ++ i) {\n        pref[i] = add(pref[i - 1], f[i]);\n    }\n\n    dp[sz] = 1; /// all 0\n\n    for (int i = a ; i <= sz ; ++ i) {\n        int res = sz - i;\n        plusle(dp[sz], pref[res]);\n        if (sz == 4) {\n            fprintf(stderr, \"add %d\\n\", pref[res]);\n        }\n    }\n\n    for (int st = 2 ; st <= sz ; ++ st) {\n     //   if (st + a - 1 > sz) break; /// necessary\n        if (st - 1 < b) {\n            /// we cannot use 0 move on left\n            int to = st + a - 1;\n            if (to > sz) continue;\n            int first_one = min(to - 1, sz - b);\n            if (first_one < st) continue;\n            int l = sz - first_one;\n            int r = sz - st;\n            plusle(dp[sz], sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            if (sz == 4) {\n                fprintf(stderr, \"%d\\n\", st);\n                fprintf(stderr, \"%d %d\\n\", l, r);\n                fprintf(stderr, \"st - 1 < b add %d\\n\", sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            }\n        } else if (st - 1 >= b) {\n            /// if we apply b from both side\n            int last_one = sz - b;\n            int first_one = st;\n            int l = sz - last_one;\n            int r = sz - first_one;\n            if (first_one <= last_one ) {\n                plusle(dp[sz], sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            }\n\n            /// if we apply from left only\n            int to = min(sz, st + a - 1);\n            int from = max(st, a);\n            l = sz - to;\n            r = sz - from;\n            if (l <= r) {\n                fprintf(stderr, \"Add %d\\n\", sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n\n                plusle(dp[sz], sub(pref[r], l == 0 ? 0 : pref[l - 1]));\n            }\n        }\n    }\n\n    return dp[sz];\n}\n\n\n\n\nint main () {\n    scanf(\"%d %d %d\", &n, &a, &b);\n    swap(a, b);\n    memset(dp, -1, sizeof(dp));\n    rec(n);\n    for (int i = 1; i <= n ; ++ i) {\n        fprintf(stderr, \"i %d dp[i] %d\\n\", i, dp[i]);\n    }\n    printf(\"%d\\n\", rec(n));\n}\n/*\n    Good Luck\n        -Lucina\n*/\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define all(a) (a).begin(),(a).end()\n#define SZ(a) ((int)((a).size()))\n\ntypedef long long ll;\ntypedef long double lf;\n\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst lf pi=acosl(-1);\n/* Source code starts here */\n\nint n,a,b;\nconst int jt=1000000007;\nint dp[5005][5005][2],qzh1[5005],qzh2[5005][5005];\nvoid inline add(int &a,int b){a+=b;if(a>=jt)a-=jt;if(a<0)a+=jt;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a<b)swap(a,b);\n\tdp[0][0][1]=1;\n\tloop(i,n+1){\n\t\tif(i)add(qzh1[i],qzh1[i-1]);\n\t\tadd(dp[i][0][0],qzh1[i]);\n\t\tloop(j,i+1){\n\t\t\tif(i)add(qzh2[i-j][i],qzh2[i-j][i-1]);\n\t\t\tadd(dp[i][j][0],qzh2[i-j][i]);\n\t\t\tif(j==a){\n\t\t\t\tadd(dp[i][j][1],dp[i][j][0]);dp[i][j][0]=0;\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][0]);\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][1]);\n\t\t\tadd(qzh1[i+1],dp[i][j][1]);\n\t\t\tadd(qzh1[i+b],-dp[i][j][1]);\n\t\t\tif(j+b<=a)add(qzh2[i-j][i+b],dp[i][j][1]);\n\t\t\telse add(dp[i+b][a][1],dp[i][j][1]);\n\t\t}\n\t}\n\tadd(dp[n][a][1],dp[n][a][0]);\n\tprintf(\"%d\\n\",dp[n][a][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 5005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,a,b;\nint dp[MAXN][MAXN][2];\nint s[MAXN][MAXN],diag[MAXN][MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint get_sum(int l1,int r1,int l2,int r2)\n{\n    int x=s[r1][r2];\n    dec(x,s[l1-1][r2]);\n    dec(x,s[r1][l2-1]);\n    add(x,s[l1-1][l2-1]);\n    return x;\n}\nint get_diag(int x,int y)\n{\n    return diag[x][y];\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b) swap(a,b);\n    dp[0][0][1]=1; \n    diag[0][0]=1;\n    for(int j=0;j<=n;j++) s[0][j]=1;\n    for(int i=1;i<=n;i++)\n    {\n        dp[i][0][0]=get_sum(max(0,i-a+1),i-1,0,b-1);\n        for(int j=1;j<=n;j++)\n        {\n            dp[i][j][1]=dp[i-1][j-1][1];\n            add(dp[i][j][1],dp[i-1][j-1][0]);\n            if(i>=a&&j>=a) add(dp[i][j][0],get_diag(i-a,j-a));\n            if(j>=b) add(dp[i][j][0],get_sum(max(0,i-a+1),i-1,j,j));\n        }\n        for(int j=0;j<=n;j++)\n        {\n            s[i][j]=s[i-1][j];\n            add(s[i][j],dp[i][j][1]);\n            if(j) \n            {\n                add(s[i][j],s[i][j-1]);\n                dec(s[i][j],s[i-1][j-1]);\n            }\n            diag[i][j]=dp[i][j][1];\n            if(j) add(diag[i][j],diag[i-1][j-1]);\n        }\n    }\n    int ans=0;\n    for(int i=b;i<=n;i++) \n    {\n        add(ans,dp[n][i][0]);\n        add(ans,dp[n][i][1]);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[200020], invf[200020];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nll dp[2][5050];\nll dp2[2][5050];\nll c[5050];\nint main()\n{\n    int n, a, b;\n    cin>>n>>a>>b;\n    if(a>b) swap(a, b);\n    fac(n+1);\n    dp2[0][0]=1;\n    for(int i=1; i<=n+2; i++){\n        for(int j=a; j<=i; j++){\n            if(i-j>=0){\n                (dp2[0][i]+=dp2[1][i-j])%=MOD;\n            }\n        }\n        for(int j=1; j<=i; j++){\n            if(i-j>=0){\n                (dp2[1][i]+=dp2[0][i-j])%=MOD;\n            }\n        }\n    }\n    dp[0][0]=1;\n    for(int i=1; i<=n+2; i++){\n        for(int j=1; j<a; j++){\n            if(i-j>=0){\n                (dp[0][i]+=dp[1][i-j])%=MOD;\n            }\n        }\n        for(int j=1; j<=b; j++){\n            if(i-j>=0){\n                if(j==b){\n                    if(i-j!=0 && i!=n+2) continue;\n                }\n                (dp[1][i]+=dp[0][i-j]*dp2[1][j])%=MOD;\n            }\n        }\n    }\n    cout<<(powmod(2, n)-dp[1][n+2]+MOD)%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val*m.val%MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 5e3 + 5;\nmi dp[MAX][MAX][2]; // have i placed a big 0 stuff\nmi prefix[MAX][2*MAX][2]; // sum for up to i, difference is j, last is last\nmi sum[MAX][2];\nint a, b;\nmi prefix_sum(int l, int r, int diff, int last){\n    if(l > r) return 0;\n    if(l <= 0) return prefix[r][diff][last];\n    return prefix[r][diff][last] - prefix[l - 1][diff][last];\n}\nmi sum_sum(int l, int r, int last){\n    if(l <= 0) return sum[r][last];\n    return sum[r][last] - sum[l - 1][last];\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n; cin >> n >> a >> b;\n    if(a<b) swap(a, b);\n    sum[0][1] = 1;\n    sum[0][0] = 1;\n    prefix[0][MAX][0] = 1;\n    prefix[0][MAX][1] = 1;\n    for(int i = 1; i <= n; i++){\n        for(int last = 0; last < 2; last++){\n            sum[i][last] = sum[i - 1][last];\n        }\n        for(int j = 0; j < 2 * MAX; j++){\n            for(int last = 0; last < 2; last++){\n                prefix[i][j][last] = prefix[i - 1][j][last];\n            }\n        }\n        for(int j = 0; j < a; j++){\n            for(int last = 0; last < 2; last ++){\n                if(last == 0){\n                    dp[i][j][last] = prefix_sum(i - min(a - 1, j), i - 1, i - j + MAX, last ^ 1);\n                }\n                else{\n                    if(j == 0){\n                        dp[i][j][last] = sum_sum(i - b + 1, i - 1, last ^ 1);\n                    }\n                    else{\n                        dp[i][j][last] = prefix_sum(i - min(a - 1, j), i - b, i - j + MAX, last ^ 1);\n                    }\n                }\n                sum[i][last] += dp[i][j][last];\n                prefix[i][i - j + MAX][last] += dp[i][j][last];\n            }\n        }\n    }\n    mi ans = 1;\n    for(int i = 0; i < n; i++) ans *= 2;\n    mi sub = 0;\n    for(int j = 0; j < a; j++){\n        for(int last = 0; last < 2; last++){\n            sub += dp[n][j][last];\n        }\n    }\n    ans -= sub;\n    cout << ans.val << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver2 {\n public:\n  int n, a, b;\n  vector<vector<vector<Modint<>>>> dp;\n  Solver2(int n, int a, int b) : n(n), a(a), b(b), dp(max(100, n + 1), vector<vector<Modint<>>>(max(100, n + 1), vector<Modint<>>(2))){};\n\n  void solve() {\n    if (a < b) swap(a, b);\n    dp[0][0][0] = Modint<>(1);\n    dp[2][1][0] = Modint<>(-1);\n    auto ans = Modint<>(0);\n    for (int i = 0; i <= n; ++i) {\n      DBG(i, dp[i])\n      if (i > 0) dp[i][1][0] += dp[i - 1][1][0];\n      DBG(i, dp[i])\n      for (int j = 0; j < a; ++j) {\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] += dp[i][j][0];\n        if (i + 2 <= n) dp[i + 2][1][0] += dp[i][j][0];\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] -= dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] += dp[i][j][1];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][1];\n      }\n      for (int j = a; j <= n; ++j) {\n        ans += (dp[i][j][0] + dp[i][j][1]) * Modint<>(2).mpow(n - i);\n      }\n      DBG(i, dp[i])\n      if (i < n) DBG(i, dp[i + 1])\n      DBG(ans)\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, a, b;\n  std::cin >> n >> a >> b;\n\n  Problem::Solver2 sol(n, a, b);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 5007, MOD = 1000 * 1000 * 1000 + 7;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N][N][2], t1[N][N][2], t2[N][N][2];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (b < a)\n        swap(a, b);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int t = 0; t < 2; ++t) {\n            int to = i;\n            if (t == 0 && i < a)\n                to = 0;\n            dp[i][to][t] = 1;\n        }   \n    }   \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < b; ++j) {\n            for (int t = 0; t < 2; ++t) {\n\n                add(t1[i][j][t], t1[i - 1][j][t]);\n                add(dp[i][j][t], t1[i][j][t]);\n                if (i && j) {\n                    add(t2[i][j][t], t2[i - 1][j - 1][t]);\n                }\n                add(dp[i][j][t], t2[i][j][t]);\n                int x = dp[i][j][t];\n\n                if (t) {\n                    if (1 < a) {\n                        add(t1[i + 1][0][t^1], x);\n                        if (i + a <= n) {\n                            add(t1[i + a][0][t^1], -x);\n                        }\n                    }\n                    if (a < b - j) {\n                        if (i + a <= n && j + a <= n) {\n                            add(t2[i + a][j + a][t^1], x);\n                        }\n                        if (i + b - j <= n && j + b - j <= n) {\n                            add(t2[i + b - j][j + b - j][t^1], -x);                            \n                        }   \n                    }   \n                    /*\n                    for (int k = a; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);\n                    */\n                }   \n                else {\n                    for (int k = 1; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);                        \n                }   \n            }   \n        }   \n    }   \n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) \n        ans = (ans << 1) % MOD;\n    for (int i = 0; i < b; ++i)\n        for (int t = 0; t < 2; ++t)\n            ans = mod(ans - dp[n][i][t]);\n    cout << ans << endl;            \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing ll = long long int;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll sp1[5050][5050],sp[5050],dp[5050][5050][2];\n\nint main(void){\n\tint n,a,b,i,j,k;\n\tll ans = 0ll, tmp;\n\tstd::cin >> n >> a >> b;\n\t/*\n\tif(a==b){\n\t\tdp[0][0][0] = 1ll;\n\t\tans = 1ll;\n\t\tfor(i=0; i<n; ++i){\n\t\t\tmul_mod(ans,2ll);\n\t\t\tfor(j=0; j<a; ++j){\n\t\t\t\tfor(k=0; k<2; ++k){\n\t\t\t\t\tadd_mod(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\t\tadd_mod(dp[i+1][1][k^1],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0; i<a; ++i){\n\t\t\tadd_mod(ans,MOD-dp[n][i][0]);\n\t\t\tadd_mod(ans,MOD-dp[n][i][1]);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\t*/\n\tif(a>b){\n\t\tstd::swap(a,b);\n\t}\n\t// std::fill(dp[0][0],dp[5050][0],0ll);\n\tn += 2;\n\tsp[1] = 1ll;\n\tfor(i=1; i<n; ++i){\n\t\tfor(j=0; j<n; ++j){\n\t\t\tadd_mod(sp1[i+1][j+1],sp1[i][j]);\n\t\t}\n\t\tfor(j=a; j<n; ++j){\n\t\t\tadd_mod(sp[i+1],sp1[i][j]);\n\t\t}\n\t\tadd_mod(sp[i+1],sp[i]);\n\t\tadd_mod(sp1[i+1][1],sp[i]);\n\t}\n\tfor(i=1; i<=n; ++i){\n\t\tadd_mod(dp[i][0][i>b],sp[i]);\n\t}\n\tfor(i=0; i<n; ++i){\n\t\tfor(k=0; k<2; ++k){\n\t\t\ttmp = 0ll;\n\t\t\tfor(j=0; j<a; ++j){\n\t\t\t\tadd_mod(dp[i+1][j+1][k],dp[i][j][k]);\n\t\t\t\tif(j){\n\t\t\t\t\tadd_mod(tmp,dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1; i+j<n; ++j){\n\t\t\t\tadd_mod(dp[i+j][0][k||j>=b],tmp*sp[j]%MOD);\n\t\t\t}\n\t\t\tadd_mod(dp[n][0][k||n-i>b],tmp*sp[n-i]%MOD);\n\t\t}\n\t}\n\tstd::cout << dp[n][0][1] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=5e3+10,mod=1e9+7;\nll dp[N][N][2];\nll par[N][N][2];\nll pd[N];\nint32_t main(){\n    ll n,a,b;\n    cin >> n >> a >> b;\n    if (a>b) swap(a,b);\n    ll ans=1;\n    for (int i=1;i<=n;i++){\n        ans*=2;\n        ans%=mod;\n    }\n    dp[0][0][0]=1;\n    dp[0][0][1]=1;\n    par[0][0][1]=1;\n    par[0][0][0]=1;\n    pd[0]=1;\n    /// par[i][j] ehtelaf i ta andis j\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<min(i+1,b);j++){\n            for (int p=0;p<=1;p++){\n                if (p==0){\n                    if (j<a) continue;\n                    dp[i][j][0]=par[i-j][i-a][1];\n                }\n                else{\n                    dp[i][j][1]=par[i-j][i-1][0];\n                }\n                dp[i][j][p]%=mod;\n             //   cout << i << \" \" << j << \" \" << p << \" \" << dp[i][j][p] << endl;;\n            }\n        }\n        for (int j=i-1;j>max((ll)-1,i-a);j--){\n            dp[i][0][0]+=pd[j];\n            dp[i][0][0]%=mod;\n        }\n        for (int j=1;j<b;j++){\n            pd[i]+=dp[i][j][1];\n            pd[i]%=mod;\n        }\n        for (int j=0;j<min(i+1,b);j++){\n            par[i-j][i][0]=par[i-j][i-1][0]+dp[i][j][0];\n            par[i-j][i][1]=par[i-j][i-1][1]+dp[i][j][1];\n            par[i-j][i][0]%=mod;\n            par[i-j][i][1]%=mod;\n        }\n    }\n    for (int i=0;i<b;i++){\n        ans-=dp[n][i][0]+dp[n][i][1];\n        ans+=mod*2;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 200\n#define LN 63\n#define ull unsigned long long\nusing namespace std;\nint n;ull a[N+5],v[LN+5];char op[N+5];\nI void Clear() {for(RI i=LN;~i;--i) v[i]=0;}\nI void Ins(ull x)\n{\n\tfor(RI i=LN;~i;--i) if((x>>i)&1) {if(!v[i]) return (void)(v[i]=x);x^=v[i];}\n}\nI bool Q(ull x)\n{\n\tfor(RI i=LN;~i;--i) if((x>>i)&1) {if(!v[i]) return 0;x^=v[i];}return 1;\n}\nint main()\n{\n\tRI Tt,i,ans;scanf(\"%d\",&Tt);W(Tt--)\n\t{\n\t\tfor(Clear(),scanf(\"%d\",&n),i=1;i<=n;++i) scanf(\"%llu\",a+i);\n\t\tfor(scanf(\"%s\",op+1),ans=1,i=n;i;--i)\n\t\t\tif(op[i]=='1') {if(!Q(a[i])) {ans=0;break;}}else Ins(a[i]);\n\t\tputchar(49-ans),putchar('\\n');\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5005;\nconst int md = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n  if (x < 0) {\n    x += md;\n  }\n  return x;\n}\n\ninline void sadd(int &x, int y) { x = add(x, y); }\n\nint dp[2][N][N];\nint pref[2][N][N];\nint sum[2][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, A, B;\n  cin >> n >> A >> B;\n  if (A > B) swap(A, B);\n  dp[0][0][0] = dp[1][0][0] = 1;\n  pref[0][0][0] = pref[1][0][0] = 1;\n  sum[0][0] = sum[1][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    sum[0][i] = sum[0][i - 1];\n    sum[1][i] = sum[1][i - 1];\n    for (int j = 0; j < min(i + 1, B); j++) {\n      if (j >= A) {\n        dp[0][i][j] = pref[1][i - j][i - A];\n      }\n      if (j == 0) {\n        dp[0][i][j] = add(sum[1][i - 1], i >= A ? -sum[1][i - A] : 0);\n      }\n      dp[1][i][j] = pref[0][i - j][i - 1];\n      sadd(sum[0][i], dp[0][i][j]);\n      sadd(sum[1][i], dp[1][i][j]);\n    }\n    for (int t : {0, 1}) {\n      for (int d = 0; d <= i; d++) {\n        pref[t][d][i] = add(pref[t][d][i - 1], dp[t][i][i - d]);\n      }\n    }\n  }\n  int res = 1;\n  for (int i = 0; i < n; i++) {\n    sadd(res, res);\n  }\n  for (int r = 0; r < B; r++) {\n    sadd(res, -dp[0][n][r]);\n    sadd(res, -dp[1][n][r]);\n  }\n  cout << res << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst ll MOD=1e9+7;\nvoid add(ll& lhs,ll rhs){\n    lhs=(lhs+rhs)%MOD;\n}\nint main(){\n    int n,a,b;\n    cin>>n>>a>>b;\n    if(b<a) swap(a,b);\n    if(a==1 || b==1){\n        ll res = 1;\n        for(int i=0;i<n;i++){\n            res=res*2%MOD;\n        }\n        cout<<res<<endl;\n        return 0;\n    }\n    vector<vector<ll>> Adp(n+1,vector<ll>(b));\n    vector<vector<ll>> Bdp(n+1,vector<ll>(b));\n    vector<vector<ll>> Cdp(n+1,vector<ll>(b));\n    vector<ll> ok(n+1);\n    Adp[0][0] = 1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<a;j++){\n            if(j+1<a){\n                add(Adp[i+1][j+1],Adp[i][j]);\n            }\n            add(Bdp[i+1][1],Adp[i][j]);\n            if(i==0 && j==0){\n                if(a==b){\n                    add(ok[i+a],Adp[i][0]);\n                }\n                else{\n                    add(Cdp[i+a][a],Adp[i][0]);\n                }\n            }\n        }\n        for(int j=0;j<b;j++){\n            add(Adp[i+1][1],Bdp[i][j]);\n            if(j+1<b){\n                add(Bdp[i+1][j+1],Bdp[i][j]);\n            }\n            else{\n                add(ok[i+1],Bdp[i][j]);\n            }\n            if(i+a<=n){\n                if(j+a<b){\n                    add(Cdp[i+a][j+a],Bdp[i][j]);\n                }\n                else{\n                    add(ok[i+a],Bdp[i][j]);\n                }\n            }\n        }        \n        for(int j=0;j<b;j++){\n            if(j+1<b){\n                add(Bdp[i+1][j+1],Cdp[i][j]);\n                add(Cdp[i+1][j+1],Cdp[i][j]);\n            }\n            else{\n                add(ok[i+1],Cdp[i][j]);\n                add(ok[i+1],Cdp[i][j]);\n            }\n        }\n        add(ok[i+1],ok[i]);\n        add(ok[i+1],ok[i]);\n    }\n\n    cout<<ok[n]<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 5007, MOD = 1000 * 1000 * 1000 + 7;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N][N][2], t1[N][N][2];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (b < a)\n        swap(a, b);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int t = 0; t < 2; ++t) {\n            int to = i;\n            if (t == 0 && i < a)\n                to = 0;\n            dp[i][to][t] = 1;\n        }   \n    }   \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < b; ++j) {\n            for (int t = 0; t < 2; ++t) {\n\n                add(t1[i][j][t], t1[i - 1][j][t]);\n                add(dp[i][j][t], t1[i][j][t]);\n                int x = dp[i][j][t];\n\n                if (t) {\n                    if (1 < a) {\n                        add(t1[i + 1][0][t^1], x);\n                        if (i + a <= n) {\n                            add(t1[i + a][0][t^1], -x);\n                        }\n                    }\n                      \n                    /*\n                    for (int k = 1; k < a; ++k)\n                        add(dp[i + k][0][t^1], x);\n                    */\n\n                    for (int k = a; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);\n                }   \n                else {\n                    for (int k = 1; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);                        \n                }   \n            }   \n        }   \n    }   \n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) \n        ans = (ans << 1) % MOD;\n    for (int i = 0; i < b; ++i)\n        for (int t = 0; t < 2; ++t)\n            ans = mod(ans - dp[n][i][t]);\n    cout << ans << endl;            \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll, ll> P;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VI = vector<ll>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\nconst int inf = 1e9 + 7;\nconst ll INF = 1LL << 61;\nconst ll mod = 1e9 + 7;\n\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvector<ll> inv, fact, invfact;\nvoid Mod_build(int n = 101010) {\n    fact.resize(n + 1);\n    inv.resize(n + 1);\n    invfact.resize(n + 1);\n    fact[0] = inv[0] = invfact[0] = 1;\n    inv[1] = 1;\n    for (ll i = 0; i < n; i++) {\n        fact[i + 1] = fact[i] * (i + 1) % mod;\n        if (i > 0) inv[i + 1] = mod - inv[mod % (i + 1)] * (mod / (i + 1)) % mod;\n        invfact[i + 1] = invfact[i] * inv[i + 1] % mod;\n    }\n}\nll perm(int n, int k) {\n    if (n < 0 || k < 0 || k > n) return 0;\n    return fact[n] * invfact[n - k] % mod;\n}\nll comb(int n, int k) {\n    if (n < 0 || k < 0 || k > n) return 0;\n    return (fact[n] * invfact[n - k] % mod) * invfact[k] % mod;\n}\nll powmod(ll n, ll k) {\n    k %= mod - 1;\n    if (k < 0) k += mod - 1;\n    ll ret = 1;\n    while (k) {\n        if (k & 1) ret = ret * n % mod;\n        n = n * n % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nll modinv(ll a) {\n    ll m = mod;\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\nint main() {\n    Mod_build();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int i, j;\n    ll n, a, b;\n    cin >> n >> a >> b;\n    if (a < b) swap(a, b);\n    if (b == 1) {\n        cout << powmod(2, n) << endl;\n        return 0;\n    }\n    VI bb(n + 3, 0);\n    VI aa(n + 3, 0);\n    for (i = 1; i <= b + 1; i++) bb[i] = i;\n    for (i = b + 2; i <= n + 2; i++) {\n        bb[i] = 1 + bb[i - 1] + bb[i - 1 - b];\n        bb[i] %= mod;\n    }\n    for (i = n + 2; i >= 1; i--) {\n        aa[i] = mod + bb[i] - bb[i - 1];\n        aa[i] %= mod;\n    }\n\n    VVI dp1(n + 1, VI(a, 0));\n    VVI dp2(n + 1, VI(b, 0));\n    VVI dp3(n + 1, VI(a, 0));\n    ll ans = 0;\n    for (i = 0; i < n; i++) {\n        if (i == 0) {\n            // dp1[i][1] = 1;\n            dp2[i][1] = 1;\n            dp3[i][1] = 1;\n        } else {\n            for (j = 1; j < a; j++) {\n                dp2[i][1] += dp1[i - 1][j] * aa[j];\n                dp2[i][1] %= mod;\n                dp2[i][1] += dp3[i - 1][j] * aa[j + 1];\n                dp2[i][1] %= mod;\n            }\n            for (j = 1; j < b; j++) {\n                dp1[i][1] += dp2[i - 1][j];\n                dp1[i][1] %= mod;\n            }\n            for (j = a - 1; j >= 2; j--) {\n                dp1[i][j] = dp1[i - 1][j - 1];\n                dp3[i][j] = dp3[i - 1][j - 1];\n            }\n            for (j = b - 1; j >= 2; j--) dp2[i][j] = dp2[i - 1][j - 1];\n        }\n    }\n    for (j = 1; j < a; j++) {\n        ans += dp1[n - 1][j] * aa[j + 1];\n        ans %= mod;\n        ans += dp3[n - 1][j] * aa[j + 2];\n        ans %= mod;\n    }\n    for (j = 1; j < b; j++) {\n        ans += dp2[n - 1][j];\n        ans %= mod;\n    }\n    cout << (powmod(2, n) + mod - ans) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1000 + 10;\ntypedef long long LL;\nconst LL MOD = 1e9 + 7;\nint n, A, B;\nLL f[N][N][2];\nLL g[N][N][2], w[N][2];\nvoid add(LL & x, LL y) {\n\tx += y;\n\tif (x > MOD) x -= MOD;\n}\nint main() {\n\tcin >> n >> A >> B;\n\tif (A < B) swap(A, B);\n\tLL tot = 1;\n\tfor (int i = 1; i <= n; i ++) tot = tot * 2 % MOD;\n\t\n\tf[0][0][0] = 1; g[0][0][0] = 1; w[0][0] = 1;\n\tf[0][0][1] = 1; g[0][0][1] = 1; w[0][1] = 1;\n\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j < A; j ++) {\n\t\t\t/*\n\t\t\tfor (int t = 1; t <= min(j, i); t ++) {\n\t\t\t\t// printf(\"(%d,%d,%d) -> (%d,%d,%d)\\n\", i-t,j-t,1,i,j,0);\n\t\t\t\tadd(f[i][j][0], f[i-t][j-t][1]);\n\t\t\t}\n\t\t\t*/\n\t\t\tif (i>=1 && j>=1) {\n\t\t\t\tadd(f[i][j][0], g[i-1][j-1][1]);\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (int t = B; t <= min(j, i); t ++) {\n\t\t\t\t// printf(\"(%d,%d,%d) -> (%d,%d,%d)\\n\", i-t,j-t,0,i,j,1);\n\t\t\t\tadd(f[i][j][1], f[i-t][j-t][0]);\n\t\t\t}\n\t\t\t*/\n\t\t\tif (i-B>=0 && j-B>=0) {\n\t\t\t\tadd(f[i][j][1], g[i-B][j-B][0]);\n\t\t\t}\n\t\t\t// printf(\"f[%d][%d] = {%lld, %lld}\\n\", i, j, f[i][j][0], f[i][j][1]);\n\t\t}\n\t\tfor (int t = 1; t <= min(i, B - 1); t ++) {\n\t\t\t/*\n\t\t\tfor (int s = 0; s < A; s ++){\n\t\t\t\t// printf(\"(%d,%d,%d) -> (%d,%d,%d)\\n\", i-t,s,0,i,0,1);\n\t\t\t\tadd(f[i][0][1], f[i-t][s][0]);\n\t\t\t}\n\t\t\t*/\n\t\t\tadd(f[i][0][1], w[i-t][0]);\n\t\t}\n\t\tg[i][0][1] = f[i][0][1];\n\t\tfor (int j = 1; j < A; j ++) {\n\t\t\tg[i][j][0]=(g[i-1][j-1][0]+f[i][j][0])%MOD;\n\t\t\tg[i][j][1]=(g[i-1][j-1][1]+f[i][j][1])%MOD;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < A; j ++) {\n\t\t\tadd(w[i][0], f[i][j][0]);\n\t\t\tadd(w[i][1], f[i][j][1]);\n\t\t}\n\t}\n\tfor (int j = 0; j < A; j ++) {\n\t\tfor (int k = 0; k < 2; k ++) {\n\t\t\ttot = tot - f[n][j][k];\n\t\t\ttot = (tot % MOD + MOD)\t% MOD;\t\n\t\t}\n\t}\n\tcout << tot << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n#include <functional>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept {\n        lint v;\n        is >> v;\n        x = v;\n        return is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class T>\nstruct SegmentTree {\n    using Merger = std::function<T(T, T)>;\n\n    int length;\n    std::vector<T> dat;\n    T unit;\n    Merger merge;\n\n    SegmentTree() = default;\n\n    SegmentTree(int n, const T& unit, const Merger& merge)\n        : length(1), unit(unit), merge(merge) {\n        while (length < n) length <<= 1;\n        dat.assign(length * 2, unit);\n    }\n\n    template <class Container>\n    SegmentTree(const Container& elems, const T& unit, const Merger& merge)\n        : length(1), unit(unit), merge(merge) {\n        int n = elems.size();\n        while (length < n) length <<= 1;\n\n        dat.assign(length * 2, unit);\n\n        std::copy(elems.begin(), elems.end(), dat.begin() + length);\n\n        for (int nidx = length - 1; nidx >= 1; --nidx) {\n            T vl = dat[nidx * 2 + 0];\n            T vr = dat[nidx * 2 + 1];\n            dat[nidx] = merge(vl, vr);\n        }\n    }\n\n    void update(int nidx, const T& elem) {\n        nidx += length;\n        dat[nidx] = elem;\n\n        while (nidx > 0) {\n            nidx >>= 1;\n            T vl = dat[nidx * 2 + 0];\n            T vr = dat[nidx * 2 + 1];\n            dat[nidx] = merge(vl, vr);\n        }\n    }\n\n    T fold(int ql, int qr) const {\n        ql = std::max(ql, 0);\n        qr = std::min(qr, length);\n        ql += length, qr += length;\n\n        T lacc = unit, racc = unit;\n        while (ql < qr) {\n            if (ql & 1) {\n                lacc = merge(lacc, dat[ql]);\n                ++ql;\n            }\n            if (qr & 1) {\n                --qr;\n                racc = merge(dat[qr], racc);\n            }\n            ql >>= 1, qr >>= 1;\n        }\n\n        return merge(lacc, racc);\n    }\n\n    T get(int idx) const { return dat[idx + length]; }\n    T fold_all() const { return dat[1]; }\n};\n\nconstexpr int MOD = 1000000007;\nusing mint = ModInt<MOD>;\n\nvoid solve() {\n    int n, a, b;\n    std::cin >> n >> a >> b;\n\n    if (a > b) std::swap(a, b);\n    // a <= b\n\n    // the previous digit\n    // index\n    // the number of continuous 1s\n    auto dp = vec(2, vec(n + 1, vec(b, mint(0))));\n    dp[1][0][0] = 1;\n\n    // the previous digit is 1\n    SegmentTree<mint> seg(n + 1, 0, [](auto a, auto b) { return a + b; });\n    seg.update(0, 1);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int o = 1; o < b; ++o) {\n            // put 1\n            for (int zp = 0; zp < 2; ++zp) {\n                dp[1][i][o] += dp[zp][i - 1][o - 1];\n            }\n        }\n\n        // put short 0s after 1\n        dp[0][i][0] = seg.fold(i - a + 1, i);\n\n        // put a 0s after 1\n        if (i >= a) {\n            for (int po = 0; po + a < b; ++po) {\n                dp[0][i][po + a] += dp[1][i - a][po];\n            }\n        }\n\n        for (int o = a + 1; o < b; ++o) {\n            // put 0 after long 0s\n            dp[0][i][o] += dp[0][i - 1][o - 1];\n        }\n\n        mint sum = 0;\n        for (auto x : dp[1][i]) sum += x;\n        seg.update(i, sum);\n    }\n\n    mint out = 0;\n    for (int zp = 0; zp < 2; ++zp) {\n        for (auto x : dp[zp][n]) out += x;\n    }\n\n    std::cout << mint(2).pow(n) - out << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}\n\nll dp[5005][5005][2][2];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,A,B;\n  cin>>N>>A>>B;\n\n  if(A>B) swap(A,B);\n\n  dp[0][0][1][0]=1;\n  for(int i=0;i<N;i++) for(int j=0;j<B;j++){\n    rep(k,2) rep(m,2){\n      if(dp[i][j][k][m]==0) continue;\n\n      ll pre=dp[i][j][k][m];\n      if(k==1&&i+A<=N){\n        if(j+A<B) add(dp[i+A][j+A][0][1],pre);\n        add(dp[i+A][0][0][0],MOD-pre);\n      }\n\n      for(int ne=0;ne<2;ne++){\n        int nj=j,nk=ne,nm=m;\n        if(ne==1||(m==1&&ne==0)) nj=j+1;\n        if(ne==0&&m==0) nj=0;\n        if(ne==1&&m==1) nm=0;\n        add(dp[i+1][nj][nk][nm],pre);\n      }\n    }\n  }\n\n  ll ans=1;\n  rep(k,N) mul(ans,2);\n  rep(j,B) rep(k,2) rep(m,2) add(ans,MOD-dp[N][j][k][m]);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint M(int x) { return x >= mod ? x - mod : x; }\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getchar();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getchar();\n    }\n    return x * f;\n}\nint n, A, B;\nint f[5003][5003], g[5003][5003];\nint pf[10004][5003], pg[10004][5003];\n\nint S(int *p, int l, int r) { return M(p[r] - (l > 0 ? p[l - 1] : 0) + mod); }\n\nint main() {\n    n = read(), A = read(), B = read();\n    if (A > B) swap(A, B);\n    int res = 1;\n    for (int i = 1; i <= n; ++i) res = M(res << 1);\n    if (A == 1) return printf(\"%d\\n\", res), 0;\n\n    for (int i = 1; i <= B; ++i)\n        f[0][i] = pf[i + n][0] = g[0][i] = pg[i + n][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        int s = 0;\n        for (int x = 1; x <= min(A - 1, i); ++x) Add(s, g[i - x][B]);\n        for (int j = 1; j <= B; ++j) {\n            f[i][j] = pf[j - i + n][i] = M(s + S(pg[j - i + n], i - j, i - A));\n            g[i][j] = pg[j - i + n][i] = S(pf[j - i + n], i - j, i - 1);\n        }\n        // cerr << \"##\" << i << endl;\n        // for (int j = 1; j <= B; ++j) cerr << f[i][j] << ' ';\n        // cerr << endl;\n        // for (int j = 1; j <= B; ++j) cerr << g[i][j] << ' ';\n        // cerr << endl;\n\n        for (int j = 1; j <= B + n; ++j)\n            Add(pf[j][i], pf[j][i - 1]), Add(pg[j][i], pg[j][i - 1]);\n    }\n    printf(\"%d\\n\", M(res + mod - M(g[n][B] + f[n][B])));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  int n = (*this).size();\n  P operator-() const {\n    P res(n);\n    rep(i, n) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, n) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, n) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, n) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, n) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, n) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q={{0, 1}, {1, -1}}) {\n    rep(i, n) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div();\n  q[1] = 1;\n  q.div();\n  f[1] = 1;\n  f[a] -= 1;\n  f.div();\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+1) g0[i] = 0;\n  rep2(i, b, n+1) g1[i] = 0;\n  rep2(i, b, n+1) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define all(a) (a).begin(),(a).end()\n#define SZ(a) ((int)((a).size()))\n\ntypedef long long ll;\ntypedef long double lf;\n\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst lf pi=acosl(-1);\n/* Source code starts here */\n\nint n,a,b;\nconst int jt=1000000007;\nint dp[5005][5005][2],qzh1[5005],qzh2[5005][5005];\nvoid inline add(int &a,int b){a+=b;if(a>=jt)a-=jt;if(a<0)a+=jt;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a<b)swap(a,b);\n\tdp[0][0][1]=1;\n\tloop(i,n+1){\n\t\tif(i)add(qzh1[i],qzh1[i-1]);\n\t\tadd(dp[i][0][0],qzh1[i]);\n\t\tloop(j,i+1){\n\t\t\tif(i)add(qzh2[i-j][i],qzh2[i-j][i-1]);\n\t\t\tadd(dp[i][j][0],qzh2[i-j][i]);\n\t\t\tif(j==a){\n\t\t\t\tadd(dp[i][j][1],dp[i][j][0]);dp[i][j][0]=0;\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][0]);\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][1]);\n\t\t\tadd(qzh1[i+1],dp[i][j][1]);\n\t\t\tif(i+b<=n){\n\t\t\t\tadd(qzh1[i+b],-dp[i][j][1]);\n\t\t\t\tif(j+b<=a)add(qzh2[i-j][i+b],dp[i][j][1]);\n\t\t\t\telse add(dp[i+b][a][1],dp[i][j][1]);\n\t\t\t}\n\t\t}\n\t}\n\tadd(dp[n][a][1],dp[n][a][0]);\n\tprintf(\"%d\\n\",dp[n][a][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nMint x[5005][5005],ans,s[5005],pw[5005];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx[0][0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=pw[i-1]*2;\n\tfor(int l=0;l<=n;l++){\n\t\tfor(int j=0;j+l<=n;j++)s[j]=0;\n\t\tfor(int j=0;j+l<=n;j++){\n\t\t\tif(j>=a){\n\t\t\t\tans+=x[l][j]*pw[n-(l+j)];\n\t\t\t\tx[l][j]=0;\n\t\t\t}\n\t\t\tif(j==a){\n\t\t\t\tfor(int k=b;k<=l+j;k++){\n\t\t\t\t\tans+=x[l][j-k]*pw[n-(l+j)];\n\t\t\t\t\tx[l][j-k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j>a){\n\t\t\t\tans+=x[l][j-b]*pw[n-(l+j)];\n\t\t\t\tx[l][j-b]=0;\n\t\t\t}\n\t\t\ts[j]+=x[l][j];\n\t\t\tif(j>0)s[j]+=s[j-1];\n\t\t\tif(j>0){\n\t\t\t\tx[l+j][1]+=s[j-1];\n\t\t\t\tif(j-b>=0)x[l+j][1]-=s[j-b];\n\t\t\t}\n\t\t\tif(j-b>=0&&j<a){\n\t\t\t\tx[l][j+1]+=s[j-b];\n\t\t\t}\n\t\t\tx[l][j+1]+=x[l][j];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define mem(a) (memset(a,0,sizeof(a)))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=5005,mod=1e9+7;\nint f[N][N],g[N][N],s[N][N],sum;\nint a[2];\ninline void add(int &a,int b){\n\ta+=b; if(a>=mod)a-=mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint n=read(),x=read(),y=read();\n\tif(x>y)swap(x,y);\n\tf[0][0]=1;\n\tFor(i,0,n){\n\t\tf[i][y]=g[i][y]=0;\n\t\tif(i>=x){\n\t\t\tFor(j,0,i)if(i>=x){\n\t\t\t\tg[i][j]=s[i-x][i-j];\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<s[i-x][i-j]<<\" \"<<sum<<endl;\n\t\t\t\tadd(sum,mod-f[i-x][j]);\n\t\t\t}\n\t\t}\n\t\tg[i][0]=sum;\n\t\tFor(j,0,min(i,y-1)){\n\t\t\t//cout<<f[i][j]<<\" \"<<g[i][j]<<\" \"<<i<<\" \"<<j<<\" \"<<endl;\n\t\t\tadd(f[i+1][j+1],g[i][j]);\n\t\t\tadd(f[i+1][j+1],f[i][j]);\n\t\t\tif(i)s[i][i-j]=s[i-1][i-j];\n\t\t\tadd(s[i][i-j],f[i][j]);\n\t\t\tadd(sum,f[i][j]);\n\t\t}\n\t}\n\tll ans=1;\n\tFor(i,1,n)ans=ans*2%mod;\n\tFor(i,0,y-1)ans=(ans-f[n][i]-g[n][i]+mod*2)%mod;\n\tcout<<ans<<endl;\n}\n/*\ndp[i][j]->dp[i+...][0]\n不妨令 1 全不满\n满的0全改为1 \n11111100111110011111\n...10011100010001\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD=1000000007;\n\nll n,a,b;\nll x[5002];\nvoid x_init(){\n\tll dp[5005][2]={};\n\tdp[1][0]=1;\n\tdp[1][1]=0;\n\tfor(int i=1;i<=a;i++){\n\t\tdp[i+1][0]+=dp[i][0];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tif(i+b<=a){\n\t\t\tdp[i+b][1]+=dp[i][0];\n\t\t\tif(dp[i+b][1]>=MOD)dp[i+b][1]-=MOD;\n\t\t}\n\t\tdp[i+1][0]+=dp[i][1];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tdp[i+1][1]+=dp[i][1];\n\t\tif(dp[i+1][1]>=MOD)dp[i+1][1]-=MOD;\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tx[i]=dp[i][0];\n\t\t//cout<<i<<\":\"<<x[i]<<endl;\n\t}\n}\n\nint main(){\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx_init();\n\t\n\tll dp[5002][2]={};\n\tfor(int i=1;i<=a-1;i++){\n\t\tdp[i][0]=x[i+1];\n\t}\n\tfor(int i=1;i<=b-1;i++){\n\t\tdp[i][1]=1;\n\t}\n\tfor(int i=1;i<=n-1;i++){\n\t\tfor(int j=1;j<=b-1;j++){\n\t\t\tif(i+j<=n){\n\t\t\t\tdp[i+j][1]+=dp[i][0];\n\t\t\t\tif(dp[i+j][1]>=MOD)dp[i+j][1]-=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=a-1;j++){\n\t\t\tif(i+j<n){\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t\telse if(i+j==n){\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j+1];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=1;\n\tfor(int i=0;i<n;i++){\n\t\tret*=2;\n\t\tret%=MOD;\n\t}\n\tret+=MOD-dp[n][0];\n\tret+=MOD-dp[n][1];\n\tcout<<ret%MOD<<endl;\n\t//cout<<(dp[n][0]+dp[n][1])%MOD<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 5005, MOD = 1e9 + 7;\nint dp[N][N][2], dp_add[N][N], dp_add_d[N][N];\n\nvoid add(int &a, int b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    if (a < 0)\n        a += MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (a < b)\n        swap(a, b);\n\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i >= j && i >= a) {\n                add(dp_add[i + 1][j], dp[i][j][0]);\n            }\n            else {\n                add(dp_add[i + b][j], dp[i][j][0]);\n\n                int lim = min(b - 1, n - i - a);\n\n                if (lim > 0) {\n                    add(dp_add_d[i + 1][i + 1 + a], dp[i][j][0]);\n                    add(dp_add_d[i + lim + 1][i + 1 + lim + a], -dp[i][j][0]);\n                }\n            }\n        }\n\n        for (int j = 0; j <= n; j++) {\n            add(dp_add[i + 1][j], dp_add[i][j]);\n            add(dp[i + 1][j][1], dp_add[i + 1][j]);\n\n            add(dp_add_d[i + 1][j + 1], dp_add_d[i][j]);\n            add(dp[i + 1][j + 1][1], dp_add_d[i + 1][j + 1]);\n\n            for (int k = 0; k < 2; k++) {\n                add(dp[i + 1][j][0], dp[i][j][k]);\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < 2; j++) {\n            add(ans, dp[n][i][j]);\n        }\n    }\n\n    cout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=5005;\nconst int mo=1000000007;\nint n,A,B,f[N][N],g[N][N],h[N*2];\nvoid F1(){\n\tf[1][1]=2;\n\tFor(i,1,n) For(j,1,A-1){\n\t\tf[i][j+1]=(f[i][j+1]+f[i-1][j])%mo;\n\t\tf[i][1]=(f[i][1]+f[i-1][j])%mo;\n\t}\n\tint ans=1;\n\tFor(i,1,n) ans=ans*2%mo;\n\tFor(j,1,A-1) ans=(ans+mo-f[n][j])%mo;\n\tcout<<ans<<endl;\n}\nvoid F2(){\n\tf[0][0]=1;\n\tFor(i,0,n+1){\n\t\tif (i) h[i]=(h[i]+h[i-1])%mo;\n\t\tf[i][1]=(f[i][1]+h[i])%mo;\n\t\tFor(j,0,B){\n\t\t\tif (i&&j) g[i][j]=(g[i][j]+g[i-1][j-1])%mo;\n\t\t\tf[i][j]=(f[i][j]+g[i][j])%mo;\n\t\t\tif (j==B) continue;\n\t\t\tf[i+1][j+1]=(f[i+1][j+1]+f[i][j])%mo;\n\t\t\th[i+2]=(h[i+2]+f[i][j])%mo;\n\t\t\th[i+A+1]=(h[i+A+1]+mo-f[i][j])%mo;\n\t\t\tif (i+A+1<=n+1&&j+A+1<=n)\n\t\t\tg[i+A+1][j+A+1]=(g[i+A+1][j+A+1]+f[i][j])%mo;\n\t\t}\n\t\t//cout<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=1;\n\tFor(i,1,n) ans=2*ans%mo;\n\tFor(j,1,B) ans=(ans+mo-f[n+1][j])%mo;\n\tcout<<ans<<endl;\n}\n/*\n11:2\n01:1\n*/\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif (A>B) swap(A,B);\n\tif (A==B) F1();\n\telse F2();\n}\n/*\n>_<\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define ld long double\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\ntemplate <typename T> using ord_set = tree <T, null_type, less <T>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 5005, MOD = 1e9 + 7;\nint n, a, b, dp[N][N], ps[N], p[N][N];\n\nvoid add(int & x, int y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\n\nint get(int l, int r, int k) {\n\tif (r < 0) return 0;\n\tif (k == -1)\n\t\treturn (ps[r] - ((l > 0) ? ps[l - 1] : 0) + MOD) % MOD;\n\treturn (p[r][k] - ((l > 0) ? p[l - 1][k] : 0) + MOD) % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n >> a >> b;\n\tif (a > b) swap(a, b);\n\tdp[0][0] = ps[0] = p[0][0] = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (min(n, i) - max(1, j) + 1 >= b) continue;\n\t\t\tadd(dp[i][j], dp[i - 1][j]);\n\t\t\tadd(dp[i][j], get(0, i - a - 1, j));\n\t\t}\n\t\tadd(dp[i][i], get(i - a, i - 2, -1));\n\t\tps[i] = ps[i - 1];\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tadd(ps[i], dp[i][j]);\n\t\t\tp[i][j] = p[i - 1][j];\n\t\t\tadd(p[i][j], dp[i][j]);\n\t\t}\n\t}\n\tint res = 0, pw = 1;\n\tfor (int i = 0; i < n; i++) pw = pw * 2 % MOD;\n\tfor (int i = 0; i <= n + 1; i++) {\n\t\tadd(res, dp[n + 1][i]);\n\t}\n\tcout << (pw - res + MOD) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n#include <algorithm>\n#include <utility>\n#include <type_traits>\n#include <cstdint>\n//永夜作\n#define mnt mint_base\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\nint main(void){\n\tint i,j,k,n,A,B;cin>>n>>A>>B;\n\tif(A>B){swap(A,B);}\n\t\n\t//できない数をカウントする\n\t\n\t\n\t\n\tstatic mint_base dp[5015][5015]={};\n\tstatic mint_base ep[5015][5015]={};\n\tmint_base wa[5015]={};\n\tmint_base ans=0;\n\tdp[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tmint_base aaa=0;\n\t\twa[i+1]+=wa[i];\n\t\tdp[i][1]+=wa[i];\n\t\tfor(j=0;j<B;j++){\n\t\t\t\n\t\t\tdp[i][j]+=ep[i][j];\n\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t\tep[i+1][j+1]+=ep[i][j];\n\t\t\tdp[i+1][j+1]+=dp[i][j];//1\n\t\t\tif(i>0&&j==0){continue;}\n\t\t\taaa+=dp[i][j];\n\t\t\tif(i+A+1<=n+5&&j+A+1<=n+5){ep[i+A+1][j+A+1]+=dp[i][j];}\n\t\t}\n\t\t//cout<<endl;\n\t\t//cout<<aaa<<endl;\n\t\twa[i+2]+=aaa;\n\t\tif(i+A+1<=n+5){wa[i+A+1]-=aaa;}\n\t\t\n\t}\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<B;j++){\n\t\t\tif(n-i+j<B||n-i<A){ans+=dp[i][j];}\n\t\t}\n\t}\n\tmint_base eee=1;\n\tfor(i=0;i<n;i++){eee*=2;}\n\tcout<<eee-ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=1e9+7;\nint add(int a,int b){\n\treturn a+b>=MOD?a+b-MOD:a+b;\n}\nint sub(int a,int b){\n\treturn a-b>=0?a-b:a-b+MOD;\n}\nvoid dadd(int &a,int b){\n\ta=add(a,b);\n}\nint mul(int a,int b){\n\treturn (LL)a*b%MOD;\n}\nconst int N=5050;\nint f[N][N+1]={0};\nint g[N][N+1]={0};\nint h[N][N+1]={0};\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\tf[n+1][b]=1;\n\tg[n+1][b]=1;\n\th[n+1][b]=1;\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j=0;j<b-1;j++){\n\t\t\tint &ans=f[i][j];\n\t\t\tans=f[i+1][min(j+1,b)];\n\t\t\tdadd(ans,h[i+2][0]);\n\t\t\tint s=i+a+1;\n\t\t\tif(s<=n+1){\n\t\t\t\tdadd(ans,sub(0,h[s][0]));\n\t\t\t\tint t=b+i-j;\n\t\t\t\tdadd(ans,g[s][j+s-i]);\n\t\t\t\tif(t+1<=n+1){\n\t\t\t\t\tdadd(ans,sub(0,g[t+1][j+t+1-i]));\n\t\t\t\t\tdadd(ans,h[t+1][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=b-1;j<=b;j++){\n\t\t\tf[i][j]=h[i+1][b];\n\t\t}\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tg[i][j]=add(g[i+1][j+1],f[i][j]);\n\t\t}\n\t\tfor(int j=0;j<=b;j++){\n\t\t\th[i][j]=add(h[i+1][j],f[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int k=0;k+1<=n+1;k++){\n\t\tdadd(ans,f[k+1][k>=a?min(k,b):0]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define CPP17\n#include <limits>\n#include <initializer_list>\n#include <utility>\n#include <bitset>\n#include <tuple>\n#include <type_traits>\n#include <functional>\n#include <string>\n#include <array>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <iterator>\n#include <algorithm>\n#include <complex>\n#include <random>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <regex>\n#include <cassert>\n#include <cstddef>\n#ifdef CPP17\n#include <variant>\n#endif\n\n// Yay!!\n#define endl codeforces\n\n// macros for iterator\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\n\n// alias\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\n\n// variadic min/max\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\n\n// variadic chmin/chmax\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\n// multi demension array\ntemplate <typename T, std::size_t Head, std::size_t... Tail> struct multi_dim_array { using type = std::array<typename multi_dim_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dim_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t... Args> using mdarray = typename multi_dim_array<T, Args...>::type;\n\n#ifdef CPP17\n// fill container\ntemplate <typename T, typename F, typename... Args> \nvoid fill_seq(T &t, F f, Args... args) { if constexpr (std::is_invocable<F, Args...>::value) { t = f(args...); } else { for (ssize_t i = 0; i < t.size(); i++) fill_seq(t[i], f, args..., i); } }\n#endif\n\n// make multi dimension vector\ntemplate <typename T> vec<T> make_v(ssize_t sz) { return vec<T>(sz); }\ntemplate <typename T, typename... Tail> auto make_v(ssize_t hs, Tail&&... ts) { auto v = std::move(make_v<T>(std::forward<Tail>(ts)...)); return vec<decltype(v)>(hs, v); }\n\n// init\nnamespace init__ { \nstruct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; \n}\n\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) noexcept : x((Mod + x % Mod) % Mod) { }\n    \n    constexpr Modint() noexcept : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const noexcept { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const noexcept {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() noexcept { \n        return x; \n    }\n    \n    constexpr ll value() const noexcept {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) noexcept {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) noexcept {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) noexcept {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) noexcept {\n        x *= oth.inv().value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const noexcept {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const noexcept {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const noexcept {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const noexcept {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const noexcept {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) noexcept {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const noexcept {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const noexcept {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nconst ll mod = 1e9 + 7;\nusing mint = math::Modint<mod>;\nconst std::size_t SIZE = 5010 * 2;\n\nmdarray<mint, SIZE, SIZE, 2> dp;\n\nint main() {\n    ll n, a, b;\n    std::cin >> n >> a >> b;\n    if (a > b) std::swap(a, b);\n    \n    mint ans = 0;\n    dp[0][0][1] = 1;\n    for (ll i = 0; i < n; i++) {\n        mint one = 0;\n        for (ll j = 0; j < b; j++) {\n            dp[i + 1][j + 1][1] += dp[i][j][0] + dp[i][j][1];\n            dp[i + 1][j + 1][0] += dp[i][j][0];\n            dp[i + a][j + a][0] += dp[i][j][1];\n            one += dp[i][j][1];\n        }\n        for (ll j = 2; j <= a; j++) {\n            dp[i + j][1][1] += one;\n        }\n        for (ll j = b; j <= n; j++) {\n            mint add = dp[i + 1][j][0] + dp[i + 1][j][1];\n            ans += add * pow(mint(2), n - i - 1);\n        }\n    }\n\n    std::cout << ans.value() << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define sz(x) (int)x.size()\n#define ld long double\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define f first\n#define s second\n\nusing namespace std;\n\nconst ll INF = 2e18;\nconst ll MOD = 1e9 + 7;\n\nll n, a, b, res = 0;\nvector<ll> p2, g;\nvector<vector<ll>> dp1, dp2;\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> a >> b;\n    p2.assign(n + 1, 1);\n    for(int i = 0; i < n; ++i){\n        p2[i + 1] = p2[i] * 2;\n        p2[i + 1] %= MOD;\n    }\n    if(a > b) swap(a, b);\n    if(b == 1){\n        cout << p2[n];\n        return 0;\n    }\n    dp1.assign(n + 1, vector<ll>(2, 0));\n    dp2.assign(n + 1, vector<ll>(2, 0));\n    dp1[0][0] = dp1[0][1] = 1;\n    for(int i = 1; i <= n; ++i){\n        for(int k = 0; k < 2; ++k){\n            for(int j = 1; j <= i; ++j){\n                if(!k && j < a) continue;\n                dp1[i][k] += dp1[i - j][k ^ 1];\n                dp1[i][k] %= MOD;\n            }\n        }\n    }\n    g.assign(n + 1, 0);\n    g[0] = 1;\n    for(int i = 1; i <= n; ++i){\n        g[i] = dp1[i][0] + dp1[i][1];\n        g[i] %= MOD;\n    }\n    for(ll i = 1; i < n; ++i){\n        if(i < a) dp2[i][0]++;\n        for(ll j = 0; j < min(i, a); ++j){\n            dp2[i][0] += dp2[i - j][1];\n        }\n        if(i < b){\n            dp2[i][1] += g[i - 1];\n            dp2[i][1] %= MOD;\n        }\n        for(ll j = 1; j < min(i, b); ++j){\n            ll w = j == 1 ? 1 : g[j - 2];\n            dp2[i][1] += dp2[i - j][0] * w;\n            dp2[i][1] %= MOD;\n        }\n        if(n - i < b){\n            res += dp2[i][0] * g[n - i - 1];\n            res %= MOD;\n        }\n        if(n - i < a){\n            res += dp2[i][1];\n            res %= MOD;\n        }\n    }\n    cout << ((p2[n] - res)%MOD + MOD)%MOD;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"[DEBUG] \");W(__VA_ARGS__);}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 5014;\nLL dp[2][SIZE][SIZE],dp2[SIZE][SIZE];\nLL sum[2][SIZE];\nvoid solve() {\n    int N,A,B;\n    R(N,A,B);\n    if(A>B)swap(A,B);\n    dp[1][0][0]=1;\n    sum[1][0]=1;\n    dp2[0][0]=1;\n    FOR(i,1,N){\n        FOR(j,1,min(i,A-1)){\n            ADD(dp[0][i][0],sum[1][i-j]);\n        }\n        FOR(j,A,i){\n            int gg=min(j-A,B-1);\n            LL v=dp2[i-(j-gg)][gg];\n            if(j>=B)ADD(dp[0][i][B],v);\n            else ADD(dp[0][i][j],v);\n        }\n        FOR(j,0,i-1)ADD(dp[0][i][B],sum[0][j]);\n        FOR(j,0,min(B,i-1)){\n            ADD(dp[1][i][min(B,j+1)],dp[0][i-1][j]+dp[1][i-1][j]);\n        }\n        FOR(j,0,B){\n            dp2[i][j]=dp[1][i][j];\n            if(j)ADD(dp2[i][j],dp2[i-1][j-1]);\n            if(j<B){\n                ADD(sum[1][i],dp[1][i][j]);\n            }\n            else sum[0][i]=dp[1][i][j];\n        }\n    }\n    LL an=dp[0][N][B]+dp[1][N][B];\n    if(an>=MOD)an-=MOD;\n    W(an);\n}\nint main(){\n#define MULTITEST 0\n#if MULTITEST    \n    CASET{\n        printf(\"Case #%d: \",cs);\n        solve();\n    }\n#else\n    solve();\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,a,b;\nll d[5005][5005],s[5005][5005],pw[5005];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nint main(){\n\tn=readint(); a=readint(); b=readint();\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=mod(pw[i-1]<<1);\n\tif(a<b) swap(a,b);\n\tll ans=0;\n\td[0][1]=s[0][1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i-a+1;j++){\n\t\t\tint t=i-b-1<0?0:s[i-b-1][j];\n\t\t\tans=mod(ans+(d[i-1][j]+t)*pw[n-i])%cys;\n\t\t}\n\t\tfor(int j=max(1,i-a+2);j<=i;j++){\n\t\t\tint t=i-b-1<0?0:s[i-b-1][j];\n\t\t\td[i][j]=mod(d[i-1][j]+t);\n\t\t}\n\t\tfor(int j=1;j<=i;j++) d[i][i+1]=mod(d[i][i+1]+mod(cys+s[i-1][j]-(i-b<0?0:s[i-b][j])));\n\t\tfor(int j=1;j<=i;j++) s[i][j]=mod(s[i-1][j]+d[i][j]);\n\t}\n\tfor(int j=1;j<=n-a+1;j++) ans=mod(ans+(n-b<0?0:s[n-b][j]));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\nconstexpr ll MAX=1e6;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Segment_tree{\n    ll N;\n    vector<pii> node;\n    Segment_tree(ll sz){\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mp(INF,INF));\n        per(i,N-2,0){\n            node[i]=std::min(node[i*2+1],node[i*2+1]);\n        }\n    }\n    void update(ll X,pii val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=std::min(node[X*2+1],node[X*2+2]);\n        }\n    }\n    pii RMQ(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mp(INF,INF);\n        if(a<=l&&r<=b) return node[now];\n        auto vl=RMQ(a,b,now*2+1,l,(l+r)/2),vr=RMQ(a,b,now*2+2,(l+r)/2,r);\n        return std::min(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    A--,B--;\n    if(A<B) std::swap(A,B);\n    vi memo(A+2,1);\n    rep(i,0,A){\n        vii dp(i+1,vi(i+1));\n        memo[i+2]=0;\n        dp[0][0]=1;\n        rep(j,0,i){\n            rep(k,0,i){\n                dp[j+1][k+1]+=dp[j][k];\n                dp[j+1][k+1]%=MOD;\n            }\n            dp[j+1][0]+=dp[j][0];\n            dp[j+1][0]%=MOD;\n            REP(k,B+1,i){\n                dp[j+1][0]+=dp[j][k];\n                dp[j+1][0]%=MOD;\n            }\n        }\n        REP(j,B+1,i){\n            memo[i+2]+=dp[i][j];\n            memo[i+2]%=MOD;\n        }\n        memo[i+2]+=dp[i][0];\n        memo[i+2]%=MOD;\n    }\n    vii dp(N+1,vi(A+1)),cp(N+1,vi(B+1));\n    ll ans=modpow(2,N,MOD);\n    dp[0][0]=1;\n    rep(i,0,N){\n        rep(j,0,A){\n            dp[i+1][j+1]+=dp[i][j];\n            dp[i+1][j+1]%=MOD;\n            if(i==j) cp[i+1][1]+=dp[i][j]*memo[j+1]%MOD;\n            else cp[i+1][1]+=dp[i][j]*memo[j]%MOD;\n            cp[i+1][1]%=MOD;\n        }\n        rep(j,0,B){\n            cp[i+1][j+1]+=cp[i][j];\n            cp[i+1][j+1]%=MOD;\n            dp[i+1][1]+=cp[i][j];\n            dp[i+1][1]%=MOD;\n        }\n        dp[i+1][1]+=cp[i][B];\n        dp[i+1][1]%=MOD;\n        if(i==A) cp[i+1][1]+=dp[i][A]*memo[A+1]%MOD;\n        else cp[i+1][1]+=dp[i][A]*memo[A]%MOD;\n        cp[i+1][1]%=MOD;\n    }\n    REP(i,0,A){\n        ans-=dp[N][i]*memo[i+1]%MOD;\n        ans%=MOD;\n        if(ans<0) ans+=MOD;\n    }\n    REP(i,0,B){\n        ans-=cp[N][i];\n        ans%=MOD;\n        if(ans<0) ans+=MOD;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1,_2,_3,name,...)name\n#define _rep(i,n)repi(i,0,n)\n#define repi(i,a,b)for(int i=int(a),i##_len=(b);i<i##_len;++i)\n#define MSVC_UNKO(x)x\n#define rep(...)MSVC_UNKO(_overload3(__VA_ARGS__,repi,_rep,_rep)(__VA_ARGS__))\n#define all(c)c.begin(),c.end()\n#define write(x)cout<<(x)<<'\\n'\nusing namespace std; using ll = long long; template<class T>using vv = vector<vector<T>>;\ntemplate<class T>auto vvec(int n, int m, T v) { return vv<T>(n, vector<T>(m, v)); }\nconstexpr int INF = 1 << 29, MOD = int(1e9) + 7; constexpr ll LINF = 1LL << 60;\nstruct aaa { aaa() { cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }; }aaaa;\n\ntemplate<std::uint_fast64_t Mod> class modint {\n    using uint = std::uint_fast64_t;\npublic:\n    uint a;\n    modint() noexcept : a(0) {}\n    constexpr modint(const uint x) noexcept : a(x% Mod) {}\n    constexpr uint& value() noexcept { return a; }\n    constexpr const uint& value() const noexcept { return a; }\n    constexpr modint operator +(modint rhs) const noexcept { return modint(*this) += rhs; }\n    constexpr modint operator -(modint rhs) const noexcept { return modint(*this) -= rhs; }\n    constexpr modint operator *(modint rhs) const noexcept { return modint(*this) *= rhs; }\n    constexpr modint operator /(modint rhs) const noexcept { return modint(*this) /= rhs; }\n    constexpr modint& operator +=(modint rhs) noexcept { a += rhs.a; if (a >= Mod) a -= Mod; return *this; }\n    constexpr modint& operator -=(modint rhs) noexcept { if (a < rhs.a) a += Mod; a -= rhs.a; return *this; }\n    constexpr modint& operator *=(modint rhs) noexcept { a = a * rhs.a % Mod; return *this; }\n    constexpr modint& operator /=(modint rhs) noexcept {\n        for (uint exp = Mod - 2; exp; exp /= 2, rhs *= rhs) if (exp % 2) *this *= rhs;\n        return *this;\n    }\n};\ntemplate<std::uint_fast64_t Mod, typename T> constexpr modint<Mod> pow(modint<Mod> base, T exp) noexcept {\n    modint<Mod> y(1); for (; exp; exp /= 2, base *= base) if (exp % 2) y *= base;\n    return y;\n}\ntemplate<std::uint_fast64_t Mod> std::istream& operator >>(std::istream& lhs, modint<Mod>& rhs) { return lhs >> rhs.a; }\ntemplate<std::uint_fast64_t Mod> std::ostream& operator <<(std::ostream& lhs, modint<Mod> rhs) { return lhs << rhs.a; }\nusing mint = modint<MOD>;\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n\n    if (A > B) swap(A, B);\n\n    constexpr int Nmax = 5000;\n\n    vector<mint> dp_sub(2 * Nmax, 0);\n    dp_sub[0] = dp_sub[1] = 1;\n    rep(i, 1, N) {\n        dp_sub[i + 1] += dp_sub[i];\n        rep(j, A, B - 2 + 1) {\n            dp_sub[i + j + 1] += dp_sub[i];\n        }\n    }\n\n    vv<mint> dp = vvec(N + 1, 2 * Nmax + 1, mint(0));\n    dp[0][Nmax + 0] = 1;\n\n    rep(i, N) {\n        rep(j, -A + 1, 0) {\n            dp[i + 1][Nmax + j - 1] += dp[i][Nmax + j];\n            dp[i + 1][Nmax + 1] += dp[i][Nmax + j];\n        }\n        rep(j, 0, B) {\n            dp[i + 1][Nmax + j + 1] += dp[i][Nmax + j];\n            dp[i + 1][Nmax - 1] += dp[i][Nmax + j] * (j == i ? dp_sub[j + 1] : dp_sub[j]);\n        }\n    }\n\n    mint ans = 0;\n    rep(j, -A + 1, 0) {\n        ans += dp[N][Nmax + j];\n    }\n    rep(j, 0, B) {\n        ans += dp[N][Nmax + j] * dp_sub[j + 1];\n    }\n    ans = pow(mint(2), N) - ans;\n\n    write(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define int long long\n//#define int __int128\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst int N = 5005, MOD = 1e9 + 7;\n\nint dp[N][3];\nint D[N][2];\nint d[N];\nint ans;\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b)\n        swap (a, b);\n    ans = 1;\n    for (int i = 0; i < n; i++)\n        ans = ans * 2 % MOD;\n    if (a == 1){\n        cout << ans << endl;\n        return 0;\n    }\n    d[0] = 1;\n    for (int i = 1; i <= n; i++){\n        d[i] = d[i-1];\n        for (int j = 0; j <= i - a; j++)\n            d[i] += d[j];\n        d[i] %= MOD;\n    }\n    D[1][1] = 1;\n    for (int i = 2; i <= n+1; i++){\n        D[i][1] = (D[i-1][1] + D[i-1][0]) % MOD;\n        for (int j = 1; j <= i - a; j++)\n            D[i][0] += D[j][1];\n        D[i][0] %= MOD;\n        //cout << i << \" \" << D[i][0] << \" \" << D[i][1] << endl;\n    }\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n    dp[0][2] = 1;\n    for (int i = 1; i <= n; i++){\n        for (int j = max (0ll, i-b+1); j < i; j++){\n            if (j)\n                dp[i][1] += dp[j][0] * D[i-j][1];\n            else\n                dp[i][1] += dp[j][0] * D[i-j+1][1];\n            dp[i][1] %= MOD;\n            if (i <= n){\n                if (j)\n                    dp[i][2] += dp[j][0] * D[i-j+1][1];\n                else\n                    dp[i][2] += dp[j][0] * d[i-j];\n                dp[i][2] %= MOD;\n            }\n        }\n        for (int j = max (0ll, i-a+1); j < i; j++)\n            dp[i][0] += dp[j][1];\n        dp[i][0] %= MOD;\n        dp[i][2] += dp[i][0];\n        dp[i][2] %= MOD;\n        //cout << i << \" \" << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << endl;\n    }\n    //cout << dp[n][2] << endl;\n    cout << (ans - dp[n][2] + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nint N, A, B;\n\nbool vis[5001][5001][2][2];\nint dp[5001][5001][2][2];\n\nll sum1(int, int, int, int);\nll sum2(int, int, int, int);\n\nint solve(int n, int k, int b, int a){\n    if(n == N){\n        if(a == 1 || k >= A) return 1;\n        else return 0;\n    }\n    if(vis[n][k][b][a]) return dp[n][k][b][a];\n    vis[n][k][b][a] = true;\n    int a2 = a;\n    if(k >= A) a2 = 1;\n    ll ret = solve(n+1, k+1, 0, a2);\n    if(b == 0){\n        /*for(int i=1; n+i<=N; i++){\n            if(i < B){\n                ret += solve(n+i, 0, 1, a2);\n            }\n            else{\n                ret += solve(n+i, k+i, 1, a2);\n            }\n        }*/\n        ret += sum1(n+1, 0, 1, a2) - sum1(n+min(B,N-n+1), 0, 1, a2);\n        ret += sum2(n+min(B, N-n+1), k+min(B, N-n+1), 1, a2) - sum2(N+1, k+N-n+1, 1, a2);\n    }\n    if(ret < 0) ret += MOD;\n    if(ret < 0) ret += MOD;\n    if(ret >= MOD) ret -= MOD;\n    if(ret >= MOD) ret -= MOD;\n    if(ret >= MOD) ret -= MOD;\n    return dp[n][k][b][a] = ret;\n}\n\nbool vis1[5001][5001][2];\nint dp1[5001][5001][2];\nll sum1(int n, int k, int b, int a){\n    if(n > N) return 0;\n    if(vis1[n][k][a]) return dp1[n][k][a];\n    vis1[n][k][a] = true;\n    ll ret = solve(n, k, b, a) + sum1(n+1, k, b, a);\n    if(ret >= MOD) ret -= MOD;\n    return dp1[n][k][a] = ret;\n}\n\nbool vis2[5001][5001][2];\nint dp2[5001][5001][2];\nll sum2(int n, int k, int b, int a){\n    if(n > N) return 0;\n    if(vis2[n][k][a]) return dp2[n][k][a];\n    vis2[n][k][a] = true;\n    ll ret = solve(n, k, b, a) + sum2(n+1, k+1, b, a);\n    if(ret >= MOD) ret -= MOD;\n    return dp2[n][k][a] = ret;\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    cout << solve(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 5000 + 7;\nconst int M = (int) 1e9 + 7;\nint streak[N][2][2], dp_streak[N], dp_0[N];\n\nint add(int a, int b) {\n        a += b;\n        if (a >= M) return a - M;\n        if (a < 0) return a + M;\n        return a;\n}\n\nint mul(int a, int b) {\n        return a * (ll) b % M;\n}\n\nint pw(int a, int b) {\n        int r = 1;\n        while (b) {\n                if (b & 1)\n                        r = mul(r, a);\n                a = mul(a, a);\n                b /= 2;\n        }\n        return r;\n}\n\nint dv(int a, int b) {\n        return mul(a, pw(b, M - 2));\n}\n\nint n, a, b;\nset<string> st;\n\nvoid bkt(string s) {\n        if (st.count(s)) return;\n        st.insert(s);\n        for (int i = 0; i + a - 1 < n; i++) {\n                string t = s;\n                for (int j = i; j <= i + a - 1; j++)\n                        t[j] = '0';\n                bkt(t);\n        }\n        for (int i = 0; i + b - 1 < n; i++) {\n                string t = s;\n                for (int j = i; j <= i + b - 1; j++)\n                        t[j] = '1';\n                bkt(t);\n        }\n}\n\nint dm(int _n, int _a, int _b) {\n        n = _n;\n        a = _a;\n        b = _b;\n        st.clear();\n        string base;\n        for (int i = 1; i <= n; i++)\n                base += \"0\";\n        bkt(base);\n        return (int) st.size();\n}\n\nint sm(int _n, int _a, int _b) {\n        n = _n;\n        a = _a;\n        b = _b;\n        if (a > b)\n                swap(a, b);\n        for (int i = 0; i <= n; i++) {\n                for (int f = 0; f <= 1; f++)\n                        for (int s = 0; s <= 1; s++)\n                                streak[i][f][s] = 0;\n                dp_streak[i] = dp_0[i] = 0;\n        }\n        for (int l0 = a; l0 <= n; l0++)\n                streak[l0][0][0] = 1;\n        for (int l1 = 1; l1 <= n; l1++)\n                streak[l1][1][1] = 1;\n        for (int l = 0; l <= n; l++) {\n                for (int f = 0; f <= 1; f++) {\n                        /// s = 0, now = 1\n                        for (int l1 = 1; l + l1 <= n; l1++)\n                                streak[l + l1][f][1] = add(streak[l + l1][f][1], streak[l][f][0]);\n                        /// s = 1, now = 0\n                        for (int l0 = a; l0 <= n; l0++)\n                                streak[l + l0][f][0] = add(streak[l + l0][f][0], streak[l][f][1]);\n                }\n        }\n        /// streak 0 streak 0 streak 0 streak\n        /// streak 0 streak 0 streak 0 streak 0\n        /// 0 streak 0 streak 0 streak 0 streak\n        /// 0 streak 0 streak 0 streak 0 streak 0\n        int bad = 0;\n        /// stars with streak\n        for (int ls = 1; ls < b; ls++)\n                dp_streak[ls] = add(streak[ls][0][1], streak[ls][1][1]);\n        /// starts with 0\n        for (int l0 = 1; l0 < a; l0++)\n                dp_0[l0] = add(dp_0[l0], 1);\n        for (int l = 1; l <= n; l++) {\n                /// streak, 0\n                for (int l0 = 1; l + l0 <= n && l0 < a; l0++) {\n                        dp_0[l + l0] = add(dp_0[l + l0], dp_streak[l]);\n                }\n                /// 0, streak\n                for (int ls = 1; l + ls <= n && ls < b; ls++) {\n                        if (l + ls == n) {\n                                dp_streak[l + ls] = add(dp_streak[l + ls], mul(dp_0[l], streak[ls][1][0]));\n                                dp_streak[l + ls] = add(dp_streak[l + ls], mul(dp_0[l], streak[ls][1][1]));\n                        } else {\n                                dp_streak[l + ls] = add(dp_streak[l + ls], mul(dp_0[l], streak[ls][1][1]));\n                        }\n                }\n        }\n        bad = add(bad, dp_streak[n]);\n        bad = add(bad, dp_0[n]);\n        return add(pw(2, n), -bad);\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        int n, a, b;\n        cin >> n >> a >> b;\n        cout << sm(n, a, b) << \"\\n\";\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 5007, MOD = 1000 * 1000 * 1000 + 7;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N][N][2], t1[N][N][2], t2[N][N][2];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (b < a)\n        swap(a, b);\n\n    for (int i = 1; i <= n; ++i) {\n        for (int t = 0; t < 2; ++t) {\n            int to = i;\n            if (t == 0 && i < a)\n                to = 0;\n            dp[i][to][t] = 1;\n        }   \n    }   \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < b; ++j) {\n            for (int t = 0; t < 2; ++t) {\n\n                add(t1[i][j][t], t1[i - 1][j][t]);\n                add(dp[i][j][t], t1[i][j][t]);\n                if (i && j) {\n                    add(t2[i][j][t], t2[i - 1][j - 1][t]);\n                }\n                add(dp[i][j][t], t2[i][j][t]);\n                int x = dp[i][j][t];\n\n                if (t) {\n                    if (1 < a) {\n                        add(t1[i + 1][0][t^1], x);\n                        if (i + a <= n) {\n                            add(t1[i + a][0][t^1], -x);\n                        }\n                    }\n                    if (a < b - j) {\n                        if (i + a <= n && j + a <= n) {\n                            add(t2[i + a][j + a][t^1], x);\n                        }\n                        if (i + b - j <= n && j + b - j <= n) {\n                            add(t2[i + b - j][j + b - j][t^1], -x);                            \n                        }   \n                    }   \n                }   \n                else {\n                    if (1 < b - j) {\n                        add(t2[i + 1][j + 1][t^1], x);\n                        if (i + b - j <= n && j + b - j <= n) {\n                            add(t2[i + b - j][j + b - j][t^1], -x);                            \n                        }   \n                    }\n                    /*\n                    for (int k = 1; k < b - j; ++k)\n                        add(dp[i + k][j + k][t^1], x);                        \n                    */\n                }   \n            }   \n        }   \n    }   \n\n    int ans = 1;\n    for (int i = 0; i < n; ++i) \n        ans = (ans << 1) % MOD;\n    for (int i = 0; i < b; ++i)\n        for (int t = 0; t < 2; ++t)\n            ans = mod(ans - dp[n][i][t]);\n    cout << ans << endl;            \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept {return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr bool operator==(const ModInt &rhs) const noexcept {return a == rhs.a;}\n    constexpr bool operator!=(const ModInt &rhs) const noexcept {return a != rhs.a;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    friend ostream &operator<<(ostream& os, const ModInt& rhs) noexcept {return os << rhs.a;}\n    friend istream &operator>>(istream& is, ModInt& rhs) noexcept {long long a; is >> a; rhs = a; return is;}\n};\n\nusing mint = ModInt<MOD>;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,A,B; cin >> N >> A >> B;\n    if (A > B) swap(A,B);\n\n    vector<mint> whilte_one(N+1);\n    auto black_one = whilte_one;\n    black_one[0] = 1;\n    rep(i,N) {\n        for (int j = A; i+j <= N; j++) {\n            whilte_one[i+j] += black_one[i];\n        }\n        black_one[i+1] += black_one[i]+whilte_one[i];\n    }\n\n    vector<mint> dp_black(N+1);\n    auto dp_white = dp_black;\n    dp_white[0] = dp_black[0] = 1;\n    rep(i,N) {\n        for (int j = 1; j < A; j++) {\n            if (i+j > N) continue; \n            dp_white[i+j] += dp_black[i];\n        }\n        for (int j = 1; j < B; j++) {\n            if (i+j > N) continue;\n            int len = j-2;\n            if (i==0) len++;\n            if (i+j==N) len++;\n            chmax(len,0);\n            dp_black[i+j] += dp_white[i]*(black_one[len]+whilte_one[len]);\n        }\n    }\n\n    mint ans = 1;\n    rep(i,N) ans *= 2;\n    cout << ans - (dp_white[N]+dp_black[N]) << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 5007 , mo = 1000000007;\n\ninline int upd(int x){return x+((x>>31)&mo);}\ninline lint upd(lint x){return x+((x>>63)&mo);}\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=upd(a+b-mo);}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=upd(a-b);}\ntemplate<typename T1,typename T2> inline T1 add(T1 a,T2 b){return upd(a+b-mo);}\ntemplate<typename T1,typename T2> inline T1 del(T1 a,T2 b){return upd(a-b);}\n\nint n,pa,pb;\nlint f[_][_][2]={0},sf[_][2]={0},g[_][_][2]={0};\n\nint main()\n{\n\tios_base::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty(),pa=ty(),pb=ty();\n\n\tif(pa<pb)swap(pa,pb);\n\n\tf[0][0][0]=sf[0][0]=g[0][0][0]=1;\n\tf[0][0][1]=sf[0][1]=g[0][0][1]=1;\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<pa;j++)\n\t\t{\n\t\t\tif(i>=1 && j>=1)ad(f[i][j][0],g[i-1][j-1][1]);\n\t\t\tif(i>=pb && j>=pb)ad(f[i][j][1],g[i-pb][j-pb][0]);\n\t\t}\n\t\tfor(int j=1;j<=min(i,pb-1);j++)ad(f[i][0][1],sf[i-j][0]);\n\n\t\tg[i][0][1]=f[i][0][1];\n\t\tfor(int j=1;j<pa;j++)\n\t\t{\n\t\t\tg[i][j][0]=add(g[i-1][j-1][0],f[i][j][0]);\n\t\t\tg[i][j][1]=add(g[i-1][j-1][1],f[i][j][1]);\n\t\t}\n\n\t\tfor(int j=0;j<pa;j++)ad(sf[i][0],f[i][j][0]),ad(sf[i][1],f[i][j][1]);\n\t}\n\n\tlint ans=1;\n\tfor(int i=1;i<=n;i++)ad(ans,ans);\n\tfor(int i=0;i<pa;i++)\n\t\tfor(int j=0;j<2;j++)\n\t\t\tdl(ans,f[n][i][j]);\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(v) v.begin(),v.end()\n#define P pair<int,int>\n#define len(s) (int)s.size()\n#define pb push_back\n\ntemplate<class T> inline bool chmin(T &a, T b){\n\tif(a>b){a=b;return true;}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T &a, T b){\n\tif(a<b){a=b;return true;}\n\treturn false;\n}\nconstexpr int mod = 1e9+7;\nconstexpr int inf = 3e18;\n\n\nint N,A,B;\nint pre[5005][2],res[5005];\nint dp[5005][2];\nint mod_pow(int x,int y,int m=mod){\n\tint res=1;\n\twhile(y>0){\n\t\tif(y&1)(res*=x)%=m;\n\t\t(x*=x)%=m;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nsigned main(){\n\tcin>>N>>A>>B;\n\tif(A>B)swap(A,B);\n\tpre[0][0]=1;\n\tpre[0][1]=1;\n\tres[0]=1;\n\trep(i,N){\n\t\tif(i)res[i]=(pre[i][0]+pre[i][1])%mod;\n\t\tREP(j,N-i+1){\n\t\t\trep(k,2){\n\t\t\t\tif(!(!k&&j<A))(pre[i+j][k^1]+=pre[i][k])%=mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[0][0]=1;dp[0][1]=1;\n\trep(i,N){\n\t\tREP(j,min(N-i+1,A))(dp[i+j][0]+=dp[i][1])%=mod;\n\t\tREP(j,min(N-i+1,B)){\n\t\t\tif(!i||i+j==N)\n\t\t\t\t(dp[i+j][1]+=dp[i][0]*res[j-1])%=mod;\n\t\t\telse\n\t\t\t\t(dp[i+j][1]+=dp[i][0]*(j==1?1:res[j-2]))%=mod;\n\t\t}\n\t}\n\tcout<<(mod_pow(2,N)-dp[N][0]-dp[N][1]+2*mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\nconst LL Mod = 1e9+7;\n\nint N,A,B; LL f[2][5010][5010],h[2][2][5010],g[5010][5010];\n\ninline void Add(LL &a,LL b){ a=(a+b>=Mod?a+b-Mod:a+b); }\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(),A=read(),B=read(); LL pw2=1;\n\tfor(int i=1;i<=N;i++) pw2=pw2*2%Mod;\n\tf[1][1][0]=1; f[0][1][1]=1; if(A>B) swap(A,B);\n\tfor(int x=0;x<2;x++)\n\t\tfor(int i=1;i<B;i++){\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tif(j>=A) Add(f[x][i+1][0],f[x][i][j]);\n\t\t\t\tAdd(f[x][i+1][j+1],f[x][i][j]);\n\t\t\t} Add(f[x][i+1][0],f[x][i][0]);\n\t\t} \n\tfor(int x=0;x<2;x++) \n\t\tfor(int i=1;i<B;i++){\n\t\t\th[x][1][i]=f[x][i][0];\n\t\t\tfor(int j=A;j<=i;j++) Add(h[x][0][i],f[x][i][j]);\n\t\t}\n\tg[0][0]=1;\n\tfor(int i=0;i<N;i++){\n\t\tLL g0=0;\n\t\tfor(int j=1;j<=min(i,A-1);j++) Add(g0,g[i][j]);\n\t\tfor(int j=0;j<=min(i,A-1);j++) Add(g[i+1][j+1],g[i][j]);\n\t\tfor(int j=1;j<B&&j+i<=N;j++){\n\t\t\tif(!i&&i+j==N){ Add(g[i+j][0],(h[0][0][j]+h[1][1][j]+h[1][0][j]+h[0][1][j])%Mod); continue; }\n\t\t\tif(!i){ Add(g[i+j][0],(h[0][1][j]+h[1][1][j])%Mod); continue; }\n\t\t\tif(i+j==N){ Add(g[i+j][0],g0*(h[1][0][j]+h[1][1][j])%Mod); continue;}\n\t\t\tAdd(g[i+j][0],g0*h[1][1][j]%Mod);\n\t\t}\n\t} for(int i=0;i<A;i++) pw2-=g[N][i]; pw2=pw2%Mod+Mod; pw2%=Mod;\n\tprintf(\"%lld\\n\",pw2);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tusing num = modnum<int(1e9)+7>;\n\n\tint N, A, B; cin >> N >> A >> B;\n\tassert(A <= N && B <= N);\n\tif (A > B) swap(A, B);\n\tassert(A <= B);\n\n\t// with bounding 1's\n\tvector<num> bways(N+3);\n\tbways[1] = 1;\n\tfor (int i = 1; i+1 < int(bways.size()); i++) {\n\t\tbways[i+1] += bways[i];\n\t\tfor (int j = A; i + j + 1 < int(bways.size()); j++) {\n\t\t\tbways[i+j+1] += bways[i];\n\t\t}\n\t}\n\n\tvector<array<num, 2>> totWays(N+3);\n\tfor (int j = 1; j-1 < B; j++) {\n\t\ttotWays[j][0] = bways[j];\n\t}\n\tfor (int i = 0; i < N+2; i++) {\n\t\tfor (int j = 1; i+j <= N+2 && j < A; j++) {\n\t\t\ttotWays[i+j][1] += totWays[i][0];\n\t\t}\n\t\tfor (int j = 1; i+j <= N+2 && j < B; j++) {\n\t\t\ttotWays[i+j][0] += totWays[i][1] * bways[j];\n\t\t}\n\t\tif (i + B == N+2) {\n\t\t\ttotWays[i+B][0] += totWays[i][1] * bways[B];\n\t\t}\n\t}\n\n\tcout << pow(num(2), N) - totWays[N+2][0] << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) //cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 6000;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\n\nll dp[N], dp1[N];\nll dpc[N], dpm[N];\nll fdp[N][3];\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n, A, B;\n\tcin >> n >> A >> B;\n\tif(A > B) swap(A, B);\n\n\t//dp[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tdp[i] = 1;\n\t\tfor(int j = A + 1; j <= i; j++) dp[i] += (1ll * dp[i - j] * (j - A)) % Mod;\n\t\tdp[i] %= Mod;\n\t\t//cerr << i << ' ' << dp[i] << '\\n';\n\t}\n\tcerr << '\\n';\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = A; j < i; j++) dp1[i] += dp[i - j];\n\t\tdp1[i] %= Mod;\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j < min(A, i); j++){\n\t\t\tif(i - j >= B) dpc[i] += dp[i - j];\n\t\t}\n\t\tdpc[i] %= Mod;\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j < min(A, i); j++){\n\t\t\tdpm[i] += dp[i - j];\n\t\t}\n\t\tdpm[i] %= Mod;\n\t}\n\tll ans = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j + i < n; j++) if((i == 0 || i >= A) && (j == 0 || j >= A)) ans += dp[n - i - j];\n\t}\n\tans %= Mod;\n\tdebug(ans);\n\tdebug(dp[3]);\n\tfor(int i = 1; i <= n; i++){\n\t\t//fdp[i][1] += 0;\n\t\tif(i < A) fdp[i][0] += 1;\n\t\tfor(int j = 1; j <= min(A - 1, i - 1); j++){\n\t\t\tif(i - j < B) fdp[i][0] += dp[i - j];\n\t\t\telse fdp[i][1] += dp[i - j];\n\t\t}\n\t\tfor(int j = 1; j <= min(A - 1, i - 1); j++){\n\t\t\tif(i - j >= B) fdp[i][1] += dp1[i - j];\n\t\t\telse fdp[i][0] += dp1[i - j];\n\t\t}\n\t\tif(i + B > n) fdp[i][0] = 0;\n\t\tfdp[i][0] %= Mod;\n\t\tfdp[i][1] %= Mod;\t\n\t\t\n\t\t//cerr << i << ' ' << fdp[i][0] << ' ' << fdp[i][1] << '\\n';\n\n\t\tfor(int ln = 1; ln + i <= n; ln ++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tfor(int k2 = k; k2 < 2; k2 ++){\n\t\t\t\t\t( fdp[i + ln][k2] += 1ll * fdp[i][k] * (k == k2 ? (k == 0 ? dpm[ln] - dpc[ln] + Mod : dpm[ln]) : dpc[ln]) ) %= Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans += (fdp[i][0] + fdp[i][1]) * (i < n ? (dp1[n - i] + dp[n - i]) : 1);\n\t\tans %= Mod;\n\t}\n\tdebug(dpc[3]);\n\tcout << ans % Mod << '\\n';\n\treturn 0;\n}\n/*\n4 2 2\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\nostream &operator<<(ostream &os, const pair<char, int> &unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 5010, P = 1000000007;\n\nint f[N][N], g[N][N], pw[N];\nint rsum[N];\n\nint norm(int x) { return x >= P ? x - P : x; }\n\nvoid add(int &x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int &x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, a, b;\n  cin >> n >> a >> b;\n  pw[0] = 1;\n  for (int i = 1; i <= n; ++i) pw[i] = norm(pw[i - 1] << 1);\n  if (a < b) swap(a, b);\n  f[0][a] = 1;\n  for (int i = 0; i <= n; ++i) {\n    if (i)\n      add(rsum[i], rsum[i - 1]);\n    add(f[i][a - 1], rsum[i]);\n    if (i)\n      for (int j = 0; j <= a; ++j) {\n        add(g[i][j], g[i - 1][j + 1]);\n        add(f[i][j], g[i][j]);\n      }\n    for (int j = 1; j <= a; ++j) {\n      if (!f[i][j]) continue;\n      add(f[i + 1][j - 1], f[i][j]);\n\n      add(rsum[i + 2], f[i][j]);\n      if (i + b + 1 <= n)\n        sub(rsum[i + b + 1], f[i][j]);\n\n      if (j > b) {\n        if (i + j <= n)\n          add(f[i + j][0], f[i][j]);\n      } else {\n        if (i + b <= n)\n          add(f[i + b][0], f[i][j]);\n      }\n      if (i + b + 1 <= n && j - b - 1 >= 0) {\n        add(g[i + b + 1][j - b - 1], f[i][j]);\n      }\n\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans = (ans + f[i][0] * (ll) pw[n - i]) % P;\n  }\n  cout << ans << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  P operator-() const {\n    P res((*this).size());\n    rep(i, (*this).size()) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, (*this).size()) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q) {\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  // P &div(map<int, T> q) {\n  //   rep(i, (*this).size()) {\n  //     for (auto &b : q) if (b.first != 0 && b.first <= i) (*this)[i] -= b.second * (*this)[i-b.first];\n  //     (*this)[i] /= q[0];\n  //   }\n  //   return *this;\n  // }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div({{0, 1}, {1, -1}});\n  q[1] = 1;\n  q.div({{0, 1}, {1, -1}});\n  f[1] = 1;\n  f[a] -= 1;\n  f.div({{0, 1}, {1, -1}});\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+2) g0[i] = 0;\n  rep2(i, b, n+2) g1[i] = 0;\n  rep2(i, b, n+2) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SZ(x) ((int)(x).size())\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int maxn = 5010;\n\nMint dp[maxn][4][2];   // last, complete\nMint sub[maxn][2][2];  // front, end\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n\n    for (int i = A; i <= N; ++i) {\n        sub[i][0][0] = 1;\n    }\n    sub[1][1][1] = 1;\n    for (int i = 1; i < N; ++i) {\n        rep(k, 2) {\n            rep(l, 2) {\n                if (l) {\n                    for (int j = A; j + i <= N; ++j) {\n                        sub[i + j][k][0] += sub[i][k][l];\n                    }\n                }\n                sub[i + 1][k][1] += sub[i][k][l];\n            }\n        }\n    }\n\n    dp[0][2][0] = 1;\n    for (int i = 0; i < N; ++i) {\n        rep(k, 3) {\n            rep(l, 2) {\n                if (!dp[i][k][l]) continue;\n                if (k) {\n                    for (int j = 1; j < A && i + j <= N; ++j) {\n                        dp[i + j][0][l] += dp[i][k][l];\n                    }\n                }\n                if (k == 2 || k == 0) {\n                    for (int j = 1; i + j <= N; ++j) {\n                        rep(fr, 2) {\n                            rep(la, 2) {\n                                if (fr != k) {\n                                    int nk = (la == 0 ? 3 : 1);\n                                    dp[i + j][nk][l | (j >= B)] +=\n                                        dp[i][k][l] * sub[j][fr][la];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    Mint ans;\n    rep(la, 4) ans += dp[N][la][1];\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod = 1000000007;\nll f[5010][2] = {},g[5010][2] = {},dp[5010][2] = {};\nint main(){\n    int i,j,n,a,b;\n    cin >> n >> a >> b;\n    if(a<b) swap(a,b);\n    for(i=0;i<b;i++) f[i][0] = 1;\n    for(i=b;i<=n;i++){\n        f[i][0] += (f[i - 1][0] + f[i - 1][1])%mod;\n        for(j=i - b;j>=0;j--){\n            (f[i][1] += f[j][0]) %= mod;\n        }\n    }\n    for(i=0;i<=n;i++){\n        for(j=max(a,i - b + 1);j<=i - 1;j++) (g[i][1] += f[j - 1][0]) %= mod;\n        for(j=max(1,i - b + 1);j<=min(i - 1,a - 1);j++) (g[i][0] += f[j - 1][0]) %= mod;\n    }\n    dp[0][0] = 1;\n    for(i=1;i<=n;i++){\n        for(j=i - 1;j>=1;j--){\n            (dp[i][1] += (g[i - j][1]*dp[j][0] + (g[i - j][1] + g[i - j][0])*dp[j][1])%mod) %= mod;\n            (dp[i][0] += (g[i - j][0]*dp[j][0])%mod) %= mod;\n        }\n        for(j=1;j<b;j++){\n            if(j<=i && i - j>=a) (dp[i][1] += f[i - j][0]) %= mod;\n            if(j<=i && i - j<a) (dp[i][0] += f[i - j][0]) %= mod;\n        }\n    }\n    ll ans = 0;\n    (ans += dp[n][1] + f[n][0] + f[n][1]) %= mod;\n    for(i=1;i<n;i++){\n        (ans += (f[n - i - 1][0] + f[n - i - 1][1])*dp[i][1]%mod) %= mod;\n        if(n - i>=a) (ans += (f[n - i - 1][0] + f[n - i - 1][1])*dp[i][0]%mod) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define ub upper_bound\n#define lb upper_bound\n#define mp make_pair\n// #define F first\n// #define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n    \nusing ll = long long;\nconst ll INF = LLONG_MAX / 40 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nint ddx[] = {-1,0,1,-1,1,-1,0,1}, ddy[] = {1,1,1,0,0,-1,-1,-1};\nvector<ll> prime;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1,0);\n        inv = vector<int>(n + 1,0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) inv[i] = fact::POW(fac[i],fmod-2);\n    }\n    ll nCr(ll n, ll r) {if (n<r) return 0; return (fac[n] * inv[r] % fmod) * inv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n};\n    \ntemplate <class T = ll> T in() {T x; cin >> x; return (x);}\nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a,b)) * b;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> bool chmin(T& a, T b) {bool res=false;if(a>b)a=b,res=true;return res;}\ntemplate <typename T> bool chmax(T& a, T b) {bool res=false;if(a<b)a=b,res=true;return res;}\nbool isSqrt(ll a) {return (pow(sqrt(a),2) == a) ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nlong long mul(long long a, long long b, long long mod) {\n    long long keta[20] = {};\n    long long c = b;\n    long long now = 0;\n    while (c != 0ll) {\n        keta[now] = c % 10; c /= 10; now++;\n    }\n    long long res = 0;\n    for (int i = 19; i >= 0; --i) {\n        res *= 10; res %= mod;\n        res += keta[i] * a % mod;\n    }\n    return res % mod;\n}\n\nint ceili(int a, int b) {\n    if (a % b) return a/b+1;\n    else a/b;\n}\n\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\n// ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = mul(a, c, mod);}a = mul(a, a, mod); b >>= 1;}return c;}\n\nlong double pi = 3.141592653589793238462643383279502884197169399375105820;\n\nint dp[5005][2];\nint dp2[5005][2];\nint dp3[5005][2];\n\nvoid solve() {\n    int n; cin >> n;\n    int a, b; cin >> a >> b; if (a > b) swap(a, b);\n\n    dp[0][1] = 1;\n    FOR (i, 1, n+1) {\n        dp[i][1] = dp[i-1][0]+dp[i-1][1];\n        rep (j, i-a+1) {\n            dp[i][0] += dp[j][1];\n        }\n        dp[i][0] %= mod, dp[i][1] %= mod;\n    }\n    // rep (i, n) cout << dp[i][0] << \" \" << dp[i][1] << endl;\n\n    dp2[0][0] = 1;\n    dp2[0][1] = 1;\n\n    FOR (i, 1, n+1) {\n        FOR (j, 1, min(a, i+1)) {\n            dp2[i][0] += dp2[i-j][1];\n        }\n        FOR (j, 1, min(b, i+1)) {\n            int mul;\n            if (i-j==0) {\n                if (i==n) mul = dp[j][0]+dp[j][1];\n                else mul = dp[j][1];\n            } else {\n                if (i==n) mul = dp[j-1][0]+dp[j-1][1];\n                else mul = dp[j-1][1];\n            }\n            dp2[i][1] += dp2[i-j][0] * mul % mod;\n        }\n        rep (j, 2) dp2[i][j] %= mod;\n    }\n    cout << (POW(2, n)+2*mod-dp2[n][0]-dp2[n][1]) % mod << endl;\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x (y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += (Mod_Int)1;}\n\n    Mod_Int operator ++ (int) {\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= (Mod_Int)1;}\n\n    Mod_Int operator -- (int) {\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow (ll n) const {\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse () const {\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*i;\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N, 1){\n        ifac[i-1] = ifac[i]*i;\n    }\n}\n\nmint comb(int n, int k){\n    return fac[n]*ifac[n-k]*ifac[k];\n}\n\nmint perm(int n, int k){\n    return fac[n]*ifac[n-k];\n}\n\nint main(){\n    int N, A, B;\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    mint dp[N+1][N+1];\n    fill(dp[0], dp[N+1], 0);\n    dp[N][N] = 1;\n    mint sum[B+1];\n    fill(sum, sum+B+1, 0);\n    sum[0] = 1;\n    rep(i, N){\n        mint memo[B+1];\n        fill(memo, memo+B+1, 0);\n        if(N-i+A <= N){\n            rep(j, B-1){\n                if(N-i+j > N) break;\n                dp[N-i+A-1][N-i+j] += dp[N-i+A][N-i+j];\n                memo[j+1] += dp[N-i+A][N-i+j];\n            }\n        }\n        if(N-i+B <= N){\n            rep(j, A-1){\n                if(N-i+j > N) break;\n                dp[N-i+j][N-i+B-1] += dp[N-i+j][N-i+B];\n                memo[B] += dp[N-i+j][N-i+B];\n            }\n        }\n        rep(j, A+1){\n            if(N-i+j > N) break;\n            dp[N-i+j][N-i-1] += dp[N-i+j][N-i];\n            if(N-i+B > N) continue;\n            dp[N-i+j][N-i-1] += dp[N-i+j][N-i+B];\n        }\n        rep2(j, 1, B-1){\n            dp[N-i][N-i-1] += sum[j];\n        }\n        rep3(j, B, 1){\n            sum[j] = sum[j-1];\n            if(N-i+j-1 > N) continue;\n            sum[j] += dp[N-i-1][N-i+j-1];\n            if(N-i+A > N) continue;\n            sum[j] -= dp[N-i+A][N-i+j-1];\n        }\n        sum[0] = 0;\n        rep2(j, 0, A+1){\n            if(N-i+j-1 > N) break;\n            sum[0] += dp[N-i+j-1][N-i-1];\n        }\n        rep(j, B+1){\n            sum[j] += memo[j];\n        }\n        if(N-i+A-1 <= N && N-i+B-1 <= N){\n            sum[B] -= dp[N-i+A-1][N-i+B-1];\n            dp[N-i+A-1][N-i+B-1] = 0;\n        }\n        if(N-i+A-1 <= N){\n            sum[0] -= dp[N-i+A-1][N-i-1];\n            dp[N-i+A-1][N-i-1] = 0;\n        }\n    }\n    mint ans = (mint(2).pow(N));\n    rep(i, A+1){\n        rep(j, B+1){\n            ans -= dp[i][j];\n        }\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=5000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\nint Power(int a,int k,int p=mod){int res=1;for (;k;k>>=1,smul(a,a,p)) if (k&1) smul(res,a,p);;return res;}\n\nint n,a,b;\n\nvoid into(){\n  scanf(\"%d%d%d\",&n,&a,&b);\n}\n\nint f[N+9][2],g[N+9];\n\nvoid Get_g(){\n  if (a>b) swap(a,b);\n  if (b==1) return;\n  g[0]=f[0][0]=f[0][1]=1;\n  for (int i=1;i<=n;++i){\n\tfor (int j=1;j<=i;++j){\n\t  sadd(f[i][1],f[i-j][0]);\n\t  if (j>=a) sadd(f[i][0],f[i-j][1]);\n\t}\n\tg[i]=add(f[i][0],f[i][1]);\n  }\n}\n\nint dp[N+9][2],sum[N+9],ans;\n\nvoid Get_dp(){\n  if (b==1) return;\n  for (int i=1;i<n;++i){\n\tif (i<a) dp[i][0]=1;\n\tfor (int j=1;j<i&&j<a;++j) sadd(dp[i][0],dp[i-j][1]);\n\tif (i<b) dp[i][1]=g[i-1];\n\tfor (int j=1;j<i&&j<b;++j) sadd(dp[i][1],mul(dp[i-j][0],j==1?1:g[j-2]));\n\tif (n-i<b) sadd(ans,mul(dp[i][0],g[n-i-1]));\n\tif (n-i<a) sadd(ans,dp[i][1]);\n  }\n}\n\nvoid work(){\n  Get_g();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",sub(Power(2,n),ans));\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nconst long long mod = 1000000007;\nint n, a, b; long long d[2][5050], e[2][5050];\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nint main()\n{\n\tscanf (\"%d %d %d\", &n, &a, &b);\n\n\tlong long all = 1;\n\tfor (int i = 0; i < n; i++) all = all * 2 % mod;\n\n\tlong long ans = 0;\n\n\tif (a > 1 && b > 1){\n\t\tif (a < b) swap(a, b);\n\t\td[0][1] = 1;\n\t\tfor (int i = 1; i < a; i++){\n\t\t\tadd(d[0][i + 1], d[0][i]);\n\t\t\tadd(d[0][i + 1], d[1][i]);\n\t\t\tif (i + b < a) add(d[1][i + b], d[0][i]);\n\t\t\tadd(d[1][i + 1], d[1][i]);\n\t\t}\n\n\t\te[0][0] = e[1][0] = 1;\n\t\tfor (int j = 1; j < a; j++) e[0][j] = d[1][j];\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 1; j < a && i + j <= n; j++) add(e[0][i + j], e[1][i] * d[0][j] % mod);\n\t\t\tfor (int j = 1; j < b && i + j <= n; j++) add(e[1][i + j], e[0][i]);\n\t\t}\n\n\t\tadd(ans, e[0][n]);\n\t\tadd(ans, e[1][n]);\n\t\tfor (int j = 1; j < a; j++) add(ans, e[1][n - j] * d[1][j] % mod);\n\t}\n\n\tans = all + mod - ans;\n\tif (ans >= mod) ans -= mod;\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 5010;\n\nll N, A, B;\nll dp1[maxn]; // B blocks starting and ending at b\nll dp2[maxn]; // complement strings ending at b\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n\n    dp1[1] = 1;\n    for (ll i = 2; i <= B; ++i) {\n        dp1[i] = dp1[i - 1];\n        for (ll j = A; i - 1 - j >= 1; ++j) Add(dp1[i], dp1[i - 1 - j]);\n    }\n    dp2[0] = 1;\n    for (ll i = 1; i <= N; ++i) {\n        for (ll j = 1; j < B; ++j) {\n            if (i == j) {\n                Add(dp2[i], dp1[j + 1]);\n            } else {\n                ll s = 0;\n                for (ll k = i - j - 1; k >= 0 && (i - j) - k < A; --k) {\n                    Add(s, dp2[k]);\n                }\n                Add(dp2[i], 1LL * dp1[j] * s);\n            }\n        }\n    }\n\n    ll sum = 0;\n    for (ll i = N; i > N - A; --i) Add(sum, dp2[i]);\n    for (ll i = N - A; i - 1 > N - B; --i) {\n        for (ll j = i; j - 1 > N - B; --j) {\n            ll s = 0;\n            for (ll k = j - 1; k >= 1 && j - k < A; --k) {\n                Add(s, dp2[k - 1]);\n            }\n            Add(sum, 1LL * dp1[i - j + 1] * s);\n        }\n    }\n\n    ll all = 1;\n    for (ll i = 1; i <= N; ++i) Add(all, all);\n\n    ll ans = (all + MOD - sum) % MOD;\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <numeric>\n#include <iostream>\nusing namespace std;\n\nint M = 1000000007;\nlong long dp[5001][3][5001];\n\nint main() {\n    int n, a, b; cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n\n    long long ans = 1;\n    for (int i = 0; i < n; i++) ans = ans * 2 % M;\n    if (a > 1) {\n        dp[0][0][1] = 1;\n        dp[0][1][1] = 0;\n        dp[0][2][1] = 1;\n        for (int i = 1; i < n; i++) {\n            dp[i][0][1] = accumulate(dp[i-1][2]+1, dp[i-1][2]+b, 0LL) % M;\n            for (int j = 2; j < a; j++) dp[i][0][j] = dp[i-1][0][j-1];\n            if (i+1 == a) dp[i][1][a] = 1;\n            for (int j = a+1; j < b; j++)\n                dp[i][1][j] = (dp[i-1][1][j-1] + (i >= a ? dp[i-a][2][j-a] : 0)) % M;\n            dp[i][2][1] = accumulate(dp[i-1][0]+1, dp[i-1][0]+a, 0LL) % M;\n            for (int j = 2; j < b; j++)\n                dp[i][2][j] = (dp[i-1][1][j-1] + dp[i-1][2][j-1]) % M;\n        }\n        ans -= accumulate(dp[n-1][0]+1, dp[n-1][0]+a, 0LL) % M;\n        ans -= accumulate(dp[n-1][1]+1, dp[n-1][1]+b, 0LL) % M;\n        ans -= accumulate(dp[n-1][2]+1, dp[n-1][2]+b, 0LL) % M;\n    }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <queue>\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(a) ((int) (a).size())\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst long long inf64 = ((long long)1 << 62) - 1;\nconst long double pi = acos(-1);\n\ntemplate <class T> T sqr (T x) {return x * x;}\ntemplate <class T> T abs (T x) {return x < 0 ? -x : x;}\n\nconst int P = 1000 * 1000 * 1000 + 7;\n\nint Sum(int a, int b) {\n    return (a + b) % P;\n}\n\nint Mult(int a, int b) {\n    return (a * (long long) b) % P;\n}\n\nint Pow(int a, int n) {\n    if (n == 0) {\n        return 1;\n    }\n\n    int res = Pow(a, n / 2);\n    res = Mult(res, res);\n    if (n % 2 == 1) {\n        res = Mult(res, a);\n    }\n\n    return res;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0);\n//  freopen(\"_input.txt\", \"rt\", stdin);\n//  freopen(\"_output.txt\", \"wt\", stdout);\n\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    if (a > b) {\n        swap(a, b);\n    }\n\n    vector<vector<int>> d1(n + 1, vector<int>(b));\n    vector<vector<int>> d0(n + 1, vector<int>(b));\n    vector<int> total1(n + 1);\n\n    d1[0][0] = 1;\n    total1[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        d1[i][0] = 0;\n        for (int j = 1; j < b; ++j) {\n            d1[i][j] = Sum(d1[i - 1][j - 1], d0[i - 1][j - 1]);\n        }\n        \n        d0[i][0] = 0;\n        for (int j = 1; j < min(a, i + 1); ++j) {\n            d0[i][0] = Sum(d0[i][0], total1[i - j]);\n        }\n        \n        if (i >= a) {\n            for (int j = a; j < b; ++j) {\n                d0[i][j] = Sum(d1[i - a][j - a], d0[i - 1][j - 1]);\n            }\n        }\n\n        total1[i] = 0;\n        for (int j = 0; j < b; ++j) {\n            total1[i] = Sum(total1[i], d1[i][j]);\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i < b; ++i) {\n        res = Sum(res, Sum(d0[n][i], d1[n][i]));\n    }\n\n    cout << Sum(Pow(2, n), P - res) << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int MaxN = 5000;\nconst int Mod = 1000000007;\n\nint N, A, B;\nint F[MaxN + 5][2], G[MaxN + 5][2];\n\ninline int add(int x, int y) { return (x += y) >= Mod ? x - Mod : x; }\ninline int sub(int x, int y) { return (x -= y) < 0 ? x + Mod : x; }\ninline int mul(int x, int y) { return 1LL * x * y % Mod; }\ninline void inc(int &x, int y = 1) { (x += y) >= Mod ? x -= Mod : 0; }\ninline int pw(int x, int y) { int z = 1; for (; y; y >>= 1, x = mul(x, x)) if (y & 1) z = mul(z, x); return z; }\n\nvoid init() {\n  scanf(\"%d %d %d\", &N, &A, &B);\n  if (A > B) std::swap(A, B);\n}\n\nvoid solve() {\n  G[0][0] = 1;\n  for (int i = 1; i < B; ++i) {\n    for (int j = A; j <= i; ++j)\n      G[i][0] = add(G[i][0], G[i - j][1]);\n    for (int j = 1; j <= i; ++j)\n      G[i][1] = add(G[i][1], G[i - j][0]);\n  }\n  for (int i = 1; i <= N; ++i) {\n    F[i][0] = i < A;\n    for (int j = 1; j < A && j < i; ++j)\n      F[i][0] = add(F[i][0], F[i - j][1]);\n    F[i][1] = add(G[i][0], G[i][1]);\n    for (int j = 1; j < B && j < i; ++j)\n      F[i][1] = add(F[i][1], mul(F[i - j][0], G[j][1]));\n  }\n  int ans = add(F[N][0], F[N][1]);\n  for (int j = 1; j < B; ++j)\n    ans = add(ans, mul(F[N - j][0], G[j][0]));\n  printf(\"%d\\n\", sub(pw(2, N), ans));\n}\n\nint main() {\n  init();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define MOD_TYPE 1\n\n#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing multiInt = boost::multiprecision::cpp_int;\nusing lld = boost::multiprecision::cpp_dec_float_100;\n*/\n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconstexpr ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\n//constexpr ll MOD = 1;\nconstexpr int INF = (int)1e9;\nconstexpr ll LINF = (ll)4e18;\nconstexpr double PI = acos(-1.0);\nconstexpr double EPS = 1e-10;\nconstexpr int Dx[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nconstexpr int Dy[] = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define REPI(i, m, n) for (int i = m; i < (int)(n); ++i)\n#define repi(i, n) REPI(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << \"\\n\"\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << \"\\n\"\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << \"\\n\"\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << \"\\n\"\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << \"\\n\"\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << \"\\n\";\n\ninline void init_main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n}\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline ll CEIL(ll a, ll b)\n{\n  return (a + b - 1) / b;\n}\ntemplate <typename A, size_t N, typename T>\ninline void Fill(A (&array)[N], const T &val)\n{\n  fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T, typename U>\nconstexpr ostream &operator<<(ostream &os, pair<T, U> &p) noexcept\n{\n  os << p.first << \" \" << p.second;\n  return os;\n}\n#pragma endregion\n\n#pragma region mint\ntemplate <int MOD>\nstruct Fp\n{\n  long long val;\n\n  constexpr Fp(long long v = 0) noexcept : val(v % MOD)\n  {\n    if (val < 0)\n      v += MOD;\n  }\n\n  constexpr int getmod()\n  {\n    return MOD;\n  }\n\n  constexpr Fp operator-() const noexcept\n  {\n    return val ? MOD - val : 0;\n  }\n\n  constexpr Fp operator+(const Fp &r) const noexcept\n  {\n    return Fp(*this) += r;\n  }\n\n  constexpr Fp operator-(const Fp &r) const noexcept\n  {\n    return Fp(*this) -= r;\n  }\n\n  constexpr Fp operator*(const Fp &r) const noexcept\n  {\n    return Fp(*this) *= r;\n  }\n\n  constexpr Fp operator/(const Fp &r) const noexcept\n  {\n    return Fp(*this) /= r;\n  }\n\n  constexpr Fp &operator+=(const Fp &r) noexcept\n  {\n    val += r.val;\n    if (val >= MOD)\n      val -= MOD;\n    return *this;\n  }\n\n  constexpr Fp &operator-=(const Fp &r) noexcept\n  {\n    val -= r.val;\n    if (val < 0)\n      val += MOD;\n    return *this;\n  }\n\n  constexpr Fp &operator*=(const Fp &r) noexcept\n  {\n    val = val * r.val % MOD;\n    if (val < 0)\n      val += MOD;\n    return *this;\n  }\n\n  constexpr Fp &operator/=(const Fp &r) noexcept\n  {\n    long long a = r.val, b = MOD, u = 1, v = 0;\n    while (b)\n    {\n      long long t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    val = val * u % MOD;\n    if (val < 0)\n      val += MOD;\n    return *this;\n  }\n\n  constexpr bool operator==(const Fp &r) const noexcept\n  {\n    return this->val == r.val;\n  }\n\n  constexpr bool operator!=(const Fp &r) const noexcept\n  {\n    return this->val != r.val;\n  }\n\n  friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept\n  {\n    return os << x.val;\n  }\n\n  friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept\n  {\n    return is >> x.val;\n  }\n};\n\nFp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept\n{\n  if (n == 0)\n    return 1;\n  auto t = modpow(a, n / 2);\n  t = t * t;\n  if (n & 1)\n    t = t * a;\n  return t;\n}\n\nusing mint = Fp<MOD>;\n\nvoid solve()\n{\n  ll n, a, b;\n  cin >> n >> a >> b;\n  if (a > b)\n    swap(a, b);\n\n  mint dp2[5010][5010] = {};\n  dp2[0][0] = 1;\n  rep(i, b) rep(j, b)\n  {\n    // 0を入れない(1)\n    dp2[i + 1][j + 1] += dp2[i][j];\n    // 0を入れる\n    if (j == 0 && i != 0)\n      dp2[i + 1][j] += dp2[i][j];\n    else if (i + a < 5010)\n      dp2[i + a][0] += dp2[i][j];\n  }\n\n  mint z[5010] = {}; // 1がn個連続しているときの0の入れ方（両端は1で固定）\n  rep(i, b) rep(j, b) z[i + 2] += dp2[i][j];\n  z[0] = z[1] = 1;\n\n  mint dp[5010][2] = {}; // i番目まで見て、最後に何を使ったか\n  dp[0][0] = dp[0][1] = 1;\n  rep(i, n) REP(j, 1, n + 1)\n  {\n    // 0 -> 1\n    if (i + j <= n && j < b)\n    {\n      if (i == 0 || i + j == n)\n        dp[i + j][1] += dp[i][0] * z[j + 1];\n      else\n        dp[i + j][1] += dp[i][0] * z[j];\n    }\n    // 1 -> 0\n    if (i + j <= n && j < a)\n      dp[i + j][0] += dp[i][1];\n  }\n  mint sum = dp[n][0] + dp[n][1];\n  cout << modpow(2, n) - sum << \"\\n\";\n}\n\nint main()\n{\n  init_main();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int P = 1e9 + 7, N = 5010;\nint n, A, B, f[N][2], g[N], h[N];\nint main(){\n\tread(n); read(A); read(B);\n\tif (A > B) swap(A, B);\n\tg[1] = 1;\n\tfor (int i = 2; i <= B; i++){\n\t\tg[i] = g[i - 1];\n\t\tfor (int j = A + 1; j <= i; j++)\n\t\t\tg[i] = (g[i] + g[i - j]) % P;\n\t}\n\th[0] = 1;\n\tfor (int i = 1; i <= B; i++){\n\t\th[i] = h[i - 1];\n\t\tfor (int j = A + 1; j <= i; j++)\n\t\t\th[i] = (h[i] + h[i - j]) % P;\n\t}\n\tf[0][0] = f[0][1] = 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (i != n){\n\t\t\tfor (int j = 1; j <= min(A - 1, i); j++)\n\t\t\t\tf[i][0] = (f[i][0] + f[i - j][1]) % P;\n\t\t\tfor (int j = 1; j <= min(B - 1, i - 1); j++)\n\t\t\t\tf[i][1] = (f[i][1] + 1ll * f[i - j][0] * g[j]) % P;\n\t\t\tif (B > i) f[i][1] = (f[i][1] + 1ll * f[0][0] * h[i]) % P;\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 1; j <= min(A - 1, i); j++)\n\t\t\t\tf[i][0] = (f[i][0] + f[i - j][1]) % P;\n\t\t\tfor (int j = 1; j <= min(B - 1, i); j++)\n\t\t\t\tf[i][1] = (f[i][1] + 1ll * f[i - j][0] * h[j]) % P;\n\t\t}\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= n; i++) ans = ans * 2 % P;\n\tans = (ans - (f[n][0] + f[n][1]) % P + P) % P;\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 5005, P = 1000000007;\n\nint n, A, B;\nint f[N][2], g[N][2];\n\nint main() {\n\tread(n), read(A), read(B);\n\tif (A > B) {\n\t\tstd::swap(A, B);\n\t}\n\tf[0][0] = f[0][1] = 1;\n\tfor (int i = 1; i < B; ++i) {\n\t\tf[i][0] = f[i][1] = 0;\n\t\tfor (int j = A; j <= i; ++j) {\n\t\t\tf[i][0] = (f[i][0] + f[i - j][1]) % P;\n\t\t}\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tf[i][1] = (f[i][1] + f[i - j][0]) % P;\n\t\t}\n\t}\n\tint s = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (i < A) {\n\t\t\tg[i][0] = 1;\n\t\t}\n\t\tfor (int j = 1; j < A && j < i; ++j) {\n\t\t\tg[i][0] = (g[i][0] + g[i - j][1]) % P;\n\t\t}\n\t\tif (i < B) {\n\t\t\tg[i][1] = f[i][1];\n\t\t}\n\t\tfor (int j = 1; j < B && j < i; ++j) {\n\t\t\tg[i][1] = (g[i][1] + 1ll * g[i - j][0] * f[j - 1][1]) % P;\n\t\t}\n\t\tif (n - i < A) {\n\t\t\ts = (s + g[i][1]) % P;\n\t\t}\n\t\tif (n - i < B) {\n\t\t\ts = (s + 1ll * g[i][0] * f[n - i][1]) % P;\n\t\t}\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans = 2ll * ans % P;\n\t}\n\tans = (ans + P - s) % P;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr ll MOD = 1e9+7;\n\ninline ll pw(ll base, ll exp) {\n\tll res = 1;\n\twhile (exp) {\n\t\tif (exp & 1) (res *= base) %= MOD;\n\t\texp >>= 1, (base *= base) %= MOD;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll x) { return pw(x, MOD - 2); }\n\nll F[5005][2], G[5005], DP[5005][2];\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    int N, A, B; cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n\n    if (B == 1) {\n        cout << pw(2, N);\n        return 0;\n    }\n\n    F[0][0] = F[0][1] = 1;\n    for (int i = 1; i <= N; ++i)\n        for (int d : { 0, 1 })\n            for (int j = 1; j <= i; ++j)\n                if (d == 1 || j >= A) (F[i][d] += F[i-j][!d]) %= MOD;\n    \n    G[0] = 1;\n    for (int i = 1; i <= N; ++i) G[i] = F[i][0]+F[i][1];\n\n    ll ans = 0;\n    for (int i = 1; i < N; ++i) {\n        if (i < A) ++DP[i][0];\n        for (int j = 1; j < min(i, A); ++j) (DP[i][0] += DP[i-j][1]) %= MOD;\n        if (i < B) (DP[i][1] += G[i-1]) %= MOD;\n        for (int j = 1; j < min(i, B); ++j) (DP[i][1] += DP[i-j][0]*(j==1?1:G[j-2])) %= MOD;\n        if (N-i < B) (ans += DP[i][0]*G[N-i-1]) %= MOD;\n        if (N-i < A) (ans += DP[i][1]) %= MOD;\n    }\n\n    //for (int i = 0; i <= N; ++i) cout << DP[i][0] << ' ' << DP[i][1] << '\\n';\n    cout << (pw(2, N)-ans+MOD)%MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=5005,Mod=1e9+7;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,a,b,Sum[MAXN],f[MAXN][MAXN],tmp[MAXN][MAXN];\ninline void Add(int&x,int y){x+=y,x>=Mod?x-=Mod:0;}\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),a=read(),b=read();if(a>b)swap(a,b);\n\tf[0][0]=1;\n\tRep(i,0,n){\n\t\tif(i)Add(Sum[i],Sum[i-1]);Add(f[i][1],Sum[i]);\n\t\tRep(j,1,b)Add(f[i][j],tmp[i][j]),Add(tmp[i+1][min(j+1,b)],tmp[i][j]);\n\t\tif(i==n)break;\n\t\tRep(j,0,b-1){\n\t\t\tAdd(f[i+1][j+1],f[i][j]),Add(Sum[i+2],f[i][j]);\n\t\t\tif(i+a+1<=n)Add(Sum[i+a+1],Mod-f[i][j]),Add(tmp[i+a+1][min(j+a+1,b)],f[i][j]);\n\t\t\tif(n-i>=a)Add(f[n][min(n-i+j,b)],f[i][j]);\n\t\t}\n\t}int ans=0;\n\tRep(i,1,n)ans=(ans+1ll*Fp(2,n-i)*f[i][b])%Mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nmint dp[5050][5050][2][2];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,a,b;\n  cin >> n >> a >> b;\n\n  if(a>b) swap(a,b); // a<b\n\n  dp[0][0][1][0] = 1;\n  REP(i,n){\n    REP(j,i+1){\n      dp[i+1][0][0][0] += dp[i][j][0][0]; // 0\n      if(j+1 < b) dp[i+1][j+1][1][0] += dp[i][j][0][0]; // 1\n\n      if(j+1 < b) dp[i+1][j+1][0][1] += dp[i][j][0][1]; // 0\n      if(j+1 < b) dp[i+1][j+1][1][0] += dp[i][j][0][1]; // 1\n\n      dp[i+1][0][0][0] += dp[i][j][1][0]; // 0\n      if(j+1 < b) dp[i+1][j+1][1][0] += dp[i][j][1][0]; // 1\n\n      if(i+a <= n){\n        if(j+a < b) dp[i+a][j+a][0][1] += dp[i][j][1][0]; // A個の0\n        dp[i+a][0][0][0] -= dp[i][j][1][0];\n      }\n    }\n  }\n\n  mint ans = 1;\n  REP(_,n) ans *= 2;\n  REP(i,n+1) REP(j,2) REP(k,2) ans -= dp[n][i][j][k];\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\nconst int N = 5005, P = 1000000007;\nint n, a, b, f[N], ff[N], g[N][2];\nint Pow(ll x, int y){\n\tint ans=1;\n\tfor(; y; y>>=1, x=x*x%P) if(y&1) ans=ans*x%P;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tif(a>b) swap(a, b);\n\tf[1]=1;\n\tfor(int i=1; i<b; ++i){\n\t\t(f[i+1]+=f[i])%=P;\n\t\tfor(int j=a+1; i+j<=b; ++j) (f[i+j]+=f[i])%=P, (ff[i+j-1]+=f[i])%=P;\n\t}\n\tg[0][0]=g[0][1]=1;\n\tfor(int i=0; i<n; ++i){\n\t\t(g[i][1]+=ff[i])%=P;\n\t\tfor(int j=1; j<a && i+j<=n; ++j) (g[i+j][0]+=g[i][1])%=P;\n\t\tfor(int j=1; j<b && i+j<=n; ++j) g[i+j][1]=(g[i+j][1]+(ll)g[i][0]*f[j])%P;\n\t\tg[n][1]=(g[n][1]+(ll)g[i][0]*ff[n-i])%P;\n\t}\n\tprintf(\"%lld\\n\", ((ll)Pow(2, n)-g[n][0]-g[n][1]+P+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\ntemplate<long long Mod>\nstruct mint{\n    long long x;\n    mint(long long x=0) :x((x% Mod+Mod)%Mod){}\n\n    mint operator-() const { return mint(-x); }\n\n    mint& operator+=(const mint a) {\n        if((x += a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if((x += Mod-a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= Mod;\n        return *this;\n    }\n\n    mint operator^(long long t) const {\n        mint ret(1);\n        mint a = *this;\n        while(t){\n            if(t&1){\n                ret *= a;\n            }\n            a *= a;\n            t >>= 1;\n        }\n        return ret;\n    }\n    mint inv() const { return *this ^ (Mod-2); }\n    mint& operator/=(const mint a) { return *this *= a.inv(); }\n\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n\n    friend istream& operator>>(istream& is, mint& a) { return is >> a.x; }\n    friend ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n};\n\nint N, A, B;\n\nbool vis[5001][5001][2][2];\nmint<MOD> dp[5001][5001][2][2];\nmint<MOD> solve(int n, int k, int b, int a){\n    if(n == N){\n        if(a == 1 || k >= A) return 1;\n        else return 0;\n    }\n    if(vis[n][k][b][a]) return dp[n][k][b][a];\n    vis[n][k][b][a] = true;\n    int a2 = a;\n    if(k >= A) a2 = 1;\n    mint<MOD> ret = solve(n+1, k+1, 0, a2);\n    if(b == 0){\n        for(int i=1; n+i<=N; i++){\n            if(i < B){\n                ret += solve(n+i, 0, 1, a2);\n            }\n            else{\n                ret += solve(n+i, k+i, 1, a2);\n            }\n        }\n    }\n    return dp[n][k][b][a] = ret;\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    cout << solve(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 5005;\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nint n, a, b;\nint dp[maxN][2][2];\nint pw2[maxN];\nint ans[maxN][2];\nint real_dp[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> a >> b;\n    if (a < b) swap(a, b);\n    for (int i = 1; i < a; i++) {\n        for (int x = 0; x < 2; x++) {\n            for (int y = 0; y < 2; y++) {\n                if (x == y) {\n                    if (x == 0) {\n                        dp[i][x][y] = 1;\n                    }\n                    if (x == 1 && i >= b) {\n                        dp[i][x][y] = 1;\n                    }\n                }\n                if (y == 1) {\n                    for (int z = b; z < i; z++) {\n                        dp[i][x][y] = sum(dp[i][x][y], dp[i - z][x][y ^ 1]);\n                    }\n                }\n                else {\n                    for (int z = 1; z < i; z++) {\n                        dp[i][x][y] = sum(dp[i][x][y], dp[i - z][x][y ^ 1]);\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        real_dp[i] = dp[i][0][0];\n    }\n    pw2[0] = 1;\n    for (int i = 1; i <= n; i++) pw2[i] = mult(2, pw2[i - 1]);\n    for (int len = 1; len <= n; len++) {\n        for (int en = 0; en < 2; en++) {\n            if (en == 1) {\n                if (len < b) {\n                    ans[len][1] = 1;\n                }\n            }\n            else {\n                ans[len][0] = sum(real_dp[len], dp[len][1][0]);\n            }\n            for (int sz = 1; sz < len; sz++) {\n                if (en == 1) {\n                    if (sz < b) {\n                        ans[len][1] = sum(ans[len][1], ans[len - sz][0]);\n                    }\n                }\n                else {\n                    ans[len][0] = sum(ans[len][0], mult(real_dp[sz], ans[len - sz][1]));\n                }\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        ans[n][1] = sum(ans[n][1], mult(ans[i][1], dp[n - i][0][1]));\n    }\n    cout << sub(pw2[n], sum(ans[n][0], ans[n][1]));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val*m.val%MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 5e3 + 5;\nmi dp[MAX][MAX][2]; // have i placed a big 0 stuff\nint a, b;\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n; cin >> n >> a >> b;\n    if(a<b) swap(a, b);\n    dp[0][0][0] = 1;\n    dp[0][0][1] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < a; j++){\n            for(int last = 0; last < 2; last++){\n                for(int block = 1; block <= a; block++){\n                    if(dp[i][j][last].val == 0) continue;\n                    if(i + block > n) continue;\n                    if(last == 0){\n                        if(block < b){\n                            dp[i + block][0][1] += dp[i][j][last];\n                        }\n                        else{\n                            if(j + block >= a) continue;\n                            dp[i + block][j + block][1] += dp[i][j][last];\n                        }\n                    }\n                    else{\n                        if(j + block >= a) continue;\n                        dp[i + block][j + block][0] += dp[i][j][last];\n                    }\n                }\n            }\n        }\n    }\n    mi ans = 1;\n    for(int i = 0; i < n; i++) ans *= 2;\n    mi sub = 0;\n    for(int j = 0; j < a; j++){\n        for(int last = 0; last < 2; last++){\n            sub += dp[n][j][last];\n        }\n    }\n    ans -= sub;\n    cout << ans.val << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef vector<ll> vll;\n#define INF 0x3f3f3f3f\n#define MOD 1000000007LL\n#define EPS 0.00001\n#define f first\n#define s second\n#define pb push_back\n\n#define FOR(i, a, b) for (int i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (int i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 5005\nint n, a, b;\nll dp1[MN][MN][3]; //0 = run of 0s, 1 = run of 1s. 2 = run of 1s and just came from 0-jump\n//legal moves:\n//0->0, 0->1, 1->0, 1->1, 1->2 via 0-jump, 2->1, 2->2. (can't have two 0-jumps in a row)\nll modExp(ll b, ll ex){\n    ll prod = 1;\n    while(ex > 0){\n        if(ex % 2 == 0){\n            b = (b * b) % MOD;\n            ex /= 2;\n        } else{\n            prod = (prod*b) % MOD;\n            ex--;\n        }\n    }\n    \n    return prod;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> a >> b;\n    if(a > b) swap(a, b);\n    dp1[1][1][0] = dp1[1][1][1] = 1;\n    dp1[a][a][2] = 1;\n    FOR(i, 1, n-1){\n        FOR(j, 1, a-1){\n            //cout << i << \" \" << j << \" 0 \" << dp1[i][j][0] << \"\\n\";\n            dp1[i+1][j+1][0] = (dp1[i+1][j+1][0]+dp1[i][j][0])%MOD;\n            dp1[i+1][1][1] = (dp1[i+1][1][1]+dp1[i+1][j+1][0])%MOD;\n        }\n        FOR(j, 1, b-1){\n            //cout << i << \" \" << j << \" 1 \" << dp1[i][j][1] << \"\\n\";\n            dp1[i+1][j+1][1] = (dp1[i+1][j+1][1]+dp1[i][j][1])%MOD;\n            dp1[i+1][1][0] = (dp1[i+1][1][0]+dp1[i][j][1])%MOD;\n            if(i+a<=n && j+a<b) dp1[i+a][j+a][2] = (dp1[i+a][j+a][2]+dp1[i][j][1])%MOD;\n            //CHECK IF BOUND OBO\n        }\n        FOR(j, 1, b-1){ //state 2\n            //cout << i << \" \" << j << \" 2 \" << dp1[i][j][2] << \"\\n\";\n            dp1[i+1][j+1][2] = (dp1[i+1][j+1][2]+dp1[i][j][2])%MOD;\n            dp1[i+1][j+1][1] = (dp1[i+1][j+1][1]+dp1[i][j][2])%MOD;\n        }\n    }\n    ll ans = 0;\n    FOR(i, 1, a-1){\n        //cout << n << \" \" << i << \" 0 \" << dp1[n][i][0] << \"\\n\";\n        ans = (ans+dp1[n][i][0])%MOD;\n    }\n    FOR(i, 1, b-1){\n        //cout << n << \" \" << i << \" 1 \" << dp1[n][i][1] << \"\\n\";\n        //cout << n << \" \" << i << \" 2 \" << dp1[n][i][2] << \"\\n\";\n        ans = (ans+dp1[n][i][1])%MOD;\n        ans = (ans+dp1[n][i][2])%MOD;\n    }\n    ll fin = modExp(2, n)-ans;\n    fin = (fin+MOD)%MOD;\n    cout << fin << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=5010,mod=1000000007;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\ninline int ksm(int a,int b)\n{\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) res=1ll*res*a%mod;\n\treturn res;\n}\nint N,A,B,f[5010][2],F[5010][2],ans;\ninline int getv(int x){return x<=2?1:(f[x-2][0]+f[x-2][1])%mod;}\nint main()\n{\n\tcin>>N>>A>>B;if(A>B) swap(A,B);f[0][0]=f[0][1]=1;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<=N;j++)\n\t{\n\t\tAdd(f[j][0],f[i][1]);\n\t\tif(j-i>=A) Add(f[j][1],f[i][0]);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tif(i<A) Add(F[i][0],1);\n\t\tif(i<B) Add(F[i][1],getv(i+1));\n\t\tfor(int j=1;j<min(i,A);j++) Add(F[i][0],F[i-j][1]);\n\t\tfor(int j=1;j<min(i,B);j++) Add(F[i][1],1ll*F[i-j][0]*getv(j)%mod);\n\t\tif(N-i<A) Add(ans,F[i][1]);\n\t\tif(N-i<B) Add(ans,1ll*F[i][0]*getv(N-i+1)%mod);\n\t}\n\tcout<<(ksm(2,N)-ans+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(lint)(n);i++)\n#define REP(i,n) for(int i=1;i<=(lint)(n);i++)\n#define all(V) V.begin(),V.end()\n#define lint long long\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = DBL_EPSILON;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, unsigned int b) {\n\tif (!b)return T(1);\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tT memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nint n,a,b;\nModInt<> dp[5010][5010][2][2],sum[5010];\nint main(){\n\tstd::cin>>n>>a>>b;\n\tif(a<b)std::swap(a,b);\n\tModInt<> ans=0;\n\tdp[0][0][0][0]=1;\n\trep(i,n){\n\t\tsum[i]=sum[i-1];\n\t\tif(i-b<0)dp[i][0][1][0]+=sum[i-1];\n\t\telse dp[i][0][1][0]+=sum[i-1]-sum[i-b];\n\t\trep(j,std::min(a,i+1)){\n\t\t\trep(k,2){\n\t\t\t\trep(l,2){\n\t\t\t\t\tif(k!=1&&l!=1)sum[i]+=dp[i][j][k][l];\n\t\t\t\t\tif(j+1<a)dp[i+1][j+1][0][0]+=dp[i][j][k][l];\n\t\t\t\t\telse ans+=dp[i][j][k][l]*mypow(ModInt<>(2),n-i-1);\n\t\t\t\t\tif(l){\n\t\t\t\t\t\tif(j+1<a)dp[i+1][j+1][0][1]+=dp[i][j][k][l];\n\t\t\t\t\t\telse ans+=dp[i][j][k][l]*mypow(ModInt<>(2),n-i-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(i+b<=n&&!k&&!l){\n\t\t\t\t\t\tif(j+b<a)dp[i+b][j+b][0][1]+=dp[i][j][k][l];\n\t\t\t\t\t\telse ans+=dp[i][j][k][l]*mypow(ModInt<>(2),n-(i+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5010, P = 1000000007;\nint n, A, B, ans, pw[maxn], f[maxn][maxn][2], pre[maxn][maxn][2], h[maxn];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &A, &B);\n    if (A < B) swap(A, B);\n    pw[0] = pw[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        pw[i] = (pw[i - 1] + pw[i - 1]) % P;\n    }\n    f[0][0][0] = f[0][0][1] = 1, h[0] = 1;\n    pre[0][0][0] = pre[0][0][1] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            (f[i][j][0] += pre[i - 1][i - j][1]) %= P;\n            if (i >= B) (f[i][j][1] += pre[i - B][i - j][0]) %= P;\n        }\n        for (int j = max(0, i - B + 1); j < i; j++) {\n            (f[i][0][1] += h[j]) %= P;\n        }\n        for (int j = A; j <= i; j++) {\n            int s = 1LL * (f[i][j][0] + f[i][j][1]) * pw[n - i] % P;\n            (ans += s) %= P, f[i][j][0] = f[i][j][1] = 0;\n        }\n        for (int j = 0; j <= i; j++) {\n            (h[i] += f[i][j][0]) %= P;\n            pre[i][i - j][0] = (pre[i - 1][i - j][0] + f[i][j][0]) % P;\n            pre[i][i - j][1] = (pre[i - 1][i - j][1] + f[i][j][1]) % P;\n        }\n    }\n    printf(\"%d\\n\", (ans + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nvoid solve() {\n\tint n, a, b; cin >> n >> a >> b;\n    if(a > b) swap(a, b);\n    static mint dp[5050][5050][2][2];\n    rep(i, 5050) {\n        rep(j, 5050) {\n            rep(k, 2) {\n                rep(l, 2) {\n                    dp[i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    dp[0][0][1][0] = 1;\n    rep(i, n) {\n        for(int j = 0; j <= i; ++ j) {\n            //0\n            if(j + 1 < a) dp[i + 1][j + 1][0][0] += dp[i][j][0][0];\n            \n            if(j + 1 < b && j >= a) dp[i + 1][j + 1][0][1] += dp[i][j][0][1];\n\n            if(j < b && 1 < a) dp[i + 1][1][0][0] += dp[i][j][1][0];\n            if(j < b && j + a < b) dp[i + a][j + a][0][1] += dp[i][j][1][0];\n            //1\n            if(j < a && 1 < b) dp[i + 1][1][1][0] += dp[i][j][0][0];\n            if(j + 1 < b) dp[i + 1][j + 1][1][0] += dp[i][j][0][1];\n            if(j + 1 < b) dp[i + 1][j + 1][1][0] += dp[i][j][1][0];\n        }\n    }\n    mint ans = modpow((mint)2, n);\n    for(int i = 0; i <= n; ++ i) {\n        rep(j, 2) {\n            rep(k, 2) {\n                ans -= dp[n][i][j][k];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=5005,MOD=1000000007;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\n\nint n,A,B,g[MAXN],f[MAXN][MAXN][2];\n\nint main()\n{\n\treadint(n),readint(A),readint(B);\n\tif(A>B)swap(A,B);\n\tif(A==1)return 0*printf(\"%d\\n\",qmi(2,n));\n\tg[1]=g[2]=1;\n\tfor(int i=3;i<=n+2;++i)\n\t{\n\t\tg[i]=g[i-1];\n\t\tfor(int j=A+1;j<i;++j)\n\t\t\tg[i]=dmy(g[i]+g[i-j]);\n\t}\n\tf[1][1][0]=f[1][1][1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\tif(j>=A)f[i][j][0]=0;\n\t\t\telse if(j>1)f[i][j][0]=f[i-1][j-1][0];\n\t\t\telse for(int k=1;k<i;++k)f[i][j][0]=(f[i][j][0]+1ll*f[i-1][k][1]*(i-1==k?g[k+1]:g[k]))%MOD;\n\t\t\tif(j>=B)f[i][j][1]=0;\n\t\t\telse if(j>1)f[i][j][1]=f[i-1][j-1][1];\n\t\t\telse for(int k=1;k<i;++k)f[i][j][1]=dmy(f[i][j][1]+f[i-1][k][0]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=1;j<=n+1;++j)ans=(ans+f[n][j][0]+1ll*f[n][j][1]*(n==j?g[j+2]:g[j+1]))%MOD;\n\tprintf(\"%d\\n\",dmy(qmi(2,n)-ans+MOD));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nint n, a, b;\n\nvector<string> moves(string s, int a, int b) {\n\tvector<string> rez;\n\t// for (int i = 0; i <= le(s) - a; i++) {\n\t\tfor (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < a; k++) {\n\t\t\t// \tt[i + k] = '0';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\tt[j + k] = '1';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t}\n\t// }\n\tfor (int i = 0; i <= le(s) - a; i++) {\n\t\t// for (int j = 0; j <= le(s) - b; j++) {\n\t\t\tstring t = s;\n\t\t\t// for (int k = 0; k < b; k++) {\n\t\t\t// \tt[j + k] = '1';\n\t\t\t// }\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tt[i + k] = '0';\n\t\t\t}\n\t\t\trez.pb(t);\n\t\t// }\n\t}\n\treturn rez;\n}\n\nint bfs(int n, int a, int b) {\n\tdeque<string> deq{string(n, '0')};\n\tset<string> used;\n\twhile (!deq.empty()) {\n\t\tstring s = deq[0];\n\t\tdeq.pop_front();\n\t\tif (used.count(s)) continue;\n\t\tused.insert(s);\n\t\tfor (string t : moves(s, a, b)) {\n\t\t\tdeq.pb(t);\n\t\t}\n\t}\n\t// for (string s : used) {\n\t// \tif (s.back() == '1' && s[le(s) - 2] == '0') {\n\t// \t\tprint s;\n\t// \t}\n\t// }\n\t// print used;\n\treturn le(used);\n}\n\nint mem[2][5010][5010];\nnum dp(int n, int l, bool can_one) {\n\tif (n < 0) return 0;\n\tif (n == 0) return l >= a;\n\tif (l >= a) return num(2).pow(n + can_one - 1);\n\tif (mem[can_one][n][l] != -1) return mem[can_one][n][l];\n\tnum rez = 0;\n\tif (can_one) {\n\t\tfor (int ones = 1; ones <= n; ones++) {\n\t\t\tif (ones < b) {\n\t\t\t\trez += dp(n - ones, 0, false);\n\t\t\t} else {\n\t\t\t\trez += dp(n - ones, l + ones, false);\n\t\t\t}\n\t\t}\n\t}\n\trez += dp(n - 1, l + 1, true);\n\tmem[can_one][n][l] = rez.value;\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tscan n, a, b;\n\tif (a < b) swap(a, b);\n\tprint dp(n, 0, true);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    ll dp[n+1][n+1];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    ll sum1[n+1];\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    ll sum2[n+1][n+1];\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                if(i<a[1]+1)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,i+1){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    /*rep(i,0,n+1){\n        rep(j,0,n+1)cout<<dp[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n#define int ll\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nint is_ok(int now) {\n    int cnts[10] = {};\n    while (now != 0) {\n        cnts[now % 10]++;\n        if (cnts[now % 10] == 2) return false;\n        now /= 10;\n    }\n    return true;\n}\nint is_Prime(int now) {\n    if (now == 1) return false;\n    for (int i = 2; i * i <= now; ++i) {\n        if (now % i == 0) return false;\n    }\n    return true;\n}\nclass EllysDifferentPrimes {\npublic:static int getClosest(int n) {\n    REP(q, 1e9) {\n        if (n - q > 0 and is_ok(n - q) == 1 and is_Prime(n - q) == 1) {\n            return n - q;\n        }\n        if (is_ok(n + q) == 1 and is_Prime(n + q) == 1) {\n            return n + q;\n        }\n    }\n    return -1;\n}\n};\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = ((this->data[i][0]) * (obj.data[0][q]));\n                for (int t = 1; t < obj.data.size(); ++t) {\n                    hoge += ((this->data[i][t]) * obj.data[t][q]);\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back(edge{ to, cap, cost, (int)graph[to].size(), false });\n        graph[to].emplace_back(edge{ from, 0, -cost, (int)graph[from].size() - 1, true });\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int)graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge& e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge& e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto& e : graph[i]) {\n                if (e.isrev) continue;\n                auto& rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\n\n#define int ll\nmodint<MAX_MOD> dp[5001];\nmodint<MAX_MOD> two[10000];\nvoid solve(){\n    two[0] = 1;\n    for (int q = 1; q < 10000; ++q) {\n        two[q] = two[q - 1] * 2;\n    }\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n\n    dp[0] = 1;\n    dp[1] = MAX_MOD - 1;\n    modint<MAX_MOD> ans = 0;\n    REP(i, n) {\n        dp[i + 1] += dp[i];\n        modint<MAX_MOD> geko[10001] = {};\n        geko[i] += dp[i];\n        geko[i + 1] -= dp[i];\n        for (int q = i; q <= n+1; ++q) {\n            geko[q + 1] += geko[q];\n            if (min(q,n) - max(i - 1LL, 0LL) >= b) {\n                ans += geko[q] * two[max(n - q, 0LL)];\n                continue;\n            }\n            if (q != n) {\n                //next -> white\n                geko[q + 1] += geko[q];\n                geko[q + 2] -= geko[q];\n            }\n            dp[q + 1 + 1] += geko[q];\n            dp[q + a + 1] -= geko[q];\n            /*\n            for (int red = 1; red < a; ++red) {\n                dp[q + red + 1] += geko[q];\n            }\n            */\n            geko[q + a + 1] += geko[q];\n        }\n    }\n    cout << ans << endl;\n}\n#undef int \nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\ninline ll fast_pow(ll a,ll b,ll p){\n\tll t=1;\n\twhile (b){\n\t\tif (b&1ll) t=t*a%p;\n\t\tb>>=1ll;a=a*a%p;\n\t}\n\treturn t;\n}\nll n,A,B,dp[5050][2],g[5050][2],h[5050];\ninline void add(ll &a,const ll &b){a=(a+b)%ljc;}\nsigned main(){\n\tn=read(),A=read(),B=read();\n\tif (A<B) swap(A,B);\n\tif (B==1||A==1){\n\t\tprintf(\"%lld\\n\",fast_pow(2,n,ljc));\n\t\treturn 0;\n\t}\n\tg[0][0]=g[0][1]=h[0]=1;\n\tfor (int i=1;i<=A;i++){\n\t\tfor (int j=1;j<=i;j++) add(g[i][0],g[i-j][1]);\n\t\tfor (int j=B;j<=i;j++) add(g[i][1],g[i-j][0]);\n\t\th[i]=(g[i][0]+g[i][1])%ljc;\n\t}\n\tdp[0][0]=dp[0][1]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=i&&j<B;j++){\n\t\t\tadd(dp[i][1],dp[i-j][0]);\n\t\t}\n\t\tfor (int j=1;j<=i&&j<A;j++){\n\t\t\tif (i==j) add(dp[i][0],h[j-1]);\n\t\t\telse if (i!=n) add(dp[i][0],(j>1?h[j-2]:1)*dp[i-j][1]%ljc);\n//\t\t\tif (i==n) add(dp[i][1],(j>1?h[j-2]:0)*dp[i-j][1]%ljc);\n\t\t\telse add(dp[i][0],h[j-1]*dp[i-j][1]%ljc);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(fast_pow(2,n,ljc)-dp[n][0]-dp[n][1]+ljc+ljc)%ljc);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=5005;\nconst int MOD=1000000007;\nint n,a,b;\nlong long f[N][2];\nlong long g[N];\nlong long dp[N][2];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a>b) swap(a,b);\n\tif(b==1)\n\t{\n\t\tprintf(\"%lld\",ksm(2,n));\n\t\treturn 0;\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t\tf[i][1]=(f[i][1]+f[j][0])%MOD;\n\t\tfor(int j=0;j+a<=i;j++)\n\t\t\tf[i][0]=(f[i][0]+f[j][1])%MOD;\n\t}\n\tg[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tg[i]=(f[i][0]+f[i][1])%MOD;\n\tlong long ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<a) dp[i][0]=(dp[i][0]+1)%MOD;\n\t\tfor(int j=max(i-a+1,1);j<i;j++)\n\t\t\tdp[i][0]=(dp[i][0]+dp[j][1])%MOD;\n\t\tif(i<b) dp[i][1]=(dp[i][1]+g[i-1])%MOD;\n\t\tfor(int j=max(i-b+1,1);j<i;j++)\n\t\t\tdp[i][1]=(dp[i][1]+dp[j][0]*(i-j==1?1:g[i-j-2])%MOD)%MOD;\n\t\tif(i+b-1>=n) ans=(ans+dp[i][0]*g[n-i-1]%MOD)%MOD;\n\t\tif(i+a-1>=n) ans=(ans+dp[i][1])%MOD;\n\t}\n\tprintf(\"%lld\",(ksm(2,n)-ans+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  P operator-() const {\n    P res((*this).size());\n    rep(i, (*this).size()) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, (*this).size()) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q) {\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  // P &div(map<int, T> q) {\n  //   rep(i, (*this).size()) {\n  //     for (auto &b : q) if (b.first != 0 && b.first <= i) (*this)[i] -= b.second * (*this)[i-b.first];\n  //     (*this)[i] /= q[0];\n  //   }\n  //   return *this;\n  // }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div({{0, 1}, {1, -1}});\n  q[1] = 1;\n  q.div({{0, 1}, {1, -1}});\n  f[1] = 1;\n  f[a] -= 1;\n  f.div({{0, 1}, {1, -1}});\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+2) g0[i] = 0;\n  rep2(i, b, n+2) g1[i] = 0;\n  rep2(i, b, n+2) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int N=5005,mod=1e9+7;\nint n,A,B,f[N][N][2],sum1[N][N][2],sum2[N][N][2],ans;\n//sum1[i][j][o] = sigma f[i][s][o] (s<=j)\n//sum2[i][j][o] = sigma f[i+s][s][o] (s<=j)\nint qpow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=(LL)res*x%mod;\n\t\tx=(LL)x*x%mod, y>>=1;\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(A>B) swap(A,B);\n\tf[0][0][0]=1, f[0][0][1]=1;\n\tfor(int i=0;i<=n;++i) {\n\t\tif(i) {\n\t\t\tfor(int j=1;j <= i && j < B;++j) {\n\t\t\t\tif(j < A) f[i][j][0]=sum1[i-j][i-j][1];\n\t\t\t\tif(j >= A) f[i][j][0]=sum2[i-j][j-A][1];\n\t\t\t\tf[i][j][1]=sum1[i-j][min(A-1,i-j)][0];\n\t\t\t\tif(j >= A)\n\t\t\t\t\tf[i][j][1]=((LL)f[i][j][1]+sum2[i-j][j-1][0]+mod-sum2[i-j][A-1][0])%mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=i;++j) for(int o=0;o<2;++o) {\n\t\t\tsum1[i][j][o]=(sum1[i][j-1][o]+f[i][j][o])%mod;\n\t\t\tsum2[i-j][j][o]=(sum2[i-j][j-1][o]+f[i][j][o])%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) ans=(ans+f[n][i][0])%mod, ans=(ans+f[n][i][1])%mod;\n\tans=(qpow(2,n)+mod-ans)%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nlint mo=1000000007;\nlint zyo[5010];\nlint dp[5010][5010][3];\nint main()\n{\n\tzyo[0]=1;\n\trep(i,5005) zyo[i+1]=(zyo[i]*2)%mo;\n\tmemset(dp,0,sizeof(dp));\n\tint n,a,b;cin>>n>>a>>b;\n\tif(a<b) swap(a,b);\n\tif(b==1){\n\t\tcout<<zyo[n]<<endl;return 0;\n\t}\n\tdp[1][1][0]=1;\n\tdp[1][1][1]=1;\n\tdp[b][b][2]=1;\n\tlint out=0;\n\trep(i,n+1) rep(j,i+1){\n\t\trep(k,3) dp[i][j][k]%=mo;\n\t\tif(j>=a){\n\t\t\trep(k,3){\n\t\t\t\tout+=dp[i][j][k]*zyo[n-i];\n\t\t\t\tout%=mo;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(i>=n) continue;\n\t\t\n\t\tdp[i+1][1][1]+=dp[i][j][0];\n\t\tif(j<b-1){\n\t\t\tdp[i+1][j+1][0]+=dp[i][j][0];\n\t\t}\n\t\t\n\t\tdp[i+1][j+1][1]+=dp[i][j][1];\n\t\tdp[i+1][1][0]+=dp[i][j][1];\n\t\tif(i+b<=n) dp[i+b][j+b][2]+=dp[i][j][1];\n\t\t\n\t\tdp[i+1][j+1][1]+=dp[i][j][2];\n\t\tdp[i+1][j+1][2]+=dp[i][j][2];\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n#include <algorithm>\n#include <utility>\n#include <type_traits>\n#include <cstdint>\n//永夜作\n#define mnt mint_base\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\nint main(void){\n\tint i,j,k,n,A,B;cin>>n>>A>>B;\n\tif(A>B){swap(A,B);}\n\t\n\t//できない数をカウントする\n\t\n\t\n\t\n\tstatic mint_base dp[5015][5015]={};\n\tstatic mint_base ep[5015][5015]={};\n\tmint_base wa[5015]={};\n\tmint_base ans=0;\n\tdp[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tmint_base aaa=0;\n\t\twa[i+1]+=wa[i];\n\t\tdp[i][1]+=wa[i];\n\t\tfor(j=0;j<B;j++){\n\t\t\t\n\t\t\tdp[i][j]+=ep[i][j];\n\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t\tep[i+1][j+1]+=ep[i][j];\n\t\t\tdp[i+1][j+1]+=dp[i][j];//1\n\t\t\tif(i>0&&j==0){continue;}\n\t\t\taaa+=dp[i][j];\n\t\t\tif(i+A+1<=n+5&&j+A+1<=n+5){ep[i+A+1][j+A+1]+=dp[i][j];}\n\t\t}\n\t\t//cout<<endl;\n\t\t//cout<<aaa<<endl;\n\t\twa[i+2]+=aaa;\n\t\twa[i+A+1]-=aaa;\n\t\t\n\t}\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<B;j++){\n\t\t\tif(n-i+j<B||n-i<A){ans+=dp[i][j];}\n\t\t}\n\t}\n\tmint_base eee=1;\n\tfor(i=0;i<n;i++){eee*=2;}\n\tcout<<eee-ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N,A,B;\n\nmint dp1[5100][5100][2];\nbool used1[5100][5100][2];\n//mint func1(int i, int a_len, int fin)\n//{\n//\tif (a_len >= A) {\n//\t\tfin = 1;\n//\t}\n//\tif (fin != 0) {\n//\t\ta_len = 0;\n//\t}\n//\tif (i == N) {\n//\t\tif (fin != 0) {\n//\t\t\treturn 1_mi;\n//\t\t}\n//\t\treturn 0_mi;\n//\t}\n//\n//\tauto& memo = dp1[i][a_len][fin];\n//\tif (used1[i][a_len][fin]) {\n//\t\treturn memo;\n//\t}\n//\tused1[i][a_len][fin] = true;\n//\n//\treturn memo = func1(i + 1, a_len + 1, fin) + func1(i + 1, 0, fin);\n//}\n\n\n\nmint pow2[5100];\nmint dp5[5100][5100];\nbool used5[5100][5100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[5100][5100][2];\nbool used4[5100][5100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\tif (i >= N) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, std::min(i + B,N));\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n//Aは[a_end-A, a_end), Bは[b_end-B, b_end)\nmint func(int i, int a_end, int b_end)\n{\n\tstatic mint dp[100][100][100];\n\tstatic bool used[100][100][100];\n\tif (N+1 <= a_end || N + 1 <= b_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i && b_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][b_end];\n\tif (used[i][a_end][b_end]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][b_end] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\tif (i < b_end) {//Bの中\n\t\tres += func(i + 1, i + A, 0);//0を置く\n\t\tres += func(i + 1, a_end, b_end);//1を置く\n\t}\n\telse if (B <= b_end && i == b_end) {//Bの終わった直後\n\t\tres += func(i + 1, a_end, b_end);//0を置く\n\t\tres += func(i + 1, a_end, b_end+1);//1を置く\n\t}\n\telse {//Aの中\n\t\tres += func(i + 1, a_end, b_end);//0を置く\n\t\tres += func(i + 1, a_end, i + B);//1を置く\n\t}\n\treturn memo = res;\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\tif (A == 1) {\n\t\tout << pow2[N] << endl;\n\t\treturn 0;\n\t}\n\tif (N < 90) {\n\t\tout << func(0, A, 0) << endl;\n\t\treturn 0;\n\t}\n\n\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt dp[5005][5005];\nInt dpxsum[5005][5005];\nInt dpysum[5005][5005];\nInt pow2[5005];\nInt ans;\nint main() {\n    Int n, a, b;\n    cin >> n >> a >> b;\n    if (a < b)\n        swap(a, b);\n\n    pow2[0] = 1;\n    for (int i = 1; i <= n; i++)\n        pow2[i] = pow2[i - 1] * 2 % MOD;\n    if (a == 1 && b == 1) {\n        cout << pow2[n] << endl;\n        return 0;\n    }\n    ans = 1;\n    for (int i = 1; i <= n; i++) {\n        if (i - 1 < b)\n            dp[i][i] = 1;\n        else\n            dp[i][i] = 0;\n        for (Int jlen = 1; jlen < b; jlen++) {\n            if (i - jlen - 1 < 1)\n                continue;\n            Int oklen_max = min(i - jlen, a);\n            dp[i][i] += dpxsum[i - jlen - 1][i - jlen - 1] -\n                        dpxsum[i - jlen - oklen_max][i - jlen - 1];\n            dp[i][i] %= MOD;\n            /*            for (Int oklen = 1; oklen < min(i - jlen, a); oklen++)\n               { dp[i][i] += dp[i - jlen - oklen][i - jlen - 1];\n                            }*/\n        }\n\n        (dpxsum[i][i] = dpxsum[i - 1][i] + dp[i][i]) %= MOD;\n        (dpysum[i][i] = dpysum[i][i - 1] + dp[i][i]) %= MOD;\n        for (int j = i + 1; j <= n; j++) {\n            if (i == 1 && j - i >= b)\n                dp[i][j]++;\n            dp[i][j] += dp[i][j - 1];\n            Int jlen_min = b, jlen_max = j - i;\n            if (jlen_min < jlen_max)\n                dp[i][j] +=\n                    dpysum[i][j - jlen_min - 1] - dpysum[i][j - jlen_max - 1];\n            /*            for (int jlen = b; j - jlen - 1 >= i; jlen++) {\n                            dp[i][j] += dp[i][j - jlen - 1];\n                            }*/\n            dp[i][j] %= MOD;\n            if (j - i + 1 >= a) {\n                ans += dp[i][j] * pow2[n - j];\n                ans %= MOD;\n                //                cout << i << \" \" << j << \" \" << dp[i][j] <<\n                //                endl;\n                dp[i][j] = 0;\n            }\n            (dpxsum[i][j] = dpxsum[i - 1][j] + dp[i][j]) %= MOD;\n            (dpysum[i][j] = dpysum[i][j - 1] + dp[i][j]) %= MOD;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (n - i + 1 >= a && n - j >= b) {\n                (ans += dp[i][j]) %= MOD;\n                //                cout << i << \" \" << j << \" \" << dp[i][j] <<\n                //                endl;\n            }\n            //            cout << dp[i][j] << \" \";\n        }\n        //        cout << endl;\n    }\n    if (ans < 0)\n        ans += MOD;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); ++i)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); --i)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); ++i)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define dec(i, n)  decID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define SI(v) static_cast<int>(v.size())\n#define RF(e, v) for(auto & e: v)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\n#define IN(T, ...) T __VA_ARGS__; IN_(__VA_ARGS__);\nvoid IN_() { };\ntemplate<typename T, typename ... U> void IN_(T &  a, U &  ... b) { cin >> a; IN_(b ...); };\ntemplate<typename T                > void OUT(T && a            ) { cout << a << endl; }\ntemplate<typename T, typename ... U> void OUT(T && a, U && ... b) { cout << a << \" \"; OUT(b ...); }\n\n// ---- ----\n\ntemplate<LL M> class ModInt {\nprivate:\n\tLL v;\n\tpair<LL, LL> ext_gcd(LL a, LL b) {\n\t\tif(b == 0) { assert(a == 1); return { 1, 0 }; }\n\t\tauto p = ext_gcd(b, a % b);\n\t\treturn { p.SE, p.FI - (a / b) * p.SE };\n\t}\npublic:\n\tModInt(LL vv = 0) { v = vv; if(abs(v) >= M) { v %= M; } if(v < 0) { v += M; } }\n\tLL get_v() { return v; }\n\tModInt inv() { return ext_gcd(M, v).SE; }\n\tModInt exp(LL b) {\n\t\tModInt p = 1, a = v; if(b < 0) { a = a.inv(); b = -b; }\n\t\twhile(b) { if(b & 1) { p *= a; } a *= a; b >>= 1; }\n\t\treturn p;\n\t}\n\tfriend bool      operator< (ModInt    a, ModInt   b) { return (a.v <  b.v); }\n\tfriend bool      operator> (ModInt    a, ModInt   b) { return (a.v >  b.v); }\n\tfriend bool      operator<=(ModInt    a, ModInt   b) { return (a.v <= b.v); }\n\tfriend bool      operator>=(ModInt    a, ModInt   b) { return (a.v >= b.v); }\n\tfriend bool      operator==(ModInt    a, ModInt   b) { return (a.v == b.v); }\n\tfriend bool      operator!=(ModInt    a, ModInt   b) { return (a.v != b.v); }\n\tfriend ModInt    operator+ (ModInt    a            ) { return ModInt(+a.v); }\n\tfriend ModInt    operator- (ModInt    a            ) { return ModInt(-a.v); }\n\tfriend ModInt    operator+ (ModInt    a, ModInt   b) { return ModInt(a.v + b.v); }\n\tfriend ModInt    operator- (ModInt    a, ModInt   b) { return ModInt(a.v - b.v); }\n\tfriend ModInt    operator* (ModInt    a, ModInt   b) { return ModInt(a.v * b.v); }\n\tfriend ModInt    operator/ (ModInt    a, ModInt   b) { return a * b.inv(); }\n\tfriend ModInt    operator^ (ModInt    a, LL       b) { return a.exp(b); }\n\tfriend ModInt  & operator+=(ModInt  & a, ModInt   b) { return (a = a + b); }\n\tfriend ModInt  & operator-=(ModInt  & a, ModInt   b) { return (a = a - b); }\n\tfriend ModInt  & operator*=(ModInt  & a, ModInt   b) { return (a = a * b); }\n\tfriend ModInt  & operator/=(ModInt  & a, ModInt   b) { return (a = a / b); }\n\tfriend ModInt  & operator^=(ModInt  & a, LL       b) { return (a = a ^ b); }\n\tfriend istream & operator>>(istream & s, ModInt & b) { s >> b.v; b = ModInt(b.v); return s; }\n\tfriend ostream & operator<<(ostream & s, ModInt   b) { return (s << b.v); }\n};\n\n// ----\n\nusing MI = ModInt<1'000'000'007>;\n\ntemplate<typename T> T MV(T v) { return v; }\ntemplate<typename T, typename ... U> auto MV(T v, int a, U ... b) { return vector<decltype(MV(v, b ...))>(a, MV(v, b ...)); }\n\nint main() {\n\tIN(int, n, a, b);\n\tif_not(a <= b) { swap(a, b); }\n\t\n\tif(a == 1) { OUT(MI(2) ^ n); exit(0); }\n\t\n\tMI ans = 0, s = 1, t = 1;\n\tauto dp_ = MV<MI>(0, n + a + 1, n + b + 1);\n\tdp_[n][n] = 1;\n\tdecII(k, 0, n) {\n\t\tauto dp = [&](int i, int j) -> MI & { return dp_[k + i][k + j]; };\n\t\t\n\t\tans += (dp(0, b) + dp(a, b)) * (MI(2) ^ k);\n\t\ts -= dp(0, b) + dp(a, b);\n\t\tt -= dp(0, b);\n\t\tdp(0, b) = 0;\n\t\tincID(i, 1, a) { dp(i, b - 1) += dp(i, b); }\n\t\t\n\t\tif(k == 0) { break; }\n\t\t\n\t\tMI u = 0, tt = 0;\n\t\tinc(j, b) {\n\t\t\tMI v = dp(0, j) + dp(a, j);\n\t\t\tdp(-1, j) += v;\n\t\t\ttt += v;\n\t\t\t\n\t\t\tdp(a - 1, j) += dp(a, j);\n\t\t\tu += dp(a, j);\n\t\t}\n\t\tdp(-1, 0) += s - (t + u);\n\t\ttt += s - (t + u);\n\t\t\n\t\ts *= 2;\n\t\tt = tt;\n\t}\n\tOUT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 5005\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll way[SIZE];\nll way2[SIZE];\nll way3[SIZE];\nll dp[SIZE][2];\n\nint main()\n{\n\tint n,A,B;\n\tscanf(\"%d %d %d\",&n,&A,&B);\n\tif(A>B) swap(A,B);\n\tfor(int i=1;i<B;i++)\n\t{\n\t\tway[i]=1;\n\t\tfor(int j=1;j+A+1<=i;j++)\n\t\t{\n\t\t\tll vl=way[j]*(ll) (i-j-A)%MOD;\n\t\t\tway[i]+=vl;\n\t\t\tif(way[i]>=MOD) way[i]-=MOD;\n\t\t}\n\t}\n\tfor(int i=1;i<B;i++)\n\t{\n\t\tway3[i]=0;\n\t\tfor(int j=A;j<i;j++)\n\t\t{\n\t\t\tway3[i]+=way[i-j];\n\t\t\tif(way3[i]>=MOD) way3[i]-=MOD;\n\t\t}\n\t}\n\tway2[0]=1;\n\tfor(int i=1;i<B;i++)\n\t{\n\t\tway2[i]=0;\n\t\tfor(int j=0;j+A+1<=i;j++)\n\t\t{\n\t\t\tll vl=way2[j]*(ll) (i-j-A)%MOD;\n\t\t\tway2[i]+=vl;\n\t\t\tif(way2[i]>=MOD) way2[i]-=MOD;\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<B;i++) dp[i][1]=way2[i];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(j-i<B)\n\t\t\t{\n\t\t\t\tdp[j][1]+=dp[i][0]*way[j-i]%MOD;\n\t\t\t\tif(dp[j][1]>=MOD) dp[j][1]-=MOD;\n\t\t\t}\n\t\t\tif(j-i<A)\n\t\t\t{\n\t\t\t\tdp[j][0]+=dp[i][1];\n\t\t\t\tif(dp[j][0]>=MOD) dp[j][0]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=(dp[n][0]+dp[n][1])%MOD;\n\tfor(int i=A;i<n;i++)\n\t{\n\t\tret+=dp[n-i][0]*way3[i]%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\tll all=1;\n\tfor(int i=0;i<n;i++) all=all*2LL%MOD;\n\tprintf(\"%lld\\n\",(all-ret+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (long long) val*m.val%MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 5e3 + 5;\nmi dp[MAX][MAX][2]; // have i placed a big 0 stuff\nmi prefix[MAX][2*MAX][2]; // sum for up to i, difference is j, last is last\nmi sum[MAX][2];\nint a, b;\nmi prefix_sum(int l, int r, int diff, int last){\n    if(r < 0) return 0;\n    if(l > r) return 0;\n    if(l <= 0) return prefix[r][diff][last];\n    return prefix[r][diff][last] - prefix[l - 1][diff][last];\n}\nmi sum_sum(int l, int r, int last){\n    if(r < 0) return 0;\n    if(l > r) return 0;\n    if(l <= 0) return sum[r][last];\n    return sum[r][last] - sum[l - 1][last];\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n; cin >> n >> a >> b;\n    if(a<b) swap(a, b);\n    sum[0][1] = 1;\n    sum[0][0] = 1;\n    prefix[0][MAX][0] = 1;\n    prefix[0][MAX][1] = 1;\n    for(int i = 1; i <= n; i++){\n        for(int last = 0; last < 2; last++){\n            sum[i][last] = sum[i - 1][last];\n        }\n        for(int j = 0; j < 2 * MAX; j++){\n            for(int last = 0; last < 2; last++){\n                prefix[i][j][last] = prefix[i - 1][j][last];\n            }\n        }\n        for(int j = 0; j < a; j++){\n            for(int last = 0; last < 2; last ++){\n                if(last == 0){\n                    dp[i][j][last] = prefix_sum(i - min(a - 1, j), i - 1, i - j + MAX, last ^ 1);\n                }\n                else{\n                    if(j == 0){\n                        dp[i][j][last] = sum_sum(i - b + 1, i - 1, last ^ 1);\n                    }\n                    else{\n                        dp[i][j][last] = prefix_sum(i - min(a - 1, j), i - b, i - j + MAX, last ^ 1);\n                    }\n                }\n                sum[i][last] += dp[i][j][last];\n                prefix[i][i - j + MAX][last] += dp[i][j][last];\n            }\n        }\n    }\n    mi ans = 1;\n    for(int i = 0; i < n; i++) ans *= 2;\n    mi sub = 0;\n    for(int j = 0; j < a; j++){\n        for(int last = 0; last < 2; last++){\n            sub += dp[n][j][last];\n        }\n    }\n    ans -= sub;\n    cout << ans.val << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\nmt19937 R(chrono::system_clock().now().time_since_epoch().count());\n\nconst int N = 1<<18|3, mo = 1e9+7, inv2 =(mo+1)/2;\nconst ll MOD=7LL*mo*mo;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\n\nint fac[N],ifac[N];\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint n,a,b,f[2][N],dp[N],dp2[N];\n\nint main() {\n\tread(n);read(a);read(b);iniC(N-1);\n\tif(a<b)swap(a,b);//a>=b\n\t\n\tf[1][0]=1;\n\trep(i,1,n){\n\t\trep(j,0,i-1)add(f[0][i],f[1][j]);\n\t\trep(k,0,i-b)add(f[1][i],f[0][k]);\n\t\tdp[i]=(f[0][i])%mo;\n\t\tdp2[i]=(f[1][i])%mo;//f[0][i]+\n\t}\n\tmemset(f,0,sizeof(f));\n\t\n\trep(i,0,1)f[i][0]=1;\n\trep(i,1,n){\n\t\trep(k,max(0,i-a+1),i-1){\n\t\t\tadd(f[0][i],1ll*f[1][k]*dp[i-k]%mo);\n\t\t\tif(i==n||k==0)add(f[0][i],1ll*f[1][k]*dp2[i-k]%mo);\n\t\t}\n\t\trep(k,max(0,i-b+1),i-1)add(f[1][i],f[0][k]);\n\t}\n\tint res=((power(2,n)-f[0][n]-f[1][n])%mo+mo)%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nconst int N=5005;\nint n,A,B;\nint dp[N][N];\nint s1[N][N],s2[N][N];\nint pw2[N];\nint main(){\n\tn=read(),A=read(),B=read();\n\tpw2[0]=1;\n\tFor(i,1,n+1)\n\t\tpw2[i]=Add(pw2[i-1]<<1);\n\tif (A<B)\n\t\tswap(A,B);\n\tdp[0][0]=1;\n\tint ans=0;\n\tFor(i,0,n-1)\n\t\tFor(j,0,i){\n\t\t\tint &v=dp[i][j];\n\t\t\tif (i>0)\n\t\t\t\tAdd(s1[i][j],s1[i-1][j]);\n\t\t\tAdd(v,s1[i][j]);\n\t\t\tif (i>0&&j>0)\n\t\t\t\tAdd(s2[i][j],s2[i-1][j-1]);\n\t\t\tAdd(v,s2[i][j]);\n//\t\t\tprintf(\"dp[%d][%d]=%d\\n\",i,j,v);\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tint L=0,R=n-i-1;\n\t\t\tif (j+1>=A)\n\t\t\t\tAdd(ans,(LL)v*pw2[n-i-1]%mod);\n\t\t\telse\n\t\t\t\tAdd(dp[i+1][j+1],v);\n\t\t\tL=1;\n\t\t\tint b=max(L-1,min(B-1,R));\n\t\t\tAdd(s1[i+L+1][1],v);\n\t\t\tDel(s1[i+b+2][1],v);\n\t\t\tL=b+1;\n\t\t\tif (L<=R){\n\t\t\t\tint a=min(R+1,max(L,A-j-1));\n\t\t\t\t//[a~R]\n\t\t\t\tif (a<=R){\n\t\t\t\t\t//pw2[n-i-1-R]+..+pw2[n-i-1-a]\n\t\t\t\t\tint x=n-i-1-R,y=n-i-1-a;\n\t\t\t\t\tAdd(ans,(LL)v*Del(pw2[y+1]-pw2[x])%mod);\n\t\t\t\t}\n\t\t\t\tR=a-1;\n\t\t\t\tif (L<=R){\n\t\t\t\t\tAdd(s2[i+L+1][j+L+1],v);\n\t\t\t\t\tDel(s2[i+R+2][j+R+2],v);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tFor(k,0,n-i-1){\n//\t\t\t\tif (0<k&&k<B)\n//\t\t\t\t\tAdd(dp[i+k+1][1],v);\n//\t\t\t\telse if (j+k+1>=A)\n//\t\t\t\t\tAdd(ans,(LL)v*Pow(2,n-i-k-1)%mod);\n//\t\t\t\telse\n//\t\t\t\t\tAdd(dp[i+k+1][j+k+1],v);\n//\t\t\t}\n\t\t\tif (n-i>=B&&j+n-i>=A)\n\t\t\t\tAdd(ans,v);\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=5010;\n\nll n, A, B, u, v, x, y, t, a, b, ans;\nll dp[MAXN][MAXN], sum[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n>>A>>B;\n\tif (A>B) swap(A, B);\n\tdp[0][0]=sum[0]=1;\n\tfor (int i=1; i<=n; i++){\n\t\tfor (int x=2; x<=A && x<=i; x++)\n\t\t\tdp[i][0]=(dp[i][0] + sum[i-x] - dp[i-x][B-1])%mod;\n\t\tif (i<A) dp[i][0]++;\n\t\t\n\t\tfor (int j=1; j<B && j<=i; j++){\n\t\t\tdp[i][j]=dp[i-1][j-1];\n\t\t\tif (j<A+1) continue ;\n\t\t\t\n\t\t\tif (j<=A+1 || i==j){\n\t\t\t\tfor (int y=A+1; y<=j; y++)\n\t\t\t\t\tdp[i][j]+=dp[i-y][j-y];\n\t\t\t}\n\t\t\telse if (j>A+1){\n\t\t\t\tdp[i][j]+=dp[i-1][j-1]-dp[i-2][j-2];\n\t\t\t\tdp[i][j]+=dp[i-A-1][j-A-1];\n\t\t\t}\n\t\t\t\n\t\t\tdp[i][j]%=mod;\n\t\t}\n\t\tif (A<=i && i<B) dp[i][i]++;\n\t\t\n\t\tfor (int j=0; j<B; j++) sum[i]=(sum[i] + dp[i][j])%mod;\n\t}\n\t\n\tans=1;\n\tfor (int i=1; i<=n; i++) ans=ans*2%mod;\n\tans=(ans-sum[n])%mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=5005,INF=1<<30;\n\nll dp[MAX][MAX];\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nll sum[MAX];\nll naname[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,A,B;cin>>N>>A>>B;\n    if(A>B) swap(A,B);\n    if(A==1){\n        cout<<rui(2,N)<<endl;\n        return 0;\n    }\n    dp[0][0]=1;\n    sum[0]=1;\n    naname[0][0]=1;\n    \n    for(int i=1;i<=N;i++){\n        for(int j=0;j<B;j++){\n            if(j) dp[i][j]+=dp[i-1][j-1];\n            \n            if(j==1){\n                if(i-2>=0) dp[i][j]+=sum[i-2];\n                if(i-(A+1)>=0) dp[i][j]+=mod-sum[i-(A+1)];\n            }\n            \n            if(i-(A+1)>=0&&j-(A+1)>=0) dp[i][j]+=naname[i-(A+1)][j-(A+1)];\n            \n            while(dp[i][j]>=mod) dp[i][j]-=mod;\n        }\n        \n        ll S=0;\n        for(int l=0;l<=B-1;l++){\n            S+=dp[i][l];\n        }\n        S%=mod;\n        sum[i]=sum[i-1]+S;\n        if(sum[i]>=mod) sum[i]-=mod;\n        \n        naname[i][0]=dp[i][0];\n        for(int j=1;j<=N;j++){\n            naname[i][j]=naname[i-1][j-1]+dp[i][j];\n            if(naname[i][j]>=mod) naname[i][j]-=mod;\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=1;i<N;i++){\n        for(int j=1;j<B;j++){\n            if(N-i<A||j+N-i<B){\n                ans+=dp[i][j];\n            }\n        }\n    }\n    \n    for(int j=0;j<B;j++){\n        ans+=dp[N][j];\n    }\n    \n    ans%=mod;\n    \n    cout<<(mod+rui(2,N)-ans)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint brute(int N,int A,int B){\n    int res=0;\n    for (int mask=0;mask<(1<<N);++mask){\n        auto d=[&](int i){return (mask&1<<i)>>i;};\n        vector<pair<int,int>> v;\n        int cnt=1;\n        for (int i=0;i+1<N;++i){\n            if (d(i)!=d(i+1)){\n                v.emplace_back(d(i),cnt);\n                cnt=1;\n            } else ++cnt;\n        }\n        v.emplace_back(d(N-1),cnt);\n        for (auto &p:v){\n            if (p.first==1&&p.second>=B){\n                p.first=0;\n            }\n        }\n        int now=0,ok=0;\n        for (auto p:v){\n            if (p.first==1) now=0;\n            else {\n                now+=p.second;\n                if (now>=A) ok=1;\n            }\n        }\n        // debug(mask,ok,v);\n        res+=ok;\n    }\n    return res;\n}\n\nconst int MAX_N=5010;\n\nmint dp[MAX_N][MAX_N][2];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,A,B; cin >> N >> A >> B;\n    if (A<B) swap(A,B);\n    dp[0][0][0]=1;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<A;++j){\n            dp[i+1][j+1][0]+=dp[i][j][0];\n            if (j>=B) dp[i+1][j+1][0]+=dp[i][j][1];\n            if (j+1!=B) dp[i+1][j+1][1]+=dp[i][j][1];\n            if (i+B<=N) dp[i+B][min(A,j+B)][1]+=dp[i][j][0];\n            dp[i+1][1][1]+=dp[i][j][0];\n            if (j<B) dp[i+1][1][0]+=dp[i][j][1];\n        }\n        /*\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][0] << (j==B?'\\n':' ');\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][1] << (j==B?'\\n':' ');\n        cerr << '\\n';\n        */\n    }\n    mint ans=0,po=1;\n    for (int i=N;i>=0;--i){\n        ans+=(dp[i][A][0]+dp[i][A][1])*po;\n        po*=2;\n    }\n    cout << ans << '\\n';\n    // cout << brute(N,A,B) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nll dp1[2][15050][2];\nll dp2[15050][2];\nint main()\n{\n\tint num, a, b;\n\tscanf(\"%d%d%d\", &num, &a, &b);\n\tif (a > b)swap(a, b);\n\tfor (int k = 0; k < 2; k++)\n\t{\n\t\tdp1[k][0][k] = 1;\n\t\tfor (int i = 0; i < num; i++)\n\t\t{\n\t\t\tfor (int j = a; i + j <= num; j++)dp1[k][i + j][0] = (dp1[k][i + j][0] + dp1[k][i][1]) % mod;;\n\t\t\tdp1[k][i + 1][1] = (dp1[k][i + 1][1] + dp1[k][i][0] + dp1[k][i][1]) % mod;\n\t\t}\n\t}\n\t//for (int k = 0; k < 2; k++)for (int i = 0; i <= num; i++)for (int j = 0; j < 2; j++)printf(\"%d %d %d  %lld\\n\", k, i, j, dp1[k][i][j]);\n\tdp2[0][0] = dp2[0][1] = 1;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 1; j < a; j++)\n\t\t{\n\t\t\tdp2[i + j][0] = (dp2[i + j][0] + dp2[i][1]) % mod;\n\t\t}\n\t\tfor (int j = 1; i + j <= num && j <= b - 1; j++)\n\t\t{\n\t\t\tint z1 = 0;\n\t\t\tif (i == 0)z1 = 1;\n\t\t\tif (i + j != num)\n\t\t\t{\n\t\t\t\tdp2[i + j][1] = (dp2[i + j][1] + dp2[i][0] * dp1[z1][j][1]) % mod;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp2[i + j][1] = (dp2[i + j][1] + dp2[i][0] * (dp1[z1][j][0] + dp1[z1][j][1])) % mod;\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%lld %lld\\n\", dp2[i + 1][0], dp2[i + 1][1]);\n\t}\n\tll s = 1;\n\tfor (int i = 0; i < num; i++)s = s * 2 % mod;\n\tprintf(\"%lld\\n\", (s + mod + mod - dp2[num][0] - dp2[num][1]) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 5005;\nint p2[N];\nint dp[N][N][2];\nint a[2 * N];\nint ans;\nint n, A, B;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\tans = 0;\n\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tif (A > B) swap(A, B);\n\tif (A == 1) {\n\t\tprintf(\"%d\\n\", p2[n]);\n\t\treturn 0;\n\t}\n\tdp[0][0][1] = 1;\n\tfor (int pref = 0; pref <= n; pref++) {\n\t\tif (pref > 0) a[pref] = add(a[pref], a[pref - 1]);\n\t\tdp[pref][1][1] = add(dp[pref][1][1], a[pref]);\n\t\tans = add(ans, mult(p2[n - pref], add(dp[pref][B][0], dp[pref][B][1])));\n\t\tif (pref == n) break;\n\t\tfor (int g = 0; g < B; g++) {\n\t\t\tdp[pref + 1][g + 1][0] = add(dp[pref + 1][g + 1][0], dp[pref][g][0]);\n\t\t\tdp[pref + 1][g + 1][1] = add(dp[pref + 1][g + 1][1], dp[pref][g][0]);\n\t\t\tif (pref + A <= n)\n\t\t\t\tdp[pref + A][min(B, g + A)][0] = add(dp[pref + A][min(B, g + A)][0], dp[pref][g][1]);\n\t\t\tdp[pref + 1][g + 1][1] = add(dp[pref + 1][g + 1][1], dp[pref][g][1]);\n\t\t\ta[pref + 2] = add(a[pref + 2], dp[pref][g][1]);\n\t\t\tif (pref + A + 1 <= n)\n\t\t\t\ta[pref + A + 1] = sub(a[pref + A + 1], dp[pref][g][1]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned int\n#define ull unsigned long long\n#define inf 1010000000\n#define infll 1010000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\n#define N 5009\n#define mod 1000000007\nusing namespace std;\n\nint read(); ll readll();\n\nint n,A,B,f[N],g[N],h[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif (B>n){ puts(\"1\"); return 0; }\n\tif (A>n){ puts(\"2\"); return 0; }\n\tif (A>B) swap(A,B);\n\tint i,j,ans;\n\tfor (i=ans=1; i<=n; i++) ans=(ans<<1)%mod;\n\tf[0]=g[0]=1;\n\tfor (i=1; i<B; i++)\n\t\tfor (j=h[i]=1,f[i]=max(0,i-A); i-j>A; j++){\n\t\t\tad(h[i],(ll)h[j]*(i-j-A));\n\t\t\tad(f[i],(ll)f[j]*(i-j-A));\n\t\t}\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=0; j<i; j++){\n\t\t\tad(f[i],(ll)g[j]*h[i-j]);\n\t\t\tif (i-j<A) ad(g[i],f[j]);\t\n\t\t}\n\tfor (i=h[0]=1; i<B; i++)\n\t\tfor (j=h[i]=0; i-j>A; j++)\n\t\t\tad(h[i],(ll)h[j]*(i-j-A));\n\tad(ans,mod-f[n]);\n\tfor (i=0; i<B; i++) ad(ans,mod-(ll)g[n-i]*h[i]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\nint read(){\n\tint x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\nll readll(){\n\tll x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxn = 5100, mod = 1e9 + 7;\nint n, w, b, B[maxn][maxn][2], W[maxn][maxn][2], dep[maxn][2];\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> w >> b;\n\tif(b < w) swap(w, b);\n\tB[0][0][0] = 1;\n\tint ans = 0;\n\tfor(int l = 0; l <= n; l++) {\n\t\tif(l) {\n\t\t\tadd(dep[l][0], dep[l-1][0]);\n\t\t\tadd(dep[l][1], dep[l-1][1]);\n\t\t}\n\t\tfor(int h = 0; h <= l; h++) {\n\t\t\tfor(int f = 0; f < 2; f++) {\n\t\t\t\tif(h == 0) add(W[l][h][f], dep[l][f]);\n\t\t\t\t\n\t\t\t\t//cout << \"B \" << l << \" \" << h << \" \" << f << \" \" << B[l][h][f] << '\\n';\n\t\t\t\t//cout << \"W \" << l << \" \" << h << \" \" << f << \" \" << W[l][h][f] << '\\n';\n\t\t\t\t\n\t\t\t\tadd(B[l + 1][h + 1][f | (h + 1 >= b)], B[l][h][f]);\n\t\t\t\tadd(B[l + 1][h + 1][f | (h + 1 >= b)], W[l][h][f]);\n\t\t\t\t\n\t\t\t\tif(h) add(W[l + 1][h + 1][f | (h + 1 >= b)], W[l][h][f]);\n\t\t\t\t//B->W\n\t\t\t\tif(l + w < maxn)\n\t\t\t\t\tadd(W[l + w][h + w][f | (h + w >= b)], B[l][h][f]);\n\t\t\t\tif(B[l][h][f]) {\n\t\t\t\t\tadd(dep[l + 1][f], B[l][h][f]);\n\t\t\t\t\tif(l + w < maxn)\n\t\t\t\t\t\tadd(dep[l + w][f], mod - B[l][h][f]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(l == n && f) add(ans, B[l][h][f]), add(ans, W[l][h][f]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll, ll> P;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VI = vector<ll>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\nconst int inf = 1e9 + 7;\nconst ll INF = 1LL << 61;\nconst ll mod = 1e9 + 7;\n\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvector<ll> inv, fact, invfact;\nvoid Mod_build(int n = 101010) {\n    fact.resize(n + 1);\n    inv.resize(n + 1);\n    invfact.resize(n + 1);\n    fact[0] = inv[0] = invfact[0] = 1;\n    inv[1] = 1;\n    for (ll i = 0; i < n; i++) {\n        fact[i + 1] = fact[i] * (i + 1) % mod;\n        if (i > 0) inv[i + 1] = mod - inv[mod % (i + 1)] * (mod / (i + 1)) % mod;\n        invfact[i + 1] = invfact[i] * inv[i + 1] % mod;\n    }\n}\nll perm(int n, int k) {\n    if (n < 0 || k < 0 || k > n) return 0;\n    return fact[n] * invfact[n - k] % mod;\n}\nll comb(int n, int k) {\n    if (n < 0 || k < 0 || k > n) return 0;\n    return (fact[n] * invfact[n - k] % mod) * invfact[k] % mod;\n}\nll powmod(ll n, ll k) {\n    k %= mod - 1;\n    if (k < 0) k += mod - 1;\n    ll ret = 1;\n    while (k) {\n        if (k & 1) ret = ret * n % mod;\n        n = n * n % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nll modinv(ll a) {\n    ll m = mod;\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\nint main() {\n    Mod_build();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int i, j;\n    ll n, a, b;\n    cin >> n >> a >> b;\n    if (a < b) swap(a, b);\n    if (b == 1) {\n        cout << powmod(2, n) << endl;\n        return 0;\n    }\n    VI bb(n + 3, 0);\n    VI aa(n + 3, 0);\n    for (i = 1; i <= b + 1; i++) bb[i] = i;\n    for (i = b + 2; i <= n + 2; i++) {\n        bb[i] = 1 + bb[i - 1];\n        bb[i] %= mod;\n        for (j = 1; j <= i - 1 - b; j++) {\n            bb[i] += bb[j];\n            bb[i] %= mod;\n        }\n    }\n    for (i = n + 2; i >= 1; i--) {\n        aa[i] = mod + bb[i] - bb[i - 1];\n        aa[i] %= mod;\n    }\n\n    VVI dp1(n + 1, VI(a, 0));\n    VVI dp2(n + 1, VI(b, 0));\n    VVI dp3(n + 1, VI(a, 0));\n    ll ans = 0;\n    for (i = 0; i < n; i++) {\n        if (i == 0) {\n            // dp1[i][1] = 1;\n            dp2[i][1] = 1;\n            dp3[i][1] = 1;\n        } else {\n            for (j = 1; j < a; j++) {\n                dp2[i][1] += dp1[i - 1][j] * aa[j];\n                dp2[i][1] %= mod;\n                dp2[i][1] += dp3[i - 1][j] * aa[j + 1];\n                dp2[i][1] %= mod;\n            }\n            for (j = 1; j < b; j++) {\n                dp1[i][1] += dp2[i - 1][j];\n                dp1[i][1] %= mod;\n            }\n            for (j = a - 1; j >= 2; j--) {\n                dp1[i][j] = dp1[i - 1][j - 1];\n                dp3[i][j] = dp3[i - 1][j - 1];\n            }\n            for (j = b - 1; j >= 2; j--) dp2[i][j] = dp2[i - 1][j - 1];\n        }\n    }\n    for (j = 1; j < a; j++) {\n        ans += dp1[n - 1][j] * aa[j + 1];\n        ans %= mod;\n        ans += dp3[n - 1][j] * aa[j + 2];\n        ans %= mod;\n    }\n    for (j = 1; j < b; j++) {\n        ans += dp2[n - 1][j];\n        ans %= mod;\n    }\n    for (i = 0; i < n; i++) {\n        //cout << i << endl;\n        for (j = 0; j < a; j++) {\n            //cout << j << \" \" << dp1[i][j] << endl;\n        }\n        for (j = 0; j < a; j++) {\n            //cout << j << \" \" << dp3[i][j] << endl;\n        }\n        for (j = 0; j < b; j++) {\n            //cout << j << \" \" << dp2[i][j] << endl;\n        }\n    }\n    cout << (powmod(2, n) + mod - ans) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"debug.cpp\"\n\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tint n,a,b;\n\tcin >> n >> a >> b;\n\t\n\tlong long mod=1000000007;\n\t\n\t//a<=b\n\tif(a>b) swap(a,b);\n\t\n\tvector<vector<long long>> dp(n+1,vector<long long>(b));\n\tvector<vector<long long>> dp2(n+1,vector<long long>(b));\n\tvector<long long> res(n+1);\n\tdp[0][0]=1;\n\tdp2[0][0]=0;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tres[i+1]+=(res[i]*2)%mod;\n\t\tres[i+1]%=mod;\n\t\t\n\t\t//add 1\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((j+1)<b){\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\tdp[i+1][j+1]+=dp2[i][j];\n\t\t\t\tdp[i+1][j+1]%=mod;\n\t\t\t}\n\t\t}\n\t\tres[i+1]+=dp[i][b-1];\n\t\tres[i+1]+=dp2[i][b-1]*2;\n\t\tres[i+1]%=mod;\n\t\t\n\t\t//add 0\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((j+1)<b){\n\t\t\t\tdp2[i+1][j+1]+=dp2[i][j];\n\t\t\t\tdp2[i+1][j+1]%=mod;\n\t\t\t}\n\t\t\tif(j<b){\n\t\t\t\tdp[i+1][0]+=dp[i][j];\n\t\t\t\tdp[i+1][0]%=mod;\n\t\t\t}\n\t\t}\n\t\tif((i+1-a)>=0){\n\t\t\tfor(int j=1;j<b;j++){\n\t\t\t\tdp[i+1][0]=(dp[i+1][0]+mod-dp[i+1-a][j])%mod;\n\t\t\t}\n\t\t\tif((i+1-a)==0) dp[i+1][0]=(dp[i+1][0]+mod-1)%mod;\n\t\t}\n\t\t\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif((i+a)>n) continue;\n\t\t\tif((j+a)<b){\n\t\t\t\tdp2[i+a][j+a]+=dp[i][j];\n\t\t\t\tdp2[i+a][j+a]%=mod;\n\t\t\t}else if(j<b){\n\t\t\t\tres[i+a]+=dp[i][j];\n\t\t\t\tres[i+a]%=mod;\n\t\t\t}\n\t\t}\n\t\tif(i==0){\n\t\t\tif(a<b){\n\t\t\t\tdp2[i+a][a]+=dp[i][0];\n\t\t\t\tdp2[i+a][a]%=mod;\n\t\t\t}else{\n\t\t\t\tres[i+a]+=dp[i][0];\n\t\t\t\tres[i+a]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res[n] << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define mod 1000000007\n#define maxn 1010\n\nint n,a,b;\nint ksm(int x,int y){int re=1;for(;(y&1?re=1ll*re*x%mod:0),y;y>>=1,x=1ll*x*x%mod);return re;}\nint g[maxn][2],f[maxn][2];\nvoid add(int &x,int y){x=(x+y>=mod?x+y-mod:x+y);}\n\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tif(a>b)swap(a,b); g[1][1]=1;\n\tfor(int i=2;i<b;i++)\n\t{\n\t\tg[i][1]=(g[i-1][0]+g[i-1][1])%mod;\n\t\tfor(int j=a;j<i;j++)add(g[i][0],g[i-j][1]);\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<min(a,i+1);j++)add(f[i][0],f[i-j][1]);\n\t\tfor(int j=1;j<min(b,i+1);j++)\n\t\t{\n\t\t\tif(i==n)add(f[i][0],1ll*f[i-j][0]*g[j][0]%mod);\n\t\t\tif(i==j)add(f[i][1],(g[j][0]+g[j][1])%mod);\n\t\t\telse add(f[i][1],1ll*f[i-j][0]*g[j][1]%mod);\n\t\t}\n\t}\n\tprintf(\"%d\",(ksm(2,n)-(f[n][0]+f[n][1])%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 5010\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 1000000007\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nint n, a, b;\nll dp[maxn][maxn]; // \nll pw[maxn];\nll s[maxn][maxn]; // 第二维固定的和 \nll tt[maxn];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> a >> b;\n\tif (a > b) swap(a, b);\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * 2 % mod;\n\tfor (int i = n + 1; i >= 0; i--) {\n\t\t//当前1的位置\n\t\tfor (int j = 1; j <= i + 1; j++) {\n\t\t\tint nl = i - j + 1;\n\t\t\tif (i == n + 1) nl--;\n\t\t\tif (nl >= b) dp[i][j] = pw[max(0, n - i)];\n\t\t\telse {\n\t\t\t\tdp[i][j] = (s[i + a + 1][j] + dp[i + 1][j]);\n\t\t\t\tdp[i][j] += tt[i + 2] - tt[i + a + 1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t\tif (dp[i][j] < 0) dp[i][j] += mod;\n\t\t\t}\n\t\t\ts[i][j] = (s[i + 1][j] + dp[i][j]) % mod;\n\t\t\tif (i == j) \n\t\t\t\ttt[i] = (tt[i + 1] + dp[i][i]) % mod; \n\t\t}\n\t} \n\tcout << dp[0][1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 5000, mod = 1e9 + 7;\nint n, A, B, f[maxn + 5], g[maxn + 5], h[maxn + 5];\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % mod) if (b & 1) c = 1ll * a * c % mod;\n\treturn c;\n}\n\ninline int chk_mod(int x) { return x < mod ? x : x - mod; }\ninline void mod_add(int &x, int y) { x += y, x < mod ? 0 : x -= mod; }\ninline void mod_add(int &x, ll y) { x = (x + y) % mod; }\n\nint F1(int x) { return f[x - 1]; }\nint F2(int x) { return x == 1 ? 1 : f[x - 2]; }\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &A, &B);\n\tif (A > B) swap(A, B);\n\tif (A == 1) printf(\"%d\\n\", qpow(2, n)), exit(0);\n\tf[0] = 1;\n\trep(i, 1, B - 1) {\n\t\tf[i] = f[i - 1];\n\t\tif (i >= A) mod_add(f[i], 1);\n\t\trep(j, A, i - 1) mod_add(f[i], f[i - j - 1]);\n\t}\n\tg[0] = h[0] = 1;\n\trep(i, 1, n) {\n\t\trep(j, 1, min(i, A - 1)) mod_add(g[i], h[i - j]);\n\t\tif (i < B) h[i] = F1(i);\n\t\trep(j, 1, min(i - 1, B - 1)) mod_add(h[i], 1ll * g[i - j] * (i == n ? F1(j) : F2(j)));\n\t}\n\tint res = qpow(2, n);\n\tmod_add(res, mod - chk_mod(g[n] + h[n]));\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass CRangeSet {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, a, b; cin >> n >> a >> b;\n      if (a == 1 || b == 1) {\n        cout << mod_pow(mint(2), n).x << endl;\n        return;\n      }\n\n      if (a > b) {\n        swap(a, b);\n      }\n\n      vector<vector<mint>> sb(b+1, vector<mint>(2));\n      // starts with 1\n      sb[1][1] = 1;\n      for(int i=1; i<b; i++) {\n        for(int j=a; j<=b; j++) {\n          if (i+j <= b) sb[i+j][0] += sb[i][1];\n        }\n        if (i+1 <= b) sb[i+1][1] += sb[i][0] + sb[i][1];\n      }\n\n      vector<vector<mint>> dp(n+1, vector<mint>(2));\n      dp[0][0] = 1; // ends with 0\n      dp[0][1] = 1; // ends with 1\n\n      for(int i=1; i<=n; i++) {\n        for(int j=1; j<a; j++) {\n          if (i-j >= 0) dp[i][0] += dp[i-j][1];\n        }\n        for(int j=1; j<b; j++) {\n          if (i-j >= 0) {\n            dp[i][1] += dp[i-j][0] * sb[j][1];\n            if (i == n) {\n              // can ends with 0 at the end.\n              dp[i][1] += dp[i-j][0] * sb[j][0];\n            }\n            if (i-j == 0) {\n              // can starts with 0 at first.\n              dp[i][1] += dp[i-j][1] * sb[j][0];\n            }\n          }\n        }\n      }\n\n      mint all = mod_pow(mint(2), n);\n      mint ret = all - dp[n][0] - dp[n][1];\n      cout << ret.x << endl;\n    }\n};\n\nsigned main() {\n  CRangeSet solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) static_cast<int>((x).size())\n\nusing LL = long long;\ntemplate<class T, size_t D>\nstruct vec : vector<vec<T, D - 1>> {\n  template<class... Args>\n  vec(size_t n = 0, Args... args)\n    : vector<vec<T, D - 1>>(n, vec<T, D - 1>(args...)) {}\n};\ntemplate<class T>\nstruct vec<T, 1> : vector<T> {\n  template<class... Args>\n  vec(Args... args)\n    : vector<T>(args...) {}\n};\n\ntemplate<class T>\ninline bool asMn(T& a, const T& b) { return a > b ? a = b, true : false; }\ntemplate<class T>\ninline bool asMx(T& a, const T& b) { return a < b ? a = b, true : false; }\ninline int nex(int i, int n) { return i == n - 1 ? 0 : i + 1; }\ninline int pre(int i, int n) { return !i ? n - 1 : i - 1; }\n\nconst int mod = 1e9 + 7;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nstruct ModInt {\n  int a;\n  ModInt(int _a = 0)\n    : a(_a) {}\n  friend istream& operator>>(istream& in, ModInt& _) {\n    in >> _.a;\n    return in;\n  }\n  friend ostream& operator<<(ostream& out, const ModInt& _) {\n    out << _.a;\n    return out;\n  }\n\n  bool operator<(const ModInt& _) const { return a < _.a; }\n  bool operator>(const ModInt& _) const { return a > _.a; }\n  bool operator<=(const ModInt& _) const { return a <= _.a; }\n  bool operator>=(const ModInt& _) const { return a >= _.a; }\n  bool operator==(const ModInt& _) const { return a == _.a; }\n  bool operator!=(const ModInt& _) const { return a != _.a; }\n  bool operator!() const { return !a; }\n\n  ModInt operator+(const ModInt& _) const {\n    int ret = a + _.a;\n    return ret < mod ? ModInt(ret) : ModInt(ret - mod);\n  }\n  ModInt operator-(const ModInt& _) const { return *this + ModInt(mod - _.a); }\n  ModInt operator*(const ModInt& _) const { return ModInt((int)((LL)a * _.a % mod)); }\n  ModInt operator/(const ModInt& _) const { return *this * _.binPow(mod - 2); }\n  ModInt& operator+=(const ModInt& _) { return *this = *this + _; }\n  ModInt& operator-=(const ModInt& _) { return *this = *this - _; }\n  ModInt& operator*=(const ModInt& _) { return *this = *this * _; }\n  ModInt& operator/=(const ModInt& _) { return *this = *this / _; }\n  ModInt& operator++() { return *this = *this + ModInt(1); }\n  ModInt& operator--() { return *this = *this - ModInt(1); }\n  ModInt operator-() const { return ModInt() - *this; }\n\n  template<class T>\n  ModInt binPow(T exponent) const {\n    ModInt ret(1), c = *this;\n    for (; exponent; exponent >>= 1, c *= c) if (exponent & 1) ret *= c;\n    return ret;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) {\n    swap(a, b);\n  }\n\n  vec<ModInt, 3> f(n + 1, n + 1, 2);\n  vec<ModInt, 1> g(n + 1);\n  f[0][0][1] = g[0] = ModInt(1);\n  for (int i = 1; i <= n; ++i) {\n    f[i][1][1] += (i >= 2 ? g[i - 2] : ModInt()) - (i >= a + 1 ? g[i - a - 1] : ModInt());\n\n    for (int j = 0; j <= n; ++j) {\n      if (i >= a && j >= a) {\n        f[i][j][0] += f[i - a][j - a][1];\n      }\n\n      if (j) {\n        f[i][j][0] += f[i - 1][j - 1][0];\n\n        f[i][j][1] += f[i - 1][j - 1][0];\n        f[i][j][1] += f[i - 1][j - 1][1];\n      }\n    }\n\n    for (int j = 0; j < b; ++j) {\n      g[i] += f[i][j][1];\n    }\n    g[i] += g[i - 1];\n  }\n\n  vec<ModInt, 1> pw2(n + 1);\n  pw2[0] = ModInt(1);\n  for (int i = 1; i < sz(pw2); ++i) {\n    pw2[i] = pw2[i - 1] + pw2[i - 1];\n  }\n\n\n  ModInt ans;\n  for (int i = 1; i < n; ++i) {\n    ModInt sum;\n    for (int j = b; j <= n; ++j) {\n      sum += f[i][j][1];\n    }\n\n    for (int j = i + 1; j <= n && j - i < a; ++j) {\n      ans += sum * pw2[max(0, n - j - 1)];\n    }\n  }\n  for (int j = b; j <= n; ++j) {\n    ans += f[n][j][0] + f[n][j][1];\n  }\n\n  cout << ans << '\\n';\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: C.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst int p=1000000007;\nstruct Z{\n\tuint x;\n\tZ(){}\n\tZ(uint a){\n\t\tx=a;\n\t}\n};\ninline uint modp(const uint x){\n\treturn x<p?x:x-p;\n}\ninline Z operator+(const Z x1, const Z x2) { return modp(x1.x+x2.x);}\ninline Z operator-(const Z x1, const Z x2) { return modp(x1.x+p-x2.x);}\ninline Z operator-(const Z x) {return x.x?p-x.x:0;}\ninline Z operator*(const Z x1, const Z x2) { return static_cast<ull>(x1.x)*x2.x%p;}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\ninline Z Inv(const Z a){\n\tint x,y;\n\texgcd(p,a.x,x,y);\n\treturn y<0?y+=p:y;\n}\ninline Z operator/(const Z x1, const Z x2) { return x1*Inv(x2);}\n\ninline Z &operator+=(Z &x1, const Z x2) { return x1 = x1 + x2; }\ninline Z &operator-=(Z &x1, const Z x2) { return x1 = x1 - x2; }\ninline Z &operator*=(Z &x1, const Z x2) { return x1 = x1 * x2; }\ninline Z &operator/=(Z &x1, const Z x2) { return x1 = x1 / x2; }\nZ f[5005][2];\nZ g[5005],h[5005];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"C.in\",\"r\",stdin);\n\tfreopen(\"C.out\",\"w\",stdout);\n#endif\n\tint n,a,b;\n\tread(n,a,b);\n\tif(a>b)swap(a,b);\n\tif(a==1){\n\t\tZ ans(1);\n\t\tfor(int i=1;i<=n;++i)ans*=2;\n\t\treturn write(ans.x,'\\n');\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tg[i]=1;\t\n\t\tfor(int j=1;j<=i;++j)g[i]+=h[i-j];\n\t\tfor(int j=a;j<=i;++j)h[i]+=g[i-j];\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=i&&j<b;++j)f[i][0]+=f[i-j][1]*(i==j||i==n?(g[j]+h[j]):g[j]);\t\n\t\tfor(int j=1;j<a&&j<=i;++j)f[i][1]+=f[i-j][0];\t\n\t}\n\tZ ans(1);\n\tfor(int i=1;i<=n;++i)ans*=2;\n\tans-=f[n][0]+f[n][1];\n\twrite(ans.x,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define bg begin\n\nnamespace IO{\n\ncs int RLEN=1<<22|1;\nchar ibuf[RLEN],*ib,*ob;\ninline char gc(){\n\t(ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n\tchar ch=gc();\n\tint res=0;bool f=0;\n\twhile(!isdigit(ch))f=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n\treturn f?-res:res;\n}\ninline ll readll(){\n\tchar ch=gc();\n\tll res=0;bool f=0;\n\twhile(!isdigit(ch))f=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n\treturn f?-res:res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\ts[top+1]='\\0';return top;\n}\n\n}\nusing IO::read;\nusing IO::readll;\nusing IO::readstring;\n\ntemplate<typename tp>inline void chemx(tp &a,tp b){(a<b)?(a=b):0;}\ntemplate<typename tp>inline void chemn(tp &a,tp b){(a>b)?(a=b):0;}\n\ncs int mod=1e9+7;\ninline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\ninline int dec(int a,int b){return a<b?a-b+mod:a-b;}\ninline int mul(int a,int b){return (ll)a*b%mod;}\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\ninline void Dec(int &a,int b){a=a<b?a-b+mod:a-b;}\ninline void Mul(int &a,int b){a=(ll)a*b%mod;}\ninline int ksm(int a,int b,int res=1){for(;b;b>>=1,Mul(a,a))if(b&1)Mul(res,a);return res;}\n\ncs int N=5005;\nint f[N][2],g[N][2],s[N];\nint n,a,b;\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read(),a=read(),b=read();\n\tif(a>b)swap(a,b);\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\tfor(int t=0;t<2;t++)\n\tfor(int j=(t?1:a);j<=i;j++)Add(f[i][t],f[i-j][t^1]);\n\ts[0]=1;\n\tfor(int i=1;i<=n;i++)s[i]=add(f[i][0],f[i][1]);\n\tint res=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(i<a)Add(g[i][0],1);\n\t\tfor(int j=1;j<min(i,a);j++)Add(g[i][0],g[i-j][1]);\n\t\tif(i<b)Add(g[i][1],s[i-1]);\n\t\tfor(int j=1;j<min(i,b);j++)\n\t\tAdd(g[i][1],mul(j==1?1:s[j-2],g[i-j][0]));\n\t\tif(n-i<b)Add(res,mul(g[i][0],s[n-i-1]));\n\t\tif(n-i<a)Add(res,g[i][1]);\n\t}cout<<dec(ksm(2,n),res)<<'\\n';return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//                               S i r o t a n   w a t c h e s   o v e r   y o u .\n//\n//                                          ...Jggg+J+JJJg@NQmgJa.....,       \n//                                 ....gH@@@@HHB\"\"\"\"7\"YYYYHMMMMMMM@@@@@@@Hma,.   \n//                            ...JH@@MMHY\"!                        ? __\"\"YH@@@@N&...     \n//                        ..JH@@HY\"~                                          _TW@@@Mme.    \n//                     .Jg@@#\"=                                                   _TTM@@N..     \n//                  .Jg@@MY!                                                          ?T@@@h,.   \n//                .-@@@B!                                                                (TM@@@L     \n//              .(H@MY                                                                      ?W@@@+    \n//             .W@@@                                                                          .T@@@[       \n//           .d@@M!                                                                             .T@@N,   \n//          .d@M@'                                                                                -W@@o. \n//         (@@M\\                                                                                    ?M@N,\n//        -d@M%                    ..,                                      ..,                      j@@b  \n//       d@@M=                     TM9                                      ?MD                       W@@[ \n//      .H@M:                                                                                         .W@H,\n//      H@Ht                                                                                           ,@@#   \n//     (@@M~                                                                                           .@@h.\n//    .@@M%                        ..gmHHJ.                             .JdHga.                        .H@@e  \n//    j@@#_                       .@@@@@@@b                            J@@@@@@@h.                      .H@@\\ \n//    d@@@                       .4@@@@@@MF                            (@@@@@@@@                        H@@b  \n//    d@@[                         ?\"BMY\"=            .d@@@@H,          ?TWHHY\"!                        d@@e    \n//    J@@b          .JJJ-..,                         ,@@@@@@M%                       .........         -@@@M. \n//    ?@@M\\         ?YHHM@@@@b                ..      .W@@HP                        X@@HMWY\"=          d@@@#\n//    ,@@@L.                                 ?H@Ng&+gd@@#H@@NHaJ+gH@[                                  J@@@] \n//     X@@@[            ......                 ?\"YYYYY\"\"   ?\"YHHHB\"^                 .....            (@@@#   \n//      WH@N+.      .W@@@@MHB=                                                      .TWH@M@Hmc       .H@@M~    \n//     .H@@@@N,      _!~                                                                            .d@@@N,   \n//   .J@@#T@@@N,                                                                                  .d@@@@@@@b. \n//  (@@@@! .T@@@n,                                                                              .(H@@@H>.W@@@x  \n// (@@@F      4@@@@MaJ.                                                                       .d@@@@Y77   4@@@r \n//.H@@P         ?TM@@@@N...                                                               .-JH@HMY=        d@@N,\n//(@@@F             ?\"WM@@@MQa-,.                                                  .(J(JN@@M#\"             Z@@@L\n// d@@H,                 (M@@@@@@@Ng&maJ....                           .. ...J.J+W@@@@@@HY!               .dH@b \n// ?M@@@N&.        ..(JW@@@MM\"?7\"\"TYHMH@@HH@@@@@HHHgkHagHa(mggdmmagH@H@@Q@@HMMMHY\"7!TMM@@@HaJ,.        ..H@@@M^ \n//   ?\"W@@@@MN@@@@@H@@MMY\"                  _???!\"= ?WMMBYYTMH=7\"\"Y@\"\"?\"~^             _\"YM@@@@@@@@MH@@@@@#\"^ \n//       ?77WMMMYB\"\"!                                                                        _7\"WWMMMY\"7=     \n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <fstream>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\ntemplate<typename T>void MACRO_OUT(const T t) { std::cout << t; }\ntemplate<typename First, typename...Rest>void MACRO_OUT(const First first, const Rest...rest) { std::cout << first << \" \"; MACRO_OUT(rest...); }\n#define OUT(...) MACRO_OUT(__VA_ARGS__);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define EOUT(...) { OUT(__VA_ARGS__)BR; exit(0); }\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t: \" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t: \";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t: \";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t: \";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define REP(w, n) FOR(w, 0, n)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define RREP(w, n) RFOR(w, 0, n)\ntemplate<class S, class T, class U> bool IN(S a, T x, U b) { return a <= x && x < b; }\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\nusing i64 = std::int_fast64_t;\nusing u64 = std::uint_fast64_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<i64, i64>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr i64 MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8---------\n\ni64 dp[5003][5003];\ni64 c[5003][5003];\ni64 c2[5003];\n\nsigned main() {\n\tINIT;\n\n\tVAR(i64, n, a, b);\n\tif (a < b) std::swap(a, b);\n\n\tdp[0][0] = 1;\n\tc[1][1] = 1;\n\tc2[0] = 1;\n\tFOR(i, 1, n + 1) FOR(j, 1, a) {\n\t\tif (j == 1) {\n\t\t\tif (i == 1) {\n\t\t\t\t(dp[i][j] += dp[i - 1][j - 1]) %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFOR(k, 2, b + 1) {\n\t\t\t\t\tif (i - k < 0) break;\n\t\t\t\t\t(dp[i][j] += c2[i - k]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(dp[i][j] += dp[i - 1][j - 1]) %= MOD;\n\t\t\tif (i - b >= 0 && j - b >= 0) (dp[i][j] += c[i - b][j - b]) %= MOD;\n\t\t}\n\n\t\t(c[i + 1][j + 1] += c[i][j] + dp[i][j]) %= MOD;\n\t\t(c2[i] += dp[i][j]) %= MOD;\n\t}\n\ti64 sub = 0;\n\tREP(i, n + 1) FOR(j, 1, a) {\n\t\ti64 t = j + (n - i >= b ? n - i : 0);\n\t\tif (t >= a) continue;\n\t\t(sub += dp[i][j]) %= MOD;\n\t}\n\ti64 ans = 1;\n\tREP(_, n) (ans *= 2) %= MOD;\n\t(ans -= sub) %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=5005;\nconst int MOD=1000000007;\nint n,a,b;\nlong long f[N][2];\nlong long g[N];\nlong long dp[N][2];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a>b) swap(a,b);\n\tif(b==1)\n\t{\n\t\tprintf(\"%lld\",ksm(2,n));\n\t\treturn 0;\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t\tf[i][1]=(f[i][1]+f[j][0])%MOD;\n\t\tfor(int j=0;j+a<=i;j++)\n\t\t\tf[i][0]=(f[i][0]+f[j][1])%MOD;\n\t}\n\tg[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tg[i]=(f[i][0]+f[i][1])%MOD;\n\tlong long ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<a) dp[i][0]=(dp[i][0]+1)%MOD;\n\t\tfor(int j=i-a+1;j<i;j++)\n\t\t\tif(j>0) dp[i][0]=(dp[i][0]+dp[j][1])%MOD;\n\t\tif(i<b) dp[i][1]=(dp[i][1]+g[i-1])%MOD;\n\t\tfor(int j=i-b+1;j<i;j++)\n\t\t\tif(j>0) dp[i][1]=(dp[i][1]+dp[j][0]*(i-j==1?1:g[i-j-2])%MOD)%MOD;\n\t\tif(i+b-1>=n) ans=(ans+dp[i][0]*g[n-i-1]%MOD)%MOD;\n\t\tif(i+a-1>=n) ans=(ans+dp[i][1])%MOD;\n\t}\n\tprintf(\"%lld\",(ksm(2,n)-ans+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 5050, mod = 1e9+7;\nint n,A,B,f[N][2],g[N][2];\n\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline void upd(int &x,int y){\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\n\nint main(){\n\tn=read(),A=read(),B=read();\n\tif (A>B) swap(A,B);\n\tg[0][0]=1;\n\tFOR(i,1,B){\n\t\tFor(j,1,i) upd(g[i][1],g[i-j][0]);\n\t\tFor(j,A,i) upd(g[i][0],g[i-j][1]);\n\t}\n\tf[0][0]=f[0][1]=1;\n\tFor(i,1,n){\n\t\tFor(j,1,min(i,A-1)) upd(f[i][0],f[i-j][1]);\n\t\tFor(j,1,min(i,B-1)){\n\t\t\tf[i][1]=(f[i][1]+1ll*f[i-j][0]*g[j][1])%mod;\n\t\t\tif (i==j) upd(f[i][1],g[i][0]);\n\t\t\tif (i==n) f[i][0]=(f[i][0]+1ll*g[j][0]*f[i-j][0])%mod;\n\t\t}\n\t}\n\tint ans=1;\n\tFor(i,1,n) ans=2*ans%mod;\n\tprintf(\"%d\\n\",Mod(ans+mod-Mod(f[n][0]+f[n][1])));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define M1 1000000007\n#define M2 998244353\n#define ll long long\n#define pll pair<ll,ll>\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define REPI(i,a,b) for(ll i=b-1;i>=a;i--)\n#define F first\n#define S second\n#define PB push_back\n#define DB pop_back\n#define MP make_pair\n#define MT make_tuple\n#define G(a,b) get<a>(b)\n#define V(a) vector<a>\n\ntemplate<typename T>\n#define o_set(T) tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>\n//member functions :\n//1. order_of_key(k) : number of elements strictly lesser than k\n//2. find_by_order(k) : k-th element in the set\n\npll Egcd(ll,ll);\npll Egcd(ll x,ll y)\n{\n    if(x==0) return MP(0,1);\n    pll t=Egcd(y%x,x);\n    return MP(t.S-t.F*(y/x),t.F);\n}\n\nll powM(ll x,ll y,ll m)\n{\n    ll ans=1,r=1;\n    x%=m;\n    while(r>0&&r<=y)\n    {\n        if(r&y)\n        {\n            ans*=x;\n            ans%=m;\n        }\n        r<<=1;\n        x*=x;\n        x%=m;\n    }\n    return ans;\n}\n\nll modI(ll a, ll m)\n{\n    ll m0=m,y=0,x=1;\n    if(m==1) return 0;\n    while(a>1)\n    {\n        ll q=a/m;\n        ll t=m;\n        m=a%m;\n        a=t;\n        t=y;\n        y=x-q*y;\n        x=t;\n    }\n    if(x<0) x+=m0;\n    return x;\n}\n\nvoid Miden(ll **p1,ll n)\n{\n    ll (*x)[n]=(ll(*)[n]) p1;\n    REP(i,0,n)\n    {\n        REP(j,0,n)\n        {\n            x[i][j]=0;\n        }\n        x[i][i]=1;\n    }\n    return;\n}\n\nvoid Mmult(ll **p1,ll **p2,ll **ans,ll x,ll y,ll z,ll m)\n{\n    ll (*a)[y]=(ll (*)[y])p1;\n    ll (*b)[z]=(ll (*)[z])p2;\n    ll (*c)[z]=(ll (*)[z])ans;\n    REP(i,0,x)\n    {\n        REP(j,0,z)\n        {\n            c[i][j]=0;\n            REP(k,0,y)\n            {\n                c[i][j]+=a[i][k]*b[k][j];\n                c[i][j]%=m;\n            }\n        }\n    }\n    return;\n}\n\nvoid Mpow(ll **p1,ll **ans,ll n,ll y,ll m)\n{\n    if(y==0)\n    {\n        Miden(ans,n);\n        return;\n    }\n    ll t[n][n];\n    Mpow(p1,(ll **)t,n,y/2,m);\n    ll z[n][n];\n    Mmult((ll **)t,(ll **)t,(ll **)z,n,n,n,m);\n    if(y%2)\n    {\n        Mmult((ll **)z,p1,ans,n,n,n,m);\n    }\n    else\n    {\n        Miden((ll **)t,n);\n        Mmult((ll **)z,(ll **)t,ans,n,n,n,m);\n    }\n    return;\n}\n\nbool isprime(ll n)\n{\n    if(n<2)\n        return false;\n    for(ll x:{2,3,5,7,11,13,17,19,23,29,31,37})\n    {\n        if(n==x)\n            return true;\n        bool flag=true;\n        ll r=1;\n        ll t=1;\n        while(r<=((n-1)>>__builtin_ctzll(n-1)))\n        {\n            if(r&((n-1)>>__builtin_ctzll(n-1)))\n                t=((__int128)t*x)%n;\n            x=((__int128)x*x)%n;\n            r<<=1;\n        }\n        if(t==1||t==n-1)\n            flag=false;\n        for(r=0;r<__builtin_ctzll(n-1);r++)\n        {\n            t=((__int128)t*t)%n;\n            if(t==n-1)\n                flag=false;\n        }\n        if(flag)\n            return false;\n    }\n    return true;\n}\n\nll PrimRoot(ll p,ll x)\n{\n    //finds primitive root of prime p greater than x(If it doesnt exist, returns 0)\n    V(ll) v;\n    ll t=p-1;\n    REP(i,2,t+1)\n    {\n        if(i*i>t) break;\n        if(t%i==0)\n        {\n            v.PB((p-1)/i);\n            while(t%i==0)\n            {\n                t/=i;\n            }\n        }\n    }\n    if(t>1) v.PB((p-1)/t);\n    REP(i,x+1,p)\n    {\n        ll flag=0;\n        REP(j,0,((ll)v.size()))\n        {\n            if(powM(i,v[j],p)==1)\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n            return i;\n        }\n    }\n\n    return 0;\n}\n\nvoid fft(V(ll) &a,ll n,bool invert,ll m,ll x)\n{\n    REP(i,0,n)\n    {\n        ll y=0;\n        REP(j,0,__builtin_ctzll(n))\n        {\n            if((1LL<<j)&i)\n            {\n                y|=(1LL<<(__builtin_ctzll(n)-j-1));\n            }\n        }\n        if(y>i)\n        {\n            swap(a[i],a[y]);\n        }\n    }\n    if(invert) x=modI(x,m);\n    REP(s,1,__builtin_ctzll(n)+1)\n    {\n        ll y=powM(x,(n/(1LL<<s)),m);\n        REP(j,0,(n/(1LL<<s)))\n        {\n            ll r=1;\n            REP(i,0,(1LL<<(s-1)))\n            {\n                ll u=a[i+j*(1LL<<s)];\n                ll v=(r*a[i+j*(1LL<<s)+(1LL<<(s-1))])%m;\n                a[i+j*(1LL<<s)]=u+v;\n                if(a[i+j*(1LL<<s)]>m) a[i+j*(1LL<<s)]-=m;\n                a[i+j*(1LL<<s)+(1LL<<(s-1))]=u-v;\n                if(a[i+j*(1LL<<s)+(1LL<<(s-1))]<0) a[i+j*(1LL<<s)+(1LL<<(s-1))]+=m;\n                r*=y;\n                r%=m;\n            }\n        }\n    }\n    if(invert)\n    {\n        ll invn=modI(n,m);\n        REP(i,0,n)\n        {\n            a[i]=(a[i]*invn)%m;\n        }\n    }\n    return;\n}\n\nvoid PolyMult(V(ll) &a,V(ll) &b,V(ll) &v,ll m,ll x)\n{\n    ll n=1;\n    while(n<((ll)a.size())+((ll)b.size()))\n    { \n        n<<=1;\n    }\n    V(ll) fa(a.begin(),a.end());\n    fa.resize(n,0);\n    V(ll) fb(b.begin(),b.end());\n    fb.resize(n,0);\n    ll y=powM(x,(m-1)/n,m);\n    fft(fa,n,false,m,y);\n    fft(fb,n,false,m,y);\n    v.resize(n,0);\n    REP(i,0,n)\n    {\n        v[i]=((fa[i]*fb[i])%m);\n    }\n    fft(v,n,true,m,y);\n    return;\n}\n\nll fn(ll x,ll rn[])\n{\n    if(x==rn[x])\n        return x;\n    else\n        return rn[x]=fn(rn[x],rn);\n}\n\nbool un(ll x,ll y,ll rn[],ll sz[])\n{\n    x=fn(x,rn);\n    y=fn(y,rn);\n    if(x==y)\n        return false;\n    if(sz[x]<sz[y])\n        swap(x,y);\n    sz[x]+=sz[y];\n    rn[y]=x;\n    return true;\n}\n\nvoid build(ll v,ll tl,ll tr,ll st[],ll lz[],bool f[],ll a[])\n{\n    if(tl==tr)\n    {\n        st[v]=a[tl];\n        lz[v]=0LL;\n        f[v]=false;\n        return;\n    }\n    build((v<<1),tl,((tl+tr)>>1),st,lz,f,a);\n    build((v<<1)|1,((tl+tr)>>1)+1,tr,st,lz,f,a);\n    //operation\n    st[v]=st[(v<<1)]+st[(v<<1)|1];\n    lz[v]=0LL;\n    f[v]=false;\n    return;\n}\n\nvoid push(ll v,ll tl,ll tr,ll st[],ll lz[],bool f[])\n{\n    if(f[v])\n    {\n        //operation\n        st[(v<<1)]=lz[(v<<1)]=st[(v<<1)|1]=lz[(v<<1)|1]=0LL;\n        f[(v<<1)]=f[(v<<1)|1]=true;\n        f[v]=false;\n    }\n    //operation\n    st[(v<<1)]+=lz[v]*(((tl+tr)>>1)-tl+1);\n    //operation\n    lz[(v<<1)]+=lz[v];\n    //operation\n    st[(v<<1)|1]+=lz[v]*(tr-((tl+tr)>>1));\n    //operation\n    lz[(v<<1)|1]+=lz[v];\n    lz[v]=0LL;\n    return;\n}\n\nvoid update(ll v,ll tl,ll tr,ll l,ll r,ll val,bool set,ll st[],ll lz[],bool f[])\n{\n    if(l>r)\n    {\n        return;\n    }\n    if(l==tl&&tr==r)\n    {\n        if(set)\n        {\n            //operation\n            st[v]=lz[v]=0LL;\n            f[v]=true;\n        }\n        //operation\n        st[v]+=val*(tr-tl+1);\n        //operation\n        lz[v]+=val;\n        return;\n    }\n    push(v,tl,tr,st,lz,f);\n    update((v<<1),tl,((tl+tr)>>1),l,min(r,((tl+tr)>>1)),val,set,st,lz,f);\n    update((v<<1)|1,((tl+tr)>>1)+1,tr,max(l,((tl+tr)>>1)+1),r,val,set,st,lz,f);\n    //operation\n    st[v]=st[(v<<1)]+st[(v<<1)|1];\n    return;\n}\n\nll query(ll v,ll tl,ll tr,ll l,ll r,ll st[],ll lz[],bool f[])\n{\n    if(l>r)\n    {\n        return 0LL;\n    }\n    if(l==tl&&tr==r)\n    {\n        return st[v];\n    }\n    push(v,tl,tr,st,lz,f);\n    //operation\n    return query((v<<1),tl,((tl+tr)>>1),l,min(r,((tl+tr)>>1)),st,lz,f)+query((v<<1)|1,((tl+tr)>>1)+1,tr,max(l,((tl+tr)>>1)+1),r,st,lz,f);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    /*\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    */\n\n    ll ntc=1;\n    //cin>>ntc;\n    REP(tc,1,ntc+1)\n    {\n        //cout<<\"Case #\"<<tc<<\": \";\n\n        ll n,a,b;\n        cin>>n>>a>>b;\n        if(a<b)\n            swap(a,b);\n        ll dp[n+1];\n        ll ad1[n+1][2],ad0[n+1][2];\n        REP(j,0,n+1)\n        {\n            dp[j]=0;\n            ad1[j][0]=0;\n            ad1[j][1]=0;\n        }\n        dp[1]=1;\n        REP(i,1,n+1)\n        {\n            REP(j,1,b)\n            {\n                ad1[i][0]+=dp[j];\n                ad1[i][0]%=M1;\n            }\n            if(i>=a)\n            {\n                REP(j,b,n+1)\n                {\n                    ad1[i][1]+=dp[j];\n                    ad1[i][1]%=M1;\n                    dp[j]=0;\n                }\n                ad1[i][1]+=dp[0];\n                ad1[i][1]%=M1;\n                dp[0]=0;\n            }\n            ll sm=0;\n            if(i<a) sm+=dp[0];\n            REPI(j,1,n+1)\n            {\n                if(!((j<b)||(i>=a&&j>=b))) sm+=dp[j];\n                if(!(i>=a&&j-1>=b)) dp[j]=dp[j-1];\n                else dp[j]=0;\n            }\n            dp[0]=sm;\n        }\n        REP(j,0,n+1)\n        {\n            dp[j]=0;\n            ad0[j][0]=0;\n            ad0[j][1]=0;\n        }\n        dp[0]=1;\n        REP(i,1,n+1)\n        {\n            REP(j,1,b)\n            {\n                ad0[i][0]+=dp[j];\n                ad0[i][0]%=M1;\n            }\n            if(i>=a)\n            {\n                REP(j,b,n+1)\n                {\n                    ad0[i][1]+=dp[j];\n                    ad0[i][1]%=M1;\n                    dp[j]=0;\n                }\n                ad0[i][1]+=dp[0];\n                ad0[i][1]%=M1;\n                dp[0]=0;\n            }\n            ll sm=0;\n            if(i<a) sm+=dp[0];\n            REPI(j,1,n+1)\n            {\n                if(!((j<b)||(i>=a&&j>=b))) sm+=dp[j];\n                if(!(i>=a&&j-1>=b)) dp[j]=dp[j-1];\n                else dp[j]=0;\n            }\n            dp[0]=sm;\n        }\n        ll ans=0;\n        ll st[n+1],cmp[n+1];\n        REP(j,0,n+1)\n        {\n            st[j]=0;\n            cmp[j]=0;\n        }\n        st[0]=1;\n        REP(i,0,n+1)\n        {\n            ans<<=1;\n            ans+=cmp[i];\n            ans%=M1;\n            if(i==0)\n            {\n                REP(j,1,n+1-i)\n                {\n                    st[i+j]+=((ad1[j][0]*1)%M1);\n                    st[i+j]%=M1;\n                    cmp[i+j]+=((ad1[j][1]*1)%M1);\n                    cmp[i+j]%=M1;\n                }\n            }\n            REP(j,1,n+1-i)\n            {\n                st[i+j]+=((ad0[j][0]*st[i])%M1);\n                st[i+j]%=M1;\n                cmp[i+j]+=((ad0[j][1]*st[i])%M1);\n                cmp[i+j]%=M1;\n            }\n        }\n        cout<<ans;\n\n        cout<<'\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nconst int N=500005,M=1000000007;\nint n,a,b,f[5005][2],i,j,g[5005][2],dp[5005][2];\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tif(a<b)\n\t\tswap(a,b);\n\tint s=1;\n\tfor(i=1;i<=n;++i)\n\t\ts=s*2%M;\n\tif(a==1||b==1)\n\t{\n\t\tcout<<s;\n\t\treturn 0;\n\t}\n\tf[0][0]=1;\n\tg[1][1]=1;\n\tg[0][0]=1;\n\tfor(i=2;i<=n;++i)\n\t{\n\t\tfor(j=i-1;j>=0;--j)\n\t\t\tg[i][1]=(g[i][1]+g[j][0])%M;\n\t\tfor(j=i-b;j>=0;--j)\n\t\t\tg[i][0]=(g[i][0]+g[j][1])%M;\n\t}\n\tdp[0][1]=1;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=i-1;j>=0;--j)\n\t\t\tdp[i][1]=(dp[i][1]+dp[j][0])%M;\n\t\tfor(j=i-b;j>=0;--j)\n\t\t\tdp[i][0]=(dp[i][0]+dp[j][1])%M;\n\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=i-1;j>=0&&j>i-b;--j)\n\t\t{\n\t\t\tf[i][0]=(f[i][0]+f[j][1])%M;\n\t\t\tif(j==0)\n\t\t\t\t++f[i][0];\n\t\t}\n\t\tfor(j=i-1;j>=0&&j>i-a;--j)\n\t\t{\n\t\t\tf[i][1]=(f[i][1]+1ll*f[j][0]*g[i-j][1])%M;\n\t\t\tif(j==0)\n\t\t\t\tf[i][1]=(f[i][1]+dp[i-j][1])%M;\n\t\t}\n\t\tif(i==n)\n\t\t\tfor(j=i-1;j>=0&&j>i-a;--j)\n\t\t\t\tf[i][1]=(f[i][1]+1ll*f[j][0]*g[i-j][0])%M;\n\t}\n\tcout<<((s-f[n][0]-f[n][1])%M+M)%M;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nLL dp[3300][3300];\nLL t[3300];\nLL t2[3300];\n\nlong long int pow_mod(long long int p_a,long long int p_n,long long int p_p=1e9+7){\n\t//p_a^p_n mod p_p\n\tlong long int p_b=1,p_t=1;\n\tfor(;p_b<=p_n;p_b<<=1);\n\tfor(p_b>>=1;p_b>0;p_b>>=1){\n\t\tp_t*=p_t;\n\t\tif(p_t>=p_p)p_t%=p_p;\n\t\tif(p_n&p_b)p_t*=p_a;\n\t\tif(p_t>=p_p)p_t%=p_p;\n\t}\n\treturn p_t;\n}\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tLL a,b,c;\n\tLL x,y;\n\tLL s[10]={0};\n\tcin>>n;\n\tcin>>x>>y;\n\tif(x<y)swap(x,y);\n\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(i=0;i<x;i++){\n\t\tdp[i+1][0]=dp[i][0];\n\t\ta=0;\n\t\tfor(j=0;j<x;j++){\n\t\t\tdp[i+1][j+1]=dp[i][j];\n\t\t\tif(j>=y)a+=dp[i][j];\n\t\t}\n\t\ta%=MAX;\n\t\tdp[i+1][0]+=a;\n\t\tif(dp[i+1][0]>=MAX)dp[i+1][0]%=MAX;\n\t}\n\tfor(i=0;i<=x;i++){\n\t\tt[i]=dp[i][0];\n\t}\n\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tif(i+1<x){\n\t\t\tdp[i+1][0]+=t[i+1];\n\t\t\tdp[i+1][0]%=MAX;\n\t\t}\n\t\tfor(j=0;j<y;j++){\n\t\t\tdp[i+1][j+1]=dp[i][j];\n\t\t\tif(j)t2[i]+=dp[i][j];\n\t\t}\n\t\tt2[i]%=MAX;\n\t\ta=0;\n\t\tfor(j=0;j<x-1;j++){\n\t\t\tif(i-j<0)break;\n\t\t\ta+=t2[i-j]*t[j];\n\t\t\tif(a>=MAX)a%=MAX;\n\t\t}\n\t\tdp[i+1][0]+=a;\n\t\tdp[i+1][0]%=MAX;\n\t}\n\tfor(i=1;i<y;i++){\n\t\ts[2]+=dp[n][i];\n\t}\n\tfor(j=1;j<x;j++){\n\t\tif(n-j<0)break;\n\t\ts[2]+=t2[n-j]*t[j];\n\t\tif(s[2]>=MAX)s[2]%=MAX;\n\t}\n\ts[2]%=MAX;\n\ts[0]=pow_mod(2,n)-s[2];\n\tif(s[0]<0)s[0]+=MAX;\n\tcout<<s[0]%MAX<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nMint x[5005][5005],ans,s[5005];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx[0][0]=1;\n\tfor(int l=0;l<=n;l++){\n\t\tfor(int j=0;j+l<=n;j++)s[j]=0;\n\t\tfor(int j=0;j+l<=n;j++){\n\t\t\tif(j>=a){\n\t\t\t\tans+=x[l][j]*Mint(2).pow(n-(l+j));\n\t\t\t\tx[l][j]=0;\n\t\t\t}\n\t\t\tif(j==a){\n\t\t\t\tfor(int k=b;k<=l+j;k++){\n\t\t\t\t\tans+=x[l][j-k]*Mint(2).pow(n-(l+j));\n\t\t\t\t\tx[l][j-k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j>a){\n\t\t\t\tans+=x[l][j-b]*Mint(2).pow(n-(l+j));\n\t\t\t\tx[l][j-b]=0;\n\t\t\t}\n\t\t\ts[j]+=x[l][j];\n\t\t\tif(j>0)s[j]+=s[j-1];\n\t\t\tif(j>0){\n\t\t\t\tx[l+j][1]+=s[j-1];\n\t\t\t\tif(j-b>=0)x[l+j][1]-=s[j-b];\n\t\t\t}\n\t\t\tif(j-b>=0&&j<a){\n\t\t\t\tx[l][j+1]+=s[j-b];\n\t\t\t}\n\t\t\tx[l][j+1]+=x[l][j];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\nll sum1[5020];\nll sum2[5020][5020];\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n  ll dp[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)dp[i][j]=0;\n    dp[0][0]=1;\n    \n    rep(i,0,n+10)sum1[i]=0;\n    sum1[0]=1;\n    \n    rep(i,0,n+10)rep(j,0,n+10)sum2[i][j]=0;\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  P operator-() const {\n    P res((*this).size());\n    rep(i, (*this).size()) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, (*this).size()) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q) {\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  // P &div(map<int, T> q) {\n  //   rep(i, (*this).size()) {\n  //     for (auto &b : q) if (b.first != 0 && b.first <= i) (*this)[i] -= b.second * (*this)[i-b.first];\n  //     (*this)[i] /= q[0];\n  //   }\n  //   return *this;\n  // }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div({{0, 1}, {1, -1}});\n  q[1] = 1;\n  q.div({{0, 1}, {1, -1}});\n  f[1] = 1;\n  f[a] -= 1;\n  f.div({{0, 1}, {1, -1}});\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+2) g0[i] = 0;\n  rep2(i, b, n+2) g1[i] = 0;\n  rep2(i, b, n+2) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=1e9+7;\ninline int ad(int x){return x>=mod?x-mod:x;}\ninline int dec(int x){return x<0?x+mod:x;}\nint f[5010][2],g[5010][2];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n=read(),a=read(),b=read();\n\tif(a>b)swap(a,b);\n\tg[1][1]=1;\n\tfor(int i=2;i<b;i++)\n\t{\n\t\tg[i][1]=ad(g[i-1][0]+g[i-1][1]);\n\t\tfor(int j=a;j<i;j++)g[i][0]=ad(g[i][0]+g[i-j][1]);\n\t}\n\tf[0][0]=f[0][1]=1;\n\tint tot=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttot=ad(2*tot);\n\t\tfor(int j=1;j<min(a,i+1);j++)f[i][0]=ad(f[i][0]+f[i-j][1]);\n\t\tfor(int j=1;j<min(b,i+1);j++)\n\t\t{\n\t\t\tif(i==n)f[i][0]=ad(f[i][0]+1LL*f[i-j][0]*g[j][0]%mod);\n\t\t\tif(i==j)f[i][1]=ad(f[i][1]+ad(g[i][0]+g[i][1]));\n\t\t\telse f[i][1]=ad(f[i][1]+1LL*f[i-j][0]*g[j][1]%mod);\n\t\t}\n\t}pr2(dec(tot-ad(f[n][0]+f[n][1])));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n#include <algorithm>\n#include <utility>\n#include <type_traits>\n#include <cstdint>\n//永夜作\n#define mnt mint_base\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\nint main(void){\n\tint i,j,k,n,A,B;cin>>n>>A>>B;\n\tif(A>B){swap(A,B);}\n\t\n\t//できない数をカウントする\n\t\n\t\n\t\n\tstatic mint_base dp[5015][5015]={};\n\tstatic mint_base ep[5015][5015]={};\n\tmint_base wa[5015]={};\n\tmint_base ans=0;\n\tdp[0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tmint_base aaa=0;\n\t\twa[i+1]+=wa[i];\n\t\tdp[i][1]+=wa[i];\n\t\tfor(j=0;j<B;j++){\n\t\t\t\n\t\t\tdp[i][j]+=ep[i][j];\n\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t\tep[i+1][j+1]+=ep[i][j];\n\t\t\tdp[i+1][j+1]+=dp[i][j];//1\n\t\t\tif(i>0&&j==0){continue;}\n\t\t\taaa+=dp[i][j];\n\t\t\tif(i+A+1<=n+5){ep[i+A+1][j+A+1]+=dp[i][j];}\n\t\t}\n\t\t//cout<<endl;\n\t\t//cout<<aaa<<endl;\n\t\twa[i+2]+=aaa;\n\t\twa[i+A+1]-=aaa;\n\t\t\n\t}\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<B;j++){\n\t\t\tif(n-i+j<B||n-i<A){ans+=dp[i][j];}\n\t\t}\n\t}\n\tmint_base eee=1;\n\tfor(i=0;i<n;i++){eee*=2;}\n\tcout<<eee-ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nll dp[5020][5020];\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    rep(i,0,n+10)rep(j,0,n+10)dp[i][j]=0;\n    dp[0][0]=1;\n    ll sum1[n+10];\n    rep(i,0,n+10)sum1[i]=0;\n    sum1[0]=1;\n    ll sum2[n+10][n+10];\n    rep(i,0,n+10)rep(j,0,n+10)sum2[i][j]=0;\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,min(a[0],(ll)i+1)){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define all(a) (a).begin(),(a).end()\n#define SZ(a) ((int)((a).size()))\n\ntypedef long long ll;\ntypedef long double lf;\n\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst lf pi=acosl(-1);\n/* Source code starts here */\n\nint n,a,b;\nconst int jt=1000000007;\nint dp[5005][5005][2],qzh1[5005],qzh2[5005][5005];\nvoid inline add(int &a,int b){a+=b;if(a>=jt)a-=jt;if(a<0)a+=jt;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a<b)swap(a,b);\n\tdp[0][0][1]=1;\n\tloop(i,n+1){\n\t\tif(i)add(qzh1[i],qzh1[i-1]);\n\t\tadd(dp[i][0][0],qzh1[i]);\n\t\tloop(j,i+1){\n\t\t\tif(i)add(qzh2[i-j][i],qzh2[i-j][i-1]);\n\t\t\tadd(dp[i][j][0],qzh2[i-j][i]);\n\t\t\tif(j==a){\n\t\t\t\tadd(dp[i][j][1],dp[i][j][0]);dp[i][j][0]=0;\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tadd(dp[i+1][j][1],dp[i][j][1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][0]);\n\t\t\tadd(dp[i+1][j+1][1],dp[i][j][1]);\n\t\t\tadd(qzh1[i+1],dp[i][j][1]);\n\t\t\tif(i+b<=n){\n\t\t\t\tadd(qzh1[i+b],-dp[i][j][1]);\n\t\t\t\tif(j+b<=a)add(qzh2[i-j][i+b],dp[i][j][1]);\n\t\t\t\telse add(dp[i+b][a][1],dp[i][j][1]);\n\t\t\t}\n\t\t}\n\t}\n\tadd(dp[n][a][1],dp[n][a][0]);\n\tprintf(\"%d\\n\",dp[n][a][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, a, b, dp[MAXN][MAXN], two[MAXN];\nint pd[MAXN][MAXN], aux[MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(a), read(b);\n\tif (a < b) swap(a, b); two[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\ttwo[i] = 2ll * two[i - 1] % P;\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (i != 0) update(aux[i], aux[i - 1]);\n\t\tupdate(dp[i][1], aux[i]);\n\t\tfor (int j = 1; j <= a; j++) {\n\t\t\tupdate(dp[i][j], pd[i][j]);\n\t\t\tupdate(pd[i + 1][min(j + 1, a)], pd[i][j]);\n\t\t}\n\t\tif (i == n) break;\n\t\tfor (int j = 0; j <= a - 1; j++) {\n\t\t\tupdate(dp[i + 1][j + 1], dp[i][j]);\n\t\t\t\n\t\t\tupdate(aux[i + 2], dp[i][j]);\n\t\t\tif (i + b + 1 <= n) update(aux[i + b + 1], P - dp[i][j]);\n\t\t\t\n\t\t\tif (i + b + 1 <= n) update(pd[i + b + 1][min(j + b + 1, a)], dp[i][j]);\n\t\t\t\n\t\t\tif (n - i >= b) update(dp[n][min(j + n - i, a)], dp[i][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tupdate(ans, 1ll * dp[i][a] * two[n - i] % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAX=5005,mod=1e9+7,inf=0x3f3f3f3f;\n\ntypedef pair < ll, ll > ii;\nll f[MAX][MAX][2],F[MAX][MAX][2],cnt[MAX];\n#define X first\n#define Y second\n#define pb push_back\n//vector < int > pr[MAX];\nint n,m;\n//ll a[MAX];\nint A,B;\nint get(int a,int b){\n    a+=b;if(a>=mod) a-=mod;return a;\n}\nint main()\n{\n    //memset(ST,0,sizeof ST);\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"45C.inp\",\"r\",stdin);freopen(\"45C.out\",\"w\",stdout);\n    cin>>n;\n    cin>>A>>B;\n    //cout<<mod*2;\n    if(A>B) swap(A,B);\n    ll ans=1;\n    f[0][0][1]=1;\n    f[0][0][0]=1;\n    cnt[0]=1;\n    F[0][0][0]=1;\n    F[0][0][1]=1;\n    for(int i=1;i<=n;i++){ans=ans<<1;if(ans>=mod) ans-=mod;}\n    for(int i=1;i<=n;i++){\n        if(i>=A) f[i][0][0]=cnt[i-1]-cnt[i-A];\n        else f[i][0][0]=cnt[i-1];\n        F[i][i][0]=get( F[i-1][i][0],f[i][0][0] );\n        for(int j=1,ma=min(B-1,i);j<=ma;j++){\n            //for(int u=A;u<j;u++) f[i][j][0]+=f[i-u][j-u][1];\n            if(i>=A) f[i][j][0]=F[i-A][i-j][1];\n\n            F[i][i-j][0]=get( F[i-1][i-j][0],f[i][j][0] );\n        }\n        for(int j=1,ma=min(B-1,i);j<=ma;j++){\n            //for(int u=1;u<=j;u++) f[i][j][1]+=f[i-u][j-u][0];\n\n            f[i][j][1]=F[i-1][i-j][0];\n\n            F[i][i-j][1]=get(F[i-1][i-j][1],f[i][j][1]);\n            cnt[i]=get(f[i][j][1],cnt[i]);\n        }\n        cnt[i]=get(cnt[i-1],cnt[i]);\n    }\n    ll temp=0;\n    for(int j=0;j<B;j++){\n        temp=(temp+f[n][j][1]+f[n][j][0])%mod;\n        //cout<<j<<' '<<f[n][j][1]<<' '<<f[n][j][0]<<'\\n';\n    }\n    cout<<(ans-temp+mod)%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); ++i)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); --i)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); ++i)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define dec(i, n)  decID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define SI(v) static_cast<int>(v.size())\n#define RF(e, v) for(auto & e: v)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\n#define IN(T, ...) T __VA_ARGS__; IN_(__VA_ARGS__);\nvoid IN_() { };\ntemplate<typename T, typename ... U> void IN_(T &  a, U &  ... b) { cin >> a; IN_(b ...); };\ntemplate<typename T                > void OUT(T && a            ) { cout << a << endl; }\ntemplate<typename T, typename ... U> void OUT(T && a, U && ... b) { cout << a << \" \"; OUT(b ...); }\n\n// ---- ----\n\ntemplate<LL M> class ModInt {\nprivate:\n\tLL v;\n\tpair<LL, LL> ext_gcd(LL a, LL b) {\n\t\tif(b == 0) { assert(a == 1); return { 1, 0 }; }\n\t\tauto p = ext_gcd(b, a % b);\n\t\treturn { p.SE, p.FI - (a / b) * p.SE };\n\t}\npublic:\n\tModInt(LL vv = 0) { v = vv; if(abs(v) >= M) { v %= M; } if(v < 0) { v += M; } }\n\tLL get_v() { return v; }\n\tModInt inv() { return ext_gcd(M, v).SE; }\n\tModInt exp(LL b) {\n\t\tModInt p = 1, a = v; if(b < 0) { a = a.inv(); b = -b; }\n\t\twhile(b) { if(b & 1) { p *= a; } a *= a; b >>= 1; }\n\t\treturn p;\n\t}\n\tfriend bool      operator< (ModInt    a, ModInt   b) { return (a.v <  b.v); }\n\tfriend bool      operator> (ModInt    a, ModInt   b) { return (a.v >  b.v); }\n\tfriend bool      operator<=(ModInt    a, ModInt   b) { return (a.v <= b.v); }\n\tfriend bool      operator>=(ModInt    a, ModInt   b) { return (a.v >= b.v); }\n\tfriend bool      operator==(ModInt    a, ModInt   b) { return (a.v == b.v); }\n\tfriend bool      operator!=(ModInt    a, ModInt   b) { return (a.v != b.v); }\n\tfriend ModInt    operator+ (ModInt    a            ) { return ModInt(+a.v); }\n\tfriend ModInt    operator- (ModInt    a            ) { return ModInt(-a.v); }\n\tfriend ModInt    operator+ (ModInt    a, ModInt   b) { return ModInt(a.v + b.v); }\n\tfriend ModInt    operator- (ModInt    a, ModInt   b) { return ModInt(a.v - b.v); }\n\tfriend ModInt    operator* (ModInt    a, ModInt   b) { return ModInt(a.v * b.v); }\n\tfriend ModInt    operator/ (ModInt    a, ModInt   b) { return a * b.inv(); }\n\tfriend ModInt    operator^ (ModInt    a, LL       b) { return a.exp(b); }\n\tfriend ModInt  & operator+=(ModInt  & a, ModInt   b) { return (a = a + b); }\n\tfriend ModInt  & operator-=(ModInt  & a, ModInt   b) { return (a = a - b); }\n\tfriend ModInt  & operator*=(ModInt  & a, ModInt   b) { return (a = a * b); }\n\tfriend ModInt  & operator/=(ModInt  & a, ModInt   b) { return (a = a / b); }\n\tfriend ModInt  & operator^=(ModInt  & a, LL       b) { return (a = a ^ b); }\n\tfriend istream & operator>>(istream & s, ModInt & b) { s >> b.v; b = ModInt(b.v); return s; }\n\tfriend ostream & operator<<(ostream & s, ModInt   b) { return (s << b.v); }\n};\n\n// ----\n\nusing MI = ModInt<1'000'000'007>;\n\ntemplate<typename T> T MV(T v) { return v; }\ntemplate<typename T, typename ... U> auto MV(T v, int a, U ... b) { return vector<decltype(MV(v, b ...))>(a, MV(v, b ...)); }\n\nint main() {\n\tIN(int, n, a, b);\n\tif_not(a <= b) { swap(a, b); }\n\t\n\tif(a == 1) { OUT(MI(2) ^ n); exit(0); }\n\t\n\tMI ans = 0, s = 0;\n\tauto dp = MV<MI>(0, n + 1, n + 1);\n\tdp[0][0] = 1;\n\tincII(k, 0, n) {\n\t\tif(k >= b) {\n\t\t\tauto & v = dp[k - b][k - a];\n\t\t\tauto & w = dp[k - b][k - 0];\n\t\t\tans += v * (MI(2) ^ (n - k));\n\t\t\tans += w * (MI(2) ^ (n - k));\n\t\t\ts -= v;\n\t\t\tv = 0;\n\t\t\tw = 0;\n\t\t\tincID(j, k - a + 1, k) {\n\t\t\t\tdp[k - b + 1][j] += dp[k - b][j];\n\t\t\t\tdp[k - b][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif(k == n) { break; }\n\t\t\n\t\tMI t = 0;\n\t\tint il = max(0, k - b + 1);\n\t\tif(k >= a) {\n\t\t\tincII(i, il, k) {\n\t\t\t\tMI & v = dp[i][k - a];\n\t\t\t\ts -= v;\n\t\t\t\tt += v;\n\t\t\t\tdp[i][k - a + 1] += v;\n\t\t\t\tdp[i][k + 1] += v;\n\t\t\t\tv = 0;\n\t\t\t}\n\t\t}\n\t\tdp[k][k + 1] += s;\n\t\ts += t;\n\t\t{\n\t\t\tincII(i, il, k) {\n\t\t\t\tMI v = dp[i][k];\n\t\t\t\ts += v;\n\t\t\t\tdp[i][k + 1] += v;\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 5e3 + 5;\nconst double eps = 1e-9;\n\nint dp[N][N][2][2];\n\ninline int add(int& x, int y) { return x = x+y < mod ? x+y : x+y-mod; }\ninline int sub(int& x, int y) { return x = x-y >= 0 ? x-y : x-y+mod; }\ninline int mul(int x, int y) { return x * 1ll * y % mod; }\ninline int pw(int x, int y) {\n  int r = 1;\n  for (; y; y /= 2, x = mul(x, x))\n    if (y & 1)\n      r = mul(r, x);\n  return r;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b)\n    swap(a, b);\n  if (a == 1) {\n    printf(\"%d\\n\", pw(2, n));\n    return 0;\n  }\n  dp[0][0][0][0] = 1;\n  dp[0][0][0][1] = 1;\n\n  dp[1][1][0][0] = mod-1;\n  dp[1][1][0][1] = mod-1;\n  for (int i = 0; i <= n; i++) {\n    int sm[2] = {0, 0};\n    for (int j = 0; j <= i; j++) {\n      if (i > 0 && j > 0)\n        for (int ii = 0; ii < 2; ii++)\n          for (int jj = 0; jj < 2; jj++)\n            add(dp[i][j][ii][jj], dp[i-1][j-1][ii][jj]);\n      if (a + i <= n) {\n        if (j+a >= b) {\n          add(dp[i+a][j+a][1][0], dp[i][j][0][1]);\n          sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][0][1]);\n        } else {\n          add(dp[i+a][j+a][0][0], dp[i][j][0][1]);\n          sub(dp[min(N-1,i+b-j)][j+b-j][0][0], dp[i][j][0][1]);\n          add(dp[min(N-1,i+b-j)][j+b-j][1][0], dp[i][j][0][1]);\n          sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][0][1]);\n        }\n        add(dp[i+a][j+a][1][0], dp[i][j][1][1]);\n        sub(dp[i+n-i+1][j+n-i+1][1][0], dp[i][j][1][1]);\n      }\n      if (j+1 >= b) {\n        add(dp[i+1][j+1][1][1], dp[i][j][0][0]);\n        sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][0][0]);\n      } else {\n        add(dp[i+1][j+1][0][1], dp[i][j][0][0]);\n        sub(dp[min(N-1,i+b-j)][j+b-j][0][1], dp[i][j][0][0]);\n        add(dp[min(N-1,i+b-j)][j+b-j][1][1], dp[i][j][0][0]);\n        sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][0][0]);\n      }\n      add(dp[i+1][j+1][1][1], dp[i][j][1][0]);\n      sub(dp[i+n-i+1][j+n-i+1][1][1], dp[i][j][1][0]);\n      for (int k = 0; k < 2; k++)\n        add(sm[k], dp[i][j][k][1]);\n    }\n    for (int nj = 1; nj + i <= n && nj < a; nj++) {\n      for (int k = 0; k < 2; k++) {\n        add(dp[i+nj][0][k][0], sm[k]);\n        sub(dp[i+nj+1][1][k][0], sm[k]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j < 2; j++)\n      add(ans, dp[n][i][1][j]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define debug(x) cerr<<#x<<\" = \"<<x\n#define sp <<\"  \"\n#define el <<endl\n#define fgx cerr<<\" ---------------------------------------------- \"<<endl\n#define LL long long\n#define uint unsigned int \n#define ULL unsigned long long\n#define LDB long double\n#define DB double\n#define pii pair<int,int>\n#define pli pair<LL,int>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ninline LL read(){\n\tLL nm=0; bool fh=true; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) fh^=(cw=='-');\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn fh?nm:-nm;\n}\n#define mod 1000000007\nnamespace  CALC{\n\tinline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}\n\tinline int mns(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}\n\tinline int mul(LL x,LL y){return x*y%mod;}\n\tinline void upd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}\n\tinline void dec(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}\n\tinline int qpow(int x,int sq){int res=1;for(;sq;sq>>=1,x=mul(x,x))if(sq&1)res=mul(res,x);return res;}\n}using namespace CALC;\n#define M 5020\nint n,A,B;\nint con0[M],con1[M];\nint F[M],G[M];\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),A=read(),B=read(); if(A>B) swap(A,B);\n\tcon0[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tcon1[i]=add(con1[i-1],con0[i-1]);\n\t\tfor(int z=A;z<=i;z++) upd(con0[i],con1[i-z]);\n\t}\n\tfor(int i=1;i<B;i++) F[i]=add(con0[i],con1[i]);\n\tfor(int i=1;i<A;i++) G[i]=1;\n\tint ans=F[n]; G[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tif(n-i<A) upd(ans,F[i]);\n\t\tif(n-i<B) upd(ans,mul(G[i],add(con0[n-i],con1[n-i])));\n\t\tfor(int k=1;i+k<=n&&k<B;k++) upd(F[i+k],mul(G[i],con1[k]));\n\t\tfor(int k=1;i+k<=n&&k<A;k++) upd(G[i+k],F[i]);\n\t}\n\tans=mns(qpow(2,n),ans);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5050, mod = 1e9 + 7;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint dp[N], dp2[N][2], cnt[N], ujung[N];\n\nint a, b;\n\nvoid upd(int & var, int val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  memset(dp, 0, sizeof dp);\n  int n;\n  scanf(\"%d %d %d\", &n, &a, &b);\n  if (a > b)\n    swap(a, b);\n  dp[0] = 2;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j <= n && j - i < b; ++j) {\n      upd(dp[j], dp[i]);\n    }\n  }\n  long long ans = (powmod(2, n) - dp[n]) % mod;\n  if (a < b) {\n    for (int i = 1; i < b; ++i) {\n      upd(cnt[i], 1);\n    }\n    for (int i = 1; i < b; ++i) {\n      for (int j = i+a+1; j < b; ++j) {\n        int add = j - i;\n        upd(cnt[j], 1LL * (add - a) * cnt[i] % mod);\n      }\n    }\n    for (int i = a+1; i < b; ++i) {\n      for (int j = a; j < i; ++j)\n        upd(ujung[i], cnt[i-j]);\n    }\n    for (int i = 1; i < b; ++i) {\n      upd(ujung[i], cnt[i]);\n    }\n    dp2[0][0] = dp2[0][1] = 1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = i+1; j <= n && j - i < a; ++j) {\n        upd(dp2[j][1], dp2[i][0]);\n      }\n      for (int j = i+1; j <= n && j - i < b; ++j) {\n        int cost = (j == n || i == 0) ? ujung[j-i] : cnt[j-i];\n        upd(dp2[j][0], 1LL * cost *  dp2[i][1] % mod);\n      }\n    }\n    ans = (ans + dp[n] - dp2[n][1] - dp2[n][0]) % mod;\n    for (int i = a+1; i < b; ++i) {\n      upd(ujung[n-i], mod - cnt[n-i]);\n      ans = (ans - ujung[n-i]) % mod;\n    }\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, a, b;\n  LL dp[5001][5001][2];\n  Solver2(int n, int a, int b) : n(n), a(a), b(b){};\n\n  void solve() {\n    if (a < b) swap(a, b);\n    dp[0][0][0] = LL(1);\n    dp[2][1][0] = LL(MOD - 1);\n    auto ans = Modint<>(0);\n    for (int i = 0; i <= n; ++i) {\n      if (i > 0) dp[i][1][0] += dp[i - 1][1][0];\n      dp[i][1][0] %= MOD;\n      for (int j = 0; j < a; ++j) {\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] += dp[i][j][0];\n        if (i + 2 <= n) dp[i + 2][1][0] += dp[i][j][0];\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] -= dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][0];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] += dp[i][j][1];\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] += dp[i][j][1];\n\n        if (i + b <= n && j + b <= n) dp[i + b][j + b][1] %= MOD;\n        if (i + 2 <= n) dp[i + 2][1][0] %= MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] += MOD;\n        if (i + b + 1 <= n) dp[i + b + 1][1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][0] %= MOD;\n        if (i + 1 <= n && j + 1 <= n) dp[i + 1][j + 1][1] %= MOD;\n      }\n      auto cf = Modint<>(2).mpow(n - i);\n      for (int j = a; j <= n; ++j) {\n        ans += (dp[i][j][0] + dp[i][j][1]) * cf;\n      }\n    }\n    cout << ans << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, a, b;\n  std::cin >> n >> a >> b;\n\n  Problem::Solver2 sol(n, a, b);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define S second\n#define F first\n#define pb push_back\n\nconst int mod = 1e9 + 7;\n\n\nint f[10101][2];\nint g[10101][2];\nint dp[5050][2];\n\nint _2[5050];\n\nint main(){\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tif(A > B)\n\t\tswap(A, B);\n\t\n\t_2[0] = 1;\n\tfor(int i = 1; i <= 5000; i++)\n\t\t_2[i] = _2[i - 1] * 2 % mod;\n\tf[0][0] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tf[i][0] += f[i - j][1];\n\t\t\tif(f[i][0] >= mod)\n\t\t\t\tf[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tf[i][1] += f[i-j][0];\n\t\t\t\tif(f[i][1] >= mod)\n\t\t\t\t\tf[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tg[0][1] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tg[i][0] += g[i - j][1];\n\t\t\tif(g[i][0] >= mod)\n\t\t\t\tg[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tg[i][1] += g[i - j][0];\n\t\t\t\tif(g[i][1] >= mod)\n\t\t\t\t\tg[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0] = dp[0][1] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tif(i < B)\n\t\t{\n\t\t\tdp[i][1] += g[i][1];\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < min(i + 1, B); j++)\n\t\t{\n\t\t\tdp[i][1] += 1ll * f[j][1] * dp[i - j][0] % mod;\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < min(i + 1, A); j++)\n\t\t{\n\t\t\tdp[i][0] += dp[i - j][1];\n\t\t\tif(dp[i][0] >= mod)\n\t\t\t\tdp[i][0] -= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= N; i++)\n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\tfor(int j = B; j < A + B; j++)\n\t\t\tif(i + j <= N)\n\t\t\t{\n\t\t\t\tans += 1ll * dp[i][1] * (g[j][0] + g[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\t\tif(ans >= mod)\n\t\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j = B; j < A + B; j++)\n\t\tif(i + j <= N)\n\t\t{\n\t\t\tans += 1ll * dp[i][0] * (f[j][0] + f[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\tif(ans >= mod)\n\t\t\t\tans -= mod; \n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    ll dp[n+1][n+1];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    ll sum1[n+1];\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    ll sum2[n+1][n+1];\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,i+1){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    /*rep(i,0,n+1){\n        rep(j,0,n+1)cout<<dp[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); ++i)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); --i)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); ++i)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define dec(i, n)  decID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define SI(v) static_cast<int>(v.size())\n#define RF(e, v) for(auto & e: v)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\n#define IN(T, ...) T __VA_ARGS__; IN_(__VA_ARGS__);\nvoid IN_() { };\ntemplate<typename T, typename ... U> void IN_(T &  a, U &  ... b) { cin >> a; IN_(b ...); };\ntemplate<typename T                > void OUT(T && a            ) { cout << a << endl; }\ntemplate<typename T, typename ... U> void OUT(T && a, U && ... b) { cout << a << \" \"; OUT(b ...); }\n\n// ---- ----\n\ntemplate<LL M> class ModInt {\nprivate:\n\tLL v;\n\tpair<LL, LL> ext_gcd(LL a, LL b) {\n\t\tif(b == 0) { assert(a == 1); return { 1, 0 }; }\n\t\tauto p = ext_gcd(b, a % b);\n\t\treturn { p.SE, p.FI - (a / b) * p.SE };\n\t}\npublic:\n\tModInt(LL vv = 0) { v = vv; if(abs(v) >= M) { v %= M; } if(v < 0) { v += M; } }\n\tLL get_v() { return v; }\n\tModInt inv() { return ext_gcd(M, v).SE; }\n\tModInt exp(LL b) {\n\t\tModInt p = 1, a = v; if(b < 0) { a = a.inv(); b = -b; }\n\t\twhile(b) { if(b & 1) { p *= a; } a *= a; b >>= 1; }\n\t\treturn p;\n\t}\n\tfriend bool      operator< (ModInt    a, ModInt   b) { return (a.v <  b.v); }\n\tfriend bool      operator> (ModInt    a, ModInt   b) { return (a.v >  b.v); }\n\tfriend bool      operator<=(ModInt    a, ModInt   b) { return (a.v <= b.v); }\n\tfriend bool      operator>=(ModInt    a, ModInt   b) { return (a.v >= b.v); }\n\tfriend bool      operator==(ModInt    a, ModInt   b) { return (a.v == b.v); }\n\tfriend bool      operator!=(ModInt    a, ModInt   b) { return (a.v != b.v); }\n\tfriend ModInt    operator+ (ModInt    a            ) { return ModInt(+a.v); }\n\tfriend ModInt    operator- (ModInt    a            ) { return ModInt(-a.v); }\n\tfriend ModInt    operator+ (ModInt    a, ModInt   b) { return ModInt(a.v + b.v); }\n\tfriend ModInt    operator- (ModInt    a, ModInt   b) { return ModInt(a.v - b.v); }\n\tfriend ModInt    operator* (ModInt    a, ModInt   b) { return ModInt(a.v * b.v); }\n\tfriend ModInt    operator/ (ModInt    a, ModInt   b) { return a * b.inv(); }\n\tfriend ModInt    operator^ (ModInt    a, LL       b) { return a.exp(b); }\n\tfriend ModInt  & operator+=(ModInt  & a, ModInt   b) { return (a = a + b); }\n\tfriend ModInt  & operator-=(ModInt  & a, ModInt   b) { return (a = a - b); }\n\tfriend ModInt  & operator*=(ModInt  & a, ModInt   b) { return (a = a * b); }\n\tfriend ModInt  & operator/=(ModInt  & a, ModInt   b) { return (a = a / b); }\n\tfriend ModInt  & operator^=(ModInt  & a, LL       b) { return (a = a ^ b); }\n\tfriend istream & operator>>(istream & s, ModInt & b) { s >> b.v; b = ModInt(b.v); return s; }\n\tfriend ostream & operator<<(ostream & s, ModInt   b) { return (s << b.v); }\n};\n\n// ----\n\nusing MI = ModInt<1'000'000'007>;\n\ntemplate<typename T> T MV(T v) { return v; }\ntemplate<typename T, typename ... U> auto MV(T v, int a, U ... b) { return vector<decltype(MV(v, b ...))>(a, MV(v, b ...)); }\n\nint main() {\n\tIN(int, n, a, b);\n\tif_not(a <= b) { swap(a, b); }\n\t\n\tif(a == 1) { OUT(MI(2) ^ n); exit(0); }\n\t\n\tMI ans = 0, s = 0;\n\tauto dp = MV<MI>(0, n + 1, n + 1);\n\tdp[0][0] = 1;\n\tincII(k, 0, n) {\n\t\tincII(i, 0, k - b) {\n\t\t\tauto & v = dp[i][k - 0];\n\t\t\tauto & w = dp[i][k - a];\n\t\t\tans += v * (MI(2) ^ (n - k));\n\t\t\tans += w * (MI(2) ^ (n - k));\n\t\t\ts -= w;\n\t\t\tv = 0;\n\t\t\tw = 0;\n\t\t}\n\t\tif(k == n) { break; }\n\t\t\n\t\tMI t = 0;\n\t\tif(k >= a) {\n\t\t\tinc(i, n) {\n\t\t\t\tMI & v = dp[i][k - a];\n\t\t\t\ts -= v;\n\t\t\t\tt += v;\n\t\t\t\tdp[i][k - a + 1] += v;\n\t\t\t\tdp[i][k + 1] += v;\n\t\t\t\tv = 0;\n\t\t\t}\n\t\t}\n\t\tdp[k][k + 1] += s;\n\t\ts += t;\n\t\t{\n\t\t\tinc(i, n) {\n\t\t\t\tMI v = dp[i][k];\n\t\t\t\ts += v;\n\t\t\t\tdp[i][k + 1] += v;\n\t\t\t}\n\t\t}\n\t}\n\tOUT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(ll x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(ll exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &x) { if((val += x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &x) { if((val += mod - x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &x) { val = static_cast<unsigned long long>(val) * x.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &x) {\n    // assert(__gcd(static_cast<int>(x.val), mod) == 1);\n    unsigned a = x.val, b = mod; int u = 1, v = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(u -= tmp * v, v);\n    }\n    return *this *= u;\n  }\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return val != x.val; }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator<=(const ModInt &x) const { return val <= x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return val >= x.val; }\n  ModInt &operator++() { if (++val == mod) val = 0; return *this; }\n  ModInt operator++(int) { ModInt res = *this; ++*this; return res; }\n  ModInt &operator--() { val = (val == 0 ? mod : val) - 1; return *this; }\n  ModInt operator--(int) { ModInt res = *this; --*this; return res; }\n  ModInt operator+() const { return *this; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend ostream &operator<<(ostream &os, const ModInt &x) { return os << x.val; }\n  friend istream &operator>>(istream &is, ModInt &x) { ll val; is >> val; x = ModInt(val); return is; }\n};\nModInt abs(const ModInt &x) { return x; }\nstruct Combinatorics {\n  int val; // \"val!\" and \"mod\" must be disjoint.\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\nint main() {\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  vector dp(n + 1, vector(n + 1, vector(2, vector(2, ModInt(0)))));\n  dp[0][0][1][false] = 1;\n  REP(i, n) REP(j, i + 1) REP(k, 2) REP(l, 2) {\n    // 0\n    if (k == 1) {\n      dp[i + 1][0][0][l] += dp[i][j][k][l];\n      if (i + a <= n) {\n        dp[i + a][j + a][0][l || j + a >= b] += dp[i][j][k][l];\n        dp[i + a][0][0][l] -= dp[i][j][k][l];\n      }\n    } else {\n      if (j >= a) {\n        dp[i + 1][j + 1][0][l || j + 1 >= b] += dp[i][j][k][l];\n      } else {\n        dp[i + 1][0][0][l] += dp[i][j][k][l];\n      }\n    }\n    // 1\n    dp[i + 1][j + 1][1][l || j + 1 >= b] += dp[i][j][k][l];\n  }\n  ModInt ans = 0;\n  REP(j, n + 1) REP(k, 2) ans += dp[n][j][k][true];\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\n        Code by a weak man who named CYJian, and he hopes the code can get more points.\n\n        Algorithm:\n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s \"in\", \"r\", stdin), freopen(s \"out\", \"w\", stdout)\n\ntemplate <typename T> inline void read(T &x) {\n    char ch, t = 0;\n    x = 0;\n    while (!isdigit(ch = ge))\n        t |= ch == '-';\n    while (isdigit(ch))\n        x = x * 10 + (ch ^ 48), ch = ge;\n    x = t ? -x : x;\n}\ninline int read_int() {\n    int x;\n    return read(x), x;\n}\ninline ll read_ll() {\n    ll x;\n    return read(x), x;\n}\n\ntemplate <typename T> inline void chkmin(T &a, T b) { a = a < b ? a : b; }\ntemplate <typename T> inline void chkmax(T &a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int mod = 1e9 + 7;\n\ninline int Mod(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\n\nint f[5010];\nint g[5010];\nint P[5010];\nint M[5010];\nint F[2][5010];\n\nint main() {\n#ifdef LOCAL\n    FILE(\"\");\n#endif\n\n    int n = ri, A = ri, B = ri, res = 1;\n    for (int i = 1; i <= n; i++)\n        res = Mod(res << 1);\n    if (A == 1 || B == 1)\n        return printf(\"%d\\n\", res), 0;\n    if (A > B)\n        swap(A, B);\n    f[0] = 1, g[0] = 1;\n    for (int i = A; i < B; i++) {\n        f[i] = Mod(f[i - 1] + g[i - 1]);\n        for (int j = A; j <= i; j++)\n            Add(g[i], f[i - j]);\n    }\n\n    for (int i = 1; i < B; i++)\n        for (int j = 1; j <= i; j++)\n            P[i] = (P[i] + 1LL * g[i - j] * (i == j ? 1 : j)) % mod;\n    for (int i = 1; i < B; i++)\n        for (int j = 1; j <= i; j++)\n            M[i] = (M[i] + 1LL * g[i - j] * (i == j ? 1 : j - 1)) % mod;\n\n    F[0][0] = F[1][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j < B; j++) {\n            if (i == j || i == n) {\n                F[1][i] = (F[1][i] + 1LL * F[0][i - j] * P[j]) % mod;\n                if (i == j)\n                    break;\n            } else\n                F[1][i] = (F[1][i] + 1LL * F[0][i - j] * M[j]) % mod;\n        }\n        for (int j = 1; j < A; j++) {\n            Add(F[0][i], F[1][i - j]);\n            if (i == j)\n                break;\n        }\n    }\n\n    cout << Mod(res + mod - Mod(F[0][n] + F[1][n])) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N, A, B;\nMInt DP[5009][5009];\nMInt DQ[5009][5009];\nMInt EP[5009][5009];\nMInt EQ[5009][5009];\nMInt S[5009];\nint main() {\n\tcin >> N >> A >> B;\n\tif (A < B) swap(A, B);\n\n\tDP[0][0] = 1;\n\tDQ[0][0] = 1;\n\tEP[0][0] = 1;\n\tEQ[0][0] = 1;\n\tS[0] = 1;\n\tREP(i, 1, N + 1) {\n\t\tREP(k, 0, A) {\n\t\t\tif (k > i) continue;\n\t\t\tif (k == 0) {\n\t\t\t\tDQ[i][0] += S[i - 1];\n\t\t\t\tif (i - B >= 0) {\n\t\t\t\t\tDQ[i][0] -= S[i - B];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint a = B;\n\t\t\t\tint c = k + 1;\n\t\t\t\tif (k - a >= 0) DQ[i][k] += EP[i - a][k - a];\n\t\t\t\tif (k - c >= 0) DQ[i][k] -= EP[i - c][k - c];\n\t\t\t}\n\n\t\t\tint a = 1;\n\t\t\tint c = k + 1;\n\t\t\tif (k - a >= 0) DP[i][k] += EQ[i - a][k - a];\n\t\t\tif (k - c >= 0) DP[i][k] -= EQ[i - c][k - c];\n\n\t\t\tEP[i][k] = DP[i][k];\n\t\t\tEQ[i][k] = DQ[i][k];\n\t\t\tif (i > 0 && k > 0) {\n\t\t\t\tEP[i][k] += EP[i - 1][k - 1];\n\t\t\t\tEQ[i][k] += EQ[i - 1][k - 1];\n\t\t\t}\n\t\t}\n\n\t\tS[i] = S[i - 1];\n\t\tREP(k, 0, A) {\n\t\t\tS[i] += DP[i][k];\n\t\t}\n\t}\n\n\tMInt sum = MInt(2)[N];\n\tREP(k, 0, A) {\n\t\tsum -= DP[N][k];\n\t\tsum -= DQ[N][k];\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n#define int ll\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nint is_ok(int now) {\n    int cnts[10] = {};\n    while (now != 0) {\n        cnts[now % 10]++;\n        if (cnts[now % 10] == 2) return false;\n        now /= 10;\n    }\n    return true;\n}\nint is_Prime(int now) {\n    if (now == 1) return false;\n    for (int i = 2; i * i <= now; ++i) {\n        if (now % i == 0) return false;\n    }\n    return true;\n}\nclass EllysDifferentPrimes {\npublic:static int getClosest(int n) {\n    REP(q, 1e9) {\n        if (n - q > 0 and is_ok(n - q) == 1 and is_Prime(n - q) == 1) {\n            return n - q;\n        }\n        if (is_ok(n + q) == 1 and is_Prime(n + q) == 1) {\n            return n + q;\n        }\n    }\n    return -1;\n}\n};\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = ((this->data[i][0]) * (obj.data[0][q]));\n                for (int t = 1; t < obj.data.size(); ++t) {\n                    hoge += ((this->data[i][t]) * obj.data[t][q]);\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back(edge{ to, cap, cost, (int)graph[to].size(), false });\n        graph[to].emplace_back(edge{ from, 0, -cost, (int)graph[from].size() - 1, true });\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int)graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge& e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge& e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto& e : graph[i]) {\n                if (e.isrev) continue;\n                auto& rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\n\n#define int ll\nmodint<MAX_MOD> dp[10001];\nmodint<MAX_MOD> two[10000];\nvoid solve(){\n    two[0] = 1;\n    for (int q = 1; q < 10000; ++q) {\n        two[q] = two[q - 1] * 2;\n    }\n    int n, a, b;\n    cin >> n >> a >> b;\n    if (a > b) swap(a, b);\n\n    dp[0] = 1;\n    dp[1] = MAX_MOD - 1;\n    modint<MAX_MOD> ans = 0;\n    REP(i, n) {\n        dp[i + 1] += dp[i];\n        modint<MAX_MOD> geko[10001] = {};\n        geko[i] += dp[i];\n        geko[i + 1] -= dp[i];\n        for (int q = i; q <= n+1; ++q) {\n            geko[q + 1] += geko[q];\n            if (min(q,n) - max(i - 1LL, 0LL) >= b) {\n                ans += geko[q] * two[max(n - q, 0LL)];\n                continue;\n            }\n            if (q != n) {\n                //next -> white\n                geko[q + 1] += geko[q];\n                geko[q + 2] -= geko[q];\n            }\n            dp[q + 1 + 1] += geko[q];\n            dp[q + a + 1] -= geko[q];\n            /*\n            for (int red = 1; red < a; ++red) {\n                dp[q + red + 1] += geko[q];\n            }\n            */\n            geko[q + a + 1] += geko[q];\n        }\n    }\n    cout << ans << endl;\n}\n#undef int \nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 5e3+10;\nint n,a,b,f[N],g[N][2];\nvoid add(int &x, ll y) {x=(x+y)%P;}\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tif (a>b) swap(a,b);\n\tf[1] = f[2] = 1;\n\tREP(i,3,n) {\n\t\tf[i] = f[i-1];\n\t\tREP(j,1,i-a-1) add(f[i],f[j]);\n\t}\n\tREP(i,1,b-1) g[i][1] = f[i];\n\tREP(i,1,a-1) g[i][0] = 1;\n\tREP(i,a,b-1) REP(j,1,b-1-i) add(g[i+j][1],f[j]);\n\tREP(i,1,n) {\n\t\tREP(j,1,a-1) add(g[i+j][0],g[i][1]);\n\t\tREP(j,1,b-1) add(g[i+j][1],(ll)g[i][0]*f[j]);\n\t}\n\tint ans = (g[n][0]+g[n][1])%P;\n\tREP(i,a,b-1) REP(j,1,b-1-i) add(ans,(ll)g[n-i-j][0]*f[j]);\n\tans = (qpow(2,n)-ans)%P;\n\tif (ans<0) ans += P;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n\nint32_t N,A,B;\nmint pow2[5100];\n\nmint func(int i, int a_end, bool prev_is_b);\nmint func_sum(int i, int k)\n{\n\tstatic mint dp[5100][5100];\n\tstatic bool used[5100][5100];\n\t//for (int k = 1; k < B; k++) {\n\t//\tres += func(i + k + 1, i + k + A, false);\n\t//}\n\n\tif (k >= B) {\n\t\treturn 0_mi;\n\t}\n\tauto& memo = dp[i][k];\n\tif (used[i][k]) {\n\t\treturn memo;\n\t}\n\tused[i][k] = true;\n\n\tmemo = func(i + k + 1, i + k + A, false);\n\tmemo += func_sum(i, k + 1);\n\treturn memo;\n}\n\n//Aは[a_end-A, a_end)\nmint func(int i, int a_end, bool prev_is_b)\n{\n\tstatic mint dp[5100][5100][2];\n\tstatic bool used[5100][5100][2];\n\tif (N < i || N + 1 <= a_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][prev_is_b ? 0 : 1];\n\tif (used[i][a_end][prev_is_b ? 0 : 1]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][prev_is_b ? 0 : 1] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\n\tif (prev_is_b) {\n\t\t//Bの終わった直後\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\tres += func(i + 1, a_end, true);//1を置く\n\t}\n\telse {\n\t\t//Aの中\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\t//for (int k = 1; k < B; k++) {//1をk個と0を一個置く\n\t\t//\t//Bの途中で0を置く\n\t\t//\tres += func(i + k + 1, i + k + A, false);\n\t\t//\t//↑最後に0を置いたのでAの中にいる\n\t\t//}\n\t\tres += func_sum(i, 1);\n\t\tres += func(i + B, a_end, true);//1をB個\n\t}\n\treturn memo = res;\n}\n\n//Aは[a_end-A, a_end), Bは[b_end-B, b_end)\nmint func_ON3(int i, int a_end, int b_end)\n{\n\tstatic mint dp[100][100][100];\n\tstatic bool used[100][100][100];\n\tif (N+1 <= a_end || N + 1 <= b_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i && b_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][b_end];\n\tif (used[i][a_end][b_end]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][b_end] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\tif (i < b_end) {//Bの中\n\t\tres += func_ON3(i + 1, i + A, 0);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end);//1を置く\n\t}\n\telse if (B <= b_end && i == b_end) {//Bの終わった直後\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end+1);//1を置く\n\t}\n\telse {//Aの中\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, i + B);//1を置く\n\t}\n\treturn memo = res;\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\t//if (A == 1) {\n\t//\tout << pow2[N] << endl;\n\t//\treturn 0;\n\t//}\n\t//if (N < 90) {\n\t//\tout << func_ON3(0, A, 0) << endl;\n\t//\treturn 0;\n\t//}\n\n\tout << func(0, A, false) << endl;\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (5006)\nll n, a, b, dp[MAXN][MAXN][3], mod=1e9+7, ans=1, sum[MAXN];\nint main(){\n\tFAST\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\tdp[0][0][2]=1, sum[0]=1;\n\tFOR(i,1,n){\n\t\tFOR(j,0,b-1){\n\t\t\tif(j==0) {\n\t\t\t\tFOR(k,1,min(a-1,i)) dp[i][j][0] += sum[i-k], dp[i][j][0] %= mod;\n\t\t\t} else{\n\t\t\t\tdp[i][j][1] += dp[i-1][j-1][1] + (j-a >= 0 && i-a >= 0 ? dp[i-a][j-a][2] : 0), dp[i][j][1] %= mod;\n\t\t\t\tdp[i][j][2] += dp[i-1][j-1][2] + dp[i-1][j-1][1] + dp[i-1][j-1][0], dp[i][j][2] %= mod;\n\t\t\t}\n\t\t\tsum[i] += dp[i][j][2], sum[i] %= mod;\n\t\t}\n\t}\n\tFOR(i,1,n) ans*=2,ans%=mod;\n\tFOR(j,0,b-1)ans-=dp[n][j][0]+dp[n][j][1]+dp[n][j][2],ans+=mod*3,ans%=mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ld long double\n#define ll long long\n#define st first\n#define nd second\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N = 5e3+5;\nconst ll mod = 1e9+7;\nll cover[N][2], sum_cover[N], sum_cover1[N];\nll dp[N][N], col[N], col_suf[N][N];\nll fpow(ll a, ll p) {\n\tif(p==0) return 1;\n\tll b = fpow(a, p/2);\n\tif(p%2==0) {\n\t\treturn b*b%mod;\n\t}\n\treturn b*b%mod*a%mod;\n}\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n, a, b;\n\tcin>>n>>a>>b;\n\tif(a < b) swap(a, b);\n\tll ans=0;\n\tcover[0][0] = 1;\n\tfor(int i=1; i<=a; ++i) {\n\t\tcover[i][0] = (cover[i-1][0] + cover[i-1][1])%mod;\n\t\tcover[i][1] = cover[i-1][1];\n\t\tif(i-b >=0 ) {\n\t\t\tcover[i][1] += cover[i-b][0];\n\t\t\tcover[i][1] %= mod;\n\t\t}\n\t}\n\tfor(int i=b-1; i>=1; --i) {\n\t\tsum_cover[i] = sum_cover[i+1];\n\t\tsum_cover[i] += cover[a-1-i][0];\n\t\tsum_cover[i] %= mod;\n\t\tsum_cover1[i] = sum_cover1[i+1];\n\t\tsum_cover1[i] += cover[a-1-i][0] + cover[a-1-i][1];\n\t\tsum_cover1[i] %= mod;\n\t}\n\tdp[0][0] = 1;\n\tdp[1][0] = 1;\n\tcol_suf[0][0] = 1;\n\tcol_suf[0][1] = 2;\n\t// bug in dp probably\n\tfor(int i=2; i<=n; ++i) { // row - index\n\t\tfor(int k=0; k<i-1; ++k) { // column - .st pos <b\n\t\t\tif(i-k < a) dp[i][k] = dp[i-1][k];\t\n\t\t\tif(i-b-1 >= 0 && i-k < a) dp[i][k] += col_suf[k][i-b-1];\n\t\t\tdp[i][k] %= mod;\n\t\t\tdp[i][i-1] += (col_suf[k][i-1] - ((i-b-1<0)?0:col_suf[k][i-b-1]) - dp[i-1][k] + 2*mod)%mod;\n\t\t\tdp[i][i-1] %= mod;\n\t\t\tcol_suf[k][i] = (col_suf[k][i-1] + dp[i][k] ) % mod;\n\t\t}\n\t\tcol_suf[i-1][i] = dp[i][i-1];\n\t}\n\t/*cout<<\"debug dp: \\n\";\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tcout<<dp[i][j]<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t}\n\tcout<<\"computing answer\\n\";*/\n\tfor(int i=1; i<=n-a+1; ++i) {\n\t\tint l = n-(i+a-1)+1;\n\t\tans += fpow(2, i-1) * ((i+a-1<n)?cover[a][0]:cover[a][0]+cover[a][1]) % mod\n\t\t* dp[l][l-1] % mod;\n\t\tans %= mod;\n\t\t//cerr<<i<<' '<<i+a-1<<'\\n';\n\t\t//cerr<<fpow(2, i-1)<<' '<<((i+a-1<n)?cover[a][0]:cover[a][0]+cover[a][1])<<' '<<dp[l][l-1]<<'\\n';\n\t\tfor(int j=i+a; j<=n; ++j) {\n\t\t\tif(j-i+1 > a+b-1) break;\n\t\t\tl = n-j+1;\n\t\t\t//ans += fpow(2, i-1) * ((j<n)?sum_cover[max(1, b-(j-(i+a-1)))]:\n\t\t\t//sum_cover1[max(1, b-(j-(i+a-1)))])% mod\n\t\t\t//* dp[l][l-1] % mod;\n\t\t\t//ans %= mod;\n\t\t\t//cerr<<i<<' '<<j<<'\\n';\n\t\t\t//cerr<<fpow(2, i-1)<<' '<<sum_cover[max(1, b-(j-(i+a-1)))]<<' '<<dp[l][l-1]<<'\\n';\n\t\t\tans += fpow(2, i-1) * ((j<n)?cover[j-i-b][0]:cover[j-i-b][0]+cover[j-i-b][1])%mod* dp[l][l-1]%mod;\n//\t\t\tcerr<<i<<' '<<j<<' '<<fpow(2, i-1)<<' '<<cover[j-i-b][0]\n\t\t}\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nint main(){\n  int n, a, b; long long ans = 1, mod = 1e9+7; cin >> n >> a >> b; if(a > b) swap(a, b);\n  vector<long long> f(b, 0); rep(i, n){ans *= 2; ans %= mod;}\n  vector<vector<long long>> dp(n+1, vector<long long>(a+b, 0)), com(n+1, vector<long long>(n+1, 1)); dp[1][1] = 1; dp[1][a+1] = 1;\n  rep(i, n+1){\n    rep(j, i-1){\n      com[i][j+1] = com[i-1][j] + com[i-1][j+1];\n      com[i][j+1] %= mod;\n    }\n  }\n  rep(i, b){\n    int tmp = max((i-1), 0)/(a+1);\n    rep(j, tmp){\n      int c = i-(a+1)*(j+1);\n      f[i] += com[c][j+1];\n      f[i] %= mod;\n    }\n    if(tmp == 0) f[i] = 1;\n  }\n  if(a > 1){\n  \trep(i, n){\n      rep(j, a+b){\n        if(j < a-1){\n          dp[i+1][a+1] += dp[i][j];\n          dp[i+1][a+1] %= mod;\n          dp[i+1][j+1] += dp[i][j];\n          dp[i+1][j+1] %= mod;\n        }\n        else if(j == a-1){\n          dp[i+1][a+1] += dp[i][j];\n          dp[i+1][a+1] %= mod;\n        }\n        else if(j < a+b-1){\n          dp[i+1][1] += dp[i][j] * f[j-a];\n          dp[i+1][1] %= mod;\n          dp[i+1][j+1] += dp[i][j];\n          dp[i+1][j+1] %= mod;\n        }\n        else{\n          dp[i+1][1] += dp[i][j] * f[j-a];\n          dp[i+1][1] %= mod;\n        }\n      }\n    }\n  }\n  rep(i, a+b){\n    ans += mod; ans -= dp[n][i] * f[max(0, i-a)] % mod; ans %= mod;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint M(int x) { return x >= mod ? x - mod : x; }\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getchar();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getchar();\n    }\n    return x * f;\n}\nint n, A, B;\nint f[5003][5003], g[5003][5003];\nint pf[10004][5003], pg[10004][5003];\n\nint S(int *p, int l, int r) { return M(p[r] - (l > 0 ? p[l - 1] : 0) + mod); }\n\nint main() {\n    // clock_t c = clock();\n    // cerr << clock() - c << endl;\n    n = read(), A = read(), B = read();\n    if (A > B) swap(A, B);\n    int res = 1;\n    for (int i = 1; i <= n; ++i) res = M(res << 1);\n    if (A == 1) return printf(\"%d\\n\", res), 0;\n\n    for (int i = 1; i <= B; ++i)\n        f[0][i] = pf[i + n][0] = g[0][i] = pg[i + n][0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        int s = 0;\n        for (int x = 1; x <= min(A - 1, i); ++x) Add(s, g[i - x][B]);\n        for (int j = 1; j <= B; ++j) {\n            f[i][j] = pf[j - i + n][i] = M(s + S(pg[j - i + n], i - j, i - A));\n            g[i][j] = pg[j - i + n][i] = S(pf[j - i + n], i - j, i - 1);\n        }\n\n        for (int j = n - i + 1; j <= B + n - i - 1; ++j)\n            Add(pf[j][i], pf[j][i - 1]), Add(pg[j][i], pg[j][i - 1]);\n    }\n    printf(\"%d\\n\", M(res + mod - M(g[n][B] + f[n][B])));\n    // cerr << clock() - c << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\ntemplate<long long Mod>\nstruct mint{\n    long long x;\n    mint(long long x=0) :x((x% Mod+Mod)%Mod){}\n\n    mint operator-() const { return mint(-x); }\n\n    mint& operator+=(const mint a) {\n        if((x += a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if((x += Mod-a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= Mod;\n        return *this;\n    }\n\n    mint operator^(long long t) const {\n        mint ret(1);\n        mint a = *this;\n        while(t){\n            if(t&1){\n                ret *= a;\n            }\n            a *= a;\n            t >>= 1;\n        }\n        return ret;\n    }\n    mint inv() const { return *this ^ (Mod-2); }\n    mint& operator/=(const mint a) { return *this *= a.inv(); }\n\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n\n    friend istream& operator>>(istream& is, mint& a) { return is >> a.x; }\n    friend ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n};\n\nint N, A, B;\n\nbool visA[5001][2];\nmint<MOD> dpA[5001][2];\nmint<MOD> countA(int L, int k){\n    if(L == 0){\n        if(k) return 1;\n        else return -1;\n    }\n    if(L < A) return 0;\n    if(visA[L][k]) return dpA[L][k];\n    visA[L][k] = true;\n    mint<MOD> ret = 0;\n    for(int i=1; i<=A && L-i>=0; i++){\n        ret += countA(L-i, k^1);\n    }\n    return dpA[L][k] = ret;\n}\n\nbool visB[5001][2];\nmint<MOD> dpB[5001][2];\nmint<MOD> countB(int L, int k){\n    if(L == 0){\n        if(k) return 1;\n        else return -1;\n    }\n    if(L < B) return 0;\n    if(visB[L][k]) return dpB[L][k];\n    visB[L][k] = true;\n    mint<MOD> ret = 0;\n    for(int i=1; i<=B && L-i>=0; i++){\n        ret += countB(L-i, k^1);\n    }\n    return dpB[L][k] = ret;\n}\n\nbool vis[5001][3][2];\nmint<MOD> dp[5001][3][2];\nmint<MOD> solve(int l, int b, int a){\n    if(l == N){\n        if(a == 0) return 0;\n        return mint<MOD>(-1);\n    }\n    if(vis[l][b][a]) return dp[l][b][a];\n    vis[l][b][a] = true;\n    mint<MOD> ret = solve(l+1, 2, a)*2;\n    for(int i=1; l+i<=N; i++){\n        if(i >= A && b != 0){\n            ret -= solve(l+i, 0, 1)*countA(i,0);\n        }\n        if(i >= B && b != 1){\n            ret -= solve(l+i, 1, 1)*countB(i,0);\n        }\n    }\n    return dp[l][b][a] = ret;\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A == 1 || B == 1){\n        cout << (mint<MOD>(2)^N) << endl;\n    }\n    else{\n        cout << solve(0, 2, 0) << endl;\n    }\n\n    /*vector<pair<vector<int>,int>> cand;\n    mint<MOD> ans = mint<MOD>(2)^N;\n    int M = 1;\n    rep(i, N) M *= 3;\n    rep(i, M){\n        vector<int> X(N);\n        int k = 1;\n        rep(j, N){\n            X[j] = (i/k)%3;\n            k *= 3;\n        }\n        X.pb(-1);\n\n        int cnt = 1;\n        bool ok = true;\n        mint<MOD> tmp = -1;\n        for(int j=1; j<N+1; j++){\n            if(X[j-1] == 2) tmp *= 2;\n            if(X[j-1] != X[j]){\n                if(X[j-1] == 0 && cnt < A){\n                    ok = false;\n                    break;\n                }\n                if(X[j-1] == 1 && cnt < B){\n                    ok = false;\n                    break;\n                }\n                if(X[j-1] == 0){\n                    tmp *= -countA(cnt,0);\n                }\n                if(X[j-1] == 1){\n                    tmp *= -countB(cnt,0);\n                }\n                cnt = 0;\n            }\n            cnt++;\n        }\n        if(!ok) continue;\n        ans += tmp;\n        cand.pb({ X,i });\n\n        rep(j, N) cout << X[j] << \" \";\n        cout << \": \" << tmp << endl;\n    }\n    cout << ans << endl;\n\n    vector<int> count(M,0);\n    rep(i, 1<<N){\n        vector<int> X(N);\n        rep(j, N){\n            X[j] = (i>>j)&1;\n        }\n\n        rep(j, cand.size()){\n            rep(k, N){\n                if(cand[j].first[k] != 2 && cand[j].first[k] != X[k]) continue;\n                count[cand[j].second]++;\n            }\n        }\n\n        \n    }*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=5005;\nint n,a,b,i,j,k,l,f1[N],f2[N],g[N][2][2],ans;\ninline void add(int&a,const int&b){a+=b-mo;a+=a>>31&mo;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);if(a<b)std::swap(a,b);\n\tfor(i=1;i<=n;++i)f1[i]=1;\n\tfor(i=1;i<n;++i)for(j=b+1;i+j<=n;++j)f1[i+j]=(f1[i+j]+1ll*f1[i]*(j-b))%mo;\n\tfor(i=b+1;i<=n;++i)f2[i]=i-b;\n\tfor(i=1;i<n;++i)for(j=b+1;i+j<=n;++j)f2[i+j]=(f2[i+j]+1ll*f2[i]*(j-b))%mo;\n\tfor(i=1;i<=n;++i)add(f2[i],f1[i]);\n\tg[0][1][0]=1;\n\tfor(i=1;i<=n;++i)g[i][1][i>=a]=f2[i];\n\tfor(i=0;i<=n;++i){\n\t\tfor(j=1;j<b && i+j<=n;++j)for(k=0;k<2;++k)add(g[i+j][0][k],g[i][1][k]);\n\t\tfor(j=1;i+j<=n;++j)for(k=0;k<2;++k)add(g[i+j][1][k|(j>=a)],1ll*(i+j==n?f2[j]:f1[j])*g[i][0][k]%mo);\n\t}\n\tfor(i=b;i<=n;++i)for(j=b;i+j+1<=n;++j)ans=(ans+f1[n-i-j])%mo;\n\tfor(j=b;j+1<=n;++j)ans=(ans+f1[n-j])%mo;\n\tans=(1ll*ans+1+g[n][0][1]+g[n][1][1])%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=5005;\nll qp(ll x,ll k){\n\tll res=1;\n\twhile(k){\n\t\tif(k&1) res=res*x%mod;\n\t\tk>>=1,x=x*x%mod;\n\t}\n\treturn res;\n}\nint n,a,b;\nll f1[N],f2[N],f3[N],f4[N];\nll g1[N],g2[N];\nint main() {\n    scanf(\"%d%d%d\",&n, &a, &b);\n\tif(a>b) swap(a,b);\n\tif(a==1) return printf(\"%lld\\n\", qp(2,n)),0;\n\tf1[1]=1;\n    inc(i,2,b-1){\n    \tf1[i]=1;\n    \tinc(j,1,i-1) f1[i]=(f1[i]+f2[i-j])%mod;\n    \tinc(j,a,i-1) f2[i]=(f2[i]+f1[i-j])%mod;\n    \tinc(j,1,i-1) f3[i]=(f3[i]+f4[i-j])%mod;\n    \tif(i>=a) f4[i]=1;\n    \tinc(j,a,i-1) f4[i]=(f4[i]+f3[i-j])%mod;\n\t}\n    inc(i,i,n){\n    \tif(i<b) g1[i]=(f1[i]+f3[i])%mod;\n    \tinc(j,1,min(b-1,i-1)) g1[i]=(g1[i]+g2[i-j]*f1[j])%mod;\n    \tif(i<a) g2[i]=1;\n    \tinc(j,1,min(a-1,i-1)) g2[i]=(g2[i]+g1[i-j])%mod;\n    }\t\n\tll ans=(g1[n]+g2[n])%mod;\n\tinc(j,1,n-1) ans=(ans+g2[n-j]*f2[j])%mod;\n    printf(\"%lld\\n\",(qp(2,n)-ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nlong long naive(int N, int A, int B)\n{\n    set<string> S;\n    S.insert(string(N, '0'));\n\n    while (true)\n    {\n        bool up = false;\n        for (string s: S)\n        {\n            for (int i=0; i<=N-A; i++)\n            {\n                for (int j=0; j+A<=N; j++)\n                {\n                    string t = s;\n                    for (int k=0; k<A; k++)\n                        t[j+k] = '0';\n                    if (S.count(t)==0)\n                    {\n                        up = true;\n                        S.insert(t);\n                    }\n                }\n            }\n            for (int i=0; i<=N-B; i++)\n            {\n                for (int j=0; j+B<=N; j++)\n                {\n                    string t = s;\n                    for (int k=0; k<B; k++)\n                        t[j+k] = '1';\n                    if (S.count(t)==0)\n                    {\n                        up = true;\n                        S.insert(t);\n                    }\n                }\n            }\n        }\n        if (!up)\n            break;\n    }\n    //for (string s: S)\n    //    cout<<s<<endl;\n    return S.size();\n}\n\nlong long solve(int N, int A, int B)\n{\n    long long M = 1000000007;\n\n    if (A<B)\n        swap(A, B);\n\n    if (B==1)\n    {\n        long long ans = 1;\n        for (int i=0; i<N; i++)\n            ans = ans*2%M;\n        return ans;\n    }\n\n    vector<long long> T1(B);\n    vector<long long> S1(N+1);\n    T1[0] = 1;\n    S1[0] = 1;\n    for (int i=0; i<N; i++)\n    {\n        vector<long long> P(B);\n        T1.swap(P);\n        for (int j=0; j<B; j++)\n        {\n            T1[0] += P[j];\n            T1[0] %= M;\n            if (j+1<B)\n            {\n                T1[j+1] += P[j];\n                T1[j+1] %= M;\n            }\n        }\n        for (int j=0; j<=B-2; j++)\n        {\n            S1[i+1] += T1[j];\n            S1[i+1] %= M;\n        }\n    }\n\n    vector<long long> T2(N+1);\n    vector<long long> S2(N+1);\n    T2[0] = 1;\n    S2[0] = 1;\n    for (int i=0; i<N; i++)\n    {\n        vector<long long> P(N+1);\n        T2.swap(P);\n        for (int j=0; j<=N; j++)\n        {\n            if (j>=B || j==0)\n            {\n                T2[0] += P[j];\n                T2[0] %= M;\n            }\n            if (j<N)\n            {\n                T2[j+1] += P[j];\n                T2[j+1] %= M;\n            }\n        }\n        for (int j=B; j<=N; j++)\n        {\n            S2[i+1] += T2[j];\n            S2[i+1] %= M;\n        }\n    }\n\n    long long ans = 0;\n    for (int l=A; l<=N; l++)\n    {\n        for (int a=0; a+l+4<=N; a++)\n        {\n            ans += S2[l]*S1[a]%M*S1[N-l-a-4]%M;\n            ans %= M;\n        }\n        if (l+2<=N)\n        {\n            ans += S2[l]*S1[N-l-2]*2%M;\n            ans %= M;\n        }\n        if (l==N)\n        {\n            ans += S2[l];\n            ans %= M;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int N, A, B;\n    cin>>N>>A>>B;\n    //cout<<naive(N, A, B)<<endl;\n    cout<<solve(N, A, B)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define eps 1e-8\nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,a,b,i,j,f[5005][5005][2],sum[5005][5005][2],sum2[5005],sum3[5005],flag[5005],ans;\nint main(){\n\tn=read();a=read();b=read();\n\tif(a<b)\n\t\tswap(a,b);\n\tsum[0][0][0]=1;\n\tsum[0][0][1]=1;\n\tsum2[0]=1;\n\tflag[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(i>=b)\n\t\t\tf[i][0][1]=(sum2[i-1]-sum2[i-b]+mo)%mo;\n\t\telse\n\t\t\tf[i][0][1]=sum2[i-1];\n\t\tsum[i][0][1]=f[i][0][1];\n\t\tfor(j=1;j<a&&j<=i;j++){\n\t\t\tf[i][j][0]=sum[i-1][j-1][1];\n\t\t\tif(j>=b)\n\t\t\t\tf[i][j][1]=sum[i-b][j-b][0];\n\t\t\tsum[i][j][0]=(sum[i-1][j-1][0]+f[i][j][0])%mo;\n\t\t\tsum[i][j][1]=(sum[i-1][j-1][1]+f[i][j][1])%mo;\n\t\t\tsum2[i]=(sum2[i]+f[i][j][0])%mo;\n\t\t}\n\t\tsum2[i]=(sum2[i]+sum2[i-1])%mo;\n\t\tflag[i]=f[i][0][1];\n\t}\n\t\n\tsum3[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(i>=b)\n\t\t\tf[i][0][1]=(sum3[i-1]-sum3[i-b]+mo)%mo;\n\t\telse\n\t\t\tf[i][0][1]=sum3[i-1];\n\t\tsum[i][0][1]=f[i][0][1];\n\t\tfor(j=1;j<=i;j++){\n\t\t\tf[i][j][0]=sum[i-1][j-1][1];\n\t\t\tif(j>=b)\n\t\t\t\tf[i][j][1]=sum[i-b][j-b][0];\n\t\t\tif(j>=a){\n\t\t\t\tans=(1LL*f[i][j][0]*flag[n-i]+ans)%mo;\n\t\t\t\tif(i==n)\n\t\t\t\t\tans=(f[i][j][1]+ans)%mo;\n\t\t\t}\n\t\t\tsum[i][j][0]=(sum[i-1][j-1][0]+f[i][j][0])%mo;\n\t\t\tsum[i][j][1]=(sum[i-1][j-1][1]+f[i][j][1])%mo;\n\t\t\tsum3[i]=(sum3[i]+f[i][j][0])%mo;\n\t\t}\n\t\tsum3[i]=(sum3[i]+sum3[i-1])%mo;\n\t}\n\tpus(ans,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){ll res=1;a%=mod;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}\n\nint main(){\n    ll n,a,b;cin>>n>>a>>b;\n    if(a==1||b==1)dame(modpow(2,n));\n    if(a>b)swap(a,b);\n    vi v(n+1);\n    v[1]=1;\n    REP(i,2,b){\n        v[i]=v[i-1];\n        for(int j=i-a-1;j>=1;j--)v[i]=(v[j]+v[i])%mod;\n    }\n    vi dp(n+1);\n    dp[0]=1;\n    REP(i,1,n+1){\n        dp[i]=dp[i-1];\n        if(i<a)dp[i]++;\n        REP(j,1,b){\n            if(j>=i)break;\n            if(i!=n){\n                ll k=dp[i-1-j];\n                if(i-a-j>=0)k-=dp[i-a-j];\n                dp[i]+=v[j]*(k+mod)%mod;\n                k=min(i,b)-j-1-max(i-j-a+1,a)+1;\n                if(k>0)dp[i]+=v[j]*k%mod;\n                dp[i]%=mod;\n            }\n            if(i==n){\n                ll k=dp[i-j];\n                if(i-a-j>=0)k-=dp[i-a-j];\n                dp[i]+=v[j]*(k+mod)%mod;\n                if(i-a-j>i-b){\n                    k=dp[i-a-j]-dp[i-b];\n                    dp[i]+=v[j]*k%mod;\n                }\n                k=min(b-j-1,i-j)-max(i-j-a+1,a)+1;\n                if(k>0)dp[i]+=v[j]*k;\n                dp[i]%=mod;\n            }\n        }\n    }\n    out((modpow(2,n)-(dp[n]-dp[n-1])+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N, A, B;\n   cin >> N >> A >> B;\n   if (A > B) swap(A, B);\n   vector<array<Mint, 2>> ways(B + 1);\n   ways[0][0] = 1;\n   ways[0][1] = 1;\n   for (int b = 1; b <= B; ++b) {\n      for (int i = 1; i <= b; ++i) ways[b][1] += ways[b - i][0];\n      for (int a = A; a <= b; ++a) ways[b][0] += ways[b - a][1];\n   }\n   vector<Mint> tot(B + 1);\n   for (int i = 1; i <= B; ++i) tot[i] = ways[i][0] + ways[i][1];\n   tot[0] = 1;\n   Mint ans = Mint(2).pow(N);\n   vector<array<Mint, 2>> dp(N + 1);\n   for (int n = 1; n < N; ++n) {\n      if (n < A) dp[n][0] += 1;\n      for (int i = 1; i < min(n, A); ++i) dp[n][0] += dp[n - i][1];\n      if (n < B) dp[n][1] += tot[n - 1];\n      for (int i = 1; i < min(n, B); ++i) {\n         Mint g = (i == 1) ? Mint(1) : tot[i - 2];\n         dp[n][1] += dp[n - i][0] * g;\n      }\n      if (N - n < B) ans -= dp[n][0] * tot[N - n - 1];\n      if (N - n < A) ans -= dp[n][1];\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nconst int mod=1e9+7;\nint n,a,b,i,j,k,f[5005],g[5005],pw[5005],ans;\nint main(){\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\tf[0]=1;g[0]=1;pw[0]=1;\n\trep(i,n){\n\t\tpw[i]=2ll*pw[i-1]%mod;\n\t\tf[i]=pw[i-1];g[i]=pw[i-1];\n\t\tf[i]=(f[i]-ans+mod)%mod;\n\t\tg[i]=(g[i]-ans+mod)%mod;\n\t\tans=2ll*ans%mod;\n\t\tif(i>=b){\n\t\t\tg[i]=(g[i]-f[i-b]+mod)%mod;\n\t\t\tans=(ans+f[i-b])%mod;\n\t\t\tfor(j=a;j<=b;j++){\n\t\t\t\tint tmp=f[i-b];\n\t\t\t\tif(j==a){\n\t\t\t\t\ttmp=0;\n\t\t\t\t\tfor(k=b;k<=i&&k<a+b;k++){\n\t\t\t\t\t\t(tmp+=f[i-k])%=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j==b){\n\t\t\t\t\tif(a!=b) tmp=(i==b);\n\t\t\t\t\telse tmp=g[i-b];\n\t\t\t\t}\n\t\t\t\tf[i]=(f[i]-tmp+mod)%mod;\n\t\t\t\tans=(ans+tmp)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\nint N, A, B;\n\nbool vis[5001][5001][2][2];\nint dp[5001][5001][2][2];\n\nint sum1(short, short, bool, bool);\nint sum2(short, short, bool, bool);\n\nint solve(short n, short k, bool b, bool a){\n    if(n == N){\n        if(a == 1 || k >= A) return 1;\n        else return 0;\n    }\n    if(vis[n][k][b][a]) return dp[n][k][b][a];\n    vis[n][k][b][a] = true;\n    bool a2 = a;\n    if(k >= A) a2 = true;\n    ll ret = solve(n+1, k+1, 0, a2);\n    if(b == 0){\n        ret += sum1(n+1, 0, 1, a2) - sum1(n+min(B,N-n+1), 0, 1, a2);\n        ret += sum2(n+min(B, N-n+1), k+min(B, N-n+1), 1, a2) - sum2(N+1, k+N-n+1, 1, a2);\n    }\n    if(ret < 0) ret += MOD;\n    if(ret < 0) ret += MOD;\n    if(ret >= MOD) ret -= MOD;\n    if(ret >= MOD) ret -= MOD;\n    return dp[n][k][b][a] = ret;\n}\n\nbool vis1[2][5001][5001];\nint dp1[2][5001][5001];\nint sum1(short n, short k, bool b, bool a){\n    if(n > N) return 0;\n    if(vis1[a][n][k]) return dp1[a][n][k];\n    vis1[a][n][k] = true;\n    int ret = solve(n, k, b, a) + sum1(n+1, k, b, a);\n    if(ret >= MOD) ret -= MOD;\n    return dp1[a][n][k] = ret;\n}\n\nbool vis2[2][5001][5001];\nint dp2[2][5001][5001];\nint sum2(short n, short k, bool b, bool a){\n    if(n > N) return 0;\n    if(vis2[a][n][k]) return dp2[a][n][k];\n    vis2[a][n][k] = true;\n    int ret = solve(n, k, b, a) + sum2(n+1, k+1, b, a);\n    if(ret >= MOD) ret -= MOD;\n    return dp2[a][n][k] = ret;\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    cout << solve(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nint main() {\n\tint n, A, B;\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tif (A > B) swap(A, B);\n\tvector<Mint> H(n + 3), I(n + 1, 1);\n\tvector<vector<Mint>> F(n + 1, vector<Mint>(2));\n\tvector<vector<Mint>> G(n + 1, vector<Mint>(2));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tI[i] = I[i - 1];\n\t\tfor (int j = A; j <= i; ++j) I[i] += i == j ? 1 : I[i - j - 1];\n\t}\n\tfor (int i = 1; i <= n + 2; ++i) {\n\t\tH[i] = i == 1 ? 1 : I[i - 2];\n\t}\n\tG[0][0] = F[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int p = 0; p < 2; ++p) {\n\t\t\tfor (int j = 1; j <= min(i, A - 1); ++j) {\n\t\t\t\tF[i][p] += G[i - j][p];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tint jj = j;\n\t\t\tif (i == j) ++jj;\n\t\t\tif (i == n) ++jj;\n\t\t\tMint h = H[jj];\n\t\t\tif (j < B) G[i][0] += h * F[i - j][0];\n\t\t\tG[i][1] += h * F[i - j][1];\n\t\t\tif (j >= B) G[i][1] += h * F[i - j][0];\n\t\t}\n\t}\n\tMint ans = F[n][1] + G[n][1];\n\tprintf(\"%d\\n\", ans.val);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 5005;\nint dp[N][N], dp2[N][N], prefdp[N];\nint p2[N];\nconst int mod = 1e9 + 7;\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint main(){\n\tp2[0] = 1;\n\tfor(int i = 1; i < N; i++) p2[i] = add(p2[i - 1], p2[i - 1]);\n\tint n, A, B; cin >> n >> A >> B;\n\tif(A > B) swap(A, B);\n\tfor(int j = 0; j <= n; j++) dp[j][B] = dp2[j][B] = p2[j];\n\tfor(int j = 1; j <= n; j++){\n\t\tfor(int i = 0; i < B; i++){\n\t\t\tdp[j][i] = dp[j - 1][i + 1];\n\t\t\t// < A zeroes, then one\n\t\t\tdp[j][i] = add(dp[j][i], sub(\n\t\t\t\tj >= 2 ? prefdp[j - 2] : 0, j - A - 1 < 0 ? 0 : prefdp[j - A - 1]));\n\t\t\t// atleast A zeroes\n\t\t\tif(j >= A){\n\t\t\t\tdp[j][i] = add(dp[j][i], dp2[j - A][min(B, i + A)]);\n\t\t\t}\n\t\t\tdp2[j][i] = add(dp2[j - 1][i + 1], dp[j - 1][i + 1]);\n\t\t\tif(i == 1) prefdp[j] = add(prefdp[j - 1], dp[j][i]);\n\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n\nint32_t N,A,B;\n\n\n\nmint pow2[5100];\nmint dp5[5100][5100];\nbool used5[5100][5100];\nmint func4(int i, int a_max, int onB);\nmint func5(int ic, int icend)\n{\n\tif (ic >= icend) {\n\t\treturn 0_mi;\n\t}\n\tif (N < icend) {\n\t\treturn 0_mi;\n\t}\n\n\tauto& memo = dp5[ic][icend];\n\tif (used5[ic][icend]) {\n\t\treturn memo;\n\t}\n\tused5[ic][icend] = true;\n\n\tmemo = func4(ic + 1, ic + A-1, 0);\n\tmemo += func5(ic+1, icend);\n\n\treturn memo;\n}\nmint dp4[5100][5100][2];\nbool used4[5100][5100][2];\nmint func4(int i, int a_max, int onB)\n{\n\tif (N <= a_max) {\n\t\treturn 0_mi;\n\t}\n\tif (i > N) {\n\t\treturn 0_mi;\n\t}\n\tif (a_max < i) {\n\t\treturn pow2[N-i];\n\t}\n\n\tauto& memo = dp4[i][a_max][onB];\n\tif (used4[i][a_max][onB]) {\n\t\treturn memo;\n\t}\n\tused4[i][a_max][onB] = true;\n\n\tif (onB!=0) {\n\t\treturn memo = func4(i + 1, a_max, 0) + func4(i + 1, a_max, 1);\n\t}\n\n\tmemo = func4(i + 1, a_max, 0);\n\t//for (size_t c = 1; c < B; c++)\n\t//{\n\t//\tmemo += func4(i + c + 1, i + c + A-1, 0);\n\t//}\n\tmemo += func5(i + 1, std::min(i + B,N));\n\tmemo += func4(i + B, a_max, 1);\n\treturn memo;\n}\n\n//Aは[a_end-A, a_end)\nmint func(int i, int a_end, bool prev_is_b)\n{\n\tstatic mint dp[5100][5100][2];\n\tstatic bool used[5100][5100][2];\n\tif (N < i || N + 1 <= a_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][prev_is_b ? 0 : 1];\n\tif (used[i][a_end][prev_is_b ? 0 : 1]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][prev_is_b ? 0 : 1] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\n\tif (prev_is_b) {\n\t\t//Bの終わった直後\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\tres += func(i + 1, a_end, true);//1を置く\n\t}\n\telse {\n\t\t//Aの中\n\t\tres += func(i + 1, a_end, false);//0を置く\n\t\tfor (int k = 1; k < B; k++) {//1をk個と0を一個置く\n\t\t\t//Bの途中で0を置く\n\t\t\tres += func(i + k + 1, i + k + A, false);\n\t\t\t//↑最後に0を置いたのでAの中にいる\n\t\t}\n\t\tres += func(i + B, a_end, true);//1をB個\n\t}\n\treturn memo = res;\n}\n\n//Aは[a_end-A, a_end), Bは[b_end-B, b_end)\nmint func_ON3(int i, int a_end, int b_end)\n{\n\tstatic mint dp[100][100][100];\n\tstatic bool used[100][100][100];\n\tif (N+1 <= a_end || N + 1 <= b_end) {\n\t\treturn 0_mi;//入りきってない\n\t}\n\tif (a_end <= i && b_end <= i) {\n\t\treturn pow2[N - i];//あとは自由\n\t}\n\n\tauto& memo = dp[i][a_end][b_end];\n\tif (used[i][a_end][b_end]) {\n\t\treturn memo;\n\t}\n\tused[i][a_end][b_end] = true;\n\n\tmint res = 0;//mintは自動MODの整数型\n\tif (i < b_end) {//Bの中\n\t\tres += func_ON3(i + 1, i + A, 0);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end);//1を置く\n\t}\n\telse if (B <= b_end && i == b_end) {//Bの終わった直後\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, b_end+1);//1を置く\n\t}\n\telse {//Aの中\n\t\tres += func_ON3(i + 1, a_end, b_end);//0を置く\n\t\tres += func_ON3(i + 1, a_end, i + B);//1を置く\n\t}\n\treturn memo = res;\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 0; i < 5050; i++)\n\t{\n\t\tpow2[i + 1] = pow2[i] + pow2[i];\n\t}\n\n    in >> N>>A>>B;\n\tif (A < B) {\n\t\tstd::swap(A, B);\n\t}\n\tif (A == 1) {\n\t\tout << pow2[N] << endl;\n\t\treturn 0;\n\t}\n\tif (N < 90) {\n\t\tout << func(0, A, false) << endl;\n\t\treturn 0;\n\t}\n\t//if (N < 90) {\n\t//\tout << func_ON3(0, A, 0) << endl;\n\t//\treturn 0;\n\t//}\n\n\n\n\t//out <<\n\t//\tfunc1(0, 0, 0) +\n\t//\tfunc2(0, 0, 0) * (func3(A) - 1_mi) << endl;\n\tout << func4(0, A - 1, 0) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lld long double\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 101000,mod = 1e9+7;\nll ans;\nint n,A,B;\nint f[2][5010][2][2];\nint s[5010][5010][2],sum[5010][2];\nint main(){\n\tread(n);read(A);read(B);\n\tif(A<B) swap(A,B);\n\ts[0][0][0]=1;\n\tf[0][0][0][0]=1;\n\tsum[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint now=i&1,lst=i-1&1;\n\t\tmemset(f[now],0,sizeof(f[now]));\n\t\tfor(int j=0;j<=i;j++) s[i][j][0]=s[i-1][j][0],s[i][j][1]=s[i-1][j][1];\n\t\tsum[i][0]=sum[i-1][0];sum[i][1]=sum[i-1][1];\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(i-j<A){\n\t\t\t\tf[now][j][0][0]=(f[lst][j][0][0]+f[lst][j][1][0])%mod;\n\t\t\t\tf[now][j][0][1]=(f[lst][j][0][1]+f[lst][j][1][1])%mod;\n\t\t\t\tif(i-j<B){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tf[now][j][1][0]=sum[i-1][0]-(i>=B?sum[i-B][0]:0);\n\t\t\t\t\t\tf[now][j][1][1]=sum[i-1][1]-(i>=B?sum[i-B][1]:0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tf[now][j][1][1]=s[i-B][j][1];\n\t\t\t\t\tf[now][j][1][0]=s[i-B][j][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf[now][j][0][1]=(0ll+f[lst][j][0][0]+f[lst][j][0][1]+f[lst][j][1][0]+f[lst][j][1][1])%mod;\n\t\t\t\tif(i>=B)\n\t\t\t\t\tf[now][j][1][1]=(s[i-B][j][0]+s[i-B][j][1])%mod;\n\t\t\t}\n\t\t//\tcerr<<i<<' '<<j<<' '<<f[now][j][0][0]<<' '<<f[now][j][0][1]<<' '<<f[now][j][1][0]<<' '<<f[now][j][1][1]<<'\\n';\n\t\t\tsum[i][0]=(sum[i][0]+f[now][j][0][0])%mod;\n\t\t\tsum[i][1]=(sum[i][1]+f[now][j][0][1])%mod;\n\t\t\ts[i][j][0]=(s[i][j][0]+f[now][j][0][0])%mod;\n\t\t\ts[i][j][1]=(s[i][j][1]+f[now][j][0][1])%mod;\n\t\t\tif(i==n) ans=(ans+f[now][j][0][1]+f[now][j][1][1])%mod;\n\t\t}\n\t}\n\tcout<<(ans+mod)%mod<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1e9 + 7;\nint upd(int x){return x + (x >> 31 & P);}\nvoid inc(int &a , int b){a = upd(a + b - P);}\nint sub(int a , int b){return upd(a - b);}\nint dp[5003][5003][2] , sum[10003][2] , sum1[10003][2] , N , A , B;\n\nint main(){\n\tcin >> N >> A >> B; dp[0][0][0] = 1; if(A > B) swap(A , B);\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tif(i - A - 1 >= 0){int pre = i - A - 1; for(int j = 0 ; j <= pre ; ++j) for(int k = 0 ; k < 2 ; ++k) inc(sum[pre - j][k] , dp[pre][j][k]);}\n\t\tfor(int j = 1 ; j <= i ; ++j)\n\t\t\tfor(int k = 0 ; k < 2 ; ++k){\n\t\t\t\tinc(dp[i][j][k | (j >= B)] , dp[i - 1][j - 1][k]);\n\t\t\t\tinc(dp[i][j][k | (j >= B)] , sum[i - j][k]);\n\t\t\t\tinc(dp[i][1][k | (1 >= B)] , sub(sum1[i - j][k] , sum[i - j][k]));\n\t\t\t}\n\t\tint pre = i - 1; for(int j = 0 ; j <= pre ; ++j) for(int k = 0 ; k < 2 ; ++k) inc(sum1[pre - j][k] , dp[pre][j][k]);\n\t}\n\tint sum = 0;\n\tfor(int i = 0 ; i <= N ; ++i)\n\t\tfor(int j = 0 ; j <= i ; ++j)\n\t\t\tfor(int k = 0 ; k < 2 ; ++k)\n\t\t\t\tif(k || (j + (N - i >= A ? N - i : 0) >= B))\n\t\t\t\t\tinc(sum , dp[i][j][k]);\n\tcout << sum; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n \nusing namespace std;\n\ntypedef long long ll;\n\n\n\nint main(){\n    int a,b,n;\n    ll ver;\n    cin>>n;\n    cout<<'\\n';\n    cin>>a;\n    cout<<'\\n';\n    cin>>b;\n    cout<<'\\n';\n    \n    if(n<a||n<b)cout<<\"error\";\n   \n    if(a==n&&b==n)ver=2;\n    if(a==1||b==1)ver=(std::pow(2,n));\n    else ver=(n-b+1)*(n-a+1);\n    double x=(double)ver/(1e9+7);\n    \n    \n    cout<<(int)x<<endl;\n    \n    \n \n   \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}                                              \n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<1000000007>;\n\nint N,A,B;\n\nmint dp[5010][3][5010];\nsigned main(){\n\tcin>>N>>A>>B;\n\tif(A>B)swap(A,B);\n\n\tdp[0][1][0]=1;\n\tmint ans=0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<B;j++){\n\t\t\tdp[i+1][0][j+1]+=dp[i][0][j];\n\t\t\tdp[i+1][1][j+1]+=dp[i][0][j];\n\t\t}\n\n\t\tfor(int j=0;j<B;j++){\n\t\t\tdp[i+1][1][j+1]+=dp[i][1][j];\n\t\t\tif(i+A<=N)dp[i+A][0][min(j+A,B)]+=dp[i][1][j];\n\t\t\tdp[i+1][2][1]+=dp[i][1][j];\n\t\t}\n\t\tfor(int j=0;j<A;j++){\n\t\t\tdp[i+1][1][1]+=dp[i][2][j];\n\t\t\tdp[i+1][2][j+1]+=dp[i][2][j];\n\t\t}\n\t\tans*=2;\n\t\tans+=dp[i+1][0][B]+dp[i+1][1][B];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n    int N, A, B; cin >> N >> A >> B;\n    if(A > B) swap(A, B);\n    vector<long long> ones(B, 0);\n    ones[1] = 1;\n    for(int i=1;i<B;i++){\n        if(i+1 < B) ones[i+1] = (ones[i+1] + ones[i]) % MOD;\n        for(int j=i+A+1;j<B;j++) ones[j] = (ones[j] + ones[i]) % MOD;\n    }\n    vector dp(N+1, vector(2, 0LL));\n    dp[0][0] = dp[0][1] = 1;\n    long long res = 1;\n    for(int i=0;i<N;i++) res = (2 * res) % MOD;\n    for(int i=A;i<B;i++){\n        for(int j=i+1;j<B;j++) dp[j][1] = (dp[j][1] + ones[j-i]) % MOD;\n    }\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<min(i+A, N+1);j++){\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD;\n        }\n        for(int j=i+1;j<min(i+B, N+1);j++){\n            auto add = dp[i][0] * ones[j-i] % MOD;\n            if(N-i < B && N-j >= A) res = (res + MOD - add) % MOD;\n            dp[j][1] = (dp[j][1] + add) % MOD;\n        }\n    }\n    for(auto& t : dp.back()) res = (res + MOD - t) % MOD;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1'000'000'007LL; /*998'244'353LL;*/\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\ntemplate<long long Mod>\nstruct mint{\n    long long x;\n    mint(long long x=0) :x((x% Mod+Mod)%Mod){}\n\n    mint operator-() const { return mint(-x); }\n\n    mint& operator+=(const mint a) {\n        if((x += a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if((x += Mod-a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= Mod;\n        return *this;\n    }\n\n    mint operator^(long long t) const {\n        mint ret(1);\n        mint a = *this;\n        while(t){\n            if(t&1){\n                ret *= a;\n            }\n            a *= a;\n            t >>= 1;\n        }\n        return ret;\n    }\n    mint inv() const { return *this ^ (Mod-2); }\n    mint& operator/=(const mint a) { return *this *= a.inv(); }\n\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n\n    friend istream& operator>>(istream& is, mint& a) { return is >> a.x; }\n    friend ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n};\n\nint N, A, B;\n\nbool vis[5001][5001][2][2];\nmint<MOD> dp[5001][5001][2][2];\n\nmint<MOD> sum1(int, int, int, int);\nmint<MOD> sum2(int, int, int, int);\n\nmint<MOD> solve(int n, int k, int b, int a){\n    if(n == N){\n        if(a == 1 || k >= A) return 1;\n        else return 0;\n    }\n    if(vis[n][k][b][a]) return dp[n][k][b][a];\n    vis[n][k][b][a] = true;\n    int a2 = a;\n    if(k >= A) a2 = 1;\n    mint<MOD> ret = solve(n+1, k+1, 0, a2);\n    if(b == 0){\n        /*for(int i=1; n+i<=N; i++){\n            if(i < B){\n                ret += solve(n+i, 0, 1, a2);\n            }\n            else{\n                ret += solve(n+i, k+i, 1, a2);\n            }\n        }*/\n        ret += sum1(n+1, 0, 1, a2) - sum1(n+min(B,N-n+1), 0, 1, a2);\n        ret += sum2(n+min(B, N-n+1), k+min(B, N-n+1), 1, a2) - sum2(N+1, k+N-n+1, 1, a2);\n    }\n    return dp[n][k][b][a] = ret;\n}\n\nbool vis1[5001][5001][2];\nmint<MOD> dp1[5001][5001][2];\nmint<MOD> sum1(int n, int k, int b, int a){\n    if(n > N) return 0;\n    if(vis1[n][k][a]) return dp1[n][k][a];\n    vis1[n][k][a] = true;\n    return dp1[n][k][a] = solve(n, k, b, a) + sum1(n+1, k, b, a);\n}\n\nbool vis2[5001][5001][2];\nmint<MOD> dp2[5001][5001][2];\nmint<MOD> sum2(int n, int k, int b, int a){\n    if(n > N) return 0;\n    if(vis2[n][k][a]) return dp2[n][k][a];\n    vis2[n][k][a] = true;\n    return dp2[n][k][a] = solve(n, k, b, a) + sum2(n+1, k+1, b, a);\n}\n\nsigned main(){\n    cin >> N >> A >> B;\n    if(A < B) swap(A, B);\n    cout << solve(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD=1000000007;\n\nll n,a,b;\nll x[5002];\nvoid x_init(){\n\tll dp[5005][2];\n\tdp[1][0]=1;\n\tdp[1][1]=0;\n\tfor(int i=1;i<=a;i++){\n\t\tdp[i+1][0]+=dp[i][0];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tif(i+b<=a){\n\t\t\tdp[i+b][1]+=dp[i][0];\n\t\t\tif(dp[i+b][1]>=MOD)dp[i+b][1]-=MOD;\n\t\t}\n\t\tdp[i+1][0]+=dp[i][1];\n\t\tif(dp[i+1][0]>=MOD)dp[i+1][0]-=MOD;\n\t\tdp[i+1][1]+=dp[i][1];\n\t\tif(dp[i+1][1]>=MOD)dp[i+1][1]-=MOD;\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tx[i]=dp[i][0];\n\t\t//cout<<i<<\":\"<<x[i]<<endl;\n\t}\n}\n\nint main(){\n\tcin>>n>>a>>b;\n\tif(a<b)swap(a,b);\n\tx_init();\n\t\n\tll dp[5002][2]={};\n\tfor(int i=1;i<=a-1;i++){\n\t\tdp[i][0]=x[i+1];\n\t}\n\tfor(int i=1;i<=b-1;i++){\n\t\tdp[i][1]=1;\n\t}\n\tfor(int i=1;i<=n-1;i++){\n\t\tfor(int j=1;j<=b-1;j++){\n\t\t\tif(i+j<=n){\n\t\t\t\tdp[i+j][1]+=dp[i][0];\n\t\t\t\tif(dp[i+j][1]>=MOD)dp[i+j][1]-=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=a-1;j++){\n\t\t\tif(i+j<n){\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t\telse if(i+j==n){\n\t\t\t\tdp[i+j][0]+=dp[i][1]*x[j+1];\n\t\t\t\tdp[i+j][0]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=1;\n\tfor(int i=0;i<n;i++){\n\t\tret*=2;\n\t\tret%=MOD;\n\t}\n\tret+=MOD-dp[n][0];\n\tret+=MOD-dp[n][1];\n\tcout<<ret%MOD<<endl;\n\t//cout<<(dp[n][0]+dp[n][1])%MOD<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint brute(int N,int A,int B){\n    int res=0;\n    for (int mask=0;mask<(1<<N);++mask){\n        auto d=[&](int i){return (mask&1<<i)>>i;};\n        vector<pair<int,int>> v;\n        int cnt=1;\n        for (int i=0;i+1<N;++i){\n            if (d(i)!=d(i+1)){\n                v.emplace_back(d(i),cnt);\n                cnt=1;\n            } else ++cnt;\n        }\n        v.emplace_back(d(N-1),cnt);\n        for (auto &p:v){\n            if (p.first==1&&p.second>=B){\n                p.first=0;\n            }\n        }\n        int now=0,ok=0;\n        for (auto p:v){\n            if (p.first==1) now=0;\n            else {\n                now+=p.second;\n                if (now>=A) ok=1;\n            }\n        }\n        // debug(mask,ok,v);\n        res+=ok;\n    }\n    return res;\n}\n\nconst int MAX_N=5010;\n\nmint dp[MAX_N][MAX_N][2];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,A,B; cin >> N >> A >> B;\n    if (A<B) swap(A,B);\n    if (B==1){\n        cout << pow(2,N) << '\\n';\n        return 0;\n    }\n    dp[0][0][0]=1;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<A;++j){\n            dp[i+1][j+1][0]+=dp[i][j][0];\n            if (j>=B) dp[i+1][j+1][0]+=dp[i][j][1];\n            else dp[i+1][1][0]+=dp[i][j][1];\n            if (j+1!=B) dp[i+1][j+1][1]+=dp[i][j][1];\n            if (i+B<=N) dp[i+B][min(A,j+B)][1]+=dp[i][j][0];\n            dp[i+1][1][1]+=dp[i][j][0];\n        }\n        /*\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][0] << (j==A?'\\n':' ');\n        for (int j=0;j<=A;++j) cerr << dp[i+1][j][1] << (j==A?'\\n':' ');\n        cerr << '\\n';\n        */\n    }\n    mint ans=0,po=1;\n    for (int i=N;i>=0;--i){\n        ans+=(dp[i][A][0]+dp[i][A][1])*po;\n        po*=2;\n    }\n    cout << ans << '\\n';\n    // cout << brute(N,A,B) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 5010;\nLL f[MAXN][MAXN];\nLL pot[MAXN];\nconst LL mod = 1e9 + 7;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    pot[0] = 1;\n    for (int i = 1; i < MAXN; i++) pot[i] = 2*pot[i-1] % mod;\n\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (A > B) swap(A, B);\n    if (A == 1) {\n        cout << pot[N] << \"\\n\";\n        return 0;\n    }\n    vector<LL> pref(MAXN, 0);\n    vector<vector<LL>> hardpref(MAXN, vector<LL>(MAXN, 0));\n    for (int n = 1; n <= N; n++) {\n        for (int k = 0; k < B; k++) {\n            f[n][k] += f[n-1][k+1];\n            if (k == B-1) f[n][k] += pot[n-1];\n            if (k + n >= B and n >= A) f[n][k]++;\n            f[n][k] += pref[n-1] - ((n-A >= 0)?pref[n-A]:0);\n            // n-1-A, 1+k+A\n            // n-z, k+z\n            int low = 1+A;\n            int high = min(n, B-k-1);\n            if (low <= high) {\n                f[n][k] += hardpref[n-low][k+low];\n                if (high != n) f[n][k] -= hardpref[n-high-1][k+high+1];\n            }\n            // for (int t = A; 1+t <= min(n, B-k-1); t++) {\n                // f[n][k] += f[n-1-t][1+k+t];\n            // }\n            int z = max(B-k, A+1);\n            if (n-z+1 >= 0) f[n][k] += pot[n-z+1]-1;\n            f[n][k] %= mod;\n            hardpref[n][k] = (hardpref[n-1][k+1] + f[n][k]) % mod;\n        }\n        pref[n+1] = (pref[n] + f[n][1]) % mod;\n    }   \n    // dbg(f[1][2]);\n    if (f[N][0] < 0) f[N][0] += mod;\n    cout << f[N][0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  P operator-() const {\n    P res((*this).size());\n    rep(i, (*this).size()) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, (*this).size()) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q={{0, 1}, {1, -1}}) {\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div();\n  q[1] = 1;\n  q.div();\n  f[1] = 1;\n  f[a] -= 1;\n  f.div();\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+1) g0[i] = 0;\n  rep2(i, b, n+1) g1[i] = 0;\n  rep2(i, b, n+1) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint main() {\n  int n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n  vector dp(n + 1, vector(b + 1, vector(2, 0LL)));\n  dp[0][0][1] = 1;\n  REP(i, n) REP(j, b + 1) REP(k, 2) {\n    // 0\n    if (k == 1) {\n      (dp[i + 1][j == b ? b : 0][0] += dp[i][j][k]) %= MOD;\n      if (i + a <= n) {\n        (dp[i + a][min(j + a, b)][0] += dp[i][j][k]) %= MOD;\n        (dp[i + a][j == b ? b : 0][0] += MOD - dp[i][j][k]) %= MOD;\n      }\n    } else {\n      if (j >= a) {\n        (dp[i + 1][min(j + 1, b)][0] += dp[i][j][k]) %= MOD;\n      } else {\n        (dp[i + 1][j == b ? b : 0][0] += dp[i][j][k]) %= MOD;\n      }\n    }\n    // 1\n    (dp[i + 1][min(j + 1, b)][1] += dp[i][j][k]) %= MOD;\n  }\n  cout << (dp[n][b][true] + dp[n][b][false]) % MOD << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int mod = 1e9 + 7;\n\ninline int Mod(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\n\nint f[5010];\nint g[5010];\nint P[5010];\nint M[5010];\nint F[2][5010];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tint n = ri, A = ri, B = ri, res = 1;\n\tfor(int i = 1; i <= n; i++) res = Mod(res << 1);\n\tif(A == 1 || B == 1) return printf(\"%d\\n\", res), 0;\n\tif(A > B) swap(A, B);\n\tf[0] = 1, g[0] = 1;\n\tfor(int i = A; i < B; i++) {\n\t\tf[i] = Mod(f[i - 1] + g[i - 1]);\n\t\tfor(int j = A; j <= i; j++)\n\t\t\tAdd(g[i], f[i - j]);\n\t}\n\n\tfor(int i = 1; i < B; i++)\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tP[i] = (P[i] + 1LL * g[i - j] * (i == j ? 1 : j)) % mod;\n\tfor(int i = 1; i < B; i++)\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tM[i] = (M[i] + 1LL * g[i - j] * (i == j ? 1 : j - 1)) % mod;\n\n\tF[0][0] = F[1][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j < B; j++) {\n\t\t\tif(i == j || i == n) {\n\t\t\t\tF[1][i] = (F[1][i] + 1LL * F[0][i - j] * P[j]) % mod;\n\t\t\t\tif(i == j) break;\n\t\t\t} else F[1][i] = (F[1][i] + 1LL * F[0][i - j] * M[j]) % mod;\n\t\t}\n\t\tfor(int j = 1; j < A; j++) {\n\t\t\tAdd(F[0][i], F[1][i - j]);\n\t\t\tif(i == j) break;\n\t\t}\n\t}\n\n\tcout << Mod(res + mod - Mod(F[0][n] + F[1][n])) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimze(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#ifndef rd\n#define trace(...)\n#define endl '\\n'\n#endif\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=0x3f3f3f3f3f3f3f3fLL;\nconst int infi=0x3f3f3f3f;\n//const int mod=998244353;\nconst int mod=1000000007;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nauto clk=clock();\nmt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\nint powm(int a, int b) {\n\tint res=1;\n\twhile(b) {\n\t\tif(b&1)\n\t\t\tres=(res*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint fact[10005],ifact[10005];\ninline int ncr(int n, int r) {\n\tif(n<r||r<0||n<0)\n\t\treturn 0;\n\treturn (((fact[n]*ifact[r])%mod)*ifact[n-r])%mod;\n}\nint dp[5005];\nvoid solve() {\n\tfact[0]=1;\n\tfr(i,1,10000)\n\t\tfact[i]=(fact[i-1]*i)%mod;\n\tifact[10000]=powm(fact[10000],mod-2);\n\tfor(int i=9999; i>=0; i--)\n\t\tifact[i]=(ifact[i+1]*(i+1))%mod;\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a!=b)\n\t\texit(1);\n\tif(a<b)\n\t\tswap(a,b);\n\tint lol=1;\n\tfr(i,1,a) {\n\t\tint places=a-b*i-i+1;\n\t\tint r=2*i+1;\n\t\tlol=(lol+ncr(places+r-1,r-1))%mod;\n\t}\n\tint ans=0;\n\tfr(i,a,n) {\n\t\tint times=powm(2,i-a);\n\t\tfr(j,a,i-a) {\n\t\t\tint minus=(dp[j]*powm(2,i-a-j))%mod;\n\t\t\ttimes=(times-minus)%mod;\n\t\t}\n\t\trep(j,i-a+1,i)\n\t\t\ttimes=(times-dp[j])%mod;\n\t\tdp[i]=times;\n\t\ttrace(times);\n\t\tans=(ans+times*powm(2,n-i))%mod;\n\t}\n\ttrace(lol,ans);\n\tif(ans<0)\n\t\tans+=mod;\n\tcout<<(ans*lol)%mod<<endl;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tcout<<fixed<<setprecision(8);\n\tint t=1;\n//\tcin>>t;\n\tfr(i,1,t)\n\t\tsolve();\n#ifdef rd\n\tcout<<endl<<endl<<endl<<endl<<\"Time elapsed: \"<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\n\nint f[10101][2];\nint g[10101][2];\nint dp[5050][2];\n\nint _2[5050];\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\t\n\tif(A > B)\n\t\tswap(A, B);\n\t\n\t_2[0] = 1;\n\tfor(int i = 1; i <= 5000; i++)\n\t\t_2[i] = _2[i - 1] * 2 % mod;\n\tf[0][0] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tf[i][0] += f[i - j][1];\n\t\t\tif(f[i][0] >= mod)\n\t\t\t\tf[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tf[i][1] += f[i-j][0];\n\t\t\t\tif(f[i][1] >= mod)\n\t\t\t\t\tf[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tg[0][1] = 1;\t\n\tfor(int i = 1; i < A + B; i++)\n\t{\n\t\tfor(int j = A; j <= ((i <= B) ? i : A); j++)\n\t\t{\n\t\t\tg[i][0] += g[i - j][1];\n\t\t\tif(g[i][0] >= mod)\n\t\t\t\tg[i][0] -= mod;\n\t\t}\n\t\tif(i <= B)\n\t\t{\n\t\t\tfor(int j = 1; j <= B; j++)\n\t\t\t{\n\t\t\t\tg[i][1] += g[i - j][0];\n\t\t\t\tif(g[i][1] >= mod)\n\t\t\t\t\tg[i][1] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0] = dp[0][1] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tif(i < B)\n\t\t{\n\t\t\tdp[i][1] += g[i][1];\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < min(i, B); j++)\n\t\t{\n\t\t\tdp[i][1] += 1ll * f[j][1] * dp[i - j][0] % mod;\n\t\t\tif(dp[i][1] >= mod)\n\t\t\t\tdp[i][1] -= mod;\n\t\t}\n\t\tfor(int j = 1; j < min(i, A); j++)\n\t\t{\n\t\t\tdp[i][0] += dp[i - j][1];\n\t\t\tif(dp[i][0] >= mod)\n\t\t\t\tdp[i][0] -= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= N; i++)\n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\tfor(int j = B; j < A + B; j++)\n\t\t\tif(i + j <= N)\n\t\t\t{\n\t\t\t\tans += 1ll * dp[i][1] * (g[j][0] + g[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\t\tif(ans >= mod)\n\t\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j = B; j < A + B; j++)\n\t\tif(i + j <= N)\n\t\t{\n\t\t\tans += 1ll * dp[i][0] * (f[j][0] + f[j][1]) % mod * _2[N - i - j] % mod;\n\t\t\tif(ans >= mod)\n\t\t\t\tans -= mod; \n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end()))\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\nmint dp0[5500][2], dp1[5500][3][2];\nsigned main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    if (B > A) { swap(A, B); }\n    if (B == 1) { fin(mint(2).pow(N)); }\n    dp0[0][0] = 1, dp0[0][1] = 1;\n    rep(i, N) {\n        for (int j = 1; i + j <= N; j++) { dp0[i + j][0] += dp0[i][1]; }\n        for (int j = B; i + j <= N; j++) { dp0[i + j][1] += dp0[i][0]; }\n    }\n    dp1[0][0][0] = 1, dp1[0][1][0] = 1;\n    rep(i, N) {\n        for (int j = 1; j < A && i + j <= N; j++) {\n            if (i != 0 && i + j != N) {\n                dp1[i + j][2][0] += dp1[i][1][0] * dp0[j - 1][0];\n                dp1[i + j][2][1] += dp1[i][1][1] * dp0[j - 1][0];\n            } else if (j != N) {\n                dp1[i + j][2][0] += dp1[i][1][0] * dp0[j][0];\n                dp1[i + j][2][1] += dp1[i][1][1] * dp0[j][0];\n            } else {\n                dp1[i + j][2][0] += dp1[i][1][0] * (dp0[j][0] + dp0[j][1]);\n                dp1[i + j][2][1] += dp1[i][1][1] * (dp0[j][0] + dp0[j][1]);\n            }\n        }\n        for (int j = 1; j < B && i + j <= N; j++) {\n            dp1[i + j][1][0] += dp1[i][0][0];\n            dp1[i + j][1][1] += dp1[i][0][1];\n            dp1[i + j][1][0] += dp1[i][2][0];\n            dp1[i + j][1][1] += dp1[i][2][1];\n        }\n        for (int j = A; i + j <= N; j++) {\n            if (i != 0 && i + j != N) {\n                dp1[i + j][2][1] += dp1[i][1][0] * dp0[j - 1][0];\n                dp1[i + j][2][1] += dp1[i][1][1] * dp0[j - 1][0];\n            } else if (j != N) {\n                dp1[i + j][2][1] += dp1[i][1][0] * dp0[j][0];\n                dp1[i + j][2][1] += dp1[i][1][1] * dp0[j][0];\n            } else {\n                dp1[i + j][2][1] += dp1[i][1][0] * (dp0[j][0] + dp0[j][1]);\n                dp1[i + j][2][1] += dp1[i][1][1] * (dp0[j][0] + dp0[j][1]);\n            }\n        }\n    }\n    cout << dp1[N][0][1] + dp1[N][1][1] + dp1[N][2][1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define sz(x) (int)x.size()\n#define ld long double\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define f first\n#define s second\n\nusing namespace std;\n\nconst ll INF = 2e18;\nconst ll MOD = 1e9 + 7;\n\nll n, a, b, res = 0;\nvector<ll> p2, g;\nvector<vector<ll>> dp1, dp2;\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> a >> b;\n    p2.assign(n + 1, 1);\n    for(int i = 0; i < n; ++i){\n        p2[i + 1] = p2[i] * 2;\n        p2[i + 1] %= MOD;\n    }\n    if(a > b) swap(a, b);\n    if(b == 1){\n        cout << p2[n];\n        return 0;\n    }\n    dp1.assign(n + 1, vector<ll>(2, 0));\n    dp2.assign(n + 1, vector<ll>(2, 0));\n    dp1[0][0] = dp1[0][1] = 1;\n    for(int i = 1; i <= n; ++i){\n        for(int k = 0; k < 2; ++k){\n            for(int j = 1; j <= i; ++j){\n                if(!k && j < a) continue;\n                dp1[i][k] += dp1[i - j][k ^ 1];\n                dp1[i][k] %= MOD;\n            }\n        }\n    }\n    g.assign(n + 1, 0);\n    g[0] = 1;\n    for(int i = 1; i <= n; ++i){\n        g[i] = dp1[i][0] + dp1[i][1];\n        g[i] %= MOD;\n    }\n    for(ll i = 1; i < n; ++i){\n        if(i < a) dp2[i][0]++;\n        for(ll j = 0; j < min(i, a); ++j){\n            dp2[i][0] += dp2[i - j][1];\n            dp2[i][0] %= MOD;\n        }\n        if(i < b){\n            dp2[i][1] += g[i - 1];\n            dp2[i][1] %= MOD;\n        }\n        for(ll j = 1; j < min(i, b); ++j){\n            ll w = j == 1 ? 1 : g[j - 2];\n            dp2[i][1] += dp2[i - j][0] * w;\n            dp2[i][1] %= MOD;\n        }\n        if(n - i < b){\n            res += dp2[i][0] * g[n - i - 1];\n            res %= MOD;\n        }\n        if(n - i < a){\n            res += dp2[i][1];\n            res %= MOD;\n        }\n    }\n    cout << ((p2[n] - res)%MOD + MOD)%MOD;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint n,a,b;\nint dp[5005][5005][2],sum[5005][5005][2];\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod)x-=mod;\n}\ninline void sub(int &x,int y){\n\tx-=y;if(x<0)x+=mod;\n}\ninline int Add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int Sub(int x,int y){\n\treturn x>=y?x-y:x-y+mod;\n}\nint main(){\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\tdp[1][0][0]=1;\n\tdp[1][0][1]=1;\n\tadd(sum[1][0][1],dp[1][0][1]);\n\tadd(sum[1][0][0],dp[1][0][0]); \n\tfor(int i=2;i<=n+1;i++){\n\t\tfor(int j=0;j<=5000;j++){\n\t\t\tif(j)add(sum[i][j][1],sum[i-1][j-1][1]);\n\t\t\tif(j)add(sum[i][j][0],sum[i-1][j-1][0]);\n\t\t\tif(j)add(dp[i][0][1],Sub(sum[i-1][j-1][0],(i>=a&&j>=a?sum[i-a][j-a][0]:0)));\n\t\t\tif(j>=b)continue;\n\t\t\tif(j)add(dp[i][j][0],sum[i-1][j-1][1]);\n\t\t\tadd(dp[i][j][1],(i>=a&&j>=a?sum[i-a][j-a][0]:0));\n\t\t}\n\t\tfor(int j=0;j<b;j++){\n\t\t\tadd(sum[i][j][1],dp[i][j][1]);\n\t\t\tadd(sum[i][j][0],dp[i][j][0]);\n//\t\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[i][j][0]<<\" \"<<dp[i][j][1]<<endl;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<b;i++){\n\t\tadd(ans,dp[n+1][i][0]);\n\t\tadd(ans,dp[n+1][i][1]);\n\t}\n\tans=Sub(modpow(2,n,mod),ans);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 5005\nconst int mod=1e9+7;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,f[N][2],dp[N][2],g[N],A,B,ans;\n#define ck(x) (x>=mod?x-mod:x) \nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read(),A=read(),B=read();\n\tif(A>B)swap(A,B);\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<B;++i){\n\t\tfor(int j=A;j<=i;++j){\n\t\t\tf[i][0]=ck(f[i][0]+f[i-j][1]);\n\t\t}\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tf[i][1]=ck(f[i][1]+f[i-j][0]);\n\t\t}\n\t}\n\tg[0]=1;\n\tfor(int i=1;i<B;++i){\n\t\tg[i]=ck(f[i][0]+f[i][1]);\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tdp[i][0]+=(i<A);\n\t\tdp[i][1]+=(i<B?f[i][1]:0);\n\t\tfor(int j=1;j<min(i,A);++j){\n\t\t\tdp[i][0]=ck(dp[i][0]+dp[i-j][1]);\n\t\t}\n\t\tfor(int j=1;j<min(i,B);++j){\n\t\t\tdp[i][1]=(dp[i][1]+1LL*dp[i-j][0]*(j==1?1:g[j-2]))%mod;\n\t\t}\n\t\tif(n-i<A)ans=ck(ans+dp[i][1]);\n\t\tif(n-i<B)ans=(ans+1LL*dp[i][0]*g[n-i-1])%mod;\n\t}\n\tprintf(\"%d\\n\",(qpow(2,n)-ans+mod)%mod);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 5010;\nconst int mod = 1e9+7;\n\nint n, A, B;\nint f[maxn][2], g[maxn][2], a[maxn][maxn], h[maxn];\n\nint calh(int l, int a, int b) {\n\tif (!a && !b) return h[l];\n\tif (l == 1) return 1;\n\treturn h[l - a - b];\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tif (A > B) swap(A, B);\n\tf[0][0] = g[0][0] = 1;\n\ta[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (!j || j >= A) a[i][0] = (a[i][0] + a[i-1][j]) % mod;\n\t\t\ta[i][j+1] = (a[i][j+1] + a[i-1][j]) % mod;\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\th[i] = (h[i] + a[i][0]) % mod;\n\t\tfor (int j = A; j <= i; j++) {\n\t\t\th[i] = (h[i] + a[i][j]) % mod;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int k = 1; k < A; k++) {\n\t\t\tf[i][0] = (f[i][0] + g[i-k][0]) % mod;\n\t\t\tf[i][1] = (f[i][1] + g[i-k][1]) % mod;\n\t\t}\n\t\tfor (int k = 1; k < B && k <= i; k++) {\n\t\t\tg[i][0] = (g[i][0] + 1LL * f[i-k][0] * calh(k, k < i, i != n) % mod) % mod;\n\t\t}\n\t\tfor (int k = 1; k <= i; k++) {\n\t\t\tg[i][1] = (g[i][1] + 1LL * f[i-k][1] * calh(k, k < i, i != n) % mod) % mod;\n\t\t}\n\t\tfor (int k = B; k <= i; k++) {\n\t\t\tg[i][1] = (g[i][1] + 1LL * f[i-k][0] * calh(k, k < i, i != n) % mod) % mod;\n\t\t}\n\t}\n\tint ans = (f[n][1] + g[n][1]) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, a, b; cin >> n >> a >> b;\n    if(a == 1 || b == 1) {\n        cout << modpow((mint)2, n) << endl;\n        return;\n    }\n    if(a < b) swap(a, b);\n    static mint dp[5050][5050][2][2][3];\n    rep(i, 5050) {\n        rep(j, 5050) {\n            rep(k, 2) {\n                rep(l, 2) {\n                    rep(m, 2) {\n                        dp[i][j][k][l][m] = 0;\n                    }\n                }\n            }\n        }\n    }\n    dp[0][0][0][0][0] = 1;\n    rep(i, n) {\n        rep(j, n + 1) {\n                rep(l, 2) {\n                    rep(m, 3) {\n                        int nl, nm;\n                        nl = (l || (j + 1 >= a)), nm = m;\n                        dp[i + 1][j + 1][0][nl][nm] += dp[i][j][0][l][m];\n                        nl = l, nm = m;\n                        dp[i + 1][1][1][nl][nm] += dp[i][j][0][l][m];\n                        nl = l, nm = m;\n                        dp[i + 1][j + 1][1][nl][nm] += dp[i][j][1][l][m];\n                        nl = l;\n                        if(i - j >= a && j <= b - 1) nm = (m == 0 ? 1 : 2);\n                        else if(n - i >= a && j <= b - 1) nm = (m == 0 ? 1 : 2);\n                        else if(j <= b - 1) nm = 2;\n                        else nm = m;\n                        dp[i + 1][1][0][nl][nm] += dp[i][j][1][l][m];\n                    }\n                }\n        }\n    }\n    mint ans = 0;\n    rep(j, n + 1) {\n        rep(m, 2) {\n            rep(k, 2) {\n                ans += dp[n][j][k][1][m];\n            }\n            ans += dp[n][j][0][0][m];\n        }\n        if(j >= b) {\n            ans += dp[n][j][1][0][0] + dp[n][j][1][0][1];\n        }\n        else {\n            if(n - j >= a) ans += dp[n][j][1][0][0];\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,a[2];cin>>n>>a[0]>>a[1];\n    if(a[0]<a[1])swap(a[0],a[1]);\n    static ll dp[5010][5010];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    ll sum1[n+1];\n    memset(sum1,0,sizeof sum1);\n    sum1[0]=1;\n    static ll sum2[5010][5010];\n    memset(sum2,0,sizeof sum2);\n    sum2[0][0]=1;\n    rep(i,1,n+1){\n        rep(j,1,a[0]){\n            if(j==1){\n                ll le=max(i-a[1],(ll)0);\n                if(i==1){\n                    dp[i][j]=1;\n                }\n                else{\n                    if(le==0)dp[i][j]=sum1[i-2];\n                    else dp[i][j]=(sum1[i-2]-sum1[le-1]+mod)%mod;\n                }\n            }\n            else if(j<=a[1]){\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else{\n                if(i<j)continue;\n                dp[i][j]=(sum2[i-j][i-(a[1]+1)]+dp[i-1][j-1])%mod;\n            }\n        }\n        sum1[i]=sum1[i-1];\n        rep(j,1,i+1){\n            (sum1[i]+=dp[i][j])%=mod;\n            sum2[i-j][i]=(sum2[i-j][i-1]+dp[i][j])%mod;\n        }\n    }\n    /*rep(i,0,n+1){\n        rep(j,0,n+1)cout<<dp[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    ll ans=beki(2,n,mod);\n    ll sum=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            ll noko=n-i;\n            if(noko<a[1])noko=0;\n            if(j+noko<a[0]){\n                (sum+=dp[i][j])%=mod;\n            }\n        }\n    }\n    ans=ans-sum+mod;\n    cout<<ans%mod<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,a,b,f[5050][2],g[5050],dp[5050][2],ans;\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tif(a>b)swap(a,b);\n\tif(b>=2)\n\t{\n\t\tf[0][0]=f[0][1]=1;\n\t\tfor(int i=1;i<=b;++i)\n\t\t\tfor(int j=1;j<=i;++j)\n\t\t\t{\n\t\t\t\tif(j>=a)add(f[i][0],f[i-j][1]);\n\t\t\t\tadd(f[i][1],f[i-j][0]);\n\t\t\t}\n\t\tg[0]=1;\n\t\tfor(int i=1;i<=b;++i)g[i]=pl(f[i][0],f[i][1]);\n\t//\tfor(int i=1;i<=b;++i)printf(\"%d \",g[i]);printf(\"\\n\");\n\t\tdp[0][0]=dp[0][1]=1;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=i;++j)\n\t\t\t{\n\t\t\t\tif(j<b)dp[i][1]=(dp[i][1]+1ll*dp[i-j][0]*g[max(j-(i!=j)-(i!=n),0)])%mod;\n\t\t\t\tif(j<a)add(dp[i][0],dp[i-j][1]);\n\t\t\t}\n\t//\tfor(int i=1;i<=n;++i)printf(\"%d %d\\n\",dp[i][0],dp[i][1]);\n\t\tans=pl(dp[n][0],dp[n][1]);\n\t}\n\tprintf(\"%d\",pl(kpow(2,n),mod-ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, a, b;\nint dp[5001][2][2][5001];\t//dp[index][nowChar][flag(1:既に条件を満たす)][len] = 何通り？\n\nsigned main() {\n\tint i, j, k, l, m;\n\t\n\tcin >> n >> a >> b;\n\tif (a > b) { swap(a, b); }\n\t\n\t//最初1文字以上の0からスタート\n\tfor (i = 1; i <= n; i++) {\n\t\tif (i < a) {\n\t\t\tdp[i][1][0][0] += 1;\n\t\t}\n\t\telse if (i < b) {\n\t\t\tdp[i][1][0][i] += 1;\n\t\t}\n\t\telse {\n\t\t\tdp[i][1][1][i] += 1;\n\t\t}\n\t}\n\t\n\t//最初1文字以上の1からスタート\n\tfor (i = 1; i <= n; i++) {\n\t\tif (i < b) {\n\t\t\tdp[i][0][0][i] += 1;\n\t\t}\n\t\telse {\n\t\t\tdp[i][0][1][i] += 1;\n\t\t}\n\t}\n\t\n\t//i文字使った状態\n\tfor (i = 1; i < n; i++) {\n\t\t//今から1文字以上のj(=0,1)で埋める\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\t//k=0:未成功, k=1:成功\n\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\t//l文字利用できる\n\t\t\t\tfor (l = 0; l <= i; l++) {\n\t\t\t\t\tif (dp[i][j][k][l] == 0) continue;\n\t\t\t\t\t//m文字連続でjを埋める\n\t\t\t\t\tfor (m = 1; i + m <= n; m++) {\n\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\t(dp[i + m][!j][k || (l + m >= b)][l + m] += dp[i][j][k][l]) %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (m < a) {\n\t\t\t\t\t\t\t\t(dp[i + m][!j][k][0] += dp[i][j][k][l]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t(dp[i + m][!j][k || (l + m >= b)][l + m] += dp[i][j][k][l]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t//i文字使った状態\n\tfor (i = n; i <= n; i++) {\n\t\t//今から1文字以上のj(=0,1)で埋める\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tfor (l = 0; l <= i; l++) {\n\t\t\t\tans += dp[i][j][1][l];\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 _y0\n#define kill _kill\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll btc = 30;\nconst ld eps = 1e-8;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 1e9 + 7;\n\n//random\n#ifdef ONPC\nmt19937_64 rnd(239);\n#else\nmt19937_64 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n//constants\nconst int M = (int)(2e5 + 239);\nconst int N = (int)(2e3 + 239);\nconst int L = 19;\nconst int T = (1 << 18) + 239;\nconst int B = 500;\nconst int X = 5010;\n\nint n, a, b;\n\nbool ok_a(string s)\n{\n    bool has = false;\n    for (int i = 0; i < s.size(); i++)\n        has |= (s[i] == '0');\n    if (!has)\n        return false;\n    int cur = -1;\n    int cnt = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] - '0' == cur)\n        {\n            cnt++;\n            continue;\n        }\n        if (cur == 0)\n        {\n            if (cnt < a)\n                return false;\n        }\n        cur = s[i] - '0';\n        cnt = 1;\n    }\n    if (cur == 0)\n    {\n        if (cnt < a)\n            return false;\n    }\n    return true;\n}\n\nbool ok_b(string s)\n{\n    bool has = false;\n    for (int i = 0; i < s.size(); i++)\n        has |= (s[i] == '1');\n    if (!has)\n        return false;\n    int cur = -1;\n    int cnt = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] - '0' == cur)\n        {\n            cnt++;\n            continue;\n        }\n        if (cur == 1)\n        {\n            if (cnt < b)\n                return false;\n        }\n        cur = s[i] - '0';\n        cnt = 1;\n    }\n    if (cur == 1)\n    {\n        if (cnt < b)\n            return false;\n    }\n    return true;\n}\n\nbool check(string s)\n{\n    for (int i = 0; i < n; i++)\n        for (int j = i; j < n; j++)\n            if (j - i + 1 >= a)\n                if (ok_b(s.substr(i, j - i + 1)))\n                    return true;\n    for (int i = 0; i < n; i++)\n        for (int j = i; j < n; j++)\n            if (j - i + 1 >= b)\n                if (ok_a(s.substr(i, j - i + 1)))\n                    return true;\n    return false;\n}\n\nvoid slow()\n{\n    int ans = 0;\n    for (int mask = 0; mask < (1 << n); mask++)\n    {\n        string s = \"\";\n        for (int i = 0; i < n; i++)\n            s += (char)('0' + ((mask >> i) & 1));\n        if (check(s))\n        {\n            ans++;\n            //cerr << s << \"\\n\";\n        }\n    }\n    cout << \"correct: \" << ans << \"\\n\";\n}\n\nint help[X], dp[two][X];\n\nint32_t main()\n{\n#ifdef ONPC\n    freopen(\"input\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> a >> b;\n    if (a < b)\n        swap(a, b);\n    help[0] = 1;\n    for (int i = 1; i < a; i++)\n    {\n        help[i] = help[i - 1];\n        if (i >= b)\n        {\n            help[i]++;\n            if (help[i] >= MOD)\n                help[i] -= MOD;\n        }\n        for (int j = b; j + 1 <= i; j++)\n        {\n            help[i] += help[i - 1 - j];\n            if (help[i] >= MOD)\n                help[i] -= MOD;\n        }\n    }\n    dp[0][0] = 1;\n    dp[1][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        dp[0][i] = 0;\n        for (int j = 1; j <= min(i, a - 1); j++)\n        {\n            int now = 0;\n            if (i == j)\n            {\n                if (i == n)\n                    now = help[j];\n                else\n                    now = help[j - 1];\n            }\n            else\n            {\n                if (i == n)\n                    now = help[j - 1];\n                else\n                {\n                    if (j == 1)\n                        now = 1;\n                    else\n                        now = help[j - 2];\n                }\n            }\n            dp[0][i] += 1LL * dp[1][i - j] * now % MOD;\n            if (dp[0][i] >= MOD)\n                dp[0][i] -= MOD;\n        }\n        dp[1][i] = 0;\n        for (int j = 1; j <= min(i, b - 1); j++)\n        {\n            dp[1][i] += dp[0][i - j];\n            if (dp[1][i] >= MOD)\n                dp[1][i] -= MOD;\n        }\n    }\n    int bad = dp[0][n] + dp[1][n];\n    if (bad >= MOD)\n        bad -= MOD;\n    int all = 1;\n    for (int i = 0; i < n; i++)\n    {\n        all += all;\n        if (all >= MOD)\n            all -= MOD;\n    }\n    all -= bad;\n    if (all < 0)\n        all += MOD;\n    cout << all << \"\\n\";\n#ifdef ONPC\n    if (n <= 10)\n        slow();\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst i64 P = 1000000000 + 7;\n\nconst int maxn = 5100;\ni64 dp[maxn][2];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, a, b;\n    cin >> n >> a >> b;\n    i64 ans;\n    i64 d2 = 1;\n    forn(i, n) (d2 *= 2) %= P;\n    if (a == b) {\n        vi64 dp(n + 1);\n        dp[0] = 1;\n        for1(i, n) for1(j, a - 1) if (j <= i) (dp[i] += dp[i - j]) %= P;\n        ans = d2 - 2 * dp[n];\n        ans %= P;\n        if (ans < 0) ans += P;\n    } else {\n        if (a > b) swap(a, b);\n        vi64 sh(b + 1);\n        sh[1] = 1;\n        forn(i, b + 1) for1(j, b - i) {\n            int l = a, r = j - 1;\n            if (l <= r) (sh[i + j] += sh[i] * (r - l + 1)) %= P;\n        }\n        forn(i, b) (sh[i + 1] += sh[i]) %= P;\n//        forn(i, b) cerr << sh[i] << ' ';\n//        cerr << '\\n';\n\n        dp[0][0] = 1;\n        forn(i, n + 2) {\n//            forn(z, 2) cerr << dp[i][z] << ' ';\n//            cerr << '\\n';\n            for1(j, a - 1) if (i + j <= n + 2) (dp[i + j][0] += dp[i][1]) %= P;\n            for1(j, b) {\n                if (j == b && i && i + j < n + 2) continue;\n                if (i + j <= n + 2) (dp[i + j][1] += dp[i][0] * sh[j]) %= P;\n            }\n        }\n\n        ans = d2;\n        (ans -= dp[n + 2][1]) %= P;\n        if (ans < 0) ans += P;\n    }\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int Mod = 1e9 + 7;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\nint ksm(int a, int b){ int as=1; for(;b;b>>=1,Mul(a,a))if(b&1)Mul(as,a); return as; }\ncs int N = 5e3 + 50;\nint n, A, B, dp[N][2], f[N][2];\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(A > B) swap(A,B);\n\tf[1][1] = 1;\n\tfor(int i=2; i<B; i++){\n\t\tAdd(f[i][1],add(f[i-1][0],f[i-1][1]));\n\t\tfor(int j=A; j<i; j++)\n\t\tAdd(f[i][0],f[i-j][1]);\n\t} dp[0][0] = dp[0][1] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<min(A,i+1); j++)\n\t\tAdd(dp[i][0],dp[i-j][1]);\n\t\tfor(int j=1; j<min(B,i+1); j++){\n\t\t\tif(i==n)Add(dp[i][0],mul(dp[i-j][0],f[j][0]));\n\t\t\tif(i==j)Add(dp[i][1],add(f[j][0],f[j][1]));\n\t\t\telse Add(dp[i][1],mul(dp[i-j][0],f[j][1]));\n\t\t}\n\t} cout<<dec(ksm(2,n),add(dp[n][0],dp[n][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long N, A, B;\nlong long dp[6009][6009][2];\nlong long ru[6009][6009];\nlong long power[6009];\nlong long Answer;\n\nvoid init() {\n\tpower[0] = 1;\n\tfor (int i = 1; i <= 5000; i++) power[i] = (2LL * power[i - 1]) % mod;\n}\n\nvoid solve(int pos) {\n\t// 累積和を取る\n\tfor (int i = 0; i <= N; i++) {\n\t\tru[pos][i] = ru[pos - 1][i];\n\t\tru[pos][i] += dp[pos - 1][i][0];\n\t\tru[pos][i] %= mod;\n\t}\n\n\t// 長い方を使う場合\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[pos][i][0] += dp[pos - 1][i][1];\n\t\tdp[pos][i][0] += dp[pos - 1][i][0];\n\t\tdp[pos][i][0] %= mod;\n\t\tif ((pos - i) >= A) {\n\t\t\tAnswer += dp[pos][i][0] * power[N - pos];\n\t\t\tAnswer %= mod;\n\t\t\tdp[pos][i][0] = 0;\n\t\t}\n\t}\n\n\t// 短い方を使う場合（そして失敗する場合）\n\tlong long rem = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tint cl = pos - B + 1, cr = pos - 1;\n\t\trem += (ru[cr + 1][i] - ru[cl][i] + mod) % mod;\n\t\trem %= mod;\n\t}\n\tdp[pos][pos][1] = rem;\n\n\t// 短い方を使う場合（そして成功する場合）\n\tfor (int i = 0; i <= N; i++) {\n\t\tint cr = pos - B;\n\t\tlong long val = ru[cr + 1][i];\n\t\tdp[pos][i][1] += val;\n\t\tif ((pos - i) >= A) {\n\t\t\tAnswer += dp[pos][i][1] * power[max(0LL, N - pos - 1)];\n\t\t\tAnswer %= mod;\n\t\t\tdp[pos][i][1] = 0;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> A >> B;\n\tif (A < B) swap(A, B);\n\tinit();\n\n\tdp[0][0][0] = 1;\n\tfor (int i = 1; i <= N; i++) solve(i);\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int P = 1e9 + 7;\nconst int N = 5e3 + 5;\nint dp[N][N];\nint pref[N][N];\nint all[N];\nint kon1[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, a, b;\n  cin>>n>>a>>b;\n  if (a > b) {\n    swap(a, b);\n  }\n  // mamy a < b\n  // po zastiapeniu ciagow >=a zer jedynkami ma byc ciag b jedynek\n  // dp[i][len] - liczba takich ciagow ze najdluzszy sufiks jedynek po zastapieniu ciagow a zer jedynkami ma dlugosc len\n  \n  //VVI dp(n + 2, VI(n + 2));\n  dp[0][0] = 1;\n  pref[0][0] = 1;\n  all[0] = 1;\n  kon1[0] = 1;\n  RE (i, n) {\n    REP (len, min(b, i + 1)) {\n      if (len) {\n        dp[i][len] = dp[i - 1][len - 1]; // dokladam 1\n        kon1[i] = (kon1[i] + dp[i][len]) % P;\n        pref[i - len][i] = (pref[i - len][i - 1] + dp[i][len]) % P;\n      } else {\n        dp[i][0] = dp[i - 1][0]; // dokladam 0 po zerze\n        if (i >= 2) {\n          dp[i][0] = (dp[i][0] + kon1[i - 1] + P) % P;\n        }\n        if (i >= a) {\n          dp[i][0] = (dp[i][0] - kon1[i - a] + P) % P;\n        }\n      }\n      // dp[i][len] += dp[i - x][len - x]  po x >= a gdzie koncza sie 1\n      if (i >= a) {\n        dp[i][len] = (dp[i][len] + pref[i - len][i - a]) % P; // dokladam 0\n      }\n      \n      all[i] = (all[i] + dp[i][len]) % P;\n      debug(i, len, dp[i][len]);\n    }\n  }\n  int res = 1;\n  RE (i, n) {\n    res = 2 * res % P;\n  }\n  if (a == 1) {\n    cout<<res<<endl;\n    return 0;\n  }\n  REP (len, n) {\n    res = (res - dp[n][len] + P) % P;\n  }\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nvector<int64_t> fact, fact_inv;\n\nvoid create_mod_tables(int num){\n    fact.assign(num+1, 1);\n    fact_inv.assign(num+1, 1);\n    for(int i=1; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n    fact_inv[num] = inv_mod(fact[num]);\n    for(int i=num; i>0; i--) fact_inv[i-1] = fact_inv[i] * i % MOD;\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint main(){\n    int N, A, B;\n    cin >> N >> A >> B;\n    if(A > B) swap(A, B);\n\n    // i番目まで、Bがj個、最後がどっちか、フィーバーかどうか\n    static int64_t dp[5001][5001][2][2];\n    dp[0][0][1][0] = 1;\n\n    for(int i=0; i<N; i++) for(int j=0; j<B; j++) for(int l=0; l<2; l++) for(int f=0; f<2; f++){\n        if(i+A <= N && l && !f){\n            if(j+A < B) add(dp[i+A][j+A][0][1], dp[i][j][l][f]);\n            add(dp[i+A][0][0][0], MOD - dp[i][j][l][f]);\n        }\n        for(int n=0; n<2; n++){\n            int j2 = (n||f ? j+1 : 0);\n            int l2 = n;\n            int f2 = f && !n;\n            if(j2 < B) add(dp[i+1][j2][l2][f2], dp[i][j][l][f]);\n        }\n    }\n\n    int64_t ans = power_mod(2, N);\n    for(int j=0; j<B; j++) for(int l=0; l<2; l++) for(int f=0; f<2; f++) add(ans, MOD - dp[N][j][l][f]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const p=1e9+7;\nint f[5005][2],g[5005][2];\nint mod(int x){return x>=p?x-p:x;}\nint main()\n{\n    int n,a,b;\n    scanf(\"%d%d%d\",&n,&a,&b);\n    if(a>b)swap(a,b);\n    g[1][1]=1;\n    for(int i=2;i<b;i++)\n    {\n        for(int j=1;j<=i-a;j++)\n            g[i][0]=mod(g[i][0]+g[j][1]);\n        g[i][1]=mod(g[i-1][0]+g[i-1][1]);\n    }\n    f[0][0]=f[0][1]=1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=max(i-a+1,0);j<i;j++)f[i][0]=mod(f[i][0]+f[j][1]);\n        for(int j=max(i-b+1,0);j<i;j++)\n        {\n            if(i==n)f[i][0]=(f[i][0]+1ll*f[j][0]*g[i-j][0])%p;\n            if(j==0)f[i][1]=(1ll*f[i][1]+g[i][0]+g[i][1])%p;\n            else f[i][1]=(f[i][1]+1ll*f[j][0]*g[i-j][1])%p;\n        }\n    }\n    int pw=1;\n    for(int i=1;i<=n;i++)pw=mod(pw+pw);\n    printf(\"%lld\",(1ll*pw+p+p-f[n][0]-f[n][1])%p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 5e3+10;\nint n,a,b,f[N],g[N][2];\nvoid add(int &x, ll y) {x=(x+y)%P;}\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tif (a>b) swap(a,b);\n\tf[1] = f[2] = 1;\n\tREP(i,3,n) {\n\t\tf[i] = f[i-1];\n\t\tREP(j,1,i-a-1) add(f[i],f[j]);\n\t}\n\tREP(i,1,b-1) g[i][1] = f[i];\n\tREP(i,1,a-1) g[i][0] = 1;\n\tREP(i,a,b-1) REP(j,1,b-1-i) add(g[i+j][1],f[j]);\n\tREP(i,1,n) {\n\t\tREP(j,1,min(n-i,a-1)) add(g[i+j][0],g[i][1]);\n\t\tREP(j,1,min(n-i,b-1)) add(g[i+j][1],(ll)g[i][0]*f[j]);\n\t}\n\tint ans = (g[n][0]+g[n][1])%P;\n\tREP(i,a,b-1) REP(j,1,b-1-i) add(ans,(ll)g[n-i-j][0]*f[j]);\n\tans = (qpow(2,n)-ans)%P;\n\tif (ans<0) ans += P;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=1e9+7;\nint add(int a,int b){\n\treturn a+b>=MOD?a+b-MOD:a+b;\n}\nint sub(int a,int b){\n\treturn a-b>=0?a-b:a-b+MOD;\n}\nvoid dadd(int &a,int b){\n\ta=add(a,b);\n}\nint mul(int a,int b){\n\treturn (LL)a*b%MOD;\n}\nconst int N=5050;\nint f[N][N+1]={0};\nint g[N][N+1]={0};\nint h[N][N+1]={0};\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tif(a>b)swap(a,b);\n\tf[n+1][b]=1;\n\tg[n+1][b]=1;\n\th[n+1][b]=1;\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j=0;j<b-1;j++){\n\t\t\tint &ans=f[i][j];\n\t\t\tans=f[i+1][min(j+1,b)];\n\t\t\tdadd(ans,h[i+2][0]);\n\t\t\tint s=i+a+1;\n\t\t\tif(s<=n+1){\n\t\t\t\tdadd(ans,sub(0,h[s][0]));\n\t\t\t\tint t=max(s-1,min(b+i-j,n+1))+1;\n\t\t\t\tdadd(ans,g[s][j-i+s]);\n\t\t\t\tif(t<=n+1){\n\t\t\t\t\tdadd(ans,g[t][j-i+t]);\n\t\t\t\t\tdadd(ans,h[t][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=b-1;j<=b;j++){\n\t\t\tf[i][j]=h[i+1][b];\n\t\t}\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tg[i][j]=add(g[i+1][j+1],f[i][j]);\n\t\t}\n\t\tfor(int j=0;j<=b;j++){\n\t\t\th[i][j]=add(h[i+1][j],f[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int k=0;k+1<=n+1;k++){\n\t\tdadd(ans,f[k+1][k>=a?min(k,b):0]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using P = Polynomial;\n  int n = (*this).size();\n  P operator-() const {\n    P res(n);\n    rep(i, n) res[i] = -(*this)[i];\n    return res;\n  }\n  P &operator+=(const P q) {\n    rep(i, n) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  P &operator-=(const P q) {\n    rep(i, n) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  P &operator*=(const P q) {\n    drep(i, n) {\n      (*this)[i] *= q[0];\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] += q[j] * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &operator/=(const P q) {\n    rep(i, n) {\n      rep2(j, 1, q.size()) if (j <= i) (*this)[i] -= q[j] * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  P operator+(const P q) const { return P(*this) += q; }\n  P operator-(const P q) const { return P(*this) -= q; }\n  P operator*(const P q) const { return P(*this) *= q; }\n  P operator/(const P q) const { return P(*this) /= q; }\n  P &mul(map<int, T> q) {\n    drep(i, n) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j > 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  P &div(map<int, T> q={{0, 1}, {1, -1}}) {\n    rep(i, n) {\n      for (auto &[j, b]: q) if (j > 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div();\n  q[1] = 1;\n  q.div();\n  f[1] = 1;\n  f[a] -= 1;\n  f.div();\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+1) g0[i] = 0;\n  rep2(i, b, n+1) g1[i] = 0;\n  rep2(i, b, n+1) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 5010\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 1000000007\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nint n, a, b;\nll dp[maxn][maxn]; // \nll pw[maxn];\nll s[maxn * 2][maxn]; // 第二维固定的和 \nll tt[maxn * 2];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> a >> b;\n\tif (a > b) swap(a, b);\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * 2 % mod;\n\tfor (int i = n + 1; i >= 0; i--) {\n\t\t//当前1的位置\n\t\tfor (int j = 1; j <= i + 1; j++) {\n\t\t\tint nl = i - j + 1;\n\t\t\tif (i == n + 1) nl--;\n\t\t\tif (nl >= b) dp[i][j] = pw[max(0, n - i)];\n\t\t\telse {\n\t\t\t\tdp[i][j] = (s[i + a + 1][j] + dp[i + 1][j]);\n\t\t\t\tdp[i][j] += tt[i + 2] - tt[i + a + 1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t\tif (dp[i][j] < 0) dp[i][j] += mod;\n\t\t\t}\n\t\t\ts[i][j] = (s[i + 1][j] + dp[i][j]) % mod;\n\t\t\tif (i == j) \n\t\t\t\ttt[i] = (tt[i + 1] + dp[i][i]) % mod; \n\t\t}\n\t} \n\tcout << dp[0][1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nll dp[10101][2];\nll dp2[10101][2];\nll dp3[10101][2];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\t\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tif (a > b)swap(a, b);\n\tif (a == 1) {\n\t\tcout << mod_pow(2, n, MOD) << \"\\n\";\n\t\treturn 0;\n\t}\n\t\n\tll ans = mod_pow(2, n, MOD);\n\tdp2[1][0] = 1;\n\trep(i, 1, n) {\n\t\t(dp2[i + 1][0] += dp2[i][1] + dp2[i][0]) %= MOD;\n\t\trep(j, a, n)(dp2[i + j][1] += dp2[i][0]) %= MOD;\n\t}\n\tdp3[0][0] = 1;\n\tREP(i, n) {\n\t\t(dp3[i + 1][0] += dp3[i][1] + dp3[i][0]) %= MOD;\n\t\trep(j, a, n + 1)(dp3[i + j][1] += dp3[i][0]) %= MOD;\n\t}\n\n\tdp[0][0] = 1;\n\tdp[0][1] = 1;\n\tREP(i, n) {\n\t\trep(j, 1, a) (dp[i + j][1] += dp[i][0]) %= MOD;\n\t\trep(j, 1, b) {\n\t\t\tif (i == 0) {\n\t\t\t\t(dp[i + j][0] += dp[i][1] * dp3[j][0] % MOD) %= MOD;\n\t\t\t\tif (i + j == n)(dp[i + j][1] += dp[i][1] * dp3[j][1] % MOD) %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(dp[i + j][0] += dp[i][1] * dp2[j][0] % MOD) %= MOD;\n\t\t\t\tif (i + j == n)(dp[i + j][1] += dp[i][1] * dp2[j][1] % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << (ans + 2*MOD - dp[n][0]-dp[n][1])%MOD  << \"\\n\";\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=5005,mod=1e9+7;\nint f[N][N][2],g[N][N],h[N],n,A,B;\n\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint main(){\n\tread(n),read(A),read(B);\n\tif(A<B) swap(A,B);\n\n\tadd(f[1][1][0],1);\n\trep(i,1,n){\n\t\tif(i<B) add(f[i][0][1],1);\n\t\telse add(f[i][i][1],1);\n\t}\n\n\trep(i,1,n){\n\t\tadd(h[i],h[i-1]);\n\t\tadd(f[i][0][1],h[i]);\n\n\t\tadd(f[i+1][1][0],f[i][0][1]);\n\t\t\n\t\trep(j,1,A-1){\n\t\t\tadd(g[i][j],g[i-1][j-1]);\n\t\t\tadd(f[i][j][1],g[i][j]);\n\n\t\t\tadd(h[i+1],f[i][j][0]);\n\t\t\tadd(h[min(n+1,i+B)],mod-f[i][j][0]);\n\t\t\tadd(f[i+1][j+1][0],f[i][j][0]);\n\t\t\tif(i+B<=n){\n\t\t\t\tadd(g[i+B][j+B],f[i][j][0]);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tadd(f[i+1][j+1][0],f[i][j][1]);\n\t\t}\n\t}\n\n\tint ans=0,tot=1;\n\trep(i,1,n){\n\t\ttot=2ll*tot%mod;\n\t}\n\trep(j,0,A-1){\n\t\tadd(ans,f[n][j][0]);\n\t\tadd(ans,f[n][j][1]);\n\t}\n\tans=((tot+mod-ans)%mod+mod)%mod;\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\ntemplate<typename T>\nstruct Polynomial : vector<T> {\n  using vector<T>::vector;\n  using Pol = Polynomial;\n  Pol operator-() const {\n    Pol res((*this).size());\n    rep(i, (*this).size()) res[i] = -(*this)[i];\n    return res;\n  }\n  Pol &operator+=(const Pol q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] += q[i];\n    return *this;\n  }\n  Pol &operator-=(const Pol q) {\n    rep(i, (*this).size()) if (i < q.size()) (*this)[i] -= q[i];\n    return *this;\n  }\n  Pol &operator*=(const Pol q) {\n    vector<pair<int, T>> nz;\n    rep2(i, 1, q.size()) if (q[i].x != 0) nz.emplace_back(i, q[i]);\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: nz) if (j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  Pol &operator/=(const Pol q) {\n    vector<pair<int, T>> nz;\n    rep2(i, 1, q.size()) if (q[i].x != 0) nz.emplace_back(i, q[i]);\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: nz) if (j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n  Pol operator+(const Pol q) const { return Pol(*this) += q; }\n  Pol operator-(const Pol q) const { return Pol(*this) -= q; }\n  Pol operator*(const Pol q) const { return Pol(*this) *= q; }\n  Pol operator/(const Pol q) const { return Pol(*this) /= q; }\n  Pol &mul(map<int, T> q) {\n    drep(i, (*this).size()) {\n      (*this)[i] *= q[0];\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] += b * (*this)[i-j];\n    }\n    return *this;\n  }\n  Pol &div(map<int, T> q={{0, 1}, {1, -1}}) {\n    rep(i, (*this).size()) {\n      for (auto &[j, b]: q) if (j != 0 && j <= i) (*this)[i] -= b * (*this)[i-j];\n      (*this)[i] /= q[0];\n    }\n    return *this;\n  }\n};\n\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  if (a > b) swap(a, b);\n\n  Polynomial<mint> p(n+1), q(n+1), f(n+1);\n  p[a] = 1;\n  p.div();\n  q[1] = 1;\n  q.div();\n  f[1] = 1;\n  f[a] -= 1;\n  f.div();\n\n  auto r = -p * q;\n  r[0] += 1;\n\n  auto g2 = q / r;\n  auto g1 = q;\n  g1[0] += 1;\n  g1 /= r;\n  auto g0 = p + q;\n  g0[0] += 2;\n  g0 /= r;\n\n  rep2(i, b, n+1) g0[i] = 0;\n  rep2(i, b, n+1) g1[i] = 0;\n  rep2(i, b, n+1) g2[i] = 0;\n\n  auto h = f;\n  h *= g1 * g1;\n  auto h0 = -f * g2;\n  h0[0] += 1;\n  h /= h0;\n  h += g0;\n\n  mint ans = mint(2).pow(n) - h[n];\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=5005;\nconst int MOD=1000000007;\nint n,a,b;\nlong long f[N][2];\nlong long g[N];\nlong long dp[N][2];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif(a>b) swap(a,b);\n\tif(b<=2)\n\t{\n\t\tprintf(\"%lld\",ksm(2,n));\n\t\treturn 0;\n\t}\n\tf[0][0]=f[0][1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t\tf[i][1]=(f[i][1]+f[j][0])%MOD;\n\t\tfor(int j=0;j+a<=i;j++)\n\t\t\tf[i][0]=(f[i][0]+f[j][1])%MOD;\n\t}\n\tg[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tg[i]=(f[i][0]+f[i][1])%MOD;\n\tlong long ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(i<a) dp[i][0]=(dp[i][0]+1)%MOD;\n\t\tfor(int j=i-a+1;j<i;j++)\n\t\t\tif(j>0) dp[i][0]=(dp[i][0]+dp[j][1])%MOD;\n\t\tif(i<b) dp[i][1]=(dp[i][1]+g[i-1])%MOD;\n\t\tfor(int j=i-b+1;j<i;j++)\n\t\t\tif(j>0) dp[i][1]=(dp[i][1]+dp[j][0]*(i-j==1?1:g[i-j-2])%MOD)%MOD;\n\t\tif(i+b-1>=n) ans=(ans+dp[i][0]*g[n-i-1]%MOD)%MOD;\n\t\tif(i+a-1>=n) ans=(ans+dp[i][1])%MOD;\n\t}\n\tprintf(\"%lld\",(ksm(2,n)-ans+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nint main(void){\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t,pt;\n  long long dp[2][5005]={0};\n  long long ce[5005]={0},cl[5005]={0},ncl[5005]={0};\n  \n  scanf(\"%lld%lld%lld\",&n,&a,&b);\n  r=power(2,n);\n  \n  if(a<b){llswap(&a,&b);}\n  ce[0]=1;\n  cl[0]=1;\n  for(i=1;i<=a;i++){\n    for(j=i-1;j>=0;j--){\n      ncl[j+1]+=cl[j];\n      ncl[j+1]%=mod;\n      if((j+1)>=b){\n        ce[i]+=cl[j];\n        ce[i]%=mod;\n      }\n      if(j>=b){\n        ncl[0]+=cl[j];\n        ncl[0]%=mod;\n      }\n    }\n    ncl[0]+=cl[0];ncl[0]%=mod;\n    ce[i]+=ncl[0];ce[i]%=mod;\n    for(j=0;j<=i;j++){\n      cl[j]=ncl[j];\n      ncl[j]=0;\n      //printf(\"[%lld]\",cl[j]);\n    }//printf(\"\\n\");\n    //printf(\"<%lld>\\n\",ce[i]);\n  }\n\n  dp[0][0]=1;\n  dp[1][0]=1;\n  for(i=0;i<=n;i++){\n    //printf(\"%lld : <%lld %lld>\\n\",i,dp[0][i],dp[1][i]);\n    for(j=1;j<a;j++){\n      if((i+j)>n){break;}\n      pt=j-2;\n      if(i==0){pt++;}\n      if(i+j==n){pt++;}\n      if(pt<0){dp[0][i+j]+=dp[1][i];}\n      else{dp[0][i+j]+=ce[pt]*dp[1][i];}\n      dp[0][i+j]%=mod;\n    }\n    for(j=1;j<b;j++){\n      if((i+j)>n){break;}\n      dp[1][i+j]+=dp[0][i];\n      dp[1][i+j]%=mod;\n    }\n  }\n  r+=mod;r-=dp[0][n];\n  r+=mod;r-=dp[1][n];\n  printf(\"%lld\\n\",r%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define Mod 1000000007\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\tif (A > B) {\n\t\tB += A;\n\t\tA = B - A;\n\t\tB -= A;\n\t}\n\n\tint i, j, k;\n\tlong long ans = 0, **dp[2];\n\tdp[0] = (long long**)malloc(sizeof(long long*) * B);\n\tdp[1] = (long long**)malloc(sizeof(long long*) * B);\n\tfor (i = 0; i <= B - 1; i++) {\n\t\tdp[0][i] = (long long*)malloc(sizeof(long long) * (A + 1));\n\t\tdp[1][i] = (long long*)malloc(sizeof(long long) * (A + 1));\n\t}\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[0][A%2][A-1] = 2; j >= 1; j--) dp[0][A%2][j] = dp[0][A%2][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[0][1-i%2][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[0][i%2][1] = dp[0][1-i%2][A-1]; j >= 1; j--) {\n\t\t\t\tdp[0][i%2][j+1] = dp[0][1-i%2][j];\n\t\t\t\tdp[0][i%2][1] += dp[0][1-i%2][j];\n\t\t\t}\n\t\t\tdp[0][i%2][1] %= Mod;\n\t\t}\n\t} else {\n\t\tdp[1][1][0] = 1;\n\t\tdp[1][0][1] = 1;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tdp[i%2][0][1] = 0;\n\t\t\tans = (ans * 2 + dp[1-i%2][B-1][0] + dp[1-i%2][B-A][A-1] + dp[1-i%2][B-A-1][A] * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 2; j >= 1; j--) dp[i%2][j+1][0] = dp[1-i%2][j][0];\n\t\t\tfor (j = B - 1, dp[i%2][B-A][1] = 0; j >= B - A; j--) dp[i%2][B-A][1] += dp[1-i%2][j][0];\n\t\t\tdp[i%2][B-A][1] %= Mod;\n\t\t\tfor (; j >= 1; j--) dp[i%2][j][1] = dp[1-i%2][j][0];\n\t\t\t\n\t\t\tfor (k = A - 1, dp[i%2][1][0] = 0; k >= 1; k--) {\n\t\t\t\tfor (j = 0; j <= B - A; j++) {\n\t\t\t\t\tdp[i%2][j][k+1] = dp[1-i%2][j][k];\n\t\t\t\t\tdp[i%2][1][0] += dp[1-i%2][j][k];\n\t\t\t\t}\n\t\t\t\tdp[i%2][1][0] %= Mod;\n\t\t\t}\n\t\t\tfor (j = 0; j <= B - A - 2; j++) {\n\t\t\t\tdp[i%2][j+1][A] = (dp[i%2][j+1][A] + dp[1-i%2][j][A]) % Mod;\n\t\t\t\tdp[i%2][j+A+1][0] = (dp[i%2][j+A+1][0] + dp[1-i%2][j][A]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC optimize(\"O3\")\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007LL\n#define VERYBIG 2000000000000000007LL\n#define ULTRABIG 300000000000000000000LL\n\n#define MOD 1000000007LL\n#define FOD  998244353LL\n#define HOD 1000000009LL\n#define IOD  100000007LL\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n// #include <functional>\n// #include <array>\n#include <iostream>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n// using std::get;\n// using std::function;\n// using std::array;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nvoid uw (ull *l, ull *r) {\n\tif (*l == *r) return;\n\tull t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 10], invf[N_MAX * 10];\nvoid f_init (sll n, sll m) {\n\tfrac[0] = 1;\n\tfor (sll i = 1; i <= n; i++) {\n\t\tfrac[i] = frac[i - 1] * i % m;\n\t}\n\n\tinvf[n] = divide(1, frac[n], m);\n\tfor (sll i = n - 1; i >= 0; i--) {\n\t\tinvf[i] = invf[i + 1] * (i + 1) % m;\n\t}\n}\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX * 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX * 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX * 5];\nsll d[N_MAX * 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 4];\nhwllc tup[N_MAX * 4];\n// sll table[3005][3005];\nsll table[2005][2005];\null gin[N_MAX];\n// here we go\n\null parent[501910], size[501910], edges[501910];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull v, ull u) {\n\tv = find(v);\n\tu = find(u);\n\n\n\n\tif (v == u) return false;\n\n\tif (size[v] < size[u]) {\n\t\tull tmp = v;\n\t\tv = u;\n\t\tu = tmp;\n\t}\n\tsize[v] += size[u];\n\tparent[u] = v;\n\treturn true;\n}\n\nsll dp[5050][5050][5];\n\nsll solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tf_init(n + 5, MOD);\n\n\t// dp[0][0] = 1;\n\t// for (i = 0; i <= m; i++) {\n\t// \tfor (j = i * 2; j <= m; j++) {\n\t// \t\tdp[i][j] %= MOD;\n\t// \t\tprintf(\"%lld %lld: %lld\\n\", i, j, dp[i][j]);\n\n\t// \t\tdp[i    ][j + 1] += dp[i][j] * (j - i);\n\t// \t\tdp[i + 1][j + 2] += dp[i][j] * (m - j - 1);\n\t// \t}\n\t// }\n\n\t// for (i = 1; i <= m; i++) {\n\t// \tfor (j = i * 2; j <= m; j++) {\n\t// \t\tresult += dp[i][j] * (frac[n - m + j - 1] * invf[j - 1] % MOD) % MOD;\n\t// \t}\n\t// \tresult %= MOD;\n\t// }\n\n\tif (va < vb) {\n\t\tsll t = va;\n\t\tva = vb;\n\t\tvb = t;\n\t}\n\n\t// 0: white A\n\t// 1: black A\n\t// 2: no    B\n\tdp[0][0][0] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < va; j++) {\n\t\t\tdp[i][j][0] %= MOD;\n\t\t\tdp[i][j][1] %= MOD;\n\t\t\tdp[i][j][2] %= MOD;\n\n\t\t\tdp[i + 1][j + 1][0] += dp[i][j][0];\n\t\t\tif (vb > 1) dp[i + 1][1][2] += dp[i][j][0];\n\t\t\tif (i + vb <= n && j + vb < va) dp[i + vb][j + vb][1] += dp[i][j][0];\n\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][1];\n\t\t\tdp[i + 1][j + 1][0] += dp[i][j][1];\n\n\t\t\tif (j + 1 < vb) dp[i + 1][j + 1][2] += dp[i][j][2];\n\t\t\tdp[i + 1][1][0] += dp[i][j][2];\n\n\t\t\t// printf(\"%lld %lld %lld: %lld\\n\", i, j, 0, dp[i][j][0]);\n\t\t\t// printf(\"%lld %lld %lld: %lld\\n\", i, j, 1, dp[i][j][1]);\n\t\t\t// printf(\"%lld %lld %lld: %lld\\n\", i, j, 2, dp[i][j][2]);\n\t\t}\n\t}\n\n\tfor (j = 0; j < va; j++) {\n\t\tresult += dp[n][j][0];\n\t\tresult += dp[n][j][1];\n\t\tif (j < vb) result += dp[n][j][2];\n\t}\n\tresult %= MOD;\n\n\tresult = (MOD + bitpow(2, n, MOD) - result) % MOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\th = 5;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%lld\", &w);\n\t// scanf(\"%lld%lld\", &h, &w);\n\tscanf(\"%lld\", &n, &m);\n\t// scanf(\"%lld\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &q);\n\tscanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%lld\", &k);\n\t// scanf(\"%lld\", &m);\n\t// scanf(\"%lld\", &n);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%s\", s[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// }\n\t// scanf(\" %c\", &ch);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%lld%lld\", &va, &vb);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// scanf(\"%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \tc[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", t[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &e[i], &c[i], &d[i]);\n\t// \tc[i]--;\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 1000000007\n\nlong long div_mod(long long x, long long y, long long z)\n{\n\tif (x % y == 0) return x / y;\n\telse return (div_mod((1 + x / y) * y - x, (z % y), y) * z + x) / y;\n}\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\n\tint i, j, k;\n\tlong long ans = 0, dp[2][5001][5001] = {};\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[0][A][A-1] = 2; j >= 1; j--) dp[0][A][j] = dp[0][A][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[0][i-1][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[0][i][1] = dp[0][i-1][A-1]; j >= 1; j--) {\n\t\t\t\tdp[0][i][j+1] = dp[0][i-1][j];\n\t\t\t\tdp[0][i][1] += dp[0][i-1][j];\n\t\t\t}\n\t\t\tdp[0][i][1] %= Mod;\n\t\t}\n\t} else {\n\t\tif (A > B) {\n\t\t\tB += A;\n\t\t\tA = B - A;\n\t\t\tB -= A;\n\t\t}\n\t\tdp[1][1][0] = 1;\n\t\tdp[1][0][1] = 1;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tdp[i%2][0][1] = 0;\n\t\t\tans = (ans * 2 + dp[1-i%2][B-1][0] + dp[1-i%2][B-A][A-1] + dp[1-i%2][B-A-1][A] * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 2; j >= 1; j--) dp[i%2][j+1][0] = dp[1-i%2][j][0];\n\t\t\tfor (j = B - 1, dp[i%2][B-A][1] = 0; j >= B - A; j--) dp[i%2][B-A][1] += dp[1-i%2][j][0];\n\t\t\tdp[i%2][B-A][1] %= Mod;\n\t\t\tfor (; j >= 1; j--) dp[i%2][j][1] = dp[1-i%2][j][0];\n\t\t\t\n\t\t\tfor (k = A - 1, dp[i%2][1][0] = 0; k >= 1; k--) {\n\t\t\t\tfor (j = 0; j <= B - A; j++) {\n\t\t\t\t\tdp[i%2][j][k+1] = dp[1-i%2][j][k];\n\t\t\t\t\tdp[i%2][1][0] += dp[1-i%2][j][k];\n\t\t\t\t}\n\t\t\t\tdp[i%2][1][0] %= Mod;\n\t\t\t}\n\t\t\tfor (j = 0; j <= B - A - 2; j++) {\n\t\t\t\tdp[i%2][j+1][A] = (dp[i%2][j+1][A] + dp[1-i%2][j][A]) % Mod;\n\t\t\t\tdp[i%2][j+A+1][0] = (dp[i%2][j+A+1][0] + dp[1-i%2][j][A]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define Mod 1000000007\n\ntypedef struct List {\n\tstruct List *prev, *next;\n\tlong long v;\n} list;\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\tif (A > B) {\n\t\tB += A;\n\t\tA = B - A;\n\t\tB -= A;\n\t}\n\t\n\tint i, j, k;\n\tlist **head = (list**)malloc(sizeof(list*) * B), **tail = (list**)malloc(sizeof(list*) * B), *d = (list*)malloc(sizeof(list) * B * (A + 1)), *p;\n\tlong long ans = 0, dp[2][5001], tmp[2], pow;\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[A%2][A-1] = 2; j >= 1; j--) dp[A%2][j] = dp[A%2][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[1-i%2][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[i%2][1] = dp[1-i%2][A-1]; j >= 1; j--) {\n\t\t\t\tdp[i%2][j+1] = dp[1-i%2][j];\n\t\t\t\tdp[i%2][1] += dp[1-i%2][j];\n\t\t\t}\n\t\t\tdp[i%2][1] %= Mod;\n\t\t}\n\t} else {\n\t\tfor (j = 0; j <= B - 1; j++) {\n\t\t\thead[j] = &(d[j*(A+1)]);\n\t\t\ttail[j] = &(d[j*(A+1)+A]);\n\t\t\td[j*(A+1)].v = 0;\n\t\t\td[j*(A+1)].prev = &(d[j*(A+1)+A]);\n\t\t\td[j*(A+1)+A].next = &(d[j*(A+1)]);\n\t\t\tfor (k = 1; k <= A; k++) {\n\t\t\t\td[j*(A+1)+k].v = 0;\n\t\t\t\td[j*(A+1)+k].prev = &(d[j*(A+1)+k-1]);\n\t\t\t\td[j*(A+1)+k-1].next = &(d[j*(A+1)+k]);\n\t\t\t}\n\t\t}\n\t\td[1].v = 1;\n\t\td[A+1].v = 1;\n\t\tfor (i = 2, pow = 2; i <= N; i++, pow = pow * 2 % Mod) {\n\t\t\tfor (j = 0, tmp[0] = 0; j <= B - 1; j++) tmp[0] += head[j]->v + tail[j]->v;\n\t\t\ttmp[0] = (pow - ans - tmp[0] + tail[B-A]->v) % Mod;\n\t\t\tif (tmp[0] < 0) tmp[0] += Mod;\n\t\t\tans = (ans * 2 + head[B-1]->v + tail[B-A]->prev->v + tail[B-A-1]->v * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 1, tmp[1] = head[B-A]->v; j > B - A; j--) {\n\t\t\t\ttmp[1] += head[j]->v;\n\t\t\t\thead[j]->v = head[j-1]->v;\n\t\t\t\tif (j >= A + 1) head[j]->v = (head[j]->v + tail[j-A-1]->v) % Mod;\n\t\t\t}\n\t\t\thead[B-A]->v = tmp[1] % Mod;\n\t\t\ttail[B-A]->v = head[B-A-1]->v;\n\t\t\tif (B - A >= A + 1) tail[B-A]->v += tail[B-A*2-1]->v;\n\t\t\ttail[B-A]->v %= Mod;\n\t\t\thead[B-A] = tail[B-A];\n\t\t\ttail[B-A] = tail[B-A]->prev;\n\t\t\tfor (j = B - A - 1; j >= A + 1; j--) {\n\t\t\t\ttail[j]->prev->v = (tail[j]->prev->v + tail[j-1]->v) % Mod;\n\t\t\t\ttail[j]->v = (head[j-1]->v + tail[j-A-1]->v) % Mod;\n\t\t\t\thead[j] = tail[j];\n\t\t\t\ttail[j] = tail[j]->prev;\n\t\t\t}\n\t\t\tfor (; j >= 1; j--) {\n\t\t\t\ttail[j]->prev->v = (tail[j]->prev->v + tail[j-1]->v) % Mod;\n\t\t\t\ttail[j]->v = head[j-1]->v;\n\t\t\t\thead[j] = tail[j];\n\t\t\t\ttail[j] = tail[j]->prev;\n\t\t\t}\n\t\t\thead[1]->v = tmp[0];\n\t\t\thead[0] = tail[0];\n\t\t\ttail[0] = tail[0]->prev;\n\t\t\thead[0]->v = 0;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 1000000007\n\nint main()\n{\n\tint N, A, B;\n\tscanf(\"%d %d %d\", &N, &A, &B);\n\n\tint i, j, k;\n\tlong long ans = 0, dp[2][5001][5001] = {};\n\tif (A == 1 || B == 1) {\n\t\tfor (i = 1, ans = 1; i <= N; i++) ans = ans * 2 % Mod;\n\t} else if (A == B) {\n\t\tfor (j = A - 2, dp[0][A][A-1] = 2; j >= 1; j--) dp[0][A][j] = dp[0][A][j+1] * 2 % Mod;\n\t\tfor (i = A + 1, ans = 2; i <= N; i++) {\n\t\t\tans = (ans * 2 + dp[0][i-1][A-1]) % Mod;\n\t\t\tfor (j = A - 2, dp[0][i][1] = dp[0][i-1][A-1]; j >= 1; j--) {\n\t\t\t\tdp[0][i][j+1] = dp[0][i-1][j];\n\t\t\t\tdp[0][i][1] += dp[0][i-1][j];\n\t\t\t}\n\t\t\tdp[0][i][1] %= Mod;\n\t\t}\n\t} else {\n\t\tif (A > B) {\n\t\t\tB += A;\n\t\t\tA = B - A;\n\t\t\tB -= A;\n\t\t}\n\t\tdp[1][1][0] = 1;\n\t\tdp[1][0][1] = 1;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tdp[i%2][0][1] = 0;\n\t\t\tans = (ans * 2 + dp[1-i%2][B-1][0] + dp[1-i%2][B-A][A-1] + dp[1-i%2][B-A-1][A] * 2) % Mod;\n\t\t\t\n\t\t\tfor (j = B - 2; j >= 1; j--) dp[i%2][j+1][0] = dp[1-i%2][j][0];\n\t\t\tfor (j = B - 1, dp[i%2][B-A][1] = 0; j >= B - A; j--) dp[i%2][B-A][1] += dp[1-i%2][j][0];\n\t\t\tdp[i%2][B-A][1] %= Mod;\n\t\t\tfor (; j >= 1; j--) dp[i%2][j][1] = dp[1-i%2][j][0];\n\t\t\t\n\t\t\tfor (k = A - 1, dp[i%2][1][0] = 0; k >= 1; k--) {\n\t\t\t\tfor (j = 0; j <= B - A; j++) {\n\t\t\t\t\tdp[i%2][j][k+1] = dp[1-i%2][j][k];\n\t\t\t\t\tdp[i%2][1][0] += dp[1-i%2][j][k];\n\t\t\t\t}\n\t\t\t\tdp[i%2][1][0] %= Mod;\n\t\t\t}\n\t\t\tfor (j = 0; j <= B - A - 2; j++) {\n\t\t\t\tdp[i%2][j+1][A] = (dp[i%2][j+1][A] + dp[1-i%2][j][A]) % Mod;\n\t\t\t\tdp[i%2][j+A+1][0] = (dp[i%2][j+A+1][0] + dp[1-i%2][j][A]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\", \"EqualsOrHashCode\")\n\nimport java.io.PrintWriter\nimport kotlin.math.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n/** @author Spheniscine */\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val numCases = 1//readInt()\n    case@ for(case in 1..numCases) {\n        //print(\"Case #$case: \")\n\n        val n = readInt()\n        var a = readInt()\n        var b = readInt()\n        if(a > b) a = b.also { b = a }\n\n        // F[x+1] = number of ways to convert x free 1s with operation A\n        val F = ModIntArray(b+1)\n        F[0] = ModInt(1)\n        for(i in 0 until b) {\n            F[i+1] += F[i]\n            for(j in i+a+1 .. b) {\n                F[j] += F[i]\n            }\n        }\n\n        val D0 = ModIntArray(n+1)\n        D0[0] = ModInt(1)\n        val D1 = ModIntArray(n+1)\n        D1[0] = ModInt(1)\n\n        for(i in 0 until n) {\n            for(j in i+1 until min(i+a, n+1)) {\n                D1[j] += D0[i]\n            }\n            for(j in i+1 until min(i+b, n+1)) {\n                var x = j - i - 2\n                if(i == 0) x++\n                if(j == n) x++\n\n                D0[j] += D1[i] * F[x+1]\n            }\n        }\n\n        val ans = ModInt(2).pow(n) - D0[n] - D1[n]\n\n        println(ans.int)\n    }\n}\n\nconst val BILLION7 = 1e9.toInt() + 7\nconst val MOD = BILLION7\nconst val TOTIENT = MOD - 1 // assumes MOD is prime\n\ninfix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt()\n\nfun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod\n\nfun Int.powMod(exponent: Int, mod: Int): Int {\n    if(exponent < 0) error(\"Inverse not implemented\")\n    var res = 1L\n    var e = exponent\n    var b = modulo(mod).toLong()\n\n    while(e > 0) {\n        if(e and 1 == 1) {\n            res = res * b % mod\n        }\n        e = e shr 1\n        b = b * b % mod\n    }\n    return res.toInt()\n}\n\ninline fun Int.toModInt() = ModInt(this modulo MOD)\ninline fun Long.toModInt() = ModInt(this modulo MOD)\n\n/** note: Only use constructor for int within modulo range, otherwise use toModInt **/\ninline class ModInt(val int: Int) {\n    companion object {\n        /** can't seem to make these private or inlined without causing compiler issues */\n        @JvmField val _invMemo = HashMap<ModInt, ModInt>()\n        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }\n    }\n\n    // normalizes an integer that's within range [-MOD, MOD) without branching\n    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)\n\n    operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30\n    inline operator fun plus(other: Int) = plus(other.toModInt())\n    operator fun inc() = normalize(int + (1 - MOD))\n\n    operator fun minus(other: ModInt) = normalize(int - other.int)\n    inline operator fun minus(other: Int) = minus(other.toModInt())\n    operator fun dec() = normalize(int - 1)\n    operator fun unaryMinus() = normalize(-int)\n\n    operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())\n    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))\n\n    fun pow(exponent: Int): ModInt {\n        val e = if(exponent < 0) {\n            require(int != 0) { \"Can't invert/divide by 0\" }\n            exponent modulo TOTIENT\n        } else exponent\n        return ModInt(int.powMod(e, MOD))\n    }\n\n    fun pow(exponent: Long) = if(int == 0) when {\n        exponent > 0 -> this\n        exponent == 0L -> ModInt(1)\n        else -> error(\"Can't invert/divide by 0\")\n    } else pow(exponent modulo TOTIENT)\n\n    inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */\n\n    fun inv_unmemoized(): ModInt {\n        require(int != 0) { \"Can't invert/divide by 0\" }\n        return pow(TOTIENT - 1)\n    }\n    inline fun inv_memoized() = _invMemoized(this)\n\n    operator fun div(other: ModInt) = times(other.inverse())\n    inline operator fun div(other: Int) = div(other.toModInt())\n\n    override inline fun toString() = int.toString()\n}\n\ninline operator fun Int.plus(modInt: ModInt) = modInt + this\ninline operator fun Int.minus(modInt: ModInt) = toModInt() - modInt\ninline operator fun Int.times(modInt: ModInt) = modInt * this\ninline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this\n\ninline class ModIntArray(val intArray: IntArray): Collection<ModInt> {\n    inline operator fun get(i: Int) = ModInt(intArray[i])\n    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }\n\n    override inline val size: Int get() = intArray.size\n    inline val lastIndex get() = intArray.lastIndex\n    inline val indices get() = intArray.indices\n\n    override inline fun contains(element: ModInt): Boolean = element.int in intArray\n\n    override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)\n\n    override inline fun isEmpty(): Boolean = intArray.isEmpty()\n\n    override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {\n        var index = 0\n        override fun hasNext(): Boolean = index < size\n        override fun next(): ModInt = get(index++)\n    }\n\n    fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))\n    fun copyOf() = copyOf(size)\n}\nfun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =\n    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))\ninline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))\ninline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int })\n\nfun ModInt.powArray(n: Int): ModIntArray {\n    val res = ModIntArray(n+1)\n    res[0] = ModInt(1)\n    for(i in 1..n) res[i] = res[i-1] * this\n    return res\n}\n\ninline fun ModIntArray.first() = get(0)\ninline fun ModIntArray.last() = get(lastIndex)\ninline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)\ninline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }\ninline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }\nfun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)\nfun ModIntArray.product() = fold(ModInt(1), ModInt::times)\n\ninline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\nfun Iterable<ModInt>.sum() = sumByModInt { it }\nfun Sequence<ModInt>.sum() = sumByModInt { it }\nfun Iterable<ModInt>.product() = productByModInt { it }\nfun Sequence<ModInt>.product() = productByModInt { it }\nfun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } }\n\n\n\n/** IO */\n//@JvmField val INPUT = File(\"input.txt\").inputStream()\n//@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\nconst val _BUFFER_SIZE = 1 shl 16\n@JvmField val _buffer = ByteArray(_BUFFER_SIZE)\n@JvmField var _bufferPt = 0\n@JvmField var _bytesRead = 0\n\ntailrec fun readChar(): Char {\n    if(_bufferPt == _bytesRead) {\n        _bufferPt = 0\n        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)\n    }\n    return if(_bytesRead < 0) Char.MIN_VALUE\n    else {\n        val c = _buffer[_bufferPt++].toChar()\n        if (c == '\\r') readChar()\n        else c\n    }\n}\n\nfun readLine(): String? {\n    var c = readChar()\n    return if(c == Char.MIN_VALUE) null\n    else buildString {\n        while(true) {\n            when(c) {\n                '\\n', Char.MIN_VALUE -> return@buildString\n                else -> {\n                    append(c)\n                    c = readChar()\n                }\n            }\n        }\n    }\n}\nfun readLn() = readLine()!!\n\nfun read() = buildString {\n    var c = readChar()\n    while(c <= ' ') {\n        if(c == Char.MIN_VALUE) return@buildString\n        c = readChar()\n    }\n    do {\n        append(c)\n        c = readChar()\n    } while(c > ' ')\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n/** shuffles and sort overrides to avoid quicksort attacks */\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    // Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }\n\n/** additional commons */\ninline fun <T> Iterable<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\nfun IntArray.sumLong() = fold(0L, Long::plus)"
  },
  {
    "language": "Kotlin",
    "code": "@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\", \"EqualsOrHashCode\")\n\nimport java.io.PrintWriter\nimport kotlin.math.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n/** @author Spheniscine */\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val numCases = 1//readInt()\n    case@ for(case in 1..numCases) {\n        //print(\"Case #$case: \")\n\n        val n = readInt()\n        var a = readInt()\n        var b = readInt()\n        if(a > b) a = b.also { b = a }\n\n        val ans = if(a == 1) ModInt(2).pow(n) else run ans@ {\n\n            // F[x+1] = number of ways to convert x free 1s with operation A\n            val F = ModIntArray(b+1)\n            F[0] = ModInt(1)\n            for(i in 0 until b) {\n                F[i+1] += F[i]\n                for(j in i+a+1 .. b) {\n                    F[j] += F[i]\n                }\n            }\n\n            val D0 = ModIntArray(n+1)\n            D0[0] = ModInt(1)\n            val D1 = ModIntArray(n+1)\n            D1[0] = ModInt(1)\n\n            for(i in 0 until n) {\n                for(j in i+1 until min(i+a, n+1)) {\n                    D1[j] += D0[i]\n                }\n                for(j in i+1 until min(i+b, n+1)) {\n                    var x = j - i - 2\n                    if(i == 0) x++\n                    if(j == n) x++\n\n                    D0[j] += D1[i] * F[x+1]\n                }\n            }\n\n            ModInt(2).pow(n) - D0[n] - D1[n]\n        }\n\n        println(ans.int)\n    }\n}\n\nconst val BILLION7 = 1e9.toInt() + 7\nconst val MOD = BILLION7\nconst val TOTIENT = MOD - 1 // assumes MOD is prime\n\ninfix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt()\n\nfun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod\n\nfun Int.powMod(exponent: Int, mod: Int): Int {\n    if(exponent < 0) error(\"Inverse not implemented\")\n    var res = 1L\n    var e = exponent\n    var b = modulo(mod).toLong()\n\n    while(e > 0) {\n        if(e and 1 == 1) {\n            res = res * b % mod\n        }\n        e = e shr 1\n        b = b * b % mod\n    }\n    return res.toInt()\n}\n\ninline fun Int.toModInt() = ModInt(this modulo MOD)\ninline fun Long.toModInt() = ModInt(this modulo MOD)\n\n/** note: Only use constructor for int within modulo range, otherwise use toModInt **/\ninline class ModInt(val int: Int) {\n    companion object {\n        /** can't seem to make these private or inlined without causing compiler issues */\n        @JvmField val _invMemo = HashMap<ModInt, ModInt>()\n        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }\n    }\n\n    // normalizes an integer that's within range [-MOD, MOD) without branching\n    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)\n\n    operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30\n    inline operator fun plus(other: Int) = plus(other.toModInt())\n    operator fun inc() = normalize(int + (1 - MOD))\n\n    operator fun minus(other: ModInt) = normalize(int - other.int)\n    inline operator fun minus(other: Int) = minus(other.toModInt())\n    operator fun dec() = normalize(int - 1)\n    operator fun unaryMinus() = normalize(-int)\n\n    operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())\n    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))\n\n    fun pow(exponent: Int): ModInt {\n        val e = if(exponent < 0) {\n            require(int != 0) { \"Can't invert/divide by 0\" }\n            exponent modulo TOTIENT\n        } else exponent\n        return ModInt(int.powMod(e, MOD))\n    }\n\n    fun pow(exponent: Long) = if(int == 0) when {\n        exponent > 0 -> this\n        exponent == 0L -> ModInt(1)\n        else -> error(\"Can't invert/divide by 0\")\n    } else pow(exponent modulo TOTIENT)\n\n    inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */\n\n    fun inv_unmemoized(): ModInt {\n        require(int != 0) { \"Can't invert/divide by 0\" }\n        return pow(TOTIENT - 1)\n    }\n    inline fun inv_memoized() = _invMemoized(this)\n\n    operator fun div(other: ModInt) = times(other.inverse())\n    inline operator fun div(other: Int) = div(other.toModInt())\n\n    override inline fun toString() = int.toString()\n}\n\ninline operator fun Int.plus(modInt: ModInt) = modInt + this\ninline operator fun Int.minus(modInt: ModInt) = toModInt() - modInt\ninline operator fun Int.times(modInt: ModInt) = modInt * this\ninline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this\n\ninline class ModIntArray(val intArray: IntArray): Collection<ModInt> {\n    inline operator fun get(i: Int) = ModInt(intArray[i])\n    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }\n\n    override inline val size: Int get() = intArray.size\n    inline val lastIndex get() = intArray.lastIndex\n    inline val indices get() = intArray.indices\n\n    override inline fun contains(element: ModInt): Boolean = element.int in intArray\n\n    override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)\n\n    override inline fun isEmpty(): Boolean = intArray.isEmpty()\n\n    override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {\n        var index = 0\n        override fun hasNext(): Boolean = index < size\n        override fun next(): ModInt = get(index++)\n    }\n\n    fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))\n    fun copyOf() = copyOf(size)\n}\nfun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =\n    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))\ninline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))\ninline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int })\n\nfun ModInt.powArray(n: Int): ModIntArray {\n    val res = ModIntArray(n+1)\n    res[0] = ModInt(1)\n    for(i in 1..n) res[i] = res[i-1] * this\n    return res\n}\n\ninline fun ModIntArray.first() = get(0)\ninline fun ModIntArray.last() = get(lastIndex)\ninline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)\ninline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }\ninline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }\nfun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)\nfun ModIntArray.product() = fold(ModInt(1), ModInt::times)\n\ninline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\nfun Iterable<ModInt>.sum() = sumByModInt { it }\nfun Sequence<ModInt>.sum() = sumByModInt { it }\nfun Iterable<ModInt>.product() = productByModInt { it }\nfun Sequence<ModInt>.product() = productByModInt { it }\nfun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } }\n\n\n\n/** IO */\n//@JvmField val INPUT = File(\"input.txt\").inputStream()\n//@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\nconst val _BUFFER_SIZE = 1 shl 16\n@JvmField val _buffer = ByteArray(_BUFFER_SIZE)\n@JvmField var _bufferPt = 0\n@JvmField var _bytesRead = 0\n\ntailrec fun readChar(): Char {\n    if(_bufferPt == _bytesRead) {\n        _bufferPt = 0\n        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)\n    }\n    return if(_bytesRead < 0) Char.MIN_VALUE\n    else {\n        val c = _buffer[_bufferPt++].toChar()\n        if (c == '\\r') readChar()\n        else c\n    }\n}\n\nfun readLine(): String? {\n    var c = readChar()\n    return if(c == Char.MIN_VALUE) null\n    else buildString {\n        while(true) {\n            when(c) {\n                '\\n', Char.MIN_VALUE -> return@buildString\n                else -> {\n                    append(c)\n                    c = readChar()\n                }\n            }\n        }\n    }\n}\nfun readLn() = readLine()!!\n\nfun read() = buildString {\n    var c = readChar()\n    while(c <= ' ') {\n        if(c == Char.MIN_VALUE) return@buildString\n        c = readChar()\n    }\n    do {\n        append(c)\n        c = readChar()\n    } while(c > ' ')\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n/** shuffles and sort overrides to avoid quicksort attacks */\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    // Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }\n\n/** additional commons */\ninline fun <T> Iterable<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\nfun IntArray.sumLong() = fold(0L, Long::plus)"
  },
  {
    "language": "Kotlin",
    "code": "import kotlin.math.max\n\nconst val MOD = 1000000007L\n\nfun main() {\n    var (n, a, b) = readLine()!!.split(\" \").map { it.toInt() }\n    if (b < a) {\n        val c = b\n        b = a\n        a = c\n    }\n    val pow2 = LongArray(n + 1)\n    pow2[0] = 1L\n    for (j in 1..n) {\n        pow2[j] = (2L * pow2[j - 1]) % MOD\n    }\n    if (a == 1) {\n        println(pow2[n])\n    } else {\n        val dp = Array(n + 1) { LongArray(b + 1) }\n        val dpOverall = LongArray(n + 1)\n        dp[0][0] = 1L\n        dpOverall[0] = 1L\n        var answer = pow2[n - b]\n        //println(\"\\tanswer = $answer\")\n        for (j in 1..n) {\n            for (k in 1..b) {\n                dp[j][k] = when (k) {\n                    1 -> if (j == 1) 1L else {\n                        var res = 0L\n                        for (j2 in max(0, j - a) until j - 1) {\n                            res += dpOverall[j2]\n                        }\n                        res\n                    }\n                    2 -> dp[j - 1][1]\n                    else -> (2L * dp[j - 1][k - 1]) - (if (j >= 2 && k >= 2) dp[j - 2][k - 2] else 0L) + (if (j >= a + 1 && k >= a + 1) dp[j - 1 - a][k - 1 - a] else 0L)\n                }\n                dp[j][k] %= MOD\n                if (k != b) {\n                    dpOverall[j] += dp[j][k]\n                }\n                //println(\"dp[$j][$k] = ${dp[j][k]}\")\n                if (k == b) {\n                    answer += pow2[n - j] * dp[j][b]\n                    answer %= MOD\n                } else if (j + max(a, b - k) <= n) {\n                    answer += pow2[n - (j + max(a, b - k))] * dp[j][k]\n                    answer %= MOD\n                }\n                //println(\"\\tanswer = $answer\")\n            }\n            dpOverall[j] %= MOD\n        }\n        answer += MOD\n        answer %= MOD\n        println(answer)\n    }\n}"
  },
  {
    "language": "Kotlin",
    "code": "@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\", \"EqualsOrHashCode\")\n\nimport java.io.PrintWriter\nimport kotlin.math.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n/** @author Spheniscine */\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val numCases = 1//readInt()\n    case@ for(case in 1..numCases) {\n        //print(\"Case #$case: \")\n\n        val n = readInt()\n        var a = readInt()\n        var b = readInt()\n        if(a > b) a = b.also { b = a }\n\n        // F[x+1] = number of ways to convert x free 1s with operation A\n        val F = ModIntArray(b+1)\n        F[0]++\n        F[1]--\n        for(i in 0 .. b) {\n            if(i > 0) F[i] += F[i-1]\n            if(i+1 <= b) F[i+1] += F[i]\n            if(i+2 <= b) F[i+2] -= F[i]\n            if(i+a+1 <= b) F[i+a+1] += F[i]\n        }\n\n        val D0 = ModIntArray(n+1)\n        D0[0] = ModInt(1)\n        val D1 = ModIntArray(n+1)\n        D1[0]++\n        D1[1]--\n\n        for(i in 0 .. n) {\n            if(i > 0) D1[i] += D1[i-1]\n            if(i+1 <= n) D1[i+1] += D0[i]\n            if(i+a <= n) D1[i+a] -= D0[i]\n\n            for(j in i+1 until min(i+b, n+1)) {\n                var x = j - i - 2\n                if(i == 0) x++\n                if(j == n) x++\n\n                D0[j] += D1[i] * F[x+1]\n            }\n        }\n\n        val ans = ModInt(2).pow(n) - D0[n] - D1[n]\n\n        println(ans.int)\n    }\n}\n\nconst val BILLION7 = 1e9.toInt() + 7\nconst val MOD = BILLION7\nconst val TOTIENT = MOD - 1 // assumes MOD is prime\n\ninfix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt()\n\nfun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod\n\nfun Int.powMod(exponent: Int, mod: Int): Int {\n    if(exponent < 0) error(\"Inverse not implemented\")\n    var res = 1L\n    var e = exponent\n    var b = modulo(mod).toLong()\n\n    while(e > 0) {\n        if(e and 1 == 1) {\n            res = res * b % mod\n        }\n        e = e shr 1\n        b = b * b % mod\n    }\n    return res.toInt()\n}\n\ninline fun Int.toModInt() = ModInt(this modulo MOD)\ninline fun Long.toModInt() = ModInt(this modulo MOD)\n\n/** note: Only use constructor for int within modulo range, otherwise use toModInt **/\ninline class ModInt(val int: Int) {\n    companion object {\n        /** can't seem to make these private or inlined without causing compiler issues */\n        @JvmField val _invMemo = HashMap<ModInt, ModInt>()\n        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }\n    }\n\n    // normalizes an integer that's within range [-MOD, MOD) without branching\n    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)\n\n    operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30\n    inline operator fun plus(other: Int) = plus(other.toModInt())\n    operator fun inc() = normalize(int + (1 - MOD))\n\n    operator fun minus(other: ModInt) = normalize(int - other.int)\n    inline operator fun minus(other: Int) = minus(other.toModInt())\n    operator fun dec() = normalize(int - 1)\n    operator fun unaryMinus() = normalize(-int)\n\n    operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())\n    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))\n\n    fun pow(exponent: Int): ModInt {\n        val e = if(exponent < 0) {\n            require(int != 0) { \"Can't invert/divide by 0\" }\n            exponent modulo TOTIENT\n        } else exponent\n        return ModInt(int.powMod(e, MOD))\n    }\n\n    fun pow(exponent: Long) = if(int == 0) when {\n        exponent > 0 -> this\n        exponent == 0L -> ModInt(1)\n        else -> error(\"Can't invert/divide by 0\")\n    } else pow(exponent modulo TOTIENT)\n\n    inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */\n\n    fun inv_unmemoized(): ModInt {\n        require(int != 0) { \"Can't invert/divide by 0\" }\n        return pow(TOTIENT - 1)\n    }\n    inline fun inv_memoized() = _invMemoized(this)\n\n    operator fun div(other: ModInt) = times(other.inverse())\n    inline operator fun div(other: Int) = div(other.toModInt())\n\n    override inline fun toString() = int.toString()\n}\n\ninline operator fun Int.plus(modInt: ModInt) = modInt + this\ninline operator fun Int.minus(modInt: ModInt) = toModInt() - modInt\ninline operator fun Int.times(modInt: ModInt) = modInt * this\ninline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this\n\ninline class ModIntArray(val intArray: IntArray): Collection<ModInt> {\n    inline operator fun get(i: Int) = ModInt(intArray[i])\n    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }\n\n    override inline val size: Int get() = intArray.size\n    inline val lastIndex get() = intArray.lastIndex\n    inline val indices get() = intArray.indices\n\n    override inline fun contains(element: ModInt): Boolean = element.int in intArray\n\n    override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)\n\n    override inline fun isEmpty(): Boolean = intArray.isEmpty()\n\n    override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {\n        var index = 0\n        override fun hasNext(): Boolean = index < size\n        override fun next(): ModInt = get(index++)\n    }\n\n    fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))\n    fun copyOf() = copyOf(size)\n}\nfun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =\n    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))\ninline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))\ninline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int })\n\nfun ModInt.powArray(n: Int): ModIntArray {\n    val res = ModIntArray(n+1)\n    res[0] = ModInt(1)\n    for(i in 1..n) res[i] = res[i-1] * this\n    return res\n}\n\ninline fun ModIntArray.first() = get(0)\ninline fun ModIntArray.last() = get(lastIndex)\ninline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)\ninline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }\ninline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }\nfun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)\nfun ModIntArray.product() = fold(ModInt(1), ModInt::times)\n\ninline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\nfun Iterable<ModInt>.sum() = sumByModInt { it }\nfun Sequence<ModInt>.sum() = sumByModInt { it }\nfun Iterable<ModInt>.product() = productByModInt { it }\nfun Sequence<ModInt>.product() = productByModInt { it }\nfun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } }\n\n\n\n/** IO */\n//@JvmField val INPUT = File(\"input.txt\").inputStream()\n//@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\nconst val _BUFFER_SIZE = 1 shl 16\n@JvmField val _buffer = ByteArray(_BUFFER_SIZE)\n@JvmField var _bufferPt = 0\n@JvmField var _bytesRead = 0\n\ntailrec fun readChar(): Char {\n    if(_bufferPt == _bytesRead) {\n        _bufferPt = 0\n        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)\n    }\n    return if(_bytesRead < 0) Char.MIN_VALUE\n    else {\n        val c = _buffer[_bufferPt++].toChar()\n        if (c == '\\r') readChar()\n        else c\n    }\n}\n\nfun readLine(): String? {\n    var c = readChar()\n    return if(c == Char.MIN_VALUE) null\n    else buildString {\n        while(true) {\n            when(c) {\n                '\\n', Char.MIN_VALUE -> return@buildString\n                else -> {\n                    append(c)\n                    c = readChar()\n                }\n            }\n        }\n    }\n}\nfun readLn() = readLine()!!\n\nfun read() = buildString {\n    var c = readChar()\n    while(c <= ' ') {\n        if(c == Char.MIN_VALUE) return@buildString\n        c = readChar()\n    }\n    do {\n        append(c)\n        c = readChar()\n    } while(c > ' ')\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n/** shuffles and sort overrides to avoid quicksort attacks */\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    // Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }\n\n/** additional commons */\ninline fun <T> Iterable<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\nfun IntArray.sumLong() = fold(0L, Long::plus)"
  },
  {
    "language": "Kotlin",
    "code": "@file:Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\", \"OVERRIDE_BY_INLINE\", \"EqualsOrHashCode\")\n\nimport java.io.PrintWriter\nimport kotlin.math.*\nimport kotlin.random.Random\nimport kotlin.collections.sort as _sort\nimport kotlin.collections.sortDescending as _sortDescending\nimport kotlin.io.println as iprintln\n\n/** @author Spheniscine */\nfun main() { _writer.solve(); _writer.flush() }\nfun PrintWriter.solve() {\n    val numCases = 1//readInt()\n    case@ for(case in 1..numCases) {\n        //print(\"Case #$case: \")\n\n        val n = readInt()\n        var a = readInt()\n        var b = readInt()\n        if(a > b) a = b.also { b = a }\n\n        val ans = if(a == 1) ModInt(2).pow(n) else run ans@ {\n\n            // F[x+1] = number of ways to convert x free 1s with operation A\n            val F = ModIntArray(b+1)\n            F[0] = ModInt(1)\n            for(i in 0 until b) {\n                F[i+1] += F[i]\n                for(j in i+a+1 .. b) {\n                    F[j] += F[i]\n                }\n            }\n\n            val D0 = ModIntArray(n+1)\n            D0[0] = ModInt(1)\n            val D1 = ModIntArray(n+1)\n            D1[0] = ModInt(1)\n\n            for(i in 0 until n) {\n                for(j in i+1 until min(i+a, n+1)) {\n                    D1[j] += D0[i]\n                }\n                for(j in i+1 until min(i+b, n+1)) {\n                    var x = j - i - 2\n                    if(i == 0) x++\n                    if(j == n) x++\n\n                    D0[j] += D1[i] * F[x+1]\n                }\n            }\n\n            ModInt(2).pow(n) - D0.last() - D1.last()\n        }\n\n        println(ans.int)\n    }\n}\n\nconst val BILLION7 = 1e9.toInt() + 7\nconst val MOD = BILLION7\nconst val TOTIENT = MOD - 1 // assumes MOD is prime\n\ninfix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }\ninfix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt()\n\nfun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod\n\nfun Int.powMod(exponent: Int, mod: Int): Int {\n    if(exponent < 0) error(\"Inverse not implemented\")\n    var res = 1L\n    var e = exponent\n    var b = modulo(mod).toLong()\n\n    while(e > 0) {\n        if(e and 1 == 1) {\n            res = res * b % mod\n        }\n        e = e shr 1\n        b = b * b % mod\n    }\n    return res.toInt()\n}\n\ninline fun Int.toModInt() = ModInt(this modulo MOD)\ninline fun Long.toModInt() = ModInt(this modulo MOD)\n\n/** note: Only use constructor for int within modulo range, otherwise use toModInt **/\ninline class ModInt(val int: Int) {\n    companion object {\n        /** can't seem to make these private or inlined without causing compiler issues */\n        @JvmField val _invMemo = HashMap<ModInt, ModInt>()\n        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }\n    }\n\n    // normalizes an integer that's within range [-MOD, MOD) without branching\n    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)\n\n    operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30\n    inline operator fun plus(other: Int) = plus(other.toModInt())\n    operator fun inc() = normalize(int + (1 - MOD))\n\n    operator fun minus(other: ModInt) = normalize(int - other.int)\n    inline operator fun minus(other: Int) = minus(other.toModInt())\n    operator fun dec() = normalize(int - 1)\n    operator fun unaryMinus() = normalize(-int)\n\n    operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())\n    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))\n\n    fun pow(exponent: Int): ModInt {\n        val e = if(exponent < 0) {\n            require(int != 0) { \"Can't invert/divide by 0\" }\n            exponent modulo TOTIENT\n        } else exponent\n        return ModInt(int.powMod(e, MOD))\n    }\n\n    fun pow(exponent: Long) = if(int == 0) when {\n        exponent > 0 -> this\n        exponent == 0L -> ModInt(1)\n        else -> error(\"Can't invert/divide by 0\")\n    } else pow(exponent modulo TOTIENT)\n\n    inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */\n\n    fun inv_unmemoized(): ModInt {\n        require(int != 0) { \"Can't invert/divide by 0\" }\n        return pow(TOTIENT - 1)\n    }\n    inline fun inv_memoized() = _invMemoized(this)\n\n    operator fun div(other: ModInt) = times(other.inverse())\n    inline operator fun div(other: Int) = div(other.toModInt())\n\n    override inline fun toString() = int.toString()\n}\n\ninline operator fun Int.plus(modInt: ModInt) = modInt + this\ninline operator fun Int.minus(modInt: ModInt) = toModInt() - modInt\ninline operator fun Int.times(modInt: ModInt) = modInt * this\ninline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this\n\ninline class ModIntArray(val intArray: IntArray): Collection<ModInt> {\n    inline operator fun get(i: Int) = ModInt(intArray[i])\n    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }\n\n    override inline val size: Int get() = intArray.size\n    inline val lastIndex get() = intArray.lastIndex\n    inline val indices get() = intArray.indices\n\n    override inline fun contains(element: ModInt): Boolean = element.int in intArray\n\n    override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)\n\n    override inline fun isEmpty(): Boolean = intArray.isEmpty()\n\n    override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {\n        var index = 0\n        override fun hasNext(): Boolean = index < size\n        override fun next(): ModInt = get(index++)\n    }\n\n    fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))\n    fun copyOf() = copyOf(size)\n}\nfun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =\n    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))\ninline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))\ninline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int })\n\nfun ModInt.powArray(n: Int): ModIntArray {\n    val res = ModIntArray(n+1)\n    res[0] = ModInt(1)\n    for(i in 1..n) res[i] = res[i-1] * this\n    return res\n}\n\ninline fun ModIntArray.first() = get(0)\ninline fun ModIntArray.last() = get(lastIndex)\ninline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)\ninline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }\ninline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }\nfun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)\nfun ModIntArray.product() = fold(ModInt(1), ModInt::times)\n\ninline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\ninline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }\nfun Iterable<ModInt>.sum() = sumByModInt { it }\nfun Sequence<ModInt>.sum() = sumByModInt { it }\nfun Iterable<ModInt>.product() = productByModInt { it }\nfun Sequence<ModInt>.product() = productByModInt { it }\nfun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } }\n\n\n\n/** IO */\n//@JvmField val INPUT = File(\"input.txt\").inputStream()\n//@JvmField val OUTPUT = File(\"output.txt\").outputStream()\n@JvmField val INPUT = System.`in`\n@JvmField val OUTPUT = System.out\n\nconst val _BUFFER_SIZE = 1 shl 16\n@JvmField val _buffer = ByteArray(_BUFFER_SIZE)\n@JvmField var _bufferPt = 0\n@JvmField var _bytesRead = 0\n\ntailrec fun readChar(): Char {\n    if(_bufferPt == _bytesRead) {\n        _bufferPt = 0\n        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)\n    }\n    return if(_bytesRead < 0) Char.MIN_VALUE\n    else {\n        val c = _buffer[_bufferPt++].toChar()\n        if (c == '\\r') readChar()\n        else c\n    }\n}\n\nfun readLine(): String? {\n    var c = readChar()\n    return if(c == Char.MIN_VALUE) null\n    else buildString {\n        while(true) {\n            when(c) {\n                '\\n', Char.MIN_VALUE -> return@buildString\n                else -> {\n                    append(c)\n                    c = readChar()\n                }\n            }\n        }\n    }\n}\nfun readLn() = readLine()!!\n\nfun read() = buildString {\n    var c = readChar()\n    while(c <= ' ') {\n        if(c == Char.MIN_VALUE) return@buildString\n        c = readChar()\n    }\n    do {\n        append(c)\n        c = readChar()\n    } while(c > ' ')\n}\nfun readInt() = read().toInt()\nfun readDouble() = read().toDouble()\nfun readLong() = read().toLong()\nfun readStrings(n: Int) = List(n) { read() }\nfun readLines(n: Int) = List(n) { readLn() }\nfun readInts(n: Int) = List(n) { read().toInt() }\nfun readIntArray(n: Int) = IntArray(n) { read().toInt() }\nfun readDoubles(n: Int) = List(n) { read().toDouble() }\nfun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }\nfun readLongs(n: Int) = List(n) { read().toLong() }\nfun readLongArray(n: Int) = LongArray(n) { read().toLong() }\n\n@JvmField val _writer = PrintWriter(OUTPUT, false)\n\n/** shuffles and sort overrides to avoid quicksort attacks */\nprivate inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {\n    // Fisher-Yates shuffle algorithm\n    for (i in size - 1 downTo 1) {\n        val j = rnd.nextInt(i + 1)\n        val temp = get(i)\n        set(i, get(j))\n        set(j, temp)\n    }\n}\n\n@JvmField var _random: Random? = null\nval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it }\n\nfun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun IntArray.sort() { shuffle(); _sort() }\nfun IntArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun LongArray.sort() { shuffle(); _sort() }\nfun LongArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\nfun DoubleArray.sort() { shuffle(); _sort() }\nfun DoubleArray.sortDescending() { shuffle(); _sortDescending() }\n\nfun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)\ninline fun CharArray.sort() { _sort() }\ninline fun CharArray.sortDescending() { _sortDescending() }\n\ninline fun <T: Comparable<T>> Array<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()\ninline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()\ninline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending()\n\nfun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }\n\n/** additional commons */\ninline fun <T> Iterable<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Sequence<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\ninline fun <T> Array<T>.sumByLong(func: (T) -> Long) = fold(0L) { acc, t -> acc + func(t) }\nfun IntArray.sumLong() = fold(0L, Long::plus)"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            CRangeSet solver = new CRangeSet();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class CRangeSet {\n        Debug debug = new Debug(false);\n        Modular mod = new Modular(1e9 + 7);\n        Power pow = new Power(mod);\n        int a;\n        int b;\n        int[] f;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            a = in.readInt();\n            b = in.readInt();\n            if (a < b) {\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n\n            f = new int[a];\n            SequenceUtils.deepFill(f, -1);\n\n//        for (int i = 0; i < a; i++) {\n//            debug.debug(\"f(\" + i + \")\", f(i));\n//        }\n\n            ArrayIndex ai = new ArrayIndex(n + 1, a, 2);\n            int[] dp = new int[ai.totalSize()];\n            dp[ai.indexOf(0, 0, 0)] = 1;\n            dp[ai.indexOf(0, 0, 1)] = 1;\n            int[] sum = new int[2];\n            for (int i = 1; i <= n; i++) {\n                Arrays.fill(sum, 0);\n                for (int j = 0; j < a; j++) {\n                    int lend = j == i - 1 ? 1 : 0;\n                    sum[0] = mod.plus(sum[0], mod.mul(dp[ai.indexOf(i - 1, j, 0)], f(j - 2 + lend)));\n                }\n                for (int j = 0; j < b; j++) {\n                    sum[1] = mod.plus(sum[1], dp[ai.indexOf(i - 1, j, 1)]);\n                }\n                debug.debug(\"i\", i - 1);\n                debug.debug(\"sum\", sum);\n                for (int k = 1; k < a; k++) {\n                    if (k == 1) {\n                        dp[ai.indexOf(i, k, 0)] = sum[1];\n                    } else {\n                        dp[ai.indexOf(i, k, 0)] = dp[ai.indexOf(i - 1, k - 1, 0)];\n                    }\n                }\n                for (int k = 1; k < b; k++) {\n                    if (k == 1) {\n                        dp[ai.indexOf(i, k, 1)] = sum[0];\n                    } else {\n                        dp[ai.indexOf(i, k, 1)] = dp[ai.indexOf(i - 1, k - 1, 1)];\n                    }\n                }\n            }\n\n            Arrays.fill(sum, 0);\n            for (int j = 0; j < a; j++) {\n                sum[0] = mod.plus(sum[0], mod.mul(dp[ai.indexOf(n, j, 0)], f(j - 1)));\n            }\n            for (int j = 0; j < b; j++) {\n                sum[1] = mod.plus(sum[1], dp[ai.indexOf(n, j, 1)]);\n            }\n            debug.debug(\"sum\", sum);\n\n            int invalid = mod.plus(sum[0], sum[1]);\n            int total = pow.pow(2, n);\n            int valid = mod.subtract(total, invalid);\n            out.println(valid);\n        }\n\n        public int f(int i) {\n            if (i <= 0) {\n                return 1;\n            }\n            if (f[i] == -1) {\n                f[i] = f(i - 1);\n                for (int t = b; i - t >= 0; t++) {\n                    f[i] = mod.plus(f[i], f(i - t - 1));\n                }\n            }\n            return f[i];\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class ArrayIndex {\n        int[] dimensions;\n\n        public ArrayIndex(int... dimensions) {\n            this.dimensions = dimensions;\n        }\n\n        public int totalSize() {\n            int ans = 1;\n            for (int x : dimensions) {\n                ans *= x;\n            }\n            return ans;\n        }\n\n        public int indexOf(int a, int b) {\n            return a * dimensions[1] + b;\n        }\n\n        public int indexOf(int a, int b, int c) {\n            return indexOf(a, b) * dimensions[2] + c;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"test\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    static int mod = 1_000_000_007;\n\n    static long pow(long a,int n) {\n        long res=1;\n        while (n>0) {\n            if ((n-n/2*2)==1) {\n                res=res*a%mod;\n            }\n            a=a*a%mod;\n            n>>=1;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        long[][] dp = new long[N][A+B-2];\n        // dp[ind][j] -> contiguous_zero is j+1 (0 <= j <A-1)\n        // dp[ind][j] -> contiguous_one is j-(A-1)+1 (A-1 <= j < A-1+B-1)\n\n        dp[0][0] = 1;\n        dp[0][A-1] = 1;\n        for (int i=0;i<N-1;i++) {\n            for (int j=0;j<A-1;j++) {\n                if (j != A-2) {\n                    dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%mod;\n                }\n                dp[i+1][A-1] = (dp[i+1][A-1]+dp[i][j])%mod;\n            }\n            for (int j=A-1;j<A+B-2;j++) {\n                if (j != A+B-3) {\n                    dp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%mod;\n                }\n                dp[i+1][0] = (dp[i+1][0]+dp[i][j])%mod;\n            }\n        }\n\n        System.out.println(Arrays.deepToString(dp));\n        long ans = 0L;\n        for (int j=0;j<A+B-2;j++) {\n            ans = (ans+dp[N-1][j])%mod;\n        }\n\n        System.out.println((pow(2, N)-ans+mod)%mod);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 1000000007;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt(), a = scanInt(), b = scanInt();\n\t\tif (a < b) {\n\t\t\tint t = a;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\tSystem.err.println(a + \" \" + b);\n\t\tint dyn1[] = new int[n + 2];\n\t\tdyn1[0] = 1;\n\t\tfor (int i = 1; i <= n + 1; i++) {\n\t\t\tint v = dyn1[i - 1];\n\t\t\tfor (int j = i - b - 1; j >= 0; j--) {\n\t\t\t\tv = add(v, dyn1[j]);\n\t\t\t}\n\t\t\tdyn1[i] = v;\n\t\t}\n\t\tint res1[] = new int[n + 1];\n\t\tint res2[] = new int[n + 1];\n\t\tint res1g[] = new int[n + 1];\n\t\tint res2g[] = new int[n + 1];\n\t\tres1[0] = res2[0] = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 1; i + j <= n; j++) {\n\t\t\t\tint cres2[] = j >= a ? res2g : res2;\n\t\t\t\tcres2[i + j] = add(cres2[i + j], mul(res1[i], dyn1[j - 1 + (i == 0 ? 1 : 0) + (i + j == n ? 1 : 0)]));\n\t\t\t\tres2g[i + j] = add(res2g[i + j], mul(res1g[i], dyn1[j - 1 + (i == 0 ? 1 : 0) + (i + j == n ? 1 : 0)]));\n\t\t\t}\n\t\t\tfor (int j = 1; j < b && i + j <= n; j++) {\n\t\t\t\tres1[i + j] = add(res1[i + j], res2[i]);\n\t\t\t\tres1g[i + j] = add(res1g[i + j], res2g[i]);\n\t\t\t}\n\t\t}\n//\t\tSystem.err.println(Arrays.toString(dyn1));\n//\t\tSystem.err.println(Arrays.toString(res1));\n//\t\tSystem.err.println(Arrays.toString(res2));\n\t\tout.print(add(res1g[n], res2g[n]));\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing System.Collections.Generic;\n\nclass Myon\n\n{\n    public Myon() { }\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Myon().calc();\n        return 0;\n    }\n    static Scanner cin;\n\n    void calc()\n    {\n        long mod = 1000000007;\n\n\n        int N = cin.nextInt();\n        int A = cin.nextInt();\n        int B = cin.nextInt();\n        if (A > B) swap(ref A, ref B);\n\n        int[] num = new int[] { A, B };\n        long[,] adddp = new long[B + 1, 2];\n        for (int i = 0; i < A; i++)\n        {\n            adddp[i, 0] = 1;\n        }\n\n        long[] dp2 = new long[B + 1];\n        long[] sum = new long[B + 1];\n        dp2[0] = 1;\n        sum[0] = 1;\n        for (int i = 1; i < B + 1; i++)\n        {\n            for (int j = 0; j < i - A; j++)\n            {\n                dp2[i] += sum[j];\n            }\n            dp2[i] %= mod;\n            \n            sum[i] = sum[i - 1] + dp2[i];\n            if (sum[i] >= mod) sum[i] -= mod;\n        }\n\n        for (int i = 1; i < B + 1; i++)\n        {\n            adddp[i, 1] = sum[i - 1];\n        }\n\n\n        long[,] dp = new long[N + 3, 2];\n        dp[0, 1] = 1;\n        dp[B, 0] = sum[B - 1];\n\n        for (int i = 0; i < N + 3; i++)\n        {\n            for (int j = 0; j < 2; j++)\n            {\n                //if (dp[i, j] == 0) continue;\n                for (int k = 1; k < num[j]; k++)\n                {\n                    if (i + k >= dp.GetLength(0)) break;\n                    dp[i + k, 1 - j] += dp[i, j] * adddp[k, j];\n                    dp[i + k, 1 - j] %= mod;\n                }\n            }\n        }\n\n        long all = 1;\n        for (int i = 0; i < N; i++)\n        {\n            all *= 2;\n            all %= mod;\n        }\n\n        long ans = all - (dp[N + 2, 0] + dp[N + 2 - B, 1] * sum[B - 1]);\n        ans %= mod;\n        ans += mod;\n        ans %= mod;\n\n        Console.WriteLine(ans);\n\n    }\n\n    void swap<T>(ref T a, ref T b)\n    {\n        T c = a;\n        a = b;\n        b = c;\n    } \n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO.Pipes;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AtCoder {\n    class RangeSet {\n        const long MOD = 1000000007L;\n\n        static void Main(string[] args) {\n            var parts = Console.ReadLine().Split(' ');\n            int N = int.Parse(parts[0]);\n            int A = int.Parse(parts[1]);\n            int B = int.Parse(parts[2]);\n            if (A>B) {\n                int tmp = A;\n                A = B;\n                B = tmp;\n            }\n\n            long ans = 1;\n            for (int i = 0; i < N; i++) {\n                ans = (2 * ans) % MOD;\n            }\n\n            long[][] dp1 = new long[N + 1][];\n            for (int i = 0; i <= N; i++) {\n                dp1[i] = new long[2];\n            }\n\n            dp1[1][1] = 1;\n            for (int len = 1; len < N; len++) {\n                dp1[len + 1][1] += dp1[len][0] + dp1[len][1];\n                dp1[len + 1][1] %= MOD;\n\n                for (int zLen = A; len + zLen <= N; zLen++) {\n                    dp1[len + zLen][0] += dp1[len][1];\n                    dp1[len + zLen][0] %= MOD;\n                }\n            }\n\n            long[][] dp2 = new long[N + 1][];\n            for (int i = 0; i <= N; i++) {\n                dp2[i] = new long[2];\n            }\n\n            dp2[0][0] = 1;\n            dp2[0][1] = 1;\n            for (int oLen = 1; oLen < B; oLen++) {\n                dp2[oLen][1] = dp1[oLen][0];\n            }\n\n            for (int len = 0; len < N; len++) {\n                for (int zLen = 1; zLen < A && len + zLen <= N; zLen++) {\n                    dp2[len + zLen][0] += dp2[len][1];\n                    dp2[len + zLen][0] %= MOD;\n                }\n                for (int oLen = 1; oLen < B && len + oLen <= N; oLen++) {\n                    dp2[len + oLen][1] += dp2[len][0] * dp1[oLen][1];\n                    dp2[len + oLen][1] %= MOD;\n\n                    if (len + oLen == N) {\n                        dp2[len + oLen][1] += dp2[len][0] * dp1[oLen][0];\n                        dp2[len + oLen][1] %= MOD;\n                    }\n                }\n            }\n\n            ans -= dp2[N][0] + dp2[N][1];\n            ans = (ans + 2 * MOD) % MOD;\n            Console.WriteLine(ans);\n        }\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "gets\n$<.each_slice(3).map{|_,a,s,*b|p a.split.map(&:to_i).zip(s.chars).reverse.all?{|a,f|b.map{a=[a,a^_1].min}\na<1||f[?0]&&b<<a}?0:1}"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 10^^9 + 7;\nalias Mint = ModInt!MO;\n\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const N = readInt();\n      int A = readInt();\n      int B = readInt();\n      if (A > B) {\n        swap(A, B);\n      }\n      \n      // (>= A) 0's and 1's\n      // len, last\n      auto sub = new Mint[][](N + 1, 2);\n      foreach (k; A .. N + 1) {\n        sub[k][0] += 1;\n      }\n      foreach (k; 1 .. N + 1) {\n        sub[k][1] += 1;\n      }\n      foreach (i; 1 .. N) {\n        foreach (k; A .. N - i + 1) {\n          sub[i + k][0] += sub[i][1];\n        }\n        foreach (k; 1 .. N - i + 1) {\n          sub[i + k][1] += sub[i][0];\n        }\n      }\n      debug {\n        if (N <= 10) {\n          writeln(\"sub = \", sub);\n        }\n      }\n      \n      // len, last, ok\n      auto dp = new Mint[][][](N + 1, 2, 2);\n      foreach (k; 1 .. A) {\n        dp[k][0][0] = 1;\n      }\n      foreach (k; 1 .. N) {\n        // *1\n        dp[k][1][(k >= B) ? 1 : 0] += sub[k][1];\n      }\n      dp[N][1][(N >= B) ? 1 : 0] += sub[N][0] + sub[N][1];\n      foreach (i; 1 .. N) {\n        foreach (k; 1 .. N - i + 1) {\n          if (k < A) {\n            foreach (t; 0 .. 2) {\n              dp[i + k][0][t] += dp[i][1][t];\n            }\n          }\n        }\n        foreach (k; 1 .. N - i) {\n          // 1 or 1*1\n          foreach (t; 0 .. 2) {\n            dp[i + k][1][(t || k >= B) ? 1 : 0] += dp[i][0][t] * ((k == 1) ? Mint(1) : sub[k - 1][1]);\n          }\n        }\n        // 1*\n        foreach (t; 0 .. 2) {\n          dp[N][1][(t || N - i >= B) ? 1 : 0] += dp[i][0][t] * sub[N - i][1];\n        }\n      }\n      \n      Mint ans;\n      foreach (s; 0 .. 2) {\n        ans += dp[N][s][1];\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 10**9 + 7\n\nN, A, B = map(int, read().split())\n\nif A > B:\n    A, B = B, A\n\ndp1 = np.zeros((N, B), dtype=np.int64)  # その時点で確定している長さ集計\ndp2 = np.zeros((N, B), dtype=np.int64)  # もし右に十分な 0 があったとしたときの、長さ集計\ndp1_sum = np.zeros(N, dtype=np.int64)\n\nans = 0\nfor n in range(N):\n    # そこで初めての 1 がたつ場合\n    if n + 1 < B:\n        if n >= A:\n            dp1[n, n + 1] += 1\n        else:\n            dp1[n, 1] += 1\n    # ひとつ手前から 1 を立てて遷移した場合\n    dp1[n, 1:] += dp1[n - 1, :-1]\n    dp1[n] %= MOD\n    # 使えない個数の 0 をはさんで遷移した場合\n    if n >= A:\n        dp1[n, 1] += dp1_sum[n - A:n - 1].sum() % MOD\n    # たくさんの個数の 0 をはさんで遷移した場合\n    if n >= A + 1:\n        dp1[n, A + 1:B] += dp2[n - A - 1, 0:B - (A + 1)]\n    dp1[n] %= MOD\n    # 右を 0 埋めして足せるなら答に足す\n    dp1_sum[n] = dp1[n].sum() % MOD\n    if (N - n - 1) < A:\n        ans += dp1_sum[n]\n        ans %= MOD\n    else:\n        # あと N - n - 1 のびても B にならないような範囲\n        M = B - (N - n - 1)\n        if M > 0:\n            ans += dp1[n, :M].sum() % MOD\n    dp2[n] += dp1[n]\n    dp2[n, 1:] += dp2[n - 1, :-1]\n    dp1[n] %= MOD\n    dp2[n] %= MOD\n\nx = pow(2, N, MOD) - ans\nprint(x % MOD)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 10**9 + 7\n\nN, A, B = map(int, read().split())\n\ndef solve(N, A, B):\n    if A > B:\n        A, B = B, A\n    if A == 1:\n        return pow(2, N, MOD)\n    dp1 = np.zeros((N, B), dtype=np.int64)  # その時点で確定している長さ集計\n    dp2 = np.zeros((N, B), dtype=np.int64)  # もし右に十分な 0 があったとしたときの、長さ集計\n    dp1_sum = np.zeros(N, dtype=np.int64)\n    ans = 0\n    for n in range(N):\n        # そこで初めての 1 がたつ場合\n        if n < A:\n            dp1[n, 1] += 1\n        else:\n            if n + 1 < B:\n                dp1[n, n + 1] += 1\n        # ひとつ手前から 1 を立てて遷移した場合\n        if n > 0:\n            dp1[n, 1:] += dp1[n - 1, :-1]\n        # 使えない個数の 0 をはさんで遷移した場合\n        dp1[n, 1] += dp1_sum[max(0, n - A):n - 1].sum() % MOD\n        # たくさんの個数の 0 をはさんで遷移した場合\n        if n >= A + 1 < B:\n            dp1[n, A + 1:B] += dp2[n - A - 1, 0:B - (A + 1)]\n        dp1[n] %= MOD\n        # 右を 0 埋めして足せるなら答に足す\n        dp1_sum[n] = dp1[n].sum() % MOD\n        if (N - n - 1) < A:\n            ans += dp1_sum[n]\n        else:\n            # あと N - n - 1 のびても B にならないような範囲\n            M = B - (N - n - 1)\n            if M > 0:\n                ans += dp1[n, :M].sum() % MOD\n        dp2[n] += dp1[n]\n        dp2[n, 1:] += dp2[n - 1, :-1]\n        dp2[n] %= MOD\n    x = pow(2, N, MOD) - ans\n    return x % MOD\n\nprint(solve(N, A, B))\n"
  },
  {
    "language": "Python",
    "code": "def combination_mod(n, r, mod):\n    # フェルマーの小定理\n    # nCr=n!(r!)^p-2((n-r)!)^p-2\n\n    n_ = 1\n    for i in range(1, n + 1):\n        n_ = (n_ * i) % mod\n    r_ = 1\n    for i in range(1, r + 1):\n        r_ = (r_ * i) % mod\n    nr_ = 1\n    for i in range(1, n - r + 1):\n        nr_ = (nr_ * i) % mod\n\n    power_r = pow(r_, mod - 2, mod)\n    power_nr = pow(nr_, mod - 2, mod)\n\n    return (n_ * power_r * power_nr) % mod\n\n\ndef main():\n    N,A,B=map(int,input().split())\n\n    mod=pow(10,9)+7\n\n    PatternA=0\n    PatternB=0\n\n    #PatternA\n    for a in range(1,N-A+2):\n        PatternA+=combination_mod(N-(A-1),a,mod)\n    #PatternB\n    for b in range(1,N-B+2):\n        PatternB+=combination_mod(N-(B-1),b,mod)\n\n    res=PatternA+PatternB\n\n    print(res+1)\n\nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\n\nすべて0にする、すべて1にするは自明に可能\nなので A >= B としてよい(A<Bの時は01を入れ替えて考えればよい)\n\n最後に置いた場所の周囲がどんな状況か考える\n\n0*Aがある場合、その周囲はすべての場合構成可能\nない場合は…？\n1*Bがある場合を考える。長さB以上の1列は後からおけるからおｋだが…\n長さB以上の1をすべて0に変えたときに、長さA以上の0があればおｋ\n\nどう数え上げる？\nダメな場合を引くのがよさそう？\n→dp[i][last][num] = i番目まで見て、lastを現在num個連続しておいている場合の通り数\nただし、dp[?][1][B-1]はdp[?][0][B]に伝播する\nこれまずいか\n\nブロックで考えるやり方はどうなんだろう\nつまり、連鎖を断ち切れるのは長さB以下の1列だけ\n\n0 or B以上連続する1の列のみで構成されたブロックX(Yに隣接する端は0である必要あり)\nB未満の1列であるブロックYを交互に置いていく\n\ndp[i][XorY] = i番目の文字を次に置けるとき、最後に置いたブロックがXorYの時の通り数\n初期値は\ndp[0][X] = 1\ndp[0][Y] = 1 ←これ、かなり注意する必要がある左端が1でもいいから\n同様に、Nに移行する時にXを置くときも右端を1にできるのに注意\n\nB以上連続する1を0に変えるとすべて0になる文字列の数をまず求める\n上と同様にブロックdp?\n0のブロックは,1以上のどんな長さでも置ける\n1のブロックは,B以上の長さ置ける\ndp[0][Z] = 1\ndp[0][O] = 1\n\n\"\"\"\n\nN,A,B = map(int,input().split())\n\nfdp = [[0,0] for i in range(N+1)]\nfdp[0] = [1,1]\nmod = 10**9+7\n\nif A < B:\n    tmp = B\n    B = A\n    A = tmp\n\nfor i in range(N):\n\n    for j in range(i+1,N+1):\n        fdp[j][0] += fdp[i][1]\n        fdp[j][0] %= mod\n\n    for j in range(i+B,N+1):\n        fdp[j][1] += fdp[i][0]\n        fdp[j][1] %= mod\n\n#print (fdp)\n\ndp = [[0,0] for i in range(N+1)]\ndp[0] = [1,1]\n\nfor i in range(N):\n\n    for j in range(i+1,min(N+1,i+B)):\n        dp[j][1] += dp[i][0]\n        dp[j][1] %= mod\n\n    #ここかなり注意\n    for j in range(i+1,min(N+1,i+A)):\n\n        l = j-i\n\n        if i == 0 or j == N:\n            if l == 1:\n                dp[j][0] += dp[i][1]\n                dp[j][0] %= mod\n            else:\n                dp[j][0] += dp[i][1] * sum(fdp[l-1])\n                dp[j][0] %= mod\n\n        else:\n            if l <= 2:\n                dp[j][0] += dp[i][1]\n                dp[j][0] %= mod\n            else:\n                dp[j][0] += dp[i][1] * sum(fdp[l-2])\n                dp[j][0] %= mod\n\n#print (dp)          \nprint ((pow(2,N,mod)-sum(dp[N])) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import math\n#import sys\n#input = sys.stdin.readline\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\ndef ValueToBits(x,digit):\n    res = [0 for i in range(digit)]\n    now = x\n    for i in range(digit):\n        res[i]=now%2\n        now = now >> 1\n    return res\n\ndef BitsToValue(arr):\n    n = len(arr)\n    ans = 0\n    for i in range(n):\n        ans+= arr[i] * 2**i\n    return ans\n\ndef ZipArray(a):\n    aa = [[a[i],i]for i in range(n)]\n\n    aa.sort(key = lambda x : x[0])\n    for i in range(n):\n        aa[i][0]=i+1\n    aa.sort(key = lambda x : x[1])\n    b=[aa[i][0] for i in range(len(a))]\n    return b\n\ndef ValueToArray10(x, digit):\n    ans = [0 for i in range(digit)]\n    now = x\n    for i in range(digit):\n        ans[digit-i-1] = now%10\n        now = now //10\n    return ans\n\ndef Zeros(a,b):\n    if(b<=-1):\n        return [0 for i in range(a)]\n    else:\n        return [[0 for i in range(b)] for i in range(a)]\n\ndef AddV2(v,w):\n    return [v[0]+w[0],v[1]+w[1]]\n\ndir4 = [[1,0],[0,1],[-1,0],[0,-1]]\n\n\ndef clamp(x,y,z):\n    return max(y,min(z,x))\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n \n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n            \n#\ndef Zaatsu(a):\n    a.sort()\n    now = a[0][0]\n    od = 0\n    for i in range(n):\n        if(now==a[i][0]):\n            a[i][0]=od\n        else:\n            now = a[i][0]\n            od+=1\n            a[i][0] = od\n    \n    a.sort(key = lambda x : x[1])\n    return a\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 併合\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか判定\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n'''\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 2\nN = 10 ** 6 + 2\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv 計算用\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\n'''\n\ndef rl(x):\n    return range(len(x))\n\n# a = list(map(int, input().split()))\n\n#################################################\n#################################################\n#################################################\n#################################################\n\n\n#11-\n\n\nn,aa,bb = list(map(int, input().split()))\n\na = max(aa,bb)\nb = min(aa,bb)\np = 1000000007\n\nxs0 = [0]*(n+1)\nos0 = [0]*(n+1)\n\nos0[0] = 1\n\nfor i in range(b,a-1):\n    for j in range(b,i+1):\n        xs0[i] += os0[i-j]\n        xs0[i] %= p\n    for j in range(1,i+1):\n        os0[i] += xs0[i-j]\n        os0[i] %= p\n\n\n#print(xs0[:50])\n#print(os0[:50])\n\nos = [0]*a\n\nfor i in range(b,a-2): #number-x\n    for j in range(2,a-i): # adding o\n        os[i+j] += xs0[i] * (j-1)\n\nx = [0]*(n+1)\no = [0]*(n+1)\n\nfor i in range(b+1,a): # adding distination\n    for j in range(b,i): # length of xs\n        o[i] += xs0[j]\n        o[i] %= p\n\nx[0] = 1\no[0] = 1\n\nfor i in range(1,n+1):\n    for j in range(1,min(b,i+1)):\n        x[i] += o[i-j]\n    for j in range(1,min(a,i+1)):\n        o[i] += x[i-j]\n    for j in range(b+2,min(a,i+1)):\n        o[i] += x[i-j]*os[j]\n    x[i] %= p\n    o[i] %= p\n\nfor i in range(b+1,a):\n    for j in range(b,i):\n        o[n] += xs0[j] * x[n-i]\n        o[i]%=p\n\nans = o[n] + x[n]\nans %= p\n\n#print(ans)\n\nbeki2 = [1]*5001\n\nfor i in range(5000):\n    beki2[i+1] = beki2[i]*2\n    beki2[i+1] %= p\n\nans = beki2[n] - ans\nans += p\nans %= p\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "S = list(input())\nN = int(input())\n\n'''\nordの位置\n#z = 122\n#a = 97\n左の文字からNで'a'に出来るかを確認\naに出来るならaにして使った分をNから引く\n繰り返して行き一番最後にあまりをすべて使う'''\n  \nfor i, s in enumerate(S):\n  if ord(s) - 97 > 0  and 122 - ord(s) < N:\n    S[i] = \"a\"\n    N -= 123 - ord(s)\nelse:\n  S[i] = (chr((ord(S[i]) + N) % 122 ))\n  \n  \nprint(\"\".join(S))"
  },
  {
    "language": "Python",
    "code": "from bisect import *\nfrom collections import *\n#from math import *\nfrom heapq import *\nfrom typing import List\nfrom itertools import *\n#from operator import *\nfrom functools import *\nimport sys\n'''\n@lru_cache(None)\ndef fact(x):\n    if x<2:\n        return 1\n    return fact(x-1)*x\n\n@lru_cache(None)\ndef per(i,j):\n    return fact(i)//fact(i-j)\n\n@lru_cache(None)\ndef com(i,j):\n    return per(i,j)//fact(j)\n\ndef linc(f,t,l,r):\n    while l<r:\n        mid=(l+r)//2\n        if t>f(mid):\n            l=mid+1\n        else:\n            r=mid\n    return l\n\ndef rinc(f,t,l,r):\n    while l<r:\n        mid=(l+r+1)//2\n        if t<f(mid):\n            r=mid-1\n        else:\n            l=mid\n    return l\n\ndef ldec(f,t,l,r):\n    while l<r:\n        mid=(l+r)//2\n        if t<f(mid):\n            l=mid+1\n        else:\n            r=mid\n    return l\n\ndef rdec(f,t,l,r):\n    while l<r:\n        mid=(l+r+1)//2\n        if t>f(mid):\n            r=mid-1\n        else:\n            l=mid\n    return l\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef power2(n):\n    while not n&1:\n        n>>=1\n    return n==1\n'''\nsys.setrecursionlimit(10000)\nmod=10**9+7\nn,a,b=map(int,input().split())\nif a>b:\n    a,b=b,a\n@lru_cache(None)\ndef dp(i,bit,carry):\n    if i==n:\n        return 1\n    if i>n:\n        return 0\n    tmp=0\n    if bit==0:\n        for j in range(1,max(a,b-carry)):\n            tmp=(tmp+dp(i+j,1,0 if j<a else carry+j))%mod\n    else:\n        for j in range(1,b-carry):\n            tmp=(tmp+dp(i+j,0,carry+j))%mod\n    return tmp\nans=pow(2,n,mod)\nif b==1:\n    print(ans)\nelse:\n    ans=(ans-dp(0,0,0)-dp(0,1,0))%mod\n    print(ans)\n        \n            \n\n\n                \n    \n\n"
  },
  {
    "language": "Python",
    "code": "def combination_mod(n, r, mod):\n    # フェルマーの小定理\n    # nCr=n!(r!)^p-2((n-r)!)^p-2\n\n    n_ = 1\n    for i in range(1, n + 1):\n        n_ = (n_ * i) % mod\n    r_ = 1\n    for i in range(1, r + 1):\n        r_ = (r_ * i) % mod\n    nr_ = 1\n    for i in range(1, n - r + 1):\n        nr_ = (nr_ * i) % mod\n\n    power_r = pow(r_, mod - 2, mod)\n    power_nr = pow(nr_, mod - 2, mod)\n\n    return (n_ * power_r * power_nr) % mod\n\n\ndef main():\n    N,A,B=map(int,input().split())\n\n    mod=pow(10,9)+7\n\n    PatternA=0\n    PatternB=0\n\n    #PatternA\n    for a in range(N-(A-1)):\n        PatternA+=combination_mod(N-(A-1),a,mod)\n    #PatternB\n    for b in range(N-(B-1)):\n        PatternB+=combination_mod(N-(B-1),b,mod)\n\n    res=PatternA+PatternB\n\n    print(res+1)\n\nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 10**9 + 7\n\nN, A, B = map(int, read().split())\n\nif A > B:\n    A, B = B, A\n\ndp1 = np.zeros((N, B), dtype=np.int64)  # その時点で確定している長さ集計\ndp2 = np.zeros((N, B), dtype=np.int64)  # もし右に十分な 0 があったとしたときの、長さ集計\ndp1_sum = np.zeros(N, dtype=np.int64)\n\nans = 0\nfor n in range(N):\n    # そこで初めての 1 がたつ場合\n    if n + 1 < B:\n        if n >= A:\n            dp1[n, n + 1] += 1\n        else:\n            dp1[n, 1] += 1\n    # ひとつ手前から 1 を立てて遷移した場合\n    dp1[n, 1:] += dp1[n - 1, :-1]\n    dp1[n] %= MOD\n    # 使えない個数の 0 をはさんで遷移した場合\n    dp1[n, 1] += dp1_sum[n - A:n - 1].sum() % MOD\n    # たくさんの個数の 0 をはさんで遷移した場合\n    if n >= A + 1:\n        dp1[n, A + 1:B] += dp2[n - A - 1, 0:B - (A + 1)]\n    dp1[n] %= MOD\n    # 右を 0 埋めして足せるなら答に足す\n    dp1_sum[n] = dp1[n].sum() % MOD\n    if (N - n - 1) < A:\n        ans += dp1_sum[n]\n        ans %= MOD\n    else:\n        # あと N - n - 1 のびても B にならないような範囲\n        M = B - (N - n - 1)\n        if M > 0:\n            ans += dp1[n, :M].sum() % MOD\n    dp2[n] += dp1[n]\n    dp2[n, 1:] += dp2[n - 1, :-1]\n    dp1[n] %= MOD\n    dp2[n] %= MOD\n\nx = pow(2, N, MOD) - ans\nprint(x % MOD)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 10**9 + 7\n\nN, A, B = map(int, read().split())\n\ndef solve(N, A, B):\n    if A > B:\n        A, B = B, A\n    if A == 1:\n        return pow(2, N, MOD)\n    dp1 = np.zeros((N, B), dtype=np.int64)  # その時点で確定している長さ集計\n    dp2 = np.zeros((N, B), dtype=np.int64)  # もし右に十分な 0 があったとしたときの、長さ集計\n    dp1_sum = np.zeros(N, dtype=np.int64)\n    ans = 0\n    for n in range(N):\n        # そこで初めての 1 がたつ場合\n        if n < A:\n            dp1[n, 1] += 1\n        else:\n            if n + 1 < B:\n                dp1[n, n + 1] += 1\n        # ひとつ手前から 1 を立てて遷移した場合\n        if n > 0:\n            dp1[n, 1:] += dp1[n - 1, :-1]\n        # 使えない個数の 0 をはさんで遷移した場合\n        dp1[n, 1] += dp1_sum[max(0, n - A):n - 1].sum() % MOD\n        # たくさんの個数の 0 をはさんで遷移した場合\n        if n >= A + 1 < B:\n            dp1[n, A + 1:B] += dp2[n - A - 1, 0:B - (A + 1)]\n        dp1[n] %= MOD\n        # 右を 0 埋めして足せるなら答に足す\n        dp1_sum[n] = dp1[n].sum() % MOD\n        if (N - n - 1) < A:\n            ans += dp1_sum[n]\n            ans %= MOD\n        else:\n            # あと N - n - 1 のびても B にならないような範囲\n            M = B - (N - n - 1)\n            if M > 0:\n                ans += dp1[n, :M].sum() % MOD\n        dp2[n] += dp1[n]\n        dp2[n, 1:] += dp2[n - 1, :-1]\n        dp1[n] %= MOD\n        dp2[n] %= MOD\n    x = pow(2, N, MOD) - ans\n    return x % MOD\n\nprint(solve(N, A, B))"
  },
  {
    "language": "Python",
    "code": "\n\nn,aa,bb = list(map(int, input().split()))\n\na = max(aa,bb)\nb = min(aa,bb)\np = 1000000007\n\nxs0 = [0]*(n+1)\nos0 = [0]*(n+1)\n\nos0[0] = 1\n\nfor i in range(b,a-1):\n    for j in range(b,i+1):\n        xs0[i] += os0[i-j]\n        xs0[i] %= p\n    for j in range(1,i+1):\n        os0[i] += xs0[i-j]\n        os0[i] %= p\n\n\n#print(xs0[:50])\n#print(os0[:50])\n\nos = [0]*a\n\nfor i in range(b,a-2): #number-x\n    for j in range(2,a-i): # adding o\n        os[i+j] += xs0[i] * (j-1)\n\nx = [0]*(n+1)\no = [0]*(n+1)\n\nfor i in range(b+1,a): # adding distination\n    for j in range(b,i): # length of xs\n        o[i] += xs0[j]\n        o[i] %= p\n\nx[0] = 1\no[0] = 1\n\nfor i in range(1,n+1):\n    for j in range(1,min(b,i+1)):\n        x[i] += o[i-j]\n    for j in range(1,min(a,i+1)):\n        o[i] += x[i-j]\n    for j in range(b+2,min(a,i+1)):\n        o[i] += x[i-j]*os[j]\n    x[i] %= p\n    o[i] %= p\n\nfor i in range(b+1,a):\n    for j in range(b,i):\n        o[n] += xs0[j] * x[n-i]\n        o[i]%=p\n\nans = o[n] + x[n]\nans %= p\n\n#print(ans)\n\nbeki2 = [1]*5001\n\nfor i in range(5000):\n    beki2[i+1] = beki2[i]*2\n    beki2[i+1] %= p\n\nans = beki2[n] - ans\nans += p\nans %= p\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n#import sys\n#input = sys.stdin.readline\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\ndef ValueToBits(x,digit):\n    res = [0 for i in range(digit)]\n    now = x\n    for i in range(digit):\n        res[i]=now%2\n        now = now >> 1\n    return res\n\ndef BitsToValue(arr):\n    n = len(arr)\n    ans = 0\n    for i in range(n):\n        ans+= arr[i] * 2**i\n    return ans\n\ndef ZipArray(a):\n    aa = [[a[i],i]for i in range(n)]\n\n    aa.sort(key = lambda x : x[0])\n    for i in range(n):\n        aa[i][0]=i+1\n    aa.sort(key = lambda x : x[1])\n    b=[aa[i][0] for i in range(len(a))]\n    return b\n\ndef ValueToArray10(x, digit):\n    ans = [0 for i in range(digit)]\n    now = x\n    for i in range(digit):\n        ans[digit-i-1] = now%10\n        now = now //10\n    return ans\n\ndef Zeros(a,b):\n    if(b<=-1):\n        return [0 for i in range(a)]\n    else:\n        return [[0 for i in range(b)] for i in range(a)]\n\ndef AddV2(v,w):\n    return [v[0]+w[0],v[1]+w[1]]\n\ndir4 = [[1,0],[0,1],[-1,0],[0,-1]]\n\n\ndef clamp(x,y,z):\n    return max(y,min(z,x))\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n \n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n            \n#\ndef Zaatsu(a):\n    a.sort()\n    now = a[0][0]\n    od = 0\n    for i in range(n):\n        if(now==a[i][0]):\n            a[i][0]=od\n        else:\n            now = a[i][0]\n            od+=1\n            a[i][0] = od\n    \n    a.sort(key = lambda x : x[1])\n    return a\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 併合\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか判定\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n'''\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 2\nN = 10 ** 6 + 2\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv 計算用\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\n'''\n\ndef rl(x):\n    return range(len(x))\n\n# a = list(map(int, input().split()))\n\n#################################################\n#################################################\n#################################################\n#################################################\n\n\n#11-\n\n\nn,aa,bb = list(map(int, input().split()))\n\na = max(aa,bb)\nb = min(aa,bb)\np = 1000000007\n\nxs0 = [0]*(n+1)\nos0 = [0]*(n+1)\n\nos0[0] = 1\n\nfor i in range(b,a-1):\n    for j in range(b,i+1):\n        xs0[i] += os0[i-j]\n        xs0[i] %= p\n    for j in range(1,i+1):\n        os0[i] += xs0[i-j]\n        os0[i] %= p\n\n\n#print(xs0[:50])\n#print(os0[:50])\n\nos = [0]*a\n\nfor i in range(b,a-2): #number-x\n    for j in range(2,a-i): # adding o\n        os[i+j] += xs0[i] * (j-1)\n\nx = [0]*(n+1)\no = [0]*(n+1)\n\nfor i in range(b+1,a): # adding distination\n    for j in range(b,i): # length of xs\n        o[i] += xs0[j]\n        o[i] %= p\n\nx[0] = 1\no[0] = 1\n\nfor i in range(1,n+1):\n    for j in range(1,min(b,i+1)):\n        x[i] += o[i-j]\n    for j in range(1,min(a,i+1)):\n        o[i] += x[i-j]\n    for j in range(b+2,min(a,i+1)):\n        o[i] += x[i-j]*os[j]\n    x[i] %= p\n    o[i] %= p\n\nfor i in range(b+1,a):\n    for j in range(b,i):\n        o[n] += xs0[j] * x[n-i]\n        o[i]%=p\n\nans = o[n] + x[n]\nans %= p\n\n#print(ans)\n\nbeki2 = [1]*5001\n\nfor i in range(5000):\n    beki2[i+1] = beki2[i]*2\n    beki2[i+1] %= p\n\nans = beki2[n] - ans\nans += p\nans %= p\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "N,A,B=map(int,input().split())\nmod=10**9+7\n\nA,B=min(A,B),max(A,B)\n\ndata=[0]*B\ndata[0]=1\nfor i in range(1,B):\n    data[i]=(data[i-1]+sum(data[i-1-k] for k in range(A,i)))%mod\n\n#print(data)\n\ndp=[0]*(N+1)\ndp[0]=1\nimos=[0]*(N+1)\nimos[0]=1\n\nfor i in range(1,N+1):\n    if i!=N:\n        for j in range(1,min(i,B)):\n            #dp[i]+=sum(dp[i-j-k]*data[j-1] for k in range(1,min(A,i-j+1)))\n            R=i-j-1\n            L=i-j-min(A,i-j+1)\n            if R>L:\n                if L>-1:\n                    dp[i]+=(imos[R]-imos[L])*data[j-1]\n                else:\n                    dp[i]+=imos[R]*data[j-1]\n                dp[i]%=mod\n        if B>i:\n            dp[i]+=data[i]\n            dp[i]%=mod\n    else:\n        for j in range(B):\n            #dp[i]+=sum(dp[i-j-k]*data[j] for k in range(1,min(A,i-j+1)))\n            R=i-j-1\n            L=i-j-min(A,i-j+1)\n            if R>L:\n                if L>-1:\n                    dp[i]+=(imos[R]-imos[L])*data[j]\n                else:\n                    dp[i]+=imos[R]*data[j]\n                dp[i]%=mod\n        #print(dp[i])\n        #dp[i]+=sum(dp[i-k] for k in range(1,A))\n    imos[i]=dp[i]\n    imos[i]+=imos[i-1]\n    imos[i]%=mod\n\n\n#print(dp)\nprint((pow(2,N,mod)-dp[N])%mod)"
  },
  {
    "language": "Python",
    "code": "n,aa,bb = list(map(int, input().split()))\n\na = max(aa,bb)\nb = min(aa,bb)\np = 1000000007\n\ndef calc(a,b,p):\n\n    xs0 = [0]*(n+1)\n    os0 = [0]*(n+1)\n    \n    os0[0] = 1\n    \n    for i in range(b,a-1):\n        for j in range(b,i+1):\n            xs0[i] += os0[i-j]\n            xs0[i] %= p\n        for j in range(1,i+1):\n            os0[i] += xs0[i-j]\n            os0[i] %= p\n    \n    \n    #print(xs0[:50])\n    #print(os0[:50])\n    \n    os = [0]*a\n    \n    for i in range(b,a-2): #number-x\n        for j in range(2,a-i): # adding o\n            os[i+j] += xs0[i] * (j-1)\n    \n    x = [0]*(n+1)\n    o = [0]*(n+1)\n    \n    for i in range(b+1,a): # adding distination\n        for j in range(b,i): # length of xs\n            o[i] += xs0[j]\n            o[i] %= p\n    \n    x[0] = 1\n    o[0] = 1\n    \n    for i in range(1,n+1):\n        for j in range(1,min(b,i+1)):\n            x[i] += o[i-j]\n        for j in range(1,min(a,i+1)):\n            o[i] += x[i-j]\n        for j in range(b+2,min(a,i+1)):\n            o[i] += x[i-j]*os[j]\n        x[i] %= p\n        o[i] %= p\n    \n    for i in range(b+1,a):\n        for j in range(b,i):\n            o[n] += xs0[j] * x[n-i]\n            o[i]%=p\n    \n    ans = o[n] + x[n]\n    ans %= p\n    \n    #print(ans)\n    \n    beki2 = [1]*5001\n    \n    for i in range(5000):\n        beki2[i+1] = beki2[i]*2\n        beki2[i+1] %= p\n    \n    ans = beki2[n] - ans\n    ans += p\n    ans %= p\n    return ans\n\nprint(calc(a,b,p))\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, a, b):\n    MOD = 10 ** 9 + 7\n    if a > b:\n        a, b = b, a\n    if a == 1:\n        return pow(2, n, MOD)\n\n    # 長さ i の区間であり、右端が '1' であり、\n    # はじめ '1' で塗りつぶされていたのを、\n    # 長さ a 以上の '0' で0回以上上書きすることで実現できる並びの個数\n    dp1 = [0] * (b + 1)\n    dp1_acc = [0] * (b + 1)\n    dp1[0] = 1\n    dp1_acc[0] = 1\n\n    for i in range(1, b + 1):\n        tmp = dp1[i - 1]  # 末尾に1を付ける\n        if i - a - 1 >= 0:\n            tmp = (tmp + dp1_acc[i - a - 1]) % MOD  # 末尾に 00..01 を付ける\n        dp1[i] = tmp\n        dp1_acc[i] = (dp1_acc[i - 1] + tmp) % MOD\n    # 派生情報\n    # dp1[i-1]: 長さ i の区間であり、「両端」が'1'であるものの個数\n    # dp1[i] - dp1[i-1]: 長さ i の区間であり、左端が'0'、右端が'1'（またはその逆）のものの個数\n\n    # dp2x[i]\n    # 長さ i の区間であり、末尾が x であり、\n    # 長さa以上の'0'も、長さb以上の'1'も含まない01の並びの個数\n    # ただし'1'は、dp1で求めたように、その内部をa個以上の'0'で置きかえたものも含む\n    dp20 = [0] * (n + 1)\n    dp21 = [0] * (n + 1)\n    dp21_acc = [0] * (n + 1)\n    dp20[0] = dp21[0] = dp21_acc[0] = 1\n    for i in range(1, n + 1):\n        t0 = dp21_acc[i - 1]\n        if i >= a:\n            t0 -= dp21_acc[i - a]\n        dp20[i] = t0 % MOD\n\n        t1 = 0\n        for j in range(1, min(i + 1, b)):\n            t1 += dp20[i - j] * dp1[j - 1]\n        # 左端が '111...' でb個以上取れないもので、さらに'0'で置きかえられた結果、最左端が'0'のもの\n        if i < b:\n            t1 += dp1[i] - dp1[i - 1]\n        t1 %= MOD\n        dp21[i] = t1\n        dp21_acc[i] = (dp21_acc[i - 1] + t1) % MOD\n\n    disable = dp20[n] + dp21[n]\n\n    # 最後が'111..'でb個以上取れないもので、\n    # さらに'0'で置きかえられた結果、右端が'0'のものが数えられていない\n    for i in range(1, b):\n        disable += dp20[n - i] * (dp1[i] - dp1[i - 1])\n\n    return (pow(2, n, MOD) - disable) % MOD\n\n\nn, a, b = map(int, input().split())\nprint(solve(n, a, b))\n"
  },
  {
    "language": "Python",
    "code": "MOD = 10 ** 9 + 7\nn, a, b = map(int, input().split())\n\nif a > b:\n    a, b = b, a\n\ndp_1s = [0] * b\nfor l in range(a + 2, b):\n    dp = [[0, 0] for _ in range(l + 1)] # at i, 0/1 precedes\n    dp[1][1] = 1\n    for i in range(1, l):\n        dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n        dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n        if i + a < l:\n            dp[i + a][0] = (dp[i + a][0] + dp[i][1]) % MOD\n    dp_1s[l] = dp[l][1] - 1\n\ndp_0s_edge = [0] * b\nfor l in range(a + 1, b):\n    dp = [[0, 0] for _ in range(l + 1)]\n    dp[a][0] = 1\n    for i in range(1, l):\n        dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n        dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n        if i + a < l:\n            dp[i + a][0] = (dp[i + a][0] + dp[i][1]) % MOD\n    dp_0s_edge[l] = dp[l][1] \n\n# starting at i, 0s/1s precede, i.e., 1s/0s follow\n# when 0s precede, len of preceding 0s is lt a\ndp = [[0, 0] for _ in range(n + 1)]\n\ndp[0] = [1, 1]\n# starting with 0s whose len is gt or eq to a\nfor l in range(a + 1, b):\n    dp[l][1] = dp_0s_edge[l]\n\nfor i in range(n):\n    for j in range(i + 1, min(n + 1, i + b)):\n        dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n    for j in range(i + 1, min(n + 1, i + a)):\n        dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n    for l in range(a + 2, b):\n        if i + l <= n:\n            dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n\n# ending with 0s whose len is gt or eq to a\nfor l in range(a + 1, b):\n    dp[n][0] = (dp[n][0] + dp[n - l][0] * dp_0s_edge[l]) % MOD\n\nprint((pow(2, n, MOD) - sum(dp[n])) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "MOD = 10 ** 9 + 7\nn, a, b = map(int, input().split())\n\nif a > b:\n    a, b = b, a\n\ndp_1s = [0] * b\nfor l in range(a + 2, b):\n    dp = [[0, 0] for _ in range(l + 1)] # at i, 0/1 precedes\n    dp[1][1] = 1\n    for i in range(1, l):\n        dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n        dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n        if i + a < l:\n            dp[i + a][0] = (dp[i + a][0] + dp[i][1]) % MOD\n    dp_1s[l] = dp[l][1] - 1\n\ndp_0s_edge = [0] * b\nfor l in range(a + 1, b):\n    dp = [[0, 0] for _ in range(l + 1)]\n    dp[a][0] = 1\n    for i in range(1, l):\n        dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n        dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n        if i + a < l:\n            dp[i + a][0] = (dp[i + a][0] + dp[i][1]) % MOD\n    dp_0s_edge[l] = dp[l][1] \n\n# starting at i, 0s/1s precede, i.e., 1s/0s follow\n# when 0s precede, len of preceding 0s is lt a\ndp = [[0, 0] for _ in range(n + 1)]\n\ndp[0] = [1, 1]\n# starting with 0s whose len is gt or eq to a\nfor l in range(a + 1, b):\n    dp[l][1] = dp_0s_edge[l]\n\nfor i in range(n):\n    for j in range(i + 1, min(n + 1, i + b)):\n        dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n    for j in range(i + 1, min(n + 1, i + a)):\n        dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n    for l in range(a + 2, b):\n        if i + l <= n:\n            dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n\n# ending with 0s whose len is gt or eq to a\nfor l in range(a + 1, b):\n    dp[n][0] = (dp[n][0] + dp[n - l][0] * dp_0s_edge[l]) % MOD\n\nprint((pow(2, n, MOD) - sum(dp[n])) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import math\n#import sys\n#input = sys.stdin.readline\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\ndef ValueToBits(x,digit):\n    res = [0 for i in range(digit)]\n    now = x\n    for i in range(digit):\n        res[i]=now%2\n        now = now >> 1\n    return res\n\ndef BitsToValue(arr):\n    n = len(arr)\n    ans = 0\n    for i in range(n):\n        ans+= arr[i] * 2**i\n    return ans\n\ndef ZipArray(a):\n    aa = [[a[i],i]for i in range(n)]\n\n    aa.sort(key = lambda x : x[0])\n    for i in range(n):\n        aa[i][0]=i+1\n    aa.sort(key = lambda x : x[1])\n    b=[aa[i][0] for i in range(len(a))]\n    return b\n\ndef ValueToArray10(x, digit):\n    ans = [0 for i in range(digit)]\n    now = x\n    for i in range(digit):\n        ans[digit-i-1] = now%10\n        now = now //10\n    return ans\n\ndef Zeros(a,b):\n    if(b<=-1):\n        return [0 for i in range(a)]\n    else:\n        return [[0 for i in range(b)] for i in range(a)]\n\ndef AddV2(v,w):\n    return [v[0]+w[0],v[1]+w[1]]\n\ndir4 = [[1,0],[0,1],[-1,0],[0,-1]]\n\n\ndef clamp(x,y,z):\n    return max(y,min(z,x))\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n \n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n            \n#\ndef Zaatsu(a):\n    a.sort()\n    now = a[0][0]\n    od = 0\n    for i in range(n):\n        if(now==a[i][0]):\n            a[i][0]=od\n        else:\n            now = a[i][0]\n            od+=1\n            a[i][0] = od\n    \n    a.sort(key = lambda x : x[1])\n    return a\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 併合\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか判定\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n'''\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 2\nN = 10 ** 6 + 2\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv 計算用\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\n'''\n\ndef rl(x):\n    return range(len(x))\n\n# a = list(map(int, input().split()))\n\n#################################################\n#################################################\n#################################################\n#################################################\n\n\n#11-\n\n\nn,aa,bb = list(map(int, input().split()))\n\na = max(aa,bb)\nb = min(aa,bb)\np = 1000000007\n\nxs0 = [0]*(n+1)\nos0 = [0]*(n+1)\n\nos0[0] = 1\n\nfor i in range(b,a-1):\n    for j in range(b,i+1):\n        xs0[i] += os0[i-j]\n        xs0[i] %= p\n    for j in range(1,i+1):\n        os0[i] += xs0[i-j]\n        os0[i] %= p\n\n#print(xs0[:50])\n#print(os0[:50])\n\nos = [0]*a\n\nfor i in range(b,a-2): #number-x\n    for j in range(2,a-i): # adding o\n        os[i+j] += xs0[i] * (j-1)\n\nx = [0]*(n+1)\no = [0]*(n+1)\n\nfor i in range(b+1,a-1): # adding distination\n    for j in range(b,i): # length of xs\n        o[i] += xs0[j]\n        o[i] %= p\n\nx[0] = 1\no[0] = 1\n\nfor i in range(1,n+1):\n    for j in range(1,min(b,i+1)):\n        x[i] += o[i-j]\n    for j in range(1,min(a,i+1)):\n        o[i] += x[i-j]\n    for j in range(b+2,min(a,i+1)):\n        o[i] += x[i-j]*os[j]\n    x[i] %= p\n    o[i] %= p\n\nfor i in range(b+1,a-1):\n    for j in range(b,i):\n        o[n] += xs0[j] * x[n-i]\n        o[i]%=p\n\nans = o[n] + x[n]\nans %= p\n\n#print(ans)\n\nbeki2 = [1]*5001\n\nfor i in range(5000):\n    beki2[i+1] = beki2[i]*2\n    beki2[i+1] %= p\n\nans = beki2[n] - ans\nans += p\nans %= p\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\nimpl From<usize> for ModInt {\n    fn from(val: usize) -> ModInt {\n        ModInt((val % MOD as usize) as u32)\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n\nuse proconio::*;\n\nfn run() {\n    input! {\n        n: usize,\n        mut a: usize,\n        mut b: usize,\n    }\n    if a > b {\n        std::mem::swap(&mut a, &mut b);\n    }\n    let (a, b) = (a, b);\n    let mut memo = vec![ModInt::zero(); b + 1];\n    memo[1] = ModInt::one();\n    for i in 1..b {\n        let v = memo[i];\n        memo[i + 1] += v;\n        for j in (a + 1).. {\n            if i + j > b {\n                break;\n            }\n            memo[i + j] += v;\n        }\n    }\n    let mut dp0 = vec![ModInt::zero(); 2 * n + 1];\n    let mut dp1 = vec![ModInt::zero(); 2 * n + 1];\n    for i in 1..a {\n        dp0[i] = ModInt::one();\n    }\n    for i in 1..b {\n        dp1[i] = memo[i + 1];\n    }\n    for i in 1..=n {\n        let v = dp0[i];\n        for j in 1..b {\n            dp1[i + j] += v * memo[j];\n        }\n        let v = dp1[i];\n        for j in 1..a {\n            dp0[i + j] += v;\n        }\n    }\n    let mut ans = ModInt(2).pow(n as u32) - (dp0[n] + dp1[n]);\n    for i in a..b {\n        for j in 1.. {\n            if i + j >= b {\n                break;\n            }\n            ans -= dp0[n - i - j] * memo[j];\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  }
]