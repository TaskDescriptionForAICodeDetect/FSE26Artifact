[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PLAYERS 100\n#define MAX_DAYS 1000\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int matches[MAX_PLAYERS][MAX_PLAYERS];\n    memset(matches, 0, sizeof(matches));\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        matches[a-1][b-1] = 1;\n        matches[b-1][a-1] = 1;\n    }\n\n    int days[MAX_DAYS][MAX_PLAYERS];\n    memset(days, 0, sizeof(days));\n    int day_count = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (matches[i][j]) {\n                bool scheduled = false;\n                for (int d = 0; d < day_count; d++) {\n                    if (days[d][i] == 0 && days[d][j] == 0) {\n                        days[d][i] = j + 1;\n                        days[d][j] = i + 1;\n                        scheduled = true;\n                        break;\n                    }\n                }\n\n                if (!scheduled) {\n                    days[day_count][i] = j + 1;\n                    days[day_count][j] = i + 1;\n                    day_count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", day_count > 0 ? day_count : -1);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int opponent;\n    int next;\n} PlayerSchedule;\n\ntypedef struct {\n    int player;\n    int day;\n} Match;\n\nPlayerSchedule schedule[MAX_N][MAX_N];\nint current_pos[MAX_N];\nint N;\n\nbool can_schedule(int max_days) {\n    int in_degree[MAX_N * MAX_D] = {0};\n    int queue[MAX_N * MAX_D];\n    int front = 0, rear = 0;\n    Match match_order[MAX_N * MAX_D];\n    int match_count = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N-1; ++j) {\n            int opponent = schedule[i][j].opponent;\n            schedule[i][j].next = j + 1;\n            if (j + 1 < N - 1) {\n                in_degree[i * max_days + (j + 1)]++;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (in_degree[i * max_days] == 0) {\n            queue[rear++] = i * max_days;\n        }\n    }\n\n    int days = 0;\n    while (front < rear) {\n        int current = queue[front++];\n        int player = current / max_days;\n        int pos = current % max_days;\n\n        if (pos >= N - 1) continue;\n\n        int opponent = schedule[player][pos].opponent;\n        int next_pos = schedule[player][pos].next;\n\n        match_order[match_count++] = (Match){player, days};\n\n        if (next_pos < N - 1) {\n            int next_node = player * max_days + next_pos;\n            in_degree[next_node]--;\n            if (in_degree[next_node] == 0) {\n                queue[rear++] = next_node;\n            }\n        }\n\n        int opponent_node = opponent * max_days + current_pos[opponent];\n        in_degree[opponent_node]--;\n        if (in_degree[opponent_node] == 0) {\n            queue[rear++] = opponent_node;\n        }\n\n        days++;\n    }\n\n    return match_count == N * (N - 1) / 2;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N - 1; ++j) {\n            scanf(\"%d\", &schedule[i][j].opponent);\n            schedule[i][j].opponent--; // converting to 0-based index\n        }\n        current_pos[i] = 0;\n    }\n\n    int left = 1, right = N * (N - 1) / 2;\n    int answer = -1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (can_schedule(mid)) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    printf(\"%d\\n\", answer);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Match {\n    int player;\n    int opponent_pos;\n};\n\nbool isPossible(int N, vector<vector<int>>& opponents) {\n    vector<int> in_degree(N, 0);\n    vector<vector<int>> adj(N);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 1; j < opponents[i].size(); ++j) {\n            int prev = opponents[i][j-1];\n            int curr = opponents[i][j];\n            adj[prev].push_back(curr);\n            in_degree[curr]++;\n        }\n    }\n\n    queue<int> q;\n    for (int i = 0; i < N; ++i) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    int cnt = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cnt++;\n        for (int v : adj[u]) {\n            if (--in_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    return cnt == N;\n}\n\nint findMinDays(int N, vector<vector<int>>& opponents) {\n    if (!isPossible(N, opponents)) {\n        return -1;\n    }\n\n    vector<int> last_day(N, 0);\n    vector<int> pos(N, 0);\n    int max_day = 0;\n\n    for (int day = 1; ; ++day) {\n        vector<bool> used(N, false);\n        bool scheduled = false;\n\n        for (int i = 0; i < N; ++i) {\n            if (pos[i] >= opponents[i].size()) continue;\n            int j = opponents[i][pos[i]];\n            if (!used[i] && !used[j] && pos[j] < opponents[j].size() && opponents[j][pos[j]] == i) {\n                used[i] = used[j] = true;\n                last_day[i] = last_day[j] = day;\n                pos[i]++;\n                pos[j]++;\n                scheduled = true;\n            }\n        }\n\n        if (!scheduled) {\n            bool all_done = true;\n            for (int i = 0; i < N; ++i) {\n                if (pos[i] < opponents[i].size()) {\n                    all_done = false;\n                    break;\n                }\n            }\n            if (all_done) break;\n        }\n\n        max_day = day;\n    }\n\n    return max_day;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> opponents(N);\n    for (int i = 0; i < N; ++i) {\n        int k;\n        cin >> k;\n        opponents[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> opponents[i][j];\n            opponents[i][j]--; // converting to 0-based index\n        }\n    }\n\n    cout << findMinDays(N, opponents) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TournamentScheduling {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<List<Integer>> opponents = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int k = scanner.nextInt();\n            List<Integer> list = new ArrayList<>();\n            for (int j = 0; j < k; j++) {\n                list.add(scanner.nextInt() - 1);\n            }\n            opponents.add(list);\n        }\n\n        int[][] matchOrder = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < opponents.get(i).size(); j++) {\n                int opponent = opponents.get(i).get(j);\n                matchOrder[i][opponent] = j + 1;\n            }\n        }\n\n        int[] ptr = new int[N];\n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 0; i < N; i++) {\n            if (ptr[i] < opponents.get(i).size()) {\n                int j = opponents.get(i).get(ptr[i]);\n                if (opponents.get(j).get(ptr[j]) == i) {\n                    queue.add(new int[]{i, j});\n                }\n            }\n        }\n\n        int days = 0;\n        int matchesScheduled = 0;\n        while (!queue.isEmpty()) {\n            days++;\n            Set<Integer> used = new HashSet<>();\n            int size = queue.size();\n            for (int s = 0; s < size; s++) {\n                int[] match = queue.poll();\n                int i = match[0], j = match[1];\n                if (used.contains(i) || used.contains(j)) {\n                    queue.add(match);\n                    continue;\n                }\n                used.add(i);\n                used.add(j);\n                ptr[i]++;\n                ptr[j]++;\n                matchesScheduled++;\n                if (ptr[i] < opponents.get(i).size()) {\n                    int nextOpp = opponents.get(i).get(ptr[i]);\n                    if (opponents.get(nextOpp).get(ptr[nextOpp]) == i) {\n                        queue.add(new int[]{i, nextOpp});\n                    }\n                }\n                if (ptr[j] < opponents.get(j).size()) {\n                    int nextOpp = opponents.get(j).get(ptr[j]);\n                    if (opponents.get(nextOpp).get(ptr[nextOpp]) == j) {\n                        queue.add(new int[]{j, nextOpp});\n                    }\n                }\n            }\n            if (used.isEmpty()) {\n                System.out.println(-1);\n                return;\n            }\n        }\n\n        if (matchesScheduled == N * (N - 1) / 2) {\n            System.out.println(days);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:44:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TennisTournamentScheduler {\n    public static int minimumDays(int N, List<List<Integer>> matchOrder) {\n        // Create adjacency list to track match requirements\n        List<Set<Integer>> graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new HashSet<>());\n        }\n\n        // Build graph of required matches\n        for (int player = 0; player < N; player++) {\n            for (int opponent : matchOrder.get(player)) {\n                if (opponent > player) {\n                    graph.get(player).add(opponent);\n                    graph.get(opponent).add(player);\n                }\n            }\n        }\n\n        // Track matches for each day and player availability\n        int[] dayForMatch = new int[N * (N - 1) / 2];\n        Arrays.fill(dayForMatch, -1);\n        boolean[] playerDayUsed = new boolean[N];\n\n        int currentDay = 0;\n        for (int player = 0; player < N; player++) {\n            for (int opponent : matchOrder.get(player)) {\n                if (opponent > player) {\n                    int matchId = getMatchId(player, opponent, N);\n                    if (dayForMatch[matchId] != -1) continue;\n\n                    // Find a day where both players are available\n                    boolean matchScheduled = false;\n                    for (int day = 0; day <= currentDay; day++) {\n                        if (!playerDayUsed[player] && !playerDayUsed[opponent]) {\n                            dayForMatch[matchId] = day;\n                            playerDayUsed[player] = true;\n                            playerDayUsed[opponent] = true;\n                            matchScheduled = true;\n                            break;\n                        }\n                        // Reset player availability for next iteration\n                        playerDayUsed[player] = false;\n                        playerDayUsed[opponent] = false;\n                    }\n\n                    // If no day found, move to next day\n                    if (!matchScheduled) {\n                        currentDay++;\n                        dayForMatch[matchId] = currentDay;\n                        playerDayUsed[player] = true;\n                        playerDayUsed[opponent] = true;\n                    }\n                }\n            }\n            // Reset player availability after processing each player\n            playerDayUsed[player] = false;\n        }\n\n        // Check if all matches are scheduled\n        for (int matchDay : dayForMatch) {\n            if (matchDay == -1) return -1;\n        }\n\n        return currentDay + 1;\n    }\n\n    private static int getMatchId(int p1, int p2, int N) {\n        if (p1 > p2) {\n            int temp = p1;\n            p1 = p2;\n            p2 = temp;\n        }\n        return (p1 * (2 * N - p1 - 3) / 2) + (p2 - p1 - 1);\n    }\n}",
    "timestamp": "2025-08-05 22:44:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<int>> opponents(N);\n    for (int i = 0; i < N; i++) {\n        int K;\n        cin >> K;\n        opponents[i].resize(K);\n        for (int j = 0; j < K; j++) {\n            cin >> opponents[i][j];\n            opponents[i][j]--;\n        }\n    }\n    \n    vector<vector<bool>> played(N, vector<bool>(N, false));\n    vector<int> days(N, 0);\n    int max_day = 0;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j : opponents[i]) {\n            if (i >= j) continue;\n            \n            if (played[i][j]) continue;\n            \n            int day = max(days[i], days[j]) + 1;\n            \n            while (true) {\n                bool conflict = false;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    \n                    if ((days[k] == day && (k == i || k == j)) ||\n                        (days[k] == day && played[k][i]) ||\n                        (days[k] == day && played[k][j])) {\n                        conflict = true;\n                        day++;\n                        break;\n                    }\n                }\n                \n                if (!conflict) break;\n            }\n            \n            days[i] = day;\n            days[j] = day;\n            played[i][j] = true;\n            played[j][i] = true;\n            \n            max_day = max(max_day, day);\n        }\n    }\n    \n    bool all_matches_played = true;\n    for (int i = 0; i < N; i++) {\n        for (int j : opponents[i]) {\n            if (i >= j) continue;\n            if (!played[i][j]) {\n                all_matches_played = false;\n                break;\n            }\n        }\n        if (!all_matches_played) break;\n    }\n    \n    if (all_matches_played) {\n        cout << max_day << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_days_schedule(N, opponents):\n    from collections import deque\n\n    # Check if number of opponents and N matches the requirement\n    if any(len(opponents[i]) != N - 1 for i in range(N)):\n        return -1\n\n    # Create match schedule queue for each player\n    schedule_queues = [deque(opps) for opps in opponents]\n\n    # Visited grid to check if a match has already been scheduled\n    completed_matches = [[False] * N for _ in range(N)]\n\n    days = 0\n    total_matches = N * (N - 1) // 2\n    scheduled_matches = 0\n\n    while scheduled_matches < total_matches:\n        # Initialize daily matches\n        today_matches = set()\n        matched = [False] * N\n\n        for i in range(N):\n            if matched[i] or not schedule_queues[i]:\n                continue\n            opponent = schedule_queues[i][0]\n            if matched[opponent] or completed_matches[i][opponent]:\n                continue\n\n            # If both players are available and match isn't played\n            if not matched[opponent] and not completed_matches[i][opponent]:\n                matched[i] = matched[opponent] = True\n                today_matches.add((i, opponent))\n        \n        # If no matches can take place today\n        if not today_matches:\n            return -1\n\n        # Schedule matches for today and update status\n        for i, j in today_matches:\n            completed_matches[i][j] = completed_matches[j][i] = True\n            schedule_queues[i].popleft()\n            schedule_queues[j].popleft()\n            scheduled_matches += 1\n\n        days += 1\n\n    return days\n\n# Example usage:\nN = 4\nopponents = [\n    [1, 2, 3],\n    [0, 2, 3],\n    [0, 1, 3],\n    [0, 1, 2]\n]\n\nprint(minimum_days_schedule(N, opponents)) # Output the minimum days or -1 if not possible",
    "timestamp": "2025-08-13 12:18:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TennisTournament {\n\n    public static int minimumDays(int N, List<List<Integer>> opponents) {\n        // Find the maximum matches to be played by any player\n        int maxMatches = 0;\n        for (List<Integer> playerOpponents : opponents) {\n            maxMatches = Math.max(maxMatches, playerOpponents.size());\n        }\n\n        // Simulate the scheduling process\n        Set<String> scheduledMatches = new HashSet<>();\n        int[][] daysPlayed = new int[N][N];\n\n        for (int day = 0; day < maxMatches; day++) {\n            for (int i = 0; i < N; i++) {\n                if (day < opponents.get(i).size()) {\n                    int opponent = opponents.get(i).get(day);\n                    if (opponent < 0 || opponent >= N || i == opponent) {\n                        return -1; // Invalid opponent\n                    }\n                    String match1 = i + \"-\" + opponent;\n                    String match2 = opponent + \"-\" + i;\n                    \n                    // Check if this match or inverse already scheduled on this day\n                    if (daysPlayed[i][day] == 1 || daysPlayed[opponent][day] == 1\n                            || scheduledMatches.contains(match1) || scheduledMatches.contains(match2)) {\n                        return -1;\n                    }\n                    \n                    daysPlayed[i][day] = 1;\n                    daysPlayed[opponent][day] = 1;\n                    scheduledMatches.add(match1);\n                }\n            }\n        }\n\n        return maxMatches;\n    }\n\n    public static void main(String[] args) {\n        // Examples of how to call the function\n        int N = 4;\n        List<List<Integer>> opponents = Arrays.asList(\n            Arrays.asList(1, 2, 3), // Player 0 matches\n            Arrays.asList(0, 2, 3), // Player 1 matches\n            Arrays.asList(0, 1, 3), // Player 2 matches\n            Arrays.asList(0, 1, 2)  // Player 3 matches\n        );\n        System.out.println(minimumDays(N, opponents)); // Should output 3\n\n        N = 3; // Another test case\n        opponents = Arrays.asList(\n            Arrays.asList(1, 2), // Player 0 matches\n            Arrays.asList(0, 2), // Player 1 matches\n            Arrays.asList(0, 1)  // Player 2 matches\n        );\n        System.out.println(minimumDays(N, opponents)); // Should output 2\n    }\n}",
    "timestamp": "2025-08-13 12:18:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int opponents[MAX_N - 1];\n    int opponent_count;\n} Player;\n\nbool is_scheduling_possible(int N, Player players[]) {\n    int total_matches = 0;\n    for (int i = 0; i < N; i++) {\n        total_matches += players[i].opponent_count;\n    }\n    \n    if (total_matches != N * (N - 1)) {\n        return false;\n    }\n    \n    int next_match[MAX_N] = {0};\n    int days_needed = 0;\n    \n    while (total_matches > 0) {\n        bool played_today[MAX_N] = {false};\n        int matches_today = 0;\n        \n        for (int i = 0; i < N; i++) {\n            if (!played_today[i] && next_match[i] < players[i].opponent_count) {\n                int opponent = players[i].opponents[next_match[i]];\n                if (!played_today[opponent]) {\n                    played_today[i] = true;\n                    played_today[opponent] = true;\n                    next_match[i]++;\n                    next_match[opponent]++;\n                    matches_today++;\n                }\n            }\n        }\n        \n        if (matches_today == 0) {\n            return false;\n        }\n        \n        total_matches -= matches_today;\n        days_needed++;\n    }\n    \n    return days_needed;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Player players[MAX_N];\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &players[i].opponent_count);\n        for (int j = 0; j < players[i].opponent_count; j++) {\n            scanf(\"%d\", &players[i].opponents[j]);\n        }\n    }\n    \n    int days = is_scheduling_possible(N, players);\n    \n    printf(\"%d\\n\", days);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:18:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nbool isSchedulingPossible(vector<vector<int>>& order, int N) {\n    vector<int> inDegree(N, 0);\n    vector<vector<int>> adj(N);\n    \n    for (int player = 0; player < N; ++player) {\n        for (int i = 0; i < order[player].size() - 1; ++i) {\n            adj[order[player][i]].push_back(order[player][i+1]);\n            inDegree[order[player][i+1]]++;\n        }\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < N; ++i) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    int count = 0;\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        count++;\n        \n        for (int next : adj[p]) {\n            if (--inDegree[next] == 0) {\n                q.push(next);\n            }\n        }\n    }\n    \n    return count == N;\n}\n\nint minDaysScheduleTournament(vector<vector<int>>& order, int N) {\n    if (!isSchedulingPossible(order, N)) return -1;\n\n    vector<int> dp(N, 0);\n    vector<vector<int>> adj(N);\n    \n    for (int player = 0; player < N; ++player) {\n        for (int i = 0; i < order[player].size() - 1; ++i) {\n            adj[order[player][i]].push_back(order[player][i+1]);\n        }\n    }\n    \n    queue<int> q;\n    vector<int> inDegree(N, 0);\n    for (int i = 0; i < N; ++i) {\n        for (int j : adj[i]) {\n            inDegree[j]++;\n        }\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n            dp[i] = 1;\n        }\n    }\n    \n    int maxDays = 0;\n    while (!q.empty()) {\n        int p = q.front();\n        q.pop();\n        \n        maxDays = max(maxDays, dp[p]);\n        \n        for (int next : adj[p]) {\n            if (--inDegree[next] == 0) {\n                q.push(next);\n            }\n            dp[next] = max(dp[next], dp[p] + 1);\n        }\n    }\n    \n    return *max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<int>> order(N);\n    for (int i = 0; i < N; ++i) {\n        int m;\n        cin >> m;\n        order[i] = vector<int>(m);\n        for (int j = 0; j < m; ++j) {\n            cin >> order[i][j];\n            order[i][j]--;  // Make player indices zero-based\n        }\n    }\n    \n    cout << minDaysScheduleTournament(order, N) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:19:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def tournament_scheduling(N, opponents):\n    # Create adjacency list of matches\n    matches = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(len(opponents[i])):\n            opponent = opponents[i][j]\n            if opponent > i:\n                matches[i].append(opponent)\n                matches[opponent].append(i)\n    \n    # Create degree list\n    degree = [len(matches[i]) for i in range(N)]\n    \n    # Track days for each match\n    match_days = {}\n    player_days = [set() for _ in range(N)]\n    \n    # Try to schedule matches\n    for i in range(N):\n        for opponent in matches[i]:\n            if opponent < i:\n                continue\n            \n            # Find first available day for both players\n            day = 0\n            while day in player_days[i] or day in player_days[opponent]:\n                day += 1\n            \n            match_days[(i, opponent)] = day\n            player_days[i].add(day)\n            player_days[opponent].add(day)\n    \n    # Return max day (+1 since days start from 0)\n    return max(max(days) for days in player_days) + 1 if matches else 0",
    "timestamp": "2025-08-13 12:19:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N)]\n    in_degree = [0] * N\n    opponents = []\n    for i in range(N):\n        parts = list(map(int, sys.stdin.readline().split()))\n        opponents.append([x - 1 for x in parts])\n    \n    # Create adjacency list and in_degree\n    node_map = {}\n    current_id = 0\n    for i in range(N):\n        for j in range(N - 1):\n            a, b = i, opponents[i][j]\n            if a > b:\n                a, b = b, a\n            if (a, b) not in node_map:\n                node_map[(a, b)] = current_id\n                current_id += 1\n    \n    total_nodes = len(node_map)\n    adj = [[] for _ in range(total_nodes)]\n    in_degree = [0] * total_nodes\n    \n    for i in range(N):\n        for j in range(N - 2):\n            a, b = i, opponents[i][j]\n            if a > b:\n                a, b = b, a\n            u = node_map[(a, b)]\n            \n            c, d = i, opponents[i][j + 1]\n            if c > d:\n                c, d = d, c\n            v = node_map[(c, d)]\n            \n            adj[u].append(v)\n            in_degree[v] += 1\n    \n    # Topological sort with BFS (Kahn's algorithm)\n    q = deque()\n    max_day = [1] * total_nodes\n    for u in range(total_nodes):\n        if in_degree[u] == 0:\n            q.append(u)\n    \n    processed = 0\n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            if max_day[v] < max_day[u] + 1:\n                max_day[v] = max_day[u] + 1\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                q.append(v)\n    \n    if processed != total_nodes:\n        print(-1)\n    else:\n        print(max(max_day))\n\nsolve()",
    "timestamp": "2025-08-13 12:19:28"
  }
]