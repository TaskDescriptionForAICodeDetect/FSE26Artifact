[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nint H, W;\nchar old_flag[MAX_H][MAX_W + 1];\nchar emblem[2][3];\n\nint count_emblem(int i, int j) {\n    int count = 0;\n    if (i + 1 < H && j + 2 < W) {\n        if (old_flag[i][j] == emblem[0][0] && old_flag[i][j+1] == emblem[0][1] && old_flag[i][j+2] == emblem[0][2] &&\n            old_flag[i+1][j] == emblem[1][0] && old_flag[i+1][j+1] == emblem[1][1] && old_flag[i+1][j+2] == emblem[1][2]) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", old_flag[i]);\n    }\n    scanf(\"%s\", emblem[0]);\n    scanf(\"%s\", emblem[1]);\n\n    int max_emblems = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            char original = old_flag[i][j];\n            for (char c = 'J'; c <= 'I'; c++) {\n                if (c == 'K') c = 'O';\n                old_flag[i][j] = c;\n                int current_emblems = 0;\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        current_emblems += count_emblem(k, l);\n                    }\n                }\n                if (current_emblems > max_emblems) {\n                    max_emblems = current_emblems;\n                }\n            }\n            old_flag[i][j] = original;\n        }\n    }\n\n    printf(\"%d\\n\", max_emblems);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class JOIEmblem {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] input = br.readLine().split(\" \");\n        int H = Integer.parseInt(input[0]);\n        int W = Integer.parseInt(input[1]);\n        \n        char[][] flag = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            flag[i] = br.readLine().toCharArray();\n        }\n        \n        int maxEmblems = countEmblems(flag);\n        \n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                if (flag[r][c] != '.') continue;\n                \n                char[] chars = {'J', 'O', 'I'};\n                for (char ch : chars) {\n                    flag[r][c] = ch;\n                    maxEmblems = Math.max(maxEmblems, countEmblems(flag));\n                    flag[r][c] = '.';\n                }\n            }\n        }\n        \n        System.out.println(maxEmblems);\n    }\n    \n    static int countEmblems(char[][] flag) {\n        int H = flag.length;\n        int W = flag[0].length;\n        int count = 0;\n        \n        for (int r = 0; r < H - 2; r++) {\n            for (int c = 0; c < W - 2; c++) {\n                if (flag[r][c] == 'J' && \n                    flag[r][c+1] == 'O' && \n                    flag[r+1][c+1] == 'I' && \n                    flag[r+2][c+1] == 'I') {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-05 18:50:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint countJOI(const vector<string>& flag, int H, int W) {\n    int cnt = 0;\n    for (int i = 0; i < H - 1; ++i) {\n        for (int j = 0; j < W - 1; ++j) {\n            string s;\n            s += flag[i][j];\n            s += flag[i][j+1];\n            s += flag[i+1][j];\n            s += flag[i+1][j+1];\n            if (s.find('J') != string::npos && s.find('O') != string::npos && s.find('I') != string::npos) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> flag(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> flag[i];\n    }\n\n    int maxJOI = countJOI(flag, H, W);\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char original = flag[i][j];\n            for (char c : {'J', 'O', 'I'}) {\n                if (c == original) continue;\n                flag[i][j] = c;\n                maxJOI = max(maxJOI, countJOI(flag, H, W));\n                flag[i][j] = original;\n            }\n        }\n    }\n\n    cout << maxJOI << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint count_emblems(char* flag) {\n    int count = 0;\n    for (int i = 0; i <= strlen(flag) - 3; i++) {\n        if (flag[i] == 'J' && flag[i+1] == 'O' && flag[i+2] == 'I') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    char flag[101];\n    scanf(\"%s\", flag);\n    int max_emblems = count_emblems(flag);\n\n    for (int i = 0; i < strlen(flag); i++) {\n        char original = flag[i];\n        char replacements[] = {'J', 'O', 'I'};\n\n        for (int j = 0; j < 3; j++) {\n            flag[i] = replacements[j];\n            int current_emblems = count_emblems(flag);\n            max_emblems = (current_emblems > max_emblems) ? current_emblems : max_emblems;\n        }\n\n        flag[i] = original;\n    }\n\n    printf(\"%d\\n\", max_emblems);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint countJOIEmblems(const vector<string>& flag) {\n    int count = 0;\n    int rows = flag.size();\n    int cols = flag[0].length();\n    \n    for (int i = 0; i < rows - 2; i++) {\n        for (int j = 0; j < cols - 2; j++) {\n            if (flag[i][j] == 'J' && flag[i+1][j+1] == 'O' && flag[i+2][j+2] == 'I') {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n\nint maxJOIEmblems(vector<string>& flag) {\n    int rows = flag.size();\n    int cols = flag[0].length();\n    int maxEmblems = countJOIEmblems(flag);\n    \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            char originalChar = flag[r][c];\n            \n            for (char newChar : {'J', 'O', 'I'}) {\n                flag[r][c] = newChar;\n                maxEmblems = max(maxEmblems, countJOIEmblems(flag));\n            }\n            \n            flag[r][c] = originalChar;\n        }\n    }\n    \n    return maxEmblems;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<string> flag(H);\n    for (int i = 0; i < H; i++) {\n        cin >> flag[i];\n    }\n    \n    cout << maxJOIEmblems(flag) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        scanner.nextLine(); // consume the remaining newline\n        \n        char[][] oldFlag = new char[N][M];\n        for (int i = 0; i < N; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < M; j++) {\n                oldFlag[i][j] = line.charAt(j);\n            }\n        }\n        \n        char[][] emblem = new char[2][2];\n        emblem[0][0] = 'J';\n        emblem[0][1] = 'O';\n        emblem[1][0] = 'I';\n        emblem[1][1] = 'J';\n        \n        int maxCount = 0;\n        \n        for (int i = 0; i <= N - 2; i++) {\n            for (int j = 0; j <= M - 2; j++) {\n                int originalCount = countEmblems(oldFlag, i, j, emblem);\n                int tempMax = originalCount;\n                \n                char original = oldFlag[i][j];\n                for (char c : new char[]{'J', 'O', 'I'}) {\n                    if (c != original) {\n                        oldFlag[i][j] = c;\n                        int currentCount = countEmblems(oldFlag, i, j, emblem);\n                        if (currentCount > tempMax) {\n                            tempMax = currentCount;\n                        }\n                    }\n                }\n                oldFlag[i][j] = original;\n                \n                original = oldFlag[i][j+1];\n                for (char c : new char[]{'J', 'O', 'I'}) {\n                    if (c != original) {\n                        oldFlag[i][j+1] = c;\n                        int currentCount = countEmblems(oldFlag, i, j, emblem);\n                        if (currentCount > tempMax) {\n                            tempMax = currentCount;\n                        }\n                    }\n                }\n                oldFlag[i][j+1] = original;\n                \n                original = oldFlag[i+1][j];\n                for (char c : new char[]{'J', 'O', 'I'}) {\n                    if (c != original) {\n                        oldFlag[i+1][j] = c;\n                        int currentCount = countEmblems(oldFlag, i, j, emblem);\n                        if (currentCount > tempMax) {\n                            tempMax = currentCount;\n                        }\n                    }\n                }\n                oldFlag[i+1][j] = original;\n                \n                original = oldFlag[i+1][j+1];\n                for (char c : new char[]{'J', 'O', 'I'}) {\n                    if (c != original) {\n                        oldFlag[i+1][j+1] = c;\n                        int currentCount = countEmblems(oldFlag, i, j, emblem);\n                        if (currentCount > tempMax) {\n                            tempMax = currentCount;\n                        }\n                    }\n                }\n                oldFlag[i+1][j+1] = original;\n                \n                if (tempMax > maxCount) {\n                    maxCount = tempMax;\n                }\n            }\n        }\n        \n        System.out.println(maxCount);\n    }\n    \n    private static int countEmblems(char[][] flag, int row, int col, char[][] emblem) {\n        int count = 0;\n        for (int i = 0; i <= flag.length - 2; i++) {\n            for (int j = 0; j <= flag[0].length - 2; j++) {\n                if (flag[i][j] == emblem[0][0] && flag[i][j+1] == emblem[0][1] &&\n                    flag[i+1][j] == emblem[1][0] && flag[i+1][j+1] == emblem[1][1]) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 18:52:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_emblems(flag, emblem):\n    rows, cols = len(flag), len(flag[0])\n    emblem_rows, emblem_cols = len(emblem), len(emblem[0])\n    max_emblems = 0\n\n    for i in range(rows - emblem_rows + 1):\n        for j in range(cols - emblem_cols + 1):\n            # Count current emblem matches\n            curr_emblems = 0\n            for x in range(emblem_rows):\n                for y in range(emblem_cols):\n                    if flag[i + x][j + y] == emblem[x][y]:\n                        curr_emblems += 1\n            if curr_emblems == emblem_rows * emblem_cols:\n                max_emblems += 1\n\n    return max_emblems\n\ndef maximize_emblems(old_flag, emblem):\n    rows, cols = len(old_flag), len(old_flag[0])\n    blank_flag = [list(row) for row in old_flag]\n    max_emblems = count_emblems(blank_flag, emblem)\n\n    for i in range(rows):\n        for j in range(cols):\n            original_value = old_flag[i][j]\n\n            for char in 'JOI':\n                blank_flag[i][j] = char\n                max_emblems = max(max_emblems, count_emblems(blank_flag, emblem))\n\n            blank_flag[i][j] = original_value\n\n    return max_emblems\n\n# Example usage:\nold_flag = [\n    'JOIOJIO',\n    'OJIOIJO',\n    'JIOJIOJ',\n    'IOJOIJO',\n    'OJIOJOI'\n]\n\nemblem = [\n    'JOI',\n    'OJI',\n    'IOJ'\n]\n\nprint(maximize_emblems(old_flag, emblem))",
    "timestamp": "2025-08-13 01:11:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class JOIFlagMaximization {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // Number of rows\n        int m = scanner.nextInt(); // Number of columns\n        int t = scanner.nextInt(); // Number of rows in the JOI emblem\n        int k = scanner.nextInt(); // Number of columns in the JOI emblem\n\n        char[][] oldFlag = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            oldFlag[i] = scanner.next().toCharArray();\n        }\n\n        char[][] joiEmblem = new char[t][k];\n        for (int i = 0; i < t; i++) {\n            joiEmblem[i] = scanner.next().toCharArray();\n        }\n\n        int maxEmblems = 0;\n        \n        for (int i = 0; i <= n - t; i++) {\n            for (int j = 0; j <= m - k; j++) {\n\n                int emblemsCount = countEmblems(oldFlag, joiEmblem, i, j);\n\n                for (int x = 0; x < t; x++) {\n                    for (int y = 0; y < k; y++) {\n                        if (oldFlag[i + x][j + y] != joiEmblem[x][y]) {\n                            char originalChar = oldFlag[i + x][j + y];\n                            oldFlag[i + x][j + y] = joiEmblem[x][y];\n                            \n                            emblemsCount = Math.max(emblemsCount, countEmblems(oldFlag, joiEmblem, i, j));\n                            \n                            oldFlag[i + x][j + y] = originalChar;\n                        }\n                    }\n                }\n                \n                maxEmblems = Math.max(maxEmblems, emblemsCount);\n            }\n        }\n        \n        System.out.println(maxEmblems);\n    }\n\n    public static int countEmblems(char[][] oldFlag, char[][] emblem, int startX, int startY) {\n        int emblemsCount = 0;\n        for (int i = startX; i <= oldFlag.length - emblem.length; i++) {\n            for (int j = startY; j <= oldFlag[0].length - emblem[0].length; j++) {\n                boolean match = true;\n                for (int x = 0; x < emblem.length && match; x++) {\n                    for (int y = 0; y < emblem[0].length; y++) {\n                        if (oldFlag[i + x][j + y] != emblem[x][y]) {\n                            match = false;\n                            break;\n                        }\n                    }\n                }\n                if (match) {\n                    emblemsCount++;\n                }\n            }\n        }\n        return emblemsCount;\n    }\n}",
    "timestamp": "2025-08-13 01:11:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint maxJOIEmblems(char oldFlag[1001][1001], char emblem[4][4], int n, int m) {\n    int maxCount = 0;\n    int emblemSize = 3;\n    for (int i = 0; i <= n - emblemSize; i++) {\n        for (int j = 0; j <= m - emblemSize; j++) {\n            int currentCount = 0;\n            int possibleChangeCount = 0;\n            for (int x = 0; x < emblemSize; x++) {\n                for (int y = 0; y < emblemSize; y++) {\n                    if (oldFlag[i + x][j + y] == emblem[x][y]) {\n                        currentCount++;\n                    }\n                }\n            }\n            maxCount = currentCount == 9 ? maxCount + 1 : maxCount;\n            for (int u = 0; u < emblemSize; u++) {\n                for (int v = 0; v < emblemSize; v++) {\n                    if (oldFlag[i + u][j + v] != emblem[u][v]) {\n                        if (currentCount + 1 > 9) {\n                            possibleChangeCount = 1;\n                            break;\n                        }\n                    }\n                }\n            }\n            maxCount += possibleChangeCount;\n        }\n    }\n    return maxCount;\n}\n\nint main() {\n    int n, m;\n    char oldFlag[1001][1001];\n    char emblem[4][4] = {{'J', 'O', 'I'}, {'O', 'I', 'J'}, {'I', 'J', 'O'}};\n    \n    // Initialize the oldFlag array and input its dimensions - n, m.\n\n    // Call the function to calculate the maximum number of JOI emblems\n    printf(\"%d\", maxJOIEmblems(oldFlag, emblem, n, m));\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:11:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_joi_emblems(old_flag):\n    rows, cols = len(old_flag), len(old_flag[0])\n    max_emblems = count_joi_emblems(old_flag)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if old_flag[r][c] != 'J':\n                new_flag = [list(row) for row in old_flag]\n                new_flag[r][c] = 'J'\n                max_emblems = max(max_emblems, count_joi_emblems(new_flag))\n            \n            if old_flag[r][c] != 'O':\n                new_flag = [list(row) for row in old_flag]\n                new_flag[r][c] = 'O'\n                max_emblems = max(max_emblems, count_joi_emblems(new_flag))\n            \n            if old_flag[r][c] != 'I':\n                new_flag = [list(row) for row in old_flag]\n                new_flag[r][c] = 'I'\n                max_emblems = max(max_emblems, count_joi_emblems(new_flag))\n    \n    return max_emblems\n\ndef count_joi_emblems(flag):\n    rows, cols = len(flag), len(flag[0])\n    emblem_count = 0\n    \n    for r in range(rows):\n        for c in range(cols-2):\n            if (flag[r][c] == 'J' and \n                flag[r][c+1] == 'O' and \n                flag[r][c+2] == 'I'):\n                emblem_count += 1\n    \n    return emblem_count",
    "timestamp": "2025-08-13 01:11:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N = int(sys.stdin.readline())\n    M = 3\n    old_flag = [sys.stdin.readline().strip() for _ in range(N)]\n    emblem = [sys.stdin.readline().strip() for _ in range(M)]\n    \n    max_count = 0\n    \n    # Precompute all possible positions for the emblem in the old flag\n    for i in range(N - M + 1):\n        for j in range(N - M + 1):\n            # Count matches without any changes\n            count = 0\n            changes = []\n            for di in range(M):\n                for dj in range(M):\n                    old_char = old_flag[i + di][j + dj]\n                    em_char = emblem[di][dj]\n                    if old_char == em_char:\n                        count += 1\n                    else:\n                        changes.append((i + di, j + dj, em_char))\n            # If no changes needed, count as is\n            if count == 9:\n                max_count = max(max_count, 1)\n                continue\n            # Try changing each possible mismatch to see if it can make a new emblem\n            # Since we can change only one square, we can potentially create multiple emblems\n            # So we need to check how many emblems can be formed by changing one square\n            # But the problem allows changing one square in the old flag to affect multiple emblems\n            # So the approach is to count for each possible change, how many emblems it can fix\n            # Then choose the change that fixes the most emblems\n            # So we need to track for each cell (x, y), what changing it to J, O, or I can do\n            \n    # To optimize, we can track for each cell (x, y), how many emblems would be satisfied if we change it to J, O, or I\n    # Initialize a 3D array: count[x][y][c] where c is 0 (J), 1 (O), 2 (I)\n    count_map = [[[0 for _ in range(3)] for __ in range(N)] for ___ in range(N)]\n    \n    for i in range(N - M + 1):\n        for j in range(N - M + 1):\n            required = []\n            mismatches = []\n            for di in range(M):\n                for dj in range(M):\n                    old_char = old_flag[i + di][j + dj]\n                    em_char = emblem[di][dj]\n                    if old_char != em_char:\n                        mismatches.append((i + di, j + dj, em_char))\n            # For each mismatch in this emblem, changing that cell to the emblem's char would fix this emblem\n            for x, y, c in mismatches:\n                if c == 'J':\n                    idx = 0\n                elif c == 'O':\n                    idx = 1\n                else:\n                    idx = 2\n                count_map[x][y][idx] += 1\n    \n    # Now find the cell and change that gives the maximum additional emblems\n    max_increase = 0\n    base_count = 0\n    \n    # First, count the number of emblems already present without any changes\n    for i in range(N - M + 1):\n        for j in range(N - M + 1):\n            match = True\n            for di in range(M):\n                for dj in range(M):\n                    if old_flag[i + di][j + dj] != emblem[di][dj]:\n                        match = False\n                        break\n                if not match:\n                    break\n            if match:\n                base_count += 1\n    \n    for x in range(N):\n        for y in range(N):\n            for c in range(3):\n                if count_map[x][y][c] > max_increase:\n                    max_increase = count_map[x][y][c]\n    \n    max_count = base_count + max_increase\n    print(max_count)\n\nsolve()",
    "timestamp": "2025-08-13 01:12:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint countEmblems(const vector<string>& flag, int r0, int c0, int r1, int c1, const vector<string>& emblem) {\n    int emblemCount = 0;\n    int er = emblem.size();\n    int ec = emblem[0].size();\n    \n    for (int i = r0; i <= r1 - er + 1; ++i) {\n        for (int j = c0; j <= c1 - ec + 1; ++j) {\n            bool match = true;\n            for (int p = 0; p < er && match; ++p) {\n                for (int q = 0; q < ec && match; ++q) {\n                    if (flag[i+p][j+q] != emblem[p][q]) {\n                        match = false;\n                    }\n                }\n            }\n            if (match) {\n                ++emblemCount;\n            }\n        }\n    }\n    return emblemCount;\n}\n\nint main() {\n    int R, C, ER, EC;\n    cin >> R >> C;\n    \n    vector<string> oldFlag(R);\n    for (int i = 0; i < R; ++i) {\n        cin >> oldFlag[i];\n    }\n    \n    cin >> ER >> EC;\n    \n    vector<string> emblem(ER);\n    for (int i = 0; i < ER; ++i) {\n        cin >> emblem[i];\n    }\n    \n    int maxEmblems = countEmblems(oldFlag, 0, 0, R-1, C-1, emblem);\n\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            char original = oldFlag[i][j];\n            for (char ch : {'J', 'O', 'I'}) {\n                if (oldFlag[i][j] != ch) {\n                    oldFlag[i][j] = ch;\n                    maxEmblems = max(maxEmblems, countEmblems(oldFlag, max(0, i-ER+1), max(0, j-EC+1), min(R-1, i+ER-1), min(C-1, j+EC-1), emblem));\n                }\n            }\n            oldFlag[i][j] = original;\n        }\n    }\n    \n    cout << maxEmblems << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:58:49"
  }
]