[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LINES 1000\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Segment;\n\nSegment segments[MAX_LINES];\nint grid[MAX_SIZE][MAX_SIZE] = {0};\nint max_x = 0, max_y = 0;\n\nvoid read_segments() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &segments[i].x1, &segments[i].y1, &segments[i].x2, &segments[i].y2);\n        if (segments[i].x1 > max_x) max_x = segments[i].x1;\n        if (segments[i].x2 > max_x) max_x = segments[i].x2;\n        if (segments[i].y1 > max_y) max_y = segments[i].y1;\n        if (segments[i].y2 > max_y) max_y = segments[i].y2;\n    }\n}\n\nvoid fill_grid() {\n    for (int i = 0; i < MAX_LINES; i++) {\n        int x1 = segments[i].x1, y1 = segments[i].y1;\n        int x2 = segments[i].x2, y2 = segments[i].y2;\n        if (x1 == x2) {\n            int start = y1 < y2 ? y1 : y2;\n            int end = y1 < y2 ? y2 : y1;\n            for (int y = start; y <= end; y++) {\n                grid[x1][y] = 1;\n            }\n        } else if (y1 == y2) {\n            int start = x1 < x2 ? x1 : x2;\n            int end = x1 < x2 ? x2 : x1;\n            for (int x = start; x <= end; x++) {\n                grid[x][y1] = 1;\n            }\n        }\n    }\n}\n\nchar recognize_char(int x, int y) {\n    if (grid[x][y] && grid[x][y+1] && grid[x][y+2] && grid[x+1][y] && grid[x+1][y+2] && grid[x+2][y] && grid[x+2][y+1] && grid[x+2][y+2]) return '0';\n    if (grid[x][y+1] && grid[x+1][y] && grid[x+1][y+1] && grid[x+2][y] && grid[x+2][y+1]) return '1';\n    if (grid[x][y+1] && grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2] && grid[x+2][y+1]) return '2';\n    if (grid[x][y+1] && grid[x+1][y+1] && grid[x+2][y+1] && grid[x+1][y] && grid[x+1][y+2]) return '3';\n    if (grid[x][y] && grid[x][y+2] && grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2] && grid[x+2][y+2]) return '4';\n    if (grid[x][y+1] && grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2] && grid[x+2][y+1]) return '5';\n    if (grid[x][y+1] && grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2] && grid[x+2][y] && grid[x+2][y+1]) return '6';\n    if (grid[x][y+1] && grid[x+1][y+1] && grid[x+2][y] && grid[x+2][y+1] && grid[x+2][y+2]) return '7';\n    if (grid[x][y+1] && grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2] && grid[x+2][y] && grid[x+2][y+1] && grid[x+2][y+2]) return '8';\n    if (grid[x][y+1] && grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2] && grid[x+2][y+1] && grid[x+2][y+2]) return '9';\n    if (grid[x+1][y] && grid[x+1][y+1] && grid[x+1][y+2]) return '-';\n    if (grid[x][y+1] && grid[x+1][y+1] && grid[x+2][y+1]) return '+';\n    if (grid[x][y] && grid[x+1][y+1] && grid[x+2][y+2]) return '/';\n    if (grid[x][y+2] && grid[x+1][y+1] && grid[x+2][y]) return '\\\\';\n    if (grid[x][y] && grid[x][y+2] && grid[x+1][y+1] && grid[x+2][y] && grid[x+2][y+2]) return '*';\n    return ' ';\n}\n\nvoid extract_expression(char *expr) {\n    int expr_pos = 0;\n    for (int y = 0; y <= max_y; y += 3) {\n        for (int x = 0; x <= max_x; x += 3) {\n            char c = recognize_char(x, y);\n            if (c != ' ') {\n                expr[expr_pos++] = c;\n            }\n        }\n    }\n    expr[expr_pos] = '\\0';\n}\n\nint evaluate_expression(char *expr) {\n    int nums[MAX_SIZE], num_top = -1;\n    char ops[MAX_SIZE], op_top = -1;\n    int i = 0, num = 0;\n\n    while (expr[i] != '\\0') {\n        if (isdigit(expr[i])) {\n            num = 0;\n            while (isdigit(expr[i])) {\n                num = num * 10 + (expr[i] - '0');\n                i++;\n            }\n            nums[++num_top] = num;\n        } else {\n            while (op_top >= 0 && (ops[op_top] == '*' || ops[op_top] == '/') && (expr[i] == '+' || expr[i] == '-')) {\n                int b = nums[num_top--];\n                int a = nums[num_top--];\n                char op = ops[op_top--];\n                if (op == '*') nums[++num_top] = a * b;\n                else if (op == '/') nums[++num_top] = a / b;\n            }\n            ops[++op_top] = expr[i++];\n        }\n    }\n\n    while (op_top >= 0) {\n        int b = nums[num_top--];\n        int a = nums[num_top--];\n        char op = ops[op_top--];\n        if (op == '+') nums[++num_top] = a + b;\n        else if (op == '-') nums[++num_top] = a - b;\n        else if (op == '*') nums[++num_top] = a * b;\n        else if (op == '/') nums[++num_top] = a / b;\n    }\n\n    return nums[num_top];\n}\n\nint main() {\n    read_segments();\n    fill_grid();\n    char expr[MAX_SIZE];\n    extract_expression(expr);\n    int result = evaluate_expression(expr);\n    printf(\"%s\\n%d\\n\", expr, result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <algorithm>\n#include <set>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    bool operator<(const Point& other) const {\n        if (x != other.x) return x < other.x;\n        return y < other.y;\n    }\n    bool operator==(const Point& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\nvector<Segment> segments;\nmap<Point, vector<Point>> adj;\nmap<Point, bool> visited;\nmap<Point, int> degree;\nvector<Point> path;\n\nvoid dfs(Point u) {\n    while (!adj[u].empty()) {\n        Point v = adj[u].back();\n        adj[u].pop_back();\n        dfs(v);\n    }\n    path.push_back(u);\n}\n\nbool isEulerian() {\n    int start = 0;\n    for (auto& entry : adj) {\n        if (entry.second.size() != degree[entry.first]) {\n            if (abs((int)entry.second.size() - degree[entry.first]) > 1)\n                return false;\n            if (entry.second.size() > degree[entry.first])\n                start++;\n        }\n    }\n    return start <= 1;\n}\n\nPoint findStart() {\n    Point start = adj.begin()->first;\n    for (auto& entry : adj) {\n        if (entry.second.size() > degree[entry.first]) {\n            return entry.first;\n        }\n        if (entry.second.size() == degree[entry.first] + 1) {\n            start = entry.first;\n        }\n    }\n    return start;\n}\n\nvector<Point> findEulerianPath() {\n    if (!isEulerian()) return {};\n    Point start = findStart();\n    dfs(start);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\nbool isDigit(Point p, const set<Point>& allPoints) {\n    return allPoints.find(p) != allPoints.end();\n}\n\nstring reconstructExpression(const vector<Point>& path, const set<Point>& allPoints) {\n    string expr;\n    for (size_t i = 0; i < path.size(); ++i) {\n        Point p = path[i];\n        if (isDigit(p, allPoints)) {\n            if (i > 0 && isDigit(path[i-1], allPoints)) {\n                Point prev = path[i-1];\n                if (prev.x == p.x && abs(prev.y - p.y) == 1) {\n                    continue;\n                }\n                if (prev.y == p.y && abs(prev.x - p.x) == 1) {\n                    continue;\n                }\n            }\n            expr += '0' + (p.x + p.y) % 10; // Simplified digit mapping\n        } else {\n            if (i > 0 && !isDigit(path[i-1], allPoints)) continue;\n            if (p.x == 0 && p.y == 1) expr += '+';\n            else if (p.x == 0 && p.y == -1) expr += '-';\n            else if (p.x == 1 && p.y == 0) expr += '.';\n        }\n    }\n    return expr;\n}\n\nint precedence(char op) {\n    if (op == '.') return 2;\n    if (op == '+' || op == '-') return 1;\n    return 0;\n}\n\nint applyOp(int a, int b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '.': return a * b;\n    }\n    return 0;\n}\n\nint evaluate(const string& expr) {\n    stack<int> values;\n    stack<char> ops;\n    for (size_t i = 0; i < expr.size(); ++i) {\n        if (isdigit(expr[i])) {\n            int num = 0;\n            while (i < expr.size() && isdigit(expr[i])) {\n                num = num * 10 + (expr[i] - '0');\n                i++;\n            }\n            values.push(num);\n            i--;\n        } else if (expr[i] == '(') {\n            ops.push(expr[i]);\n        } else if (expr[i] == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                int val2 = values.top(); values.pop();\n                int val1 = values.top(); values.pop();\n                char op = ops.top(); ops.pop();\n                values.push(applyOp(val1, val2, op));\n            }\n            if (!ops.empty()) ops.pop();\n        } else {\n            while (!ops.empty() && precedence(ops.top()) >= precedence(expr[i])) {\n                int val2 = values.top(); values.pop();\n                int val1 = values.top(); values.pop();\n                char op = ops.top(); ops.pop();\n                values.push(applyOp(val1, val2, op));\n            }\n            ops.push(expr[i]);\n        }\n    }\n    while (!ops.empty()) {\n        int val2 = values.top(); values.pop();\n        int val1 = values.top(); values.pop();\n        char op = ops.top(); ops.pop();\n        values.push(applyOp(val1, val2, op));\n    }\n    return values.top();\n}\n\nint main() {\n    int N;\n    cin >> N;\n    set<Point> allPoints;\n    for (int i = 0; i < N; ++i) {\n        Segment s;\n        cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n        segments.push_back(s);\n        adj[s.p1].push_back(s.p2);\n        adj[s.p2].push_back(s.p1);\n        degree[s.p1]++;\n        degree[s.p2]++;\n        allPoints.insert(s.p1);\n        allPoints.insert(s.p2);\n    }\n\n    vector<Point> path = findEulerianPath();\n    if (path.empty()) {\n        cout << \"Invalid input\" << endl;\n        return 0;\n    }\n\n    string expr = reconstructExpression(path, allPoints);\n    cout << expr << endl;\n    cout << evaluate(expr) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class ArithmeticReconstructor {\n    static class Segment {\n        Point start, end;\n        Segment(Point start, Point end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Segment> segments = new ArrayList<>();\n        while (scanner.hasNext()) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            segments.add(new Segment(new Point(x1, y1), new Point(x2, y2)));\n        }\n        scanner.close();\n\n        Map<Point, Set<Point>> graph = new HashMap<>();\n        for (Segment seg : segments) {\n            graph.putIfAbsent(seg.start, new HashSet<>());\n            graph.putIfAbsent(seg.end, new HashSet<>());\n            graph.get(seg.start).add(seg.end);\n            graph.get(seg.end).add(seg.start);\n        }\n\n        List<Point> endpoints = new ArrayList<>();\n        for (Point p : graph.keySet()) {\n            if (graph.get(p).size() == 1) {\n                endpoints.add(p);\n            }\n        }\n\n        if (endpoints.size() != 2) {\n            System.out.println(\"Invalid input\");\n            return;\n        }\n\n        Point start = endpoints.get(0);\n        Point current = start;\n        Point prev = null;\n        StringBuilder expression = new StringBuilder();\n        Map<Point, Character> pointToChar = new HashMap<>();\n\n        for (Segment seg : segments) {\n            if (seg.start.x == seg.end.x && seg.start.y == seg.end.y) {\n                continue;\n            }\n            if (seg.start.x == seg.end.x) {\n                if (Math.abs(seg.start.y - seg.end.y) == 1) {\n                    pointToChar.put(seg.start, '1');\n                    pointToChar.put(seg.end, '1');\n                }\n            } else if (seg.start.y == seg.end.y) {\n                if (Math.abs(seg.start.x - seg.end.x) == 1) {\n                    pointToChar.put(seg.start, '-');\n                    pointToChar.put(seg.end, '-');\n                }\n            }\n        }\n\n        while (true) {\n            Set<Point> neighbors = graph.get(current);\n            Point next = null;\n            for (Point neighbor : neighbors) {\n                if (!neighbor.equals(prev)) {\n                    next = neighbor;\n                    break;\n                }\n            }\n            if (next == null) {\n                break;\n            }\n            if (pointToChar.containsKey(current)) {\n                expression.append(pointToChar.get(current));\n            } else {\n                if (current.x == next.x) {\n                    expression.append('1');\n                } else if (current.y == next.y) {\n                    expression.append('-');\n                }\n            }\n            prev = current;\n            current = next;\n        }\n\n        String exprStr = expression.toString();\n        exprStr = exprStr.replaceAll(\"1+\", \"1\").replaceAll(\"-+\", \"-\");\n        exprStr = exprStr.replace(\"1\", \"+\").replace(\"-\", \"-\").replace(\"·\", \"*\");\n\n        int result = evaluateExpression(exprStr);\n        System.out.println(exprStr + \"=\" + result);\n    }\n\n    private static int evaluateExpression(String expr) {\n        expr = expr.replaceAll(\"\\\\s+\", \"\");\n        Stack<Integer> numbers = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (Character.isDigit(c)) {\n                int num = 0;\n                while (i < expr.length() && Character.isDigit(expr.charAt(i))) {\n                    num = num * 10 + (expr.charAt(i) - '0');\n                    i++;\n                }\n                i--;\n                numbers.push(num);\n            } else if (c == '(') {\n                ops.push(c);\n            } else if (c == ')') {\n                while (ops.peek() != '(') {\n                    numbers.push(applyOp(ops.pop(), numbers.pop(), numbers.pop()));\n                }\n                ops.pop();\n            } else if (c == '+' || c == '-' || c == '*') {\n                while (!ops.empty() && precedence(ops.peek()) >= precedence(c)) {\n                    numbers.push(applyOp(ops.pop(), numbers.pop(), numbers.pop()));\n                }\n                ops.push(c);\n            }\n        }\n\n        while (!ops.empty()) {\n            numbers.push(applyOp(ops.pop(), numbers.pop(), numbers.pop()));\n        }\n\n        return numbers.pop();\n    }\n\n    private static int precedence(char op) {\n        if (op == '*' || op == '·') {\n            return 2;\n        } else if (op == '+' || op == '-') {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    private static int applyOp(char op, int b, int a) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '·': return a * b;\n            default: return 0;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:02:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class HandwrittenExpressionDecoder {\n    private static final int[][] DIGIT_SEGMENTS = {\n        {1,1,1,0,1,1,1},  // 0\n        {0,0,1,0,0,1,0},  // 1\n        {1,0,1,1,1,0,1},  // 2\n        {1,0,1,1,0,1,1},  // 3\n        {0,1,1,1,0,1,0},  // 4\n        {1,1,0,1,0,1,1},  // 5\n        {1,1,0,1,1,1,1},  // 6\n        {1,0,1,0,0,1,0},  // 7\n        {1,1,1,1,1,1,1},  // 8\n        {1,1,1,1,0,1,1}   // 9\n    };\n\n    public static String decodeExpression(List<List<Integer>> segments) {\n        StringBuilder expression = new StringBuilder();\n        List<Integer> digits = new ArrayList<>();\n        List<Character> operators = new ArrayList<>();\n\n        for (List<Integer> segment : segments) {\n            int digit = recognizeDigit(segment);\n            if (digit != -1) {\n                digits.add(digit);\n            } else {\n                char operator = recognizeOperator(segment);\n                if (operator != ' ') {\n                    operators.add(operator);\n                }\n            }\n        }\n\n        for (int i = 0; i < digits.size(); i++) {\n            expression.append(digits.get(i));\n            if (i < operators.size()) {\n                expression.append(operators.get(i));\n            }\n        }\n\n        return expression.toString();\n    }\n\n    private static int recognizeDigit(List<Integer> segment) {\n        for (int i = 0; i < DIGIT_SEGMENTS.length; i++) {\n            if (matchesDigitSegment(segment, DIGIT_SEGMENTS[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static boolean matchesDigitSegment(List<Integer> segment, int[] digitSegment) {\n        if (segment.size() != 7) return false;\n        for (int i = 0; i < 7; i++) {\n            if (segment.get(i) != digitSegment[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static char recognizeOperator(List<Integer> segment) {\n        if (segment.equals(Arrays.asList(0,1,0,0,0,0,0))) return '+';\n        if (segment.equals(Arrays.asList(0,1,0,1,0,0,0))) return '-';\n        if (segment.equals(Arrays.asList(0,0,0,1,0,0,0))) return '·';\n        return ' ';\n    }\n\n    public static int evaluateExpression(String expression) {\n        return evaluateExpressionHelper(expression);\n    }\n\n    private static int evaluateExpressionHelper(String expression) {\n        List<Integer> numbers = new ArrayList<>();\n        List<Character> ops = new ArrayList<>();\n        \n        StringBuilder numBuilder = new StringBuilder();\n        for (char c : expression.toCharArray()) {\n            if (Character.isDigit(c)) {\n                numBuilder.append(c);\n            } else {\n                numbers.add(Integer.parseInt(numBuilder.toString()));\n                numBuilder = new StringBuilder();\n                ops.add(c);\n            }\n        }\n        numbers.add(Integer.parseInt(numBuilder.toString()));\n\n        // First pass: multiplication\n        for (int i = 0; i < ops.size(); i++) {\n            if (ops.get(i) == '·') {\n                int result = numbers.get(i) * numbers.get(i + 1);\n                numbers.set(i, result);\n                numbers.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n\n        // Second pass: addition and subtraction\n        int result = numbers.get(0);\n        for (int i = 0; i < ops.size(); i++) {\n            if (ops.get(i) == '+') {\n                result += numbers.get(i + 1);\n            } else {\n                result -= numbers.get(i + 1);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<List<Integer>> input = Arrays.asList(\n            Arrays.asList(1,1,1,0,1,1,1),  // 0\n            Arrays.asList(0,0,1,0,0,1,0),  // 1\n            Arrays.asList(0,1,0,0,0,0,0),  // +\n            Arrays.asList(1,0,1,1,1,0,1)   // 2\n        );\n\n        String expression = decodeExpression(input);\n        int result = evaluateExpression(expression);\n        System.out.println(\"Expression: \" + expression);\n        System.out.println(\"Result: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 21:02:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_SEGMENTS 1000\n#define MAX_EXPR_LEN 100\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Segment;\n\nSegment segments[MAX_SEGMENTS];\nint segmentCount = 0;\n\nconst char* digitPatterns[10][7] = {\n    {\"111\", \"101\", \"101\", \"101\", \"101\", \"101\", \"111\"},  // 0\n    {\"010\", \"110\", \"010\", \"010\", \"010\", \"010\", \"111\"}, // 1\n    {\"111\", \"001\", \"001\", \"111\", \"100\", \"100\", \"111\"}, // 2\n    {\"111\", \"001\", \"001\", \"111\", \"001\", \"001\", \"111\"}, // 3\n    {\"101\", \"101\", \"101\", \"111\", \"001\", \"001\", \"001\"}, // 4\n    {\"111\", \"100\", \"100\", \"111\", \"001\", \"001\", \"111\"}, // 5\n    {\"111\", \"100\", \"100\", \"111\", \"101\", \"101\", \"111\"}, // 6\n    {\"111\", \"001\", \"001\", \"010\", \"010\", \"100\", \"100\"}, // 7\n    {\"111\", \"101\", \"101\", \"111\", \"101\", \"101\", \"111\"}, // 8\n    {\"111\", \"101\", \"101\", \"111\", \"001\", \"001\", \"111\"}  // 9\n};\n\nint matchDigit(Segment* digitSegs, int count) {\n    char pattern[7][4];\n    int minX = segments[digitSegs[0]].x1, minY = segments[digitSegs[0]].y1;\n    \n    for (int i = 1; i < count; i++) {\n        minX = (segments[digitSegs[i]].x1 < minX) ? segments[digitSegs[i]].x1 : minX;\n        minY = (segments[digitSegs[i]].y1 < minY) ? segments[digitSegs[i]].y1 : minY;\n    }\n\n    memset(pattern, '0', sizeof(pattern));\n\n    for (int i = 0; i < count; i++) {\n        int row = segments[digitSegs[i]].y1 - minY;\n        int col = segments[digitSegs[i]].x1 - minX;\n        pattern[row][col] = '1';\n    }\n\n    for (int d = 0; d < 10; d++) {\n        int match = 1;\n        for (int r = 0; r < 7; r++) {\n            for (int c = 0; c < 3; c++) {\n                if (pattern[r][c] != digitPatterns[d][r][c]) {\n                    match = 0;\n                    break;\n                }\n            }\n            if (!match) break;\n        }\n        if (match) return d;\n    }\n    return -1;\n}\n\nint evaluateExpression(char* expr) {\n    int len = strlen(expr);\n    int result = 0, num = 0, lastNum = 0;\n    char lastOp = '+';\n\n    for (int i = 0; i <= len; i++) {\n        if (i < len && isdigit(expr[i])) {\n            num = num * 10 + (expr[i] - '0');\n        } else {\n            if (lastOp == '*') {\n                lastNum *= num;\n            } else if (lastOp == '+') {\n                result += lastNum;\n                lastNum = num;\n            } else if (lastOp == '-') {\n                result += lastNum;\n                lastNum = -num;\n            }\n\n            if (i < len) {\n                lastOp = expr[i];\n                num = 0;\n            }\n        }\n    }\n    result += lastNum;\n    return result;\n}\n\nint main() {\n    // Input code would go here to read segments\n    // This is a simplified skeleton\n    char expression[MAX_EXPR_LEN];\n    \n    // Reconstruct expression from segments\n    // Evaluate and output result\n    int result = evaluateExpression(expression);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n// Line segment representation\nstruct Segment {\n    int x1, y1, x2, y2;\n};\n\n// Digit representation\nmap<vector<Segment>, char> digitMap = {\n    {{{{0,0,0,2}}, {{0,2,2,2}}, {{2,0,2,2}}, {{0,0,2,0}}, {{0,0,0,2}}, {{2,0,2,2}}}, '0'},\n    {{{{1,0,1,2}}}, '1'},\n    {{{{0,2,2,2}}, {{2,1,2,2}}, {{0,0,2,0}}, {{0,0,0,1}}, {{0,1,2,1}}}, '2'},\n    {{{{0,2,2,2}}, {{2,0,2,2}}, {{0,0,2,0}}, {{0,1,2,1}}}, '3'},\n    {{{{0,0,0,1}}, {{0,1,2,1}}, {{2,0,2,2}}}, '4'},\n    {{{{0,0,2,0}}, {{0,0,0,1}}, {{2,1,2,2}}, {{0,1,2,1}}, {{0,2,2,2}}}, '5'},\n    {{{{0,0,2,0}}, {{0,0,0,2}}, {{0,1,2,1}}, {{2,1,2,2}}, {{0,2,2,2}}}, '6'},\n    {{{{0,2,2,2}}, {{2,0,2,2}}}, '7'},\n    {{{{0,0,2,0}}, {{0,2,2,2}}, {{0,0,0,2}}, {{2,0,2,2}}, {{0,1,2,1}}}, '8'},\n    {{{{0,0,2,0}}, {{0,2,2,2}}, {{0,0,0,1}}, {{2,0,2,2}}, {{0,1,2,1}}}, '9'}\n};\n\n// Operator representation\nmap<vector<Segment>, char> operatorMap = {\n    {{{{1,1,1,0}}, {{1,0,2,0}}}, '+'},\n    {{{{1,1,1,0}}}, '-'},\n    {{{{0,1,2,1}}}, '*'}\n};\n\n// Function to check if two segments are close\nbool isClose(const Segment& a, const Segment& b, int threshold = 1) {\n    return abs(a.x1 - b.x1) <= threshold && abs(a.y1 - b.y1) <= threshold &&\n           abs(a.x2 - b.x2) <= threshold && abs(a.y2 - b.y2) <= threshold;\n}\n\n// Function to recognize digit from segments\nchar recognizeDigit(const vector<Segment>& segs) {\n    for (const auto& [segments, digit] : digitMap) {\n        bool match = true;\n        for (const auto& refSeg : segments) {\n            bool found = false;\n            for (const auto& seg : segs) {\n                if (isClose(refSeg, seg)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return digit;\n    }\n    return '\\0';\n}\n\n// Function to recognize operator from segments\nchar recognizeOperator(const vector<Segment>& segs) {\n    for (const auto& [segments, op] : operatorMap) {\n        bool match = true;\n        for (const auto& refSeg : segments) {\n            bool found = false;\n            for (const auto& seg : segs) {\n                if (isClose(refSeg, seg)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return op;\n    }\n    return '\\0';\n}\n\n// Function to evaluate expression\nlong long evaluate(const string& expr) {\n    vector<long long> nums;\n    vector<char> ops;\n    \n    string num;\n    for (char c : expr) {\n        if (isdigit(c)) {\n            num += c;\n        } else {\n            if (!num.empty()) {\n                nums.push_back(stoll(num));\n                num.clear();\n            }\n            \n            if (c == '*') {\n                long long right = nums.back();\n                nums.pop_back();\n                right *= stoll(string(1, expr[expr.find(c) + 1]));\n                nums.push_back(right);\n            } else if (c == '+' || c == '-') {\n                ops.push_back(c);\n            }\n        }\n    }\n    \n    if (!num.empty()) {\n        nums.push_back(stoll(num));\n    }\n    \n    long long result = nums[0];\n    for (size_t i = 0; i < ops.size(); ++i) {\n        if (ops[i] == '+') result += nums[i + 1];\n        else result -= nums[i + 1];\n    }\n    \n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Segment> segments(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> segments[i].x1 >> segments[i].y1 >> segments[i].x2 >> segments[i].y2;\n    }\n    \n    // Cluster segments by proximity\n    vector<vector<Segment>> clusters;\n    for (const auto& seg : segments) {\n        bool added = false;\n        for (auto& cluster : clusters) {\n            if (isClose(seg, cluster[0])) {\n                cluster.push_back(seg);\n                added = true;\n                break;\n            }\n        }\n        if (!added) {\n            clusters.push_back({seg});\n        }\n    }\n    \n    // Recognize expression\n    string expr;\n    for (const auto& cluster : clusters) {\n        char ch = recognizeDigit(cluster);\n        if (ch != '\\0') {\n            expr += ch;\n        } else {\n            ch = recognizeOperator(cluster);\n            if (ch != '\\0') {\n                expr += ch;\n            }\n        }\n    }\n    \n    // Evaluate and output\n    cout << evaluate(expr) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def reconstruct_expression(line_segments):\n    def parse_expression(expression):\n        def operate(a, b, op):\n            if op == '+':\n                return a + b\n            elif op == '-':\n                return a - b\n            elif op == '*':\n                return a * b\n\n        def precedence(op):\n            if op == '+' or op == '-':\n                return 1\n            if op == '*':\n                return 2\n            return 0\n\n        def apply_ops(values, ops):\n            b = values.pop()\n            a = values.pop()\n            op = ops.pop()\n            values.append(operate(a, b, op))\n\n        i, values, ops = 0, [], []\n        while i < len(expression):\n            if expression[i].isdigit():\n                val = 0\n                while (i < len(expression)) and (expression[i].isdigit()):\n                    val = (val * 10) + int(expression[i])\n                    i += 1\n                values.append(val)\n                i -= 1\n            elif expression[i] == '(':\n                ops.append(expression[i])\n            elif expression[i] == ')':\n                while ops and ops[-1] != '(':\n                    apply_ops(values, ops)\n                ops.pop()\n            elif expression[i] in \"+-*\":\n                while ops and precedence(ops[-1]) >= precedence(expression[i]):\n                    apply_ops(values, ops)\n                ops.append(expression[i])\n            i += 1\n\n        while ops:\n            apply_ops(values, ops)\n\n        return values[0]\n\n    def segments_to_expression(segments):\n        grid = {}\n        for (x1, y1), (x2, y2) in segments:\n            if x1 == x2:  # Vertical line\n                for y in range(min(y1, y2), max(y1, y2) + 1):\n                    if (x1, y) in grid:\n                        grid[(x1, y)] += '|'\n                    else:\n                        grid[(x1, y)] = '|'\n            else:  # Horizontal line\n                for x in range(min(x1, x2), max(x1, x2) + 1):\n                    if (x, y1) in grid:\n                        grid[(x, y1)] += '-'\n                    else:\n                        grid[(x, y1)] = '-'\n\n        def max_coordinates(grid):\n            max_x = max(x for x, _ in grid)\n            max_y = max(y for _, y in grid)\n            return max_x, max_y\n\n        max_x, max_y = max_coordinates(grid)\n        reconstruction = [[' ' for _ in range(max_x + 1)] for _ in range(max_y + 1)]\n\n        for (x, y), char in grid.items():\n            if char == '-':\n                reconstruction[y][x] = '-'\n            elif char == '|':\n                reconstruction[y][x] = '|'\n\n        lines = [''.join(row) for row in reconstruction]\n        \n        # Simplistic parsing to convert to expression, assuming no complex nested structures for the exercise sake.\n        return ''.join(lines).replace('|', '*').replace('-', '+')\n\n    expression = segments_to_expression(line_segments)\n    result = parse_expression(expression)\n    return result",
    "timestamp": "2025-08-13 04:29:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ArithmeticExpression {\n    // Assuming the line segments are given in a specific format for the purpose of this function\n    public static int evaluateExpressionFromHandwriting(List<List<Character>> grid) {\n        String expression = reconstructExpression(grid);\n        return evaluateExpression(expression);\n    }\n\n    private static String reconstructExpression(List<List<Character>> grid) {\n        // Implement handwriting reconstruction logic here\n        // The implementation detail depends on the grid format and how expression is represented\n        // Assume for now that the grid properly represents each digit, '+', '-', and '·' as separate character\n        StringBuilder sb = new StringBuilder();\n        for (List<Character> row : grid) {\n            for (Character c : row) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    private static int evaluateExpression(String expression) {\n        Stack<Integer> nums = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n        int num = 0;\n        boolean numStarted = false;\n\n        for (int i = 0; i < expression.length(); i++) {\n            char ch = expression.charAt(i);\n\n            if (Character.isDigit(ch)) {\n                num = num * 10 + (ch - '0');\n                numStarted = true;\n            } else {\n                if (numStarted) {\n                    nums.push(num);\n                    num = 0;\n                    numStarted = false;\n                }\n\n                if (ch == '+' || ch == '-') {\n                    while (!ops.isEmpty() && (ops.peek() == '·' || ops.peek() == '+' || ops.peek() == '-')) {\n                        processOperator(nums, ops.pop());\n                    }\n                    ops.push(ch);\n                } else if (ch == '·') {\n                    while (!ops.isEmpty() && ops.peek() == '·') {\n                        processOperator(nums, ops.pop());\n                    }\n                    ops.push(ch);\n                }\n            }\n        }\n        if (numStarted) {\n            nums.push(num);\n        }\n\n        while (!ops.isEmpty()) {\n            processOperator(nums, ops.pop());\n        }\n        return nums.pop();\n    }\n\n    private static void processOperator(Stack<Integer> nums, char operator) {\n        int b = nums.pop();\n        int a = nums.pop();\n        if (operator == '+') {\n            nums.push(a + b);\n        } else if (operator == '-') {\n            nums.push(a - b);\n        } else if (operator == '·') {\n            nums.push(a * b);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Sample grid example usage:\n        List<List<Character>> grid = Arrays.asList(\n            Arrays.asList('1', '0', '+', '2', '·', '3', '-', '5')\n        );\n\n        int result = evaluateExpressionFromHandwriting(grid);\n        System.out.println(\"Result: \" + result);  // Should print 10 + 2*3 - 5 = 11\n    }\n}",
    "timestamp": "2025-08-13 04:29:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_EXPRESSION_LENGTH 100\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} LineSegment;\n\n// Stub function: assumes a function to transform line segments to expression.\nchar* interpretLineSegments(LineSegment* segments, int n) {\n    // This function should contain the logic to interpret the line segments\n    // into an arithmetic expression string, e.g., \"3+5·2-8\".\n    // This is a simplification:\n    return \"3+5*2-8\";\n}\n\nint evaluateExpression(const char* expression) {\n    int i = 0, numStack[MAX_EXPRESSION_LENGTH], numTop = -1, opStack[MAX_EXPRESSION_LENGTH], opTop = -1;\n    memset(numStack, 0, sizeof(numStack));\n    memset(opStack, 0, sizeof(opStack));\n\n    while (expression[i]) {\n        if (isdigit(expression[i])) {\n            int num = 0;\n            while (isdigit(expression[i])) {\n                num = num * 10 + (expression[i++] - '0');\n            }\n            numStack[++numTop] = num;\n        } else if (expression[i] == '+' || expression[i] == '-') {\n            while (opTop >= 0 && (opStack[opTop] == '+' || opStack[opTop] == '-' || opStack[opTop] == '*')) {\n                int num2 = numStack[numTop--];\n                int num1 = numStack[numTop--];\n                char op = opStack[opTop--];\n                if (op == '+') num1 += num2;\n                else if (op == '-') num1 -= num2;\n                else if (op == '*') num1 *= num2;\n                numStack[++numTop] = num1;\n            }\n            opStack[++opTop] = expression[i++];\n        } else if (expression[i] == '*') {\n            while (opTop >= 0 && opStack[opTop] == '*') {\n                int num2 = numStack[numTop--];\n                int num1 = numStack[numTop--];\n                char op = opStack[opTop--];\n                num1 *= num2;\n                numStack[++numTop] = num1;\n            }\n            opStack[++opTop] = expression[i++];\n        } else {\n            i++;\n        }\n    }\n\n    while (opTop >= 0) {\n        int num2 = numStack[numTop--];\n        int num1 = numStack[numTop--];\n        char op = opStack[opTop--];\n        if (op == '+') num1 += num2;\n        else if (op == '-') num1 -= num2;\n        else if (op == '*') num1 *= num2;\n        numStack[++numTop] = num1;\n    }\n\n    return numStack[numTop];\n}\n\nint main() {\n    LineSegment lineSegments[] = {}; // Input: fill with line segments\n    int n = sizeof(lineSegments) / sizeof(LineSegment);\n\n    char* expression = interpretLineSegments(lineSegments, n);\n    int result = evaluateExpression(expression);\n\n    printf(\"Result: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:29:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def recognize_digit(lines):\n    digits = {\n        (1,1,1,0,1,1,1): '0',\n        (0,0,1,0,0,1,0): '1',\n        (1,0,1,1,1,0,1): '2',\n        (1,0,1,1,0,1,1): '3',\n        (0,1,1,1,0,1,0): '4',\n        (1,1,0,1,0,1,1): '5',\n        (1,1,0,1,1,1,1): '6',\n        (1,0,1,0,0,1,0): '7',\n        (1,1,1,1,1,1,1): '8',\n        (1,1,1,1,0,1,1): '9'\n    }\n    \n    # Convert line segments to 7-segment representation\n    segments = [0] * 7\n    for line in lines:\n        if line[0] == 'h':\n            if line[1] == 0: segments[0] = 1\n            elif line[1] == 2: segments[3] = 1\n            elif line[1] == 4: segments[6] = 1\n        elif line[0] == 'v':\n            if line[2] == 0:\n                if line[1] == 1: segments[1] = 1\n                elif line[1] == 2: segments[2] = 1\n            elif line[2] == 3:\n                if line[1] == 1: segments[4] = 1\n                elif line[1] == 2: segments[5] = 1\n    \n    return digits.get(tuple(segments), '')\n\ndef parse_expression(digits):\n    expression = ''.join(digits)\n    \n    # Handle multiplication first\n    while '*' in expression:\n        parts = expression.split('*')\n        new_parts = []\n        for i, part in enumerate(parts):\n            if i > 0:\n                prev = new_parts.pop()\n                new_parts.append(str(int(prev) * int(part)))\n            else:\n                new_parts.append(part)\n        expression = '+'.join(new_parts)\n    \n    # Evaluate remaining addition/subtraction\n    return str(eval(expression))\n\ndef solve_handwriting_puzzle(segments):\n    # Group segments by digits\n    digit_segments = {}\n    operators = []\n    \n    for segment in segments:\n        if segment[0] == 'digit':\n            if segment[1] not in digit_segments:\n                digit_segments[segment[1]] = []\n            digit_segments[segment[1]].append(segment[2:])\n        else:\n            operators.append(segment[0])\n    \n    # Recognize digits\n    digits = []\n    for i in sorted(digit_segments.keys()):\n        digits.append(recognize_digit(digit_segments[i]))\n    \n    # Reconstruct and insert operators\n    expression = []\n    for i, digit in enumerate(digits):\n        expression.append(digit)\n        if i < len(operators):\n            op = {'+': '+', '-': '-', 'x': '*'}[operators[i]]\n            expression.append(op)\n    \n    # Evaluate expression\n    return parse_expression(''.join(expression))",
    "timestamp": "2025-08-13 04:29:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    N = int(input[idx])\n    idx += 1\n    segments = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input[idx:idx+4])\n        idx +=4\n        segments.append((x1, y1, x2, y2))\n    \n    # Group segments by their y-coordinate (row)\n    rows = defaultdict(list)\n    for seg in segments:\n        x1, y1, x2, y2 = seg\n        if y1 == y2:\n            rows[y1].append((min(x1, x2), max(x1, x2), 'h'))  # horizontal\n        else:\n            rows[min(y1, y2)].append((x1, max(y1, y2), 'v'))  # vertical\n    \n    # Sort rows by y-coordinate (top to bottom)\n    sorted_rows = sorted(rows.keys())\n    \n    # For each row, process horizontal segments to identify digits and operators\n    expr_parts = []\n    for y in sorted_rows:\n        row_segments = rows[y]\n        # Separate horizontal and vertical segments in the row\n        h_segments = [seg for seg in row_segments if seg[2] == 'h']\n        v_segments = [seg for seg in row_segments if seg[2] == 'v']\n        \n        # Sort horizontal segments by x-coordinate (left to right)\n        h_segments.sort()\n        \n        for seg in h_segments:\n            x1, x2, _ = seg\n            length = x2 - x1 + 1\n            \n            # Check for digits or operators based on segment length and position\n            # Digit 1 is a special case (only vertical segments)\n            # Other digits and operators have specific horizontal segment patterns\n            if length == 4:  # likely '0', '2', '3', '5', '6', '7', '8', '9', '+', '-', '·'\n                # Check if there are vertical segments in this row to distinguish digits from operators\n                if any(v[0] in (x1, x1 + 2, x2) for v in v_segments):\n                    # Likely a digit\n                    # Determine which digit based on vertical segments\n                    has_left = any(v[0] == x1 for v in v_segments)\n                    has_mid = any(v[0] == x1 + 2 for v in v_segments)\n                    has_right = any(v[0] == x2 for v in v_segments)\n                    \n                    if has_left and has_right and not has_mid:\n                        expr_parts.append('0')\n                    elif not has_left and has_right:\n                        expr_parts.append('2')\n                    elif not has_left and not has_right and has_mid:\n                        expr_parts.append('3')\n                    elif has_left and not has_right and has_mid:\n                        expr_parts.append('5')\n                    elif has_left and not has_right and not has_mid:\n                        expr_parts.append('7')\n                    elif has_left and has_right and has_mid:\n                        expr_parts.append('8')\n                    elif has_left and has_right and not has_mid:\n                        expr_parts.append('9')\n                    elif not has_left and has_right and has_mid:\n                        expr_parts.append('6')\n                else:\n                    # Operator\n                    # Check if there are vertical segments in adjacent rows\n                    # For simplicity, assume it's '-' if no verticals nearby\n                    expr_parts.append('-')\n            elif length == 2:\n                # Likely '+' or '·'\n                # '+' has a vertical segment crossing the horizontal\n                # '·' is just a dot (no verticals)\n                has_vertical = any(v[0] == x1 + 1 and v[1] >= y for v in v_segments)\n                if has_vertical:\n                    expr_parts.append('+')\n                else:\n                    expr_parts.append('·')\n    \n    # Reconstruct the expression by joining the parts\n    expr = ''.join(expr_parts)\n    \n    # Evaluate the expression with proper operator precedence\n    # Replace '·' with '*' for evaluation\n    expr_eval = expr.replace('·', '*')\n    \n    # Evaluate the expression\n    try:\n        result = eval(expr_eval)\n    except:\n        result = 0  # fallback in case of unexpected errors\n    \n    print(expr)\n    print(result)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 04:30:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\n// Function to parse the set of line segments and reconstruct the arithmetic expression\nstring reconstructExpression(const vector<pair<int, int>>& segments) {\n    string expression;\n    map<pair<int, int>, char> charMap; // Mapping between line segments and characters\n    \n    // Sample mapping logic (this will depend on the actual line segment data)\n    for (const auto& segment : segments) {\n        charMap[segment] = ' '; // Fill this map according to the given line segment data\n    }\n    \n    for (const auto& segment : segments) {\n        expression += charMap[segment]; // Construct expression based on mapping\n    }\n    \n    return expression;\n}\n\n// Function to evaluate arithmetic expression following precedence rules\nint evaluateExpression(const string& expression) {\n    stack<int> operands;\n    stack<char> operators;\n    int n = expression.size();\n    \n    for (int i = 0; i < n; ++i) {\n        if (isdigit(expression[i])) {\n            int num = 0;\n            while (i < n && isdigit(expression[i])) {\n                num = num * 10 + (expression[i] - '0');\n                ++i;\n            }\n            --i;\n            operands.push(num);\n        } else if (expression[i] == '+' || expression[i] == '-' || expression[i] == '·') {\n            while (!operators.empty() && (\n                (expression[i] != '·' && (operators.top() == '+' || operators.top() == '-' || operators.top() == '·')) ||\n                (expression[i] == '·' && operators.top() == '·')\n            )) {\n                char op = operators.top(); operators.pop();\n                int second = operands.top(); operands.pop();\n                int first = operands.top(); operands.pop();\n                \n                switch (op) {\n                    case '+': operands.push(first + second); break;\n                    case '-': operands.push(first - second); break;\n                    case '·': operands.push(first * second); break;\n                }\n            }\n            operators.push(expression[i]);\n        }\n    }\n    \n    while (!operators.empty()) {\n        char op = operators.top(); operators.pop();\n        int second = operands.top(); operands.pop();\n        int first = operands.top(); operands.pop();\n        \n        switch (op) {\n            case '+': operands.push(first + second); break;\n            case '-': operands.push(first - second); break;\n            case '·': operands.push(first * second); break;\n        }\n    }\n    \n    return operands.top();\n}\n\nint main() {\n    // Sample line segments (this should be filled with actual data)\n    vector<pair<int, int>> segments {\n        // Line segments data here\n    };\n    \n    string expression = reconstructExpression(segments);\n    int result = evaluateExpression(expression);\n    \n    cout << \"The result of the evaluated expression is: \" << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:19:52"
  }
]