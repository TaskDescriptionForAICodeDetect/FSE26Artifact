[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n\nstring ume_c=\"89605+32471-*\";\nstring ume[13][5]={\n    {//8\n    \"111\",\n    \"101\",\n    \"111\",\n\t\"101\",\n    \"111\"\n    },\n\n\t{\n    \"111\",\n    \"101\",\n    \"111\",\n\t\"001\",\n    \"111\"\n    },\n\t\n\t{\n    \"111\",\n    \"100\",\n    \"111\",\n\t\"101\",\n    \"111\"\n    },\n\t\n\t{\n    \"111\",\n    \"101\",\n    \"101\",\n\t\"101\",\n    \"111\"\n    },\n\t\n\t{\n    \"111\",\n    \"100\",\n    \"111\",\n\t\"001\",\n    \"111\"\n    },\n\t\n\t{\n    \"000\",\n    \"010\",\n    \"111\",\n\t\"010\",\n    \"000\"\n    },\n\t\n\t{\n    \"111\",\n    \"001\",\n    \"111\",\n\t\"001\",\n    \"111\"\n    },\n\t\n\t{\n    \"111\",\n    \"001\",\n    \"111\",\n\t\"100\",\n    \"111\"\n    },\n\t\n\t{\n    \"101\",\n    \"101\",\n    \"111\",\n\t\"001\",\n    \"001\"\n    },\n\t\n\t{\n    \"111\",\n    \"001\",\n    \"001\",\n\t\"001\",\n    \"001\"\n    },\n\t{\n    \"001\",\n    \"001\",\n    \"001\",\n\t\"001\",\n    \"001\"\n    },\n\t{\n    \"000\",\n    \"000\",\n    \"111\",\n\t\"000\",\n    \"000\"\n    },\n\t{\n    \"000\",\n    \"000\",\n    \"010\",\n\t\"000\",\n    \"000\"\n    }\n\t\n\t\n};\n\n\nstring S;\nint pos;\n\nint expr();\nint term();\nint num();\n\nint expr(){\n\tint res = term();\n\twhile(1){\n\t\tif(S[pos]=='+'){\n\t\t\tpos++;\n\t\t\tres += term();\n\t\t}else if(S[pos]=='-'){\n\t\t\tpos++;\n\t\t\tres -= term();\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint term(){\n\tint res = num();\n\twhile(1){\n\t\tif(S[pos]=='*'){\n\t\t\tpos++;\n\t\t\tres *= num();\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint num(){\n\tint c = S[pos++]-'0';\n\twhile('0' <= S[pos] && S[pos] <= '9'){\n\t\tc *= 10;\n\t\tc += S[pos++]-'0';\n\t}\n\treturn c;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tint mp[321][321]={0};\n\tchar s[322]={};\n\tfor(int i=0;i<321;i++)s[i]=' ';\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tx1 += 20;\n\t\ty1 += 20;\n\t\tx2 += 20;\n\t\ty2 += 20;\n\t\t\n\t\tif(x1==x2){\n\t\t\tif( y1 > y2 ) swap(y1,y2);\n\t\t\tfor(int j=y1;j<=y2;j++){\n\t\t\t\tmp[x1][j]=1;\n\t\t\t}\n\t\t}else{\n\t\t\tif( x1 > x2 ) swap(x1,x2);\n\t\t\tfor(int j=x1;j<=x2;j++){\n\t\t\t\tmp[j][y1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<ume_c.size();i++){\n\t\tfor(int j=0;j<=300;j++){\n\t\t\tfor(int k=0;k<=300;k++){\n\t\t\t\tint t=1;\n\t\t\t\tint minx = 1e9;\n\t\t\t\tfor(int l=0;l<=4;l++){\n\t\t\t\t\tfor(int m=0;m<=2;m++){\n\t\t\t\t\t\tif(ume[i][l][m]=='1'){\n\t\t\t\t\t\t\tminx = min(minx,k+m);\n\t\t\t\t\t\t\tif(mp[k+m][j+l]==0){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tt=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t==1){\n\t\t\t\t\ts[minx]=ume_c[i];\n\t\t\t\t\tfor(int l=0;l<=4;l++){\n\t\t\t\t\t\tfor(int m=0;m<=2;m++){\n\t\t\t\t\t\t\tif(ume[i][l][m]=='1'){\n\t\t\t\t\t\t\t\tmp[k+m][j+l]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tS = string(s);\n\tS.erase(remove(S.begin(),S.end(),' '),S.end());\n\tpos = 0;\n\tS += \"~\";\n\tcout<<expr()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * d.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 150;\nconst int H = 201;\nconst int W = 201;\n//const int H = 30;\n//const int W = 30;\nconst int CH = 5;\nconst int CW = 3;\n\nconst int INF = 1 << 30;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nenum { OP_PLUS = 10, OP_MINUS = 11, OP_MUL = 12 };\n\n/* global variables */\n\nbool flds[H][W], used[H][W];\nvpii e;\n\n/* subroutines */\n\ninline char chs(int c) {\n  if (c == OP_PLUS) return '+';\n  if (c == OP_MINUS) return '-';\n  if (c == OP_MUL) return '*';\n  return '0' + c;\n}\n\nint num(vpii &e, int &pos) {\n  int d = 0;\n  while (pos < e.size() && e[pos].second <= 9)\n    d = d * 10 + e[pos++].second;\n  return d;\n}\n\nint term(vpii &e, int &pos) {\n  int t0 = num(e, pos);\n  while (pos < e.size() && e[pos].second == OP_MUL) {\n    pos++; // OP_MUL\n    int t1 = num(e, pos);\n    t0 *= t1;\n  }\n  return t0;\n}\n\nint expr(vpii &e, int &pos) {\n  int e0 = term(e, pos);\n  while (pos < e.size() &&\n\t (e[pos].second == OP_PLUS || e[pos].second == OP_MINUS)) {\n    int sign = (e[pos].second == OP_PLUS) ? 1 : -1;\n    pos++; // OP_PLUS || OP_MINUS\n    int e1 = term(e, pos);\n    e0 += e1 * sign;\n  }\n  return e0;\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n\n    if (x0 > x1) swap(x0, x1);\n    if (y0 > y1) swap(y0, y1);\n    int dx = ((x0 == x1) ? 0 : 1), dy = ((y0 == y1) ? 0 : 1);\n\n    for (int x = x0, y = y0; x != x1 || y != y1; x += dx, y += dy)\n      flds[y][x] = true;\n    flds[y1][x1] = true;\n  }\n\n  if (false)\n    for (int y = 0; y < H; y++) {\n      for (int x = 0; x < W; x++) putchar(flds[y][x] ? 'X' : '.');\n      putchar('\\n');\n    }\n\n  for (int y0 = 0; y0 < H; y0++)\n    for (int x0 = 0; x0 < W; x0++)\n      if (flds[y0][x0] && ! used[y0][x0]) {\n\tused[y0][x0] = true;\n\tint minx = x0, maxx = x0, miny = y0, maxy = y0;\n\tint size = 1;\n\tqueue<pii> q;\n\tq.push(pii(x0, y0));\n\n\twhile (! q.empty()) {\n\t  pii u = q.front(); q.pop();\n\t  int &ux = u.first, &uy = u.second;\n\t  for (int di = 0; di < 4; di++) {\n\t    int vx = ux + dxs[di], vy = uy + dys[di];\n\t    if (vx >= 0 && vx < W && vy >= 0 && vy < H &&\n\t\tflds[vy][vx] && ! used[vy][vx]) {\n\t      used[vy][vx] = true;\n\t      size++;\n\t      q.push(pii(vx, vy));\n\t      if (minx > vx) minx = vx;\n\t      if (maxx < vx) maxx = vx;\n\t      if (miny > vy) miny = vy;\n\t      if (maxy < vy) maxy = vy;\n\t    }\n\t  }\n\t}\n\n\tif (false) {\n\t  printf(\"(%d,%d)-(%d,%d) %d\\n\", minx, miny, maxx, maxy, size);\n\t  for (int y = miny; y <= maxy; y++) {\n\t    for (int x = minx; x <= maxx; x++) putchar(flds[y][x] ? 'X' : '.');\n\t    putchar('\\n');\n\t  }\n\t}\n\n\tint num = -1;\n\tint dx = maxx - minx + 1, dy = maxy - miny + 1;\n\n\tif (size == 1) num = OP_MUL;\n\telse if (size == 3) num = OP_MINUS;\n\telse if (size == 5) {\n\t  if (dx == 1) num = 1;\n\t  else num = OP_PLUS;\n\t}\n\telse if (size == 7) num = 7;\n\telse if (size == 9) num = 4;\n\telse if (size == 11) {\n\t  bool b0 = flds[miny + 1][minx], b1 = flds[miny + 3][minx];\n\t  if (! b0 && b1) num = 2;\n\t  else if (! b0 && ! b1) num = 3;\n\t  else num = 5;\n\t}\n\telse if (size == 12) {\n\t  if (! flds[miny + 2][minx + 1]) num = 0;\n\t  else if (! flds[miny + 1][maxx]) num = 6;\n\t  else num = 9;\n\t}\n\telse num = 8;\n\n\te.push_back(pii(minx, num));\n      }\n\n  sort(e.begin(), e.end());\n  //for (int i = 0; i < e.size(); i++) putchar(chs(e[i].second)); putchar('\\n');\n\n  int pos = 0;\n  int ans = expr(e, pos);\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 201;\nbool black[MAX_SIZE + 2][MAX_SIZE + 2];\n\nconstexpr array<int, 4> dx{1, -1, 0, 0};\nconstexpr array<int, 4> dy{0, 0, 1, -1};\n\ntypedef array<int, 5> counter;\nmap<counter, char> converter{\n    {{{7, 5, 5, 5, 7}}, '0'},\n    {{{1, 1, 1, 1, 1}}, '1'},\n    {{{7, 4, 7, 1, 7}}, '2'},\n    {{{7, 4, 7, 4, 7}}, '3'},\n    {{{5, 5, 7, 4, 4}}, '4'},\n    {{{7, 1, 7, 4, 7}}, '5'},\n    {{{7, 1, 7, 5, 7}}, '6'},\n    {{{7, 4, 4, 4, 4}}, '7'},\n    {{{7, 5, 7, 5, 7}}, '8'},\n    {{{7, 5, 7, 4, 7}}, '9'},\n    {{{7, 2, 0, 0, 0}}, '+'},\n    {{{7, 0, 0, 0, 0}}, '-'},\n    {{{1, 0, 0, 0, 0}}, '*'}};\n\nvoid dfs(int x, int y, int bx, int by, counter &cnt) {\n    if(by <= y) cnt[y - by] += (1 << (x - bx));\n    black[y][x] = false;\n\n    for(int d = 0; d < dx.size(); ++d) {\n        const int nx = x + dx[d];\n        const int ny = y + dy[d];\n        if(black[ny][nx]) dfs(nx, ny, bx, by, cnt);\n    }\n}\n\nstring lex() {\n    string res = \"\";\n    for(int x = 1; x <= MAX_SIZE; ++x) {\n        for(int y = 1; y <= MAX_SIZE; ++y) {\n            if(black[y][x]) {\n                counter cnt;\n                cnt.fill(0);\n                dfs(x, y, x, y, cnt);\n                res += converter.at(cnt);\n            }\n        }\n    }\n    return res;\n}\n\nint parse(const string &s, int l, int r) {\n    for(int i = r - 1; i >= l; --i) {\n        if(s[i] == '+') return parse(s, l, i) + parse(s, i + 1, r);\n        if(s[i] == '-') return parse(s, l, i) - parse(s, i + 1, r);\n    }\n    for(int i = r - 1; i >= l; --i) {\n        if(s[i] == '*') return parse(s, l, i) * parse(s, i + 1, r);\n    }\n    return stoi(s.substr(l, r - l));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        ++x1; ++y1; ++x2; ++y2;\n\n        if(x1 > x2) {\n\t\t\tswap(x1, x2);\n\t\t}\n        else if(y1 > y2) {\n\t\t\tswap(y1, y2);\n\t\t}\n\n        for(int x = x1; x <= x2; ++x) {\n            for(int y = y1; y <= y2; ++y) {\n                black[y][x] = true;\n            }\n        }\n    }\n\n    const string expression = lex();\n    cout << parse(expression, 0, expression.size()) << endl;\n\n    return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\n\nconst int N = 222;\nstring s[N];\nbool vis[N][N]={};\n\nbool IN(int y, int x){\n    return 0<=y && y<N && 0<=x && x<N;\n}\n\n//  0, 1,  2,  3, 4,  5,  6, 7,  8,  9, +, -, *\n// 12, 5, 11, 11, 9, 11, 12, 7, 13, 12, 5, 3, 1\nchar GET(int y, int x, int c){\n    if(c == 1) return '*';\n    if(c == 3) return '-';\n    if(c == 5){\n        if(s[y+1][x] == 'X') return '1';\n        return '+';\n    }\n    if(c == 7) return '7';\n    if(c == 9) return '4';\n    if(c == 11){\n        // 2,3,5\n        if(s[y+3][x+2] != 'X') return '2';\n        if(s[y+1][x] != 'X') return '3';\n        return '5';\n    }\n    if(c == 12){\n        // 0,6,9\n        if(s[y+2][x+1] != 'X') return '0';\n        if(s[y+1][x+2] != 'X') return '6';\n        return '9';\n    }\n    return '8';\n}\n\nint main(){\n    rep(i,N) s[i] = string(N,'.');\n\n    int n;\n    cin >>n;\n    rep(i,n){\n        int x1,y1,x2,y2;\n        cin >>x1 >>y1 >>x2 >>y2;\n        if(x1==x2) for(int y=min(y1,y2); y<=max(y1,y2); ++y) s[y][x1]='X';\n        else for(int x=min(x1,x2); x<=max(x1,x2); ++x) s[y1][x]='X';\n    }\n\n    string a = \"\";\n    rep(x,N){\n        rep(y,N)if(s[y][x]=='X' && !vis[y][x]){\n            queue<pi> que;\n\n            vis[y][x] = true;\n            que.push({y,x});\n            int ct = 1;\n\n            while(!que.empty()){\n                pi c = que.front();\n                que.pop();\n                rep(i,4){\n                    int ny = c.fi+dy[i], nx = c.se+dx[i];\n                    if(IN(ny,nx) && s[ny][nx]=='X' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                        ++ct;\n                    }\n                }\n            }\n\n            a += GET(y,x,ct);\n        }\n    }\n\n    int A = a.size();\n    ll ans = 0;\n\n    int i = 0;\n    int m = 1;\n    ll t = 1;\n    while(i<A){\n        if(isdigit(a[i])){\n            ll v = 0;\n            while(i<A && isdigit(a[i])){\n                v = 10*v + (a[i]-'0');\n                ++i;\n            }\n            t *= v;\n        }\n        else{\n            if(a[i] == '+'){\n                ans += m*t;\n                m = 1;\n                t = 1;\n            }\n            else if(a[i] == '-'){\n                ans += m*t;\n                m = -1;\n                t = 1;\n            }\n            ++i;\n        }\n    }\n    ans += m*t;\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\n#ifdef LOCAL\n#include \"local.h\"\n#endif\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n\n\nconst char* g_zero[] = { \n    \"@@@\",\n    \"@.@\",\n    \"@.@\",\n    \"@.@\",\n    \"@@@\",\n};\nconst char* g_one[] = { \n    \"..@\",\n    \"..@\",\n    \"..@\",\n    \"..@\",\n    \"..@\",\n};\nconst char* g_two[] = { \n    \"@@@\",\n    \"..@\",\n    \"@@@\",\n    \"@..\",\n    \"@@@\",\n};\nconst char* g_three[] = { \n    \"@@@\",\n    \"..@\",\n    \"@@@\",\n    \"..@\",\n    \"@@@\",\n};\nconst char* g_four[] = { \n    \"@.@\",\n    \"@.@\",\n    \"@@@\",\n    \"..@\",\n    \"..@\",\n};\nconst char* g_five[] = { \n    \"@@@\",\n    \"@..\",\n    \"@@@\",\n    \"..@\",\n    \"@@@\",\n};\nconst char* g_six[] = { \n    \"@@@\",\n    \"@..\",\n    \"@@@\",\n    \"@.@\",\n    \"@@@\",\n};\nconst char* g_seven[] = { \n    \"@@@\",\n    \"..@\",\n    \"..@\",\n    \"..@\",\n    \"..@\",\n};\nconst char* g_eight[] = { \n    \"@@@\",\n    \"@.@\",\n    \"@@@\",\n    \"@.@\",\n    \"@@@\",\n};\nconst char* g_nine[] = { \n    \"@@@\",\n    \"@.@\",\n    \"@@@\",\n    \"..@\",\n    \"@@@\",\n};\nconst char* g_plus[] = { \n    \"...\",\n    \".@.\",\n    \"@@@\",\n    \".@.\",\n    \"...\",\n};\nconst char* g_minus[] = { \n    \"...\",\n    \"...\",\n    \"@@@\",\n    \"...\",\n    \"...\",\n};\nconst char* g_product[] = {\n    \"...\",\n    \"...\",\n    \".@.\",\n    \"...\",\n    \"...\",\n};\nset<pint> normalize(const set<pint>& s)\n{\n    set<pint> res;\n    pint o = *s.begin();\n    foreach(it, s)\n    {\n        pint t = *it;\n        t.first -= o.first;\n        t.second -= o.second;\n        res.insert(t);\n    }\n    return res;\n}\nset<pint> convert(const char** g)\n{\n    set<pint> s;\n    rep(y, 5) rep(x, 3)\n        if (g[y][x] == '@')\n            s.insert(pint(x, y));\n    return normalize(s);\n}\n\n\nchar c[256][256];\nvoid land(int x, int y, set<pint>& s)\n{\n    if (c[y][x] == '.')\n        return;\n    c[y][x] = '.';\n    s.insert(pint(x, y));\n    rep(dir, 4)\n        land(x + dx[dir], y + dy[dir], s);\n}\n\ntypedef pair<int, int> result;\n#define value first\n#define p second\n\nresult equation(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' || s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    if (s[r.p] == '+')\n        r.value += r_.value;\n    else\n        r.value -= r_.value;\n\n    r.p      = r_.p;\n  }\n  return r;\n}\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*') {\n    result r_ = term(s, r.p+1);\n    r.value *= r_.value;\n    r.p      = r_.p;\n  }\n  return r;\n}\nresult term(const string &s, int p) {\n  if (s[p] == '(') {\n    result r = equation(s, p+1);\n    r.p += 1; // skip ')'\n    return r;\n  } else {\n    int value = 0;\n    while (isdigit(s[p]))\n      value = value * 10 + (s[p++] - '0');\n    return result(value, p);\n  }\n}\n\nint eval(string e)\n{\n    return equation(e).value;\n}\n\nint main()\n{\n    map<set<pint>, char> char_table;\n#define add(g, c) char_table[convert(g)] = c\n    add(g_zero, '0');\n    add(g_one, '1');\n    add(g_two, '2');\n    add(g_three, '3');\n    add(g_four, '4');\n    add(g_five, '5');\n    add(g_six, '6');\n    add(g_seven, '7');\n    add(g_eight, '8');\n    add(g_nine, '9');\n    add(g_plus, '+');\n    add(g_minus, '-');\n    add(g_product, '*');\n\n    clr(c, '.');\n    int n;\n    cin >> n;\n    rep(i, n)\n    {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        ++x1, ++x2, ++y1, ++y2;\n        if (x1 == x2)\n        {\n            if (y1 > y2)\n                swap(y1, y2);\n            for (int y = y1; y <= y2; ++y)\n                c[y][x1] = '@';\n        }\n        else\n        {\n            if (x1 > x2)\n                swap(x1, x2);\n            for (int x = x1; x <= x2; ++x)\n                c[y1][x] = '@';\n        }\n    }\n\n\n    string expr;\n    rep(x, 250)\n    {\n        rep(y, 250)\n        {\n            if (c[y][x] == '@')\n            {\n                set<pint> pos;\n                land(x, y, pos);\n                expr += char_table[normalize(pos)];\n            }\n        }\n    }\n    cout << eval(expr) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nconst char *chars[13][5] = {\n\t{\n\t\t\"###\",\n\t\t\"#.#\",\n\t\t\"#.#\",\n\t\t\"#.#\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"..#\",\n\t\t\"..#\",\n\t\t\"..#\",\n\t\t\"..#\",\n\t\t\"..#\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"###\",\n\t\t\"#..\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"#.#\",\n\t\t\"#.#\",\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"..#\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"#..\",\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"#..\",\n\t\t\"###\",\n\t\t\"#.#\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"..#\",\n\t\t\"..#\",\n\t\t\"..#\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"#.#\",\n\t\t\"###\",\n\t\t\"#.#\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"###\",\n\t\t\"#.#\",\n\t\t\"###\",\n\t\t\"..#\",\n\t\t\"###\"\n\t},\n\t{\n\t\t\"...\",\n\t\t\".#.\",\n\t\t\"###\",\n\t\t\".#.\",\n\t\t\"...\"\n\t},\n\t{\n\t\t\"...\",\n\t\t\"...\",\n\t\t\"###\",\n\t\t\"...\",\n\t\t\"...\"\n\t},\n\t{\n\t\t\"...\",\n\t\t\"...\",\n\t\t\".#.\",\n\t\t\"...\",\n\t\t\"...\"\n\t},\n};\n\nbool b[201][201];\nbool vis[201][201];\nvpii shapes[13];\nvpii shape;\n\nvoid dfs(int i, int j) {\n\tif(vis[i][j]) return;\n\tshape.pb(mp(i,j));\n\tvis[i][j] = true;\n\tstatic const int dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\trep(d, 4) {\n\t\tint yy = i + dy[d], xx = j + dx[d];\n\t\tif(yy<0||yy>=201||xx<0||xx>=201) continue;\n\t\tif(!b[yy][xx]) continue;\n\t\tdfs(yy, xx);\n\t}\n}\n\nchar s[40001];\n\ntypedef const char *Pos;\n\ninline void expect(char c, Pos &p) {\n\tassert(*p == c);\n\t++ p;\n}\n\nint equation(Pos &p);\nint factor(Pos &p);\nint term(Pos &p);\n\nint equation(Pos &p) {\n\tint r = factor(p);\n\twhile(*p == '+' || *p == '-') {\n\t\tbool minus = *p == '-';\n\t\t++ p;\n\t\tint u = factor(p);\n\t\tif(!minus) r += u; else r -= u;\n\t}\n\treturn r;\n}\n\nint factor(Pos &p) {\n\tint r = term(p);\n\twhile(*p == '*') {\n\t\t++ p;\n\t\tint u = term(p);\n\t\tr *= u;\n\t}\n\treturn r;\n}\n\nint term(Pos &p) {\n\tint r = 0;\n\twhile(isdigit(*p)) {\n\t\tr = r * 10 + (*p - '0');\n\t\t++ p;\n\t}\n\treturn r;\n}\n\n\nint main() {\n\trep(c, 13) {\n\t\tmset(b, 0);\n\t\trep(i, 5) rep(j, 3) b[i][j] = chars[c][i][j] == '#';\n\t\tmset(vis, 0);\n\t\trep(i, 5) rep(j, 3) if(b[i][j]) {\n\t\t\tshape.clear();\n\t\t\tdfs(i, j);\n\t\t\teach(k, shape) k->first -= i, k->second -= j;\n\t\t\tsort(all(shape));\n\t\t\tshapes[c] = shape;\n//\t\t\tcerr << c << \": \";\n//\t\teach(k, shape) cerr << k->first << \", \" << k->second << \"; \"; cerr << endl;\n\t\t\tgoto outer;\n\t\t}\n\t\touter:;\n\t}\n\tmset(b, 0);\n\tint N;\n\tscanf(\"%d\", &N);\n\trep(i, N) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tif(x1 > x2) swap(x1, x2);\n\t\tif(y1 > y2) swap(y1, y2);\n\t\trer(y, y1, y2) rer(x, x1, x2)\n\t\t\tb[y][x] = true;\n\t}\n\tmset(vis, 0);\n\tvector<pair<int,int> > cs;\n\trep(i, 201) rep(j, 201) if(!vis[i][j] && b[i][j]) {\n\t\tshape.clear();\n\t\tdfs(i, j);\n\t\tint minx = INF;\n\t\teach(k, shape) amin(minx, k->second);\n\t\teach(k, shape) k->first -= i, k->second -= j;\n\t\tsort(all(shape));\n\t\tint cc = -1;\n//\t\teach(k, shape) cerr << k->first << \", \" << k->second << \"; \"; cerr << endl;\n\t\trep(c, 13) if(shapes[c] == shape) cc = c;\n\t\tif(cc == -1) cerr << \"Error: \" << i << \", \" << j << endl;\n\t\tcs.pb(mp(minx, cc));\n\t}\n\tsort(all(cs));\n\teach(i, cs)\n\t\ts[i - cs.begin()] = \"0123456789+-*\"[i->second];\n\ts[cs.size()] = 0;\n\tPos p = s;\n\tint ans = equation(p);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntypedef pair<int,int> P;\n\nnamespace NS {\n  string s;\n  int p;\n  int exp();\n  int term();\n  int fact();\n  \n  int exp() {\n    int x = term();\n    while(s[p] == '+' || s[p] == '-') {\n      if(s[p] == '+') {\n        ++p;\n        x += term();\n      } else {\n        ++p;\n        x -= term();\n      }\n    }\n    return x;\n  }\n  \n  int term() {\n    int x = fact();\n    while(s[p] == '*') {\n      ++p;\n      x *= fact();\n    }\n    return x;\n  }\n  \n  int fact() {\n    string num = \"\";\n    while(isdigit(s[p])) {\n      num += s[p++];\n    }\n    return atoi(num.c_str());\n  }\n}\n\nint parse(string s) {\n  NS::s = s + \"$\";\n  NS::p = 0;\n  int res = NS::exp();\n  assert(NS::p+1 == NS::s.size());\n  return res;\n}\n\n\nconst int MAXH = 221;\nconst int MAXW = 221;\nconst int MH = 7;\nconst int MW = 5;\nint N;\nchar G[MAXH][MAXW];\n\n\nconst string F[13][MH] = {\n  {\n    \".....\",\n    \".###.\",\n    \".#.#.\",\n    \".#.#.\",\n    \".#.#.\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".#...\",\n    \".#...\",\n    \".#...\",\n    \".#...\",\n    \".#...\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \"...#.\",\n    \".###.\",\n    \".#...\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \"...#.\",\n    \".###.\",\n    \"...#.\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".#.#.\",\n    \".#.#.\",\n    \".###.\",\n    \"...#.\",\n    \"...#.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \".#...\",\n    \".###.\",\n    \"...#.\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \".#...\",\n    \".###.\",\n    \".#.#.\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \"...#.\",\n    \"...#.\",\n    \"...#.\",\n    \"...#.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \".#.#.\",\n    \".###.\",\n    \".#.#.\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".###.\",\n    \".#.#.\",\n    \".###.\",\n    \"...#.\",\n    \".###.\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".....\",\n    \"..#..\",\n    \".###.\",\n    \"..#..\",\n    \".....\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".....\",\n    \".....\",\n    \".###.\",\n    \".....\",\n    \".....\",\n    \".....\"\n  },\n  {\n    \".....\",\n    \".....\",\n    \".....\",\n    \".#...\",\n    \".....\",\n    \".....\",\n    \".....\"\n  }\n};\n\nvoid show(int w = 101, int h = 101) {\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      cout << G[i][j];\n    }\n    cout << endl;\n  }\n}\n\nint main() {\n  cin >> N;\n  fill(G[0], G[MAXH], '.');\n  for(int k = 0; k < N; ++k) {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if(b == d) {\n      for(int i = min(a,c); i <= max(a,c); ++i) G[10+b][10+i] = '#';\n    } else {\n      for(int i = min(b,d); i <= max(b,d); ++i) G[10+i][10+a] = '#';\n    }\n  }\n\n  vector<pair<int,int> > id;\n  for(int k = 0; k < 13; ++k) {\n    pair<int,int> p(0, k);\n    for(int a = 0; a < MH; ++a) {\n      for(int b = 0; b < MW; ++b) {\n        p.first -= F[k][a][b] == '#';\n      }\n    }\n    id.push_back(p);\n  }\n  sort(id.begin(), id.end());\n\n  vector<pair<int,int> > v;\n  for(int t = 0; t < 13; ++t) {\n    int k = id[t].second;\n    for(int i = 0; i+MH <= MAXH; ++i) {\n      for(int j = 0; j+MW <= MAXW; ++j) {\n        try {\n          for(int a = 0; a < MH; ++a) {\n            for(int b = 0; b < MW; ++b) {\n              if(G[i+a][j+b] == '.' && F[k][a][b] == '#') throw 0;\n            }\n          }\n          for(int a = 0; a < MH; ++a) {\n            for(int b = 0; b < MW; ++b) {\n              if(F[k][a][b] == '#') G[i+a][j+b] = '.';\n            }\n          }\n          v.push_back(make_pair(j, k));\n        } catch(...) {}\n      }\n    }\n  }\n\n  sort(v.begin(), v.end());\n  \n  string s;\n  for(int i = 0; i < v.size(); ++i) {\n    if(v[i].second == 10) {\n      s += '+';\n    } else if(v[i].second == 11) {\n      s += '-';\n    } else if(v[i].second == 12) {\n      s += '*';\n    } else {\n      s += '0'+v[i].second;\n    }\n  }\n  //cout << s << endl;\n  cout << parse(s) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nint g[222][222],f[222][222];;\nchar s[222222];\nint sz = 0;\nint pos;\nint d[]={0,1,0,-1};\ntypedef int ll;\n\nint put(int x,int y)\n{\n  if( x < 0 || x > 200 || y < 0 || y > 200 || !g[y][x] ) return 0;\n  g[y][x] = 0;\n  int res = 1;\n  for( int i = 0; i < 4; i++ ) {\n    res += put(x+d[i],y+d[3-i]);\n  }\n  return res;\n}\n\nll number()\n{\n  ll a = 0;\n  while( isdigit(s[pos]) ) {\n    a = a*10+s[pos]-'0';\n    ++pos;\n  }\n  return a;\n}\nll fact()\n{\n  return number();\n}\n\nll term()\n{\n  ll a = number();\n  while( s[pos] == '*' ) {\n    pos += 1;\n    a *= fact();\n  }\n  return a;\n}\n\nll expr()\n{\n  ll a = term();\n  while( s[pos] == '+' || s[pos] == '-' ) {\n    char o = s[pos];\n    pos += 1;\n    ll b = term();\n    if( o == '+' ) a += b;\n    else a -= b;\n  }\n  return a;\n}\n\nll aaa()\n{\n  pos = 0;\n  return expr();\n}\n\nint main(void)\n{\n  int n;\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    int x1,y1,x2,y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n    if( x1 == x2 ) {\n      if( y2 < y1 ) swap(y1,y2);\n      for( int y = y1; y <= y2; y++ ) f[y][x1] = g[y][x1] = 1;\n    } else {\n      if( x2 < x1 ) swap(x1,x2);\n      for( int x = x1; x <= x2; x++ ) f[y1][x] = g[y1][x] = 1;\n    }\n  }\n  for( int x = 0; x <= 200; x++ ) {\n    for( int y = 0; y <= 200; y++ ) {\n      if( g[y][x] ) {\n        int c = put(x,y);\n        switch(c) {\n        case 12:\n          if( !f[y+3][x+0] ) s[sz++] = '9';\n          else if( !f[y+2][x+1] ) s[sz++] = '0';\n          else s[sz++] = '6';\n          break;\n        case 5:\n          if( f[y+1][x+0] ) s[sz++] = '1';\n          else s[sz++] = '+';\n          break;\n        case 11:\n          if( !f[y+1][x+2] ) s[sz++] = '5';\n          else if( !f[y+3][x] ) s[sz++] = '3';\n          else s[sz++] = '2';\n          break;\n        case 9:\n          s[sz++] = '4';\n          break;\n        case 7:\n          s[sz++] = '7';\n          break;\n        case 13:\n          s[sz++] = '8';\n          break;\n        case 3:\n          s[sz++] = '-';\n          break;\n        case 1:\n          s[sz++] = '*';\n          break;\n        }\n      }\n    }\n  }\n  s[sz] = 0;\n  printf(\"%d\\n\",aaa());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nstring t[] = {\n  \"111101101101111\",\n  \"\",\n  \"111001111100111\",\n  \"111001111001111\",\n  \"101101111001001\",\n  \"111100111001111\",\n  \"111100111101111\",\n  \"111001001001001\",\n  \"111101111101111\",\n  \"111101111001111\"\n};\n\nint a[250][250];\n\nstring s;\n\nint term(int &i);\nint fact(int &i);\n\nint exp(int &i) {\n  int p = term(i);\n  while(s[i]=='+' || s[i]=='-') {\n    char c = s[i++];\n    if (c == '+') {\n      int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nint term(int &i) {\n  int p = fact(i);\n  while(s[i]=='*') {\n    i++;\n    p *= fact(i);\n  }\n  return p;\n}\n\nint fact(int &i) {\n  if (s[i] == '(') {\n    i++;\n    int p = exp(i);\n    assert(s[i++]==')');\n    return p;\n  } else {\n    int num = 0;\n    while(isdigit(s[i])) {\n      num *= 10;\n      num += s[i]-'0';\n      i++;\n    }\n    return num;\n  }\n}\n\nenum Type {EXPR, TERM, FACT};\nint parse(Type t, int &i) {\n  int p;\n  if (t == EXPR) {\n    p = parse(TERM, i);\n    while(s[i]=='+' || s[i]=='-') {\n      if (s[i++] == '+') p += term(i);\n      else p -= term(i);\n    }\n  } else if (t == TERM) {\n    p = fact(i);\n    while(s[i]=='*') {\n      i++;\n      p *= fact(i);\n    }\n  } else if (t == FACT) {\n    if (s[i]=='(') {\n      i++;\n      p = exp(i);\n      assert(s[i++]==')');\n    } else { \n      p = 0;\n      while(isdigit(s[i])) {\n        p *= 10;\n        p += s[i]-'0';\n        i++;\n      }\n    }\n  }\n  return p;\n}\n\nint main() {\n  int n;\n  while(cin >> n) {\n    memset(a,0,sizeof(a));\n    REP(i,n) {\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if (x1 == x2) {\n        if (y1>y2)swap(y1,y2);\n        for (int y=y1; y<=y2; ++y) {\n          a[y][x1] = 1;\n        }\n      } else {\n        if (x1>x2)swap(x1,x2);\n        for (int x=x1; x<=x2; ++x) {\n          a[y1][x] = 1;\n        }\n      }\n    }\n    // REP(i,10) {\n    //   REP(j,10) cout << a[i][j] << \" \";\n    //   cout << endl;\n    // }\n    s = \"\";\n    const int dy[] = {-1,0,1,0};\n    const int dx[] = {0,1,0,-1};\n\n    int id = 2;\n    REP(x,250) {\n      REP(y,250) {\n        if (a[y][x] == 1) {\n          queue<pii> Q;\n          Q.push(pii(y,x));\n          a[y][x] = id;\n          int y1,x1,y2,x2;\n          y1=y2=y;\n          x1=x2=x;\n          while(!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            int cy = p.first;\n            int cx = p.second;\n            chmin(y1,cy);\n            chmax(y2,cy);\n            chmin(x1,cx);\n            chmax(x2,cx);\n            REP(i,4) {\n              int yy=cy+dy[i];\n              int xx=cx+dx[i];\n              if (valid(yy,xx,250,250)&&a[yy][xx]==1) {\n                a[yy][xx] = id;\n                Q.push(pii(yy,xx));\n              }\n            }\n          }\n          int cw = x2-x1+1;\n          int ch = y2-y1+1;\n          // cout << cw << \" \" << ch << endl;\n          if (cw == 1 && ch == 1) {\n            s += \"*\";\n          } else if (cw == 3 && ch == 1) {\n            s += \"-\";\n          } else if (cw == 3 && ch == 3) {\n            s += \"+\";\n          } else if (cw == 1 && ch == 5) {\n            s += \"1\";\n          } else {\n            REP(i,10) {\n              if (i==1) continue;\n\n              bool ok = 1;\n\n              REP(yy,5) {\n                REP(xx,3) {\n                  if (a[y1+yy][x1+xx] == id ^ t[i][yy*3+xx]=='1') {\n                    ok = 0;\n                  }\n                }\n              }\n              if (ok) {\n                s += '0' + i;\n              }\n            }\n          }\n          id++;\n        }\n      }\n    }\n\n    int i = 0;\n    cout << exp(i) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAX=1000000000;\n \nint a[201][201],d[201][201];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint t,r;\nstring s;\n \nint toInt() {\n  int x=0;\n  while(isdigit(s[t])) {\n    x*=10;\n    x+=(int)s[t]-48;\n    t++;\n  }\n  return x;\n}\n \nint multi() {\n  int x=toInt();\n  while(s.size()>=t && s[t]=='*') {\n    t++;\n    x*=toInt();\n  }\n  return x;\n}\n   \nint calc() {\n  int ans=multi();\n  while(s.size()>t) {\n    if(s[t]=='+') {\n      t++;\n      ans+=multi();\n    }\n    if(s[t]=='-') {\n      t++;\n      ans-=multi();\n    }\n  }\n  return ans;\n}\n \nvoid di(int i,int j) {\n  queue<P> que;\n  que.push(P(i,j));\n  d[i][j]=r;\n  while(!que.empty()) {\n    P p=que.front();\n    que.pop();\n    int nx=p.first,ny=p.second;\n    for(int i=0; i<4; i++) {\n      int x=nx+dx[i],y=ny+dy[i];\n      if(x>=0 && x<=200 && y>=0 && y<=200) {\n        if(a[x][y] && !d[x][y]) {\n          que.push(P(x,y));\n          d[x][y]=r;\n        }\n      }\n    }\n  }\n}\n \nchar mozi(int i,int j) {\n  di(i,j);\n  if(d[i][j+1]==r && d[i][j+2]==r && d[i][j+3]==r && d[i][j+4]==r && d[i+1][j]!=r) return '1';\n  if(d[i][j+1]!=r && d[i+1][j]!=r) return '*';\n  if(d[i+1][j]!=r) return '4';\n  if(d[i][j+1]!=r && d[i+2][j+1]!=r) {\n    if(d[i+1][j+1]!=r) return '-';\n    else return '+';\n  }\n  if(d[i+1][j+2]!=r) {\n    if(d[i][j+1]==r) return '0';\n    else return '7';\n  }\n  if(d[i+2][j+1]!=r) {\n    if(d[i][j+3]==r) return '6';\n    else return '5';\n  }\n  if(d[i][j+1]!=r) {\n    if(d[i][j+3]==r) return '2';\n    else return '3';\n  }\n  if(d[i][j+3]==r) return '8';\n  else return '9';\n}\n \nint main() {\n  for(int i=0; i<201; i++) {\n    for(int j=0; j<201; j++) {\n      a[i][j]=0;\n      d[i][j]=0;\n    }\n  }\n  t=0;\n  r=1;\n  int n;\n  cin >> n;\n  for(int i=0; i<n; i++) {\n    int x1,x2,y1,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    if(x1==x2) {\n      if(y1>y2) swap(y1,y2);\n      for(int i=y1; i<=y2; i++) a[x1][i]=1;\n    } else {\n      if(x1>x2) swap(x1,x2);\n      for(int i=x1; i<=x2; i++) a[i][y1]=1;\n    }\n  }\n  s=\"\";\n  for(int i=0; i<201; i++) {\n    for(int j=0; j<201; j++) {\n      if(a[i][j] && !d[i][j]) {\n        s+=mozi(i,j);\n        r++;\n      }\n    }\n  }\n  cout << calc() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<sstream>\nusing namespace std;\nstruct SS{\n  int ch;//true>c\n  char c;\n  int n;\n};\n\npair<int,string> to_split_int_string(string s){\n  stringstream ss(s);\n  int i;\n  ss>>i;\n  string sss;\n  ss>>sss;\n  return make_pair(i,sss);\n}\nvector<SS> conv(string s){\n  stack<SS> st;\n  vector<SS> res;\n  for(int i=0;i<s.size();i++){\n    if(s[i]<'0'||'9'<s[i]){\n      if(!st.empty()){\n        SS tmp = st.top();\n        while((tmp.c!='*'&&s[i]!='*')||tmp.c=='*'){\n          res.push_back(tmp);\n          st.pop();\n          if(st.empty())break;\n          tmp=st.top();\n        }\n      }\n      st.push(SS{1,s[i],0});\n    }else{\n      pair<int,string> tmp= to_split_int_string(s.substr(i));\n      res.push_back(SS{0,0,tmp.first});\n      s= tmp.second;\n      i=-1;\n    }\n  }\n  while(!st.empty()){\n    res.push_back(st.top());st.pop();\n  }\n  return res;\n}\n\nvoid print(vector<SS> cul){\n  for(int i=0;i<cul.size();i++){\n    if(cul[i].ch){\n      cout<<cul[i].c<<\" \";\n    }else{\n      cout<<cul[i].n<<\" \";\n    }\n  }\n  cout<<endl;\n}\n\nlong long cccc(long long a,long long b,char c){\n  switch(c){\n    case '+':return a+b;\n    case '-':return a-b;\n    case '*':return a*b;\n  }\n}\n\nint solve(vector<SS> list){\n  stack<long long> st;\n  for(int i=0;i<list.size();i++){\n    if(list[i].ch){\n      long long a = st.top();st.pop();\n      long long b = st.top();st.pop();\n      st.push(cccc(b,a,list[i].c));\n    }else{\n      st.push(list[i].n);\n    }\n  }\n  return st.top();\n}\n\nint CCC(string s){\n  vector<SS> cul = conv(s);\n  //print(cul);\n  return solve(cul);\n}\n\n\nvector<vector<int> > F;\nstring c = \"0123456789+-*\";\nvector<int> vec = {8,0,6,9,3,7,5,2,4,10,1,11,12};\nvector<vector<vector<int> > > judge={\n  {{0,0},{0,1},{0,2},{1,0},{1,2},{2,0},{2,2},{3,0},{3,2},{4,0},{4,1},{4,2}},//0\n  {{0,0},{1,0},{2,0},{3,0},{4,0}},//1\n  {{0,0},{0,1},{0,2},{1,2},{2,0},{2,1},{2,2},{3,0},{4,0},{4,1},{4,2}},//2\n  {{0,0},{0,1},{0,2},{1,2},{2,0},{2,1},{2,2},{3,2},{4,0},{4,1},{4,2}},//3\n  {{0,0},{0,2},{1,0},{1,2},{2,0},{2,1},{2,2},{3,2},{4,2}},//4\n  {{0,0},{0,1},{0,2},{1,0},{2,0},{2,1},{2,2},{3,2},{4,0},{4,1},{4,2}},//5\n  {{0,0},{0,1},{0,2},{1,0},{2,0},{2,1},{2,2},{3,0},{3,2},{4,0},{4,1},{4,2}},//6\n  {{0,0},{0,1},{0,2},{1,2},{2,2},{3,2},{4,2}},//7\n  {{0,0},{0,1},{0,2},{1,0},{1,2},{2,0},{2,1},{2,2},{3,0},{3,2},{4,0},{4,1},{4,2}},//8\n  {{0,0},{0,1},{0,2},{1,0},{1,2},{2,0},{2,1},{2,2},{3,2},{4,0},{4,1},{4,2}},//9\n  {{-1,1},{0,0},{0,1},{0,2},{1,1}},//+\n  {{0,0},{0,1},{0,2}},//-\n  {{0,0}}//dot\n};\n\nbool jj(int x,int y,vector<vector<int>> jud){\n  for(int i=0;i<jud.size();i++){\n    if(F[x+jud[i][0]][y+jud[i][1]]==0){\n      return false;\n    }\n  }\n  return true;\n}\nvoid jjfill(int x,int y,vector<vector<int>> jud){\n  for(int i=0;i<jud.size();i++){\n    F[x+jud[i][0]][y+jud[i][1]]=0;\n  }\n}\n\nchar C(int x,int y){\n  for(int i=0;i<vec.size();i++){\n    if(jj(x,y,judge[vec[i]])){\n      jjfill(x,y,judge[vec[i]]);\n      return c[vec[i]];\n    }\n  }\n  return 0;\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  F.resize(300);\n  for(int i=0;i<300;i++){\n    F[i].resize(300);\n    for(int j=0;j<300;j++){\n      F[i][j]=0;\n    }\n  }\n  for(int i=0;i<n;i++){\n    int xa,ya,xb,yb;\n    cin>>xa>>ya>>xb>>yb;\n    xa+=5;\n    xb+=5;\n    ya+=5;\n    yb+=5;\n    swap(xa,ya);\n    swap(xb,yb);\n    if(xa==xb){\n      if(ya>yb)swap(ya,yb);\n      for(int j=ya;j<=yb;j++){\n        F[xa][j]=1;\n      }\n    }else{\n      if(xa>xb)swap(xa,xb);\n      for(int j=xa;j<=xb;j++){\n        F[j][ya]=1;\n      }\n    }\n  }\n  string cul=\"\";\n  for(int i=0;i<300;i++){\n    for(int j=0;j<300;j++){\n      if(F[j][i]==1){\n        cul += C(j,i);\n        /*\n        for(int i=0;i<20;i++){\n          for(int j=0;j<100;j++){\n            cout<<(F[i][j]?'*':' ');\n          }cout<<endl;\n        }cout<<endl;\n        */\n      }\n    }\n  }\n  //cout<<cul<<endl;\n  cout<<CCC(cul)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 155\n\nstruct LOC{\n\tLOC(int arg_y,int arg_x){\n\t\ty = arg_y;\n\t\tx = arg_x;\n\t}\n\tint y,x;\n};\n\nstruct Info{\n\n\tInfo(int arg_loc,char arg_ch){\n\t\tloc = arg_loc;\n\t\tch = arg_ch;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\treturn loc < arg.loc;\n\t}\n\n\tchar ch;\n\tint loc;\n};\n\nint N;\nint H = 210,W = 210;\nint small_H = 5,small_W = 3;\n\nchar MAP[215][215];\nchar words[9][5][4] = {\n   {\"###\",\n\t\"#.#\",\n\t\"#.#\",\n\t\"#.#\",\n\t\"###\",}\n\t,\n   {\"###\",\n\t\"..#\",\n\t\"###\",\n\t\"#..\",\n\t\"###\",}\n\t,\n   {\"###\",\n\t\"..#\",\n\t\"###\",\n\t\"..#\",\n\t\"###\",}\n   ,\n   {\"#.#\",\n\t\"#.#\",\n\t\"###\",\n\t\"..#\",\n\t\"..#\",}\n\t,\n   {\"###\",\n\t\"#..\",\n\t\"###\",\n\t\"..#\",\n\t\"###\",}\n\t,\n   {\"###\",\n\t\"#..\",\n\t\"###\",\n\t\"#.#\",\n\t\"###\",}\n\t,\n\n   {\"###\",\n\t\"#.#\",\n\t\"###\",\n\t\"#.#\",\n\t\"###\",}\n   ,\n   {\"###\",\n   \t\"#.#\",\n   \t\"###\",\n   \t\"..#\",\n   \t\"###\",}\n   ,\n   {\"###\",\n  \t\"..#\",\n  \t\"..#\",\n  \t\"..#\",\n  \t\"..#\",}\n  \t,\n   \t};\nchar table[9] = {'0','2','3','4','5','6','8','9','7'};\nchar line[SIZE],work_line[SIZE];\nint diff[13] =   {0,1,0,0,0,0,0,0,0,0,0,0,1};\nint ans_len = -1;\n\nint calc_E(int left,int right);\nint calc_T(int left,int right);\nint calc_F(int left,int right);\nint calc_NUM(int left,int right);\n\n\nint calc_E(int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、プラスまたは-を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の+-がない\n\t\treturn calc_T(left,right);\n\t}\n\n\tint tmp = calc_E(left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、*,/を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の*がない\n\t\treturn calc_F(left,right);\n\t}\n\n\tint tmp = calc_T(left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '*'){\n\t\t\ttmp *= tmp_right;\n\t\t}else{\n\t\t\ttmp /= tmp_right;\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint calc_F(int left,int right){\n\n\tif(line[left] >= '0' && line[left] <= '9'){\n\t\treturn calc_NUM(left,right);\n\t}else if(line[left] == '-'){\n\t\treturn -1*calc_F(left+1,right);\n\t}else if(line[left] == '('){\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\treturn calc_E(left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(int left,int right){\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 10*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\nbool recursive(int col,int index){\n\n\tif(col == W){//探索完了\n\n\t\tfor(int i = 0; i < index; i++){\n\n\t\t\tline[i] = work_line[i];\n\t\t}\n\t\tans_len = index;\n\n\t\treturn true;\n\t}\n\n\t//この列の黒マス数を調べる\n\tint num_black = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tif(MAP[row][col] == '#'){\n\n\t\t\tnum_black++;\n\t\t}\n\t}\n\n\tif(num_black == 0){ //この行には'#'がないので、次の行へ行く\n\n\t\treturn recursive(col+1,index);\n\t}\n\n\t//どの文字かを調べる\n\n\tfor(int row = 0; row < H; row++){\n\t\tif(MAP[row][col] == '.')continue;\n\n\t\tint match_word = -1;\n\t\tvector<LOC> V_LOC;\n\n\t\t//まずはわかりやすい9種でチェック\n\t\tfor(int a = 0; a < 9; a++){\n\t\t\tbool FLG = true;\n\t\t\tV_LOC.clear();\n\t\t\tfor(int y = 0; y < small_H; y++){\n\t\t\t\tfor(int x = 0; x < small_W; x++){\n\t\t\t\t\tif(MAP[row+y][col+x] != words[a][y][x]){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(MAP[row+y][col+x] == '#'){\n\t\t\t\t\t\tV_LOC.push_back(LOC(row+y,col+x)); //塗られている場所を保存\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\t\t\tif(!FLG)continue;\n\n\t\t\tmatch_word = a;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(match_word != -1){ //一致する文字あり\n\n\t\t\t//とりあえず、黒マスを消す\n\t\t\tfor(int k = 0; k < V_LOC.size(); k++){\n\n\t\t\t\tMAP[V_LOC[k].y][V_LOC[k].x] = '.';\n\t\t\t}\n\n\t\t\t//この列の黒マスが全て消えたかを調べる\n\t\t\tfor(int tmp_row = 0; tmp_row < H; tmp_row++){\n\t\t\t\tif(MAP[tmp_row][col] == '#'){\n\n\t\t\t\t\t//状態を復元し、falseを返す\n\t\t\t\t\tfor(int k = 0; k < V_LOC.size(); k++){\n\n\t\t\t\t\t\tMAP[V_LOC[k].y][V_LOC[k].x] = '#';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//この列の黒マスは全て消えた\n\n\t\t\twork_line[index] = table[match_word];\n\n\t\t\tif(recursive(col+1,index+1)){\n\n\t\t\t\treturn true; //trueなら復元不要\n\n\t\t\t}else{\n\t\t\t\t//falseなら復元\n\t\t\t\tfor(int k = 0; k < V_LOC.size(); k++){\n\n\t\t\t\t\tMAP[V_LOC[k].y][V_LOC[k].x] = '#';\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif(MAP[row+1][col] == '#'){ //1しか該当するものがない場合\n\n\t\t\tif(num_black != 5)return false;\n\n\t\t\tfor(int tmp_row = 0; tmp_row < 5; tmp_row++){ //とりあえず黒マスを消す\n\n\t\t\t\tif(MAP[row+tmp_row][col] == '#'){\n\n\t\t\t\t\tV_LOC.push_back(LOC(row+tmp_row,col));\n\t\t\t\t}\n\n\t\t\t\tMAP[row+tmp_row][col] = '.';\n\t\t\t}\n\n\t\t\t//この列の黒マスが全て消えたかを調べる\n\t\t\tfor(int tmp_row = 0; tmp_row < H; tmp_row++){\n\t\t\t\tif(MAP[tmp_row][col] == '#'){\n\n\t\t\t\t\t//状態を復元し、falseを返す\n\t\t\t\t\tfor(int k = 0; k < V_LOC.size(); k++){\n\n\t\t\t\t\t\tMAP[V_LOC[k].y][V_LOC[k].x] = '#';\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//この列の黒マスは全て消えた\n\t\t\twork_line[index] = '1';\n\n\t\t\tif(recursive(col+1,index+1)){\n\n\t\t\t\treturn true; //trueなら復元不要\n\n\t\t\t}else{\n\t\t\t\t//falseなら復元\n\t\t\t\tfor(int k = 0; k < V_LOC.size(); k++){\n\n\t\t\t\t\tMAP[V_LOC[k].y][V_LOC[k].x] = '#';\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}else{ //[+,-,*]のいずれか\n\n\t\t\tif(num_black != 1)return false;\n\n\t\t\t//+\n\t\t\tif(MAP[row-1][col+1] == '#' && MAP[row][col+1] == '#' && MAP[row+1][col+1] == '#' && MAP[row][col+2] == '#'){\n\n\t\t\t\t//とりあえず黒マスを消す\n\t\t\t\tMAP[row][col] = '.';\n\t\t\t\tMAP[row-1][col+1] = '.';\n\t\t\t\tMAP[row][col+1] = '.';\n\t\t\t\tMAP[row+1][col+1] = '.';\n\t\t\t\tMAP[row][col+2] = '.';\n\n\t\t\t\twork_line[index] = '+';\n\n\t\t\t\tif(recursive(col+1,index+1)){\n\n\t\t\t\t\treturn true; //trueなら復元不要\n\n\t\t\t\t}else{\n\t\t\t\t\t//falseなら復元\n\t\t\t\t\tMAP[row][col] = '#';\n\t\t\t\t\tMAP[row-1][col+1] = '#';\n\t\t\t\t\tMAP[row][col+1] = '#';\n\t\t\t\t\tMAP[row+1][col+1] = '#';\n\t\t\t\t\tMAP[row][col+2] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//-\n\t\t\tif(MAP[row][col+1] == '#' && MAP[row][col+2] == '#'){\n\n\t\t\t\t//とりあえず黒マスを消す\n\t\t\t\tMAP[row][col] = '.';\n\t\t\t\tMAP[row][col+1] = '.';\n\t\t\t\tMAP[row][col+2] = '.';\n\n\t\t\t\twork_line[index] = '-';\n\n\t\t\t\tif(recursive(col+1,index+1)){\n\n\t\t\t\t\treturn true; //trueなら復元不要\n\n\t\t\t\t}else{\n\t\t\t\t\t//falseなら復元\n\t\t\t\t\tMAP[row][col] = '#';\n\t\t\t\t\tMAP[row][col+1] = '#';\n\t\t\t\t\tMAP[row][col+2] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//*\n\t\t\t//とりあえず黒マスを消す\n\t\t\tMAP[row][col] = '.';\n\n\t\t\twork_line[index] = '*';\n\n\t\t\tif(recursive(col+1,index+1)){\n\n\t\t\t\treturn true; //trueなら復元不要\n\n\t\t\t}else{\n\t\t\t\t//falseなら復元\n\t\t\t\tMAP[row][col] = '#';\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tMAP[row][col] = '.';\n\t\t}\n\t}\n\n\tscanf(\"%d\",&N);\n\n\tint x1,y1,x2,y2;\n\n\t//マップを塗る\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\n\t\tif(x1 == x2){ //縦\n\n\t\t\tfor(int y = min(y1,y2); y <= max(y1,y2); y++){\n\n\t\t\t\tMAP[y][x1] = '#';\n\t\t\t}\n\n\t\t}else{ //y1 == y2:横\n\n\t\t\tfor(int x = min(x1,x2); x <= max(x1,x2); x++){\n\n\t\t\t\tMAP[y1][x] = '#';\n\t\t\t}\n\t\t}\n\t}\n\n\trecursive(0,0);\n\n\tprintf(\"%d\\n\",calc_E(0,ans_len-1));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint analize(string str){\n  int res=0;\n  {\n    bool ok=true;\n    for(int i=0;i<(int)str.size();i++){\n      if(!(str[i]>='0'&&str[i]<='9')){\n        ok=false;\n        break;\n      }\n    }\n    if(ok){\n      return atoi(str.c_str());\n    }\n  }\n  for(int i=(int)str.size()-1;i>=0;i--){\n    if(str[i]=='+'){\n      res+=analize(str.substr(0,i));\n      res+=analize(str.substr(i+1));\n      return res;\n    }\n    else if(str[i]=='-'){\n      res+=analize(str.substr(0,i));\n      res-=analize(str.substr(i+1));\n      return res;\n    }\n  }\n  for(int i=0;i<(int)str.size();i++){\n    if(str[i]=='*'){\n      res=1;\n      res*=analize(str.substr(0,i));\n      res*=analize(str.substr(i+1));\n      return res;\n    }\n  }\n}\n\nint num_aas[10][5][3]={\n  {\n    {1,1,1},\n    {1,0,1},\n    {1,0,1},\n    {1,0,1},\n    {1,1,1}\n  },\n  {\n    {0,0,1},\n    {0,0,1},\n    {0,0,1},\n    {0,0,1},\n    {0,0,1}\n  },\n  {\n    {1,1,1},\n    {0,0,1},\n    {1,1,1},\n    {1,0,0},\n    {1,1,1}\n  },\n  {\n    {1,1,1},\n    {0,0,1},\n    {1,1,1},\n    {0,0,1},\n    {1,1,1}\n  },\n  {\n    {1,0,1},\n    {1,0,1},\n    {1,1,1},\n    {0,0,1},\n    {0,0,1}\n  },\n  {\n    {1,1,1},\n    {1,0,0},\n    {1,1,1},\n    {0,0,1},\n    {1,1,1}\n  },\n  {\n    {1,1,1},\n    {1,0,0},\n    {1,1,1},\n    {1,0,1},\n    {1,1,1}\n  },\n  {\n    {1,1,1},\n    {0,0,1},\n    {0,0,1},\n    {0,0,1},\n    {0,0,1}\n  },\n  {\n    {1,1,1},\n    {1,0,1},\n    {1,1,1},\n    {1,0,1},\n    {1,1,1}\n  },\n  {\n    {1,1,1},\n    {1,0,1},\n    {1,1,1},\n    {0,0,1},\n    {1,1,1}\n  },\n};\n\nint plus_aa[5][3]=\n  {\n    {0,0,0},\n    {0,1,0},\n    {1,1,1},\n    {0,1,0},\n    {0,0,0},\n  };\nint minus_aa[5][3]=\n  {\n    {0,0,0},\n    {0,0,0},\n    {1,1,1},\n    {0,0,0},\n    {0,0,0},\n  };\nint mul_aa[5][3]=\n  {\n    {0,0,0},\n    {0,0,0},\n    {0,1,0},\n    {0,0,0},\n    {0,0,0},\n  };\n  \nint N;\nbool field[201][201];\nbool used[201][201];\n\nchar GetMatchChar(int y,int x){\n  //cout<<y<<\" \"<<x<<endl;\n  //if(y==1)cout<<x<<endl;\n  char res=-1;\n  for(int k=0;k<10;k++){\n    bool ok=true;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(num_aas[k][i][j]==0)continue;\n        if(num_aas[k][i][j]!=(int)field[i+y][j+x])\n          ok=false;\n      }\n    }\n    if(ok)return '0'+k;\n  }\n  // +\n  {\n    //if(y==1&&x==3)cout<<\"a\"<<endl;\n    bool ok=true;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(plus_aa[i][j]==0)continue;\n        if(plus_aa[i][j]!=(int)field[i+y][j+x])\n          ok=false;\n      }\n    }\n    if(ok)return '+';\n  }\n  // -\n  {\n    bool ok=true;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(minus_aa[i][j]==0)continue;\n        if(minus_aa[i][j]!=(int)field[i+y][j+x]){\n          ok=false;\n        }\n      }\n    }\n    if(ok)return '-';\n  }\n  // *\n  {\n    bool ok=true;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(mul_aa[i][j]==0)continue;\n        if(mul_aa[i][j]!=(int)field[i+y][j+x]){\n          ok=false;\n        }\n      }\n    }\n    if(ok)return '*';\n  }\n  return res;\n}\n\nvoid dfs(int y,int x,set<pii> &st,int &miny,int &minx){\n  miny=min(miny,y);\n  minx=min(minx,x);\n  //cout<<y<<\" \"<<x<<endl;\n  used[y][x]=true;\n  st.insert(pii(y,x));\n  int dy[]={-1,0,0,1};\n  int dx[]={0,1,-1,0};\n  for(int i=0;i<4;i++){\n    int ny=dy[i]+y;\n    int nx=dx[i]+x;\n    if(ny>=0&&nx>=0&&ny<=200&&nx<=200&&!used[ny][nx]\n       &&field[ny][nx]){\n      dfs(ny,nx,st,miny,minx);\n    }\n  }\n}\n\nint main(){\n\n  map<set<pii>,char> pointsToChar;\n  for(int k=0;k<10;k++){\n    set<pii> st;\n    int miny=1<<29,minx=1<<29;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(num_aas[k][i][j]){\n          miny=min(miny,i);\n          minx=min(minx,j);\n        }\n      }\n    }\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(num_aas[k][i][j]){\n          if(miny==-1){\n            miny=i,minx=j;\n          }\n          st.insert(pii(i-miny,j-minx));\n          // if(k==1){\n          //   // cout<<\"a\"<<endl;\n          //   //cout<<i-miny<<\" \"<<j-minx<<endl;\n          // }\n        }\n      }\n    }\n    pointsToChar[st]=k+'0';\n  }\n  {\n    int miny=1<<29,minx=1<<29;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(plus_aa[i][j]){\n          miny=min(miny,i);\n          minx=min(minx,j);\n        }\n      }\n    }\n    set<pii> st;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(plus_aa[i][j]){\n          if(miny==-1){\n            miny=i,minx=j;\n          }\n          //cout<<i<<\" \"<<j<<endl;\n          st.insert(pii(i-miny,j-minx));\n          //cout<<i-miny<<\" \"<<j-minx<<endl;\n        }\n      }\n    }\n    pointsToChar[st]='+';\n  }\n  {\n    int miny=1<<29,minx=1<<29;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(minus_aa[i][j]){\n          miny=min(miny,i);\n          minx=min(minx,j);\n        }\n      }\n    }\n    set<pii> st;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(minus_aa[i][j]){\n          if(miny==-1){\n            miny=i,minx=j;\n          }\n          st.insert(pii(i-miny,j-minx));\n        }\n      }\n    }\n    pointsToChar[st]='-';\n  }\n  {\n    int miny=1<<29,minx=1<<29;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(mul_aa[i][j]){\n          miny=min(miny,i);\n          minx=min(minx,j);\n        }\n      }\n    }\n    set<pii> st;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<3;j++){\n        if(mul_aa[i][j]){\n          if(miny==-1)miny=i,minx=j;\n          st.insert(pii(i-miny,j-minx));\n        }\n      }\n    }\n    pointsToChar[st]='*';\n  }\n  \n  string cmd;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    for(int y=min(b,d);y<=max(b,d);y++)\n      for(int x=min(a,c);x<=max(a,c);x++)\n        field[y][x]=true;\n  }\n  \n  // x=0から左まで、数字か演算子があるかどうかを調べる\n  // 見つかった順番にstringを構築する\n  for(int x=0;x<=200;x++){\n    for(int y=0;y<=200;y++){\n      if(used[y][x])continue;\n      if(!field[y][x])continue;\n      // ここから深さ優先探索して，数字を取得する\n      set<pii> st;\n      int miny=1<<29,minx=1<<29;\n      dfs(y,x,st,miny,minx);\n      set<pii> tmp;\n      //cout<<y<<\" \"<<x<<endl;\n      for(pii p : st){\n        pii np=pii(p.first-miny,p.second-minx);\n        tmp.insert(np);\n        // if(y==4){\n        //   cout<<np.first<<\" \"<<np.second<<endl;\n        // }\n      }\n      st=tmp;\n      //cout<<st.size()<<endl;\n      if(pointsToChar.count(st)){\n        char ch=pointsToChar[st];\n        cmd+=ch;\n      }\n    }\n  }\n  // cmdを構文解析\n  //cout<<cmd<<endl;\n  cout<<analize(cmd)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP1(i,n) for(int i=1;i<=n;++i)\n#define ALL(c) (c).begin(),(c).end()\nbool a[210][210];\ntypedef pair<int,int> P;\nvector<P> num[13];\t\t//0~9,+,-,.\nvoid makenum(){\n\tnum[0].push_back(P(0,0));\n\tnum[0].push_back(P(0,1));\n\tnum[0].push_back(P(0,2));\n\tnum[0].push_back(P(0,3));\n\tnum[0].push_back(P(0,4));\n\tnum[0].push_back(P(1,0));\n\tnum[0].push_back(P(1,4));\n\tnum[0].push_back(P(2,0));\n\tnum[0].push_back(P(2,1));\n\tnum[0].push_back(P(2,2));\n\tnum[0].push_back(P(2,3));\n\tnum[0].push_back(P(2,4));\n\tnum[1].push_back(P(0,0));\n\tnum[1].push_back(P(0,1));\n\tnum[1].push_back(P(0,2));\n\tnum[1].push_back(P(0,3));\n\tnum[1].push_back(P(0,4));\n\tnum[2].push_back(P(0,0));\n\tnum[2].push_back(P(0,2));\n\tnum[2].push_back(P(0,3));\n\tnum[2].push_back(P(0,4));\n\tnum[2].push_back(P(1,0));\n\tnum[2].push_back(P(1,2));\n\tnum[2].push_back(P(1,4));\n\tnum[2].push_back(P(2,0));\n\tnum[2].push_back(P(2,1));\n\tnum[2].push_back(P(2,2));\n\tnum[2].push_back(P(2,4));\n\tnum[3].push_back(P(0,0));\n\tnum[3].push_back(P(0,2));\n\tnum[3].push_back(P(0,4));\n\tnum[3].push_back(P(1,0));\n\tnum[3].push_back(P(1,2));\n\tnum[3].push_back(P(1,4));\n\tnum[3].push_back(P(2,0));\n\tnum[3].push_back(P(2,1));\n\tnum[3].push_back(P(2,2));\n\tnum[3].push_back(P(2,3));\n\tnum[3].push_back(P(2,4));\n\tnum[4].push_back(P(0,0));\n\tnum[4].push_back(P(0,1));\n\tnum[4].push_back(P(0,2));\n\tnum[4].push_back(P(1,2));\n\tnum[4].push_back(P(2,0));\n\tnum[4].push_back(P(2,1));\n\tnum[4].push_back(P(2,2));\n\tnum[4].push_back(P(2,3));\n\tnum[4].push_back(P(2,4));\n\tnum[5].push_back(P(0,0));\n\tnum[5].push_back(P(0,1));\n\tnum[5].push_back(P(0,2));\n\tnum[5].push_back(P(0,4));\n\tnum[5].push_back(P(1,0));\n\tnum[5].push_back(P(1,2));\n\tnum[5].push_back(P(1,4));\n\tnum[5].push_back(P(2,0));\n\tnum[5].push_back(P(2,2));\n\tnum[5].push_back(P(2,3));\n\tnum[5].push_back(P(2,4));\n\tnum[6].push_back(P(0,0));\n\tnum[6].push_back(P(0,1));\n\tnum[6].push_back(P(0,2));\n\tnum[6].push_back(P(0,3));\n\tnum[6].push_back(P(0,4));\n\tnum[6].push_back(P(1,0));\n\tnum[6].push_back(P(1,2));\n\tnum[6].push_back(P(1,4));\n\tnum[6].push_back(P(2,0));\n\tnum[6].push_back(P(2,2));\n\tnum[6].push_back(P(2,3));\n\tnum[6].push_back(P(2,4));\n\tnum[7].push_back(P(0,0));\n\tnum[7].push_back(P(1,0));\n\tnum[7].push_back(P(2,0));\n\tnum[7].push_back(P(2,1));\n\tnum[7].push_back(P(2,2));\n\tnum[7].push_back(P(2,3));\n\tnum[7].push_back(P(2,4));\n\tnum[8].push_back(P(0,0));\n\tnum[8].push_back(P(0,1));\n\tnum[8].push_back(P(0,2));\n\tnum[8].push_back(P(0,3));\n\tnum[8].push_back(P(0,4));\n\tnum[8].push_back(P(1,0));\n\tnum[8].push_back(P(1,2));\n\tnum[8].push_back(P(1,4));\n\tnum[8].push_back(P(2,0));\n\tnum[8].push_back(P(2,1));\n\tnum[8].push_back(P(2,2));\n\tnum[8].push_back(P(2,3));\n\tnum[8].push_back(P(2,4));\n\tnum[9].push_back(P(0,0));\n\tnum[9].push_back(P(0,1));\n\tnum[9].push_back(P(0,2));\n\tnum[9].push_back(P(0,4));\n\tnum[9].push_back(P(1,0));\n\tnum[9].push_back(P(1,2));\n\tnum[9].push_back(P(1,4));\n\tnum[9].push_back(P(2,0));\n\tnum[9].push_back(P(2,1));\n\tnum[9].push_back(P(2,2));\n\tnum[9].push_back(P(2,3));\n\tnum[9].push_back(P(2,4));\n\tnum[10].push_back(P(1,-1));\n\tnum[10].push_back(P(1,0));\n\tnum[10].push_back(P(1,1));\n\tnum[10].push_back(P(2,0));\n\tnum[10].push_back(P(0,0));\n\tnum[11].push_back(P(0,0));\n\tnum[11].push_back(P(1,0));\n\tnum[11].push_back(P(2,0));\n\tnum[12].push_back(P(0,0));\n\t//8069235471+-.\n}\nint main(){\n\tmakenum();\t\t//yamipoyo\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint x1,y1,x2,y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1==x2){\n\t\t\tif(y1>y2) swap(y1,y2);\n\t\t\tfor(int j=y1;j<=y2;j++) a[x1][j]=true;\n\t\t}else{\n\t\t\tif(x1>x2) swap(x1,x2);\n\t\t\tfor(int j=x1;j<=x2;j++) a[j][y1]=true;\n\t\t}\n\t}\n\tint numn=0,pro=1,ans=0;\n\tbool plus=true;\n\trep(i,200){\n\t\trep(j,200){\n\t\t\tif(!a[i][j]) continue;\n\t\t\tint type=-1;\n\t\t\tif(!a[i+1][j]){//14.\n\t\t\t\tif(!a[i][j+1]){//.\n\t\t\t\t\ttype=12;\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i][j+3]){//1\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t}else{//4\n\t\t\t\t\t\ttype=4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{//02356789+-\n\t\t\t\tif(a[i+1][j+1]){//+\n\t\t\t\t\ttype=10;\n\t\t\t\t}else{//02356789-\n\t\t\t\t\tif(!a[i][j+1] && !a[i+2][j+1]){//-\n\t\t\t\t\t\ttype=11;\n\t\t\t\t\t}else{//02356789\n\t\t\t\t\t\tif(a[i][j+1]){//05689\n\t\t\t\t\t\t\tif(!a[i+1][j+2]){//0\n\t\t\t\t\t\t\t\ttype=0;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(a[i][j+3]){//68\n\t\t\t\t\t\t\t\t\tif(a[i+2][j+1]) type=8;\n\t\t\t\t\t\t\t\t\telse type=6;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tif(a[i+2][j+1]){//9\n\t\t\t\t\t\t\t\t\t\ttype=9;\n\t\t\t\t\t\t\t\t\t}else{//5\n\t\t\t\t\t\t\t\t\t\ttype=5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{//237\n\t\t\t\t\t\t\tif(!a[i][j+2]){//7\n\t\t\t\t\t\t\ttype=7;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(a[i][j+3]){//2\n\t\t\t\t\t\t\t\t\ttype=2;\n\t\t\t\t\t\t\t\t}else{//3\n\t\t\t\t\t\t\t\t\ttype=3;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,num[type].size()) a[i+num[type][k].first][j+num[type][k].second]=false;\n//\t\t\tcout << type << \" \" << i << \" \" << j << endl;\n\t\t\tif(type<10){\n\t\t\t\tnumn=numn*10+type;\n\t\t\t}\n\t\t\tif(type==10){\n\t\t\t\tpro*=numn;\n\t\t\t\tif(plus) ans+=pro;\n\t\t\t\telse ans-=pro;\n\t\t\t\tplus=true;\n\t\t\t\tnumn=0;\n\t\t\t\tpro=1;\n\t\t\t}\n\t\t\tif(type==11){\n\t\t\t\tpro*=numn;\n\t\t\t\tif(plus) ans+=pro;\n\t\t\t\telse ans-=pro;\n\t\t\t\tplus=false;\n\t\t\t\tnumn=0;\n\t\t\t\tpro=1;\n\t\t\t}\n\t\t\tif(type==12){\n\t\t\t\tpro*=numn;\n\t\t\t\tnumn=0;\n\t\t\t}\n//\t\t\tcout << numn << \" \" << pro << \" \" << ans << endl;\n\t\t}\n\t}\n\tpro*=numn;\n\tif(plus) ans+=pro;\n\telse ans-=pro;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int (i)=(bg);(i)<(ed);(i)++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nstruct cww {\n\tcww() {\n\t\tios::sync_with_stdio(false);\n\t\tcin.tie(0);\n\t}\n};\ntemplate<typename T>\ninline bool chmax(T& l, T r) {\n\tbool res = l < r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\ninline bool chmin(T& l, T r) {\n\tbool res = l > r;\n\tif (res)l = r;\n\treturn res;\n}\n\nconst LL INF = 1e15;\n\n\n\nint  num[15][13][2] = { \n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,0 },{ 1,2 },{ 2,0 },{ 2,2 },{ 3,0 },{ 3,2 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,0 },{ 1,0 },{ 2,0 },{ 3,0 },{ 4,0 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,2 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,0 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,2 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,2 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,0 },{ 0,2 },{ 1,0 },{ 1,2 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,2 },{ 4,2 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,0 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,2 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,0 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,0 },{ 3,2 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,2 },{ 2,2 },{ 3,2 },{ 4,2 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,0 },{ 1,2 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,0 },{ 3,2 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 },{ 1,0 },{ 1,2 },{ 2,0 },{ 2,1 },{ 2,2 },{ 3,2 },{ 4,0 },{ 4,1 },{ 4,2 } },\n\t{ { 0,1 },{ 1,0 },{ 1,1 },{ 1,2 },{ 2,1 } },\n\t{ { 0,0 },{ 0,1 },{ 0,2 } },\n\t{ { 0,0 } } \n};\nint  sz[] = { 12, 5, 11, 11, 9, 11, 12, 7, 13, 12, 5, 3, 1 };\nchar ch[] = \"0123456789+-*\";\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\nconst int M = 300;\ntypedef pair<int, int> P;\ntypedef vector<P> VP;\n#define fi first\n#define second se\n\nvector<VP> nm;\nconst int dr[] = { 0,0,1,-1 };\nconst int dc[] = { 1,-1,0,0 };\nint id = 0;\nstring s;\nint calc3() {\n\tint res = 0;\n\twhile (id < s.size()) {\n\t\tif (!isdigit(s[id]))break;\n\t\tres *= 10;\n\t\tres += s[id++] - '0';\n\t}\n\treturn res;\n}\nint calc2() {\n\tint res = 1;\n\tdo {\n\t\tif (s[id] == '*')id++;\n\t\tres *= calc3();\n\t} while (id < s.size() && s[id] == '*');\n\treturn res;\n}\nint calc1() {\n\tint res = 0;\n\tint C = 1;\n\tdo {\n\t\tif (s[id] == '+') {\n\t\t\tC = 1;\n\t\t\tid++;\n\t\t}\n\t\tif (s[id] == '-') {\n\t\t\tC = -1;\n\t\t\tid++;\n\t\t}\n\n\t\tres += C*calc2();\n\t} while (id < s.size() && (s[id] == '+'||s[id]=='-'));\n\treturn res;\n}\nint main() {\n\tVV grid(M, V(M, 0));\n\tint N;\n\tcin >> N;\n\tREP(i, 13) {\n\t\tVP v;\n\t\tREP(j, sz[i]) {\n\t\t\tP p(num[i][j][0], num[i][j][1]);\n\t\t\tv.push_back(p);\n\t\t}\n\t\tnm.push_back(v);\n\t}\n\tREP(k, N) {\n\t\tint a, b, c, d;\n\t\tcin >> b >> a >> d >> c;\n\t\ttie(a, c) = minmax({ a,c });\n\t\ttie(b, d) = minmax({ b,d });\n\n\t\tFOR(i, a, c + 1)FOR(j, b, d + 1)grid[i+1][j+1] = 1;\n\t}\n\tqueue<P> que;\n\tREP(c, M)REP(r, M)if (grid[r][c]) {\n\t\tconst int rr = r;\n\t\tconst int cc = c;\n\t\tque.push(P(r, c));\n\t\tint ar = r;\n\t\tint ac = c;\n\t\tgrid[ar][ac] = 0;\n\t\tvector<P> v;\n\t\tv.push_back(P(ar-rr, ac-cc));\n\t\twhile (que.size()) {\n\t\t\ttie(ar, ac) = que.front(); que.pop();\n\t\t\tREP(i, 4) {\n\t\t\t\tint nr = ar + dr[i];\n\t\t\t\tint nc = ac + dc[i];\n\t\t\t\tif (grid[nr][nc] == 1) {\n\t\t\t\t\tque.push(P(nr, nc));\n\t\t\t\t\tv.push_back(P(nr-rr, nc-cc));\n\t\t\t\t\tgrid[nr][nc] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = 0;\n\t\tfor (auto &it : v)chmin(x, it.fi);\n\t\tfor (auto &it : v)it.fi -= x;\n\n\t\tsort(ALL(v));\n\t\tREP(i, 13)if (v == nm[i])s += ch[i];\n\t}\n\t//cout << s << endl;\n\tcout << calc1() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <cctype>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstruct Line {\n\tint x1, y1, x2, y2;\n};\n\nconst int INF = 1000000000;\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nconst int table[13][5][3] = {\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 0, 0 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 0, 0, 1 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 0 },\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 0, 0, 1 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 1, 0, 1 },\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 1 },\n\t\t{ 1, 1, 1 }\n\t},\n\t{\n\t\t{ 0, 1, 0 },\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 1, 0 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 }\n\t},\n\t{\n\t\t{ 1, 1, 1 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 }\n\t},\n\t{\n\t\t{ 1, 0, 0 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 },\n\t\t{ 0, 0, 0 }\n\t}\n};\n\npii lex_expr(const char *s, int p);\npii lex_term(const char *s, int p);\npii lex_number(const char *s, int p);\n\npii lex_expr(const char *s, int p){\n\tpii r = lex_term(s, p);\n\tp = r.second;\n\twhile(s[p] == '+' || s[p] == '-'){\n\t\tpii q = lex_term(s, p + 1);\n\t\tif(s[p] == '+'){\n\t\t\tr.first += q.first;\n\t\t}else{\n\t\t\tr.first -= q.first;\n\t\t}\n\t\tp = q.second;\n\t}\n\tr.second = p;\n\treturn r;\n}\npii lex_term(const char *s, int p){\n\tpii r = lex_number(s, p);\n\tp = r.second;\n\twhile(s[p] == '*'){\n\t\tpii q = lex_number(s, p + 1);\n\t\tr.first *= q.first;\n\t\tp = q.second;\n\t}\n\tr.second = p;\n\treturn r;\n}\npii lex_number(const char *s, int p){\n\tint x = 0;\n\twhile(isdigit(s[p])){\n\t\tx = (x * 10) + s[p++] - '0';\n\t}\n\treturn pii(x, p);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector< vector<int> > grid(210, vector<int>(210));\n\tfor(int i = 0; i < n; ++i){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1 > x2){ swap(x1, x2); }\n\t\tif(y1 > y2){ swap(y1, y2); }\n\t\tif(y1 == y2){\n\t\t\tfor(int x = x1; x <= x2; ++x){ grid[y1][x] = 1; }\n\t\t}else{\n\t\t\tfor(int y = y1; y <= y2; ++y){ grid[y][x1] = 1; }\n\t\t}\n\t}\n\tstring s;\n\tfor(int j = 0; j < grid[0].size(); ++j){\n\t\tfor(int i = 0; i < grid.size(); ++i){\n\t\t\tif(grid[i][j] == 0){ continue; }\n\t\t\tint mx = j, my = i;\n\t\t\tvector<pii> ps;\n\t\t\tqueue<pii> q;\n\t\t\tq.push(pii(i, j));\n\t\t\tps.push_back(pii(i, j));\n\t\t\tgrid[i][j] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tconst pii p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor(int d = 0; d < 4; ++d){\n\t\t\t\t\tconst int y = p.first + dy[d], x = p.second + dx[d];\n\t\t\t\t\tif(y < 0 || x < 0 || grid[y][x] == 0){ continue; }\n\t\t\t\t\tgrid[y][x] = 0;\n\t\t\t\t\tps.push_back(pii(y, x));\n\t\t\t\t\tq.push(pii(y, x));\n\t\t\t\t\tmx = min(mx, x);\n\t\t\t\t\tmy = min(my, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p[5][3] = { { 0 } };\n\t\t\tfor(int k = 0; k < ps.size(); ++k){\n\t\t\t\tp[ps[k].first - my][ps[k].second - mx] = 1;\n\t\t\t}\n\t\t\tint c = -1;\n\t\t\tfor(int k = 0; k < 13; ++k){\n\t\t\t\tbool match = true;\n\t\t\t\tfor(int y = 0; y < 5; ++y){\n\t\t\t\t\tfor(int x = 0; x < 3; ++x){\n\t\t\t\t\t\tif(p[y][x] != table[k][y][x]){ match = false; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(match){ c = k; }\n\t\t\t}\n\t\t\tif(0 <= c && c < 10){\n\t\t\t\ts += '0' + c;\n\t\t\t}else if(c == 10){\n\t\t\t\ts += '+';\n\t\t\t}else if(c == 11){\n\t\t\t\ts += '-';\n\t\t\t}else if(c == 12){\n\t\t\t\ts += '*';\n\t\t\t}\n\t\t}\n\t}\n\tcout << lex_expr(s.c_str(), 0).first << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\n\nconst bool chs[5][13][3] ={\n\t{\n\t\t{1, 1, 1},\n\t\t{1, 0, 0},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 0, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{0, 1, 0},//\n\t\t{1, 1, 1},\n\t\t{1, 0, 0},\n\t},\n\t{\n\t\t{1, 0, 1},\n\t\t{1, 0, 0},\n\t\t{0, 0, 1},\n\t\t{0, 0, 1},\n\t\t{1, 0, 1},\n\t\t{1, 0, 0},\n\t\t{1, 0, 0},\n\t\t{0, 0, 1},\n\t\t{1, 0, 1},\n\t\t{1, 0, 1},\n\t\t{1, 1, 1},//\n\t\t{0, 0, 0},\n\t\t{0, 0, 0},\n\t},\n\t{\n\t\t{1, 0, 1},\n\t\t{1, 0, 0},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{0, 0, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{0, 1, 0},//\n\t\t{0, 0, 0},\n\t\t{0, 0, 0},\n\t},\n\t{\n\t\t{1, 0, 1},\n\t\t{1, 0, 0},\n\t\t{1, 0, 0},\n\t\t{0, 0, 1},\n\t\t{0, 0, 1},\n\t\t{0, 0, 1},\n\t\t{1, 0, 1},\n\t\t{0, 0, 1},\n\t\t{1, 0, 1},\n\t\t{0, 0, 1},\n\t\t{0, 0, 0},//\n\t\t{0, 0, 0},\n\t\t{0, 0, 0},\n\t},\n\t{\n\t\t{1, 1, 1},\n\t\t{1, 0, 0},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{0, 0, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{0, 0, 1},\n\t\t{1, 1, 1},\n\t\t{1, 1, 1},\n\t\t{0, 0, 0},//\n\t\t{0, 0, 0},\n\t\t{0, 0, 0},\n\t},\n};\n\n\nconst int h = 300, w = 300;\nint n;\nbool a[300][300], v[300][300], b[5][4];\n\nvoid dfs(int y, int x, int i = 0, int j = 1){\n\tconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\n\t\n\tv[y][x] = 1;\n\tb[i][j] = 1;\n\t\n\trep(d, 4){\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\n\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\tif(!a[ny][nx] || v[ny][nx]) continue;\n\t\t\n\t\tdfs(ny, nx, i + dy[d], j + dx[d]);\n\t}\n}\n\nbool ok(int d){\n\t\n\trep(i, 5) rep(j, 3){\n\t\t\n\t\tif(chs[i][d][j] != b[i][j + (d != 10)]) return 0;\n\t}\n\treturn 1;\n}\n\nstring s;\nint p;\n\nint number(){\n\tint res = 0;\n\twhile(p < s.size() && isdigit(s[p])) res *= 10, res += s[p++] - '0';\n\treturn res;\n}\nint term(){\n\tint res = 1;\n\t\n\twhile(1){\n\t\tint n = number();\n\t\tres *= n;\n\t\tif(p >= s.size() || s[p] != '.') break;\n\t\tp++;\n\t}\n\treturn res;\n}\nint expr(){\n\tint res = 0;\n\tbool mi = 0;\n\t\n\twhile(1){\n\t\tint n = term();\n\t\t\n\t\tif(mi) res -= n;\n\t\telse res += n;\n\t\t\n\t\tif(p >= s.size()) break;\n\t\tmi = s[p++] == '-';\n\t}\n\treturn res;\n}\n\n\n\nint main(){\n\tcin >> n;\n\trep(i, n){\n\t\tint x, y, X, Y;\n\t\tcin >> x >> y >> X >> Y;\n\t\t\n\t\tif(x > X) swap(x, X);\n\t\tif(y > Y) swap(y, Y);\n\t\t\n\t\tif(x == X) for(int i = y; i <= Y; i++) a[i][x] = 1;\n\t\telse for(int i = x; i <= X; i++) a[y][i] = 1;\n\t}\n\t\n\tvector<pair<int, char> > cs;\n\t\n\trep(i, h) rep(j, w) if(!v[i][j] && a[i][j]){\n\t\t\n\t\t//cerr<<\"i: \"<<i<<\" j: \"<<j<<endl;\n\t\t\n\t\tmemset(b, 0, sizeof(b));\n\t\tdfs(i, j);\n\t\t\n\t\trep(k, 13) if(ok(k)){\n\t\t\tcs.pb(mp(j, \"0123456789+-.\"[k]));\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tsort(all(cs));\n\trep(i, cs.size()) s += cs[i].second;\n\t\n\t//dbg(s);\n\tcout << expr() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nbool table[210][210];\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring S;\nsize_t cur=0;\n\nint term();\nint expression();\n\nint digit(){\n//\tassert(isdigit(S[cur])); \n\tint n = S[cur] - '0'; \n\tcur++; \n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(cur <S.size() && isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nint factor() {\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n//\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint term(){\n\tint sum = factor();\n\twhile(S[cur] == '*' || S[cur] == '/'){\n\t\tchar op = S[cur];\n\t\tcur += 1;\n\t\tint b = factor();\n\t\tif( op == '*')\n\t\t\tsum*=b;\n\t\telse {\n//\t\t\tassert(b);\n\t\t\tsum/=b;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(S[cur] == '+' || S[cur] == '-'){\n\t\tchar op = S[cur];\n\t\tcur += 1;\n\t\tint b = term();\n\t\tif( op == '+')\n\t\t\tsum+=b;\n\t\telse \n\t\t\tsum-=b;\n\t}\n\treturn sum;\n}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tint x1,y1,x2,y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1==x2){\n\t\t\tif(y1>y2) swap(y1,y2);\n\t\t\tfor(int j=y1;j<=y2;j++)\n\t\t\t\ttable[x1][j]=true;\n\t\t}else{\n\t\t\tif(x1>x2) swap(x1,x2);\n\t\t\tfor(int j=x1;j<=x2;j++)\n\t\t\t\ttable[j][y1]=true;\n\t\t}\n\t}\n\tS=\"\";\n\trep(i,200+1)rep(j,200+1){\n\t\t\tif(table[i][j]){\n\t\t\t\tint rec=0;\n\t\t\t\trep(k,3)rep(l,5){ rec+=table[i+k][j+l]; }\n\t\t\t\t\n\t\t\t\tint tmp=table[i+1][j+1]+table[i+1][j+3];\n\t\t\t\t\n\t\t\t\tif(rec==13&&tmp==0){\n\t\t\t\t\tS+='8';\n\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t}else if(rec==12){\n\t\t\t\t\tif(tmp+table[i+1][j+2]==0){\n\t\t\t\t\t\tS+='0';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}else if(tmp+table[i][j+3]==0){\n\t\t\t\t\t\tS+='9';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}else if(tmp+table[i+2][j+1]==0){\n\t\t\t\t\t\tS+='6';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}\n\t\t\t\t}else if(rec==11){\n\t\t\t\t\tif(tmp+table[i][j+1]+table[i+2][j+3]==0){\n\t\t\t\t\t\tS+='2';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}else if(tmp+table[i][j+1]+table[i][j+3]==0){\n\t\t\t\t\t\tS+='3';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}else if(tmp+table[i+2][j+1]+table[i][j+3]==0){\n\t\t\t\t\t\tS+='5';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}\n\t\t\t\t}else if(rec==9){\n\t\t\t\t\tif(tmp+table[i+1][j]+table[i][j+3]+table[i][j+4]+table[i+1][j+4]==0){\n\t\t\t\t\t\tS+='4';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}\n\t\t\t\t}else if(rec==7){\n\t\t\t\t\tif(tmp+table[i][j+1]+table[i][j+2]+table[i+1][j+2]+table[i][j+3]+table[i][j+4]+table[i+1][j+4]==0){\n\t\t\t\t\t\tS+='7';\n\t\t\t\t\t\trep(k,3)rep(l,5){ table[i+k][j+l]=false;}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(table[i][j]+table[i][j+1]+table[i][j+2]+table[i][j+3]+table[i][j+4]==5){\n\t\t\t\t\t\tS+='1';\n\t\t\t\t\t\trep(l,5){ table[i][j+l]=false;}\n\t\t\t\t\t}else if(table[i][j]+table[i+1][j-1]+table[i+1][j]+table[i+1][j+1]+table[i+2][j]==5){\n\t\t\t\t\t\tS+='+';\n\t\t\t\t\t\ttable[i][j]=false;\n\t\t\t\t\t\ttable[i+1][j-1]=false;\n\t\t\t\t\t\ttable[i+1][j]=false;\n\t\t\t\t\t\ttable[i+1][j+1]=false;\n\t\t\t\t\t\ttable[i+2][j]=false;\n\t\t\t\t\t}else if(table[i][j]+table[i+1][j]+table[i+2][j]==3){\n\t\t\t\t\t\tS+='-';\n\t\t\t\t\t\ttable[i][j]=false;\n\t\t\t\t\t\ttable[i+1][j]=false;\n\t\t\t\t\t\ttable[i+2][j]=false;\n\t\t\t\t\t}else{ \n\t\t\t\t\t\tS+='*';\n\t\t\t\t\t\ttable[i][j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcout << expression() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\n\nint S=203;\n\nvector<pair<int,int>> dfs(const vector<vector<int>>&field, vector<vector<int>>&used, int y, int x) {\n\tif(used[y][x])return vector<pair<int,int>>(0);\n\telse {\n\t\tvector<pair<int,int>>anss(1,make_pair(x,y));\n\t\tused[y][x]=true;\n\t\tint dx[] = { -1,0,1,0 };\n\t\tint dy[] = { 0,1,0,-1 };\n\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tint nexty=y+dy[way];\n\t\t\tint nextx=x+dx[way];\n\n\t\t\tif (field[nexty][nextx]) {\n\t\t\t\tauto p=dfs(field,used,nexty,nextx);\n\t\t\t\tanss.insert(anss.end(),p.begin(),p.end());\n\t\t\t}\n\t\t}\n\t\treturn anss;\n\t}\n}\n\nchar check(vector<pair<int, int>>v) {\n\tint sz=v.size();\n\tint xsum=0;\n\tint ysum=0;\n\tsort(v.begin(),v.end());\n\tfor (auto p : v) {\n\t\txsum+=p.first;\n\t\tysum+=p.second;\n\t}\n\tif (sz == 1) {\n\t\treturn '*';\n\t}\n\telse if (sz == 3) {\n\t\treturn '-';\n\t}\n\telse if (sz == 5) {\n\t\tif(xsum==0)return '1';\n\t\telse return '+';\n\t}\n\telse if (sz == 7) {\n\t\treturn '7';\n\t}\n\telse if (sz == 9) {\n\t\treturn '4';\n\t}\n\telse if (sz == 11) {\n\t\tif (xsum == 13) {\n\t\t\treturn '3';\n\t\t}else {\n\t\t\tassert(xsum==11);\n\t\t\tauto it=find(v.begin(),v.end(),make_pair(0,1));\n\t\t\tif(it==v.end())return '2';\n\t\t\telse return '5';\n\t\t}\n\n\t}\n\telse if (sz == 12) {\n\t\tif (xsum == 11)return '6';\n\t\tif (xsum == 12)return '0';\n\t\t{\n\t\t\tassert(xsum == 13);\n\t\t\treturn '9';\n\t\t}\n\t}\n\telse {\n\t\tassert(xsum==13);\n\t\treturn '8';\n\t}\n\n}\n\nstring st;\nint a=0;\n\nint num() {\n\tassert(isdigit(st[a]));\n\tint num=0;\n\twhile (st.size() != a&&isdigit(st[a])) {\n\t\tnum*=10;\n\t\tnum+=st[a]-'0';\n\t\ta++;\n\t}\n\treturn num;\n}\nint mul() {\n\tint k=num();\n\twhile (st.size() != a&&st[a] == '*') {\n\t\ta++;\n\t\tint x=num();\n\t\tk*=x;\n\t}\n\treturn k;\n}\n\nint calc() {\n\tint k=mul();\n\twhile (st.size() != a&&(st[a] == '+'||st[a]=='-')) {\n\t\tchar ch = st[a];\n\t\ta++;\n\t\t\n\t\tint x=mul();\n\t\tif(ch=='-')k-=x;\n\t\telse {\n\t\t\tassert(ch=='+');\n\t\t\tk+=x;\n\t\t}\n\t\t\n\t}\n\treturn k;\n}\nint main() {\n\t\n\tvector<vector<int>>field(S,vector<int>(S));\n\t{\n\n\t\tint N;cin>>N;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint sx,sy;cin>>sx>>sy;\n\t\t\tint gx,gy;cin>>gx>>gy;\n\t\t\tsx++;sy++;gx++;gy++;\n\t\t\tif (sx == gx) {\n\t\t\t\tif(sy>gy)swap(sy,gy);\n\t\t\t\tfor (int y = sy,x=sx; y <= gy; ++y) {\n\t\t\t\t\tfield[y][x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(sx>gx)swap(sx,gx);\n\t\t\t\tfor (int x = sx,y=sy; x <= gx; ++x) {\n\t\t\t\t\tfield[y][x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t{\n\t\tmap<int, char>mp;\n\t\tvector<vector<int>>used(S,vector<int>(S));\n\t\tfor (int x = 1; x < S - 1; ++x) {\n\t\t\tfor (int y = 1; y < S - 1; ++y) {\n\t\t\t\tif (!used[y][x]&&field[y][x]) {\n\t\t\t\t\tauto v=dfs(field,used,y,x);\n\t\t\t\t\tint ay=1e8;\n\t\t\t\t\tfor (auto &p : v) {\n\t\t\t\t\t\tay=min(ay,p.second);\n\t\t\t\t\t}\n\t\t\t\t\tfor (auto &p : v) {\n\t\t\t\t\t\tp.first-=x;\n\t\t\t\t\t\tp.second-=ay;\n\t\t\t\t\t}\n\t\t\t\t\tmp[x]=check(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto m : mp) {\n\t\t\tst.push_back(m.second);\n\t\t}\n\t}\n\tint answer=calc();\n\tcout<<answer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1529: Cheat Case\n// 2019.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define gc() getchar()\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nchar exp[1000], *bp;\n\nint factor()\n{\n\tint n = 0;\n\twhile (*bp >= '0' && *bp <= '9') n = 10 * n + (*bp++ - '0');\n\treturn n;\n}\n\nint term()\n{\n\tint x, y;\n\tx = factor();\n\twhile (1) {\n\t\tif (*bp != '*') break;\n\t\tbp++;\n\t\ty = factor();\n\t\tx *= y;\n\t}\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\tx = term();\n\twhile (1) {\n\t\tif (*bp == '+') op = 1;\n\t\telse if (*bp == '-') op = 0;\n\t\telse break;\n\t\tbp++;\n\t\ty = term();\n\t\tif (op) x += y; else x -= y;\n\t}\n\treturn x;\n}\n\nchar pat[13][5][3] = {\n/*0*/ {{1,1,1},{1,0,1},{1,0,1},{1,0,1},{1,1,1}},\n/*1*/ {{1,0,2},{1,0,2},{1,0,2},{1,0,2},{1,0,2}},\n/*2*/ {{1,1,1},{0,0,1},{1,1,1},{1,0,0},{1,1,1}},\n/*3*/ {{1,1,1},{0,0,1},{1,1,1},{0,0,1},{1,1,1}},\n/*4*/ {{1,0,1},{1,0,1},{1,1,1},{0,0,1},{2,0,1}},\n/*5*/ {{1,1,1},{1,0,0},{1,1,1},{0,0,1},{1,1,1}},\n/*6*/ {{1,1,1},{1,0,0},{1,1,1},{1,0,1},{1,1,1}},\n/*7*/ {{1,1,1},{0,0,1},{2,0,1},{2,0,1},{2,0,1}},\n/*8*/ {{1,1,1},{1,0,1},{1,1,1},{1,0,1},{1,1,1}},\n/*9*/ {{1,1,1},{1,0,1},{1,1,1},{0,0,1},{1,1,1}},\n/*+*/ {{0,1,0},{1,1,1},{0,1,0}},\n/*-*/ {{1,1,1}},\n/*.*/ {{1,0,0}}\n};\n\nchar a[210][210];\n\nint match(int r0, int c0, int id, int h, int w)\n{\n\tint r, c;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++)\n\t\tif (pat[id][r][c] != 2 && a[r0 + r][c0 + c] != pat[id][r][c]) return 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++)\n\t\tif (pat[id][r][c] == 1) a[r0 + r][c0 + c] = 0;\n\treturn 1;\n}\n\nint main()\n{\n\tint i, r, c, N, H, W;\n\tint t, x1, y1, x2, y2;\n\n\tN = in(), H = W = 0;\n\tfor (i = 0; i < N; i++) {\n\t\tx1 = in(), y1 = in(), x2 = in(), y2 = in();\n\t\tif (x1 > W) W = x1;\n\t\tif (x2 > W) W = x2;\n\t\tif (y1 > H) H = y1;\n\t\tif (y2 > H) H = y2;\n\t\tif (x1 == x2) {\n\t\t\tif (y1 > y2) t = y1, y1 = y2, y2 = t;\n\t\t\twhile (y1 <= y2) a[y1++][x1] = 1;\n\t\t}\n\t\telse {\n\t\t\tif (x1 > x2) t = x1, x1 = x2, x2 = t;\n\t\t\twhile (x1 <= x2) a[y1][x1++] = 1;\n\t\t}\n\t}\n\n\tbp = exp;\n\tfor (c = 0; c <= W; c++) for (r = 0; r <= H; r++) {\n\t\tif (a[r][c] == 0) continue;\n\t\tfor (i = 0; i <= 9; i++) {\n\t\t\tif (match(r, c, i, 5, 3)) {\n\t\t\t\t*bp++ = i + '0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i > 9) {\n\t\t\tif (r > 0 && match(r-1, c, 10, 3, 3)) *bp++ = '+';\n\t\t\telse if (match(r, c, 11, 1, 3)) *bp++ = '-';\n\t\t\telse if (match(r, c, 12, 1, 1)) *bp++ = '*';\n\t\t\telse {\n\t\t\t\tprintf(\"Panic!!!\\n\"); return -1;\n\t\t\t}\n\t\t}\n\t}\n\t*bp = 0, bp = exp;\n\tprintf(\"%d\\n\", expr());\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "dic = {((0, 0), (0, 1), (0, 2), (0, 3), (0, 4),\n        (1, 0), (1, 4),\n        (2, 0), (2, 1), (2, 2), (2, 3), (2, 4)):\"0\",\n\n       ((0, 0), (0, 1), (0, 2), (0, 3), (0, 4)):\"1\",\n\n       ((0, 0), (0, 2), (0, 3), (0, 4),\n        (1, 0), (1, 2), (1, 4),\n        (2, 0), (2, 1), (2, 2), (2, 4)):\"2\",\n\n       ((0, 0), (0, 2), (0, 4),\n        (1, 0), (1, 2), (1, 4),\n        (2, 0), (2, 1), (2, 2), (2, 3), (2, 4)):\"3\",\n\n       ((0, 0), (0, 1), (0, 2),\n        (1, 2),\n        (2, 0), (2, 1), (2, 2), (2, 3), (2, 4)):\"4\",\n\n       ((0, 0), (0, 1), (0, 2), (0, 4),\n        (1, 0), (1, 2), (1, 4),\n        (2, 0), (2, 2), (2, 3), (2, 4)):\"5\",\n\n       ((0, 0), (0, 1), (0, 2), (0, 3), (0, 4),\n        (1, 0), (1, 2), (1, 4),\n        (2, 0), (2, 2), (2, 3), (2, 4)):\"6\",\n\n       ((0, 0), \n        (1, 0),\n        (2, 0), (2, 1), (2, 2), (2, 3), (2, 4)):\"7\",\n\n       ((0, 0), (0, 1), (0, 2), (0, 3), (0, 4),\n        (1, 0), (1, 2), (1, 4),\n        (2, 0), (2, 1), (2, 2), (2, 3), (2, 4)):\"8\",\n\n       ((0, 0), (0, 1), (0, 2), (0, 4),\n        (1, 0), (1, 2), (1, 4),\n        (2, 0), (2, 1), (2, 2), (2, 3), (2, 4)):\"9\",\n\n       ((0, 0),\n        (1, -1), (1, 0), (1, 1),\n        (2, 0)):\"+\",\n\n       ((0, 0),\n        (1, 0), \n        (2, 0)):\"-\",\n\n       ((0, 0), ):\"*\"}\n\n\nn = int(input())\nmp = [[0] * 201 for _ in range(201)]\nfor _ in range(n):\n  x1, y1, x2, y2 = map(int, input().split())\n  if x1 == x2:\n    y1, y2 = min(y1, y2), max(y1, y2)\n    for y in range(y1, y2 + 1):\n      mp[y][x1] = 1\n\n  elif y1 == y2:\n    x1, x2 = min(x1, x2), max(x1, x2)\n    for x in range(x1, x2 + 1):\n      mp[y1][x] = 1\n\nchecked = [[False] * 201 for _ in range(201)]\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n\n\ndef search(x, y, ix, iy, stack):\n  for dx, dy in vec:\n    if not 0 <= y + dy < 201 or not 0 <= x + dx < 201:continue\n    if mp[y + dy][x + dx] == 1 and not checked[y + dy][x + dx]:\n      checked[y + dy][x + dx] = True\n      stack.append((x + dx - ix, y + dy - iy))\n      search(x + dx, y + dy, ix, iy, stack)\n\ns = \"\"\nfor x in range(201):\n  for y in range(201):\n    if mp[y][x] == 1 and not checked[y][x]:\n      checked[y][x] = True\n      stack = [(0, 0)]\n      search(x, y, x, y, stack)\n      stack.sort()\n      s += dic[tuple(stack)]\n\nprint(eval(s))\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet};\nuse std::fmt::{Display, Formatter, Error};\nuse ::State::Either;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nenum State {\n    Black, White, Either\n}\nimpl Display for State  {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        match self {\n            &State::Black => write!(f, \"B\"),\n            &State::White => write!(f, \"W\"),\n            &State::Either => write!(f, \"E\"),\n        }\n    }\n}\nfn is_match(state: &[[bool; 201]; 201], x: usize, y: usize, character: &[[State; 5]; 7]) -> bool {\n    for i in 0 .. 7 {\n        for j in 0 .. 5 {\n            match character[i][j] {\n                State::Black if x + j < 1 || 201 < x + j || y + i < 1 || 201 < y + i || state[y + i - 1][x + j - 1] == false => return false,\n                State::White if 1 <= x + j && x + j <= 201 && 1 <= y + i && y + i <= 201 && state[y + i - 1][x + j - 1] => return false,\n                _ => {}\n            }\n        }\n    }\n    true\n}\nfn to_pattern(character: &[[bool; 3]; 5]) -> [[State; 5]; 7] {\n    let mut result = [[State::Either; 5]; 7];\n    for y in 1 .. 6 {\n        for x in 1 .. 4 {\n            if character[y - 1][x - 1] {\n                result[y][x] = State::Black;\n                if result[y + 1][x] != State::Black {\n                    result[y + 1][x] = State::White;\n                }\n                if result[y - 1][x] != State::Black {\n                    result[y - 1][x] = State::White;\n                }\n                if result[y][x + 1] != State::Black {\n                    result[y][x + 1] = State::White;\n                }\n                if result[y][x - 1] != State::Black {\n                    result[y][x - 1] = State::White;\n                }\n            }\n        }\n    }\n    result\n}\nfn parse(state: &[[bool; 201];201]) -> Vec<char> {\n    let zero = to_pattern( &[[true, true, true], [true, false, true], [true, false, true], [true, false, true], [true, true, true]]);\n    let one = to_pattern(&[[true, false, false],[true, false, false],[true, false, false],[true, false, false],[true, false, false]]);\n    let two = to_pattern(&[[true, true, true], [false, false, true], [true, true, true], [true, false, false], [true, true, true]]);\n    let three = to_pattern(&[[true, true, true], [false, false, true], [true, true, true], [false, false, true], [true, true, true]]);\n    let four = to_pattern(&[[true, false, true], [true, false, true], [true, true, true], [false, false, true], [false, false, true]]);\n    let five = to_pattern(&[[true, true, true], [true, false, false], [true, true, true], [false, false, true], [true, true, true]]);\n    let six = to_pattern(&[[true, true, true], [true, false, false], [true, true, true], [true, false, true], [true, true, true]]);\n    let seven = to_pattern(&[[true, true, true], [false, false, true], [false, false, true], [false, false, true], [false, false, true]]);\n    let eight = to_pattern(&[[true, true, true], [true, false, true], [true, true, true], [true, false, true], [true, true, true]]);\n    let nine = to_pattern(&[[true, true, true], [true, false, true], [true, true, true], [false, false, true], [true, true, true]]);\n    let plus = to_pattern(&[[false, true, false], [true, true, true], [false, true, false], [false, false, false], [false, false, false]]);\n    let minus = to_pattern(&[[true, true, true], [false, false, false], [false, false, false], [false, false, false], [false, false, false]]);\n    let times = to_pattern(&[[true, false, false], [false, false, false], [false, false, false], [false, false, false], [false, false, false]]);\n    let mut result = Vec::new();\n    for x in 0 .. 201 {\n        for y in 0 .. 201 {\n            if is_match(state, x, y,&zero) {\n                result.push('0');\n            }else if is_match(state, x, y, &one) {\n                result.push('1');\n            }else if is_match(state, x, y, &two) {\n                result.push('2');\n            }else if is_match(state, x, y, &three) {\n                result.push('3');\n            }else if is_match(state, x, y, &four) {\n                result.push('4');\n            }else if is_match(state, x, y, &five) {\n                result.push('5');\n            }else if is_match(state, x, y, &six) {\n                result.push('6');\n            }else if is_match(state, x, y, &seven){\n                result.push('7');\n            }else if is_match(state, x, y, &eight) {\n                result.push('8');\n            }else if is_match(state, x, y, &nine) {\n                result.push('9');\n            }else if is_match(state, x, y, &plus) {\n                result.push('+');\n            }else if is_match(state, x, y, &minus) {\n                result.push('-');\n            }else if is_match(state, x, y, &times) {\n                result.push('*');\n            }\n        }\n    }\n    result\n}\nfn parse_i32(state: &Vec<char>, position: usize) -> Option<(i32, usize)> {\n    if state.len() <= position || !state[position].is_digit(10) {\n        return None\n    }\n    let mut result = 0;\n    for i in position .. state.len() {\n        if let Some(d) = state[i].to_digit(10) {\n            result *= 10;\n            result += d as i32;\n        }else {\n            return Some((result, i))\n        }\n    }\n    Some((result, state.len()))\n}\nfn parse_term(state: &Vec<char>, position: usize) -> Option<(i32, usize)> {\n    if let Some((value, next)) = parse_i32(state, position) {\n        let mut pos = next;\n        let mut result = value;\n        while pos < state.len() && state[pos] == '*' {\n            if let Some((v, n)) = parse_i32(state, pos + 1) {\n                result *= v;\n                pos = n;\n            } else {unreachable!()}\n        }\n        Some((result, pos))\n    }else {\n        None\n    }\n}\nfn parse_expression(state: &Vec<char>) -> i32 {\n    if let Some((value, position)) = parse_term(state, 0) {\n        let mut pos = position;\n        let mut result = value;\n        while pos < state.len() {\n            match state[pos] {\n                '+' => {\n                    if let Some((v, p)) = parse_term(state, pos + 1) {\n                        pos = p;\n                        result += v;\n                    }else {unreachable!()}\n                }\n                '-' => {\n                    if let Some((v, p)) = parse_term(state, pos + 1){\n                        pos = p;\n                        result -= v;\n                    }else {unreachable!()}\n                }\n                _ => unreachable!()\n            }\n        }\n        result\n    }else {\n        unreachable!()\n    }\n}\nfn main() {\n    let mut state: [[bool; 201]; 201] = [[false; 201]; 201];\n    let_all!(n: usize);\n    for _ in 0 .. n {\n        let_all!(fx: usize, fy: usize, tx: usize, ty: usize);\n        for x in min(fx, tx) .. max(fx, tx) + 1 {\n            for y in min(fy, ty) .. max(fy, ty) + 1 {\n                state[y][x] = true;\n            }\n        }\n    }\n    println!(\"{}\", parse_expression(&parse(&state)));\n}\n\n"
  }
]