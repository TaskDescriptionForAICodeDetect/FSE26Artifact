[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n#define MAX_N 200\n#define INF 1e18\n\ntypedef struct {\n    double x, y, c;\n} Meat;\n\nMeat meats[MAX_N];\nint N, K;\n\ndouble distance(double X, double Y, Meat meat) {\n    return sqrt(pow(X - meat.x, 2) + pow(Y - meat.y, 2));\n}\n\ndouble solve() {\n    double result = INF;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i; j < N; j++) {\n            double x1 = meats[i].x, y1 = meats[i].y;\n            double x2 = meats[j].x, y2 = meats[j].y;\n            \n            for (int dx = -1; dx <= 1; dx++) {\n                for (int dy = -1; dy <= 1; dy++) {\n                    double X = (x1 + x2) / 2.0 + dx * 1e-9;\n                    double Y = (y1 + y2) / 2.0 + dy * 1e-9;\n                    \n                    double maxTime = 0;\n                    int count = 0;\n                    \n                    for (int k = 0; k < N; k++) {\n                        double time = meats[k].c * distance(X, Y, meats[k]);\n                        if (time <= result) {\n                            count++;\n                        }\n                        maxTime = fmax(maxTime, time);\n                    }\n                    \n                    if (count >= K) {\n                        result = fmin(result, maxTime);\n                    }\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &meats[i].x, &meats[i].y, &meats[i].c);\n    }\n    \n    printf(\"%.10f\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:36:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y, c;\n} Meat;\n\nMeat meats[60];\nint N, K;\n\ndouble distance(double X, double Y, int i) {\n    double dx = X - meats[i].x;\n    double dy = Y - meats[i].y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nint compare(const void *a, const void *b) {\n    double *da = (double *)a;\n    double *db = (double *)b;\n    if (*da < *db) return -1;\n    else if (*da > *db) return 1;\n    return 0;\n}\n\nbool is_possible(double time) {\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double xi = meats[i].x, yi = meats[i].y, ci = meats[i].c;\n            double xj = meats[j].x, yj = meats[j].y, cj = meats[j].c;\n            double A = (ci * ci) - (cj * cj);\n            double B = -2 * (xi * ci * ci - xj * cj * cj);\n            double C = -2 * (yi * ci * ci - yj * cj * cj);\n            double D = (xi * xi + yi * yi) * ci * ci - (xj * xj + yj * yj) * cj * cj - time * time * (ci * ci - cj * cj);\n            \n            for (int k = 0; k < N; k++) {\n                if (k == i || k == j) continue;\n                double xk = meats[k].x, yk = meats[k].y, ck = meats[k].c;\n                double a = (ci * ci) - (ck * ck);\n                double b = -2 * (xi * ci * ci - xk * ck * ck);\n                double c = -2 * (yi * ci * ci - yk * ck * ck);\n                double d = (xi * xi + yi * yi) * ci * ci - (xk * xk + yk * yk) * ck * ck - time * time * (ci * ci - ck * ck);\n                \n                double det = A * c - a * C;\n                if (fabs(det) < 1e-9) continue;\n                double Y = (a * D - A * d) / det;\n                double X = (-B - C * Y) / (2 * A);\n                \n                int cnt = 0;\n                for (int l = 0; l < N; l++) {\n                    if (meats[l].c * distance(X, Y, l) <= time + 1e-9) {\n                        cnt++;\n                    }\n                }\n                if (cnt >= K) return true;\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        double X = meats[i].x, Y = meats[i].y;\n        int cnt = 0;\n        for (int j = 0; j < N; j++) {\n            if (meats[j].c * distance(X, Y, j) <= time + 1e-9) {\n                cnt++;\n            }\n        }\n        if (cnt >= K) return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &meats[i].x, &meats[i].y, &meats[i].c);\n    }\n    \n    double left = 0.0, right = 1e9;\n    for (int iter = 0; iter < 100; iter++) {\n        double mid = (left + right) / 2;\n        if (is_possible(mid)) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n    \n    printf(\"%.10f\\n\", right);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n\nusing namespace std;\n\nstruct Point {\n    double x, y, c;\n};\n\nint N, K;\nvector<Point> points;\n\nbool isPossible(double time) {\n    vector<pair<double, double>> intervals;\n    for (const auto& p : points) {\n        if (p.c * 0 > time) continue;\n        double max_d = time / p.c;\n        intervals.emplace_back(p.x - max_d, p.x + max_d);\n    }\n    if (intervals.size() < K) return false;\n\n    sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    });\n\n    int count = 0;\n    double last = -1e18;\n    for (const auto& interval : intervals) {\n        if (interval.first > last) {\n            count++;\n            last = interval.second;\n        }\n        if (count >= K) return true;\n    }\n    return count >= K;\n}\n\ndouble solve() {\n    double left = 0.0, right = 1e18;\n    for (int iter = 0; iter < 100; ++iter) {\n        double mid = (left + right) / 2;\n        if (isPossible(mid)) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n    return right;\n}\n\nint main() {\n    cin >> N >> K;\n    points.resize(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y >> points[i].c;\n    }\n    cout << fixed << setprecision(10) << solve() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        int c;\n        Point(double x, double y, int c) {\n            this.x = x;\n            this.y = y;\n            this.c = c;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        Point[] points = new Point[N];\n        for (int i = 0; i < N; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            int c = sc.nextInt();\n            points[i] = new Point(x, y, c);\n        }\n\n        double left = 0;\n        double right = 1e9;\n        for (int iter = 0; iter < 100; iter++) {\n            double mid = (left + right) / 2;\n            if (canCover(points, N, K, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        System.out.printf(\"%.10f\\n\", right);\n    }\n\n    private static boolean canCover(Point[] points, int N, int K, double t) {\n        for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                Point p1 = points[i];\n                Point p2 = points[j];\n                double x1 = p1.x, y1 = p1.y, c1 = p1.c;\n                double x2 = p2.x, y2 = p2.y, c2 = p2.c;\n\n                double t1 = t / c1;\n                double t2 = t / c2;\n                if (t1 < 0 || t2 < 0) continue;\n\n                double dx = x2 - x1;\n                double dy = y2 - y1;\n                double d = Math.sqrt(dx * dx + dy * dy);\n                if (d > t1 + t2) continue;\n\n                if (d + t2 <= t1) {\n                    if (countPointsInCircle(points, N, x1, y1, t1) >= K) return true;\n                    continue;\n                }\n                if (d + t1 <= t2) {\n                    if (countPointsInCircle(points, N, x2, y2, t2) >= K) return true;\n                    continue;\n                }\n\n                double a = (t1 * t1 - t2 * t2 + d * d) / (2 * d);\n                double h = Math.sqrt(t1 * t1 - a * a);\n                double x3 = x1 + a * dx / d;\n                double y3 = y1 + a * dy / d;\n                double x4 = x3 - h * dy / d;\n                double y4 = y3 + h * dx / d;\n                if (countPointsInCircle(points, N, x4, y4, t / points[i].c) >= K) return true;\n                double x5 = x3 + h * dy / d;\n                double y5 = y3 - h * dx / d;\n                if (countPointsInCircle(points, N, x5, y5, t / points[i].c) >= K) return true;\n            }\n        }\n        return false;\n    }\n\n    private static int countPointsInCircle(Point[] points, int N, double X, double Y, double r) {\n        int count = 0;\n        for (Point p : points) {\n            double dist = Math.sqrt((X - p.x) * (X - p.x) + (Y - p.y) * (Y - p.y));\n            if (dist <= r + 1e-9) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 22:38:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MeatGrilling {\n    static class Meat {\n        int x, y, c;\n        Meat(int x, int y, int c) {\n            this.x = x;\n            this.y = y;\n            this.c = c;\n        }\n    }\n\n    public static double solve(Meat[] meats, int K) {\n        int N = meats.length;\n        double left = 0, right = 1e9;\n        \n        while (right - left > 1e-6) {\n            double mid = (left + right) / 2;\n            if (canGrill(meats, K, mid)) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        \n        return left;\n    }\n\n    static boolean canGrill(Meat[] meats, int K, double time) {\n        int n = meats.length;\n        List<Double> times = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            double bestTime = Double.MAX_VALUE;\n            \n            for (int j = 0; j < n; j++) {\n                double dist = Math.sqrt(\n                    (meats[i].x - meats[j].x) * (meats[i].x - meats[j].x) +\n                    (meats[i].y - meats[j].y) * (meats[i].y - meats[j].y)\n                );\n                bestTime = Math.min(bestTime, time / meats[i].c - dist);\n            }\n            \n            if (bestTime >= 0) {\n                times.add(bestTime);\n            }\n        }\n        \n        Collections.sort(times);\n        return times.size() >= K;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        \n        Meat[] meats = new Meat[N];\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int c = sc.nextInt();\n            meats[i] = new Meat(x, y, c);\n        }\n        \n        System.out.printf(\"%.10f\\n\", solve(meats, K));\n    }\n}",
    "timestamp": "2025-08-05 22:38:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\ndouble calc_time(vector<pair<pair<int, int>, int>>& meats, double x, double y) {\n    vector<double> times;\n    for (auto& meat : meats) {\n        times.push_back(meat.second * distance(x, y, meat.first.first, meat.first.second));\n    }\n    sort(times.begin(), times.end());\n    return times.size() > 0 ? times[meats.size() - 1] : 0;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<pair<pair<int, int>, int>> meats(N);\n    for (int i = 0; i < N; i++) {\n        cin >> meats[i].first.first >> meats[i].first.second >> meats[i].second;\n    }\n    \n    double left = 0, right = 1000;\n    for (int iter = 0; iter < 100; iter++) {\n        double mid1 = left + (right - left) / 3;\n        double mid2 = right - (right - left) / 3;\n        \n        double t1 = calc_time(meats, mid1, mid1);\n        double t2 = calc_time(meats, mid2, mid2);\n        \n        if (t1 < t2) {\n            right = mid2;\n        } else {\n            left = mid1;\n        }\n    }\n    \n    vector<pair<double, double>> candidates = {{left, left}};\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double x1 = meats[i].first.first, y1 = meats[i].first.second;\n            double x2 = meats[j].first.first, y2 = meats[j].first.second;\n            \n            double dx = x2 - x1, dy = y2 - y1;\n            double len = sqrt(dx*dx + dy*dy);\n            \n            double nx = -dy / len, ny = dx / len;\n            \n            candidates.push_back({x1 + nx, y1 + ny});\n            candidates.push_back({x1 - nx, y1 - ny});\n        }\n    }\n    \n    double min_time = 1e18;\n    for (auto& cand : candidates) {\n        vector<double> times;\n        for (auto& meat : meats) {\n            times.push_back(meat.second * distance(cand.first, cand.second, \n                                                   meat.first.first, meat.first.second));\n        }\n        sort(times.begin(), times.end());\n        \n        if (times.size() >= K) {\n            min_time = min(min_time, times[K-1]);\n        }\n    }\n    \n    cout << fixed << setprecision(10) << min_time << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from scipy.optimize import minimize\nimport numpy as np\n\ndef grilling_time(N, K, coords, hardness):\n    def time_to_grill(point):\n        X, Y = point\n        times = [c * np.sqrt((X - x) ** 2 + (Y - y) ** 2) for (x, y), c in zip(coords, hardness)]\n        times.sort()\n        return times[K-1]\n    \n    result = minimize(time_to_grill, np.mean(coords, axis=0), method='L-BFGS-B')\n    return time_to_grill(result.x)\n\n# Example Usage:\nN = 3\nK = 2\ncoords = [(1, 1), (2, 2), (3, 3)]\nhardness = [1, 10, 1]\nprint(grilling_time(N, K, coords, hardness))",
    "timestamp": "2025-08-13 11:46:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MeatGrilling {\n    static class Meat {\n        int x, y, c;\n\n        Meat(int x, int y, int c) {\n            this.x = x;\n            this.y = y;\n            this.c = c;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        Meat[] meats = new Meat[N];\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int c = scanner.nextInt();\n            meats[i] = new Meat(x, y, c);\n        }\n\n        System.out.println(findMinTime(meats, K));\n    }\n\n    static double findMinTime(Meat[] meats, int K) {\n        double low = 0, high = 1e9;\n        for (int t = 0; t < 100; t++) {\n            double mid = (low + high) / 2;\n            if (canGrillInTime(meats, K, mid)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        return high;\n    }\n\n    static boolean canGrillInTime(Meat[] meats, int K, double time) {\n        int count = 0;\n        for (Meat meat : meats) {\n            double maxDistance = time / meat.c;\n            if (maxDistance * maxDistance >= (meat.x * meat.x + meat.y * meat.y)) {\n                count++;\n            }\n        }\n        return count >= K;\n    }\n}",
    "timestamp": "2025-08-13 11:46:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\n// Structure to hold a piece of meat information\ntypedef struct {\n    double x;\n    double y;\n    double c;\n} Meat;\n\nint N, K;\nMeat meats[1000];\n\n// Function to calculate the time with a heat source at (X, Y)\ndouble calculate_time(double X, double Y) {\n    double times[N];\n    for (int i = 0; i < N; i++) {\n        double distance = sqrt((X - meats[i].x) * (X - meats[i].x) + (Y - meats[i].y) * (Y - meats[i].y));\n        times[i] = meats[i].c * distance;\n    }\n\n    // Sort times to find minimum time for K pieces\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (times[i] > times[j]) {\n                double temp = times[i];\n                times[i] = times[j];\n                times[j] = temp;\n            }\n        }\n    }\n\n    double max_time = 0;\n    for (int i = 0; i < K; i++) {\n        if (times[i] > max_time) {\n            max_time = times[i];\n        }\n    }\n    return max_time;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &meats[i].x, &meats[i].y, &meats[i].c);\n    }\n\n    double left = -10000, right = 10000;\n    double bottom = -10000, top = 10000;\n    \n    // Perform ternary search for both X and Y to find the optimal position\n    for (int _ = 0; _ < 100; _++) {\n        double midX1 = left + (right - left) / 3;\n        double midX2 = right - (right - left) / 3;\n        \n        double minYTime1 = FLT_MAX;\n        double minYTime2 = FLT_MAX;\n        \n        for (int __ = 0; __ < 100; __++) {\n            double midY1 = bottom + (top - bottom) / 3;\n            double midY2 = top - (top - bottom) / 3;\n            \n            double time1 = calculate_time(midX1, midY1);\n            double time2 = calculate_time(midX1, midY2);\n            double time3 = calculate_time(midX2, midY1);\n            double time4 = calculate_time(midX2, midY2);\n            \n            minYTime1 = fmin(minYTime1, fmin(time1, time2));\n            minYTime2 = fmin(minYTime2, fmin(time3, time4));\n            \n            if (time1 < time2) {\n                top = midY2;\n            } else {\n                bottom = midY1;\n            }\n        }\n\n        if (minYTime1 < minYTime2) {\n            right = midX2;\n        } else {\n            left = midX1;\n        }\n    }\n\n    printf(\"%.10lf\\n\", calculate_time((left + right) / 2, (bottom + top) / 2));\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minGrillTime(meats, K) {\n    const n = meats.length;\n\n    // Function to calculate time to grill K pieces\n    function timeToGrill(x, y) {\n        const times = [];\n        for (let i = 0; i < n; i++) {\n            const [xi, yi, ci] = meats[i];\n            const distance = Math.sqrt((x - xi) ** 2 + (y - yi) ** 2);\n            times.push(ci * distance);\n        }\n        times.sort((a, b) => a - b);\n        return times[K - 1];\n    }\n\n    // Ternary search over the possible coordinates range\n    function ternarySearch() {\n        let leftX = -10000, rightX = 10000;\n        let leftY = -10000, rightY = 10000;\n        \n        const eps = 1e-7; // Precision level\n\n        while (rightX - leftX > eps) {\n            let midX1 = leftX + (rightX - leftX) / 3;\n            let midX2 = rightX - (rightX - leftX) / 3;\n\n            let time1 = minY1 = minY2 = Infinity;\n\n            let ltx = leftY, rty = rightY;\n            while (rty - ltx > eps) {\n                let mdy1 = ltx + (rty - ltx) / 3;\n                let mdy2 = rty - (rty - ltx) / 3;\n\n                let time1y1 = timeToGrill(midX1, mdy1);\n                let time1y2 = timeToGrill(midX1, mdy2);\n                if (time1y1 < time1y2) {\n                    rty = mdy2;\n                    minY1 = time1y1;\n                } else {\n                    ltx = mdy1;\n                    minY1 = time1y2;\n                }\n            }\n\n            ltx = leftY, rty = rightY;\n            \n            while (rty - ltx > eps) {\n                let mdy1 = ltx + (rty - ltx) / 3;\n                let mdy2 = rty - (rty - ltx) / 3;\n\n                let time2y1 = timeToGrill(midX2, mdy1);\n                let time2y2 = timeToGrill(midX2, mdy2);\n                if (time2y1 < time2y2) {\n                    rty = mdy2;\n                    minY2 = time2y1;\n                } else {\n                    ltx = mdy1;\n                    minY2 = time2y2;\n                }\n            }\n\n            time1 = minY1;\n            let time2 = minY2;\n\n            if (time1 < time2) {\n                rightX = midX2;\n            } else {\n                leftX = midX1;\n            }\n        }\n\n        return timeToGrill(leftX, leftY);\n    }\n\n    return ternarySearch();\n}\n\n// Example usage\nconst meats = [\n    [1, 1, 1],\n    [2, 2, 1],\n    [3, 3, 1],\n    [4, 4, 1],\n    [5, 5, 1]\n];\nconst K = 3;\nconsole.log(minGrillTime(meats, K));",
    "timestamp": "2025-08-13 11:47:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nfrom itertools import combinations\n\ndef solve(N, K, x, y, c):\n    def total_time(X, Y):\n        times = []\n        for i in range(N):\n            dist = math.sqrt((X - x[i])**2 + (Y - y[i])**2)\n            times.append(c[i] * dist)\n        times.sort()\n        return max(times[:K])\n\n    best_time = float('inf')\n    \n    # Try heat source at each piece of meat\n    for i in range(N):\n        best_time = min(best_time, total_time(x[i], y[i]))\n    \n    # Try heat source at midpoints of meat pairs\n    for a, b in combinations(range(N), 2):\n        X = (x[a] + x[b]) / 2\n        Y = (y[a] + y[b]) / 2\n        best_time = min(best_time, total_time(X, Y))\n\n    return best_time\n\n# Example usage\nN, K = map(int, input().split())\nx = []\ny = []\nc = []\nfor _ in range(N):\n    xi, yi, ci = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n    c.append(ci)\n\nresult = solve(N, K, x, y, c)\nprint(f\"{result:.10f}\")",
    "timestamp": "2025-08-13 11:47:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumTimeToGrillMeat(N, K, coordinates, hardness) {\n    function calculateTime(sourceX, sourceY) {\n        const times = coordinates.map((coord, i) => \n            hardness[i] * Math.sqrt(\n                Math.pow(sourceX - coord[0], 2) + \n                Math.pow(sourceY - coord[1], 2)\n            )\n        );\n        times.sort((a, b) => a - b);\n        return times[K - 1];\n    }\n\n    let minTime = Infinity;\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            const x1 = coordinates[i][0];\n            const y1 = coordinates[i][1];\n            const x2 = coordinates[j][0];\n            const y2 = coordinates[j][1];\n\n            const midX = (x1 + x2) / 2;\n            const midY = (y1 + y2) / 2;\n\n            minTime = Math.min(minTime, calculateTime(midX, midY));\n        }\n    }\n\n    return minTime;\n}",
    "timestamp": "2025-08-13 11:47:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, K = map(int, data[idx:idx+2])\n    idx +=2\n    meats = []\n    for _ in range(N):\n        x, y, c = map(float, data[idx:idx+3])\n        idx +=3\n        meats.append((x, y, c))\n    \n    # Binary search the minimal maximum time\n    left = 0.0\n    right = 1e18\n    for _ in range(100):\n        mid = (left + right) / 2\n        # Check if there's a position (X, Y) where at least K meats have time <= mid\n        # For each meat, the condition c_i * dist <= mid => dist <= mid / c_i\n        # So the meat's circle is (x_i, y_i) with radius mid / c_i\n        # We need to find a point (X, Y) that is inside at least K circles\n        # To find such a point, we can check all pairs of circles (or triple) intersections\n        # and test those points plus the centers\n        candidates = []\n        for i in range(N):\n            x1, y1, c1 = meats[i]\n            r1 = mid / c1\n            candidates.append((x1, y1))  # center of the circle\n            for j in range(i+1, N):\n                x2, y2, c2 = meats[j]\n                r2 = mid / c2\n                # Find intersection points between circle i and j\n                dx = x2 - x1\n                dy = y2 - y1\n                d = math.hypot(dx, dy)\n                if d > r1 + r2 or d < abs(r1 - r2):\n                    continue  # no intersection or one is inside the other\n                # Find intersection points\n                a = (r1**2 - r2**2 + d**2) / (2 * d)\n                h = math.sqrt(r1**2 - a**2)\n                xm = x1 + a * dx / d\n                ym = y1 + a * dy / d\n                xp1 = xm + h * dy / d\n                yp1 = ym - h * dx / d\n                candidates.append((xp1, yp1))\n                xp2 = xm - h * dy / d\n                yp2 = ym + h * dx / d\n                candidates.append((xp2, yp2))\n        \n        # Check all candidate points\n        found = False\n        for (X, Y) in candidates:\n            count = 0\n            for (x, y, c) in meats:\n                dist_sq = (X - x)**2 + (Y - y)**2\n                if c * math.sqrt(dist_sq) <= mid + 1e-8:\n                    count += 1\n                    if count >= K:\n                        found = True\n                        break\n            if found:\n                break\n        if found:\n            right = mid\n        else:\n            left = mid\n    print(\"{0:.10f}\".format(right))\n\nsolve()",
    "timestamp": "2025-08-13 11:47:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, K] = input[0].split(' ').map(Number);\n    const meats = [];\n    for (let i = 1; i <= N; i++) {\n        const [x, y, c] = input[i].split(' ').map(Number);\n        meats.push({ x, y, c });\n    }\n\n    let left = 0;\n    let right = 1e18;\n    const maxIterations = 100;\n    const eps = 1e-8;\n\n    for (let iter = 0; iter < maxIterations; iter++) {\n        const mid = (left + right) / 2;\n        let ok = false;\n\n        const circles = meats.map(meat => {\n            const r = mid / meat.c;\n            return { x: meat.x, y: meat.y, r };\n        });\n\n        // Check if there are K circles that have a common intersection point\n        for (let i = 0; i < N && !ok; i++) {\n            for (let j = i + 1; j < N && !ok; j++) {\n                const c1 = circles[i];\n                const c2 = circles[j];\n                const dx = c2.x - c1.x;\n                const dy = c2.y - c1.y;\n                const d = Math.sqrt(dx * dx + dy * dy);\n                if (d > c1.r + c2.r + eps) continue;\n                if (d < Math.abs(c1.r - c2.r) - eps) continue;\n\n                const a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);\n                const h = Math.sqrt(Math.max(0, c1.r * c1.r - a * a));\n                const px = c1.x + (a * dx) / d;\n                const py = c1.y + (a * dy) / d;\n\n                const candidates = [\n                    { x: px + (h * dy) / d, y: py - (h * dx) / d },\n                    { x: px - (h * dy) / d, y: py + (h * dx) / d }\n                ];\n\n                for (const candidate of candidates) {\n                    let count = 0;\n                    for (const circle of circles) {\n                        const dist = Math.sqrt(\n                            (candidate.x - circle.x) ** 2 + (candidate.y - circle.y) ** 2\n                        );\n                        if (dist <= circle.r + eps) {\n                            count++;\n                        }\n                        if (count >= K) break;\n                    }\n                    if (count >= K) {\n                        ok = true;\n                        break;\n                    }\n                }\n                if (ok) break;\n            }\n        }\n\n        if (!ok) {\n            for (const circle of circles) {\n                let count = 0;\n                for (const other of circles) {\n                    const dist = Math.sqrt(\n                        (circle.x - other.x) ** 2 + (circle.y - other.y) ** 2\n                    );\n                    if (dist <= other.r + eps) {\n                        count++;\n                    }\n                    if (count >= K) break;\n                }\n                if (count >= K) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n\n        if (ok) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n\n    console.log(right.toFixed(10));\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:48:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Meat {\n    double x, y, hardness;\n    Meat(double x, double y, double c) : x(x), y(y), hardness(c) {}\n};\n\ndouble calculateTime(const vector<Meat>& meats, int K, double X, double Y) {\n    vector<double> times;\n    for (const auto& meat : meats) {\n        double time = meat.hardness * sqrt(pow(X - meat.x, 2) + pow(Y - meat.y, 2));\n        times.push_back(time);\n    }\n    sort(times.begin(), times.end());\n    double totalTime = 0;\n    for (int i = 0; i < K; ++i) {\n        totalTime += times[i];\n    }\n    return totalTime;\n}\n\ndouble findMinimumTime(vector<Meat>& meats, int K) {\n    double lowX = -1e5, highX = 1e5;\n    double lowY = -1e5, highY = 1e5;\n    double minTime = numeric_limits<double>::max();\n    \n    while (highX - lowX > 1e-6 || highY - lowY > 1e-6) {\n        double midX1 = lowX + (highX - lowX) / 3;\n        double midX2 = highX - (highX - lowX) / 3;\n        double midY1 = lowY + (highY - lowY) / 3;\n        double midY2 = highY - (highY - lowY) / 3;\n        \n        double time1 = calculateTime(meats, K, midX1, midY1);\n        double time2 = calculateTime(meats, K, midX2, midY2);\n        \n        if (time1 < time2) {\n            highX = midX2;\n            highY = midY2;\n            minTime = min(minTime, time1);\n        } else {\n            lowX = midX1;\n            lowY = midY1;\n            minTime = min(minTime, time2);\n        }\n    }\n    \n    return minTime;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<Meat> meats;\n    \n    for (int i = 0; i < N; ++i) {\n        double x, y, c;\n        cin >> x >> y >> c;\n        meats.push_back(Meat(x, y, c));\n    }\n    \n    double minTime = findMinimumTime(meats, K);\n    cout << fixed << minTime << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:04:57"
  }
]