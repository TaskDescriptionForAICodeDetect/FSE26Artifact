[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD (long long)(1e9 + 7)\nusing namespace std;\n\nlong long ssize = 0;\nlong long dp[200005][2] = {0}, sum[200005][2] = {0};\nstring s, t;\n\nlong long solve();\n\nint main() {\n  cin >> s >> t;\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  ssize = s.size();\n  dp[0][0] = 1;\n  for(int i = 0; i < ssize; ++i) {\n    int nums = s[i] - '0', numt = t[i] - '0';\n    if(t[i] != '?') {\n      if(nums == numt) {\n        (dp[i + 1][1] += dp[i][1]) %= MOD;\n        (dp[i + 1][0] += dp[i][0]) %= MOD;\n\n        sum[i + 1][1] +=\n            (sum[i][1] * 10 % MOD + dp[i][1] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n        sum[i + 1][0] +=\n            (sum[i][0] * 10 % MOD + dp[i][0] * numt % MOD) %\n            MOD;\n        sum[i + 1][0] %= MOD;\n      }\n      else if(nums < numt) {\n        dp[i + 1][1] += dp[i][1];\n        dp[i + 1][1] %= MOD;\n\n        sum[i + 1][1] +=\n            (sum[i][1] * 10 % MOD + dp[i][1] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n      }\n      else {\n        dp[i + 1][1] += dp[i][1];\n        (dp[i + 1][1] += dp[i][0]) %= MOD;\n\n        sum[i + 1][1] +=\n            (sum[i][1] * 10 % MOD + dp[i][1] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n        sum[i + 1][1] +=\n            (sum[i][0] * 10 % MOD + dp[i][0] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n      }\n    }\n    else {\n      for(int k = 0; k < 10; ++k) {\n        numt = k;\n        if(nums == numt) {\n          (dp[i + 1][1] += dp[i][1]) %= MOD;\n          (dp[i + 1][0] += dp[i][0]) %= MOD;\n\n          sum[i + 1][1] += (sum[i][1] * 10 % MOD +\n                            dp[i][1] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n          sum[i + 1][0] += (sum[i][0] * 10 % MOD +\n                            dp[i][0] * numt % MOD) %\n                           MOD;\n          sum[i + 1][0] %= MOD;\n        }\n        else if(nums < numt) {\n          dp[i + 1][1] += dp[i][1];\n          dp[i + 1][1] %= MOD;\n\n          sum[i + 1][1] += (sum[i][1] * 10 % MOD +\n                            dp[i][1] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n        }\n        else {\n          dp[i + 1][1] += dp[i][1];\n          (dp[i + 1][1] += dp[i][0]) %= MOD;\n\n          sum[i + 1][1] += (sum[i][1] * 10 % MOD +\n                            dp[i][1] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n          sum[i + 1][1] += (sum[i][0] * 10 % MOD +\n                            dp[i][0] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n        }\n      }\n    }\n  }\n\n  return (sum[ssize][1] + sum[ssize][0]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\n#include <cstdint>\nusing namespace std;\nusing LL = long long;\n\nstring S, T;\n\n//0 ぴったし,1 そうじゃない\nLL dp[234567][10][2], ep[234567][10][2];\n\nconst LL MOD = 1000000007;\n\nint main() {\n\tcin >> S >> T;\n\tint N = S.size();\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < 10; ++j) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tbool no[10] = {};\n\t\t\t\tif (T[i] != '?') {\n\t\t\t\t\tfor (int jj = 0; jj < 10; ++jj) {\n\t\t\t\t\t\tif (T[i] - '0' != jj)no[jj] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k == 0) {\n\t\t\t\t\tfor (int jj = 0; jj < 10; ++jj) {\n\t\t\t\t\t\tif (S[i] - '0' < jj) {\n\t\t\t\t\t\t\tno[jj] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int jj = 0; jj < 10; ++jj) {\n\t\t\t\t\tif (no[jj])continue;\n\t\t\t\t\tauto &dxt = dp[i + 1][jj][k | (S[i] - '0' != jj)];\n\t\t\t\t\tdxt += dp[i][j][k];\n\t\t\t\t\tdxt %= MOD;\n\t\t\t\t\tauto& ext = ep[i + 1][jj][k | (S[i] - '0' != jj)];\n\t\t\t\t\text += ((ep[i][j][k] * 10) % MOD + (jj * dp[i][j][k]) % MOD) % MOD;\n\t\t\t\t\text %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL ans = 0;\n\tLL deb = 0;\n\tfor (int j = 0; j < 10; ++j) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tdeb += dp[N][j][k];\n\t\t\tans += ep[N][j][k];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t//cout << deb << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconstexpr ll MOD = ll(1e9+7);\n\nll dp[200005][2][2];\n\nint main(){\n    string s, t;\n    cin >> s >> t;\n    int n = s.size();\n    dp[0][0][1] = 1;\n    for(int i=0;i<n;i++){\n        int sd = s[i]-'0';\n        if(t[i]=='?'){\n            for(int j=0;j<2;j++){\n                for(int d=0;d<=(j?9:sd);d++){\n                    dp[i+1][j||(sd>d)][0] += dp[i][j][0] * 10 + dp[i][j][1] * d;\n                    dp[i+1][j||(sd>d)][0] %= MOD;\n                    dp[i+1][j||(sd>d)][1] += dp[i][j][1];\n                    dp[i+1][j||(sd>d)][1] %= MOD;\n                }\n            }\n        }\n        else{\n            int td = t[i]-'0';\n            for(int j=0;j<2;j++){\n                if(sd < td &&j == 0) continue;\n                dp[i+1][j||(sd>td)][0] += dp[i][j][0] * 10 + dp[i][j][1] * td;\n                dp[i+1][j||(sd>td)][0] %= MOD;\n                dp[i+1][j||(sd>td)][1] += dp[i][j][1];\n                dp[i+1][j||(sd>td)][1] %= MOD;\n            \n            }\n        }\n    }\n    ll ans = 0;\n    ans = (dp[n][1][0] + dp[n][0][0]) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007;\n\nint dp[200001][2] = {};\nint dp2[200001][2] = {};\n\nint main(){\n    string s, t;\n    cin >> s >> t;\n    int n = s.length();\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 2; j++){\n            if(dp[i][j] == 0)   continue;\n            for(int k = 0; k < 10; k++){\n                if(j == 0 && k > s[i]-'0')  break;\n                if(t[i] != '?' && t[i]-'0' != k)    continue;\n                int nj = j | (s[i]-'0' > k);\n                dp[i+1][nj] += dp[i][j];\n                dp[i+1][nj] %= mod;\n                dp2[i+1][nj] += ((ll)dp2[i][j]*10 + (ll)(dp[i][j])*k)%mod;\n                dp2[i+1][nj] %= mod;\n            }\n        }\n    }\n    cout << (dp2[n][0]+dp2[n][1])%mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstring S,T;\nll dp[200010][2];\nll sum[200010][2];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>S>>T;\n  ll N=T.size();\n  dp[0][0]=1;\n  rep(i,N)rep(j,2){\n    if(T[i]=='?'){\n      if(j==0){\n        rep(d,S[i]-'0'+1){\n          if(S[i]<(char)(d+'0')){\n\n          }else if(S[i]==(char)(d+'0')){\n            (dp[i+1][j]+=dp[i][j])%=mod;\n            (sum[i+1][j]+=sum[i][j]*10+d*dp[i][j])%=mod;\n          }else{\n            (dp[i+1][1]+=dp[i][j])%=mod;\n            (sum[i+1][1]+=sum[i][j]*10+d*dp[i][j])%=mod;\n          }\n        }\n      }else{\n        rep(d,10){\n          (dp[i+1][1]+=dp[i][j])%=mod;\n          (sum[i+1][1]+=sum[i][j]*10+d*dp[i][j])%=mod;\n        }\n      }\n    }else{\n      ll d=T[i]-'0';\n      if(j==0){\n        {\n          if(S[i]<(char)(d+'0')){\n\n          }else if(S[i]==(char)(d+'0')){\n            (dp[i+1][j]+=dp[i][j])%=mod;\n            (sum[i+1][j]+=sum[i][j]*10+d*dp[i][j])%=mod;\n          }else{\n            (dp[i+1][1]+=dp[i][j])%=mod;\n            (sum[i+1][1]+=sum[i][j]*10+d*dp[i][j])%=mod;\n          }\n        }\n      }else{\n        {\n          (dp[i+1][1]+=dp[i][j])%=mod;\n          (sum[i+1][1]+=sum[i][j]*10+d*dp[i][j])%=mod;\n        }\n      }/*\n      if(S[i]<T[i]){\n\n      }else if(S[i]==T[i]){\n        (dp[i+1][j]+=dp[i][j])%=mod;\n        (sum[i+1][j]+=sum[i][j]*10+d*dp[i][j])%=mod;\n      }else{\n        (dp[i+1][1]+=dp[i][j])%=mod;\n        (sum[i+1][1]+=sum[i][j]*10+d*dp[i][j])%=mod;\n      }*/\n    }\n  }\n  cout<<(sum[N][0]+sum[N][1])%mod<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nstring s;\nstring t;\nint dpCnt[200001][2];\nint dpSum[200001][2];\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> s >> t;\n\tint n = s.length();\n\t\n\tdpCnt[0][0] = 1;\n\trep(i, n) {\n\t\trep(j, 2) {\n\t\t\trep(k, 10) {\n\t\t\t\tif (t[i] != '?' && k != (t[i] - '0')) continue;\n\t\t\t\tif (j == 0 && k > (s[i] - '0')) continue;\n\t\t\t\tint nj = (j || (k < (s[i] - '0')));\n\t\t\t\t(dpCnt[i + 1][nj] += dpCnt[i][j]) %= mod;\n\t\t\t\t(dpSum[i + 1][nj] += 10 * dpSum[i][j] + dpCnt[i][j] * k) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = dpSum[n][0] + dpSum[n][1];\n\tcout << ans % mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nconst int MOD = 1e9 + 7;\n\ntypedef modint<MOD> mint;\nint mod_pow(int n,int p,int MOD){ // a/n ≡ a*n^(p-2) nとpは互いに素\n  int r = 1;\n  for(; p > 0; p >>= 1){\n    if(p & 1LL) r = (r * n) % MOD;\n    n = (n * n) % MOD;\n  }\n  return r; // r = n^p % MOD\n}\n\n  mint dpl[200001][10][2]={};\n  mint dpr[200001][10][2]={};\nsigned main(){\n\n  string s,t; cin >> s >> t;\n\n  int n = s.size();\n  dpl[0][0][0] = 1;\n  for(int i = 1; i <= n; i++){\n    if(t[i-1] == '?'){\n      int d = (int)(s[i-1]-'0');\n      for(int j = 0; j < 10; j++){\n        for(int k = 0; k < 10; k++){\n          if(j < d) {\n              dpl[i][j][1] += dpl[i-1][k][1] + dpl[i-1][k][0];\n              \n          }\n          if(j == d){\n            dpl[i][j][0] += dpl[i-1][k][0];\n            dpl[i][j][1] += dpl[i-1][k][1];\n          }\n          if(j > d) dpl[i][j][1] += dpl[i-1][k][1];\n        }\n      }\n    }\n    else {\n      int d = s[i-1]-'0';\n      int dd = t[i-1]-'0';\n      for(int j = dd; j < dd+1; j++){\n        for(int k = 0; k < 10; k++){\n          if(j < d) dpl[i][j][1] += dpl[i-1][k][1] + dpl[i-1][k][0];\n          if(j == d){\n            dpl[i][j][0] += dpl[i-1][k][0];\n            dpl[i][j][1] += dpl[i-1][k][1];\n          }\n          if(j > d) dpl[i][j][1] += dpl[i-1][k][1];\n        }\n      }\n    }\n  }\n  //cout << dpl[1][6][1] << \" \" << dpl[2][9][1] << endl;\n  for(int i = n; i > 0; i--){\n      if(i==n){\n          int d = s[i-1]-'0';\n          if(t[i-1]=='?'){\n              for(int j=0;j<10;j++){\n                  if(j<=d){\n                      dpr[i][j][1] = 1;\n                  }else if(j>d){\n                      dpr[i][j][0] = 1;\n                  }\n              }\n          }else{\n              \n              for(int j=(t[i-1]-'0');j<(t[i-1]-'0')+1;j++){\n                  if(j<=d){\n                      dpr[i][j][1] = 1;\n                  }else if(j>d){\n                      dpr[i][j][1] = 0;\n                  }\n              }\n          }\n\n          continue;\n      }\n    if(t[i-1] == '?'){\n      int d = (int)(s[i-1]-'0');\n      for(int j = 0; j < 10; j++){\n        for(int k = 0; k < 10; k++){\n          if(j < d) dpr[i][j][1] += dpr[i+1][k][1] + dpr[i+1][k][0];\n          if(j == d){\n            dpr[i][j][0] += dpr[i+1][k][0];\n            dpr[i][j][1] += dpr[i+1][k][1];\n          }\n          if(j > d) dpr[i][j][0] += dpr[i+1][k][1] + dpr[i+1][k][0];\n        }\n      }\n    }\n    else {\n      int dd = t[i-1]-'0';\n      \n      int d = s[i-1]-'0';\n      for(int j = dd; j < dd+1; j++){\n        for(int k = 0; k < 10; k++){\n          if(j < d) dpr[i][j][1] += dpr[i+1][k][1] + dpr[i+1][k][0];\n          if(j == d){\n            dpr[i][j][0] += dpr[i+1][k][0];\n            dpr[i][j][1] += dpr[i+1][k][1];\n          }\n          if(j > d) dpr[i][j][0] += dpr[i+1][k][1] + dpr[i+1][k][0];\n        }\n      }\n    }\n  }\n\n\n  mint ans = 0;\n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j < 10; j++){\n      ans += (dpl[i][j][1] * (dpr[i][j][0]+dpr[i][j][1]) )* (j * mod_pow(10,n-i,MOD)%MOD);\n      ans += (dpl[i][j][0] * (dpr[i][j][1]) ) * (j * mod_pow(10,n-i,MOD)%MOD);\n    }\n  }\n  cout << ans.value() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\n// auto mod int\nconst int mod = 1000000007;\n// const int mod = 998244353;\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n      if ((x += a.x) >= mod) x -= mod;\n      return *this;\n    }\n    mint& operator-=(const mint a) {\n      if ((x += mod-a.x) >= mod) x -= mod;\n      return *this;\n    }\n    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n    mint operator+(const mint a) const { return mint(*this) += a;}\n    mint operator-(const mint a) const { return mint(*this) -= a;}\n    mint operator*(const mint a) const { return mint(*this) *= a;}\n    mint pow(ll t) const {\n      if (!t) return 1;\n      mint a = pow(t>>1);\n      a *= a;\n      if (t&1) a *= *this;\n      return a;\n    }\n\n    // for prime mod\n    mint inv() const { return pow(mod-2);}\n    mint& operator/=(const mint a) { return *this *= a.inv();}\n    mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\nstring s, t;\n// dp[上から何桁目][未満フラグ]\nmint dp[200200][2];     // 求めたい答え\nmint num[200200][2];    // 組み合わせの数\n\nint main() {\n    cin >> s >> t;\n    int slen = s.length();\n    memset(dp, 0, sizeof(dp));\n    memset(num, 0, sizeof(num));\n    num[0][1] = 1;\n\n    for(int i = 0; i < slen; ++i) {\n      int sch = s[i] - '0';\n      if(t[i] == '?') {\n        // tが?だったとき\n        // 未満の時、未満→未満\n        for(int d = 0; d <= 9; ++d) {\n          dp[i+1][0] += (dp[i][0]*(mint)10 + (mint)d*num[i][0]);\n          num[i+1][0] += num[i][0];\n        }\n\n        // 一致しているとき、一致→一致or一致→未満\n        for(int d = 0; d < sch; ++d) {\n          dp[i+1][0] += (dp[i][1]*(mint)10 + (mint)d*num[i][1]);\n          num[i+1][0] += num[i][1];\n        }\n        dp[i+1][1] += (dp[i][1]*(mint)10 + (mint)sch*num[i][1]);\n        num[i+1][1] += num[i][1];\n        \n      }else {\n        int tch = t[i] - '0';\n        // 未満の時、未満→未満、tchが何であっても処理は一緒\n        dp[i+1][0] += (dp[i][0]*(mint)10 + (mint)tch*num[i][0]);\n        num[i+1][0] += num[i][0];\n\n        // 一致しているとき、一致→一致or一致→未満\n        if(tch == sch) {\n          dp[i+1][1] += (dp[i][1]*(mint)10 + (mint)tch*num[i][1]);\n          num[i+1][1] += num[i][1];\n        }else if(tch < sch) {\n          dp[i+1][0] += (dp[i][1]*(mint)10 + (mint)tch*num[i][1]);\n          num[i+1][0] += num[i][1];\n        }\n      }\n    }\n    mint ans = dp[slen][0] + dp[slen][1];\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstring s, t;\nllint dp[200005][2], dp2[200005][2];\nllint beki[200005];\n\nint main(void)\n{\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  cin >> s >> t;\n  reverse(s.begin(), s.end());\n  reverse(t.begin(), t.end());\n  int n = s.size();\n\n  beki[0] = 1;\n  for(int i = 1; i < 200005; i++) beki[i] = beki[i-1] * 10, beki[i] %= mod;\n\n  dp[n][0] = 1;\n  for(int i = n; i > 0; i--){\n    for(int j = 0; j < 2; j++){\n      for(int k = 0; k < 10; k++){\n        if(t[i-1] != '?' && t[i-1]-'0' != k) continue;\n        if(j == 0 && s[i-1]-'0' < k) continue;\n        int nj = j;\n        if(k < s[i-1]-'0') nj = 1;\n        dp[i-1][nj] += dp[i][j], dp[i-1][nj] %= mod;\n      }\n    }\n  }\n\n  for(int i = n; i > 0; i--){\n    for(int j = 0; j < 2; j++){\n      for(int k = 0; k < 10; k++){\n        if(t[i-1] != '?' && t[i-1]-'0' != k) continue;\n        if(j == 0 && s[i-1]-'0' < k) continue;\n        int nj = j;\n        if(k < s[i-1]-'0') nj = 1;\n        dp2[i-1][nj] += dp2[i][j] + dp[i][j]*k%mod*beki[i-1]%mod, dp2[i-1][nj] %= mod;\n      }\n    }\n  }\n\n  llint ans = 0;\n  for(int i = 0; i < 2; i++) ans += dp2[0][i], ans %= mod;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  constexpr ModInt() : v(0) {}\n  constexpr ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned)1e9 + 7>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  string s, t; cin >> s >> t;\n  int n = s.size();\n  VV<Mint> dp(n + 1, V<Mint>(2));\n  VV<Mint> sum(n + 1, V<Mint>(2));\n  dp[0][1] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int f = 0; f < 2; ++f) for (int d = 0; d < 10; ++d) if (t[i] == '?' or t[i] - '0' == d) {\n      if (f == 1 and d > s[i] - '0') continue;\n      dp[i + 1][f and d == s[i] - '0'] += dp[i][f];\n      sum[i + 1][f and d == s[i] - '0'] += sum[i][f] * 10 + d * dp[i][f];\n    }\n  }\n  cout << sum[n][0] + sum[n][1] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconstexpr ll MOD = ll(1e9+7);\n\nll dp[200005][2][2];\n\nint main(){\n    string s, t;\n    cin >> s >> t;\n    int n = s.size();\n    dp[0][0][1] = 1;\n    for(int i=0;i<n;i++){\n        int sd = s[i]-'0';\n        if(t[i]=='?'){\n            for(int j=0;j<2;j++){\n                for(int d=0;d<=(j?9:sd);d++){\n                    dp[i+1][j||(sd>d)][0] += dp[i][j][0] * 10 + dp[i][j][1] * d;\n                    dp[i+1][j||(sd>d)][0] %= MOD;\n                    dp[i+1][j||(sd>d)][1] += dp[i][j][1];\n                    dp[i+1][j||(sd>d)][1] %= MOD;\n                }\n            }\n        }\n        else{\n            int td = t[i]-'0';\n            for(int j=0;j<2;j++){\n                if(sd < td &&j == 0) continue;\n                dp[i+1][j||(sd>td)][0] += dp[i][j][0] * 10 + dp[i][j][1] * td;\n                dp[i+1][j||(sd>td)][0] %= MOD;\n                dp[i+1][j||(sd>td)][1] += dp[i][j][1];\n                dp[i+1][j||(sd>td)][1] %= MOD;\n            \n            }\n        }\n    }\n    ll ans = 0;\n    ans = (dp[n][1][0] + dp[n][0][0]) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n\treturn modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n\treturn modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n\treturn modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n\treturn modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n\ta += rhs.a;\n\tif (a >= Modulus) {\n\t  a -= Modulus;\n\t}\n\treturn *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n\tif (a < rhs.a) {\n\t  a += Modulus;\n\t}\n\ta -= rhs.a;\n\treturn *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n\ta = a * rhs.a % Modulus;\n\treturn *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n\tu64 exp = Modulus - 2;\n\twhile (exp) {\n\t  if (exp % 2) {\n\t\t*this *= rhs;\n\t  }\n\t  rhs *= rhs;\n\t  exp /= 2;\n\t}\n\treturn *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nmint dp[202020][2];\nmint ep[202020][2];\n\nint main(){\n\tstring s,t; cin >> s >> t;\n\tll n = s.size();\n\tep[0][0] = 1;\n\trep(i,n){\n\t\tif(t[i]=='?'){\n\t\t\tll num = s[i] - '0';\n\t\t\trep(j,10){\n\t\t\t\tif(j < num){\n\t\t\t\t\tdp[i+1][1] += (dp[i][0] + dp[i][1]) * 10 + \n\t\t\t\t\t\t\t(mint)j * (ep[i][0] + ep[i][1]);\n\t\t\t\t\tep[i+1][1] += ep[i][1] + ep[i][0];\n\t\t\t\t}else if(j == num){\n\t\t\t\t\tdp[i+1][1] += dp[i][1] * 10 + (mint)j * ep[i][1];\n\t\t\t\t\tdp[i+1][0] += dp[i][0] * 10 + (mint)j * ep[i][0];\n\t\t\t\t\tep[i+1][1] += ep[i][1];\n\t\t\t\t\tep[i+1][0] += ep[i][0];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][1] += dp[i][1] * 10 + (mint)j * ep[i][1];\n\t\t\t\t\tep[i+1][1] += ep[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tll num = t[i] - '0';\n\t\t\tif(t[i] < s[i]){\n\t\t\t\tdp[i+1][1] += (dp[i][0] + dp[i][1]) * 10 + \n\t\t\t\t\t\t\t(mint)num * (ep[i][0] + ep[i][1]);\n\t\t\t\tep[i+1][1] += ep[i][1] + ep[i][0];\n\t\t\t}else if(t[i] == s[i]){\n\t\t\t\tdp[i+1][1] += dp[i][1] * 10 + (mint)num * ep[i][1];\n\t\t\t\tdp[i+1][0] += dp[i][0] * 10 + (mint)num * ep[i][0];\n\t\t\t\tep[i+1][1] += ep[i][1];\n\t\t\t\tep[i+1][0] += ep[i][0];\n\t\t\t}else{\n\t\t\t\tdp[i+1][1] += dp[i][1] * 10 + (mint)num * ep[i][1];\n\t\t\t\tep[i+1][1] += ep[i][1];\n\t\t\t}\n\t\t}\n\t}\n\tmint ans = dp[n][0] + dp[n][1];\n\tcout << ans.value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nconst ll mod = 1e9+7;\n\nll dp[200010][2][2];\n\nint main(){\n  string s, t;\n  cin >> s >> t;\n\n  int n = sz(s);\n  dp[0][0][1] = 1;\n  rep(i,n) {\n    const int sD = s[i] - '0'; \n    if (t[i] == '?') {\n      rep(j,2) {\n        for (int d = 0; d <= (j ? 9 : sD); d++) {\n          (dp[i+1][j||(d<sD)][0] += dp[i][j][0] * 10 + d * dp[i][j][1]) %= mod;\n          (dp[i+1][j||(d<sD)][1] += dp[i][j][1]) %= mod;\n        }\n      }\n    } else {\n      const int tD = t[i] - '0';\n      rep(j,2) {\n        if (sD < tD && j == 0) continue;\n        (dp[i+1][j||(tD<sD)][0] += dp[i][j][0] * 10 + tD * dp[i][j][1]) %= mod;\n        (dp[i+1][j||(tD<sD)][1] += dp[i][j][1]) %= mod;\n      }\n    }\n  }\n  cout << (dp[n][0][0] + dp[n][1][0]) % mod << endl;\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<functional>\n#include<math.h>\n#include<random>\n#include <bitset>\nusing namespace std;\n#define N (1000000000+7)\n//#define N 998244353\n#define INF 1e16\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\n\nconst int inf = (int)1e9; \n\nll gcd(ll a, ll b) {\n\tif (b > a) {\n\t\tll tmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\t}\n\tif (a%b == 0)return b;\n\telse return gcd(b, a%b);\n}\n\nll dp[200010][2][2];\n\nll ten[200010];\n\nint main(void){\n\tstring S,T;\n\tcin>>S>>T;\n\tll n = S.length();\n\tdp[0][1][0]=1;\n\tdp[0][0][0]=0;\n\tten[0]=1;\n\tfor(ll i=0;i<=200000;i++){\n\t\tten[i+1] = (10*ten[i])%N;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tif(T[i]=='?'){\n\t\t\tll x = S[i]-'0';\n\t\t\tll s = x*(x-1)/2;\n\t\t\tdp[i+1][1][0] = dp[i][1][0];\n\t\t\tdp[i+1][0][0] = ((dp[i][1][0]*x)%N+(dp[i][0][0])*10)%N;\n\t\t\tdp[i+1][1][1] = dp[i][1][1] + (x*((dp[i+1][1][0]*ten[n-i-1])%N))%N;\n\t\t\tdp[i+1][1][1] = dp[i+1][1][1]%N;\n\t\t\tdp[i+1][0][1] = (dp[i][0][1]*10)%N+(45*((ten[n-i-1]*dp[i][0][0])%N))%N;\n\t\t\tdp[i+1][0][1] = dp[i+1][0][1]%N;\n\t\t\tdp[i+1][0][1] = dp[i+1][0][1]+ (dp[i][1][1]*x)%N+(((s*ten[n-i-1])%N)*(dp[i][1][0]))%N;\n\t\t\tdp[i+1][0][1] = dp[i+1][0][1]%N;\n\t\t}\n\t\telse{\n\t\t\tif(S[i]==T[i]){\n\t\t\t\tll x = T[i]-'0';\n\t\t\t\tdp[i+1][1][0] = dp[i][1][0];\n\t\t\t\tdp[i+1][0][0] = dp[i][0][0];\n\t\t\t\tdp[i+1][1][1] = dp[i][1][1] + (((x*ten[n-i-1])%N)*dp[i][1][0])%N;\n\t\t\t\tdp[i+1][0][1] = dp[i][0][1] + (((x*ten[n-i-1])%N)*dp[i][0][0])%N;\n\t\t\t\tdp[i+1][1][1] = dp[i+1][1][1]%N;\n\t\t\t\tdp[i+1][0][1] = dp[i+1][0][1]%N;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(S[i]<T[i]){\n\t\t\t\t\tll x = T[i]-'0';\n\t\t\t\t\tdp[i+1][0][0] = dp[i][0][0];\n\t\t\t\t\tdp[i+1][0][1] = dp[i][0][1]+(((x*ten[n-i-1])%N)*dp[i+1][0][0])%N;\n\t\t\t\t\tdp[i+1][0][1] = dp[i+1][0][1]%N;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tll x = T[i]-'0';\n\t\t\t\t\tdp[i+1][0][0] = (dp[i][0][0]+dp[i][1][0])%N;\n\t\t\t\t\tdp[i+1][0][1] = (dp[i][0][1]+dp[i][1][1])%N+(((x*ten[n-i-1])%N)*dp[i+1][0][0])%N;\n\t\t\t\t\tdp[i+1][0][1] = dp[i+1][0][1]%N;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<dp[3][0][0]<<endl;\n\tcout<<(dp[n][0][1]+dp[n][1][1])%N<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint N;\nstring S,T;\n\nll dp[200020][2];\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nint main(){\n  cin>>S;\n  cin>>T;\n  N=S.size();\n\n  dp[0][0]=0;\n  ll x=0;\n  bool big=false;\n  bool end=false;\n  for(int i=0;i<N;i++){\n    if(T[i]!='?'){\n      add(dp[i+1][1],dp[i][1]*10+(T[i]-'0')*x);\n      if(S[i]>T[i]&&big==false&&end==false){\n          add(dp[i+1][1],dp[i][0]*10+(T[i]-'0'));\n          add(x,1);\n      }else if(S[i]==T[i]&&end==false) add(dp[i+1][0],dp[i][0]*10+(T[i]-'0'));\n\n      if(S[i]>T[i]) big=true;\n      if(S[i]<T[i]){\n          end=true;\n          dp[i+1][0]=0;\n      }\n    }else{\n      for(int j=0;j<=9;j++){\n        add(dp[i+1][1],dp[i][1]*10+(j)*x);\n      }\n      if(big==false&&end==false){\n          add(dp[i+1][0],dp[i][0]*10+(S[i]-'0'));\n          for(int j=0;j<(S[i]-'0');j++){\n            add(dp[i+1][1],dp[i][0]*10+j);\n          }\n      }\n      x=x*10%MOD;\n      if(big==false&&end==false) add(x,S[i]-'0');\n    }\n  }\n\n  ll ans=0;\n  for(int j=0;j<=1;j++) add(ans,dp[N][j]);\n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"Yes\\n\"\n#define no cout<<\"No\\n\"\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\nint dp[200020][2],ok[200020][2];\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n    string s,t;\n    cin>>s>>t;\n    int MOD=1000000007;\n    ok[0][0]=1;\n    rep(i,s.size())rep(j,2)rep(x,10)if(t[i]=='?'||t[i]-'0'==x){\n        int I=i+1,J=j|s[i]-'0'>x;\n        if(!J&&s[i]-'0'<x)continue;\n        // cout<<i<<\" \"<<j<<\" \"<<x<<\" \"<<dp[i][j]<<\" \"<<I<<\" \"<<J<<endl;\n        (ok[I][J]+=ok[i][j])%=MOD;\n        (dp[I][J]+=dp[i][j]*10+ok[i][j]*x%MOD)%=MOD;\n    }\n    cout<<(dp[s.size()][0]+dp[s.size()][1])%MOD<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 3110.cc: Many Decimal Integers\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200000;\nconst int MOD = 1000000007;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* global variables */\n\nint dsums[10 + 1];\nchar s[MAX_N + 4], t[MAX_N + 4];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (int i = 0; i < 10; i++) dsums[i + 1] = dsums[i] + i;\n\n  scanf(\"%s%s\", s, t);\n  int n = strlen(s);\n\n  int dp0 = 0, n0 = 1;\n  int dp1 = 0, n1 = 0;\n\n  for (int i = 0; i < n; i++) {\n    int si = s[i] - '0';\n    int tdp0 = (ll)dp0 * 10 % MOD;\n    int tdp1 = (ll)dp1 * 10 % MOD;\n\n    if (t[i] != '?') {\n      int ti = t[i] - '0';\n      int nd0 = (tdp0 + (ll)ti * n0 % MOD) % MOD;\n      int nd1 = (tdp1 + (ll)ti * n1 % MOD) % MOD;\n\n      dp1 = nd1;\n      if (ti == si)\n\tdp0 = nd0;\n      else if (ti < si) {\n\tdp1 = (dp1 + nd0) % MOD;\n\tdp0 = 0;\n\tn1 = (n1 + n0) % MOD;\n\tn0 = 0;\n      }\n      else {\n\tdp0 = 0;\n\tn0 = 0;\n      }\n    }\n    else { // t[i] == '?'\n      int nd0 = (tdp0 + (ll)si * n0 % MOD) % MOD;\n      int nd1 = ((ll)tdp0 * si % MOD + (ll)dsums[si] * n0 % MOD) % MOD;\n      int nd2 = ((ll)tdp1 * 10 % MOD + (ll)dsums[10] * n1 % MOD) % MOD;\n\n      dp0 = nd0;\n      dp1 = (nd2 + nd1) % MOD;\n      n1 = ((ll)n0 * si % MOD + (ll)n1 * 10 % MOD) % MOD;\n    }\n  }\n\n  printf(\"%d\\n\", (dp0 + dp1) % MOD);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nll dp[201010][2];\nll dp2[201010][2];\nll base[201010];\n\nvoid solve() {\n    string S, T;\n    cin >> S >> T;\n    int N = S.size();\n\n    base[0] = 1;\n    REP(i, N) base[i+1] = base[i] * 10 % MOD;\n\n    dp2[0][0] = 1;\n\n    REP(i, N) REP(j, 2) {\n        ll b = base[N-i-1];\n        REP(nd, 10) {\n            if (T[i] != '?' && nd != T[i] - '0') continue;\n            if (!j && nd > S[i] - '0') continue;\n            (dp[i+1][j||(nd<S[i]-'0')] += (dp[i][j] + b * nd % MOD * dp2[i][j] % MOD)) %= MOD;\n            (dp2[i+1][j||(nd<S[i]-'0')] += dp2[i][j]) %= MOD;\n        }\n    }\n\n    cout << (dp[N][0] + dp[N][1]) % MOD << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nlong long mod=1e9+7;\nlong long power(long long a,long long b)\n{\n\treturn b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;\n}\nlong long M;\nstring S,T;\nlong long P[2<<17];\npair<int,long long>dp[2][2<<17];\nvoid add(pair<int,long long>&a,pair<int,long long>b,long long now)\n{\n\t(a.first+=b.first)%=mod;\n\t(a.second+=b.first*now+b.second)%=mod;\n}\nint main()\n{\n\tcin>>S>>T;\n\tP[0]=1;\n\tfor(int i=1;i<T.size();i++)\n\t{\n\t\tP[i]=P[i-1]*10%mod;\n\t}\n\tdp[0][0].first=1;\n\tfor(int i=0;i<T.size();i++)\n\t{\n\t\tlong tmp=P[T.size()-i-1];\n\t\tfor(int j=0;j<2;j++)\n\t\t{\n\t\t\tif(T[i]!='?')\n\t\t\t{\n\t\t\t\tif(j==1||T[i]<=S[i])\n\t\t\t\t{\n\t\t\t\t\tadd(dp[j||T[i]<S[i]][i+1],dp[j][i],tmp*(T[i]-'0')%mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lim=j==1?9:S[i]-'0';\n\t\t\t\tfor(int k=0;k<=lim;k++)\n\t\t\t\t{\n\t\t\t\t\tadd(dp[j||k<lim][i+1],dp[j][i],tmp*k%mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(dp[0][T.size()].second+dp[1][T.size()].second)%mod<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nconstexpr int64 mod = 1e9+7;\nusing Mint = ModInt<mod>;\n\nstring S, T;\nint64 N;\nvector<vector<pair<Mint, Mint>>> dp;\nvector<vector<int>> used;\nvector<Mint> ten;\n\nusing PMM = pair<Mint, Mint>;\n\nPMM dfs(int64 dig = 0, bool tight = 1) {\n    if (used[dig][tight]) return dp[dig][tight];\n    if (dig == N) return PMM(1, 0);\n    used[dig][tight] = 1;\n    PMM &res = dp[dig][tight];\n    res = PMM(0, 0);\n\n    int64 lim = tight ? S[dig]-'0' : 9;\n    if (T[dig] == '?') {\n        for (int64 i = 0; i <= lim; i++) {\n            Mint val = ten[dig] * i;\n            PMM ret = dfs(dig+1, tight && (lim == i));\n            res.fs += ret.fs;\n            res.sc += ret.sc + ret.fs * val;\n        }\n    } else {\n        if (lim < T[dig]-'0') return PLL(0, 0);\n        Mint val = ten[dig] * (T[dig]-'0');\n        PMM ret = dfs(dig + 1, tight && (lim == T[dig] - '0'));\n//        cout << dig << \" \" << ret.fs << \" \" << ret.sc << \" \" << val << endl;\n        res.fs += ret.fs;\n        res.sc += ret.sc + ret.fs * val;\n    }\n    return res;\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> S >> T;\n\tN = S.size();\n\tdp = make_v<PMM>(N+1, 2);\n\tused = make_v<int>(N+1, 2);\n\tten = vector<Mint>(N+1, 0);\n\tten[N-1] = 1;\n\tfor (int64 i = N-2; i >= 0; i--) {\n\t    ten[i] = ten[i+1] * 10;\n\t}\n\tfill_v<int>(used, 0);\n\tcout << dfs().sc << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst int INF=1e9;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;\n    res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\n//main\nsigned main(){\n  string s,t;cin>>s>>t;\n  int N=s.size();\n  std::vector<int> v(223456),a(223456);\n  std::vector<int> w(11);\n  w[0]=0;\n  for(int i=1;i<=10;i++)w[i]=w[i-1]+i;\n  reverse(t.begin(),t.end());\n\n  a[0]=1;\n  for(int i=0;i<N;i++){\n    if(t[i]=='?')a[i+1]=a[i]*10%MOD;\n    else a[i+1]=a[i];\n    a[i+1]%=MOD;\n  }\n\n  v[0]=0;\n  int now=1;\n  for(int i=0;i<N;i++){\n    if(t[i]=='?')v[i+1]=v[i]*10%MOD+w[9]*now%MOD*a[i];\n    else v[i+1]=v[i]*1+(t[i]-'0')*now%MOD*a[i]%MOD;\n    now*=10;now%=MOD;\n    v[i+1]%=MOD;\n  }\n\n  reverse(t.begin(),t.end());\n\n  int gyaku=pw(10,MOD-2);\n  now=pw(10,N-1);\n\n  int ans=0,res=0,flg=0;\n  for(int i=0;i<N;i++){\n    //cout<<i<<\" \"<<ans<<endl;\n    int j=s[i]-'0';\n    //cout<<i<<\" \"<<j<<endl;\n    if(t[i]=='?'){\n      if(j>0){\n        ans+=res*j%MOD*a[N-i-1]%MOD;\n        ans+=w[j-1]*now%MOD*a[N-i-1]%MOD;\n        ans+=v[N-i-1]*j%MOD;\n        ans%=MOD;\n      }\n      res+=j*now%MOD;\n      res%=MOD;\n      now*=gyaku;\n      now%=MOD;\n      continue;\n    }\n\n    if(s[i]<t[i]){\n      flg=1;\n      break;\n    }\n\n    if(s[i]>t[i]){\n      ans+=res*a[N-i-1];\n      ans+=(t[i]-'0')*now%MOD*a[N-i-1]%MOD;\n      ans+=v[N-i-1];\n      ans%=MOD;\n      flg=1;\n      break;\n    }\n\n    assert(s[i]==t[i]);\n    res+=j*now%MOD;\n    res%=MOD;\n    now*=gyaku;\n    now%=MOD;\n  }\n\n  if(!flg) ans+=res;\n  ans%=MOD;\n\n  //for(int i=0;i<5;i++)cout<<v[i]<<\" \";cout<<endl;\n  //for(int i=0;i<5;i++)cout<<a[i]<<\" \";cout<<endl;\n  fin(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD (long long)(1e9 + 7)\nusing namespace std;\n\nlong long ssize = 0;\nlong long dp[200005][2] = {0}, sum[200005][2] = {0};\nstring s, t;\n\nlong long solve();\n\nint main() {\n  cin >> s >> t;\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  ssize = s.size();\n  dp[0][0] = 1;\n  for(int i = 0; i < ssize; ++i) {\n    int nums = s[i] - '0', numt = t[i] - '0';\n    if(t[i] != '?') {\n      if(nums == numt) {\n        (dp[i + 1][1] += dp[i][1]) %= MOD;\n        (dp[i + 1][0] += dp[i][0]) %= MOD;\n\n        sum[i + 1][1] +=\n            (sum[i][1] * 10 % MOD + dp[i][1] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n        sum[i + 1][0] +=\n            (sum[i][0] * 10 % MOD + dp[i][0] * numt % MOD) %\n            MOD;\n        sum[i + 1][0] %= MOD;\n      }\n      else if(nums < numt) {\n        dp[i + 1][1] += dp[i][1];\n        dp[i + 1][1] %= MOD;\n\n        sum[i + 1][1] +=\n            (sum[i][1] * 10 % MOD + dp[i][1] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n      }\n      else {\n        dp[i + 1][1] += dp[i][1];\n        (dp[i + 1][1] += dp[i][0]) %= MOD;\n\n        sum[i + 1][1] +=\n            (sum[i][1] * 10 % MOD + dp[i][1] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n        sum[i + 1][1] +=\n            (sum[i][0] * 10 % MOD + dp[i][0] * numt % MOD) %\n            MOD;\n        sum[i + 1][1] %= MOD;\n      }\n    }\n    else {\n      for(int k = 0; k < 10; ++k) {\n        numt = k;\n        if(nums == numt) {\n          (dp[i + 1][1] += dp[i][1]) %= MOD;\n          (dp[i + 1][0] += dp[i][0]) %= MOD;\n\n          sum[i + 1][1] += (sum[i][1] * 10 % MOD +\n                            dp[i][1] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n          sum[i + 1][0] += (sum[i][0] * 10 % MOD +\n                            dp[i][0] * numt % MOD) %\n                           MOD;\n          sum[i + 1][0] %= MOD;\n        }\n        else if(nums < numt) {\n          dp[i + 1][1] += dp[i][1];\n          dp[i + 1][1] %= MOD;\n\n          sum[i + 1][1] += (sum[i][1] * 10 % MOD +\n                            dp[i][1] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n        }\n        else {\n          dp[i + 1][1] += dp[i][1];\n          (dp[i + 1][1] += dp[i][0]) %= MOD;\n\n          sum[i + 1][1] += (sum[i][1] * 10 % MOD +\n                            dp[i][1] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n          sum[i + 1][1] += (sum[i][0] * 10 % MOD +\n                            dp[i][0] * numt % MOD) %\n                           MOD;\n          sum[i + 1][1] %= MOD;\n        }\n      }\n    }\n  }\n\n  return (sum[ssize][1] + sum[ssize][0]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\nstring S, T;\nvector<Int> B;\n\nInt dfs2(Int idx, Int same){\n  static Int mem[200010][2], used[200010][2];\n  if(idx == (Int)T.size()) return 1;\n  if(used[idx][same]++) return mem[idx][same];\n\n  Int res = 0;\n  for(Int num=0;num<10;num++){\n    if(isdigit(T[idx]) && num != T[idx] - '0') continue;\n    if(same && S[idx] - '0' < num) continue;\n    Int nsame = same & (S[idx] - '0' == num);\n    res += dfs2(idx + 1, nsame);\n    res %= mod;\n  }\n  return mem[idx][same] = res;\n}\n\nInt dfs(Int idx, Int same, Int keta){\n  static Int mem[200010][2], used[200010][2];\n  if(idx == (Int)T.size()) return 0;\n  if(used[idx][same]++) return mem[idx][same];\n  Int res = 0, update = 0;\n  for(Int num=0;num<10;num++){\n    if(isdigit(T[idx]) && num != T[idx] - '0') continue;\n    if(same && S[idx] - '0' < num) continue;\n    Int nsame = same && (S[idx] - '0' == num);\n    Int t = dfs(idx + 1, nsame, keta-1);\n    if(t == -1) continue;\n    update = 1;\n    res += B[keta] * num * dfs2(idx + 1, nsame) + t;\n    res %= mod;\n  }\n  if(!update) res = -1;\n  return mem[idx][same] = res;\n}\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>S;\n  cin>>T;\n  {\n    reverse(S.begin(), S.end());\n    reverse(T.begin(), T.end());\n    while(S.size() < T.size()) S += '0';\n    while(T.size() < S.size()) T += '0';\n    reverse(S.begin(), S.end());\n    reverse(T.begin(), T.end());\n  }\n\n  const Int N = 200010;\n  B.resize(N);\n  B[0] = 1;\n  for(Int i=1;i<N;i++) B[i] = B[i-1] * 10 % mod;\n  Int ans = dfs(0, 1, T.size() - 1);\n  if(ans == -1) ans = 0;\n  cout<<ans<<endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nll dp1[202020] = {0};\nll dp1sum[202020] = {0};\nll dp2[202020] = {0};\nll dp2sum[202020] = {0};\nll P = 1000000007;\nll po10[202020] = {0};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  string s, t;\n  cin >> s >> t;\n\n  int n = s.size();\n  po10[0] = 1;\n  for (int i = 0; i < n; i++) {\n    po10[i + 1] = (po10[i] * 10) % P;\n  }\n\n  dp1[0] = 1;\n  dp2[0] = 0;\n  for (int i2 = 0; i2 < n; i2++) {\n    int i = n - i2 - 1;\n    for (int j = '0'; j <= '9'; j++) {\n      if (t[i2] != '?' && t[i2] != j) continue;\n      if (s[i2] == j) {\n        dp1[i2 + 1] += dp1[i2];\n        dp1[i2 + 1] %= P;\n        dp1sum[i2 + 1] += (((j - '0') * po10[i] * dp1[i2]) % P + dp1sum[i2]) % P;\n        dp1sum[i2 + 1] %= P;\n        dp2[i2 + 1] += dp2[i2];\n        dp2[i2 + 1] %= P;\n        dp2sum[i2 + 1] += (((j - '0') * po10[i] * dp2[i2]) % P + dp2sum[i2]) % P;\n        dp2sum[i2 + 1] %= P;\n      } else if (s[i2] > j) {\n        dp2[i2 + 1] += dp1[i2] + dp2[i2];\n        dp2[i2 + 1] %= P;\n        dp2sum[i2 + 1] += (((j - '0') * po10[i] * (dp1[i2] + dp2[i2])) % P + dp1sum[i2] + dp2sum[i2]) % P;\n        dp2sum[i2 + 1] %= P;\n      } else {\n        dp2[i2 + 1] += dp2[i2];\n        dp2[i2 + 1] %= P;\n        dp2sum[i2 + 1] += (((j - '0') * po10[i] * dp2[i2]) % P + dp2sum[i2]) % P;\n      }\n    }\n  }\n\n  cout << (dp1sum[n] + dp2sum[n]) % P << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define dmp(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl;\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T,class U>\nostream& operator << (ostream& os,pair<T,U>& p){\n\tos << p.fi << ',' << p.sec; return os;\n}\ntemplate<class T,class U>\nistream& operator >> (istream& is,pair<T,U>& p){\n\tis >> p.fi >> p.sec; return is;\n}\ntemplate<class T>\nostream& operator << (ostream &os,const vector<T> &vec){\n\tfor(int i=0;i<vec.size();i++){\n\t\tos << vec[i];\n\t\tif(i+1<vec.size())os << ' ';\n\t}\n\treturn os;\n}\ntemplate<class T>\nistream& operator >> (istream &is,vector<T>& vec){\n\tfor(int i=0;i<vec.size();i++)is >> vec[i];\n\treturn is;\n}\nvoid fastio(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n}\n// How to devide :\n// ModInt a(6ll);\n// ModInt b(2ll);\n// a *= b.exp(MOD-2ll);  -> a/=b;  result: a = 3\nll MOD = 1000000007ll; // if inv is needed, this shold be prime.\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n};\nistream& operator>>(istream&i,ModInt&x){i>>x.val;return i;}\nostream& operator<<(ostream&o,const ModInt&x){o<<x.val;return o;}\nModInt pow(ModInt a,ll x){\n\tModInt res = ModInt(1ll);\n\twhile(x){\n\t\tif(x&1)res *= a;\n\t\tx >>= 1;\n\t\ta = a*a;\n\t}\n\treturn res;\n}\nconst int SIZE = 100100;\nModInt inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\tassert(!(n<r));\n\tassert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(){\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\treturn;\n}\nstring s,t;\nModInt dp[200100][2];\nModInt ep[200100][2];\nint main(){\n  cin >> s;\n  cin >> t;\n  ep[0][1]=ModInt(1ll);\n  for(int i=0;i<t.size();i++){\n    if(t[i]=='?'){\n      dp[i+1][0] += dp[i][0]*ModInt(100ll)+ep[i][0]*ModInt(45ll);\n      ep[i+1][0] += ep[i][0]*ModInt(10ll);\n      int c = (int)(s[i]-'0');\n      int sum = 0;\n      for(int j=0;j<c;j++)sum += j;\n      dp[i+1][0] += dp[i][1]*ModInt(10*c)+ep[i][1]*ModInt(sum);\n      ep[i+1][0] += ep[i][1]*ModInt(c);\n      dp[i+1][1] += dp[i][1]*ModInt(10ll)+ep[i][1]*ModInt(c);\n      ep[i+1][1] += ep[i][1];\n    }else{\n      int sc = (int)(s[i]-'0');\n      int tc = (int)(t[i]-'0');\n      if(tc==sc){\n        dp[i+1][1] += dp[i][1]*ModInt(10ll)+ep[i][1]*ModInt(tc);\n        ep[i+1][1] += ep[i][1];\n      }else if(tc<sc){\n        dp[i+1][0] += dp[i][1]*ModInt(10ll)+ep[i][1]*ModInt(tc);\n        ep[i+1][0] += ep[i][1];\n      }\n      dp[i+1][0] += dp[i][0]*ModInt(10ll)+ep[i][0]*ModInt(tc);\n      ep[i+1][0] += ep[i][0];\n    }\n    // cout << dp[i+1][0] << ' ' << dp[i+1][1] << endl; \n  }\n  cout << dp[t.size()][0]+dp[t.size()][1] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nchar S[SIZE], T[SIZE];\nll dp1[SIZE][2], dp2[SIZE][2];\n\nint main(){\n  int N;\n\n  scanf(\"%s%s\", S, T);\n\n  N = strlen(S);\n\n  dp1[0][1] = 1;\n\n  for(int i=0; i<N; i++) {\n    if (T[i] == '?') {\n      dp1[i+1][0] = (dp1[i][0] * 10 + dp1[i][1] * (S[i] - '0')) % mod;\n      dp1[i+1][1] = dp1[i][1] % mod;\n      dp2[i+1][0] = (dp2[i][1] * 10 * (S[i] - '0') + dp2[i][0] * 10 * 10 + dp1[i][0] * 45 + dp1[i][1] * ((S[i] - '0') * (S[i] - '0' - 1) / 2)) % mod;\n      dp2[i+1][1] = (dp2[i][1] * 10 + dp1[i][1] * (S[i] - '0')) % mod;\n    } else {\n      if(S[i] < T[i]) {\n        dp1[i+1][0] = (dp1[i+1][0] + dp1[i][0]) % mod;\n        dp2[i+1][0] = (dp2[i][0] * 10 + dp1[i][0] * (T[i] - '0')) % mod;\n      } else if (S[i] == T[i]) {\n        dp1[i+1][0] = (dp1[i+1][0] + dp1[i][0]) % mod;\n        dp1[i+1][1] = (dp1[i+1][1] + dp1[i][1]) % mod;\n        dp2[i+1][0] = (dp2[i][0] * 10 + dp1[i][0] * (T[i] - '0')) % mod;\n        dp2[i+1][1] = (dp2[i][1] * 10 + dp1[i][1] * (T[i] - '0')) % mod;\n      } else {\n        dp1[i+1][0] = (dp1[i][0] + dp1[i][1]) % mod;\n        dp2[i+1][0] = (dp2[i][0] * 10 + dp2[i][1] * 10 + (dp1[i][0] + dp1[i][1]) * (T[i] - '0')) % mod;\n      }\n    }\n  }\n\n  cout << (dp2[N][0] + dp2[N][1]) % mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint p10[300010];\nvoid add(int &a, const int &b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tp10[0] = 1;\n\tfor (int i = 1; i <= 300005; i++) {\n\t\tp10[i] = (p10[i - 1] * 10) % MOD;\n\t}\n\tstring S;\n\tcin >> S;\n\tstring T;\n\tcin >> T;\n\tint N = S.size();\n\n\tvector<vector<int> > dp(N + 1, vector<int>(2, 0));\n\tvector<vector<int> > sum(N + 1, vector<int>(2, 0));\n\tdp[0][0] = 1;\n\tsum[0][0] = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint mn, mx;\n\t\tif (T[i] == '?') {\n\t\t\tmx = 9;\n\t\t\tmn = 0;\n\t\t}\n\t\telse {\n\t\t\tmn = mx = T[i] - '0';\n\t\t}\n\t\tfor (int j = mn; j <= mx; j++) {\n\t\t\tint t = (j * p10[N - 1 - i]) % MOD;\n\t\t\tadd(dp[i + 1][1], dp[i][1]);\n\t\t\tadd(sum[i + 1][1], (sum[i][1] + dp[i][1] * t) % MOD);\n\t\t\tif (S[i] - '0' == j) {\n\t\t\t\tadd(dp[i + 1][0], dp[i][0]);\n\t\t\t\tadd(sum[i + 1][0], (sum[i][0] + dp[i][0] * t) % MOD);\n\t\t\t}\n\t\t\telse if (S[i] - '0' > j) {\n\t\t\t\tadd(dp[i + 1][1], dp[i][0]);\n\t\t\t\tadd(sum[i + 1][1], (sum[i][0] + dp[i][0] * t) % MOD);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tadd(res, sum.back()[0]);\n\tadd(res, sum.back()[1]);\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\nll dp[300000][2] = {0};\nll sum[300000][2] = {0};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s, t;\n    cin >> s >> t;\n    ll n = s.size();\n    dp[0][0] = 1;\n    for (ll i = 0; i < n; i++)\n    {\n        ll sNum = s[i] - '0';\n        ll tNum = t[i] - '0';\n        if (t[i] != '?')\n        {\n            if (sNum == tNum)\n            {\n                (dp[i + 1][0] += dp[i][0]) %= MOD;\n                (dp[i + 1][1] += dp[i][1]) %= MOD;\n                (sum[i + 1][1] += (sum[i][1] * 10 % MOD + dp[i][1] * tNum % MOD) % MOD) %= MOD;\n                (sum[i + 1][0] += (sum[i][0] * 10 % MOD + dp[i][0] * tNum % MOD) % MOD) %= MOD;\n            }\n            else if (sNum < tNum)\n            {\n                (dp[i + 1][1] += dp[i][1]) %= MOD;\n                (sum[i + 1][1] += (sum[i][1] * 10 % MOD + dp[i][1] * tNum % MOD) % MOD) %= MOD;\n            }\n            else\n            {\n                (dp[i + 1][1] += dp[i][1]) %= MOD;\n                (dp[i + 1][1] += dp[i][0]) %= MOD;\n                (sum[i + 1][1] += (sum[i][1] * 10 % MOD + dp[i][1] * tNum % MOD) % MOD) %= MOD;\n                (sum[i + 1][1] += (sum[i][0] * 10 % MOD + dp[i][0] * tNum % MOD) % MOD) %= MOD;\n            }\n        }\n        else\n        {\n            for (ll j = 0; j <= 9; j++)\n            {\n                tNum = j;\n                if (sNum == tNum)\n                {\n                    (dp[i + 1][0] += dp[i][0]) %= MOD;\n                    (dp[i + 1][1] += dp[i][1]) %= MOD;\n                    (sum[i + 1][1] += (sum[i][1] * 10 % MOD + dp[i][1] * tNum % MOD) % MOD) %= MOD;\n                    (sum[i + 1][0] += (sum[i][0] * 10 % MOD + dp[i][0] * tNum % MOD) % MOD) %= MOD;\n                }\n                else if (sNum < tNum)\n                {\n                    (dp[i + 1][1] += dp[i][1]) %= MOD;\n                    (sum[i + 1][1] += (sum[i][1] * 10 % MOD + dp[i][1] * tNum % MOD) % MOD) %= MOD;\n                }\n                else\n                {\n                    (dp[i + 1][1] += dp[i][1]) %= MOD;\n                    (dp[i + 1][1] += dp[i][0]) %= MOD;\n                    (sum[i + 1][1] += (sum[i][1] * 10 % MOD + dp[i][1] * tNum % MOD) % MOD) %= MOD;\n                    (sum[i + 1][1] += (sum[i][0] * 10 % MOD + dp[i][0] * tNum % MOD) % MOD) %= MOD;\n                }\n            }\n        }\n    }\n    cout << (sum[n][0] + sum[n][1]) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\n\nint main(){\n    string S,T;\n    cin >> S >> T;\n    int N = S.size();\n    vector<vector<ll>> dp(N+1,vector<ll>(2,0)),dp2(N+1,vector<ll>(2,0));\n    dp[0][1] = 0;\n    dp2[0][1]=1;\n    for(int i=0;i<N;i++){\n        if(T[i]=='?'){\n            for(char c = '0';c<='9';c++){\n                ll n = c-'0';\n                if(c==S[i]){\n                    if(dp[i][0]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][0];\n                    }\n                    if(dp[i][1]!=-1){\n                        if(dp[i+1][1]!=-1) (dp[i+1][1] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        else (dp[i+1][1] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        dp2[i+1][1]+=dp2[i][1];\n                    }\n                }else if(S[i]>c){\n                    if(dp[i][0]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][0];\n                    }\n                    if(dp[i][1]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][1];\n                    }\n                }else{\n                    if(dp[i][0]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][0];\n                    }\n                }\n            }\n        }else{\n            ll n = T[i]-'0';\n                if(T[i]==S[i]){\n                    if(dp[i][0]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][0];\n                    }\n                    if(dp[i][1]!=-1){\n                        if(dp[i+1][1]!=-1) (dp[i+1][1] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        else (dp[i+1][1] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        dp2[i+1][1]+=dp2[i][1];\n                    }\n                }else if(S[i]>T[i]){\n                    if(dp[i][0]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][0];\n                    }\n                    if(dp[i][1]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][1]*10+dp2[i][1]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][1];\n                    }\n                }else{\n                    if(dp[i][0]!=-1){\n                        if(dp[i+1][0]!=-1) (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        else (dp[i+1][0] += dp[i][0]*10+dp2[i][0]*n)%=mod;\n                        dp2[i+1][0]+=dp2[i][0];\n                    }\n                }\n        }\n        dp2[i+1][0]%=mod;\n        dp2[i+1][1]%=mod;\n    }\n    ll ans = 0;\n    if(dp[N][0]!=-1) (ans += dp[N][0])%=mod;\n    if(dp[N][1]!=-1) (ans += dp[N][1])%=mod;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[200010][2],dp2[200010];\nint cnt[200010];\nconst int mod=1e9+7;\n\nint modPow(int x,int n)\n{\n    int res=1;\n    while(n>0){\n        if(n&1) res=res*x%mod;\n        x=x*x%mod;\n        n>>=1;\n    }\n    return res;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s,t; cin>>s>>t;\n    int N=s.size();\n    reverse(s.begin(),s.end());\n    reverse(t.begin(),t.end());\n\n    for(int i=0;i<N;i++){\n        cnt[i+1]=cnt[i]+(t[i]=='?');\n    }\n\n    dp[N][0]=1;\n    for(int i=N-1;i>=0;i--){\n        if(t[i]=='?'){\n            dp[i][1]=dp[i+1][1]*10%mod+dp[i+1][0]*(s[i]-'0')%mod;\n            dp[i][1]%=mod;\n            dp[i][0]=dp[i+1][0];\n        }else{\n            dp[i][1]=dp[i+1][1]+(t[i]<s[i]? dp[i+1][0]:0);\n            dp[i][1]%=mod;\n            dp[i][0]=(t[i]==s[i]? dp[i+1][0]:0);\n        }\n    }\n\n    dp2[0]=1;\n    for(int i=0;i<N;i++){\n        if(t[i]=='?'){\n            dp2[i+1]=dp2[i]+(s[i]-'0')*modPow(10,cnt[i])%mod;\n            dp2[i+1]%=mod;\n        }else{\n            if(t[i]<s[i]) dp2[i+1]=modPow(10,cnt[i]);\n            else if(t[i]==s[i]) dp2[i+1]=dp2[i];\n            else dp2[i+1]=0;\n        }\n    }\n\n    int sum=0;\n    for(int i=0;i<N;i++){\n        for(int d=0;d<10;d++){\n            if(t[i]!='?' and t[i]-'0'!=d) continue;\n            int k;\n            if(d<s[i]-'0'){\n                k=(dp[i+1][0]+dp[i+1][1])*modPow(10,cnt[i])%mod;\n            }else if(d==s[i]-'0'){\n                k=dp[i+1][1]*modPow(10,cnt[i])%mod+dp[i+1][0]*dp2[i];\n                k%=mod;\n            }else{\n                k=dp[i+1][1]*modPow(10,cnt[i])%mod;\n            }\n            k=k*d%mod*modPow(10,i)%mod;\n            sum=(sum+k)%mod;\n        }\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 200005\n\nenum Type{\n\n\tSAME,\n\tSMALL,\n};\n\n\nint length;\nll sum_table[2][SIZE],count_table[2][SIZE];\nchar S[SIZE],T[SIZE];\nType type_array[2] = {SAME,SMALL};\n\n\nint main(){\n\n\tscanf(\"%s\",S);\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; S[length] != '\\0'; length++);\n\n\tfor(int i = 0; i < length; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\n\t\t\tsum_table[k][i] = 0;\n\t\t\tcount_table[k][i] = 0;\n\t\t}\n\t}\n\n\tcount_table[SAME][0] = 1;\n\n\tType type;\n\n\tfor(int i = 0; i <= length-1; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\n\t\t\ttype = type_array[k];\n\t\t\tif(count_table[type][i] == 0)continue;\n\n\t\t\tfor(ll num = 0; num <= 9; num++){\n\t\t\t\tif(T[i] != '?' && (T[i]-'0') != num)continue;\n\n\t\t\t\tif(type == SAME){\n\n\t\t\t\t\tif(num > S[i]-'0')continue;\n\n\t\t\t\t\tif(num == S[i]-'0'){\n\n\t\t\t\t\t\tcount_table[SAME][i+1] = 1;\n\t\t\t\t\t\tsum_table[SAME][i+1] = (sum_table[SAME][i]*10+num)%MOD;\n\n\t\t\t\t\t}else{ //num < S[i]-'0'\n\n\t\t\t\t\t\tcount_table[SMALL][i+1] += 1;\n\t\t\t\t\t\tsum_table[SMALL][i+1] += (sum_table[SAME][i]*10+num)%MOD;\n\t\t\t\t\t\tsum_table[SMALL][i+1] %= MOD;\n\t\t\t\t\t}\n\n\t\t\t\t}else{ //type == SMALL\n\n\t\t\t\t\tcount_table[SMALL][i+1] += count_table[SMALL][i];\n\t\t\t\t\tcount_table[SMALL][i+1] %= MOD;\n\t\t\t\t\tsum_table[SMALL][i+1] += (sum_table[SMALL][i]*10+num*count_table[SMALL][i])%MOD;\n\t\t\t\t\tsum_table[SMALL][i+1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",(sum_table[SAME][length]+sum_table[SMALL][length])%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define ll long long\n#define MOD 1000000007\n#define add0(p,q)(p=(p+(q))%MOD)\n#define add1(p,q)(p=(p+(q)-1)%MOD+1)\n\nll dp[200010][2];//dp[i][j]=下からi桁見て小さいことが確定してい(j?る:ない)ものの和\nll cnt[200010][2];//dp[i][j]=下からi桁見て小さいことが確定してい(j?る:ない)ものの個数\nchar s[200010],t[200010];\nint main(){\n\tscanf(\"%s%s\",s,t);\n\tint n=strlen(s);\n\tll p10=1;\n\tcnt[n][1]=1;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(t[i]=='?'){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tadd0(dp [i][k< s[i]-'0'],dp[i+1][0]+k*p10*cnt[i+1][0]);\n\t\t\t\tadd1(cnt[i][k< s[i]-'0'],cnt[i+1][0]);\n\t\t\t\tadd0(dp [i][k<=s[i]-'0'],dp[i+1][1]+k*p10*cnt[i+1][1]);\n\t\t\t\tadd1(cnt[i][k<=s[i]-'0'],cnt[i+1][1]);\n\t\t\t}\n\t\t}else{\n\t\t\tint k=t[i]-'0';\n\t\t\tadd0(dp [i][k< s[i]-'0'],dp[i+1][0]+k*p10*cnt[i+1][0]);\n\t\t\tadd1(cnt[i][k< s[i]-'0'],cnt[i+1][0]);\n\t\t\tadd0(dp [i][k<=s[i]-'0'],dp[i+1][1]+k*p10*cnt[i+1][1]);\n\t\t\tadd1(cnt[i][k<=s[i]-'0'],cnt[i+1][1]);\n\t\t}\n\t\tp10=p10*10%MOD;\n\t}\n\tprintf(\"%d\\n\",dp[0][1]);\n}\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n\ndef solve():\n    s = list(map(int, input()))\n    t = list(input())\n    n = len(t)\n    for i in range(n):\n        if t[i].isdecimal():\n            t[i] = int(t[i])\n    dp = [[[0]*2 for j in range(2)] for i in range(n+1)]\n    dp[0][0] = [1,0]\n    p = [pow(10,i,mod) for i in range(n)]\n    for i in range(n):\n        ni = i+1\n        for j in range(2):\n            if t[i] == \"?\":\n                x = 9 if j else s[i]\n                for d in range(x+1):\n                    nj = j|(d < s[i])\n                    dp[ni][nj][0] += dp[i][j][0]\n                    dp[ni][nj][1] += dp[i][j][0]*d+10*dp[i][j][1]\n                    dp[ni][nj][0] %= mod\n                    dp[ni][nj][1] %= mod\n            else:\n                d = t[i]\n                nj = j|(d < s[i])\n                if d <= s[i]:\n                    dp[ni][nj][0] += dp[i][j][0]\n                    dp[ni][nj][1] += dp[i][j][0]*d+10*dp[i][j][1]\n                    dp[ni][nj][0] %= mod\n                    dp[ni][nj][1] %= mod\n                else:\n                    if nj:\n                        dp[ni][nj][0] += dp[i][j][0]\n                        dp[ni][nj][1] += dp[i][j][0]*d+10*dp[i][j][1]\n                        dp[ni][nj][0] %= mod\n                        dp[ni][nj][1] %= mod\n\n    print((dp[-1][0][1]+dp[-1][1][1])%mod)\n    return\n\n\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n    pub fn comb(n: u32, k: u32) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        let k = std::cmp::min(k, n - k);\n        let mut nu = ModInt::one();\n        let mut de = ModInt::one();\n        for i in 0..k {\n            nu *= ModInt(n - i);\n            de *= ModInt(i + 1);\n        }\n        nu * de.inv()\n    }\n}\n\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end ModInt ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn run() {\n    input! {\n        s: chars,\n        t: chars,\n    }\n    let mut sum = ModInt::zero();\n    let mut cnt = ModInt::zero();\n    let mut sup = ModInt::zero();\n    let mut sup_cnt = ModInt::one();\n    let f = ModInt(10);\n    for (s, t) in s.iter().zip(t.iter()) {\n        let x = s.to_digit(36).unwrap();\n        if *t == '?' {\n            let mut next_sum = ModInt::zero();\n            let mut next_cnt = ModInt::zero();\n            for i in 0..10 {\n                next_sum += f * sum + ModInt(i) * cnt;\n                next_cnt += cnt;\n            }\n            for i in 0..x {\n                next_sum += f * sup + ModInt(i) * sup_cnt;\n                next_cnt += sup_cnt;\n            }\n            sum = next_sum;\n            cnt = next_cnt;\n            sup = sup_cnt * (f * sup + ModInt(x));\n        } else {\n            let y = t.to_digit(36).unwrap();\n            if y > x {\n                sum = f * sum + ModInt(y) * cnt;\n                sup_cnt = ModInt(0);\n                sup = ModInt(0);\n            } else if y < x {\n                sum = ModInt(10) * sum + ModInt(y) * cnt;\n                sup = sup_cnt * (ModInt(10) * sup + ModInt(y));\n                sum += sup;\n                cnt += sup_cnt;\n                sup = ModInt::zero();\n                sup_cnt = ModInt::zero();\n            } else {\n                sum = f * sum + ModInt(y) * cnt;\n                sup = f * sup + ModInt(y) * sup_cnt;\n            }\n        }\n    }\n    let ans = sum + sup;\n    println!(\"{}\", ans.0);\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]