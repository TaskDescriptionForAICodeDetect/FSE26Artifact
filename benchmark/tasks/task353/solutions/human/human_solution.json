[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i]* 2.0l -vertics[(i+2)%3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = i + 1; j < s.size(); ++j) {\n\t\t\tif (isis_ss( s[i],  s[j])) {\n\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <s.size(); ++i) {\n\t\tcrss.push_back( s[i][0]);\n\t\tcrss.push_back( s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif ((adis - dis) > eps)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t}\n\t\tvector<Line>nls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tnls.push_back(ls[i]);\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = p + bisvec / (abs(bis[1] - bis[0]))*dis;\n\t\t\t\tPoint kouho2 = p - bisvec / (abs(bis[1] - bis[0]))*dis;\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n, n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1) cout << fixed << ans[0].real() << \" \" << ans[0].imag() << endl;\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n      else cout << \"None\" << endl;\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=abs(a[i].fir-tmp)<eps?a[i].sec:a[i].fir;\n\tP bt=abs(a[j].fir-tmp)<eps?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size()&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif ((cnt==0||abs(ans-cand)>1e-05) && check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    if (n == 1||n ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn (l.first-x).cross(l.second-x) == 0;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\ttmp.push_back(make_pair((p[i]+p[j])*0.5, (q[i]+q[j])*0.5));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\telse if(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec.clear();\n\t\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec.clear();\n\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\nPt hLP(Pt a,Pt b,Pt c){\n\treturn pLL(a,b,c,c+(b-a)*Pt(0,1));\n}\ndouble ax[110];\ndouble ay[110];\ndouble bx[110];\ndouble by[110];\nPt p[110];\nPt q[110];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",ax+i,ay+i,bx+i,by+i);\n\t\t\tp[i]=Pt(ax[i],ay[i]);\n\t\t\tq[i]=Pt(bx[i],by[i]);\n\t\t}\n\t\tint ret=0;\n\t\tPt v=Pt(0,0);\n\t\tfor(int i=0;i<50;i++){\n\t\t\tPt at=Pt((double)(rand()%20000-10000),(double)(rand()%20000-10000));\n\t\t\tdouble ks=100;\n\t\t\tfor(int j=0;j<3000;j++){\n\t\t\t\tdouble dis=-9999;\n\t\t\t\tint ind=0;\n\t\t\t\tdouble tl=99999999;\n\t\t\t\tdouble tr=0;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tdouble tmp=dLP(p[k],q[k],at);\n\t\t\t\t\ttl=min(tl,tmp);\n\t\t\t\t\ttr=max(tr,tmp);\n\t\t\t\t\tif(tmp>dis){\n\t\t\t\t\t\tdis=tmp;\n\t\t\t\t\t\tind=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tr-tl<1e-6)break;\n\t\t\t\tPt dv=hLP(p[ind],q[ind],at)-at;\n\t\t\t\tdv=dv/dv.ABS()*ks;\n\t\t\t\tat=at+dv;\n\t\t\t\tif((j+1)%100==0){\n\t\t\t\t\tks/=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble L=9999999;\n\t\t\tdouble R=0;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble tmp=dLP(p[j],q[j],at);\n\t\t\t\tL=min(L,tmp);\n\t\t\t\tR=max(R,tmp);\n\t\t\t}\n\t\t\tif(R-L<1e-5){\n\t\t//\t\tprintf(\"(%f, %f)\\n\",at.x,at.y);\n\t\t\t\tif(!ret){ret++;v=at;}\n\t\t\t\telse{\n\t\t\t\t\tif((v-at).ABS()>1e-5)ret++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ret>1)break;\n\t\t}\n\t\tif(ret>1)printf(\"Many\\n\");\n\t\telse if(!ret)printf(\"None\\n\");\n\t\telse{\n\t\t\tprintf(\"%f %f\\n\",v.x,v.y);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-10;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define EPS (1.0e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n  bool operator < (const Point &p) const {\n    if(!equals(x, p.x)) return x < p.x;\n    if(!equals(y, p.y)) return y < p.y;\n    return false;\n  }\n  bool operator == (const Point &p) const {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Line s1, Line s2) {\n  return isParallel(s1.p2-s1.p1, s2.p2-s2.p1);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Line s1, Line s2) {\n  Vector a = s1.p2 - s1.p1;\n  Vector b = s2.p2 - s2.p1;\n  double d1 = cross(b, s2.p1 - s1.p1);\n  double d2 = cross(b, a);\n  return s1.p1 + a * d1/d2;\n}\n\nVector getOthogonalV(Vector a) {\n  return Vector(-a.y, a.x);\n}\n\nLine getOthogonalL(Line s) {\n  Line res;\n  res.p1 = s.p1;\n  res.p2 = s.p1 + getOthogonalV(s.p2 - s.p1);\n  return res;\n}\n\ndouble getDistanceLP(Line s, Point p) {\n  return fabs(cross(s.p2 - s.p1, p - s.p1))/abs(s.p2 - s.p1);\n}\n\nint N;\nLine S[100];\n\nvoid getBisector(vector<Line> &v) {\n  for(int i = 0; i < 1; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      Vector a = S[i].p2 - S[i].p1;\n      Vector b = S[j].p2 - S[j].p1;\n      if(isParallel(S[i], S[j])) {\n\tdouble d = getDistanceLP(S[i], S[j].p1)/2.0;\n\tVector vn;\n\tif(ccw(S[i].p1, S[i].p2, S[j].p1) >= 1) {\n\t  vn.x = -a.y;\n\t  vn.y = a.x;\n\t} else {\n\t  vn.x = a.y;\n\t  vn.y = -a.x;\n\t}\n\tvn = vn*d/abs(vn);\n\tLine l;\n\tl.p1 = S[i].p1 + vn;\n\tl.p2 = S[i].p2 + vn;\n\tv.push_back(l);\n      } else {\n\tPoint p = getCrossPoint(S[i], S[j]);\n\tLine l;\n\tl.p1 = p;\n\tl.p2 = p + b+a*sqrt(norm(b)/norm(a));\n\tv.push_back(l);\n\tv.push_back(getOthogonalL(l));\n      }\n    }\n  }\n}\n\nvoid solve() {\n  if(N <= 2) {\n    cout << \"Many\" << endl;\n    return;\n  }\n\n  vector<Line> v;\n  getBisector(v);\n\n  vector<Point> cp;\n  for(int i = 0; i < v.size(); ++i) {\n    for(int j = i+1; j < v.size(); ++j) {\n      if(isParallel(v[i], v[j])) continue;\n      cp.push_back(getCrossPoint(v[i], v[j]));\n    }\n  }\n  sort(cp.begin(), cp.end());\n  cp.erase(unique(cp.begin(), cp.end()), cp.end());\n  int count = 0;\n  Point ans;\n  for(vector<Point>::iterator ii = cp.begin(); ii != cp.end(); ++ii) {\n    double d = getDistanceLP(S[0], *ii);\n    bool flag = true;\n    for(int j = 1; j < N; ++j) {\n      if(!equals(d, getDistanceLP(S[j], *ii))) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      ++count;\n      if(count >= 2) break;\n      ans = *ii;\n    }\n  }\n\n  if(count == 0) cout << \"None\" << endl;\n  else if(count == 1) printf(\"%.5f %.5f\\n\", ans.x, ans.y);\n  else if(count >= 2) cout << \"Many\" << endl;\n}\n\nmain() {\n  while((cin >> N) && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].p1.x >> S[i].p1.y >> S[i].p2.x >> S[i].p2.y;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > 1e-7 )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); assert(0); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-5;\nconst double pi = acos(-1.0);\nconst double mag = 1;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d)&&eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-5;\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nbool lineCross(L l, L m){\n\treturn abs(imag((l.first-l.second)/(m.first-m.second)))<EPS;\n}\n\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.second-a.first, b.second-b.first);\n\tdouble B = cross(a.second-a.first, a.second-b.first);\n\treturn b.first + B/A*(b.second-b.first);\n}\n\nvector<L> distLine(L l, L m){\n\tvector<L> res;\n\tif(lineCross(l,m)){\n\t\tP a = (l.first+m.first)/2.0;\n\t\tP b = a+(l.second-l.first)/abs(l.second-l.first);\n\t\tres.push_back(make_pair(a,b));\n\t} else {\n\t\tP a = ssCrosspoint(l, m);\n\t\tif(abs(l.first-a)<EPS) swap(l.first, l.second);\n        P dirA = (l.first-a)/abs(l.first-a);\n\t\tif(abs(m.first-a)<EPS) swap(m.first, m.second);\n\t\tP dirB = (m.first-a)/abs(m.first-a);\n\t\tP b = a + (dirA+dirB)/abs(dirA+dirB);\n\t\tres.push_back(make_pair(a,b));\n\t\tres.push_back(make_pair(a,(b-a)*P(0,1)+a));\n\t}\n\treturn res;\n}\n\nbool onLine(L a, P p){\n\treturn abs(imag((p-a.first)/(a.second-a.first)))<EPS;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector< pair<P, P> > vp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble a, b, c, d; cin >> a >> b >> c >> d;{\n\t\t\t\tvp.push_back(make_pair(P(a,b),P(c,d)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n<3){ puts(\"Many\"); continue; }\n\n\t\tvector<P> vpt;\n\t\tvector<L> vlA = distLine(vp[0],vp[1]), vlB = distLine(vp[0], vp[2]);\n\t\tfor(int i=0;i<vlA.size();i++){\n\t\t\tfor(int j=0;j<vlB.size();j++){\n\t\t\t\tif(lineCross(vlA[i],vlB[j])) continue;\n\t\t\t\tvpt.push_back(ssCrosspoint(vlA[i],vlB[j]));\n\t\t\t}\n\t\t}\n\t\tif(!vpt.empty()){\n\t\t\tvector<P> tmp;\n\t\t\ttmp.push_back(vpt[0]);\n\t\t\tfor(int i=1;i<vpt.size();i++){\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\t\t\tif(abs(tmp[j]-vpt[i])<EPS) flag = true;\n\t\t\t\tif(!flag) tmp.push_back(vpt[i]);\n\t\t\t}\n\t\t\tvpt = tmp;\n\t\t}\n\t\tfor(int i=0;i<1;i++){\n\t\t\tfor(int j=3;j<n;j++){\n\t\t\t\tvector<P> nvp;\n\t\t\t\tfor(int k=0;k<vpt.size();k++){\n\t\t\t\t\tvector<L> vL = distLine(vp[i],vp[j]);\n\t\t\t\t\tbool flag = false;\n\t\t\t\t\tfor(int l=0;l<vL.size();l++){\n\t\t\t\t\t\tif(onLine(vL[l],vpt[k])){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) nvp.push_back(vpt[k]);\n\t\t\t\t}\n\t\t\t\tvpt = nvp;\n\t\t\t}\n\t\t}\n\t\tif(vpt.empty()) { puts(\"None\"); }\n\t\telse if(vpt.size()>1) { puts(\"Many\"); }\n\t\telse {\n\t\t\tprintf(\"%.5lf %.5lf\\n\", real(vpt[0]), imag(vpt[0]));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst bool debug = false;\n\ntypedef long double real;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nconst real EPS = 1e-6;\n\nbool EQ(real x, real y) {\n    return abs(x - y) < EPS;\n}\n\nstruct Point {\n    real x, y;\n    Point() {}\n    Point(real x, real y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(real k) const { return Point(k * x, k * y); }\n    Point operator/(real k) const { return Point(x / k, y / k); }\n};\nreal dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\nreal cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\nreal norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nbool EQ(const Point& a, const Point& b) {\n    return EQ(a.x, b.x) && EQ(a.y, b.y);\n}\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n};\nbool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\nistream& operator>>(istream& is, Line& l) { return is >> l.a >> l.b; }\nostream& operator<<(ostream& os, const Line& l) { return os << \"Line(\" << l.a << \",\" << l.b << \")\"; }\n\nPoint projection(const Line& l, const Point& p) {\n    Point u = (p - l.a), v = (l.b - l.a);\n    return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n}\n\nPoint crosspoint(const Line& s, const Line& t) {\n    double d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n}\n\nint N;\nvector<Line> L;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    L.clear(); L.resize(N);\n    for (int i = 0; i < N; i++) cin >> L[i];\n    return true;\n}\n\nPoint unit(const Point& v) {\n    return v / norm(v);\n}\n\nLine rot90(const Line& l, const Point& c) {\n    return Line( rot90(l.a - c) + c, rot90(l.b - c) + c );\n}\n\nvector<Line> midline(const Line& s, const Line& t) {\n    if (parallel(s, t)) {\n        Point p = projection(t, s.a),\n              q = projection(t, s.b);\n        return vector<Line>(1, Line( (s.a + p) / 2, (s.b + q) / 2 ));\n    } else {\n        Point c = crosspoint(s, t);\n        Line ret;\n        Point p = projection(t, s.a);\n        real d = norm(s.a - c);\n        Point q = c + unit(t.b - t.a) * d;\n        ret.a = (s.a + q) / 2;\n\n        p = projection(t, s.b);\n        d = norm(s.b - c);\n        q = c + unit(t.b - t.a) * d;\n        ret.b = (s.b + q) / 2;\n        vector<Line> lret(2);\n        lret[0] = ret;\n        lret[1] = rot90(ret, c);\n        return lret;\n    }\n}\n\nreal dist(const Line& l, const Point& p) {\n    Point q = projection(l, p);\n    return norm(q - p);\n}\n\nvoid solve() {\n    if (N <= 2) {\n        cout << \"Many\" << endl;\n        return;\n    }\n\n    vector<Line> X, Y;\n    X = midline(L[0], L[1]);\n    Y = midline(L[1], L[2]);\n\n    vector<Point> C;\n\n    for (int i = 0; i < X.size(); i++) {\n        for (int j = 0; j < Y.size(); j++) {\n            if (parallel(X[i], Y[j])) continue;\n            C.push_back(crosspoint(X[i], Y[j]));\n        }\n    }\n\n    if (debug) {\n        cerr << \"X: \" << X << endl;\n        cerr << \"Y: \" << Y << endl;\n    }\n    \n    if (C.empty()) {\n        cout << \"None\" << endl;\n        return;\n    }\n\n    vector<Point> ans;\n    for (int i = 0; i < C.size(); i++) {\n        Point p = C[i];\n        real d = dist(L[0], p);\n        for (int i = 0; i < N; i++) {\n            if (!EQ(dist(L[i], p), d)) {\n                goto next;\n            }\n        }\n        ans.push_back(p);\n        next:;\n    }\n\n    if (ans.size() >= 2) {\n        cout << \"Many\" << endl;\n    } else if (ans.empty()) {\n        cout << \"None\" << endl;\n    } else {\n        printf(\"%.12Lf %.12Lf\\n\", ans[0].x, ans[1].y);\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1){\n    REP(j,i+1,a.size()){\n//       cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n// \t   << a[j].fir <<\" \" << a[j].sec << endl;\n//       cout << j<<\" \"<< is_intersected_ll(\n// \t\t\t\t\t a[i].fir,a[i].sec,\n// \t\t\t\t\t a[j].fir,a[j].sec)<<\n// \t\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && EQV(ans,cand))continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-5;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\n\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint projection(Line l, Point p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) throw 0; // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<Line> ls;\n        REP(i, n){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        if(n <= 2){\n            cout << \"Many\" << endl;\n            continue;\n        }\n        vector<Line> cand_line;\n        for(int i = 0; i < n; i++)\n        for(int j = i + 1; j < n; j++){\n            if(paralell(ls[i], ls[j])){\n                Point t = projection(ls[j], ls[i][0]);\n                Line l(ls[i][0] + 0.5 * t, ls[i][1] + 0.5 * t);\n                cand_line.push_back(l);\n            }else{\n                Point t = crosspointLL(ls[i], ls[j]);\n                Line l(t, t + ls[i].vector() + ls[j].vector());\n                cand_line.push_back(l);\n                Line m(t, t + ls[i].vector() - ls[j].vector());\n                cand_line.push_back(m);\n            }\n        }\n\n        bool ans_exist = false;\n        bool many = false;\n        Point answer;\n        for(int i = 0; i < cand_line.size(); i++)\n        for(int j = i + 1; j < cand_line.size(); j++){\n            try{\n                Point p = crosspointLL(cand_line[i], cand_line[j]);\n                double d = distanceLP(ls[0], p);\n                bool ok = true;\n                for(int k = 0; k < n; k++){\n                    if(abs(d - distanceLP(ls[k], p)) > EPS){\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok){\n                    if(ans_exist && abs(answer - p) > EPS){\n                        many = true;\n                        goto OUTPUT;\n                    }\n                    if(!ans_exist){\n                        ans_exist = true;\n                        answer = p;\n                    }\n                }\n            }catch(...){\n            }\n        }\n        OUTPUT:\n        if(many){\n            cout << \"Many\" << endl;\n        }else if(ans_exist){\n            printf(\"%.12f %.12f\\n\", answer.real(), answer.imag());\n        }else{\n            cout << \"None\" << endl;\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-5)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          /*\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          */\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-1;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n\tpoint is;\n\tif(intersectionLL( vl[i], vl[j], is)){\n\t  vec va;\n\t  vec vb;\n\t  \n\t  if( far(is,vl[i].fr) ){\n\t    va = uvec(vl[i].fr-is);\n\t  }else{\n\t    va = uvec(vl[i].sc-is);\n\t  }\n\t  \n\t  if( far(is,vl[j].fr) ){\n\t    vb = uvec(vl[j].fr-is);\n\t  }else{\n\t    vb = uvec(vl[j].sc-is);\n\t  }\n\t  \n\t  bisector.push_back( line( is, is+va+vb ) );\n\t  bisector.push_back( line( is, is+va-vb ) );\n\t  \n\t}else{\n\t  elem d = 0.5 * dist_l( vl[j], vl[i].fr );\n\t  point is;\n\t  intersectionLL( line(vl[i].fr, vl[i].fr+unmr(vl[i].sc-vl[i].fr) ), vl[j], is );\n\t  \n\t  point cfr = d * uvec(is-vl[i].fr) + vl[i].fr;\n\t  point csc = d * uvec(is-vl[i].fr) + vl[i].sc;\n\t  bisector.push_back( line(cfr,csc) );\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\n\tif( ccw(bisector[i].fr,bisector[i].sc,bisector[j].fr) & (OVER|FRONT|BACK) &&\n\t    ccw(bisector[i].fr,bisector[i].sc,bisector[j].sc) & (OVER|FRONT|BACK) ) continue;\n\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      break;\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n \nconst double EPS = 1e-6;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n \nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n \ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n \nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nvector<L> equidist(const L &a, const L &b){\n    vector<L> ret;\n    if(isParallel(a, b)){\n        P mid = (a[0]+b[0])/2.0;\n        ret.push_back( L(mid, mid+(a[1]-a[0])) );\n    }else{\n        P cp = crosspointLL(a, b);\n        P v1 = unit(a[1]-a[0])*1000.0, v2 = unit(b[1]-b[0])*1000.0;\n        ret.push_back( L(cp, cp+ (v1+v2)/2.0) );\n        ret.push_back( L(cp, cp+ (v1-v2)/2.0) );\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n         \n        vector<L> l(n);\n        for(int i=0; i<n; i++){\n            int x1,y1,x2,y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            l[i] = L(P(x1,y1), P(x2,y2));\n        }\n\n        if(n <= 2){\n            cout << \"Many\" << endl;\n            continue;\n        }else if(isParallel(l[0], l[1]) && isParallel(l[1], l[2])){\n            cout << \"None\" << endl;\n            continue;\n        }\n\n        vector<L> ml;\n        for(int i=0; i<3; i++){\n            vector<L> cl = equidist(l[i], l[(i+1)%3]);\n            copy(cl.begin(), cl.end(), back_inserter(ml));\n        }\n        VP cand;\n        for(int i=0; i<(int)ml.size(); i++){\n            for(int j=i+1; j<(int)ml.size(); j++){\n                if(!isParallel(ml[i], ml[j])){\n                    cand.push_back(crosspointLL(ml[i], ml[j]));\n                }\n            }\n        }\n        sort(cand.begin(), cand.end());\n        cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n        int count = 0;\n        P ans;\n        for(int i=0; i<(int)cand.size(); i++){\n            bool success = true;\n            double dist = distanceLP(l[0], cand[i]);\n            for(int j=1; j<n; j++){\n                if(!EQ(dist, distanceLP(l[j], cand[i]))){\n                    success = false;\n                    break;\n                }\n            }\n            if(success){\n                count++;\n                ans = cand[i];\n            }\n        }\n\n        if(count==0){\n            cout << \"None\" << endl;\n        }else if(count >= 2){\n            cout << \"Many\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans.X << \" \" << ans.Y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\nint n;\nvector<L> A;\n\nbool check(P a){\n  double dis = getDistanceSP(A[0],a);\n  for(int i=0;i<n;i++)\n    if(abs(dis - getDistanceSP(A[i],a)) > EPS) return 0;\n  return 1;\n}\n\nvoid update(P &ans,int &flg,P t){\n  bool res = check(t);\n  if(!flg&& res) ans = t,flg = 1;\n  else if(flg && res && abs(ans.real()-t.real())+abs(ans.imag() - t.imag())>1e-6) flg = 2;\n}\n\nint main(){\n  while(cin>>n,n){\n    A.resize(n);\n    for(int i=0,x1,y1,x2,y2;i<n;i++){\n      cin>>x1>>y1>>x2>>y2;\n      A[i] = make_pair(P(x1,y1),P(x2,y2));\n    }\n\n    P ans;\n    int flg=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i == j)continue;\n\tif(isIntersect(A[i],A[j]))update(ans,flg,crossPoint(A[i],A[j]));\n\tvector<P>I({A[i].first,A[i].second}),J({A[j].first,A[j].second});\n\tfor(int k=0;k<2;k++)\n\t  for(int l=0;l<2;l++){\n\t    P a1 = I[k], b1= J[l];\n\t    P a2 = I[!k],b2= J[!l];\n\t    L s = make_pair(a1,b1);\n\t    L t = make_pair(a2,b2);\n\t    if(isIntersect(s,t))update(ans,flg,crossPoint(s,t));\n\t  }\n      }\n    \n    if(n==2||flg==2) cout<<\"Many\"<<endl; \n    else if(flg==1) printf(\"%f %f\\n\",ans.real(),ans.imag());\n    else cout<<\"None\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-12)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n, n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8f %.8f\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-1;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n\tpoint is;\n\tif(intersectionLL( vl[i], vl[j], is)){\n\t  vec va;\n\t  vec vb;\n\t  \n\t  if( far(is,vl[i].fr) ){\n\t    va = uvec(vl[i].fr-is);\n\t  }else{\n\t    va = uvec(vl[i].sc-is);\n\t  }\n\t  \n\t  if( far(is,vl[j].fr) ){\n\t    vb = uvec(vl[j].fr-is);\n\t  }else{\n\t    vb = uvec(vl[j].sc-is);\n\t  }\n\t  \n\t  bisector.push_back( line( is, is+va+vb ) );\n\t  bisector.push_back( line( is, is+va-vb ) );\n\t  \n\t}else{\n\t  elem d = 0.5 * dist_l( vl[j], vl[i].fr );\n\t  point is;\n\t  intersectionLL( line(vl[i].fr, vl[i].fr+unmr(vl[i].sc-vl[i].fr) ), vl[j], is );\n\t  \n\t  point cfr = d * uvec(is-vl[i].fr) + vl[i].fr;\n\t  point csc = d * uvec(is-vl[i].fr) + vl[i].sc;\n\t  bisector.push_back( line(cfr,csc) );\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n    /*    \n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-6;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    if(sign(cross(vec1, vec2)) == 0){\n        res.push_back(Line((l[0] + m[0]) / 2.0, (l[1] + m[1]) / 2.0));\n    }else{\n        Point p = crosspointLL(l, m);\n        res.push_back(Line(p, p + vec1 + vec2));\n        res.push_back(Line(p, p + vec1 - vec2));\n    }\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 1; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n            //if(paralell(lines[i], lines[j])) continue;\n        vector<Line> mids = get_midline(lines[0], lines[i]);\n        midlines.insert(midlines.end(), mids.begin(), mids.end());\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 0; k < lines.size(); k++){\n                for(int k2 = 0; k2 < lines.size(); k2++){\n                    if(sign(distanceLP(lines[k], p) - distanceLP(lines[k2], p)) != 0){\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.9f %.9f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-9)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tlong double d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tlong double A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n\n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n          ans = nans;\n            \n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n    \n    //FOR(it,ans) cout << *it << endl;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-3;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\t\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP pos = projection(ls[i],ls[j][0]);\n\t\t\t\t\t\tP vec = ls[j][0]-pos;\n\t\t\t\t\t\tln.push_back(L(pos,pos+vec/2.));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > EPS )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-9L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/(long double)2.0,\n                       (V[0].first+V[j].first)/(long double)2.0 + V[0].second - V[0].first);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.size() == 0) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define EPS (1.0e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n  bool operator < (const Point &p) const {\n    if(!equals(x, p.x)) return x < p.x;\n    if(!equals(y, p.y)) return y < p.y;\n    return false;\n  }\n  bool operator == (const Point &p) const {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Line s1, Line s2) {\n  return isParallel(s1.p2-s1.p1, s2.p2-s2.p1);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Line s1, Line s2) {\n  Vector a = s1.p2 - s1.p1;\n  Vector b = s2.p2 - s2.p1;\n  double d1 = cross(b, s2.p1 - s1.p1);\n  double d2 = cross(b, a);\n  return s1.p1 + a * d1/d2;\n}\n\nVector getOthogonalV(Vector a) {\n  return Vector(-a.y, a.x);\n}\n\nLine getOthogonalL(Line s) {\n  Line res;\n  res.p1 = s.p1;\n  res.p2 = s.p1 + getOthogonalV(s.p2 - s.p1);\n  return res;\n}\n\ndouble getDistanceLP(Line s, Point p) {\n  return fabs(cross(s.p2 - s.p1, p - s.p1))/abs(s.p2 - s.p1);\n}\n\nint N;\nLine S[100];\n\nvoid getBisector(vector<Line> &v) {\n  for(int i = 0; i < 1; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      Vector a = S[i].p2 - S[i].p1;\n      Vector b = S[j].p2 - S[j].p1;\n      if(isParallel(S[i], S[j])) {\n\tdouble d = getDistanceLP(S[i], S[j].p1)/2.0;\n\tVector vn;\n\tif(ccw(S[i].p1, S[i].p2, S[j].p1) >= 1) {\n\t  vn.x = -a.y;\n\t  vn.y = a.x;\n\t} else {\n\t  vn.x = a.y;\n\t  vn.y = -a.x;\n\t}\n\tvn = vn*d/abs(vn);\n\tLine l;\n\tl.p1 = S[i].p1 + vn;\n\tl.p2 = S[i].p2 + vn;\n\tv.push_back(l);\n      } else {\n\tPoint p = getCrossPoint(S[i], S[j]);\n\tLine l;\n\tl.p1 = p;\n\tl.p2 = p + b+a*sqrt(norm(b)/norm(a));\n\tv.push_back(l);\n\tv.push_back(getOthogonalL(l));\n      }\n    }\n  }\n}\n\nvoid solve() {\n  if(N <= 2) {\n    cout << \"Many\" << endl;\n    return;\n  }\n  if(N == 3) {\n    bool f1 = isParallel(S[0], S[1]);\n    bool f2 = isParallel(S[1], S[2]);\n    bool f3 = isParallel(S[2], S[0]);\n    if(f1 && f2 && f3) {\n      cout << \"None\" << endl;\n      return;\n    } else {\n      cout << \"Many\" << endl;\n      return;\n    }\n  }\n\n  vector<Line> v;\n  getBisector(v);\n\n  vector<Point> cp;\n  for(int i = 0; i < v.size(); ++i) {\n    for(int j = i+1; j < v.size(); ++j) {\n      if(isParallel(v[i], v[j])) continue;\n      cp.push_back(getCrossPoint(v[i], v[j]));\n    }\n  }\n  sort(cp.begin(), cp.end());\n  cp.erase(unique(cp.begin(), cp.end()), cp.end());\n  int count = 0;\n  Point ans;\n  for(vector<Point>::iterator ii = cp.begin(); ii != cp.end(); ++ii) {\n    double d = getDistanceLP(S[0], *ii);\n    bool flag = true;\n    for(int j = 1; j < N; ++j) {\n      if(!equals(d, getDistanceLP(S[j], *ii))) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      ++count;\n      if(count >= 2) break;\n      ans = *ii;\n    }\n  }\n\n  if(count == 0) cout << \"None\" << endl;\n  else if(count == 1) printf(\"%.5f %.5f\\n\", ans.x, ans.y);\n  else if(count >= 2) cout << \"Many\" << endl;\n}\n\nmain() {\n  while((cin >> N) && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].p1.x >> S[i].p1.y >> S[i].p2.x >> S[i].p2.y;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-8)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n        C.push_back(A.back().first);\n        C.push_back(A.back().second);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tok++;\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-9;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n==2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==2){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1000000007LL\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pb push_back\n#define sz size()\n\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool insecLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nP proj(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distLP(const L &l, const P &p) {\n  return abs(p - proj(l, p));\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<L> bisector(const L &l, const L &m){\n\tvector<L> res;\n\tif(insecLL(l,m)){\n\t\tP p=crosspoint(l,m);\n\t\tP dl=l[1]-l[0],dm=m[1]-m[0];\n\t\tP q,r;\n\t\tif(abs(dl)>abs(dm)){\n\t\t\tq=dl+dm/abs(dm)*abs(dl);\n\t\t\tr=dl-dm/abs(dm)*abs(dl);\n\t\t}else{\n\t\t\tq=dl/abs(dl)*abs(dm)+dm;\n\t\t\tr=dl/abs(dl)*abs(dm)-dm;\n\t\t}\n\t\tres.pb(L(p,p+q));\n\t\tres.pb(L(p,p+r));\n\t\treturn res;\n\t}\n\telse{\n\t\tP p=proj(l,m[0]);\n\t\tP q=(m[0]+p)/2.;\n\t\tres.pb(L(q,q+l[1]-l[0]));\n\t\treturn res;\n\t}\n}\n\nint n;\nL line[111];\n\nint main(){\n\tcout<<setprecision(15);\n\twhile(cin>>n && n){\n\t\trep(i,n){\n\t\t\tint x,y,xx,yy;\n\t\t\tcin>>x>>y>>xx>>yy;\n\t\t\tline[i]=L(P(x,y),P(xx,yy));\n\t\t}\n\t\tif(n<=2){\n\t\t\tcout<<\"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> bisec01=bisector(line[0],line[1]),\n\t\tbisec02=bisector(line[0],line[2]);\n\t\tP ans(INF,INF);\n\t\trep(i,bisec01.sz)rep(j,bisec02.sz){\n\t\t\tif(insecLL(bisec01[i],bisec02[j])){\n\t\t\t\tP p=crosspoint(bisec01[i],bisec02[j]);\n\t\t\t\tdouble dist=distLP(line[0],p);\n\t\t\t\trep2(k,3,n){\n\t\t\t\t\tif(abs(distLP(line[k],p)-dist)>EPS){\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(abs(ans-p)>EPS){\n\t\t\t\t\tif(abs(ans)>INF){\n\t\t\t\t\t\tans=p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout<<\"Many\\n\";\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfail:;\n\t\t\t}\n\t\t}\n\t\tif(abs(ans)>INF)cout<<\"None\\n\";\n\t\telse cout<<ans.real()<<\" \"<<ans.imag()<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-5;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n == 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<Line> ls;\n\t\trep(i, bs.size()) for (auto b : bs[i]){\n\t\t\tls.eb(b);\n\t\t}\n\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, bs.size()) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (cps.size() > 50) return;\n\t\t\t}\n\t\t}();\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tunique(cps);\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnone = true;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tnone = false;\n\t\t\t\tres = cps[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (none) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\nP normalize(P p) {\n  return p/abs(p);\n}\nvector<L> angleBisector(const L &l, const L &m) {\n  vector<L> res;\n  if (abs(cross(l[1]-l[0], m[1]-m[0])) > EPS) { // non-parallel\n    P p1 = crosspoint(l,m);\n    P p2 = p1+(normalize(l[1]-l[0]) + normalize(m[1]-m[0]))*0.5;\n    res.push_back(L(p1,p2));\n    p2 = p1+(normalize(l[1]-l[0]) + normalize(m[0]-m[1]))*0.5;\n    res.push_back(L(p1,p2));\n  } else {                      \n    P p1 = (projection(l,m[0])+m[0])*0.5;\n    res.push_back(L(p1,p1+l[1]-l[0]));\n  }\n  \n  return res;\n}\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<L> v;\n    REP(i,n) {\n      P p1, p2;\n      cin>>p1.real()>>p1.imag()>>p2.real()>>p2.imag();\n      v.push_back(L(p1,p2));\n    }\n    // FOR(it, v) {\n    //   FOR(jt, v) {\n    //     if (*it == *jt) continue;\n    //     if (intersectLL(*it,*jt))\n    //         cout << crosspoint(*it, *jt) << endl;\n    //   }\n    // }\n    if (n<=2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> vl1 = angleBisector(v[0],v[1]);\n    vector<L> vl2 = angleBisector(v[0],v[2]);\n    set<P> se;\n    FOR(it, vl1) FOR(jt, vl2) {\n      //cout << (*it)[0] << \" \" << (*it)[1] << \",  \" << (*jt)[0] << \" \" << (*jt)[1] << endl;\n      if (intersectLL(*it,*jt))\n        se.insert(crosspoint(*it,*jt));\n    }\n    vector<P> ans;\n    FOR(it, se) {\n      double d = -1;\n      bool dame = 0;\n      FOR(jt, v) {\n        if (d == -1) d = distanceLP(*jt, *it);\n        else if (abs(d-distanceLP(*jt,*it))>EPS) {\n          dame = 1;\n          break;\n        }\n      }\n      if (!dame) ans.push_back(*it);\n    }\n    // cout << \"se\"  << endl; FOR(it, se ) cout << *it << endl;\n    // cout << \"ans\" << endl; FOR(it, ans) cout << *it << endl;\n    if (ans.size() > 1) cout << \"Many\" << endl;\n    else if (ans.size() == 0) cout << \"None\" << endl;\n    else {\n      printf(\"%.15f %.15f\\n\", ans[0].real(), ans[0].imag());\n    }\n  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=3){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg){\n          vec.push_back(target);\n        }\n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(vec.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(vec.size()==1){\n    printf(\"%.8f %.8f\\n\",real(vec[0]),imag(vec[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-9;\nconst double pi = acos(-1.0);\nconst double mag = 10;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d) && eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double x, double y) : x(x), y(y) {}\n};\ndouble sqr(double x) { return x * x; }\npoint operator + (const point& p1, const point& p2) { return point(p1.x + p2.x, p1.y + p2.y); }\npoint operator - (const point& p1, const point& p2) { return point(p1.x - p2.x, p1.y - p2.y); }\npoint operator * (const point& p1, double d) { return point(p1.x * d, p1.y * d); }\npoint operator / (const point& p1, double d) { return point(p1.x / d, p1.y / d); }\nint dcmp(double x) { return fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); }\ndouble det(point p1, point p2) { return p1.x * p2.y - p1.y * p2.x; }\ndouble dist(point p1, point p2) { return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y)); }\npoint nor(point p) { return p / sqrt(max(0., sqr(p.x) + sqr(p.y))); }\n\n\nint size = 0, n;\npoint a[10001], b[10001];\npair<point, point> p[20001][2];\n\npoint inter(point p, point v, point q, point w) {\n\tpoint u = p - q;\n\tdouble t = det(w, u) / det(v, w);\n\treturn p + v * t;\n}\n\ndouble D(point p, point p1, point p2) {\n\treturn fabs(det(p - p1, p - p2)) / dist(p1, p2);\n}\n\nbool Online(point o, point x, point y) {\n\treturn dcmp(det(y - x, y - o)) == 0;\n}\n\nbool operator < (const point& p1, const point& p2) {\n\tif (dcmp(p1.x - p2.x)) return p1.x < p2.x;\n\treturn p1.y < p2.y;\n}\n\nint main( ) {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%lf %lf\", &a[i].x, &a[i].y);\n\t\t\tscanf(\"%lf %lf\", &b[i].x, &b[i].y);\n\t\t}\n\t\tif (n <= 2) { printf(\"Many\\n\"); continue; }\n\t\tfor (int i = 1; i <= 2; i ++) {\n\t\t\tif (dcmp(det(b[i] - a[i], b[i + 1] - a[i + 1])) == 0) \n\t\t\t\tp[i][0] = p[i][1] = make_pair((a[i] + a[i + 1]) / 2., (b[i] - a[i]));\n\t\t\telse {\n\t\t\t\tpoint o = inter(a[i], b[i] - a[i], a[i + 1], b[i + 1] - a[i + 1]);\n\t\t\t\tp[i][0] = make_pair(o, (nor(b[i] - a[i]) + nor(b[i + 1] - a[i + 1])) * 0.5);\n\t\t\t\tp[i][1] = make_pair(o, (nor(a[i] - b[i]) + nor(b[i + 1] - a[i + 1])) * 0.5);\n\t\t\t}\n\t\t}\n\t\tset<point> S;\n\t\tfor (int i = 0; i < 2; i ++)\n\t\t\tfor (int j = 0; j < 2; j ++) {\n\t\t\t\tpoint x = p[1][i].second;\n\t\t\t\tpoint y = p[2][j].second;\n\n\t\t\t\tif (dcmp(det(x, y)) == 0) continue;\n\t\t\t\tpoint o = inter(p[1][i].first, p[1][i].second, p[2][j].first, p[2][j].second);\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 2; j <= n; ++ j)\n\t\t\t\t\tif (dcmp(D(o, a[j], b[j]) - D(o, a[1], b[1]))) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == false) S.insert(o);\n\t\t\t}\n\t\tif (S.size() == 0) printf(\"None\\n\");\n\t\telse if (S.size() > 1) printf(\"Many\\n\");\n\t\telse printf(\"%.10f %.10f\\n\", (*S.begin()).x, (*S.begin()).y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 1; i < n; ++i){\n      point is;\n      if(intersectionLL( vl[0], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[0].fr) ){\n\t  va = uvec(vl[0].fr-is);\n\t}else{\n\t  va = uvec(vl[0].sc-is);\n\t}\n\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tbisector.push_back( line( is, is+va+vb ) );\n\tbisector.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[0].fr );\n\tpoint is;\n\tintersectionLL( line(vl[0].fr, vl[0].fr+unmr(vl[0].sc-vl[0].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[0].fr) + vl[0].fr;\n\tpoint csc = d * uvec(is-vl[0].fr) + vl[0].sc;\n\tbisector.push_back( line(cfr,csc) );\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn (l.first-x).cross(l.second-x) == 0;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\ttmp.push_back(make_pair((p[i]+p[j])*0.5, (q[i]+q[j])*0.5));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\tif(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec = npvec;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec = npvec;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-7;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-6;\nconstexpr ld pi = std::acos(-1.0);\n\nusing point = std::complex<long double>;\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nbool comp(point a, point b) {\n    return (std::real(a - b) * 1.347589 + std::imag(a - b)) > 0;\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\nstd::vector<point> unique(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), comp);\n    std::vector<point> res;\n    for(auto& p : ps) {\n        if(res.empty() || abs(res.back() - p) > eps) {\n            res.push_back(p);\n        }\n    }\n    return res;\n}\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\npoint rot(point p, ld theta) {\n    ld x = real(p), y = imag(p);\n    return point(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n}\n\nld get_angle(point vec) {\n    ld res = arg(vec);\n    if(res < 0) {\n        res += 2 * pi;\n    }\n    if(res > pi) {\n        res -= pi;\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<line> ls;\n        for(int i = 0; i < N; ++i) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            if(x1 > x2) {\n                swap(x1, x2);\n                swap(y1, y2);\n            }\n            point p1(x1, y1), p2(x2, y2);\n            bool check = true;\n            for(auto& l : ls) {\n                if(isis_lp(l, p1) && isis_lp(l, p2)) {\n                    check = false;\n                    break;\n                }\n            }\n            if(check) {\n                ls.emplace_back(p1, p2);\n            }\n        }\n\n        N = ls.size();\n        if(N == 1 || N == 2) {\n            cout << \"Many\" << endl;\n            continue;\n        }\n\n        vector<line> cand[2];\n        for(int i = 0; i < 2; ++i) {\n            if(isis_ll(ls[i], ls[i + 1])) {\n                auto p = is_ll(ls[i], ls[i + 1]);\n                ld ang = (get_angle(ls[i].b - ls[i].a) + get_angle(ls[i + 1].b - ls[i + 1].a)) / 2;\n                ang = ang - get_angle(ls[i].b - ls[i].a);\n                if(abs(ls[i].b - p) > eps) {\n                    cand[i].emplace_back(p, p + rot(ls[i].b - p, ang));\n                    cand[i].emplace_back(p, p + rot(ls[i].b - p, ang + pi / 2));\n                } else {\n                    cand[i].emplace_back(p, p + rot(ls[i].a - p, ang));\n                    cand[i].emplace_back(p, p + rot(ls[i].a - p, ang + pi / 2));\n                }\n            } else {\n                auto p1 = (ls[i].a + proj(ls[i + 1], ls[i].a)) * 0.5L;\n                auto p2 = (ls[i].b + proj(ls[i + 1], ls[i].b)) * 0.5L;\n                cand[i].emplace_back(p1, p2);\n            }\n        }\n        vector<point> res;\n        for(auto& l1 : cand[0]) {\n            for(auto& l2 : cand[1]) {\n                if(!isis_ll(l1, l2)) {\n                    continue;\n                }\n                auto p = is_ll(l1, l2);\n                bool check = true;\n                ld d = abs(p - proj(ls[0], p));\n                for(int i = 1; i < N; ++i) {\n                    check &= abs(d - abs(p - proj(ls[i], p))) < eps;\n                }\n                if(check) {\n                    res.push_back(p);\n                }\n            }\n        }\n        res = unique(res);\n        if(res.size() > 1) {\n            cout << \"Many\" << endl;\n        } else if(res.size() == 1) {\n            cout << fixed << setprecision(5) << real(res[0]) << ' ' << imag(res[0]) << endl;\n        } else {\n            cout << \"None\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  //rep(i,a.size()){\n  //rep(i,a.size()){\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      //cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n      //<< a[j].fir <<\" \" << a[j].sec << endl;\n      //cout << j<<\" \"<< is_intersected_ll(\n      //a[i].fir,a[i].sec,\n      //a[j].fir,a[j].sec)<<\n      //\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tP tmp2=b[b.size()-1].sec;\n\ttmp2-=tmp;\n\tswap(tmp2.real(),tmp2.imag());\n\ttmp2.real()*=-1;\n\ttmp2+=tmp;\n\tb.pb(mp(tmp,tmp2));\n\n\n// \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n// \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n\t\n// \tcout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n//  \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" << endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n\n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\t\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP pos = projection(ls[i],ls[j][0]);\n\t\t\t\t\t\tP vec = ls[j][0]-pos;\n\t\t\t\t\t\tln.push_back(L(pos,pos+vec/2.));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > 1e-7 )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << cp << endl;\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-9L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-6;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    if(sign(cross(vec1, vec2)) == 0){\n        res.push_back(Line((l[0] + m[0]) / 2.0, (l[1] + m[1]) / 2.0));\n    }else{\n        Point p = crosspointLL(l, m);\n        res.push_back(Line(p, p + vec1 + vec2));\n        res.push_back(Line(p, p + vec1 - vec2));\n    }\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 0; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n        for(int j = i + 1; j < 3; j++){\n            //if(paralell(lines[i], lines[j])) continue;\n            vector<Line> mids = get_midline(lines[i], lines[j]);\n            midlines.insert(midlines.end(), mids.begin(), mids.end());\n        }\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 1; k < lines.size(); k++){\n                if(sign(distanceLP(lines[k], p) - distanceLP(lines[k - 1], p)) != 0){\n                    ok = false;\n                    break;\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.9f %.9f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-5;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else// if(ans.size()==1)\n    {\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  //  }else{\n  //    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n  \nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \n//rad ??????§?????????????????¢???????§???????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \n// ????????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \n// a => prev, b => cur, c=> next\n// prev ?????? cur ??????????£??? next ??????????????????§??????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //?????????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n  //arg_a = getArg(p1,cp,p2);\n\n  //assert( !( cp == p1 || cp == p2 || p1 == p2 ) );  \n\n  int res = ccw(cp,p1,p2);\n  //assert( ( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  //while( !( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  //cout << base << \" -> \" << cp << \" -> \" << not_base << endl;\n  arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n  //puts(\"^^^^^\");\n  //cout << \"base = \" << base << \" | \" << (arg_a*180/M_PI)<< endl;\n  //cout << line1 << \" and \" << line2 << endl;\n  //cout << cp << \" | \" << p1 << \" | \" << p2 << endl;\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  //cout << \"return = \" << tmp << endl;\n  //puts(\"_____\");  \n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      //cout << vec[i] << \" x \" << vec[j] << endl;\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      //cout << \"tmp = \" << tmp << endl;\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      //cout << \"tmp = \" << tmp << endl;\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 50 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    //puts(\"\");\n    //cout << \"p = \" << p << endl;\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n      //cout << dist << \" ?? \" << tmp << endl;\n    }\n    //cout << \"success ?= \" << success << endl;\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double x, double y) : x(x), y(y) {}\n};\ndouble sqr(double x) { return x * x; }\npoint operator + (const point& p1, const point& p2) { return point(p1.x + p2.x, p1.y + p2.y); }\npoint operator - (const point& p1, const point& p2) { return point(p1.x - p2.x, p1.y - p2.y); }\npoint operator * (const point& p1, double d) { return point(p1.x * d, p1.y * d); }\npoint operator / (const point& p1, double d) { return point(p1.x / d, p1.y / d); }\nint dcmp(double x) { return fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); }\ndouble det(point p1, point p2) { return p1.x * p2.y - p1.y * p2.x; }\ndouble dist(point p1, point p2) { return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y)); }\npoint nor(point p) { return p / sqrt(max(0., sqr(p.x) + sqr(p.y))); }\n\nstruct Line {\n\tpoint s, d;\n\tLine(const point & a, const point & b) : s(a), d(b) {\n\t}\n\tLine() {\n\t}\n} l[10001], p[10001][2];\n\nint n;\npoint a[10001], b[10001];\n\npoint inter(point p, point v, point q, point w) {\n\tpoint u = p - q;\n\tdouble t = det(w, u) / det(v, w);\n\treturn p + v * t;\n}\n\ndouble D(point p, point p1, point p2) {\n\treturn fabs(det(p - p1, p - p2)) / dist(p1, p2);\n}\nbool operator < (const point& p1, const point& p2) {\n\tif (dcmp(p1.x - p2.x)) return p1.x < p2.x;\n\tif (dcmp(p1.y - p2.y)) return p1.y < p2.y;\n\treturn false;\n}\n__inline double operator * (const point & a, const point & b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n__inline point intersection(const Line & a, const Line & b) {\n\tdouble lambda((b.s - a.s) * b.d / (a.d * b.d));\n\treturn a.s + a.d * lambda;\n}\nint main( ) {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%lf %lf\", &a[i].x, &a[i].y);\n\t\t\tscanf(\"%lf %lf\", &b[i].x, &b[i].y);\n\t\t}\n\t\tif (n <= 2) { printf(\"Many\\n\"); continue; }\n\t\tfor(int i(1); i <= 3; i++) {\n\t\t\tl[i] = Line(a[i], b[i] - a[i]);\n\t\t}\n\t\tfor (int i = 1; i <= 2; i ++) {\n\t\t\tif (dcmp(det(l[i].d, l[i + 1].d)) == 0) \n\t\t\t\tp[i][0] = p[i][1] = Line((l[i].s + l[i + 1].s) * 0.5, l[i].d);\n\t\t\telse {\n\t\t\t\tp[i][0] = Line(intersection(l[i], l[i + 1]), (nor(b[i] - a[i]) + nor(b[i + 1] - a[i + 1])) * 0.5);\n\t\t\t\tp[i][1] = Line(intersection(l[i], l[i + 1]), (nor(a[i] - b[i]) + nor(b[i + 1] - a[i + 1])) * 0.5);\n\t\t\t}\n\t\t}\n\t\tset<point> S;\n\t\tfor (int i = 0; i < 2; i ++)\n\t\t\tfor (int j = 0; j < 2; j ++) {\n\t\t\t\tpoint x = p[1][i].d;\n\t\t\t\tpoint y = p[2][j].d;\n\n\t\t\t\tif (dcmp(det(x, y)) == 0) continue;\n\t\t\t\tpoint o = intersection(p[1][i], p[2][j]);\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 2; j <= n; ++ j)\n\t\t\t\t\tif (dcmp(D(o, a[j], b[j]) - D(o, a[1], b[1]))) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == false) S.insert(o);\n\t\t\t}\n\t\tif (S.size() == 0) printf(\"None\\n\");\n\t\telse if (S.size() > 1) printf(\"Many\\n\");\n\t\telse printf(\"%.10f %.10f\\n\", (*S.begin()).x, (*S.begin()).y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-10;\nconst double pi = acos(-1.0);\nconst double mag = 800;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ) va = uvec(vl[t].fr-is);\n\telse va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) ) vb = uvec(vl[i].fr-is);\n\telse vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      if(i==1)\n\tbreak;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\ntypedef complex<ld> Point;\nbool eq(ld a, ld b){ return abs(a - b) < eps; }\nld dot(Point a, Point b) { return real(conj(a)*b); }\nld cross(Point a, Point b) { return imag(conj(a)*b); }\nbool eq(Point a, Point b) { return norm(a - b) < eps*eps; }\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n\t}\n}\nstruct Line {\n\tPoint a, b;\n};\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//counter clockwise\n\tif (cross(b, c) < -eps)return -1;//clock wise\n\tif (dot(b, c) < 0)return 2;//c--a--b on line\n\tif (norm(b) < norm(c))return -2;//a--b--c on line\n\treturn 0; //a--c--b on line\n}\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Line> mid_ll(Line l, Line m) {\n\tif (!isis_ll(l, m)) {\n\t\tld u = dist_ll(l, m);\n\t\tPoint d = l.b - l.a;\n\t\tPoint md=d* exp(Point{ 0,pi / 2.0 });\n\t\tLine l_ = { l.a,l.a + md };\n\t\tPoint ma = is_ll(l_, m);\n\t\tPoint dif = ma - l.a;\n\t\tdif /= 2.0;\n\t\tLine res = { l.a + dif,(l.a + dif) + d };\n\t\treturn { res };\n\t}\n\telse {\n\t\tPoint p = is_ll(l, m);\n\t\tld t1 = arg(l.b - l.a);\n\t\tld t2 = arg(m.b - m.a);\n\t\tld t = (t1 + t2) / 2.0;\n\t\tPoint dif = { cos(t),sin(t) };\n\t\tPoint np = p + dif;\n\t\tld d1 = dist_lp(l, np);\n\t\tld d2 = dist_lp(m, np);\n\t\tvector<Line> res;\n\t\tres.push_back({ p,p + dif });\n\t\tt += pi / 2.0;\n\t\tdif = { cos(t),sin(t) };\n\t\tres.push_back({ p,p + dif });\n\t\treturn res;\n\t}\n}\n\nint n;\nvoid solve() {\n\tvector<Line> vl;\n\trep(i, n) {\n\t\tld x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tvl.push_back({ {x1,y1},{x2,y2} });\n\t}\n\tif (n <= 2) {\n\t\tcout << \"Many\" << endl; return;\n\t}\n\tvector<Line> l1 = mid_ll(vl[0], vl[1]);\n\tvector<Line> l2 = mid_ll(vl[0], vl[2]);\n\tvector<Point> anss;\n\trep(i, l1.size()) {\n\t\trep(j, l2.size()) {\n\t\t\tLine l = l1[i], m = l2[j];\n\t\t\tif (!isis_ll(l, m))continue;\n\t\t\tPoint p = is_ll(l, m);\n\t\t\tvector<ld> dist;\n\t\t\trep(k, n) {\n\t\t\t\tld d = dist_lp(vl[k], p);\n\t\t\t\tdist.push_back(d);\n\t\t\t}\n\t\t\tsort(dist.begin(), dist.end());\n\t\t\t//cout << p << endl;\n\t\t\t//cout << dist[0] << \" \" << dist[n - 1] << endl;\n\t\t\tif (eq(dist[0], dist[n - 1])) {\n\t\t\t\tanss.push_back(p);\n\t\t\t\t//cout << real(p) << \" \" << imag(p) << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tsort(anss.begin(), anss.end());\n\trep(i, anss.size()) {\n\t\tif (i > 0 && eq(anss[i], anss[i - 1])) {\n\t\t\tanss.erase(anss.begin() + i); i--;\n\t\t}\n\t}\n\tif (anss.size() > 1) {\n\t\tcout << \"Many\" << endl;\n\t}\n\telse if (anss.size() == 1) {\n\t\tcout << real(anss[0]) << \" \" << imag(anss[0]) << endl;\n\t}\n\telse {\n\t\tcout << \"None\" << endl;\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(9);\n\t//init();\n\twhile (cin >> n,n) {\n\t\tsolve();\n\t}\n\t//stop\n\t\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "    #include \"bits/stdc++.h\"\n    #include<unordered_map>\n    #pragma warning(disable:4996)\n    using namespace std;\n    using ld = long double;\n    template<class T>\n    using Table = vector<vector<T>>;\n     \n     \n    /* ??????????????¬ */\n     \n    #include <complex>\n     \n    typedef long double ld;\n    typedef complex<ld> Point;\n    #define REP(i,n) for(int i=0;i<(int)(n);i++)\n    #define ALL(x) (x).begin(),(x).end()\n     \n    const ld eps = 1e-13, pi = acos(-1.0);\n    const ld dtop = pi / 180.;\n    const ld ptod = 1. / dtop;\n     \n    namespace std {\n    \tbool operator<(const Point &lhs, const Point &rhs) {\n    \t\tif (lhs.real() < rhs.real() - eps) return true;\n    \t\tif (lhs.real() > rhs.real() + eps) return false;\n    \t\treturn lhs.imag() < rhs.imag();\n    \t}\n    }\n     \n    // ????????\\???\n    Point input_point() {\n    \tld x, y;\n    \tcin >> x >> y;\n    \treturn Point(x, y);\n    }\n     \n    // ????????????????????????\n    bool eq(const ld a, const ld b) {\n    \treturn (abs(a - b) < eps);\n    }\n     \n    // ??????\n    ld dot(const Point& a, const Point& b) {\n    \treturn real(conj(a) * b);\n    }\n     \n    // ??????\n    ld cross(const Point& a, const Point& b) {\n    \treturn imag(conj(a) * b);\n    }\n     \n    // ??´????????????\n    class Line {\n    public:\n    \tPoint a, b;\n    \tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n    \tLine(Point a, Point b) : a(a), b(b) {}\n    \tPoint operator[](const int _num)const {\n    \t\tif (_num == 0)return a;\n    \t\telse if (_num == 1)return b;\n    \t\telse {\n    \t\t\tassert(false);\n    \t\t\treturn Point();\n    \t\t}\n    \t}\n    };\n     \n    // ????????????\n    class Circle {\n    public:\n    \tPoint p;\n    \tld r;\n    \tCircle() : p(Point(0, 0)), r(0) {}\n    \tCircle(Point p, ld r) : p(p), r(r) {}\n    };\n     \n    // CCW\n    int ccw(const Point& a, const Point &b, const Point &c) {\n    \tconst Point nb(b - a);\n    \tconst Point nc(c - a);\n    \tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n    \tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n    \tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n    \tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n    \treturn 0;                          // a,c,b???????????´???????????¶\n    }\n     \n     \n    /* ???????????? */\n     \n    // ??´?????¨??´??????????????????\n    bool isis_ll(const Line& l, const Line& m) {\n    \treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n    }\n     \n    // ??´?????¨?????????????????????\n    bool isis_ls(const Line& l, const Line& s) {\n    \treturn isis_ll(l, s) &&\n    \t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n    }\n     \n    // ????????¨?????????????????????\n    bool isis_ss(const Line& s, const Line& t) {\n    \treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    \t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n     \n    // ????????´????????????\n    bool isis_lp(const Line& l, const Point& p) {\n    \treturn (abs(cross(l.b - p, l.a - p)) < eps);\n    }\n     \n    // ?????????????????????\n    bool isis_sp(const Line& s, const Point& p) {\n    \treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n    }\n     \n    // ??´????????´????????????\n    bool lisonl(const Line&l, const Line&m) {\n    \treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n    }\n     \n    // ??????????¶?\n    Point proj(const Line &l, const Point& p) {\n    \tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    \treturn l.a + t * (l.a - l.b);\n    }\n     \n    // ??´?????¨??´????????????\n    Point is_ll(const Line &s, const Line& t) {\n    \tPoint sv = s.b - s.a, tv = t.b - t.a;\n    \tassert(cross(sv, tv) != 0);\n    \treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n    }\n    // ????????¨???????????????\n    //???????????£????????¨???????????¨assert(false)\n    Point is_ss(const Line &s, const Line& t) {\n    \tif (isis_ss(s, t)) {\n    \t\tfor (int k = 0; k < 2; ++k) {\n    \t\t\tfor (int l = 0; l < 2; ++l) {\n    \t\t\t\tif (s[k] == t[l])return s[k];\n    \t\t\t}\n    \t\t}\n    \t\treturn is_ll(s, t);\n    \t}\n    \telse {\n    \t\treturn Point(0, 0);\n    \t}\n    }\n    // ??´?????¨???????????¢\n    ld dist_lp(const Line& l, const Point& p) {\n    \treturn abs(p - proj(l, p));\n    }\n     \n    // ??´?????¨??´???????????¢\n    ld dist_ll(const Line& l, const Line& m) {\n    \treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n    }\n     \n    // ??´?????¨??????????????¢\n    ld dist_ls(const Line& l, const Line& s) {\n    \treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n    }\n     \n    // ????????¨???????????¢\n    ld dist_sp(const Line& s, const Point& p) {\n    \tPoint r = proj(s, p);\n    \treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n    }\n     \n    // ????????¨??????????????¢\n    ld dist_ss(const Line& s, const Line& t) {\n    \tif (isis_ss(s, t)) return 0;\n    \treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n    }\n     \n     \n    //??´?????¨??´?????????????????????????????????\n    //???????????????a ??¨???a ??????????????????????????????????????????\n    Line bisection(const Line &s, const Line &t) {\n    \tif (!isis_ll(s, t)) {\n    \t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n    \t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n    \t\t}\n    \t\telse {\n     \n    \t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n    \t\t}\n    \t}\n    \tconst Point laglanju(is_ll(s, t));\n    \tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n    \tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n     \n    \treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n    }\n     \n    //???????????´?????????????????????\n    //???????????´??????????????§???????????¨????¢?????????¨?????????\n    Point  inner_center(const vector<Line>&ls) {\n    \tvector<Point>vertics;\n    \tfor (int i = 0; i < ls.size(); ++i) {\n    \t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n    \t}\n    \tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n    \tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n    \tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n    \tif (bi1[0] == bi2[0])return bi1[0];\n    \telse {\n    \t\treturn is_ll(bi1, bi2);\n    \t}\n    }\n     \n    //???????????´?????????????????????\n    //???????????´??????????????§???????????¨????¢?????????¨?????????\n    vector<Point>  ex_center(const vector<Line>&ls) {\n    \tvector<Point>vertics;\n    \tfor (int i = 0; i < ls.size(); ++i) {\n    \t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n    \t}\n    \tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n    \tvector<Point>ecs;\n    \tfor (int i = 0; i < 3; ++i) {\n    \t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n    \t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n    \t\tecs.push_back(is_ll(bi1, bi2));\n    \t}\n    \treturn ecs;\n    }\n     \n    //a,b:??????\n    //c:????????§??????\n    //???????????´?????????????????¢?????????????±??????????\n    vector<Point>  same_dis(const vector<Line>&ls) {\n    \tvector<Point>vertics;\n    \tvertics.push_back(is_ll(ls[0], ls[2]));\n    \tvertics.push_back(is_ll(ls[1], ls[2]));\n     \n    \tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n    \tLine bis(bisection(ls[0],ls[1]));\n    \tvector<Point>ecs;\n     \n    \t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n    \t\tecs.push_back(is_ll(bis,abi));\n     \n     \n    \t\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0]-vertics[1]), ls[0]));\n    \t\tecs.push_back(is_ll(bis, bbi));\n     \n    \treturn ecs;\n    }\n     \n    /* ??? */\n     \n    // ?????¨????????????\n    vector<Point> is_cc(const Circle& c1, const Circle& c2) {\n    \tvector<Point> res;\n    \tld d = abs(c1.p - c2.p);\n    \tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    \tld dfr = c1.r * c1.r - rc * rc;\n    \tif (abs(dfr) < eps) dfr = 0.0;\n    \telse if (dfr < 0.0) return res; // no intersection\n    \tld rs = sqrt(dfr);\n    \tPoint diff = (c2.p - c1.p) / d;\n    \tres.push_back(c1.p + diff * Point(rc, rs));\n    \tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    \treturn res;\n    }\n     \n    // ?????¨??´????????????\n    vector<Point> is_lc(const Circle& c, const Line& l) {\n    \tvector<Point> res;\n    \tld d = dist_lp(l, c.p);\n    \tif (d < c.r + eps) {\n    \t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    \t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n    \t\tres.push_back(proj(l, c.p) + len * nor);\n    \t\tres.push_back(proj(l, c.p) - len * nor);\n    \t}\n    \treturn res;\n    }\n     \n    // ?????¨??????????????¢\n    vector<Point> is_sc(const Circle& c, const Line& l) {\n    \tvector<Point> v = is_lc(c, l), res;\n    \tfor (Point p : v)\n    \t\tif (isis_sp(l, p)) res.push_back(p);\n    \treturn res;\n    }\n     \n    // ?????¨????????\\???\n    vector<Line> tangent_cp(const Circle& c, const Point& p) {\n    \tvector<Line> ret;\n    \tPoint v = c.p - p;\n    \tld d = abs(v);\n    \tld l = sqrt(norm(v) - c.r * c.r);\n    \tif (isnan(l)) { return ret; }\n    \tPoint v1 = v * Point(l / d, c.r / d);\n    \tPoint v2 = v * Point(l / d, -c.r / d);\n    \tret.push_back(Line(p, p + v1));\n    \tif (l < eps) return ret;\n    \tret.push_back(Line(p, p + v2));\n    \treturn ret;\n    }\n     \n    // ?????¨????????\\???\n    vector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n    \tvector<Line> ret;\n    \tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    \t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    \t\tret = tangent_cp(c1, center);\n    \t}\n    \tif (abs(c1.r - c2.r) > eps) {\n    \t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    \t\tvector<Line> nret = tangent_cp(c1, out);\n    \t\tret.insert(ret.end(), ALL(nret));\n    \t}\n    \telse {\n    \t\tPoint v = c2.p - c1.p;\n    \t\tv /= abs(v);\n    \t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n    \t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n    \t\tret.push_back(Line(q1, q1 + v));\n    \t\tret.push_back(Line(q2, q2 + v));\n    \t}\n    \treturn ret;\n    }\n     \n     \n    /* ????§???¢ */\n     \n    typedef vector<Point> Polygon;\n     \n    // ??¢???\n    ld area(const Polygon &p) {\n    \tld res = 0;\n    \tint n = p.size();\n    \tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n    \treturn res / 2;\n    }\n     \n    // ????§???¢????????¢??????\n    bool is_counter_clockwise(const Polygon &poly) {\n    \tld angle = 0;\n    \tint n = poly.size();\n    \tREP(i, n) {\n    \t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n    \t\tangle += arg((c - b) / (b - a));\n    \t}\n    \treturn angle > eps;\n    }\n     \n    // ??????????????????\n    //  0 => out\n    //  1 => on\n    //  2 => in\n    int is_in_polygon(const Polygon &poly, const  Point& p) {\n    \tld angle = 0;\n    \tint n = poly.size();\n    \tREP(i, n) {\n    \t\tPoint a = poly[i], b = poly[(i + 1) % n];\n    \t\tif (isis_sp(Line(a, b), p)) return 1;\n    \t\tangle += arg((b - p) / (a - p));\n    \t}\n    \treturn eq(angle, 0) ? 0 : 2;\n    }\n    //??????????????????2?????????\n    enum { OUT, ON, IN };\n    int convex_contains(const Polygon &P, const Point &p) {\n    \tconst int n = P.size();\n    \tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n    \tint a = 0, b = n;\n    \twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    \t\tint c = (a + b) / 2;\n    \t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n    \t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n    \t\t\telse                                                  a = c;\n    \t\t}\n    \t\telse {\n    \t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n    \t\t\telse                                                  b = c;\n    \t\t}\n    \t}\n    \tb %= n;\n    \tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n    \tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n    \treturn 1;\n    }\n     \n    // ??????\n    // ???????????????????????¨????????????????????§??¨???\n    Polygon convex_hull(vector<Point> ps) {\n    \tint n = ps.size();\n    \tint k = 0;\n    \tsort(ps.begin(), ps.end());\n    \tPolygon ch(2 * n);\n    \tfor (int i = 0; i < n; ch[k++] = ps[i++])\n    \t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    \tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    \t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    \tch.resize(k - 1);\n    \treturn ch;\n    }\n     \n     \n     \n    // ????????????\n    vector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n    \tint n = ps.size();\n    \tPolygon Q;\n    \tPolygon R;\n    \tREP(i, n) {\n    \t\tPoint A = ps[i], B = ps[(i + 1) % n];\n    \t\tLine m = Line(A, B);\n    \t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    \t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n    \t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n    \t\t\tQ.push_back(is_ll(l, m));\n    \t\t\tR.push_back(is_ll(l, m));\n    \t\t}\n    \t}\n    \tconst vector<Polygon>polys{ Q,R };\n    \treturn polys;\n    }\n     \n     \n     \n     \n    bool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n    \tfor (auto l : ls) {\n    \t\tld adis = abs(dist_lp(l, kouho));\n    \t\tif (abs(adis - dis) > 3e-5)return false;\n    \t}\n    \treturn true;\n    }\n     \n    int main() {\n    \tcout << setprecision(11) << fixed;\n    \twhile (1) {\n    \t\tint N; cin >> N;\n    \t\tif (!N)break;\n    \t\tvector<Line>nls;\n    \t\t{\n    \t\t\tvector<Line>ls;\n    \t\t\tfor (int i = 0; i < N; ++i) {\n    \t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    \t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n    \t\t\t}\n    \t\t\tfor (int i = 0; i < N; ++i) {\n    \t\t\t\tbool ok = true;\n    \t\t\t\tfor (int j = i + 1; j < N; ++j) {\n    \t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n    \t\t\t\t\t\tok = false;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\telse {\n     \n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif(ok)nls.push_back(ls[i]);\n    \t\t\t}\n    \t\t}\n    \t\tif (nls.size() <= 2) {\n    \t\t\tcout << \"Many\" << endl;\n    \t\t\tcontinue;\n    \t\t}\n    \t\telse {\n    \t\t\tLine a(nls[0]);\n    \t\t\tLine b(nls[1]);\n    \t\t\tLine c(nls[2]);\n    \t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n    \t\t\t\tcout << \"None\" << endl;\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n    \t\t\t\tvector<Point >ps;\n    \t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n    \t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n    \t\t\t\tps.push_back(nai);\n    \t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n    \t\t\t\t\tps.push_back(bou[i]);\n    \t\t\t\t}\n    \t\t\t\tvector<bool>oks(ps.size());\n    \t\t\t\tint num = 0;\n    \t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n    \t\t\t\t\tld dis = dist_lp(a, ps[i]);\n    \t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n    \t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n    \t\t\t\t\toks[i] = check(ps[i], nls, dis);\n    \t\t\t\t\tif (oks[i])num++;\n    \t\t\t\t}\n    \t\t\t\tif (num >= 2) {\n    \t\t\t\t\tcout << \"Many\" << endl;\n    \t\t\t\t}\n    \t\t\t\telse if (num == 1) {\n    \t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n    \t\t\t\t\t\tif (oks[i]) {\n    \t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\telse {\n    \t\t\t\t\tcout << \"None\" << endl;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tif (dist_ll(b, c) > eps) {\n    \t\t\t\t\tswap(a, c);\n    \t\t\t\t}\n    \t\t\t\tif (dist_ll(c, a) > eps) {\n    \t\t\t\t\tswap(b, c);\n    \t\t\t\t}\n    \t\t\t\tassert(dist_ll(a, b) > eps);\n    \t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n    \t\t\t\tLine bis(bisection(a,b));\n    \t\t\t\tPoint bisvec = bis[1] - bis[0];\n    \t\t\t\tld dis = dist_ll(a,b) / 2;\n    \t\t\t\tPoint p = is_ll(bis, c);\n    \t\t\t\tPoint kouho1 = kouhos[0];\n    \t\t\t\tPoint kouho2 = kouhos[1];\n     \n    \t\t\t\tbool ok1 = check(kouho1, nls, dis);\n    \t\t\t\tbool ok2 = check(kouho2, nls, dis);\n    \t\t\t\tif (ok1&&ok2) {\n    \t\t\t\t\tcout << \"Many\" << endl;\n    \t\t\t\t}\n    \t\t\t\telse if (ok1&&!ok2) {\n    \t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n    \t\t\t\t}\n    \t\t\t\telse if (!ok1&&ok2) {\n    \t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n    \t\t\t\t}\n    \t\t\t\telse {\n    \t\t\t\t\tcout << \"None\" << endl;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n     \n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n\n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n          ans = nans;\n            \n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n    \n    //FOR(it,ans) cout << *it << endl;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8f %.8f\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-7;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\n\t\tif (n <= 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\t/*\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tshuffle(all(bs), mt19937());\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, std::min<int>(bs.size(), 15)) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}();\n\t\t\n\t\t/*\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\t\t\n\t\trep(i, cps.size()) rep(j, i){\n\t\t\tif (cps[i] == cps[j]){\n\t\t\t\tswap(cps[i], cps.back());\n\t\t\t\tcps.pb();\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tcnt++;\n\t\t\t\tres = cps[i];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\t\t\n\t\tPoint res;\n\t\tint cnt = 0;\n\t\tfor (auto cp : cps){\n\t\t\tReal d = distance(l[0], cp);\n\t\t\tbool f = true;\n\t\t\trep(i, n){\n\t\t\t\tif (neq(d, distance(l[i], cp))){\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcnt++;\n\t\t\t\tres = cp;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt >= 2) cout << \"Many\\n\";\n\t\telse if (cnt == 0) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-11L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ) if( abs(answer-cp) > EPS )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t\t/*assert( abs(answer-cp) < EPS );*/\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ) puts(\"Many\");\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    /*\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    */\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg){\n          vec.push_back(target);\n        }\n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(vec.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(vec.size()==1){\n    printf(\"%.8f %.8f\\n\",real(vec[0]),imag(vec[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\nusing namespace std;\nconst double EPS = 1e-6;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\n\nPt p1[110];\nPt p2[110];\ndouble rd[100];\ndouble ld[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X1,X2,Y1,Y2;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&X1,&Y1,&X2,&Y2);\n\t\t\tp1[i]=Pt(X1,Y1);\n\t\t\tp2[i]=Pt(X2,Y2);\n\t\t}\n\t\tif(a<=2){\n\t\t\tprintf(\"Many\\n\");continue;\n\t\t}\n\t\tif(iLL(p1[0],p2[0],p1[1],p2[1])==0&&iLL(p1[1],p2[1],p1[2],p2[2])==0){\n\t\t\tprintf(\"None\\n\");continue;\n\t\t}\n\t\tvector<pair<Pt,Pt> >L1;\n\t\tvector<pair<Pt,Pt> >L2;\n\t\tif(iLL(p1[0],p2[0],p1[1],p2[1])==0){\n\t\t\tPt L=(p1[0]+p1[1])/2;\n\t\t\tPt R=(p2[0]+p2[1])/2;\n\t\t\tif((L-R).ABS()<1.0){\n\t\t\t\tL=(p1[0]+p2[1])/2;\n\t\t\t\tR=(p2[0]+p1[1])/2;\n\t\t\t}\n\t\t\tL1.push_back(make_pair(L,R));\n\t\t}else{\n\t\t\tPt p=pLL(p1[0],p2[0],p1[1],p2[1]);\n\t\t\tdouble th=0;\n\t\t\tif((p2[0]-p).ABS()>1)th+=((p2[0]-p).arg());\n\t\t\telse th+=((p1[0]-p).arg());\n\t\t\tif((p2[1]-p).ABS()>1)th+=((p2[1]-p).arg());\n\t\t\telse th+=((p1[1]-p).arg());\n\t\t\tth/=2;\n\t\t\tL1.push_back(make_pair(p,p+Pt(cos(th),sin(th))*1000.0));\n\t\t\tL1.push_back(make_pair(p,p+Pt(cos(th+PI/2),sin(th+PI/2))*1000.0));\n\t\t}\n\t\tif(iLL(p1[2],p2[2],p1[1],p2[1])==0){\n\t\t\tPt L=(p1[2]+p1[1])/2;\n\t\t\tPt R=(p2[2]+p2[1])/2;\n\t\t\tif((L-R).ABS()<1.0){\n\t\t\t\tL=(p1[2]+p2[1])/2;\n\t\t\t\tR=(p2[2]+p1[1])/2;\n\t\t\t}\n\t\t\tL2.push_back(make_pair(L,R));\n\t\t}else{\n\t\t\tPt p=pLL(p1[2],p2[2],p1[1],p2[1]);\n\t\t\tdouble th=0;\n\t\t\tif((p2[2]-p).ABS()>1)th+=((p2[2]-p).arg());\n\t\t\telse th+=((p1[2]-p).arg());\n\t\t\tif((p2[1]-p).ABS()>1)th+=((p2[1]-p).arg());\n\t\t\telse th+=((p1[1]-p).arg());\n\t\t\tth/=2;\n\t\t\tL2.push_back(make_pair(p,p+Pt(cos(th),sin(th))*1000.0));\n\t\t\tL2.push_back(make_pair(p,p+Pt(cos(th+PI/2),sin(th+PI/2))*1000.0));\n\t\t}\n\t//\tprintf(\"%d %d\\n\",L1.size(),L2.size());\n\t\tvector<Pt>hb;\n\t\tfor(int i=0;i<L1.size();i++)for(int j=0;j<L2.size();j++){\n\t\t//\tif(iLL(L1[i].first,L1[i].second,L2[j].first,L2[j].second)!=1)printf(\"Alert\\n\");\n\t\t\thb.push_back(pLL(L1[i].first,L1[i].second,L2[j].first,L2[j].second));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<hb.size();i++){\n\t//\t\tprintf(\"%f %f: \",hb[i].x,hb[i].y);\n\t\t\tbool dame=false;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif((hb[i]-hb[j]).ABS()<EPS){\n\t\t\t\t\tdame=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dame){\n\t\t\t\trd[i]=1;ld[i]=0;continue;\n\t\t\t}\n\t\t\trd[i]=-999999999;ld[i]=999999999;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble dist=dLP(p1[j],p2[j],hb[i]);\n\t\t\t\trd[i]=max(rd[i],dist);\n\t\t\t\tld[i]=min(ld[i],dist);\n\t\t\t//\tprintf(\"%f \",dist);\n\t\t\t}//printf(\"\\n\");\n\t\t\tif(rd[i]-ld[i]<EPS)ans++;\n\t\t}\n\t\tif(ans>1)printf(\"Many\\n\");\n\t\telse if(ans==0)printf(\"None\\n\");\n\t\telse{\n\t\t\tfor(int i=0;i<hb.size();i++){\n\t\t\t\tif(rd[i]-ld[i]<EPS)printf(\"%f %f\\n\",hb[i].x,hb[i].y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-7;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n\tpoint is;\n\tif(intersectionLL( vl[i], vl[j], is)){\n\t  vec va;\n\t  vec vb;\n\t  \n\t  if( far(is,vl[i].fr) ){\n\t    va = uvec(vl[i].fr-is);\n\t  }else{\n\t    va = uvec(vl[i].sc-is);\n\t  }\n\t  \n\t  if( far(is,vl[j].fr) ){\n\t    vb = uvec(vl[j].fr-is);\n\t  }else{\n\t    vb = uvec(vl[j].sc-is);\n\t  }\n\t  \n\t  bisector.push_back( line( is, is+va+vb ) );\n\t  bisector.push_back( line( is, is+va-vb ) );\n\t  \n\t}else{\n\t  elem d = 0.5 * dist_l( vl[j], vl[i].fr );\n\t  point is;\n\t  intersectionLL( line(vl[i].fr, vl[i].fr+unmr(vl[i].sc-vl[i].fr) ), vl[j], is );\n\t  \n\t  point cfr = d * uvec(is-vl[i].fr) + vl[i].fr;\n\t  point csc = d * uvec(is-vl[i].fr) + vl[i].sc;\n\t  bisector.push_back( line(cfr,csc) );\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\n\tif( ccw(bisector[i].fr,bisector[i].sc,bisector[j].fr) & (OVER|FRONT|BACK) &&\n\t    ccw(bisector[i].fr,bisector[i].sc,bisector[j].sc) & (OVER|FRONT|BACK) ) continue;\n\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      break;\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-5)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    if(n <= 2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector< vector<Line> > bilines;\n    rep(i, n) reps(j, i+1, n) {\n      Line l = lines[i], r = lines[j];\n      Vector lv = l.p2 - l.p1, rv = r.p2 - r.p1;\n      lv = lv / abs(lv); rv = rv / abs(rv);\n      vector<Line> bi;\n      if(isParallel(l, r)) {\n\tPoint o = (l.p1+r.p1)/2;\n\tLine m = Line(o, o + lv);\n\tbi.push_back(m);\n\tbilines.push_back(bi);\n      } else {\n\tPoint p = getCrossPointLL(l, r);\n\tLine v = Line(p, p + lv*100 + rv*100);\n\tLine w = Line(p, p + lv*100 - rv*100);\n\tbi.push_back(v);\n\tbi.push_back(w);\n\tbilines.push_back(bi);\n      }\n    }\n    vector<Point> ans;\n    rep(i, min((int)bilines.size(), 10LL)) {\n      reps(j, i+1, min((int)bilines.size(), 10LL)) {\n\tvector<Line> a = bilines[i], b = bilines[j];\n\trep(k, a.size()) rep(l, b.size()) {\n\t  if(isParallel(a[k], b[l])) continue;\n\t  bool flag = true;\n\t  Point cp = getCrossPointLL(a[k], b[l]);\n\t  //cout<<cp.x<<\" \"<<cp.y<<endl;\n\t  double dist = getDistanceLP(lines[0], cp);\n\t  rep(x, n) {\n\t    //cout<<dist<< \" \"<< getDistanceLP(lines[x], cp) << endl;\n\t    if(!eq(dist, getDistanceLP(lines[x], cp))) flag = false;\n\t  }\n\t  rep(x, ans.size()) {\n\t    if(eq(abs(ans[x]-cp), 0)) flag = false;\n\t  }\n\t  if(flag) ans.push_back(cp);\n\t}\n      }\n    }\n    if(ans.size() == 0) cout << \"None\" << endl;\n    else if(ans.size() == 1) {\n      cout << ans[0].x << \" \" << ans[0].y << endl;\n    }\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-8;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n\t// operator point<double>()const{ return (point<double>){x,y}; }\n};\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\n// 整数 × 整数点, 実数 × 実数点 ( 他のバリエーションは必要になったときに用意する )\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\nbool intersect(const line<double> &L1,const line<double> &L2){\n\treturn abs(cross(L1.b-L1.a,L2.b-L2.a))>EPS\n\t\t|| abs(cross(L1.b-L1.a,L2.a-L1.a))<EPS;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<double> &L,const line<double> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tpoint<double> P[4];\n\t\tP[0]=(L.a+M.a)/2;\n\t\tP[1]=(L.a+M.b)/2;\n\t\tP[2]=(L.b+M.a)/2;\n\t\tP[3]=(L.b+M.b)/2;\n\t\tsort(P,P+4);\n\t\tunique(P,P+4);\n\t\tres.push_back((line<double>){P[0],P[1]});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(L.a==o?L.b:L.a);\n\t\tpoint<double> q=(M.a==o?M.b:M.a);\n\t\tres.push_back((line<double>){o,p+q-o});\n\t\tq+=2.*(o-q);\n\t\tres.push_back((line<double>){o,p+q-o});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<double> L[100];\n\t\trep(i,n) scanf(\"%lf%lf%lf%lf\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist(L[j],p)-dist(L[0],p))>EPS) { ok=false; break; }\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\t\tsort(ans.begin(),ans.end());\n\t\tans.erase(unique(ans.begin(),ans.end()),ans.end());\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n    /*    \n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    \n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-4)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return (x!=p.x ? x-p.x<-eps : y-p.y<-eps);}\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  return r;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(all(vp));\n  res.pb(vp[0]);\n  FOR(i,1,vp.size())if(!(vp[i]==res.back()))res.pb(vp[i]);\n  return res;\n}\n\ntypedef pair<Line,Line> pll;\n\nint n;\nvector<Segment> vs;\nvector<Point> vp;\n\nbool check2(Point p){\n  double dis=getDistanceLP(vs[0],p);\n  FOR(i,1,n)\n    if(!equals(dis,getDistanceLP(vs[i],p)))return false;\n  return true;\n}\n\nvoid check1(Line a,Line b,Line c){\n  Point d=getCrossPointLL(a,c),e=getCrossPointLL(b,c);\n  Point m=d+(e-d)/2.0;\n  double dis=getDistanceLP(a,m);\n  Vector v=a.p1-a.p2;\n  v=v*dis/abs(v);\n  if(check2(m+v))vp.pb(m+v);\n  if(check2(m-v))vp.pb(m-v);\n  return;\n}\n\nvoid check3(pll a,pll b){\n  if(!isParallel(a.f,b.f)){\n    Point c=getCrossPointLL(a.f,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.f,b.s)){\n    Point c=getCrossPointLL(a.f,b.s);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.f)){\n    Point c=getCrossPointLL(a.s,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.s)){\n    Point c=getCrossPointLL(a.s,b.s);\n    if(check2(c))vp.pb(c);\n  }\n}\n\npair<Line,Line> getS(Line a,Line b){\n  Point m=getCrossPointLL(a,b);\n  double r=getAngle(a.p1-a.p2,b.p1-b.p2);\n  Line c(rotate(m,a.p1,r/2.0),rotate(m,a.p2,r/2.0));\n  Line d(rotate(m,a.p1,(180.0-r)/2.0),rotate(m,a.p2,(180.0-r)/2.0));\n  return mp(c,d);\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      FOR(k,j+1,n){\n        if(isParallel(vs[i],vs[j]) && isParallel(vs[i],vs[k]))continue;\n        if(isParallel(vs[i],vs[j]))check1(vs[i],vs[j],vs[k]);\n        else if(isParallel(vs[i],vs[k]))check1(vs[i],vs[k],vs[j]);\n        else if(isParallel(vs[j],vs[k]))check1(vs[j],vs[k],vs[i]);\n        else {\n          pll a=getS(vs[i],vs[j]);\n          pll b=getS(vs[j],vs[k]);\n          pll c=getS(vs[k],vs[i]);\n          check3(a,b);\n          check3(b,c);\n          check3(c,a);\n        }\n      }\n    }\n  }\n  vp=unique(vp);\n  if(vp.empty())cout<<\"None\"<<endl;\n  else if(vp.size()>1)cout<<\"Many\"<<endl;\n  else printf(\"%.10f %.10f\\n\",vp[0].x,vp[0].y);\n  return;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    vs.clear();\n    vp.clear();\n    FOR(i,0,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      vs.pb(Segment(Point(a,b),Point(c,d)));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-9L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n\n  int res = ccw(cp,p1,p2);\n\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 30 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = (m); i < (n); ++i)\n#define pb push_back\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Pt;\ndouble dot(const Pt &a, const Pt &b) { return real(conj(a) * b); }\ndouble cross(const Pt &a, const Pt &b) { return imag(conj(a) * b); }\nnamespace std {\n    bool operator == (const Pt &a, const Pt &b) {\n        return abs(real(a) - real(b)) < EPS && abs(imag(a) - imag(b)) < EPS;\n    }\n}\n\nstruct Line : public vector<Pt>\n{\n    Line(){};\n    Line(const Pt &a, const Pt &b) {\n        pb(a); pb(b);\n    }\n};\n\nPt projection(const Line &l, const Pt &p)\n{\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distLP(const Line &l, const Pt &p)\n{\n    return abs(p - projection(l, p));\n}\n\nbool is_parallel(const Line &l, const Line &m)\n{\n    return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\nPt crosspoint(const Line &l, const Line &m)\n{\n    double a = cross(l[1] - l[0], m[1] - m[0]);\n    double b = cross(l[1] - l[0], l[1] - m[0]);\n    return m[0] + b / a * (m[1] - m[0]);\n}\n\n\nint main()\n{\n    int n, x1, y1, x2, y2;\n    cout << fixed << setprecision(5);\n    \n    while (cin >> n && n)\n    {\n        vector<Line> line;\n        rep(i, n) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            line.pb(Line(Pt(x1, y1), Pt(x2, y2)));\n        }\n        if(n < 3) { cout << \"Many\" << endl; continue; }\n        \n        vector<Pt> cand;\n        vector<Pt> insec;\n        vector<Line> bis;\n        vector<double> dist;\n        rep(i, 3)\n        {\n            Line &l1 = line[i], &l2 = line[(i+1)%3];\n            if(!is_parallel(l1, l2))\n            {\n                Pt p1 = l1[1] - l1[0], p2 = l2[1] - l2[0];\n                p1 /= abs(p1); p2 /= abs(p2);\n                Pt c = crosspoint(l1, l2);\n                bis.pb(Line(c, c + p1 + p2));\n                bis.pb(Line(c, c + p1 - p2));\n                insec.pb(c);\n            }\n            else\n            {\n                Pt p((real(l1[0]) + real(l2[0])) / 2, (imag(l1[0]) + imag(l2[0])) / 2);\n                bis.pb(Line(p, p + l1[1] - l1[0]));\n            }\n        }\n        rep(i, bis.size()) rep2(j, i + 1, bis.size())\n        {\n        \tif(is_parallel(bis[i], bis[j])) continue;\n            bool same = false;\n            Pt p = crosspoint(bis[i], bis[j]);\n            rep(k, cand.size()) if(p == cand[k]) same = true;\n            rep(k, insec.size()) if(p == insec[k]) same = true;\n            if(!same) cand.pb(p);\n        }\n        rep(i, cand.size()) dist.pb(distLP(line[0], cand[i]));\n        \n        rep2(i, 3, n) rep(j, cand.size()) if(abs(dist[j] - distLP(line[i], cand[j])) > EPS)\n        {\n            cand.erase(cand.begin() + j);\n            dist.erase(dist.begin() + j);\n            --j;\n        }\n        \n        if(cand.size() > 1)  cout << \"Many\" << endl;\n        if(cand.size() == 1) cout << real(cand[0]) << ' ' << imag(cand[0]) << endl;\n        if(cand.size() == 0) cout << \"None\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point p = crosspointLL(l, m);\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    res.push_back(Line(p, p + vec1 + vec2));\n    res.push_back(Line(p, p + vec1 - vec2));\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 0; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n        for(int j = i + 1; j < 3; j++){\n            if(paralell(lines[i], lines[j])) continue;\n            vector<Line> mids = get_midline(lines[i], lines[j]);\n            midlines.insert(midlines.end(), mids.begin(), mids.end());\n        }\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 1; k < lines.size(); k++){\n                if(sign(distanceLP(lines[k], p) - distanceLP(lines[k - 1], p)) != 0){\n                    ok = false;\n                    break;\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.12f %.12f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1){\n    REP(j,i+1,a.size()){\n//       cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n// \t   << a[j].fir <<\" \" << a[j].sec << endl;\n//       cout << j<<\" \"<< is_intersected_ll(\n// \t\t\t\t\t a[i].fir,a[i].sec,\n// \t\t\t\t\t a[j].fir,a[j].sec)<<\n// \t\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && abs(ans-cand)<1e-5)continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    //    REP(j,i+1,a.size()){\n    REP(j,i+1,i+3){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\t//\tb.pb(mp(tmp,tmp+rot2(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n\n\n//  \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n//  \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n//   \tcout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n//  \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" \n//  \t     <<\"[\"<<a[i].fir<<\",\" << a[i].sec<<\"],\" \n//  \t     <<\"[\"<<a[j].fir<<\",\" << a[j].sec<<\"],\" <<endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-10;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n\n\n        if( isParallel(ab,bc) && isParallel(bc,ca) && isParallel(ca,ab) ){\n          continue;\n        }\n        \n        P target;\n        \n        if( !isParallel(ab,bc) ){\n          target=intersect(ab,bc);\n        }\n        if( !isParallel(ca,bc) ){\n          target=intersect(ca,bc);\n        }\n        if( !isParallel(bc,ca) ){\n          target=intersect(bc,ca);\n        }\n        \n        if( !isParallel(ab,bc) ){\n          P q2=intersect(ab,bc);\n          if( abs(target-q2) > eps )continue;\n        }\n        if( !isParallel(bc,ca) ){\n          P q0=intersect(bc,ca);\n          if( abs(target-q0) > eps )continue;\n        }\n        if( !isParallel(ca,bc) ){\n          P q1=intersect(ca,ab);         \n          if( abs(target-q1) > eps )continue;\n        }\n\n\n        \n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  //  rep(i,1){\n  //    REP(j,i+1,a.size()){\n  rep(i,a.size()-1){\n    int j=i+1;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\t//\tb.pb(mp(tmp,tmp+rot2(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n\n\n// \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n// \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n//  \tcout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n// \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" \n// \t     <<\"[\"<<a[i].fir<<\",\" << a[i].sec<<\"],\" \n// \t     <<\"[\"<<a[j].fir<<\",\" << a[j].sec<<\"],\" <<endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  //  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n\n  rep(i,candy.size()){\n    //cout << candy[i] << endl;\n  }\n\n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    sort(a.begin(),a.end());\n    if (a.size() == 1){\n      printf(\"None\\n\");\n    }else if (a.size() == 2){\n      printf(\"Many\\n\");\n    } else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-7;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<sqrt(eps);\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    //P m=(a1+b1)/2.l;\n    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-3;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn (l.first-x).cross(l.second-x) == 0;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\ttmp.push_back(make_pair((p[i]+p[j])*0.5, (q[i]+q[j])*0.5));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\telse if(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec.clear();\n\t\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\t\tif( fabs(pvec[j].x - npvec[j].x) < eps && fabs(pvec[j].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec.clear();\n\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\tif( fabs(pvec[j].x - npvec[j].x) < eps && fabs(pvec[j].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1&&a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n\t\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size()&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n\tif (cnt == 1 && EQV(ans,cand))continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-7;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n == 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<Line> ls;\n\t\trep(i, bs.size()) for (auto b : bs[i]){\n\t\t\tls.eb(b);\n\t\t}\n\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, bs.size()) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (cps.size() > 50) return;\n\t\t\t}\n\t\t}();\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tunique(cps);\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnone = true;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tnone = false;\n\t\t\t\tres = cps[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (none) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nstruct point {\n\tdouble x, y;\n\tvoid scan() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tpoint() {\n\t}\n\tpoint(const double & a, const double & b) : x(a), y(b) {\n\t}\n\tdouble sqrlen() const {\n\t\treturn x * x + y * y;\n\t}\n\tdouble len() const {\n\t\treturn sqrt(max(0., sqrlen()));\n\t}\n\tpoint zoom(const double & l) const {\n\t\tdouble lambda(l / len());\n\t\treturn point(lambda * x, lambda * y);\n\t}\n\tpoint rev() const {\n\t\treturn point(-y, x);\n\t}\n\tvoid print() const {\n\t\tprintf(\"%.10f %.10f\\n\", x, y);\n\t}\n};\ndouble sqr(double x) { return x * x; }\npoint operator + (const point& p1, const point& p2) { return point(p1.x + p2.x, p1.y + p2.y); }\npoint operator - (const point& p1, const point& p2) { return point(p1.x - p2.x, p1.y - p2.y); }\npoint operator * (const point& p1, double d) { return point(p1.x * d, p1.y * d); }\npoint operator / (const point& p1, double d) { return point(p1.x / d, p1.y / d); }\nint dcmp(double x) { return fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); }\ndouble det(point p1, point p2) { return p1.x * p2.y - p1.y * p2.x; }\ndouble dist(point p1, point p2) { return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y)); }\npoint nor(point p) { return p / sqrt(max(0., sqr(p.x) + sqr(p.y))); }\n\nstruct Line {\n\tpoint s, d;\n\tLine(const point & a, const point & b) : s(a), d(b) {\n\t}\n\tLine() {\n\t}\n} l[10001], p[10001][2];\n\nint n;\npoint a[10001], b[10001];\n\npoint inter(point p, point v, point q, point w) {\n\tpoint u = p - q;\n\tdouble t = det(w, u) / det(v, w);\n\treturn p + v * t;\n}\n\nbool operator < (const point& p1, const point& p2) {\n\tif (dcmp(p1.x - p2.x)) return p1.x < p2.x;\n\tif (dcmp(p1.y - p2.y)) return p1.y < p2.y;\n\treturn false;\n}\n__inline double operator * (const point & a, const point & b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n__inline point intersection(const Line & a, const Line & b) {\n\tdouble lambda((b.s - a.s) * b.d / (a.d * b.d));\n\treturn a.s + a.d * lambda;\n}\n__inline bool equal(const double & a, const double & b) {\n\treturn dcmp(a - b) == 0;\n}\n\n\ndouble D(point p, point p1, point p2) {\n\treturn fabs((p - p1) * (p - p2)) / dist(p1, p2);\n}\nint main( ) {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%lf %lf\", &a[i].x, &a[i].y);\n\t\t\tscanf(\"%lf %lf\", &b[i].x, &b[i].y);\n\t\t}\n\t\tif (n <= 2) { printf(\"Many\\n\"); continue; }\n\t\tfor(int i(1); i <= 3; i++) {\n\t\t\tl[i] = Line(a[i], b[i] - a[i]);\n\t\t}\n\t\tfor (int i = 1; i <= 2; i ++) {\n\t\t\tif (dcmp(l[i].d * l[i + 1].d) == 0) \n\t\t\t\tp[i][0] = p[i][1] = Line((l[i].s + l[i + 1].s) * 0.5, l[i].d);\n\t\t\telse {\n\t\t\t\tp[i][0] = Line(intersection(l[i], l[i + 1]), (l[i].d.zoom(1) + l[i + 1].d.zoom(1)) * 0.5);\n\t\t\t\tp[i][1] = Line(intersection(l[i], l[i + 1]), (l[i].d.zoom(-1) + l[i + 1].d.zoom(1)) * 0.5);\n\t\t\t}\n\t\t}\n\t\tset<point> S;\n\t\tfor (int i = 0; i < 2; i ++)\n\t\t\tfor (int j = 0; j < 2; j ++) {\n\t\t\t\tpoint x = p[1][i].d;\n\t\t\t\tpoint y = p[2][j].d;\n\n\t\t\t\tif (dcmp(det(x, y)) == 0) continue;\n\t\t\t\tpoint o = intersection(p[1][i], p[2][j]);\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 2; j <= n; ++ j)\n\t\t\t\t\tif (dcmp(D(o, a[j], b[j]) - D(o, a[1], b[1]))) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == false) S.insert(o);\n\t\t\t}\n\t\tif (S.size() == 0) printf(\"None\\n\");\n\t\telse if (S.size() > 1) printf(\"Many\\n\");\n\t\telse S.begin() -> print();\n\t}\n\treturn 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5) - Point((s[1] + t[1])*0.5)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5), Point((s[1] + t[0])*0.5));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5), Point((s[1] + t[1])*0.5));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n\tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > 3e-5)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n        C.push_back(A.back().first);\n        C.push_back(A.back().second);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-7;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ){\n\t  va = uvec(vl[t].fr-is);\n\t}else{\n\t  va = uvec(vl[t].sc-is);\n\t}\n\t\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\n\tif( (ccw(bisector1[i].fr,bisector1[i].sc,bisector2[j].fr) & (OVER|FRONT|BACK)) &&\n\t    (ccw(bisector1[i].fr,bisector1[i].sc,bisector2[j].sc) & (OVER|FRONT|BACK)) ) continue;\n\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      if(i==1)\n\tbreak;\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\ntypedef complex<double> P;\n\nstruct L: public vector<P> {\n    L(){}\n    L(const P &a, const P &b){\n        pb(a);pb(b);\n    }\n};\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\ndouble dot(const P &a, const P &b){\n    return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>0)return +1;\n    if(cross(b,c)<0)return -1;\n    if(dot(b,c)<0)return +2;\n    if(norm(b)<norm(c))return -2;\n}\n\nbool insecLL(const L &l, const L &m){\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nP proj(const L &l, const P &p){\n    double t=dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distLP(const L &l, const P &p){\n    return abs(p - proj(l,p));\n}\n\nP crosspoint(const L &l, const L &m){\n    double A=cross(l[1]-l[0],m[1]-m[0]);\n    double B=cross(l[1]-l[0],l[1]-m[0]);\n    if(abs(A)<EPS && abs(B)<EPS)return m[0];\n    if(abs(A)<EPS)assert(0);\n    return m[0] + B/A*(m[1]-m[0]);\n}\n\nvector<L> bisector(const L &l, const L &m){\n    if(!insecLL(l,m))assert(0);\n    P p=crosspoint(l,m);\n    vector<L> res;\n    L res0,res1;\n    P l0=(l[1]-l[0])/norm(l[1]-l[0]);\n    P m0=(m[1]-m[0])/norm(m[1]-m[0]);\n    res0.pb(p); res0.pb(p+l0+m0);\n    res1.pb(p); res1.pb(p+l0-m0);\n    res.pb(res0); res.pb(res1);\n    return res;\n}\n\nint n;\nL line[111];\n\nint main(){\n\twhile(cin>>n && n){\n        int num=0;\n        P ans;\n        rep(i,n){\n            int x,y,xx,yy;\n            cin>>x>>y>>xx>>yy;\n            line[i]=L(P(x,y),P(xx,yy));\n        }\n        if(n<=2){\n            cout<<\"Many\\n\";continue;\n        }\n        L l0=line[0],l1=line[1],l2=line[2];\n        vector<L> v1,v2;\n        if(insecLL(l0,l1)){\n            v1=bisector(l0,l1);\n        }else{\n            P p=proj(l0,l1[0]);\n            P mid=(p,l1[0]);\n            v1.pb(L(mid,mid+l0[1]-l0[0]));\n        }\n        if(insecLL(l0,l2)){\n            v2=bisector(l0,l2);\n        }else{\n            P p=proj(l0,l2[0]);\n            P mid=(p,l2[0]);\n            v2.pb(L(mid,mid+l0[1]-l0[0]));\n        }\n        rep(i,v1.sz)rep(j,v2.sz){\n            if(insecLL(v1[i],v2[j])){\n                P p=crosspoint(v1[i],v2[j]);\n                double d=distLP(l0,p);\n                rep2(k,3,n){\n                    if(abs(d-distLP(line[k],p))>EPS){\n                        goto fail;\n                    }\n                }\n                if(num>0){\n                    cout<<\"Many\"<<endl;\n                    goto end;\n                }\n                num++;\n                ans=p;\n            fail:;\n            }\n        }\n        if(num==1)cout<<ans.real()<<\" \"<<ans.imag()<<endl;\n        else cout<<\"None\"<<endl;\n    end:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-10;\nconst double pi = acos(-1.0);\nconst double mag = 800;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ) va = uvec(vl[t].fr-is);\n\telse va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) ) vb = uvec(vl[i].fr-is);\n\telse vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n \nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n \ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n \nbool intersectLL(const L& a, const L& b){\n    return ( abs(cross(a[1]-a[0], b[1]-b[0])) > EPS ) ||\n        ( abs(cross(a[1]-a[0], b[0]-a[0])) < EPS );\n}\n \nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n \nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nvector<L> equidist(const L &a, const L &b){\n    vector<L> ret;\n    if(isParallel(a, b)){\n        P mid = (a[0]+b[0])/2.0;\n        ret.push_back( L(mid, mid+(a[1]-a[0])) );\n    }else{\n        P cp = crosspointLL(a, b);\n        P v1 = unit(a[1]-a[0]), v2 = unit(b[1]-b[0]);\n        ret.push_back( L(cp, cp+ (v1+v2)/2.0) );\n        ret.push_back( L(cp, cp+ (v1-v2)/2.0) );\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n         \n        vector<L> l(n);\n        for(int i=0; i<n; i++){\n            int x1,y1,x2,y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            l[i] = L(P(x1,y1), P(x2,y2));\n        }\n        \n        if(n<=2){\n            cout << \"Many\" << endl;\n            continue;\n        }\n        \n        vector<L> line = equidist(l[0], l[1]);\n        VP point;\n        for(int i=2; i<n; i++){\n            for(int j=0; j<i; j++){\n                VP newpoint;\n                vector<bool> remain_l(line.size(), false);\n                vector<bool> remain_p(point.size(), false);\n                vector<L> cl = equidist(l[i], l[j]);\n                for(int d=0; d<(int)cl.size(); d++){\n                    for(int k=0; k<(int)line.size(); k++){\n                        if(distanceLL(cl[d], line[k]) < EPS){\n                            if(isParallel(cl[d], line[k])) remain_l[k] = true;\n                            else newpoint.push_back(crosspointLL(cl[d], line[k]));\n                        }\n                    }\n                    for(int k=0; k<(int)point.size(); k++){\n                        if(distanceLP(cl[d], point[k]) < EPS) remain_p[k] = true;\n                    }\n                }\n                for(int k=line.size()-1; k>=0; k--){\n                    if(!remain_l[k]) line.erase(line.begin()+k);\n                }\n                for(int k=point.size()-1; k>=0; k--){\n                    if(!remain_p[k]) point.erase(point.begin()+k);\n                }\n                copy(newpoint.begin(), newpoint.end(), back_inserter(point));\n            }\n        }\n        \n        sort(point.begin(), point.end());\n        point.erase(unique(point.begin(), point.end()), point.end());\n        if(!line.empty() || (int)point.size()>1){\n            cout << \"Many\" << endl;\n        }else if(point.empty()){\n            cout << \"None\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(3);\n            cout << point[0].X << \" \" << point[0].Y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <assert.h>\n#include <string.h>\n\nusing namespace std;\n\ntypedef complex<double> Complex;\ntypedef Complex P;\n\nstatic const double EPS = 1e-6;\ninline bool EQ(double a, double b) { return abs(a - b) < EPS; }\ninline bool EQP(Complex a, Complex b) { return norm(a - b) < EPS; }\n\nstruct Seg;\nstruct Line;\nstruct Circle;\n\ndouble X(P p) { return p.real(); }\ndouble Y(P p) { return p.imag(); }\ndouble dot(P a, P b) { return X(conj(a) * b); }\ndouble cross(P a, P b) { return Y(conj(a) * b); }\ndouble ccw(P p1, P p2, P p3) { return cross(p2 - p1, p3 - p1); }\nP proj(P p, P q) { return q * dot(p, q) / norm(q); }\nP rot(P p) { return p * P(0, 1); }\n\n\nstruct Line {\n  P p, v;\n  double distance(P q) {\n    return abs(cross(v, q - p)) / abs(v);\n  }\n  bool is_contain(P q) {\n    return EQ(cross(v, q - p), 0.0);\n  }\n  bool is_parallel(Line rhs) {\n    return EQ(cross(v, rhs.v), 0.0);\n  }\n  P intersection(Line rhs) {\n    assert(!is_parallel(rhs));\n    return p + v * cross(rhs.v, rhs.p - p) / cross(rhs.v, v);\n  }\n};\n\n\nstruct Triangle {\n  P p1, p2, p3;\n  Triangle(P p1, P p2, P p3) : p1(p1), p2(p2), p3(p3) {;}\n  P incenter() {\n    double le1 = abs(p2 - p3), le2 = abs(p3 - p1), le3 = abs(p1 - p2);\n    return (p1 * le1 + p2 * le2 + p3 * le3) / (le1 + le2 + le3);\n  }\n\n  vector<P> excenter() {\n    vector<P> ret;\n    double le1 = abs(p2 - p3), le2 = abs(p3 - p1), le3 = abs(p1 - p2);\n    ret.push_back((-p1 * le1 + p2 * le2 + p3 * le3) / (-le1 + le2 + le3));\n    ret.push_back(( p1 * le1 - p2 * le2 + p3 * le3) / ( le1 - le2 + le3));\n    ret.push_back(( p1 * le1 + p2 * le2 - p3 * le3) / ( le1 + le2 - le3));\n    return ret;\n  }\n};\n\nLine line[300];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    line[i].p = Complex(x1, y1);\n    line[i].v = Complex(x2 - x1, y2 - y1);\n    line[i].v /= abs(line[i].v);\n  }\n  if (n < 3) {\n    puts(\"Many\");\ncontinue;\n  }\n  if (line[0].is_parallel(line[1]) && line[0].is_parallel(line[2])) {\n    puts(\"None\");\ncontinue;\n  }\n  vector<P> point;\n  vector<double> dist;\n  bool fail[4];\n  memset(fail, false, sizeof(fail));\n  if (line[0].is_parallel(line[1]) || line[0].is_parallel(line[2]) || line[1].is_parallel(line[2])) {\n    if (line[0].is_parallel(line[1])) {\n    } else if (line[0].is_parallel(line[2])) {\n      swap(line[1], line[2]);\n    } else if (line[2].is_parallel(line[2])) {\n      swap(line[0], line[2]);\n    }\n    P p1 = line[2].intersection(line[0]);\n    P p2 = line[2].intersection(line[1]);\n    P c = (p1 + p2) / 2.0;\n    point.push_back(c + line[0].v * abs(p1 - c));\n    point.push_back(c - line[0].v * abs(p1 - c));\n    dist.push_back(line[0].distance(point[0]));\n    dist.push_back(line[0].distance(point[1]));\n  } else {\n    P p1 = line[0].intersection(line[1]);\n    P p2 = line[1].intersection(line[2]);\n    P p3 = line[2].intersection(line[0]);\n    if (EQP(p1, p2) && EQP(p1, p3)) {\n      point.push_back(p1);\n      dist.push_back(0.0);\n    } else {\n      Triangle tri(p1, p2, p3);\n      point = tri.excenter();\n      point.push_back(tri.incenter());\n      dist.push_back(line[0].distance(point[0]));\n      dist.push_back(line[0].distance(point[1]));\n      dist.push_back(line[0].distance(point[2]));\n      dist.push_back(line[0].distance(point[3]));\n    }\n  }\n  int rest = (int)point.size();\n  for (int i = 3; i < n; i++) {\n    for (int j = 0; j < (int)point.size(); j++) {\n      if (fail[j]) { continue; }\n      double d = line[i].distance(point[j]);\n      if (!EQ(d, dist[j])) {\n        fail[j] = true;\n        rest--;\n      }\n    }\n  }\n  P ans;\n  for (int i = 0; i < (int)point.size(); i++) {\n    if (!fail[i]) {\n      ans = point[i];\n    }\n  }\n  if (rest == 0) {\n    puts(\"None\");\n  } else if (rest > 1) {\n    puts(\"Many\");\n  } else {\n    printf(\"%.4lf %.4lf\\n\", ans.real(), ans.imag());\n  }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-9;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n<=2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==2){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<set>\nusing namespace std;\nconst int N(111);\nstruct Point {\n\tdouble x, y;\n\tvoid scan() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tPoint() {\n\t}\n\tPoint(const double & a, const double & b) : x(a), y(b) {\n\t}\n\tdouble sqrlen() const {\n\t\treturn x * x + y * y;\n\t}\n\tdouble len() const {\n\t\treturn sqrt(max(0., sqrlen()));\n\t}\n\tPoint zoom(const double & l) const {\n\t\tdouble lambda(l / len());\n\t\treturn Point(lambda * x, lambda * y);\n\t}\n\tPoint rev() const {\n\t\treturn Point(-y, x);\n\t}\n\tvoid print() const {\n\t\tprintf(\"%.10f %.10f\\n\", x, y);\n\t}\n} s[N], t[N];\nstruct Line {\n\tPoint s, d;\n\tLine(const Point & a, const Point & b) : s(a), d(b) {\n\t}\n\tLine() {\n\t}\n} l[N], l4[N][2];\ndouble eps(1e-10);\n__inline int sign(const double & x) {\n\treturn fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); \n}\n__inline bool equal(const double & a, const double & b) {\n\treturn sign(a - b) == 0;\n}\n__inline Point operator + (const Point & a, const Point & b) {\n\treturn Point(a.x + b.x, a.y + b.y);\n}\n__inline Point operator - (const Point & a, const Point & b) {\n\treturn Point(a.x - b.x, a.y - b.y);\n}\n__inline Point operator * (const double & a, const Point & b) {\n\treturn Point(a * b.x, a * b.y);\n}\n__inline double operator * (const Point & a, const Point & b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n__inline double operator % (const Point & a, const Point & b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n__inline Point intersection(const Line & a, const Line & b) {\n\tdouble lambda((b.s - a.s) * b.d / (a.d * b.d));\n\treturn a.s + lambda * a.d;\n}\n__inline double dis(const Point & a, const Point & s, const Point & t) {\n\treturn fabs((s - a) * (s - t)) / (s - t).len();\n}\n__inline bool operator < (const Point & a, const Point & b) {\n\tif(!equal(a.x, b.x)) {\n\t\treturn a.x < b.x;\n\t}\n\tif(!equal(a.y, b.y)) {\n\t\treturn a.y < b.y;\n\t}\n\treturn false;\n}\nint main() {\n\tint n;\n\tfor(int _ = 1; ; _++) {\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i(1); i <= n; i++) {\n\t\t\ts[i].scan();\n\t\t\tt[i].scan();\n\t\t}\n\t\tif(n <= 2) {\n\t\t\tprintf(\"Many\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i(1); i <= 3; i++) {\n\t\t\tl[i] = Line(s[i], t[i] - s[i]);\n\t\t}\n\t\tfor(int i(1); i <= 2; i++) {\n\t\t\tif(sign(l[i].d * l[i + 1].d) == 0) {\n\t\t\t\tl4[i][0] = l4[i][1] = Line(0.5 * (l[i].s + l[i + 1].s), l[i].d);\n\t\t\t}else {\n\t\t\t\tl4[i][0] = Line(intersection(l[i], l[i + 1]), 0.5 * (l[i].d.zoom(1) + l[i + 1].d.zoom(1)));\n\t\t\t\tl4[i][1] = Line(intersection(l[i], l[i + 1]), 0.5 * (l[i].d.zoom(-1) + l[i + 1].d.zoom(1)));\n\t\t\t}\n\t\t}\n\t\tset<Point> st;\n\t\tfor(int i(0); i < 2; i++) {\n\t\t\tfor(int j(0); j < 2; j++) {\n\t\t\t\tif(sign(l4[1][i].d * l4[2][j].d) != 0) {\n\t\t\t\t\tPoint p(intersection(l4[1][i], l4[2][j]));\n\t\t\t\t\tdouble d(dis(p, s[1], t[1]));\n\t\t\t\t\tbool flag(true);\n\t\t\t\t\tfor(int k(2); k <= n; k++) {\n\t\t\t\t\t\tdouble d1(dis(p, s[k], t[k]));\n\t\t\t\t\t\tif(!equal(d1, d)) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tst.insert(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(st.size() == 0) {\n\t\t\tprintf(\"None\\n\");\n\t\t}else if(st.size() >= 2) {\n\t\t\tprintf(\"Many\\n\");\n\t\t}else if(st.size() == 1) {\n\t\t\tst.begin()->print();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1){\n    REP(j,i+1,a.size()){\n//       cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n// \t   << a[j].fir <<\" \" << a[j].sec << endl;\n//       cout << j<<\" \"<< is_intersected_ll(\n// \t\t\t\t\t a[i].fir,a[i].sec,\n// \t\t\t\t\t a[j].fir,a[j].sec)<<\n// \t\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && abs(ans,cand)<1e-5)continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nstruct point {\n\tdouble x, y;\n\tvoid scan() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tpoint() {\n\t}\n\tpoint(const double & a, const double & b) : x(a), y(b) {\n\t}\n\tdouble sqrlen() const {\n\t\treturn x * x + y * y;\n\t}\n\tdouble len() const {\n\t\treturn sqrt(max(0., sqrlen()));\n\t}\n\tpoint zoom(const double & l) const {\n\t\tdouble lambda(l / len());\n\t\treturn point(lambda * x, lambda * y);\n\t}\n\tpoint rev() const {\n\t\treturn point(-y, x);\n\t}\n\tvoid print() const {\n\t\tprintf(\"%.10f %.10f\\n\", x, y);\n\t}\n};\ndouble sqr(double x) { return x * x; }\npoint operator + (const point& p1, const point& p2) { return point(p1.x + p2.x, p1.y + p2.y); }\npoint operator - (const point& p1, const point& p2) { return point(p1.x - p2.x, p1.y - p2.y); }\npoint operator * (const point& p1, double d) { return point(p1.x * d, p1.y * d); }\npoint operator / (const point& p1, double d) { return point(p1.x / d, p1.y / d); }\nint dcmp(double x) { return fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); }\ndouble det(point p1, point p2) { return p1.x * p2.y - p1.y * p2.x; }\ndouble dist(point p1, point p2) { return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y)); }\npoint nor(point p) { return p / sqrt(max(0., sqr(p.x) + sqr(p.y))); }\n\nstruct Line {\n\tpoint s, d;\n\tLine(const point & a, const point & b) : s(a), d(b) {\n\t}\n\tLine() {\n\t}\n} l[10001], p[10001][2];\n\nint n;\npoint a[10001], b[10001];\n\npoint inter(point p, point v, point q, point w) {\n\tpoint u = p - q;\n\tdouble t = det(w, u) / det(v, w);\n\treturn p + v * t;\n}\n\ndouble D(point p, point p1, point p2) {\n\treturn fabs(det(p - p1, p - p2)) / dist(p1, p2);\n}\nbool operator < (const point& p1, const point& p2) {\n\tif (dcmp(p1.x - p2.x)) return p1.x < p2.x;\n\tif (dcmp(p1.y - p2.y)) return p1.y < p2.y;\n\treturn false;\n}\n__inline double operator * (const point & a, const point & b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n__inline point intersection(const Line & a, const Line & b) {\n\tdouble lambda((b.s - a.s) * b.d / (a.d * b.d));\n\treturn a.s + a.d * lambda;\n}\n__inline bool equal(const double & a, const double & b) {\n\treturn dcmp(a - b) == 0;\n}\n\n__inline double dis(const point & a, const point & s, const point & t) {\n\tLine lp(a, (t - s).rev());\n\tpoint p(intersection(lp, Line(s, t - s)));\n\treturn (a - p).len();\n}\nint main( ) {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%lf %lf\", &a[i].x, &a[i].y);\n\t\t\tscanf(\"%lf %lf\", &b[i].x, &b[i].y);\n\t\t}\n\t\tif (n <= 2) { printf(\"Many\\n\"); continue; }\n\t\tfor(int i(1); i <= 3; i++) {\n\t\t\tl[i] = Line(a[i], b[i] - a[i]);\n\t\t}\n\t\tfor (int i = 1; i <= 2; i ++) {\n\t\t\tif (dcmp(l[i].d * l[i + 1].d) == 0) \n\t\t\t\tp[i][0] = p[i][1] = Line((l[i].s + l[i + 1].s) * 0.5, l[i].d);\n\t\t\telse {\n\t\t\t\tp[i][0] = Line(intersection(l[i], l[i + 1]), (l[i].d.zoom(1) + l[i + 1].d.zoom(1)) * 0.5);\n\t\t\t\tp[i][1] = Line(intersection(l[i], l[i + 1]), (l[i].d.zoom(-1) + l[i + 1].d.zoom(1)) * 0.5);\n\t\t\t}\n\t\t}\n\t\tset<point> S;\n\t\tfor (int i = 0; i < 2; i ++)\n\t\t\tfor (int j = 0; j < 2; j ++) {\n\t\t\t\tpoint x = p[1][i].d;\n\t\t\t\tpoint y = p[2][j].d;\n\n\t\t\t\tif (dcmp(det(x, y)) == 0) continue;\n\t\t\t\tpoint o = intersection(p[1][i], p[2][j]);\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 2; j <= n; ++ j)\n\t\t\t\t\tif (dcmp(dis(o, a[j], b[j]) - dis(o, a[1], b[1]))) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == false) S.insert(o);\n\t\t\t}\n\t\tif (S.size() == 0) printf(\"None\\n\");\n\t\telse if (S.size() > 1) printf(\"Many\\n\");\n\t\telse S.begin() -> print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-5;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        //        P q0=intersect(bc,ca);\n        //        P q1=intersect(ca,ab);\n        //        if( abs(target-q0) > eps )continue;\n        //        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-6;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    if(sign(cross(vec1, vec2)) == 0){\n        res.push_back(Line((l[0] + m[0]) / 2.0, (l[1] + m[1]) / 2.0));\n    }else{\n        Point p = crosspointLL(l, m);\n        res.push_back(Line(p, p + vec1 + vec2));\n        res.push_back(Line(p, p + vec1 - vec2));\n    }\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 1; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n            //if(paralell(lines[i], lines[j])) continue;\n        vector<Line> mids = get_midline(lines[0], lines[i]);\n        midlines.insert(midlines.end(), mids.begin(), mids.end());\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 1; k < lines.size(); k++){\n                if(sign(distanceLP(lines[k], p) - distanceLP(lines[k - 1], p)) != 0){\n                    ok = false;\n                    break;\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.9f %.9f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\nconst D eps=1e-6;\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nbool intersectLL(L l,L m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nint main(){\n  while(1){\n    int N;\n    vector<L> ls;\n    cin>>N;\n    if(N==0)break;\n    rep(i,N){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      ls.push_back(L(P(x1,y1),P(x2,y2)));\n    }\n    if(N<=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n    vector<P> candps;\n    {\n      vector<L> cls[3];\n      rep(i,3){\n        int j=(i+1)%3;\n        if(intersectLL(ls[i],ls[j])){\n          P cp=crosspoint(ls[i],ls[j]);\n          P v1=ls[i][1]-ls[i][0];\n          P v2=ls[j][1]-ls[j][0];\n          P v3=(abs(v2)*(abs(v1)+abs(v2)))*v1+(abs(v1)*(abs(v1)+abs(v2)))*v2;\n          cls[i].push_back(L(cp,cp+v3));\n          cls[i].push_back(L(cp,cp+P(-v3.Y,v3.X)));\n        }else{\n          P vv=P(ls[i][0].Y-ls[i][1].Y,ls[i][1].X-ls[i][0].X);\n          L vl=L(ls[i][0],ls[i][0]+vv);\n          P c1=crosspoint(vl,ls[i]); P c2=crosspoint(vl,ls[j]);\n          P mp=(c1+c2)/(long double)2.0;\n          cls[i].push_back(L(mp,mp+(ls[i][1]-ls[i][0])));\n        }\n      }\n      rep(a,cls[0].size())rep(b,cls[1].size())rep(c,cls[2].size()){\n        if(!intersectLL(cls[0][a],cls[1][b]))continue;\n        if(!intersectLL(cls[1][b],cls[2][c]))continue;\n        if(!intersectLL(cls[2][c],cls[0][a]))continue;\n        P p1=crosspoint(cls[0][a],cls[1][b]);\n        P p2=crosspoint(cls[1][b],cls[2][c]);\n        P p3=crosspoint(cls[2][c],cls[0][a]);\n        if(abs(p1-p2)<eps&&abs(p2-p3)<eps&&abs(p3-p1)<eps){\n          candps.push_back(p1);\n        }\n      }\n    }\n    vector<P> res;\n    rep(i,candps.size()){\n      vector<D> ds;\n      rep(j,N){\n        ds.push_back(distanceLP(ls[j],candps[i]));\n      }\n      bool ok=true;\n      rep(j,ds.size())rep(k,j){\n        if(abs(ds[j]-ds[k])>eps)ok=false;\n      }\n      if(ok)res.push_back(candps[i]);\n    }\n    if(res.size()==0)cout<<\"None\"<<endl;\n    else if(res.size()==1)printf(\"%.10Lf %.10Lf\\n\", res[0].X,res[0].Y);\n    else cout<<\"Many\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n\tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > 3e-5)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){x+=p.x,y+=p.y; return *this;}\n\tPoint& operator-=(Point p){x-=p.x,y-=p.y; return *this;}\n\tPoint& operator*=(double c){x*=c,y*=c; return *this;}\n\tPoint& operator/=(double c){x/=c,y/=c; return *this;}\n};\nPoint operator+(Point a,Point b){return a+=b;}\nPoint operator-(Point a,Point b){return a-=b;}\nPoint operator*(Point a,double c){return a*=c;}\nPoint operator*(double c,Point a){return a*=c;}\nPoint operator/(Point a,double c){return a/=c;}\nbool operator==(Point a,Point b){return abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n};\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (inclusive)\n}\n\nbool IntersectLL(Line a,Line b){\n\treturn abs(Cross(a.dir,b.dir))>EPS || abs(Cross(a.dir,b.pos-a.pos))<EPS;\n}\nbool IntersectLP(Line l,Point p){\n\treturn abs(CCW(l.pos,l.pos+l.dir,p))!=1;\n}\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS) return a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Line& l){\n\treturn os<<'('<<l.pos<<','<<l.dir<<')';\n}\n\nstring solve(vector<Line> ls)\n{\n\tint n=ls.size();\n\tif(n<=2) return \"Many\"; // trivial case\n\t\n\tvector<vector<Line>> els; // equidistant lines\n\trep(i,n) repi(j,i+1,n){\n\t\tLine a=ls[i],b=ls[j];\n\t\tif(IntersectLL(a,b)){\n\t\t\t// \"The lines do not coincide each other.\"なので直線は1点で交わる\n\t\t\tPoint p=InterPointLL(a,b);\n\t\t\ta.dir/=Abs(a.dir),b.dir/=Abs(b.dir);\n\t\t\tels.push_back({Line(p,(a.dir+b.dir)/2),Line(p,(a.dir-b.dir)/2)});\n\t\t}\n\t\telse{\n\t\t\tels.push_back({Line((a.pos+b.pos)/2,a.dir)});\n\t\t}\n\t}\n\t\n\t// 全直線が平行\n\tif(all_of(all(els),[](const vector<Line>& a){return a.size()==1;})){\n\t\trepi(i,1,els.size())\n\t\t\tif(!IntersectLL(els[0][0],els[i][0]))\n\t\t\t\treturn \"None\";\n\t\treturn \"Many\";\n\t}\n\t\n\tvector<Point> ps;\n\trep(i,3) repi(j,i+1,3) for(Line a:els[i]) for(Line b:els[j]){\n\t\tif(abs(Cross(a.dir,b.dir))>EPS)\n\t\t\tps.push_back(InterPointLL(a,b));\n\t}\n\tsort(all(ps),[](Point a,Point b){return abs(a.x-b.x)>EPS?a.x<b.x:a.y<b.y;});\n\tps.erase(unique(all(ps)),end(ps));\n\t\n\tvector<Point> res;\n\tfor(Point p:ps){\n\t\tbool on=true;\n\t\trep(i,els.size()){\n\t\t\tbool tmp=false;\n\t\t\tfor(Line l:els[i])\n\t\t\t\ttmp|=IntersectLP(l,p);\n\t\t\tif(!tmp){\n\t\t\t\ton=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(on) res.push_back(p);\n\t}\n\t\n\tif(res.size()==0) return \"None\";\n\tif(res.size()>=2) return \"Many\";\n\t\n\tchar tmp[100];\n\tsprintf(tmp,\"%f %f\",res[0].x,res[0].y);\n\treturn tmp;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<Line> ls(n);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;\n\t\t\tls[i]=Line(x1,y1,x2-x1,y2-y1);\n\t\t}\n\t\tcout<<solve(ls)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-9;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n<=2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==0){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n          B.emplace_back(a,a+v);\n        }\n        C.push_back(A.back().first);\n        C.push_back(A.back().second);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-7L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-9;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<eps;\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=abs(a[i].fir-tmp)<eps?a[i].sec:a[i].fir;\n\tP bt=abs(a[j].fir-tmp)<eps?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nvoid makecand(vector<Line> & a,vector<P> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec))\n\tb.pb(intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec));\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  vector<P> cand;\n  makeall(a,b);\n  makecand(b,cand);\n  P ans;\n  int cnt=0;\n  rep(i,cand.size()){\n    if (check(a,cand[i])){\n      ans=cand[i];\n      if(cnt != 0&&abs(ans-cand[i])<1e-05);\n      else cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    if (n == 1||n ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-3;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \n#define double long double\nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\t\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / (double)2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP pos = projection(ls[i],ls[j][0]);\n\t\t\t\t\t\tP vec = ls[j][0]-pos;\n\t\t\t\t\t\tln.push_back(L(pos,pos+vec/(double)2.));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > EPS )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10Lf %.10Lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  //rep(i,a.size()){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      //cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n      //<< a[j].fir <<\" \" << a[j].sec << endl;\n      //cout << j<<\" \"<< is_intersected_ll(\n      //a[i].fir,a[i].sec,\n      //a[j].fir,a[j].sec)<<\n      //\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      //cout << is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)<<endl;\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && abs(ans-cand)<1e-5)continue;\n\tif (false&&check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \nusing namespace std;\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n \ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n \nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n \nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n \nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n \nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n \nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n \nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n \nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n \nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n      ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n \nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n \ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n \ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n         min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n \n \npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n \n \ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n \nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n \npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n \nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n \nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n \ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n \n \nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n \nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n \nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n \nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n \nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1*1000/v1.abs();\n    v2=v2*1000/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n \nint main(){\n  int n;\n  while(cin>>n,n){\n    Line l[n];\n    for(int i=0;i<n;i++) cin>>l[i].p1>>l[i].p2;\n    if(n<=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n    Polygon ans;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n    for(int k=j+1;k<n;k++){\n      vector<Line> l1=corner(l[i],l[j]);\n      vector<Line> l2=corner(l[i],l[k]);\n      for(int a=0;a<(int)l1.size();a++){\n        for(int b=0;b<(int)l2.size();b++){\n          if(isParallel(l1[a],l2[b])) continue;\n          Point p=getCrossPointLL(l1[a],l2[b]);\n          bool f=1;\n          double d=getDistanceLP(l[0],p);\n          for(int c=1;c<n;c++) f&=equals(d,getDistanceLP(l[c],p));\n          if(f){\n        bool ff=0;\n        for(int c=0;c<(int)ans.size();c++){\n          ff|=ans[c]==p;\n        }\n        if(!ff) ans.push_back(p);\n        if(ans.size()>1) goto END;\n          }\n        }\n      }\n    }\n      }\n    }\n  END:\n     \n    if(ans.size()==0){\n      cout<<\"None\"<<endl;\n      continue;\n    }\n    if(ans.size()==1){\n      printf(\"%.6f %.6f\\n\",ans[0].x,ans[0].y);\n      continue;\n    }\n    if(ans.size()>=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-5;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 1; i < n; ++i){\n      point is;\n      if(intersectionLL( vl[0], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[0].fr) ){\n\t  va = uvec(vl[0].fr-is);\n\t}else{\n\t  va = uvec(vl[0].sc-is);\n\t}\n\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tbisector.push_back( line( is, is+va+vb ) );\n\tbisector.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[0].fr );\n\tpoint is;\n\tintersectionLL( line(vl[0].fr, vl[0].fr+unmr(vl[0].sc-vl[0].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[0].fr) + vl[0].fr;\n\tpoint csc = d * uvec(is-vl[0].fr) + vl[0].sc;\n\tbisector.push_back( line(cfr,csc) );\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = long double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/(ld)2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/(ld)2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/(ld)2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n<=2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    sort(ans.begin(),ans.end(),cmp);\n    ans.erase(unique(ans.begin(),ans.end(),eqq),ans.end());\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==0){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n\n  Point cp = crosspoint(line1,line2);\n  int res = ccw(cp,p1,p2);\n\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  double arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 20 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\nconst D eps=1e-8;\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nbool intersectLL(L l,L m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nint main(){\n  while(1){\n    int N;\n    vector<L> ls;\n    cin>>N;\n    if(N==0)break;\n    rep(i,N){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      ls.push_back(L(P(x1,y1),P(x2,y2)));\n    }\n    if(N<=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n    vector<P> candps;\n    {\n      vector<L> cls[3];\n      rep(i,3){\n        int j=(i+1)%3;\n        if(intersectLL(ls[i],ls[j])){\n          P cp=crosspoint(ls[i],ls[j]);\n          P v1=ls[i][1]-ls[i][0];\n          P v2=ls[j][1]-ls[j][0];\n          P v3=(abs(v2)*(abs(v1)+abs(v2)))*v1+(abs(v1)*(abs(v1)+abs(v2)))*v2;\n          cls[i].push_back(L(cp,cp+v3));\n          cls[i].push_back(L(cp,cp+P(-v3.Y,v3.X)));\n        }else{\n          P vv=P(ls[i][0].Y-ls[i][1].Y,ls[i][1].X-ls[i][0].X);\n          L vl=L(ls[i][0],ls[i][0]+vv);\n          P c1=crosspoint(vl,ls[i]); P c2=crosspoint(vl,ls[j]);\n          P mp=(c1+c2)/2.0;\n          cls[i].push_back(L(mp,mp+(ls[i][1]-ls[i][0])));\n        }\n      }\n      rep(a,cls[0].size())rep(b,cls[1].size())rep(c,cls[2].size()){\n        if(!intersectLL(cls[0][a],cls[1][b]))continue;\n        if(!intersectLL(cls[1][b],cls[2][c]))continue;\n        if(!intersectLL(cls[2][c],cls[0][a]))continue;\n        P p1=crosspoint(cls[0][a],cls[1][b]);\n        P p2=crosspoint(cls[1][b],cls[2][c]);\n        P p3=crosspoint(cls[2][c],cls[0][a]);\n        if(abs(p1-p2)<eps&&abs(p2-p3)<eps&&abs(p3-p1)<eps)candps.push_back(p1);\n      }\n    }\n    vector<P> res;\n    rep(i,candps.size()){\n      vector<D> ds;\n      rep(j,N){\n        ds.push_back(distanceLP(ls[j],candps[i]));\n      }\n      bool ok=true;\n      rep(j,ds.size())rep(k,j){\n        if(abs(ds[j]-ds[k])>eps)ok=false;\n      }\n      if(ok)res.push_back(candps[i]);\n    }\n    if(res.size()==0)cout<<\"None\"<<endl;\n    else if(res.size()==1)printf(\"%.10f %.10f\\n\", res[0].X,res[0].Y);\n    else cout<<\"Many\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  //rep(i,a.size()){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      //cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n      //<< a[j].fir <<\" \" << a[j].sec << endl;\n      //cout << j<<\" \"<< is_intersected_ll(\n      //a[i].fir,a[i].sec,\n      //a[j].fir,a[j].sec)<<\n      //\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      //cout << is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)<<endl;\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && abs(ans-cand)<1e-5)continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-12)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n, n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8f %.8f\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-12)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n, n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1) cout << fixed << ans[0].real() << \" \" << ans[0].imag() << endl;\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n      else cout << \"None\" << endl;\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-5;\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nbool lineCross(L l, L m){\n\treturn abs(imag((l.first-l.second)/(m.first-m.second)))<EPS;\n}\n\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.second-a.first, b.second-b.first);\n\tdouble B = cross(a.second-a.first, a.second-b.first);\n\treturn b.first + B/A*(b.second-b.first);\n}\n\nvector<L> distLine(L l, L m){\n\tvector<L> res;\n\tif(lineCross(l,m)){\n\t\tP a = (l.first+m.first)/2.0;\n\t\tP b = a+(l.second-l.first)/abs(l.second-l.first);\n\t\tres.push_back(make_pair(a,b));\n\t} else {\n\t\tP a = ssCrosspoint(l, m);\n\t\tif(abs(l.first-a)<EPS) swap(l.first, l.second);\n        P dirA = (l.first-a)/abs(l.first-a);\n\t\tif(abs(m.first-a)<EPS) swap(m.first, m.second);\n\t\tP dirB = (m.first-a)/abs(m.first-a);\n\t\tP b = a + (dirA+dirB)/abs(dirA+dirB);\n\t\tres.push_back(make_pair(a,b));\n\t\tres.push_back(make_pair(a,(b-a)*P(0,1)+a));\n\t}\n\treturn res;\n}\n\nbool onLine(L a, P p){\n\treturn abs(imag((p-a.first)/(a.second-a.first)))<EPS;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tif(n<3){ puts(\"Many\"); continue; }\n\t\tvector< pair<P, P> > vp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble a, b, c, d; cin >> a >> b >> c >> d;{\n\t\t\t\tvp.push_back(make_pair(P(a,b),P(c,d)));\n\t\t\t}\n\t\t}\n\t\tvector<P> vpt;\n\t\tvector<L> vlA = distLine(vp[0],vp[1]), vlB = distLine(vp[0], vp[2]);\n\t\tfor(int i=0;i<vlA.size();i++){\n\t\t\tfor(int j=0;j<vlB.size();j++){\n\t\t\t\tif(lineCross(vlA[i],vlB[j])) continue;\n\t\t\t\tvpt.push_back(ssCrosspoint(vlA[i],vlB[j]));\n\t\t\t}\n\t\t}\n\t\tif(!vpt.empty()){\n\t\t\tvector<P> tmp;\n\t\t\ttmp.push_back(vpt[0]);\n\t\t\tfor(int i=1;i<vpt.size();i++){\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\t\t\tif(abs(tmp[j]-vpt[i])<EPS) flag = true;\n\t\t\t\tif(!flag) tmp.push_back(vpt[i]);\n\t\t\t}\n\t\t\tvpt = tmp;\n\t\t}\n\t\tfor(int i=0;i<1;i++){\n\t\t\tfor(int j=3;j<n;j++){\n\t\t\t\tvector<P> nvp;\n\t\t\t\tfor(int k=0;k<vpt.size();k++){\n\t\t\t\t\tvector<L> vL = distLine(vp[i],vp[j]);\n\t\t\t\t\tbool flag = false;\n\t\t\t\t\tfor(int l=0;l<vL.size();l++){\n\t\t\t\t\t\tif(onLine(vL[l],vpt[k])){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) nvp.push_back(vpt[k]);\n\t\t\t\t}\n\t\t\t\tvpt = nvp;\n\t\t\t}\n\t\t}\n\t\tif(vpt.empty()) { puts(\"None\"); }\n\t\telse if(vpt.size()>1) { puts(\"Many\"); }\n\t\telse {\n\t\t\tprintf(\"%.5lf %.5lf\\n\", real(vpt[0]), imag(vpt[0]));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-3;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ){\n\t  va = uvec(vl[t].fr-is);\n\t}else{\n\t  va = uvec(vl[t].sc-is);\n\t}\n\t\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( (ccw(bisector1[i].fr,bisector1[i].sc,bisector2[j].fr) & (OVER|FRONT|BACK)) &&\n\t    (ccw(bisector1[i].fr,bisector1[i].sc,bisector2[j].sc) & (OVER|FRONT|BACK)) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      if(i==1)\n\tbreak;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a) - imag(b)) < EPS;\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\n\ndouble getDistanceSP(L s, P p){\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //テァツ崢エテァツキツ堙」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\n}\n// テッツシツ津ァツ崢エテァツキツ堙ゥツ鳴禿」ツ?ョテ、ツコツ、テァツつケ\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<L> getSS(L a,L b){\n  vector<L> ret;\n  if( a.first - a.second == b.first - b.second ){\n    ret.push_back( L( P((a.first - b.first)/2.0 + b.first), P((a.second - b.second)/2.0 + b.second) ) );\n    return ret;\n  } else if(  a.second - a.first == b.first - b.second ) {\n    ret.push_back( L( P((a.second - b.first)/2.0 + b.first), P((a.first - b.second)/2.0 + b.second) ) );\n    return ret;\n  }\n  P v = crossPoint(a,b);\n  P ma = a.first - v;\n  if( ma == P(0,0) ) ma = a.second - v;\n  P mb = b.first - v;\n  if( mb == P(0,0) ) mb = b.second - v;\n  ma = ma / abs(ma);\n  mb = mb / abs(mb);\n\n  //cout << v << \" \"<< ma << \" \"<< mb << endl;\n  \n  ret.push_back( L( v, v + ma + mb ) );\n  ma *= -1;\n  ret.push_back( L( v, v + ma + mb ) );\n}\n\nint N;\nint main(){\n  while( cin >> N && N ){\n    vector<L> s;\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      s.push_back( L( P(x1,y1), P(x2,y2) ) );      \n    }\n\n    if( N <= 2 ){\n      cout << \"Many\" << endl;\n    } else {\n      \n      vector<L> ss1,ss2; \n      ss1 = getSS(s[0],s[1]);\n      ss2 = getSS(s[0],s[2]);\n\n\n      vector<P> ans;\n      for(int i=0;i<(int)ss1.size();i++){\n        for(int j=0;j<(int)ss2.size();j++){\n          P p  = crossPoint(ss1[i],ss2[j]);\n          double d = getDistanceSP(s[0],p);\n          // cout << ss1[i].first << \" - \" << ss1[i].second << endl;\n          //cout << ss2[j].first << \" - \" << ss2[j].second << endl;\n          //cout << p << \" \" << d<< endl;\n          bool f = true;\n          for(int k=1;k<N;k++){\n            //cout << s[k].first << \" \"<< s[k].second << endl;\n            //cout << getDistanceSP(s[k],p) << endl;\n            if( fabs( d - getDistanceSP(s[k],p) ) < 1E-4 ) continue;\n            f = false;\n          }\n          if( f ) ans.push_back( p );\n        }        \n      }\n\n      sort(ans.begin(),ans.end());\n      ans.erase(unique(ans.begin(),ans.end()),ans.end());\n\n      if( ans.empty() ){\n        cout << \"None\" << endl;\n      } else if( ans.size() == 1 ){\n        printf(\"%.10lf %.10lf\\n\",ans[0].real(),ans[0].imag());\n      } else {\n        cout << \"Many\" << endl;\n      }\n      \n\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-5)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\n// ------------------\n\ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n\nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n\n  int res = ccw(cp,p1,p2);\n  //assert( ( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  //while( !( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n\nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n\n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n\n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n  }\n  \n  vector<Point> candidatePoints;\n\n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n\n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n\n\n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n\n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n\nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nD eps=1e-9;\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool eq(P a,P b){return abs(a-b)<eps;}\nint sig(D a){return eq(a,0)?0:(a>0?1:-1);}\nD cro(P a,P b){return imag(conj(a)*b);}\nD dot(P a,P b){return real(conj(a)*b);}\nP perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\nbool ispal(L a,L b){\n\treturn sig(cro(a.fs-a.sc,b.fs-b.sc))==0;\n}\nbool on(L l,P p){\n\treturn sig(cro(l.fs-l.sc,p-l.sc))==0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tvector<L> ls;\n\t\trep(i,N){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tls.pb(L(P(a,b),P(c,d)));\n\t\t}\n\t\tif(N<=2){\n\t\t\tputs(\"Many\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> vl;\n\t\tvector<P> vp;\n\t\trep(i,N) rep(j,i){\n\t\t\tvector<L> nvl;\n\t\t\tvector<P> nvp;\n\t\t\tL a=ls[i],b=ls[j];\n\t\t\tif(ispal(a,b)){\n\t\t\t\tP p=(perp(b,a.fs)+a.fs)/2.0,q=p+a.sc-a.fs;\n\t\t\t\tL l=L(p,q);\n\t\t\t\tif(i==1){\n\t\t\t\t\tvl.pb(l);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(L x:vl){\n\t\t\t\t\tif(ispal(l,x)){\n\t\t\t\t\t\tif(on(l,x.fs)) nvl.pb(x);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnvp.pb(intLL(x,l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(P x:vp){\n\t\t\t\t\tif(on(l,x)) nvp.pb(x);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tP p=intLL(a,b);\n\t\t\t\tif(eq(p,a.fs)) swap(a.fs,a.sc);\n\t\t\t\tif(eq(p,b.fs)) swap(b.fs,b.sc);\n\t\t\t\tP e=a.fs-p,f=b.fs-p;\n\t\t\t\te/=abs(e),f/=abs(f);//\n\t\t\t\tL l[2]={L(p,p+e+f),L(p,p-e+f)};\n\t\t\t\tif(i==1){\n\t\t\t\t\tvl.pb(l[0]),vl.pb(l[1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k,2){\n\t\t\t\t\tfor(L x:vl){\n\t\t\t\t\t\tif(ispal(l[k],x)){\n\t\t\t\t\t\t\tif(on(l[k],x.fs)) nvl.pb(x);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnvp.pb(intLL(x,l[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(P x:vp){\n\t\t\t\t\t\tif(on(l[k],x)) nvp.pb(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvl=nvl,vp=nvp;\n\t\t}\n\t\tif(!vl.empty()||vp.size()>1){\n\t\t\tputs(\"Many\");\n\t\t}else if(vp.size()==0){\n\t\t\tputs(\"None\");\n\t\t}else{\n\t\t\tprintf(\"%.12f %.12f\\n\",vp[0].real(),vp[0].imag());\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\nconst double mag = 1;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ) va = uvec(vl[t].fr-is);\n\telse va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) ) vb = uvec(vl[i].fr-is);\n\telse vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-3)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad テ」ツ?ッティツァツ津・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテヲツ個?」ツ?淌」ツ?崚」ツつ凝」ツ?禿」ツ?ィ\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// テ・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev テ」ツ?凝」ツつ?cur テ」ツ?クティツ。ツ古」ツ?」テ」ツ?ヲ next テ」ツ?クティツ。ツ古」ツ?湘ゥツ堋崚」ツ?ョティツァツ津・ツコツヲテ」ツつ津ヲツアツづ」ツつ?」ツつ?\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //テ・ツ青古」ツ?佚」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗」ツ?凝」ツつづ」ツつ?\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\n// ------------------\n\ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n\nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n\n  int res = ccw(cp,p1,p2);\n  assert( res == CLOCKWISE || res == COUNTER_CLOCKWISE );\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n\nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n\n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n\n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n  }\n  \n  vector<Point> candidatePoints;\n\n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n\n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n\n\n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n\n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n\nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<random>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nmt19937 engine;\nint n;\nint x1[123],y_1[123],x2[123],y2[123];\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dist(P p,int idx){\n  P a=P(x1[idx],y_1[idx]);\n  P vb=P(x2[idx],y2[idx])-a;\n  return fabs(cross(p-a,vb)/abs(vb));\n}\n\ndouble ddiff(P p){\n  double mxd=-1,mnd=1e9;\n  for(int i=0;i<n;i++){\n    double d=dist(p,i);\n    mxd=max(mxd,d);\n    mnd=min(mnd,d);\n  }\n  return mxd-mnd;\n}\n\nbool par(int a,int b){\n  return fabs(dist(P(x1[a],y_1[a]),b)-dist(P(x2[a],y2[a]),b))<1e-9;\n}\n\nint main(){\n  for(;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x1[i]>>y_1[i]>>x2[i]>>y2[i];\n    }\n    if(n<=2){\n      cout<<\"Many\"<<endl;\n    }else if(n==3){\n      if(par(0,1)&&par(1,2)){\n\tcout<<\"None\"<<endl;\n      }else{\n\tcout<<\"Many\"<<endl;\n      }\n    }else{\n      P p=P(0,0);\n      double r=1e9;\n      for(int j=0;j<10;j++){\n\tfor(int i=0;i<10000;i++,r*=.99){\n\t  P np=p+polar(r,uniform_real_distribution<double>(0,9)(engine));\n\t  if(ddiff(np)<ddiff(p)){\n\t    p=np;\n\t  }\n\t}\n      }\n      if(ddiff(p)<1e-5){\n\tcout<<fixed<<p.real()<<' '<<p.imag()<<endl;\n      }else{\n\tcout<<\"None\"<<endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-5)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    cout << \"None\" << endl;\n    continue;\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n//#define EPS 0.000000001\nusing namespace std;\n\n\n#define EPS 0.000001\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\nstruct Line{\n\tPoint p[2];\n\tLine(Point p1,Point p2){\n\t\tp[0] = p1;\n\t\tp[1] = p2;\n\t}\n\tLine(){\n\n\t}\n};\n\ntypedef Point Vector;\n\nint N;\nPoint point[3];\nvector<Line> LINE;\ndouble slope[3];\n\n\n\n//交点を求める関数\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPoint calc_Cross_Point(Line A,Line B){\n\n\treturn calc_Cross_Point(A.p[0],A.p[1],B.p[0],B.p[1]);\n}\n\ndouble calc_slope(Line A){\n\n\tif(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n\t\treturn DBL_MAX;\n\n\t}else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n\t\treturn 0;\n\n\t}else{\n\n\t\treturn (A.p[0].y-A.p[1].y)/(A.p[0].x-A.p[1].x);\n\t}\n}\n\n//★★直線の交差判定★★\nbool is_Cross(Line A,Line B){\n\n\treturn fabs(calc_slope(A)-calc_slope(B)) > EPS;\n}\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble calc_dist1(Line line,Point point){\n    return abs(cross(line.p[1]-line.p[0],point-line.p[0]))/abs(line.p[1]-line.p[0]);\n}\n\nvector<Line> calc_Equal_Line(Line A,Line B){\n\n\tvector<Line> ret;\n\n\tif(is_Cross(A,B)){\n\n\t\tPoint cross_point = calc_Cross_Point(A,B);\n\n\t\tVector dir_A = A.p[1]-A.p[0];\n\t\tVector dir_B = B.p[1]-B.p[0];\n\n\t\tdir_A = dir_A/abs(dir_A);\n\t\tdir_B = dir_B/abs(dir_B);\n\n\t\tret.push_back(Line(cross_point,cross_point+dir_A+dir_B));\n\t\tret.push_back(Line(cross_point,cross_point+dir_A-dir_B));\n\n\t}else{\n\n\t\tret.push_back(Line((A.p[0]+B.p[0])/2,(A.p[0]+B.p[0])/2+(A.p[1]-A.p[0])));\n\t}\n\n\treturn ret;\n}\n\n\nvoid func(){\n\n\tLINE.clear();\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tPoint A,B;\n\n\t\tscanf(\"%lf %lf %lf %lf\",&A.x,&A.y,&B.x,&B.y);\n\n\t\tif(A.x > B.x){\n\n\t\t\tswap(A,B);\n\t\t}\n\t\tLINE.push_back(Line(A,B));\n\t}\n\n\tif(N <= 2){\n\n\t\tprintf(\"Many\\n\");\n\t\treturn;\n\t}\n\n\tvector<Line> LINE_01 = calc_Equal_Line(LINE[0],LINE[1]);\n\tvector<Line> LINE_02 = calc_Equal_Line(LINE[0],LINE[2]);\n\n\tvector<Point> CANDIDATE,ANS;\n\n\tfor(int i = 0; i < LINE_01.size(); i++){\n\t\tfor(int k = 0; k < LINE_02.size(); k++){\n\n\t\t\tif(!is_Cross(LINE_01[i],LINE_02[k]))continue;\n\n\t\t\tCANDIDATE.push_back(calc_Cross_Point(LINE_01[i],LINE_02[k]));\n\t\t}\n\t}\n\n\tsort(CANDIDATE.begin(),CANDIDATE.end());\n\tCANDIDATE.erase(unique(CANDIDATE.begin(),CANDIDATE.end()),CANDIDATE.end());\n\n\tint count = 0;\n\n\tfor(int i = 0; i < CANDIDATE.size(); i++){\n\n\t\tdouble base_dist =  calc_dist1(LINE[0],CANDIDATE[i]);\n\n\t\tbool FLG = true;\n\n\t\tfor(int k = 1; k < N; k++){\n\n\t\t\tif(fabs(base_dist-calc_dist1(LINE[k],CANDIDATE[i])) > EPS){\n\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tif(FLG){\n\t\t\tcount++;\n\t\t\tANS.push_back(CANDIDATE[i]);\n\t\t}\n\t}\n\n\tif(count == 0){\n\n\t\tprintf(\"None\\n\");\n\t}else if(count >= 2){\n\n\t\tprintf(\"Many\\n\");\n\n\t}else{\n\n\t\tprintf(\"%.10lf %.10lf\\n\",ANS[0].x,ANS[0].y);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn (l.first-x).cross(l.second-x) == 0;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\ttmp.push_back(make_pair((p[i]+p[j])*0.5, (q[i]+q[j])*0.5));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\telse if(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec = npvec;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec = npvec;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\nbool EQ(double a,double b){\n\treturn fabs(a) < EPS;\n}\nbool GE(double a,double b){\n\treturn a > b - EPS;\n}\nbool LE(double a,double b){\n\treturn a < b + EPS;\n}\n\nint convex_contains(const polygon &P, const point &p) {\n  const int n = P.size();\n  point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n      if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n      else                                                  a = c;\n    } else {\n      if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nbool intersect_1pt(const point& a, const point& b,\n                   const point& c, const point& d, point &r) {\n  double D =  cross(b - a, d - c);\n  if (EQ(D, 0)) return false;\n  double t =  cross(c - a, d - c) / D;\n  double s = -cross(a - c, b - a) / D;\n  r = a + t * (b - a);\n  return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n}\npolygon convex_intersect(const polygon &P, const polygon &Q) {\n  const int n = P.size(), m = Q.size();\n  int a = 0, b = 0, aa = 0, ba = 0;\n  enum { Pin, Qin, Unknown } in = Unknown;\n  polygon R;\n  do {\n    int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n    double C = cross(P[a] - P[a1], Q[b] - Q[b1]);\n    double A = cross(P[a1] - Q[b], P[a] - Q[b]);\n    double B = cross(Q[b1] - P[a], Q[b] - P[a]);\n    point r;\n    if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n      if (in == Unknown) aa = ba = 0;\n      R.push_back( r );\n      in = B > 0 ? Pin : A > 0 ? Qin : in;\n    }\n    if (C == 0 && B == 0 && A == 0) {\n      if (in == Pin) { b = (b + 1) % m; ++ba; }\n      else           { a = (a + 1) % m; ++aa; }\n    } else if (C >= 0) {\n      if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n      else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n    } else {\n      if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n      else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n    }\n  } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n  if (in == Unknown) {\n    if (convex_contains(Q, P[0])) return P;\n    if (convex_contains(P, Q[0])) return Q;\n  }\n  return R;\n}\n\n\nvector<L> ls;\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\ndouble PI = acos(-1);\n \n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nG gen(L l,double d){\n\tP f = l[1]-l[0];\n\tf /= abs(f);\n\tP r = f * exp(P(0,PI/2.));\n\tP a = l[0] + r * d;\n\tP b = l[0] - r * d;\n\t\n\tdouble len = 100000;\n\tG g;\n\tg.push_back(a+f*len);\n\tg.push_back(a-f*len);\n\tg.push_back(b+f*len);\n\tg.push_back(b-f*len);\n\t\n\treturn convex_hull(g);\n}\ndouble ok(double d,int f=0){\n\tvector<P> co;\n\t\n\tfor(int i = 0 ; i < ls.size() ; i++){\n\t\tauto v = gen(ls[i],d);\n\t\tif(i==0){\n\t\t\tco = v;\n\t\t}else{\n\t\t\tif( area2(co) < EPS ) co.clear();\n\t\t\tif( co.size() ) co = convex_intersect(co,v);\n\t\t}\n\t}\n\tif(f){\n\t\tprintf(\"%.10lf %.10lf\\n\",co[0].real(),co[0].imag());\n\t}\n\treturn area2(co);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble l = 0, r = 100000;\n\t\t\tif( ok(r) < EPS ){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\t\tdouble m = (l+r)/2.;\n\t\t\t\tif( ok(m) > EPS ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tok(l,1);\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn (l.first-x).cross(l.second-x) == 0;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\ttmp.push_back(make_pair((p[i]+p[j])*0.5, (q[i]+q[j])*0.5));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\tif(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec = npvec;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec = npvec;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-12)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n, n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8f %.8f\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      if (n <= 2) cout << \"Many\" << endl;\n      else cout << \"None\" << endl;\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Line l[n];\n    for(int i=0;i<n;i++) cin>>l[i].p1>>l[i].p2;\n    if(n<=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n    Polygon ans;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tfor(int k=j+1;k<n;k++){\n\t  vector<Line> l1=corner(l[i],l[j]);\n\t  vector<Line> l2=corner(l[i],l[k]);\n\t  for(int a=0;a<(int)l1.size();a++){\n\t    for(int b=0;b<(int)l2.size();b++){\n\t      if(isParallel(l1[a],l2[b])) continue;\n\t      Point p=getCrossPointLL(l1[a],l2[b]);\n\t      bool f=1;\n\t      double d=getDistanceLP(l[0],p);\n\t      for(int c=1;c<n;c++) f&=equals(d,getDistanceLP(l[c],p));\n\t      if(f){\n\t\tbool ff=0;\n\t\tfor(int c=0;c<(int)ans.size();c++){\n\t\t  ff|=ans[c]==p;\n\t\t}\n\t\tif(!ff) ans.push_back(p);\n\t\tif(ans.size()>1) goto END;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  END:\n    \n    if(ans.size()==0){\n      cout<<\"None\"<<endl;\n      continue;\n    }\n    if(ans.size()==1){\n      printf(\"%.6f %.6f\\n\",ans[0].x,ans[0].y);\n      continue;\n    }\n    if(ans.size()==2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\nusing namespace std;\nconst long double EPS = 1e-6;\nconst long double INF = 1e+10;\nconst long double PI = acos(-1);\nint sig(long double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline long double ABS(long double a){return max(a,-a);}\nstruct Pt {\n\tlong double x, y;\n\tPt() {}\n\tPt(long double x, long double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const long double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const long double &k) const { return Pt(x / k, y / k); }\n\tlong double ABS() const { return sqrt(x * x + y * y); }\n\tlong double abs2() const { return x * x + y * y; }\n\tlong double arg() const { return atan2(y, x); }\n\tlong double dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tlong double det(const Pt &a) const { return x * a.y - y * a.x; }\n};\nlong double tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\nlong double dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\n\nPt p1[110];\nPt p2[110];\nlong double rd[100];\nlong double ld[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tlong double X1,X2,Y1,Y2;\n\t\t\tscanf(\"%Lf%Lf%Lf%Lf\",&X1,&Y1,&X2,&Y2);\n\t\t\tp1[i]=Pt(X1,Y1);\n\t\t\tp2[i]=Pt(X2,Y2);\n\t\t}\n\t\tif(a<=2){\n\t\t\tprintf(\"Many\\n\");continue;\n\t\t}\n\t\tif(iLL(p1[0],p2[0],p1[1],p2[1])==0&&iLL(p1[1],p2[1],p1[2],p2[2])==0){\n\t\t\tprintf(\"None\\n\");continue;\n\t\t}\n\t\tvector<pair<Pt,Pt> >L1;\n\t\tvector<pair<Pt,Pt> >L2;\n\t\tif(iLL(p1[0],p2[0],p1[1],p2[1])==0){\n\t\t\tPt L=(p1[0]+p1[1])/2;\n\t\t\tPt R=(p2[0]+p2[1])/2;\n\t\t\tif((L-R).ABS()<EPS){\n\t\t\t\tL=(p1[0]+p2[1])/2;\n\t\t\t\tR=(p2[0]+p1[1])/2;\n\t\t\t}\n\t\t\tL1.push_back(make_pair(L,R));\n\t\t}else{\n\t\t\tPt p=pLL(p1[0],p2[0],p1[1],p2[1]);\n\t\t\tlong double th=((p2[0]-p).arg()+(p2[1]-p).arg())/2;\n\t\t\tL1.push_back(make_pair(p,p+Pt(cos(th),sin(th))*1000.0));\n\t\t\tL1.push_back(make_pair(p,p+Pt(-sin(th),cos(th))*1000.0));\n\t\t}\n\t\tif(iLL(p1[2],p2[2],p1[1],p2[1])==0){\n\t\t\tPt L=(p1[2]+p1[1])/2;\n\t\t\tPt R=(p2[2]+p2[1])/2;\n\t\t\tif((L-R).ABS()<EPS){\n\t\t\t\tL=(p1[2]+p2[1])/2;\n\t\t\t\tR=(p2[2]+p1[1])/2;\n\t\t\t}\n\t\t\tL2.push_back(make_pair(L,R));\n\t\t}else{\n\t\t\tPt p=pLL(p1[2],p2[2],p1[1],p2[1]);\n\t\t\tlong double th=((p2[2]-p).arg()+(p2[1]-p).arg())/2;\n\t\t\tL2.push_back(make_pair(p,p+Pt(cos(th),sin(th))*1000.0));\n\t\t\tL2.push_back(make_pair(p,p+Pt(-sin(th),cos(th))*1000.0));\n\t\t}\n\t\tvector<Pt>hb;\n\t\tfor(int i=0;i<L1.size();i++)for(int j=0;j<L2.size();j++){\n\t\t\thb.push_back(pLL(L1[i].first,L1[i].second,L2[j].first,L2[j].second));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<hb.size();i++){\n\t\t//\tprintf(\"%Lf %Lf: \",hb[i].x,hb[i].y);\n\t\t\tbool dame=false;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif((hb[i]-hb[j]).ABS()<EPS){\n\t\t\t\t\tdame=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dame){\n\t\t\t\trd[i]=1;ld[i]=0;continue;\n\t\t\t}\n\t\t\trd[i]=-999999999;ld[i]=999999999;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlong double dist=dLP(p1[j],p2[j],hb[i]);\n\t\t\t\trd[i]=max(rd[i],dist);\n\t\t\t\tld[i]=min(ld[i],dist);\n\t\t\t//\tprintf(\"%Lf \",dist);\n\t\t\t}//printf(\"\\n\");\n\t\t\tif(rd[i]-ld[i]<EPS)ans++;\n\t\t}\n\t\tif(ans>1)printf(\"Many\\n\");\n\t\telse if(ans==0)printf(\"None\\n\");\n\t\telse{\n\t\t\tfor(int i=0;i<hb.size();i++){\n\t\t\t\tif(rd[i]-ld[i]<EPS)printf(\"%Lf %Lf\\n\",hb[i].x,hb[i].y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a) - imag(b)) < EPS;\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\n\ndouble getDistanceSP(L s, P p){\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //テァツ崢エテァツキツ堙」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\n}\n// テッツシツ津ァツ崢エテァツキツ堙ゥツ鳴禿」ツ?ョテ、ツコツ、テァツつケ\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nbool ispara(L a,L b){\n  P v1 = a.first - a.second;\n  v1 /= abs(v1);\n  P v2 = b.first - b.second;\n  v2 /= abs(v2);\n  if( v1 == v2 || -v1 == v2 ) return true;\n  return false;\n}\n\nvector<L> getSS(L a,L b){\n  vector<L> ret;\n  if( ispara(a,b) ) {\n    P vec = a.first - a.second;\n    P nv = P(vec.imag()*1,vec.real()*-1);\n    P ps = crossPoint( L(a.first, a.first + nv) , b );\n    L r = L(  a.first + (ps - a.first) / 2.0 ,\n              a.second + (ps - a.first) / 2.0 );\n    ret.push_back( r );\n    return ret;\n  }\n  P v = crossPoint(a,b);\n  P ma = a.first - v;\n  if( ma == P(0,0) ) ma = a.second - v;\n  P mb = b.first - v;\n  if( mb == P(0,0) ) mb = b.second - v;\n  ma = ma / abs(ma);\n  mb = mb / abs(mb);\n\n  //cout << v << \" \"<< ma << \" \"<< mb << endl;\n  \n  ret.push_back( L( v, v + ma + mb ) );\n  ma *= -1;\n  ret.push_back( L( v, v + ma + mb ) );\n}\n\nint N;\nint main(){\n  while( cin >> N && N ){\n    vector<L> s;\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      s.push_back( L( P(x1,y1), P(x2,y2) ) );      \n    }\n\n    if( N <= 2 ){\n      cout << \"Many\" << endl;\n    } else {\n      \n      vector<L> ss1,ss2; \n      ss1 = getSS(s[0],s[1]);\n      ss2 = getSS(s[0],s[2]);\n\n\n      vector<P> ans;\n      for(int i=0;i<(int)ss1.size();i++){\n        for(int j=0;j<(int)ss2.size();j++){\n          P p  = crossPoint(ss1[i],ss2[j]);\n          double d = getDistanceSP(s[0],p);\n          //cout << ss1[i].first << \" - \" << ss1[i].second << endl;\n          //cout << ss2[j].first << \" - \" << ss2[j].second << endl;\n          //cout << p << \" \" << d<< endl;\n          bool f = true;\n          for(int k=1;k<N;k++){\n            //cout << s[k].first << \" \"<< s[k].second << endl;\n            //cout << getDistanceSP(s[k],p) << endl;\n            if( fabs( d - getDistanceSP(s[k],p) ) < 1E-4 ) continue;\n            f = false;\n          }\n          if( f ) ans.push_back( p );\n        }        \n      }\n\n      sort(ans.begin(),ans.end());\n      ans.erase(unique(ans.begin(),ans.end()),ans.end());\n\n      if( ans.empty() ){\n        cout << \"None\" << endl;\n      } else if( ans.size() == 1 ){\n        printf(\"%.10lf %.10lf\\n\",ans[0].real(),ans[0].imag());\n      } else {\n        cout << \"Many\" << endl;\n      }\n      \n\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > 3e-5)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\t\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP pos = projection(ls[i],ls[j][0]);\n\t\t\t\t\t\tP vec = ls[j][0]-pos;\n\t\t\t\t\t\tln.push_back(L(pos,pos+vec/2.));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > EPS )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << cp << endl;\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define double long double\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-10;\nconst double eps = 1e-10;\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\nbool eq(double a,double b){return abs(a-b)<eps;}\nbool eq(P a,P b){return eq(a.real(),b.real())&&eq(a.imag(),b.imag());}\ndouble getDistanceLP(L s, P p){\n \n  assert( !eq( s.first, s.second) );\n \n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\nbool isParalell(L a,L b){return  eq(0,cross(a.second-a.first,b.second-b.first));}\n \nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n \nvector<L> A;\nbool check(P a){\n  double dis = getDistanceLP(A[0],a);\n \n  for(int i=0;i<(int)A.size();i++)\n    if(!eq(dis,getDistanceLP(A[i],a))) return 0;\n \n  return  1;\n}\n \nL calc(P o,P a,P b){\n  a-=o,b-=o;\n  return L(o,(a/abs(a) + b/abs(b)) + o);\n}\n \nint main(){\n  int n;\n  while(cin>>n,n){\n    A.resize(n);\n    for(int i=0,x1,y1,x2,y2;i<n;i++){\n      cin>>x1>>y1>>x2>>y2;\n      A[i] = L(P(x1,y1),P(x2,y2));\n    }\n \n \n    if(n<=2){cout<<\"Many\"<<endl;continue;}\n     \n    vector<L> B; \n    for(int i=0;i<n;i++)\n      for(int j=0;j<i;j++){\n    L a = A[i], b = A[j];\n \n    if(isParalell(a,b)||B.size()>100)continue;\n \n    P o = crossPoint(a,b);\n    P va=a.second-a.first;\n    P vb=b.second-b.first;\n    va /= abs(va);\n    vb /= abs(vb);\n \n    B.push_back( L( o , o+va+vb) );\n    B.push_back( L( o , o+va-vb ) );\n \n      }\n \n    vector<P> ans;\n    for(int i=0;i<(int)B.size();i++)\n      for(int j=i+1;j<(int)B.size();j++){\n    L a = B[i], b = B[j];\n    if(isParalell(a,b)) continue;\n    P c = crossPoint(a,b);\n    if(check(c)&&(ans.empty()||!eq(ans[0],c))) ans.push_back(c);\n \n      }\n     \n    if(ans.size()>=2) cout<<\"Many\"<<endl;\n    else if(ans.empty()) cout<<\"None\"<<endl;\n    else printf(\"%Lf %Lf\\n\",ans[0].real(),ans[0].imag());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-4)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n   \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n   \nusing namespace std;\n   \nclass Point{\npublic:\n  double x,y;\n   \n  Point(double x = 0,double y = 0): x(x),y(y){}\n   \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n   \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n   \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n   \n};\n   \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n   \n};\n   \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n   \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n   \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n   \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n   \ndouble abs(Point a){ return sqrt(norm(a)); }\n   \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n   \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n   \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n   \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n   \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n   \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n   \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n   \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n   \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n   \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n     \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n     \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n    \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n   \n// ------------------\n   \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n \n  Point cp = crosspoint(line1,line2);\n  int res = ccw(cp,p1,p2);\n \n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  double arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n \n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n   \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n   \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n   \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 4 ) break;\n  }\n     \n  vector<Point> candidatePoints;\n   \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n   \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n   \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n   \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n   \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a) - imag(b)) < EPS;\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //テァツ崢エテァツキツ堙」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\n}\n// テッツシツ津ァツ崢エテァツキツ堙ゥツ鳴禿」ツ?ョテ、ツコツ、テァツつケ\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<L> getSS(L a,L b){\n  vector<L> ret;\n  if( a.first - a.second == b.first - b.second ){\n    ret.push_back( L( P((a.first - b.first)/2.0 + b.first), P((a.second - b.second)/2.0 + b.second) ) );\n    return ret;\n  } else if(  a.second - a.first == b.first - b.second ) {\n    ret.push_back( L( P((a.second - b.first)/2.0 + b.first), P((a.first - b.second)/2.0 + b.second) ) );\n    return ret;\n  }\n  P v = crossPoint(a,b);\n  P ma = a.first - v;\n  if( ma == P(0,0) ) ma = a.second - v;\n  P mb = b.first - v;\n  if( mb == P(0,0) ) mb = b.second - v;\n  ma = ma / abs(ma);\n  mb = mb / abs(mb);\n  \n  ret.push_back( L( v, v + ma + mb ) );\n  ma *= -1;\n  ret.push_back( L( v, v + ma + mb ) );\n}\n\nint N;\nint main(){\n  while( cin >> N && N ){\n    vector<L> s;\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      s.push_back( L( P(x1,y1), P(x2,y2) ) );      \n    }\n\n    if( N <= 2 ){\n      cout << \"Many\" << endl;\n    } else {\n      \n      vector<L> ss1,ss2; \n      ss1 = getSS(s[0],s[1]);\n      ss2 = getSS(s[0],s[2]);\n\n\n      vector<P> ans;\n      for(int i=0;i<(int)ss1.size();i++){\n        for(int j=0;j<(int)ss2.size();j++){\n          P p  = crossPoint(ss1[i],ss2[j]);\n          double d = getDistanceSP(s[0],p);\n          bool f = true;\n          for(int k=1;k<N;k++){\n            if( d == getDistanceSP(s[k],p) ) continue;\n            f = false;\n          }\n          if( f ) ans.push_back( p );\n        }        \n      }\n\n      sort(ans.begin(),ans.end());\n      ans.erase(unique(ans.begin(),ans.end()),ans.end());\n\n      if( ans.empty() ){\n        cout << \"None\" << endl;\n      } else if( ans.size() == 1 ){\n        printf(\"%.10lf %.10lf\\n\",ans[0].real(),ans[0].imag());\n      } else {\n        cout << \"Many\" << endl;\n      }\n      \n\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn fabs((l.first-x).cross(l.second-x)) < eps;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\ttmp.push_back(make_pair((p[i]+p[j])*0.5, (q[i]+q[j])*0.5));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\telse if(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec.clear();\n\t\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec.clear();\n\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <assert.h>\n#include <string.h>\n\nusing namespace std;\n\ntypedef complex<double> Complex;\ntypedef Complex P;\n\nstatic const double EPS = 1e-6;\ninline bool EQ(double a, double b) { return abs(a - b) < EPS; }\ninline bool EQP(Complex a, Complex b) { return norm(a - b) < EPS; }\n\nstruct Seg;\nstruct Line;\nstruct Circle;\n\ndouble X(P p) { return p.real(); }\ndouble Y(P p) { return p.imag(); }\ndouble dot(P a, P b) { return X(conj(a) * b); }\ndouble cross(P a, P b) { return Y(conj(a) * b); }\ndouble ccw(P p1, P p2, P p3) { return cross(p2 - p1, p3 - p1); }\nP proj(P p, P q) { return q * dot(p, q) / norm(q); }\nP rot(P p) { return p * P(0, 1); }\n\n\nstruct Line {\n  P p, v;\n  double distance(P q) {\n    return abs(cross(v, q - p)) / abs(v);\n  }\n  bool is_contain(P q) {\n    return EQ(cross(v, q - p), 0.0);\n  }\n  bool is_parallel(Line rhs) {\n    return EQ(cross(v, rhs.v), 0.0);\n  }\n  P intersection(Line rhs) {\n    assert(!is_parallel(rhs));\n    return p + v * cross(rhs.v, rhs.p - p) / cross(rhs.v, v);\n  }\n};\n\n\nstruct Triangle {\n  P p1, p2, p3;\n  Triangle(P p1, P p2, P p3) : p1(p1), p2(p2), p3(p3) {;}\n  P incenter() {\n    double le1 = abs(p2 - p3), le2 = abs(p3 - p1), le3 = abs(p1 - p2);\n    return (p1 * le1 + p2 * le2 + p3 * le3) / (le1 + le2 + le3);\n  }\n\n  vector<P> excenter() {\n    vector<P> ret;\n    double le1 = abs(p2 - p3), le2 = abs(p3 - p1), le3 = abs(p1 - p2);\n    ret.push_back((-p1 * le1 + p2 * le2 + p3 * le3) / (-le1 + le2 + le3));\n    ret.push_back(( p1 * le1 - p2 * le2 + p3 * le3) / ( le1 - le2 + le3));\n    ret.push_back(( p1 * le1 + p2 * le2 - p3 * le3) / ( le1 + le2 - le3));\n    return ret;\n  }\n};\n\nLine line[300];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n  if (n < 3) {\n    puts(\"Many\");\ncontinue;\n  }\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    line[i].p = Complex(x1, y1);\n    line[i].v = Complex(x2 - x1, y2 - y1);\n    line[i].v /= abs(line[i].v);\n  }\n  if (line[0].is_parallel(line[1]) && line[0].is_parallel(line[2])) {\n    puts(\"None\");\n    return 0;\n  }\n  vector<P> point;\n  vector<double> dist;\n  bool fail[4];\n  memset(fail, false, sizeof(fail));\n  if (line[0].is_parallel(line[1]) || line[0].is_parallel(line[2]) || line[1].is_parallel(line[2])) {\n    if (line[0].is_parallel(line[1])) {\n    } else if (line[0].is_parallel(line[2])) {\n      swap(line[1], line[2]);\n    } else if (line[2].is_parallel(line[2])) {\n      swap(line[0], line[2]);\n    }\n    P p1 = line[2].intersection(line[0]);\n    P p2 = line[2].intersection(line[1]);\n    P c = (p1 + p2) / 2.0;\n    point.push_back(c + line[0].v * abs(p1 - c));\n    point.push_back(c - line[0].v * abs(p1 - c));\n    dist.push_back(line[0].distance(point[0]));\n    dist.push_back(line[0].distance(point[1]));\n  } else {\n    P p1 = line[0].intersection(line[1]);\n    P p2 = line[1].intersection(line[2]);\n    P p3 = line[2].intersection(line[0]);\n    if (EQP(p1, p2) && EQP(p1, p3)) {\n      point.push_back(p1);\n      dist.push_back(0.0);\n    } else {\n      Triangle tri(p1, p2, p3);\n      point = tri.excenter();\n      point.push_back(tri.incenter());\n      dist.push_back(line[0].distance(point[0]));\n      dist.push_back(line[0].distance(point[1]));\n      dist.push_back(line[0].distance(point[2]));\n      dist.push_back(line[0].distance(point[3]));\n    }\n  }\n  int rest = (int)point.size();\n  for (int i = 3; i < n; i++) {\n    for (int j = 0; j < (int)point.size(); j++) {\n      if (fail[j]) { continue; }\n      double d = line[i].distance(point[j]);\n      if (!EQ(d, dist[j])) {\n        fail[j] = true;\n        rest--;\n      }\n    }\n  }\n  P ans;\n  for (int i = 0; i < (int)point.size(); i++) {\n    if (!fail[i]) {\n      ans = point[i];\n    }\n  }\n  if (rest == 0) {\n    puts(\"None\");\n  } else if (rest > 1) {\n    puts(\"Many\");\n  } else {\n    printf(\"%.4lf %.4lf\\n\", ans.real(), ans.imag());\n  }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return P(rand(), rand()); // same line\n  if (abs(A) < EPS) return P(rand(), rand());// !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\nP incenter(const P &x, const P &y, const P &z){\n\tP a = y - x, b = z - x;\n\tP d1 = a / abs(a) + b / abs(b);\n\tP d2 = -a / abs(a) + (b - a) / abs(b - a);\n\treturn crosspoint(L(P(0, 0), d1), L(a, a + d2)) + x;\n}\nG excenter(const G &t){\n\tG res;\n\trep(i, 3){\n\t\tP a = t[i], b = t[(i + 1) % 3], c = t[(i + 2) % 3];\n\t\tres.pb(crosspoint(L(a, a + (a - c) / abs(a - c) + (b - a) / abs(b - a)),\n\t\tL(b, b + (b - c) / abs(b - c) + (a - b) / abs(a - b))));\n\t}\n\treturn res;\n}\nbool parallel(const L &l, const L &m){\n\treturn abs(cross(l[0] - l[1], m[0] - m[1])) < EPS;\n}\n\nint n;\nint main(){\n\twhile(cin >> n, n){\n\t\tvector<L> ls;\n\t\trep(i, n){\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tL l(P(a, b), P(c, d));\n\t\t\trep(j, i) if(parallel(ls[j], l) && abs(cross(ls[j][0] - l[1], l[0] - l[1])) < EPS) goto SKIP;\n\t\t\t\n\t\t\tls.pb(l);\n\t\t\tSKIP:;\n\t\t}\n\t\tn = ls.size();\n\t\tif(n < 3){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tP p(INF, INF);\n\t\tG cand;\n\t\tbool pa[100][100] = {};\n\t\trep(i, n) rep(j, i) pa[i][j] = pa[j][i] = parallel(ls[i], ls[j]);\n\t\trep(i, n) rep(j, i) if(pa[i][j]) rep(k, j) if(pa[j][k]){\n\t\t\tcout << \"None\" << endl;\n\t\t\tgoto END;\n\t\t}\n\t\t\n\t\trep(i, n) rep(j, i) rep(k, j){\n\t\t\tif(pa[i][j] || pa[j][k] || pa[k][i]) continue;\n\t\t\tP x = crosspoint(ls[i], ls[j]), y = crosspoint(ls[j], ls[k]), z = crosspoint(ls[k], ls[i]);\n\t\t\tcand.pb(incenter(x, y, z));\n\t\t\tG g; g.pb(x); g.pb(y); g.pb(z);\n\t\t\tg = excenter(g);\n\t\t\tcand.insert(cand.end(), all(g));\n\t\t\tgoto OUT;\n\t\t}\n\t\tOUT:\n\t\t\n\t\tif(cand.size()){\n\t\t\trep(it, cand.size()){\n\t\t\t\tbool ok = 1;\n\t\t\t\tdouble dist = distanceLP(ls[0], cand[it]);\n\t\t\t\trep(i, n) if(abs(dist - distanceLP(ls[i], cand[it])) > EPS){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tp = cand[it];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p.real() == INF){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(n < 4){\n\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(all(ls));\n\t\t\tdo{\n\t\t\t\tif(parallel(ls[0], ls[1]) && parallel(ls[2], ls[3])) break;\n\t\t\t}while(next_permutation(all(ls)));\n\t\t\t\n\t\t\tvector<L> t;\n\t\t\trep(i, 2){\n\t\t\t\tP m = (ls[i * 2][0] + ls[i * 2 + 1][0]) * 0.5;\n\t\t\t\tt.pb(L(m, m + ls[i * 2][1] - ls[i * 2][0]));\n\t\t\t}\n\t\t\tp = crosspoint(t[0], t[1]);\n\t\t\tdouble dist = distanceLP(ls[0], p);\n\t\t\trep(i, 4) if(abs(distanceLP(ls[i], p) - dist) > EPS){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.9f %.9f\\n\", p.real(), p.imag());\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-8\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn fabs((l.first-x).cross(l.second-x)) < eps;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\tvec2d v1, v2;\n\t\t\t\t\tv1 = (p[i]+p[j])*0.5, v2 = (q[i]+q[j])*0.5;\n\t\t\t\t\tif( fabs(v1.x - v2.x) < eps && fabs(v1.y - v2.y) < eps ){\n\t\t\t\t\t\ttmp.push_back(make_pair((p[i]+q[j])*0.5, (q[i]+p[j])*0.5));\n\t\t\t\t\t}\n\t\t\t\t\telse tmp.push_back(make_pair(v1, v2));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\telse if(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec.clear();\n\t\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec.clear();\n\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        //        P q0=intersect(bc,ca);\n        //        P q1=intersect(ca,ab);\n        //        if( abs(target-q0) > eps )continue;\n        //        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.10f %.10f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\nconst D eps=1e-4;\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nbool intersectLL(L l,L m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nint main(){\n  while(1){\n    int N;\n    vector<L> ls;\n    cin>>N;\n    if(N==0)break;\n    rep(i,N){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      ls.push_back(L(P(x1,y1),P(x2,y2)));\n    }\n    if(N<=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n    vector<P> candps;\n    {\n      vector<L> cls[3];\n      rep(i,3){\n        int j=(i+1)%3;\n        if(intersectLL(ls[i],ls[j])){\n          P cp=crosspoint(ls[i],ls[j]);\n          P v1=ls[i][1]-ls[i][0];\n          P v2=ls[j][1]-ls[j][0];\n          P v3=(abs(v2)*(abs(v1)+abs(v2)))*v1+(abs(v1)*(abs(v1)+abs(v2)))*v2;\n          cls[i].push_back(L(cp,cp+v3));\n          cls[i].push_back(L(cp,cp+P(-v3.Y,v3.X)));\n        }else{\n          P vv=P(ls[i][0].Y-ls[i][1].Y,ls[i][1].X-ls[i][0].X);\n          L vl=L(ls[i][0],ls[i][0]+vv);\n          P c1=crosspoint(vl,ls[i]); P c2=crosspoint(vl,ls[j]);\n          P mp=(c1+c2)/(long double)2.0;\n          cls[i].push_back(L(mp,mp+(ls[i][1]-ls[i][0])));\n        }\n      }\n      rep(a,cls[0].size())rep(b,cls[1].size())rep(c,cls[2].size()){\n        if(!intersectLL(cls[0][a],cls[1][b]))continue;\n        if(!intersectLL(cls[1][b],cls[2][c]))continue;\n        if(!intersectLL(cls[2][c],cls[0][a]))continue;\n        P p1=crosspoint(cls[0][a],cls[1][b]);\n        P p2=crosspoint(cls[1][b],cls[2][c]);\n        P p3=crosspoint(cls[2][c],cls[0][a]);\n        if(abs(p1-p2)<eps&&abs(p2-p3)<eps&&abs(p3-p1)<eps){\n          bool ok=true;\n          rep(z,candps.size())if(abs(candps[z]-p1)<eps)ok=false;\n          if(ok)candps.push_back(p1);\n        }\n      }\n    }\n    vector<P> res;\n    rep(i,candps.size()){\n      vector<D> ds;\n      rep(j,N){\n        ds.push_back(distanceLP(ls[j],candps[i]));\n      }\n      bool ok=true;\n      rep(j,ds.size())rep(k,j){\n        if(abs(ds[j]-ds[k])>eps)ok=false;\n      }\n      if(ok)res.push_back(candps[i]);\n    }\n    if(res.size()==0)cout<<\"None\"<<endl;\n    else if(res.size()==1)printf(\"%.10Lf %.10Lf\\n\", res[0].X,res[0].Y);\n    else cout<<\"Many\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    vector<P> C, D;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      C.push_back(V.back().first);\n      C.push_back(V.back().second);\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n        C.push_back(A.back().first);\n        C.push_back(A.back().second);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-2;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n        }\n        P a = A.back().first, v = n_vector(A.back().second-a);\n        B.emplace_back(a,a+v);\n        //cout << i << \" \" << j << \" \" << A.back().first << \" \" << A.back().second << endl;\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) < EPS){\n      cout << \"None\" << endl;\n      continue;\n    }\n    P c = intersection(A[0],A[1]);\n    bool f = true;\n    for(int i = 0; i < A.size(); ++i){\n      if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n        f = false;\n        cout << \"None\" << endl;\n        break;\n      }\n    }\n    if(f){\n      printf(\"%.12f %.12f\\n\",c.X,c.Y);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return P(rand(), rand()); // same line\n  if (abs(A) < EPS) return P(rand(), rand());// !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\nP incenter(const P &x, const P &y, const P &z){\n\tP a = y - x, b = z - x;\n\tP d1 = a / abs(a) + b / abs(b);\n\tP d2 = -a / abs(a) + (b - a) / abs(b - a);\n\treturn crosspoint(L(P(0, 0), d1), L(a, a + d2)) + x;\n}\nG excenter(const G &t){\n\tG res;\n\trep(i, 3){\n\t\tP a = t[i], b = t[(i + 1) % 3], c = t[(i + 2) % 3];\n\t\tres.pb(crosspoint(L(a, a + (a - c) / abs(a - c) + (b - a) / abs(b - a)),\n\t\tL(b, b + (b - c) / abs(b - c) + (a - b) / abs(a - b))));\n\t}\n\treturn res;\n}\nbool parallel(const L &l, const L &m){\n\treturn abs(cross(l[0] - l[1], m[0] - m[1])) < EPS;\n}\n\nint n;\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<L> ls;\n\t\trep(i, n){\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tL l(P(a, b), P(c, d));\n\t\t\trep(j, i) if(parallel(ls[j], l) && abs(cross(ls[j][0] - l[1], l[0] - l[1])) < EPS) goto SKIP;\n\t\t\t\n\t\t\tls.pb(l);\n\t\t\tSKIP:;\n\t\t}\n\t\tn = ls.size();\n\t\tif(n < 3){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tP p(INF, INF);\n\t\tG cand;\n\t\tbool pa[100][100] = {};\n\t\trep(i, n) rep(j, i) pa[i][j] = pa[j][i] = parallel(ls[i], ls[j]);\n\t\trep(i, n) rep(j, i) if(pa[i][j]) rep(k, j) if(pa[j][k]){\n\t\t\tcout << \"None\" << endl;\n\t\t\tgoto END;\n\t\t}\n\t\t\n\t\trep(i, n) rep(j, i) rep(k, j){\n\t\t\tif(pa[i][j] || pa[j][k] || pa[k][i]) continue;\n\t\t\tP x = crosspoint(ls[i], ls[j]), y = crosspoint(ls[j], ls[k]), z = crosspoint(ls[k], ls[i]);\n\t\t\tif(abs(x - y) < EPS && abs(y - z) < EPS){\n\t\t\t\tcand.pb(x);\n\t\t\t\tgoto OUT;\n\t\t\t}\n\t\t\t\n\t\t\tcand.pb(incenter(x, y, z));\n\t\t\tG g; g.pb(x); g.pb(y); g.pb(z);\n\t\t\tg = excenter(g);\n\t\t\tcand.insert(cand.end(), all(g));\n\t\t\tgoto OUT;\n\t\t}\n\t\tOUT:\n\t\t\n\t\tif(cand.size()){\n\t\t\trep(it, cand.size()){\n\t\t\t\tbool ok = 1;\n\t\t\t\tdouble dist = distanceLP(ls[0], cand[it]);\n\t\t\t\trep(i, n) if(abs(dist - distanceLP(ls[i], cand[it])) > EPS){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tif(p.real() != INF){\n\t\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t\t\tgoto END;\n\t\t\t\t\t}\n\t\t\t\t\tp = cand[it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p.real() == INF){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(n < 4){\n\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(all(ls));\n\t\t\tdo{\n\t\t\t\tif(parallel(ls[0], ls[1]) && parallel(ls[2], ls[3])) break;\n\t\t\t}while(next_permutation(all(ls)));\n\t\t\t\n\t\t\tvector<L> t;\n\t\t\trep(i, 2){\n\t\t\t\tP m = (ls[i * 2][0] + ls[i * 2 + 1][0]) * 0.5;\n\t\t\t\tt.pb(L(m, m + ls[i * 2][1] - ls[i * 2][0]));\n\t\t\t}\n\t\t\tp = crosspoint(t[0], t[1]);\n\t\t\tdouble dist = distanceLP(ls[0], p);\n\t\t\trep(i, 4) if(abs(distanceLP(ls[i], p) - dist) > EPS){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.9f %.9f\\n\", p.real(), p.imag());\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double phi=arg(b*conj(a))/2;\n\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\nconst double mag = 800;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d)&&eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      cout << c << endl;\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nint  makeall(vector<Line> &a,vector<Line> &b){\n  int ret=0;\n  //rep(i,1&&a.size()){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }\n    }\n    if (i == 0)ret=b.size();\n  }\n  return ret;\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  int p=makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,p&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && EQV(ans,cand))continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n \nconst double EPS = 1e-6;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n \nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n \ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n \nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nvector<L> equidist(const L &a, const L &b){\n    vector<L> ret;\n    if(isParallel(a, b)){\n        P mid = (a[0]+b[0])/2.0;\n        ret.push_back( L(mid, mid+(a[1]-a[0])) );\n    }else{\n        P cp = crosspointLL(a, b);\n        P v1 = unit(a[1]-a[0])*1000.0, v2 = unit(b[1]-b[0])*1000.0;\n        ret.push_back( L(cp, cp+ (v1+v2)/2.0) );\n        ret.push_back( L(cp, cp+ (v1-v2)/2.0) );\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n         \n        vector<L> l(n);\n        for(int i=0; i<n; i++){\n            int x1,y1,x2,y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            l[i] = L(P(x1,y1), P(x2,y2));\n        }\n\n        if(n <= 2){\n            cout << \"Many\" << endl;\n            continue;\n        }else if(isParallel(l[0], l[1]) && isParallel(l[1], l[2])){\n            cout << \"None\" << endl;\n            continue;\n        }\n\n        vector<L> ml;\n        for(int i=0; i<3; i++){\n            vector<L> cl = equidist(l[i], l[(i+1)%3]);\n            copy(cl.begin(), cl.end(), back_inserter(ml));\n        }\n        VP cand;\n        for(int i=0; i<(int)ml.size(); i++){\n            for(int j=i+1; j<(int)ml.size(); j++){\n                if(!isParallel(ml[i], ml[j])){\n                    cand.push_back(crosspointLL(ml[i], ml[j]));\n                }\n            }\n        }\n        sort(cand.begin(), cand.end());\n        cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n        int count = 0;\n        P ans;\n        for(int i=0; i<(int)cand.size(); i++){\n            bool success = true;\n            double dist = distanceLP(l[0], cand[i]);\n            for(int j=1; j<n; j++){\n                if(!EQ(dist, distanceLP(l[j], cand[i]))){\n                    success = false;\n                    break;\n                }\n            }\n            if(success){\n                count++;\n                ans = cand[i];\n            }\n        }\n\n        if(count==0){\n            cout << \"None\" << endl;\n        }else if(count >= 2){\n            cout << \"Many\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans.X << \" \" << ans.Y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  //rep(i,a.size()){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      //cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n      //<< a[j].fir <<\" \" << a[j].sec << endl;\n      //cout << j<<\" \"<< is_intersected_ll(\n      //a[i].fir,a[i].sec,\n      //a[j].fir,a[j].sec)<<\n      //\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      //cout << is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)<<endl;\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n\n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nbool mergeIfAble(Segment &s1, Segment s2) {\n  if(abs(cross(s1.p2 - s1.p1, s2.p2 - s2.p1)) > EPS) return false;\n  if(ccw(s1.p1, s2.p1, s1.p2) == COUNTER_CLOCKWISE ||\n     ccw(s1.p1, s2.p1, s1.p2) == CLOCKWISE) return false;\n  if(ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n     ccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT) return false;\n  s1 = Segment(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].p2 < segs[i].p1) swap(segs[i].p1, segs[i].p2);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i+1; j < segs.size(); j++) {\n      if(mergeIfAble(segs[i], segs[j])) {\n\tsegs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  edge(){}\n  edge(int to, double cost):to(to), cost(cost){}\n\n  bool operator < (const edge& e) const {\n    return lt(cost, e.cost);\n  }\n};\ntypedef vector< vector<edge> > Graph;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < segs.size(); i++) {\n    ps.push_back(segs[i].p1);\n    ps.push_back(segs[i].p2);\n    for(int j = i+1; j < segs.size(); j++) {\n      if(intersect(segs[i], segs[j])) ps.push_back(getCrossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  Graph graph(ps.size());\n  for(int i = 0; i < segs.size(); i++) {\n    vector< pair<double, int> > ls;\n    for(int j = 0; j < ps.size(); j++) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(getDistanceSP(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < ls.size(); j++) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, getDistance(ps[u], ps[v]));\n      graph[v].emplace_back(u, getDistance(ps[u], ps[v]));\n    }\n  }\n  return graph;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    vector<Line> onlines;\n    int cnt = 0;\n    rep(i, n) {\n      Line l = lines[i];\n      reps(j, i+1, n) {\n\tLine r = lines[j];\n\tif(isParallel(l, r)) {\n\t  double d = getDistance(l, r)/2;\n\t  auto lt = getTranslation(l, d);\n\t  auto rt = getTranslation(r, d);\n\t  Line m;\n\t  rep(i, 2) rep(j, 2) {\n\t    if(eq(getDistance(lt[i], rt[j]), 0)) {\n\t      m = lt[i];\n\t    }\n\t  }\n\t  onlines.push_back(m);\n\t  cnt++;\n\t} else {\n\t  Point p = getCrossPointLL(l, r);\n\t  Line v = Line(p, (l.p2-l.p1) + (r.p2-r.p1) + p);\n\t  Line w = Line(p, (l.p2-l.p1) - (r.p2-r.p1) + p);\n\t  onlines.push_back(v);\n\t  onlines.push_back(w);\n\t  cnt++;\n\t}\n      }\n    }\n    if(cnt == 0) {\n      cout << \"None\" << endl;\n      continue;\n    }\n    if(cnt == 1) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    set<Point> ans;\n    rep(i, min((int)onlines.size(), 10LL)) {\n      Line a = onlines[i];\n      reps(j, i+1, min((int)onlines.size(), 10LL)) {\n\tLine b = onlines[j];\n\tif(!intersect(a, b)) continue;\n\tPoint cp = getCrossPointLL(a, b);\n\tdouble dist = getDistanceLP(lines[0], cp);\n\tbool flag = true;\n\treps(k, 1, n) {\n\t  if(!eq(dist, getDistanceLP(lines[k], cp))) flag = false;\n\t}\n\tif(flag) ans.insert(cp);\n      }\n    }\n    if(ans.size() == 1) cout << ans.begin()->x << \" \" << ans.begin()->y << endl;\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    if (abs(a-b)<1e-10) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\nP normalize(P p) {\n  return p/abs(p);\n}\nvector<L> angleBisector(const L &l, const L &m) {\n  vector<L> res;\n  if (abs(cross(l[1]-l[0], m[1]-m[0])) > EPS) { // non-parallel\n    P p1 = crosspoint(l,m);\n    P p2 = p1+(normalize(l[1]-l[0]) + normalize(m[1]-m[0]))*0.5;\n    res.push_back(L(p1,p2));\n    p2 = p1+(normalize(l[1]-l[0]) + normalize(m[0]-m[1]))*0.5;\n    res.push_back(L(p1,p2));\n  } else {                      \n    P p1 = (projection(l,m[0])+m[0])*0.5;\n    res.push_back(L(p1,p1+l[1]-l[0]));\n  }\n  \n  return res;\n}\nint main() {\n  int n;\n  int hoge = 0;\n  while(cin>>n,n) {\n    //if (hoge++) break;\n    vector<L> v;\n    REP(i,n) {\n      P p1, p2;\n      cin>>p1.real()>>p1.imag()>>p2.real()>>p2.imag();\n      v.push_back(L(p1,p2));\n    }\n    // FOR(it, v) {\n    //   FOR(jt, v) {\n    //     if (*it == *jt) continue;\n    //     if (intersectLL(*it,*jt))\n    //         cout << crosspoint(*it, *jt) << endl;\n    //   }\n    // }\n    if (n<=2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> vl1 = angleBisector(v[0],v[1]);\n    vector<L> vl2 = angleBisector(v[0],v[2]);\n    set<P> se;\n    FOR(it, vl1) FOR(jt, vl2) {\n      //cout << (*it)[0] << \" \" << (*it)[1] << \",  \" << (*jt)[0] << \" \" << (*jt)[1] << endl;\n      if (intersectLL(*it,*jt))\n        se.insert(crosspoint(*it,*jt));\n    }\n    vector<P> ans;\n    FOR(it, se) {\n      double d = -1;\n      bool dame = 0;\n      FOR(jt, v) {\n        if (d == -1) d = distanceLP(*jt, *it);\n        else if (abs(d-distanceLP(*jt,*it))>1e-6) {\n          dame = 1;\n          break;\n        }\n      }\n      if (!dame) ans.push_back(*it);\n    }\n    // cout << \"se\"  << endl; FOR(it, se ) cout << *it << endl;\n    // cout << \"ans\" << endl; FOR(it, ans) cout << *it << endl;\n    if (ans.size() > 1) cout << \"Many\" << endl;\n    else if (ans.size() == 0) cout << \"None\" << endl;\n    else {\n      printf(\"%.5f %.5f\\n\", ans[0].real(), ans[0].imag());\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = long double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/(ld)2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/(ld)2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/(ld)2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n<=2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    sort(ans.begin(),ans.end(),cmp);\n    ans.erase(unique(ans.begin(),ans.end(),eqq),ans.end());\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==0){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\nnamespace std{\n  bool operator < (const Point& p, const Point& q){\n    if(p.real() != q.real()) return p.real() < q.real();\n    return p.imag() < q.imag();\n  }\n}\n\nint sign(double a){\n  if(a > EPS) return 1;\n  if(a < -EPS) return -1;\n  return 0;\n}\nbool equal(Point a, Point b){\n  return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n}\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b){\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\nbool intersect(const Line& l, const Point& p){\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\ndouble distanceLP(const Line& l, const Point& p){\n  return abs(p - projection(l, p));\n}\n\nPoint crosspoint(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0) assert(false);\n  return m[0] + m.vector() * B / A;\n}\n\nbool ok(const vector<Line>& l, Point p){\n  REP(i, l.size() - 1) if(sign(distanceLP(l[i], p) - distanceLP(l[i + 1], p)) != 0) return false;\n  return true;\n}\nvoid insert(vector<Point>& ans, Point p){\n  if(ans.empty() || !equal(ans.front(), p)) return ans.push_back(p);\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Line> l;\n    REP(i, N){\n      Point p[2];\n      REP(j, 2) cin >> p[j].real() >> p[j].imag();\n      sort(p, p + 2);\n      l.push_back(Line(p[0], p[1]));\n    }\n    if(N <= 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<Line> mid_lines;\n    REP(i, N) FOR(j, i + 1, N){\n      if(paralell(l[i], l[j])){\n        assert(!equalLL(l[i], l[j]));\n        Point p = projection(l[i], l[j][0]);\n        Point p1 = (p - l[j][0]) * 0.5;\n        Point p2 = p1 + l[i].vector();\n        mid_lines.push_back(Line(p1, p2));\n      }else{\n        Point p = crosspoint(l[i], l[j]);\n        Point q = p + l[i].vector() / abs(l[i].vector()) + l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n        q = p + l[i].vector() / abs(l[i].vector()) - l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n      }\n    }\n    // mid = 10000\n    vector<Point> ans;\n    int C = 0;\n    random_shuffle(mid_lines.begin(), mid_lines.end());\n    REP(i, mid_lines.size()) FOR(j, i + 1, mid_lines.size()){\n      if(C * N > 50000000) break;\n      C++;\n      if(ans.size() >= 2) break;\n      if(equalLL(mid_lines[i], mid_lines[j])){\n        REP(iter, 3){\n          double t = 1000.0 * rand() / RAND_MAX;\n          Point p = mid_lines[i][0] + mid_lines[i].vector() * t;\n          if(ok(l, p)) insert(ans, p);\n          else break;\n        }\n      }else if(!paralell(mid_lines[i], mid_lines[j])){\n        Point p = crosspoint(mid_lines[i], mid_lines[j]);\n        if(ok(l, p)) insert(ans, p);\n      }\n    }\n    if(ans.empty()) cout << \"None\" << endl;\n    else if(ans.size() == 1) printf(\"%.16lf %.16lf\\n\", ans.front().real(), ans.front().imag());\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  //rep(i,a.size()){\n  //rep(i,a.size()){\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      //cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n      //<< a[j].fir <<\" \" << a[j].sec << endl;\n      //cout << j<<\" \"<< is_intersected_ll(\n      //a[i].fir,a[i].sec,\n      //a[j].fir,a[j].sec)<<\n      //\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot2(at-tmp,bt-tmp)));\n// \tP tmp2=b[b.size()-1].sec;\n// \ttmp2-=tmp;\n// \tswap(tmp2.real(),tmp2.imag());\n// \ttmp2.real()*=-1;\n// \ttmp2+=tmp;\n// \tb.pb(mp(tmp,tmp2));\n\n\n// \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n// \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n\t\n \t//cout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n\t//  \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" << endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n\n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < 1; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-6;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<sqrt(eps);\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    //P m=(a1+b1)/2.l;\n    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n \nusing namespace std;\n \nclass Point{\npublic:\n  double x,y;\n \n  Point(double x = 0,double y = 0): x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n \n};\n \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n \n};\n \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n \nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n \ndouble abs(Point a){ return sqrt(norm(a)); }\n \n//rad ?????§????????????????¢??????§??????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n \n// ???????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n \n// a => prev, b => cur, c=> next\n// prev ?????? cur ?????????£??? next ?????????????????§?????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //????????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n \n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n   \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n   \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n  \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n \n// ------------------\n \ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n \n  int res = ccw(cp,p1,p2);\n  //assert( ( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  //while( !( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n \n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 10 ) break;\n  }\n   \n  vector<Point> candidatePoints;\n \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n \n \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n \nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-4)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long double LD;\nconst LD eps=1e-6;\nconst int maxn=110;\nLD sqr(LD x){return x*x;}\nint sgn(LD x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct P{\n\tLD x,y;\n\tP(){}\n\tP(LD x,LD y):x(x),y(y){}\n\tLD len(){\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n\tP turn90(){\n\t\treturn P(y,-x);\n\t}\n\tvoid read(){\n\t\tdouble tx,ty;\n\t\tscanf(\"%lf%lf\",&tx,&ty);\n\t\tx=tx;\n\t\ty=ty;\n\t}\n};\nbool operator==(P a,P b){\n\treturn !sgn(a.x-b.x)&&!sgn(a.y-b.y);\n}\nbool operator<(P a,P b){\n\treturn sgn(a.x-b.x)?a.x<b.x:a.y<b.y;\n}\nP operator+(P a,P b){\n\treturn P(a.x+b.x,a.y+b.y);\n}\nP operator-(P a,P b){\n\treturn P(a.x-b.x,a.y-b.y);\n}\nLD operator^(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\nLD operator*(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\nP operator*(P a,LD p){\n\treturn P(a.x*p,a.y*p);\n}\nP operator/(P a,LD p){\n\treturn P(a.x/p,a.y/p);\n}\nP rot(P p,double rad){\n\treturn P(p.x*cos(rad)-p.y*sin(rad),p.x*sin(rad)+p.y*cos(rad));\n}\nLD det(P a,P b,P c){\n\treturn (b-a)*(c-a);\n}\nP intersect(P a,P b,P c,P d){\n\tLD s1=det(a,b,c);\n\tLD s2=det(a,b,d);\n\treturn (d*s1-c*s2)/(s1-s2);\n}\nstruct L{\n\tP a,b;\n\tP v(){return b-a;}\n\tL(){}\n\tL(P a,P b):a(a),b(b){}\n}l[maxn];\nbool operator==(L a,L b){\n\treturn a.a==b.a&&a.b==b.b;\n}\nbool operator<(L a,L b){\n\treturn !(a.a==b.a)?a.a<b.a:a.b<b.b;\n}\nP intersect(L l1,L l2){\n\treturn intersect(l1.a,l1.b,l2.a,l2.b);\n}\nbool parallel(P a,P b){\n\treturn !sgn(a*b);\n}\nL Rev(L l){\n\tl.b=l.a+l.v().turn90();\n\treturn l;\n}\nint n;\nL binary(L l1,L l2){\n\tL ans;\n\tif(parallel(l1.v(),l2.v())){\n\t\tP v=l1.v().turn90();\n\t\tL newl=L(l1.a,l1.a+v);\n\t\tP p=intersect(newl,l2);\n\t\tans.a=(l1.a+p)/2.0;\n\t\tans.b=ans.a+l1.v();\n\t}else{\n\t\tP e1=l1.v()/l1.v().len();\n\t\tP e2=l2.v()/l2.v().len();\n\t\tP p=intersect(l1,l2);\n\t\tans.a=p;\n\t\tans.b=p+e1+e2;\n\t}\n\treturn ans;\n}\nbool Online(P p,L l){\n\treturn sgn((p-l.a)*(l.b-l.a))==0;\n}\nvector<L>ansL;\nvector<P>ansP;\nvoid Intersec(L l){\n\tvector<L>tmpL;\n\tvector<P>tmpP;\n\t\n\tfor(int i=0;i<ansP.size();i++){\n\t\tif(Online(ansP[i],l))\t\n\t\t\ttmpP.push_back(ansP[i]);\n\t}\n\t\n\tfor(int i=0;i<ansL.size();i++){\n\t\tif(parallel(ansL[i].v(),l.v())){\n\t\t\tif(Online(l.a,ansL[i])){\n\t\t\t\ttmpL.push_back(ansL[i]);\n\t\t\t}\n\t\t}else{\n\t\t\tP p=intersect(l,ansL[i]);\n\t\t\ttmpP.push_back(p);\n\t\t}\n\t}\n\t\n\tansP=tmpP;\n\tansL=tmpL;\n\tsort(ansP.begin(),ansP.end());\n\tansP.erase(unique(ansP.begin(),ansP.end()),ansP.end());\n\tsort(ansL.begin(),ansL.end());\n\tansL.erase(unique(ansL.begin(),ansL.end()),ansL.end());\n}\nvoid Intersec(L l1,L l2){\n\tvector<L>tmpL;\n\tvector<P>tmpP;\n\t\n\tfor(int i=0;i<ansP.size();i++){\n\t\tif(Online(ansP[i],l1) || Online(ansP[i],l2))\t\n\t\t\ttmpP.push_back(ansP[i]);\n\t}\n\t\n\tfor(int i=0;i<ansL.size();i++){\n\t\tif(parallel(ansL[i].v(),l1.v())){\n\t\t\tif(Online(l1.a,ansL[i])){\n\t\t\t\ttmpL.push_back(ansL[i]);\n\t\t\t}\n\t\t}else{\n\t\t\tP p=intersect(l1,ansL[i]);\n\t\t\ttmpP.push_back(p);\n\t\t}\n\t\tif(parallel(ansL[i].v(),l2.v())){\n\t\t\tif(Online(l2.a,ansL[i])){\n\t\t\t\ttmpL.push_back(ansL[i]);\n\t\t\t}\n\t\t}else{\n\t\t\tP p=intersect(l2,ansL[i]);\n\t\t\ttmpP.push_back(p);\n\t\t}\n\t}\n\t\n\tansP=tmpP;\n\tansL=tmpL;\t\n\tsort(ansP.begin(),ansP.end());\n\tansP.erase(unique(ansP.begin(),ansP.end()),ansP.end());\n\tsort(ansL.begin(),ansL.end());\n\tansL.erase(unique(ansL.begin(),ansL.end()),ansL.end());\n}\nvoid printans(){\n\tfor(int i=0;i<ansP.size();i++){\n\t\tprintf(\"(%.3f,%.3f)%c\",(double)ansP[i].x,(double)ansP[i].y,\" \\n\"[i+1==ansP.size()]);\n\t}\n\t\n\tfor(int i=0;i<ansL.size();i++){\n\t\tprintf(\"(%.3f,%.3f)--(%.3f,%.3f)%c\",(double)ansL[i].a.x,(double)ansL[i].a.y,(double)ansL[i].b.x,(double)ansL[i].b.y,\" \\n\"[i+1==ansL.size()]);\n\t}\n\t\n}\nint main(){\n\twhile(scanf(\"%d\",&n)!=-1){\n\t\tif(!n)break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tl[i].a.read();\n\t\t\tl[i].b.read();\n\t\t}\n\t\t\n\t\tif(n<=2){\n\t\t\tputs(\"Many\");\n\t\t\tcontinue;\n\t\t}\n\t\tansL.clear();\n\t\tansP.clear();\n\t\t\n\t\tif(sgn(l[1].v()*l[2].v())==0){\n\t\t\tansL.push_back(binary(l[1],l[2]));\n\t\t}else{\n\t\t\tL li=binary(l[1],l[2]);\n\t\t\tansL.push_back(li);\n\t\t\tli.b=li.a+li.v().turn90();\n\t\t\tansL.push_back(li);\n\t\t}\n\t\t\n\t\t//printans();\n\t\t\n\t\tfor(int i=3;i<=n;i++){\t\t\t\n\t\t\tif(sgn(l[1].v()*l[i].v())==0){\n\t\t\t\tIntersec(binary(l[1],l[i]));\n\t\t\t}else{\n\t\t\t\tL li=binary(l[1],l[i]);\n\t\t\t\tL li2=li;\n\t\t\t\tli2.b=li2.a+li2.v().turn90();\n\t\t\t\tIntersec(li,li2);\n\t\t\t}\n\n\t\t\t//printf(\"ans after %d\\n\",i);\n\t\t\t//printans();\n\n\t\t}\n\t\t\n\t\t\n\t\tif(ansL.empty()&&ansP.empty()){\n\t\t\tputs(\"None\");\n\t\t}else\n\t\tif(!ansL.empty() || ansP.size()>1){\n\t\t\tputs(\"Many\");\n\t\t}else{\n\t\t\tprintf(\"%.8f %.8f\\n\",(double)ansP[0].x,(double)ansP[0].y);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\nconst double mag = 400;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d)&&eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ) assert( abs(answer-cp) < EPS );\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nstruct point {\n\tdouble x, y;\n\tvoid scan() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tpoint() {\n\t}\n\tpoint(const double & a, const double & b) : x(a), y(b) {\n\t}\n\tdouble sqrlen() const {\n\t\treturn x * x + y * y;\n\t}\n\tdouble len() const {\n\t\treturn sqrt(max(0., sqrlen()));\n\t}\n\tpoint zoom(const double & l) const {\n\t\tdouble lambda(l / len());\n\t\treturn point(lambda * x, lambda * y);\n\t}\n\tpoint rev() const {\n\t\treturn point(-y, x);\n\t}\n\tvoid print() const {\n\t\tprintf(\"%.10f %.10f\\n\", x, y);\n\t}\n};\ndouble sqr(double x) { return x * x; }\npoint operator + (const point& p1, const point& p2) { return point(p1.x + p2.x, p1.y + p2.y); }\npoint operator - (const point& p1, const point& p2) { return point(p1.x - p2.x, p1.y - p2.y); }\npoint operator * (const point& p1, double d) { return point(p1.x * d, p1.y * d); }\npoint operator / (const point& p1, double d) { return point(p1.x / d, p1.y / d); }\nint dcmp(double x) { return fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); }\ndouble det(point p1, point p2) { return p1.x * p2.y - p1.y * p2.x; }\ndouble dist(point p1, point p2) { return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y)); }\npoint nor(point p) { return p / sqrt(max(0., sqr(p.x) + sqr(p.y))); }\n\nstruct Line {\n\tpoint s, d;\n\tLine(const point & a, const point & b) : s(a), d(b) {\n\t}\n\tLine() {\n\t}\n} l[10001], p[10001][2];\n\nint n;\npoint a[10001], b[10001];\n\npoint inter(point p, point v, point q, point w) {\n\tpoint u = p - q;\n\tdouble t = det(w, u) / det(v, w);\n\treturn p + v * t;\n}\n\ndouble D(point p, point p1, point p2) {\n\treturn fabs(det(p - p1, p - p2)) / dist(p1, p2);\n}\nbool operator < (const point& p1, const point& p2) {\n\tif (dcmp(p1.x - p2.x)) return p1.x < p2.x;\n\tif (dcmp(p1.y - p2.y)) return p1.y < p2.y;\n\treturn false;\n}\n__inline double operator * (const point & a, const point & b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n__inline point intersection(const Line & a, const Line & b) {\n\tdouble lambda((b.s - a.s) * b.d / (a.d * b.d));\n\treturn a.s + a.d * lambda;\n}\n__inline double dis(const point & a, const point & s, const point & t) {\n\treturn fabs((s - a) * (s - t)) / (s - t).len();\n}\n__inline bool equal(const double & a, const double & b) {\n\treturn dcmp(a - b) == 0;\n}\nint main( ) {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%lf %lf\", &a[i].x, &a[i].y);\n\t\t\tscanf(\"%lf %lf\", &b[i].x, &b[i].y);\n\t\t}\n\t\tif (n <= 2) { printf(\"Many\\n\"); continue; }\n\t\tfor(int i(1); i <= 3; i++) {\n\t\t\tl[i] = Line(a[i], b[i] - a[i]);\n\t\t}\n\t\tfor (int i = 1; i <= 2; i ++) {\n\t\t\tif (dcmp(l[i].d * l[i + 1].d) == 0) \n\t\t\t\tp[i][0] = p[i][1] = Line((l[i].s + l[i + 1].s) * 0.5, l[i].d);\n\t\t\telse {\n\t\t\t\tp[i][0] = Line(intersection(l[i], l[i + 1]), (l[i].d.zoom(1) + l[i + 1].d.zoom(1)) * 0.5);\n\t\t\t\tp[i][1] = Line(intersection(l[i], l[i + 1]), (l[i].d.zoom(-1) + l[i + 1].d.zoom(1)) * 0.5);\n\t\t\t}\n\t\t}\n\t\tset<point> S;\n\t\tfor (int i = 0; i < 2; i ++)\n\t\t\tfor (int j = 0; j < 2; j ++) {\n\t\t\t\tpoint x = p[1][i].d;\n\t\t\t\tpoint y = p[2][j].d;\n\n\t\t\t\tif (dcmp(det(x, y)) == 0) continue;\n\t\t\t\tpoint o = intersection(p[1][i], p[2][j]);\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 2; j <= n; ++ j)\n\t\t\t\t\tif (dcmp(D(o, a[j], b[j]) - D(o, a[1], b[1]))) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == false) S.insert(o);\n\t\t\t}\n\t\tif (S.size() == 0) printf(\"None\\n\");\n\t\telse if (S.size() > 1) printf(\"Many\\n\");\n\t\telse S.begin() -> print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = (m); i < (n); ++i)\n#define pb push_back\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Pt;\ndouble dot(const Pt &a, const Pt &b) { return real(conj(a) * b); }\ndouble cross(const Pt &a, const Pt &b) { return imag(conj(a) * b); }\nnamespace std {\n    bool operator == (const Pt &a, const Pt &b) {\n        return abs(real(a) - real(b)) < EPS && abs(imag(a) - imag(b)) < EPS;\n    }\n}\n\nstruct Line : public vector<Pt>\n{\n    Line(){};\n    Line(const Pt &a, const Pt &b) {\n        pb(a); pb(b);\n    }\n};\n\nPt projection(const Line &l, const Pt &p)\n{\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distLP(const Line &l, const Pt &p)\n{\n    return abs(p - projection(l, p));\n}\n\nbool is_parallel(const Line &l, const Line &m)\n{\n    return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\nPt crosspoint(const Line &l, const Line &m)\n{\n    double a = cross(l[1] - l[0], m[1] - m[0]);\n    double b = cross(l[1] - l[0], l[1] - m[0]);\n    return m[0] + b / a * (m[1] - m[0]);\n}\n\n\nint main()\n{\n    int n, x1, y1, x2, y2;\n    cout << fixed << setprecision(5);\n    \n    while (cin >> n && n)\n    {\n        vector<Line> line;\n        rep(i, n)\n        {\n            cin >> x1 >> y1 >> x2 >> y2;\n            line.pb(Line(Pt(x1, y1), Pt(x2, y2)));\n        }\n        if(n < 3) { cout << \"Many\" << endl; continue; }\n        \n        vector<Line> bis[2];\n        vector<Pt> cand;\n        vector<double> dist;\n        rep(i, 2)\n        {\n            Line &l1 = line[i], &l2 = line[i+1];\n            if(!is_parallel(l1, l2))\n            {\n                Pt p1 = l1[1] - l1[0], p2 = l2[1] - l2[0];\n                p1 /= abs(p1); p2 /= abs(p2);\n                Pt c = crosspoint(l1, l2);\n                bis[i].pb(Line(c, c + p1 + p2));\n                bis[i].pb(Line(c, c + p1 - p2));\n            }\n            else\n            {\n                Pt p((real(l1[0]) + real(l2[0])) / 2, (imag(l1[0]) + imag(l2[0])) / 2);\n                bis[i].pb(Line(p, p + l1[1] - l1[0]));\n            }\n        }\n        rep(i, bis[0].size()) rep(j, bis[1].size())\n        \tcand.pb(crosspoint(bis[0][i], bis[1][j]));\n        rep(i, cand.size()) rep(j, i) if(cand[i] == cand[j]) {\n        \tcand.erase(cand.begin() + i); --i; break;\n        }\n        rep(i, cand.size()) dist.pb(distLP(line[0], cand[i]));\n        \n        rep2(i, 3, n) rep(j, cand.size()) if(abs(dist[j] - distLP(line[i], cand[j])) > EPS)\n        {\n        \tcand.erase(cand.begin() + j);\n        \tdist.erase(dist.begin() + j);\n        \t--j;\n        }\n        \n        if(cand.size() > 1)  cout << \"Many\" << endl;\n        if(cand.size() == 1) cout << real(cand[0]) << ' ' << imag(cand[0]) << endl;\n        if(cand.size() == 0) cout << \"None\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-6;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\nbool intersect(const line<double> &L1,const line<double> &L2){\n\treturn abs(cross(L1.b-L1.a,L2.b-L2.a))>EPS\n\t\t|| abs(cross(L1.b-L1.a,L2.a-L1.a))<EPS;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<double> &L,const line<double> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tres.push_back((line<double>){(L.a+M.a)/2,(L.a+M.a)/2+(L.b-L.a)});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(L.a==o?L.b:L.a)-o;\n\t\tpoint<double> q=(M.a==o?M.b:M.a)-o;\n\t\tp/=abs(p);\n\t\tq/=abs(q);\n\t\tres.push_back((line<double>){o,o+p+q});\n\t\tres.push_back((line<double>){o,o+p-q});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<double> L[100];\n\t\trep(i,n) scanf(\"%lf%lf%lf%lf\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\t\tsort(P_cand.begin(),P_cand.end());\n\t\tP_cand.erase(unique(P_cand.begin(),P_cand.end()),P_cand.end());\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist(L[j],p)-dist(L[0],p))>EPS) { ok=false; break; }\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n\n  Point cp = crosspoint(line1,line2);\n  int res = ccw(cp,p1,p2);\n\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  double arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 20 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-5;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\n\ninline Point projectionOfLP(Line L, Point P){return L[0]+(Point(P-L[0])).dot(L[0]-L[1])/norm(L[0]-L[1])*(L[0]-L[1]);}\ninline Point reflectionOfLP(Line L, Point P){return P+2.0*(projectionOfLP(L, P)-P);}\ninline bool intersectionDeterminationOfLL(Line L, Line M){return abs(Point(L[1]-L[0]).det(M[1]-M[0]))>EPS||abs(Point(L[1]-L[0]).det(M[0]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLS(Line L, Line S){return(Point(L[1]-L[0]).det(S[0]-L[0]))\n*(Point(L[1]-L[0]).det(S[1]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLP(Line L, Point P){return abs(Point(L[1]-P).det(L[0]-P))<EPS;}\ninline bool intersectionDeterminationOfSS(Line S, Line T){return ccw(S[0],S[1],T[0])*ccw(S[0],S[1],T[1])<=0&&ccw(T[0],T[1],S[0])*ccw(T[0],T[1],S[1])<=0;}\ninline bool intersectionDeterminationOfSP(Line S, Point P){return abs(S[0]-P)+abs(S[1]-P)-abs(S[1]-S[0])<EPS;}\ninline double distanceOfLP(Line L, Point P){return abs(P-projectionOfLP(L,P));}\ninline double distanceOfLL(Line L, Line M){return intersectionDeterminationOfLL(L,M)?0.0:distanceOfLP(L,M[0]);}\ninline double distanceOfLS(Line L, Line S){return intersectionDeterminationOfLS(L,S)?0.0:min(distanceOfLP(L,S[0]),distanceOfLP(L,S[1]));}\ninline double distanceOfSP(Line S, Point P){Point r=projectionOfLP(S,P);return intersectionDeterminationOfSP(S,r)?abs(r-P):min(abs(S[0]-P),abs(S[1]-P));}\ninline double distanceOfSS(Line S, Line T){return intersectionDeterminationOfSS(S,T)?0.0:min(min(distanceOfSP(S,T[0]),distanceOfSP(S,T[1])),min(distanceOfSP(T,S[0]),distanceOfSP(T,S[1])));}\nPoint intersectionOfLL(Line L, Line M)\n{\n  double A = Point(L[1]-L[0]).det(M[1]-M[0]);\n  double B = Point(L[1]-L[0]).det(L[1]-M[0]);\n  if(abs(A)<EPS && abs(B)<EPS) return M[0];\n  if(abs(A)<EPS) assert(false);\n  return M[0] + B / A * (M[1] - M[0]);\n}\ninline bool onLine(Point P, Line L){ return semieq(Point(L[0]-P).det(L[1]-P),0.0); }\ninline bool onSegment(Point P, Segment S){ return semieq(Point(S[0]-P).det(S[1]-P),0.0)&&!semige(Point(S[0]-P).dot(S[1]-P),0.0); }\n\n// P ????????? L ????????´????????????\ninline Line perpendicularBisector(Point P, Line L)\n{\n  return Line(P, (L[0] - P) * complex<double>(0.0, 1.0) + P);\n}\n\n// L ??¨ M ????????´????????¨????????\\??????\nvector<Line> bisector(Line L, Line M)\n{\n  vector<Line> ret(2);\n  if(intersectionDeterminationOfLL(L, M)){\n    Point P = intersectionOfLL(L, M);\n    int s, t;\n    if(semile(abs(L[0] - P), abs(L[1] - P))) s = 1;  else s = 0;\n    if(semile(abs(M[0] - P), abs(M[1] - P))) t = 1;  else t = 0;\n    Point S = (L[s] - P) / abs(L[s] - P);\n    Point T = (M[t] - P) / abs(M[t] - P);\n    Point ST = (S + T) / 2.0;\n    ret[0] = Line(P, P + ST);\n    ret[1] = Line(P, P + ST * complex<double>(0.0, 1.0));\n  }\n  else{\n    Point E[2];\n    rep(i, 2){\n      Line LL = perpendicularBisector(L[i], L);\n      Point PP = intersectionOfLL(LL, M);\n      E[i] = (L[i] + PP) / 2.0;\n    }\n    ret[0] = ret[1] = Line(E[0], E[1]);\n  }\n  return ret;  \n}\n\nint n;\nLine* L;\ndouble sx, sy, tx, ty;\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n, n){\n    L = new Line[n];\n    rep(i, n){\n      cin >> sx >> sy >> tx >> ty;\n      L[i] = Line(sx, sy, tx, ty);\n    }\n\n    if(n <= 2){\n      puts(\"Many\");\n      delete[] L;\n      continue;\n    }\n\n    vector<Line> bis = bisector(L[0], L[1]);\n    vector<Line> M = bisector(L[0], L[n - 1]);\n    vector<Point> ret;\n    vrep(v, bis){\n      vrep(w, M){\n        if(intersectionDeterminationOfLL(*v, *w)){\n          Point P = intersectionOfLL(*v, *w);\n          double d = distanceOfLP(L[0], P);\n          bool ok = true;\n          rep(i, n){\n            if(!semieq(distanceOfLP(L[i], P), d)){\n              ok = false;\n              break;\n            }\n          }\n          if(ok){\n            vrep(c, ret) if(semieq(c->real(), P.real()) && semieq(c->imag(), P.imag())){\n              ok = false;\n              break;\n            }\n            if(ok) ret.pb(P);\n          }\n        }\n      }\n    }\n    if(ret.size() == 0) puts(\"None\");\n    else if(ret.size() == 1) printf(\"%.15f %.15f\\n\", ret[0].real(), ret[0].imag());\n    else puts(\"Many\");\n    \n    delete[] L;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-11;\nconst double pi = acos(-1.0);\nconst double mag = 1;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d)&&eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\n#define PI (4.0*atan(1.0))\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P,i) - curr(P,i))\nenum { OUT, ON, IN };\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<L> bisector(const L &l, const L &m){\n\tvector<L> res;\n\tif(intersectLL(l,m)){\n\t\tP p=crosspoint(l,m);\n\t\tP q=(l[1]-l[0])\n\t\t+ (m[1]-m[0])/abs(m[1]-m[0])*abs(l[1]-l[0]);\n\t\tP r=(l[1]-l[0])\n\t\t+ (m[0]-m[1])/abs(m[0]-m[1])*abs(l[1]-l[0]);\n\t\tres.pb(L(p,p+q));\n\t\tres.pb(L(p,p+r));\n\t\treturn res;\n\t}\n\telse{\n\t\tP p=projection(l,m[0]);\n\t\tP q=(m[0]+p)*0.5;\n\t\tres.pb(L(q,q+l[1]-l[0]));\n\t\treturn res;\n\t}\n}\n\nint n;\nL line[111];\n\nint main(){\n\tcout<<setprecision(15);\n\twhile(cin>>n && n){\n\t\trep(i,n){\n\t\t\tint x,y,xx,yy;\n\t\t\tcin>>x>>y>>xx>>yy;\n\t\t\tline[i]=L(P(x,y),P(xx,yy));\n\t\t}\n\t\tif(n<=2){\n\t\t\tcout<<\"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t//cout<<line[0][0]-line[0][1]<<endl;\n\t\tvector<L> bisec01=bisector(line[0],line[1]),\n\t\tbisec02=bisector(line[0],line[2]);\n\t\tP ans(INF,INF);\n\t\trep(i,bisec01.sz)rep(j,bisec02.sz){\n\t\t\tif(intersectLL(bisec01[i],bisec02[j])){\n\t\t\t\t//cout<<bisec01[i][0]<<\" \"<<bisec01[i][1]<<endl;\n\t\t\t\t//cout<<bisec02[i][0]<<\" \"<<bisec02[i][1]<<endl;\n\t\t\t\tP p=crosspoint(bisec01[i],bisec02[j]);\n\t\t\t\t//cout<<p<<endl;\n\t\t\t\tdouble dist=distanceLP(line[0],p);\n\t\t\t\trep2(k,3,n){\n\t\t\t\t\tif(abs(distanceLP(line[k],p)-dist)>EPS){\n\t\t\t\t\t\t//cout<<k<<\" \"<<abs(distanceLP(line[k],p)-dist)<<endl;\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(abs(ans-p)>EPS){\n\t\t\t\t\tif(abs(ans)>INF){\n\t\t\t\t\t\tans=p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout<<\"Many\\n\";\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfail:;\n\t\t\t}\n\t\t}\n\t\tif(abs(ans)>INF)cout<<\"None\\n\";\n\t\telse cout<<ans.real()<<\" \"<<ans.imag()<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    if(sign(cross(vec1, vec2)) == 0){\n        res.push_back(Line((l[0] + m[0]) / 2.0, (l[1] + m[1]) / 2.0));\n    }else{\n        Point p = crosspointLL(l, m);\n        res.push_back(Line(p, p + vec1 + vec2));\n        res.push_back(Line(p, p + vec1 - vec2));\n    }\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 0; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n        for(int j = i + 1; j < 3; j++){\n            //if(paralell(lines[i], lines[j])) continue;\n            vector<Line> mids = get_midline(lines[i], lines[j]);\n            midlines.insert(midlines.end(), mids.begin(), mids.end());\n        }\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 1; k < lines.size(); k++){\n                if(sign(distanceLP(lines[k], p) - distanceLP(lines[k - 1], p)) != 0){\n                    ok = false;\n                    break;\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.12f %.12f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n \nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n \ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n \nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nvector<L> equidist(const L &a, const L &b){\n    vector<L> ret;\n    if(isParallel(a, b)){\n        P mid = (a[0]+b[0])/2.0;\n        ret.push_back( L(mid, mid+(a[1]-a[0])) );\n    }else{\n        P cp = crosspointLL(a, b);\n        P v1 = unit(a[1]-a[0]), v2 = unit(b[1]-b[0]);\n        ret.push_back( L(cp, cp+ (v1+v2)/2.0) );\n        ret.push_back( L(cp, cp+ (v1-v2)/2.0) );\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n         \n        vector<L> l(n);\n        for(int i=0; i<n; i++){\n            int x1,y1,x2,y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            l[i] = L(P(x1,y1), P(x2,y2));\n        }\n\n        if(n < 3){\n            cout << \"Many\" << endl;\n            continue;\n        }else if(isParallel(l[0], l[1]) && isParallel(l[1], l[2])){\n            cout << \"None\" << endl;\n            continue;\n        }\n\n        vector<L> ml;\n        for(int i=0; i<3; i++){\n            vector<L> cl = equidist(l[i], l[(i+1)%3]);\n            copy(cl.begin(), cl.end(), back_inserter(ml));\n        }\n        VP cand;\n        for(int i=0; i<(int)ml.size(); i++){\n            for(int j=i+1; j<(int)ml.size(); j++){\n                if(!isParallel(ml[i], ml[j])){\n                    cand.push_back(crosspointLL(ml[i], ml[j]));\n                }\n            }\n        }\n        sort(cand.begin(), cand.end());\n        cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n        int count = 0;\n        P ans;\n        for(int i=0; i<(int)cand.size(); i++){\n            bool success = true;\n            double dist = distanceLP(l[0], cand[i]);\n            for(int j=1; j<n; j++){\n                if(!EQ(dist, distanceLP(l[j], cand[i]))){\n                    success = false;\n                    break;\n                }\n            }\n            if(success){\n                count++;\n                ans = cand[i];\n            }\n        }\n\n        if(count==0){\n            cout << \"None\" << endl;\n        }else if(count >= 2){\n            cout << \"Many\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans.X << \" \" << ans.Y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    vector<P> D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        D.push_back(c);\n\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else{\n      vector<P> D_;\n      sort(D.begin(),D.end());\n      D_.push_back(D[0]);\n      for(int i = 1; i < D.size(); ++i){\n        if(abs(D_.back()-D[i]) > EPS){\n          D_.push_back(D[i]);\n        }\n      }\n      if(D_.size() == 1) printf(\"%.12f %.12f\\n\",D_[0].X,D_[0].Y);\n      else cout << \"Many\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\t/*if( abs(answer-cp) > EPS  && abs(answer-cp) < 100000)\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tassert( abs(answer-cp) < 100000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ) puts(\"Many\");\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = long double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-10;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/(ld)2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/(ld)2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/(ld)2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n<=2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    sort(ans.begin(),ans.end(),cmp);\n    ans.erase(unique(ans.begin(),ans.end(),eqq),ans.end());\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==0){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/2.0,\n                       (V[0].first+V[j].first)/2.0 + V[0].second - V[0].first);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a);\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.size() == 0) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12f %.12f\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < 1; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-7;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n <= 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<Line> ls;\n\t\trep(i, bs.size()) for (auto b : bs[i]){\n\t\t\tls.eb(b);\n\t\t}\n\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, std::min<int>(bs.size(), 5)) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}();\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tunique(cps);\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tcnt++;\n\t\t\t\tres = cps[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (cnt > 2) cout << \"Many\\n\";\n\t\telse if (cnt == 0) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n  \nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \n//rad ??????§?????????????????¢???????§???????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \n// ????????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \n// a => prev, b => cur, c=> next\n// prev ?????? cur ??????????£??? next ??????????????????§??????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //?????????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n  \n  int res = ccw(cp,p1,p2);\n  //assert( ( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  //while( !( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 10 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n,n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-5;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long double LD;\nconst LD eps=1e-12;\nconst int maxn=110;\nLD sqr(LD x){return x*x;}\nint sgn(LD x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct P{\n\tLD x,y;\n\tP(){}\n\tP(LD x,LD y):x(x),y(y){}\n\tLD len(){\n\t\treturn sqrt(sqr(x)+sqr(y));\n\t}\n\tP turn90(){\n\t\treturn P(y,-x);\n\t}\n\tvoid read(){\n\t\tdouble tx,ty;\n\t\tscanf(\"%lf%lf\",&tx,&ty);\n\t\tx=tx;\n\t\ty=ty;\n\t}\n};\nbool operator==(P a,P b){\n\treturn !sgn(a.x-b.x)&&!sgn(a.y-b.y);\n}\nbool operator<(P a,P b){\n\treturn sgn(a.x-b.x)?a.x<b.x:a.y<b.y;\n}\nP operator+(P a,P b){\n\treturn P(a.x+b.x,a.y+b.y);\n}\nP operator-(P a,P b){\n\treturn P(a.x-b.x,a.y-b.y);\n}\nLD operator^(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\nLD operator*(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\nP operator*(P a,LD p){\n\treturn P(a.x*p,a.y*p);\n}\nP operator/(P a,LD p){\n\treturn P(a.x/p,a.y/p);\n}\nP rot(P p,double rad){\n\treturn P(p.x*cos(rad)-p.y*sin(rad),p.x*sin(rad)+p.y*cos(rad));\n}\nLD det(P a,P b,P c){\n\treturn (b-a)*(c-a);\n}\nP intersect(P a,P b,P c,P d){\n\tLD s1=det(a,b,c);\n\tLD s2=det(a,b,d);\n\treturn (d*s1-c*s2)/(s1-s2);\n}\nstruct L{\n\tP a,b;\n\tP v(){return b-a;}\n\tL(){}\n\tL(P a,P b):a(a),b(b){}\n}l[maxn];\nbool operator==(L a,L b){\n\treturn a.a==b.a&&a.b==b.b;\n}\nbool operator<(L a,L b){\n\treturn !(a.a==b.a)?a.a<b.a:a.b<b.b;\n}\nP intersect(L l1,L l2){\n\treturn intersect(l1.a,l1.b,l2.a,l2.b);\n}\nbool parallel(P a,P b){\n\treturn !sgn(a*b);\n}\nL Rev(L l){\n\tl.b=l.a+l.v().turn90();\n\treturn l;\n}\nint n;\nL binary(L l1,L l2){\n\tL ans;\n\tif(parallel(l1.v(),l2.v())){\n\t\tP v=l1.v().turn90();\n\t\tL newl=L(l1.a,l1.a+v);\n\t\tP p=intersect(newl,l2);\n\t\tans.a=(l1.a+p)/2.0;\n\t\tans.b=ans.a+l1.v();\n\t}else{\n\t\tP e1=l1.v()*10000.0/l1.v().len();\n\t\tP e2=l2.v()*10000.0/l2.v().len();\n\t\tP p=intersect(l1,l2);\n\t\tans.a=p;\n\t\tans.b=p+e1+e2;\n\t}\n\treturn ans;\n}\nbool Online(P p,L l){\n\treturn sgn((p-l.a)*(l.b-l.a))==0;\n}\nvector<L>ansL;\nvector<P>ansP;\nvoid Intersec(L l){\n\tvector<L>tmpL;\n\tvector<P>tmpP;\n\t\n\tfor(int i=0;i<ansP.size();i++){\n\t\tif(Online(ansP[i],l))\t\n\t\t\ttmpP.push_back(ansP[i]);\n\t}\n\t\n\tfor(int i=0;i<ansL.size();i++){\n\t\tif(parallel(ansL[i].v(),l.v())){\n\t\t\tif(Online(l.a,ansL[i])){\n\t\t\t\ttmpL.push_back(ansL[i]);\n\t\t\t}\n\t\t}else{\n\t\t\tP p=intersect(l,ansL[i]);\n\t\t\ttmpP.push_back(p);\n\t\t}\n\t}\n\t\n\tansP=tmpP;\n\tansL=tmpL;\n\tsort(ansP.begin(),ansP.end());\n\tansP.erase(unique(ansP.begin(),ansP.end()),ansP.end());\n\tsort(ansL.begin(),ansL.end());\n\tansL.erase(unique(ansL.begin(),ansL.end()),ansL.end());\n}\nvoid Intersec(L l1,L l2){\n\tvector<L>tmpL;\n\tvector<P>tmpP;\n\t\n\tfor(int i=0;i<ansP.size();i++){\n\t\tif(Online(ansP[i],l1) || Online(ansP[i],l2))\t\n\t\t\ttmpP.push_back(ansP[i]);\n\t}\n\t\n\tfor(int i=0;i<ansL.size();i++){\n\t\tif(parallel(ansL[i].v(),l1.v())){\n\t\t\tif(Online(l1.a,ansL[i])){\n\t\t\t\ttmpL.push_back(ansL[i]);\n\t\t\t}\n\t\t}else{\n\t\t\tP p=intersect(l1,ansL[i]);\n\t\t\ttmpP.push_back(p);\n\t\t}\n\t\tif(parallel(ansL[i].v(),l2.v())){\n\t\t\tif(Online(l2.a,ansL[i])){\n\t\t\t\ttmpL.push_back(ansL[i]);\n\t\t\t}\n\t\t}else{\n\t\t\tP p=intersect(l2,ansL[i]);\n\t\t\ttmpP.push_back(p);\n\t\t}\n\t}\n\t\n\tansP=tmpP;\n\tansL=tmpL;\t\n\tsort(ansP.begin(),ansP.end());\n\tansP.erase(unique(ansP.begin(),ansP.end()),ansP.end());\n\tsort(ansL.begin(),ansL.end());\n\tansL.erase(unique(ansL.begin(),ansL.end()),ansL.end());\n}\nvoid printans(){\n\tfor(int i=0;i<ansP.size();i++){\n\t\tprintf(\"(%.3f,%.3f)%c\",(double)ansP[i].x,(double)ansP[i].y,\" \\n\"[i+1==ansP.size()]);\n\t}\n\t\n\tfor(int i=0;i<ansL.size();i++){\n\t\tprintf(\"(%.3f,%.3f)--(%.3f,%.3f)%c\",(double)ansL[i].a.x,(double)ansL[i].a.y,(double)ansL[i].b.x,(double)ansL[i].b.y,\" \\n\"[i+1==ansL.size()]);\n\t}\n\t\n}\nint main(){\n\twhile(scanf(\"%d\",&n)!=-1){\n\t\tif(!n)break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tl[i].a.read();\n\t\t\tl[i].b.read();\n\t\t}\n\t\t\n\t\tif(n<=2){\n\t\t\tputs(\"Many\");\n\t\t\tcontinue;\n\t\t}\n\t\tansL.clear();\n\t\tansP.clear();\n\t\t\n\t\tif(sgn(l[1].v()*l[2].v())==0){\n\t\t\tansL.push_back(binary(l[1],l[2]));\n\t\t}else{\n\t\t\tL li=binary(l[1],l[2]);\n\t\t\tansL.push_back(li);\n\t\t\tli.b=li.a+li.v().turn90();\n\t\t\tansL.push_back(li);\n\t\t}\n\t\t\n\t\t//printans();\n\t\t\n\t\tfor(int i=3;i<=n;i++){\t\t\t\n\t\t\tif(sgn(l[1].v()*l[i].v())==0){\n\t\t\t\tIntersec(binary(l[1],l[i]));\n\t\t\t}else{\n\t\t\t\tL li=binary(l[1],l[i]);\n\t\t\t\tL li2=li;\n\t\t\t\tli2.b=li2.a+li2.v().turn90();\n\t\t\t\tIntersec(li,li2);\n\t\t\t}\n\n\t\t\t//printf(\"ans after %d\\n\",i);\n\t\t\t//printans();\n\n\t\t}\n\t\t\n\t\t\n\t\tif(ansL.empty()&&ansP.empty()){\n\t\t\tputs(\"None\");\n\t\t}else\n\t\tif(!ansL.empty() || ansP.size()>1){\n\t\t\tputs(\"Many\");\n\t\t}else{\n\t\t\tprintf(\"%.8f %.8f\\n\",(double)ansP[0].x,(double)ansP[0].y);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-9;\nconst double pi = acos(-1.0);\nconst double mag = 800;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d)&&eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-4;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\n\t\tif (n <= 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\t/*\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tshuffle(all(bs), mt19937());\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, std::min<int>(bs.size(), 15)) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}();\n\t\t\n\t\t/*\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\t\t\n\t\trep(i, cps.size()) rep(j, i){\n\t\t\tif (cps[i] == cps[j]){\n\t\t\t\tswap(cps[i], cps.back());\n\t\t\t\tcps.pb();\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tcnt++;\n\t\t\t\tres = cps[i];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\t\t\n\t\tPoint res;\n\t\tint cnt = 0;\n\t\tfor (auto cp : cps){\n\t\t\tReal d = distance(l[0], cp);\n\t\t\tbool f = true;\n\t\t\trep(i, n){\n\t\t\t\tif (neq(d, distance(l[i], cp))){\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcnt++;\n\t\t\t\tres = cp;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt >= 2) cout << \"Many\\n\";\n\t\telse if (cnt == 0) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<vector>\n#include<utility>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double eps=1e-5;\n\nint x1[123],y1_[123],x2[123],y2_[123];\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection(P a1,P a2,P b1,P b2){\n  P a=a2-a1;\n  P b=b2-b1;\n  P ab=cross(a,b);\n  if(fabs(ab)<eps)throw 0;\n  return a1+a*cross(b1-a1,b)/ab;\n}\n\nvector<pair<P,P> > bisector(int i,int j){\n  P a1=P(x1[i],y1_[i]),a2=P(x2[i],y2_[i]);\n  P b1=P(x1[j],y1_[j]),b2=P(x2[j],y2_[j]);\n  vector<pair<P,P> > r;\n  try{\n    P c=intersection(a1,a2,b1,b2);\n    P a=a1-a2;\n    P b=b1-b2;\n    P d=a/abs(a)+b/abs(b);\n    r.emplace_back(c,c+d);\n    r.emplace_back(c,c+d*P(0,-1));\n  }catch(...){\n    P m=(a1+b1)/2.;\n    r.emplace_back(m,m+a1-a2);\n  }\n  return r;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x1[i]>>y1_[i]>>x2[i]>>y2_[i];\n    }\n    if(n==1){\n      cout<<\"Many\"<<endl;\n    }else{\n      vector<P> points;\n      vector<pair<P,P> > lines;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<i;j++){\n\t  auto r=bisector(i,j);\n\t  if(i==1&&j==0){\n\t    for(auto e:r){\n\t      lines.push_back(e);\n\t    }\n\t  }else{\n\t    vector<pair<P,P> > nl;\n\t    vector<P> np;\n\t    for(auto e:r){\n\t      for(auto f:lines){\n\t\ttry{\n\t\t  auto cp=intersection(e.first,e.second,f.first,f.second);\n\t\t  np.push_back(cp);\n\t\t}catch(...){\n\t\t  P b=e.second-e.first;\n\t\t  if(fabs(cross(b,f.first-e.first))<eps&&fabs(cross(b,f.second-e.first))<eps){\n\t\t    nl.push_back(e);\n\t\t  }\n\t\t}\n\t      }\n\t      for(auto it=begin(points);it!=end(points);){\n\t\tif(fabs(cross(e.first-e.second,*it-e.second))<eps){\n\t\t  np.push_back(*it);\n\t\t  it=points.erase(it);\n\t\t}else{\n\t\t  ++it;\n\t\t}\n\t      }\n\t    }\n\t    swap(lines,nl);\n\t    swap(points,np);\n\t  }\n\t}\n      }\n      if(!lines.empty()||points.size()>1){\n\tcout<<\"Many\"<<endl;\n      }else if(lines.empty()&&points.empty()){\n\tcout<<\"None\"<<endl;\n      }else{\n\tauto p=*begin(points);\n\tcout<<fixed<<p.real()<<' '<<p.imag()<<endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <set>\nusing namespace std;\n#define EPS (1.0e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n  bool operator == (const Point &p) const {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n  bool operator < (const Point &p) const {\n    if(!equals(x, p.x)) return x < p.x;\n    if(!equals(y, p.y)) return y < p.y;\n    return false;\n  }\n};\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) {\n    this->p1 = p1;\n    this->p2 = p2;\n  }\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Line s1, Line s2) {\n  return isParallel(s1.p2 - s1.p1, s2.p2 - s2.p1);\n}\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\nPoint getCrossPoint(Line s1, Line s2) {\n  Vector a = s1.p2 - s1.p1;\n  Vector b = s2.p2 - s2.p1;\n  double d1 = cross(b, s2.p1 - s1.p1);\n  double d2 = cross(b, a);\n  return s1.p1 + a*d1/d2;\n}\ndouble getDistanceLP(Line s, Point p) {\n  return fabs(cross(s.p2 - s.p1, p - s.p1))/abs(s.p2-s.p1);\n}\n\nVector getOthogonalV(Vector a) {\n  return Vector(-a.y, a.x);\n}\n\nLine getOthogonalL(Line s) {\n  return Line(s.p1, s.p1 + getOthogonalV(s.p2 - s.p1));\n}\n\n\nLine getBisector(Line s1, Line s2) {\n  Vector a = s1.p2 - s1.p1;\n  Vector b = s2.p2 - s2.p1;\n  if(isParallel(a, b)) {\n    double d = cross(a, s2.p1-s1.p1)/abs(a)/2.0;\n    /*double d = getDistanceLP(s1, s2.p1)/2.0;\n    Vector vn;\n    if(ccw(s1.p1, s1.p2, s2.p1) >= 1) {\n      vn.x = -a.y;\n      vn.y = a.x;\n    } else {\n      vn.x = a.y;\n      vn.y = -a.x;\n    }\n    vn = vn*d/abs(vn);\n    return Line(s1.p1 + vn, s1.p2 + vn);*/\n    Vector c = getOthogonalV(a);\n    c = c / abs(c);\n    c = c * d;\n    return Line(s1.p1 + c, s1.p2 + c);\n  } else {\n    Point p = getCrossPoint(s1, s2);\n    return Line(p, p + a + b*sqrt(norm(a)/norm(b)));\n  }\n}\n\n\nint n;\nLine s[100];\n\nvoid make(vector<Line> &v) {\n  for(int i = 1; i < n; ++i) {\n    Line l = getBisector(s[0], s[i]);\n    v.push_back(l);\n    if(!isParallel(s[0], s[i])) {\n      v.push_back(getOthogonalL(l));\n    }\n  }\n}\n\nbool check(Point &p) {\n  double d = getDistanceLP(s[0], p);\n  for(int i = 1; i < n; ++i) {\n    if(!equals(d, getDistanceLP(s[i], p))) return false;\n  }\n  return true;\n}\n\nvoid solve() {\n  if(n <= 2) {\n    cout << \"Many\" << endl;\n    return;\n  }\n\n  vector<Line> bl;\n  make(bl);\n\n  vector<Point> cp;\n  for(int i = 0; i < bl.size(); ++i) {\n    for(int j = i+1; j < bl.size(); ++j) {\n      if(isParallel(bl[i], bl[j])) continue;\n      cp.push_back(getCrossPoint(bl[i], bl[j]));\n    }\n  }\n  sort(cp.begin(), cp.end());\n  cp.erase(unique(cp.begin(), cp.end()), cp.end());\n\n  int count = 0, pos = -1;\n\n  for(int i = 0; i < cp.size(); ++i) {\n    if(check(cp[i])) {\n      count++;\n      if(count == 2) break;\n      pos = i;\n    }\n  }\n\n  switch(count) {\n  case 0: cout << \"None\" << endl; break;\n  case 1: printf(\"%.5f %.5f\\n\", cp[pos].x, cp[pos].y); break;\n  case 2: cout << \"Many\" << endl; break;\n  }\n}\n\nmain() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> s[i].p1.x >> s[i].p1.y >> s[i].p2.x >> s[i].p2.y;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > 1e-7 )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"None\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-8;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\nbool intersect(const line<double> &L1,const line<double> &L2){\n\treturn abs(cross(L1.b-L1.a,L2.b-L2.a))>EPS\n\t\t|| abs(cross(L1.b-L1.a,L2.a-L1.a))<EPS;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<double> &L,const line<double> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tres.push_back((line<double>){(L.a+M.a)/2,(L.a+M.a)/2+(L.b-L.a)});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(L.a==o?L.b:L.a);\n\t\tpoint<double> q=(M.a==o?M.b:M.a);\n\t\tres.push_back((line<double>){o,p+q-o});\n\t\tq+=2.*(o-q);\n\t\tres.push_back((line<double>){o,p+q-o});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<double> L[100];\n\t\trep(i,n) scanf(\"%lf%lf%lf%lf\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\t\tsort(P_cand.begin(),P_cand.end());\n\t\tP_cand.erase(unique(P_cand.begin(),P_cand.end()),P_cand.end());\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist(L[j],p)-dist(L[0],p))>EPS) { ok=false; break; }\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst bool debug = false;\n\ntypedef long double real;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nconst real EPS = 1e-6;\n\nbool EQ(real x, real y) {\n    return abs(x - y) < EPS;\n}\n\nstruct Point {\n    real x, y;\n    Point() {}\n    Point(real x, real y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(real k) const { return Point(k * x, k * y); }\n    Point operator/(real k) const { return Point(x / k, y / k); }\n};\nreal dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\nreal cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\nreal norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nbool EQ(const Point& a, const Point& b) {\n    return EQ(a.x, b.x) && EQ(a.y, b.y);\n}\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n};\nbool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\nistream& operator>>(istream& is, Line& l) { return is >> l.a >> l.b; }\nostream& operator<<(ostream& os, const Line& l) { return os << \"Line(\" << l.a << \",\" << l.b << \")\"; }\n\nPoint projection(const Line& l, const Point& p) {\n    Point u = (p - l.a), v = (l.b - l.a);\n    return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n}\n\nPoint crosspoint(const Line& s, const Line& t) {\n    double d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n}\n\nint N;\nvector<Line> L;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    L.clear(); L.resize(N);\n    for (int i = 0; i < N; i++) cin >> L[i];\n    return true;\n}\n\nPoint unit(const Point& v) {\n    return v / norm(v);\n}\n\nLine rot90(const Line& l, const Point& c) {\n    return Line( rot90(l.a - c) + c, rot90(l.b - c) + c );\n}\n\nvector<Line> midline(const Line& s, const Line& t) {\n    if (parallel(s, t)) {\n        Point p = projection(t, s.a),\n              q = projection(t, s.b);\n        return vector<Line>(1, Line( (s.a + p) / 2, (s.b + q) / 2 ));\n    } else {\n        Point c = crosspoint(s, t);\n        Line ret;\n        Point m = (EQ(s.a, c) ? s.b : s.a);\n        Point p = projection(t, m);\n        real d = norm(m - c);\n        Point q = c + unit(t.b - t.a) * d;\n        ret.a = (m + q) / 2;\n        ret.b = c;\n        vector<Line> lret(2);\n        lret[0] = ret;\n        lret[1] = rot90(ret, c);\n        return lret;\n    }\n}\n\nreal dist(const Line& l, const Point& p) {\n    Point q = projection(l, p);\n    return norm(q - p);\n}\n\nstruct point_comp {\n    bool operator()(const Point& a, const Point& b) {\n        return EQ(a.x, b.x) ? a.y < b.y + EPS : a.x < b.x + EPS;\n    }\n};\n\npair<bool, Point> same_crosspoint() {\n    if (parallel(L[0], L[1])) return make_pair(false, Point(0, 0));\n    Point c = crosspoint(L[0], L[1]);\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (parallel(L[i], L[j]) || !EQ(c, crosspoint(L[i], L[j]))) {\n                return make_pair(false, Point(0, 0));\n            }\n        }\n    }\n    return make_pair(true, c);\n}\n\nvoid solve() {\n    if (N <= 2) {\n        cout << \"Many\" << endl;\n        return;\n    }\n\n    pair<bool, Point> p = same_crosspoint();\n    if (p.first) {\n        printf(\"%.12Lf %.12Lf\\n\", p.second.x, p.second.y);\n        return;\n    }\n\n    vector<Line> X, Y;\n    X = midline(L[0], L[1]);\n    Y = midline(L[1], L[2]);\n\n    vector<Point> C;\n\n    for (int i = 0; i < X.size(); i++) {\n        for (int j = 0; j < Y.size(); j++) {\n            if (parallel(X[i], Y[j])) continue;\n            C.push_back(crosspoint(X[i], Y[j]));\n        }\n    }\n\n    if (debug) {\n        cerr << \"X: \" << X << endl;\n        cerr << \"Y: \" << Y << endl;\n        cerr << \"C: \" << C << endl;\n    }\n    \n    if (C.empty()) {\n        cout << \"None\" << endl;\n        return;\n    }\n\n    vector<Point> ans;\n    for (int i = 0; i < C.size(); i++) {\n        Point p = C[i];\n        real d = dist(L[0], p);\n        for (int i = 0; i < N; i++) {\n            if (!EQ(dist(L[i], p), d)) {\n                goto next;\n            }\n        }\n        ans.push_back(p);\n        next:;\n    }\n\n    if (ans.size() >= 2) {\n        cout << \"Many\" << endl;\n    } else if (ans.empty()) {\n        cout << \"None\" << endl;\n    } else {\n        printf(\"%.12Lf %.12Lf\\n\", ans[0].x, ans[0].y);\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-8;\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double x, double y) : x(x), y(y) {}\n};\ndouble sqr(double x) { return x * x; }\npoint operator + (const point& p1, const point& p2) { return point(p1.x + p2.x, p1.y + p2.y); }\npoint operator - (const point& p1, const point& p2) { return point(p1.x - p2.x, p1.y - p2.y); }\npoint operator * (const point& p1, double d) { return point(p1.x * d, p1.y * d); }\npoint operator / (const point& p1, double d) { return point(p1.x / d, p1.y / d); }\nint dcmp(double x) { return fabs(x) <= eps ? 0 : (x > 0 ? 1 : -1); }\ndouble det(point p1, point p2) { return p1.x * p2.y - p1.y * p2.x; }\ndouble dist(point p1, point p2) { return sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y)); }\npoint nor(point p) { return p / sqrt(sqr(p.x) + sqr(p.y)); }\n\n\nint size = 0, n;\npoint a[10001], b[10001];\nbool mark[20001];\npair<point, point> p[20001][2];\nint c[100001];\nbool bb[100001];\npoint ans[10001];\npoint stk[100001];\n\npoint inter(point p, point v, point q, point w) {\n\tpoint u = p - q;\n\tdouble t = det(w, u) / det(v, w);\n\treturn p + v * t;\n}\n\ndouble D(point p, point p1, point p2) {\n\treturn fabs(det(p - p1, p - p2)) / dist(p1, p2);\n}\n\nbool Online(point o, point x, point y) {\n\treturn dcmp(det(y - x, y - o)) == 0;\n}\n\nbool cmp(const point& p1, const point& p2) {\n\tif (dcmp(p1.x - p2.x)) return p1.x < p2.x;\n\treturn p1.y < p2.y;\n}\n\nbool operator == (const point& p1, const point& p2) { return dcmp(p1.x - p2.x) == 0 && dcmp(p1.y - p2.y) == 0; }\nint main( ) {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%lf %lf\", &a[i].x, &a[i].y);\n\t\t\tscanf(\"%lf %lf\", &b[i].x, &b[i].y);\n\t\t}\n\t\tif (n <= 2) { printf(\"Many\\n\"); continue; }\n\t\tfor (int i = 1; i <= 2; i ++) {\n\t\t\tif (dcmp(det(b[i] - a[i], b[i + 1] - a[i + 1])) == 0) \n\t\t\t\tp[i][0] = make_pair((a[i] + a[i + 1]) / 2., (a[i] + a[i + 1]) / 2. + (b[i] - a[i]));\n\t\t\telse {\n\t\t\t\tpoint o = inter(a[i], b[i] - a[i], a[i + 1], b[i + 1] - a[i + 1]);\n\t\t\t\tp[i][0] = make_pair(o, o + (nor(b[i] - a[i]) + nor(b[i + 1] - a[i + 1])) * 0.5);\n\t\t\t\tp[i][1] = make_pair(o, o + (nor(a[i] - b[i]) + nor(b[i + 1] - a[i + 1])) * 0.5);\n\t\t\t}\n\t\t}\n\n\t\tsize = 0;\n\t\tfor (int i = 0; i < 2; i ++)\n\t\t\tfor (int j = 0; j < 2; j ++) {\n\t\t\t\tpoint x = p[1][i].second - p[1][i].first;\n\t\t\t\tpoint y = p[2][j].second - p[2][j].first;\n\n\t\t\t\tif (dcmp(det(x, y)) == 0) continue;\n\t\t\t\telse \n\t\t\t\t\tans[++ size] = inter(p[1][i].first, p[1][i].second - p[1][i].first, p[2][j].first, p[2][j].second - p[2][j].first);\n\t\t\t}\n\t\tif (size == 0) printf(\"None\\n\");\n\t\telse {\n\t\t\tint num = 0;\n\t\t\tfor (int i = 1; i <= size; i ++) {\n\t\t\t\tbool flag = false;\n\t\t\t\tfor (int j = 2; j <= n; ++ j)\n\t\t\t\t\tif (dcmp(D(ans[i], a[j], b[j]) - D(ans[i], a[1], b[1]))) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == false) stk[++ num] = ans[i];\n\t\t\t}\n\t\t\tsort(stk + 1, stk + 1 + num, cmp);\n\t\t\tnum = (int )(unique(stk + 1, stk + 1 + num) - stk) - 1;\n\t\t\tif (num == 0) printf(\"None\\n\");\n\t\t\telse if (num > 1) printf(\"Many\\n\");\n\t\t\telse printf(\"%.10f %.10f\\n\", stk[1].x, stk[1].y);\n\t\t\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-3;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    if(sign(cross(vec1, vec2)) == 0){\n        res.push_back(Line((l[0] + m[0]) / 2.0, (l[1] + m[1]) / 2.0));\n    }else{\n        Point p = crosspointLL(l, m);\n        res.push_back(Line(p, p + vec1 + vec2));\n        res.push_back(Line(p, p + vec1 - vec2));\n    }\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 1; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n            //if(paralell(lines[i], lines[j])) continue;\n        vector<Line> mids = get_midline(lines[0], lines[i]);\n        midlines.insert(midlines.end(), mids.begin(), mids.end());\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 1; k < lines.size(); k++){\n                if(sign(distanceLP(lines[k], p) - distanceLP(lines[k - 1], p)) != 0){\n                    ok = false;\n                    break;\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.9f %.9f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5) - Point((s[1] + t[1])*0.5)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5), Point((s[1] + t[0])*0.5));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5), Point((s[1] + t[1])*0.5));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n\tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0 - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > 3e-5)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-6;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#define eps 1e-6\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ntypedef pair<vec2d, vec2d> Line;\n\nbool isOnL(Line l, vec2d x)\n{\n\treturn fabs((l.first-x).cross(l.second-x)) < eps;\n}\n\nvec2d getCrossPoint(Line l, Line m)\n{\n\tvec2d p = l.first, q = l.second, r = m.first, s = m.second;\n\t\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\treturn p + (q-p)*t;\n}\n\nint n;\nvec2d p[105], q[105];\nint type;\nvector<Line> lvec;\nvector<vec2d> pvec;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y;\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttype = 0;\n\t\tvector<Line> tmp;\n\t\tlvec.clear(), pvec.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\ttmp.clear();\n\t\t\t\tif((p[i]-q[i]).cross(p[j]-q[j]) == 0){\n\t\t\t\t\tvec2d v1, v2;\n\t\t\t\t\tv1 = (p[i]+p[j])*0.5, v2 = (q[i]+q[j])*0.5;\n\t\t\t\t\tif( fabs(v1.x - v2.x) < eps && fabs(v1.y - v2.y) < eps ){\n\t\t\t\t\t\ttmp.push_back(make_pair((p[i]+q[j])*0.5, (q[i]+p[j])*0.5));\n\t\t\t\t\t}\n\t\t\t\t\telse tmp.push_back(make_pair(v1, v2));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble ang = atan2((p[i]-q[i]).y, (p[i]-q[i]).x);\n\t\t\t\t\tdouble ang2 = atan2((p[j]-q[j]).y, (p[j]-q[j]).x);\n\t\t\t\t\tvec2d v1 = vec2d(cos((ang+ang2)/2), sin((ang+ang2)/2));\n\t\t\t\t\tvec2d v2 = vec2d(cos((ang+ang2+M_PI)/2), sin((ang+ang2+M_PI)/2));\n\t\t\t\t\tvec2d x = getCrossPoint(make_pair(p[i], q[i]), make_pair(p[j], q[j]));\n\t\t\t\t\ttmp.push_back(make_pair(x, v1 + x));\n\t\t\t\t\ttmp.push_back(make_pair(x, v2 + x));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << i << \"  \" << j << endl;\n\t\t\t\tfor(int i = 0; i < tmp.size(); i++){\n\t\t\t\t\tcout << tmp[i].first.x << \" \" << tmp[i].first.y << \" \" << tmp[i].second.x << \" \" << tmp[i].second.y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t\t\n\t\t\t\tif(type == 0){\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tlvec = tmp;\n\t\t\t\t}\n\t\t\t\telse if(type == 1){\n\t\t\t\t\tvector<Line> nlvec;\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < lvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(lvec[i], tmp[j].first) && isOnL(lvec[i], tmp[j].second)) nlvec.push_back(lvec[i]);\n\t\t\t\t\t\t\telse if((lvec[i].first - lvec[i].second).cross(tmp[j].first - tmp[j].second) == 0) continue;\n\t\t\t\t\t\t\telse npvec.push_back(getCrossPoint(lvec[i], tmp[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nlvec.size()) lvec = nlvec;\n\t\t\t\t\telse if(npvec.size()){\n\t\t\t\t\t\ttype = 2;\n\t\t\t\t\t\tpvec.clear();\n\t\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type == 2){\n\t\t\t\t\tvector<vec2d> npvec;\n\t\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\t\tfor(int j = 0; j < tmp.size(); j++){\n\t\t\t\t\t\t\tif(isOnL(tmp[j], pvec[i])){\n\t\t\t\t\t\t\t\tnpvec.push_back(pvec[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpvec.clear();\n\t\t\t\t\tfor(int i = 0; i < npvec.size(); i++){\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int j = 0; j < pvec.size(); j++){\n\t\t\t\t\t\t\tif( fabs(pvec[i].x - npvec[j].x) < eps && fabs(pvec[i].y - npvec[j].y) < eps ){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag) pvec.push_back(npvec[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << type << endl;\n\t\t\t\tfor(int i = 0; i < pvec.size(); i++){\n\t\t\t\t\tcout << pvec[i].x << \" \" << pvec[i].y << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(type < 2) cout << \"Many\" << endl;\n\t\telse{\n\t\t\tif(pvec.size() > 1) cout << \"Many\" << endl;\n\t\t\telse if(pvec.size() == 0) cout << \"None\" << endl;\n\t\t\telse{\n\t\t\t\tprintf(\"%.11f %.11f\\n\", pvec[0].x, pvec[0].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-5;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<eps;\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<vector>\n#include<utility>\n#include<unordered_set>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double eps=1e-9;\n\nint x1[123],y1_[123],x2[123],y2_[123];\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection(P a1,P a2,P b1,P b2){\n  P a=a2-a1;\n  P b=b2-b1;\n  P ab=cross(a,b);\n  if(fabs(ab)<eps)throw 0;\n  return a1+a*cross(b1-a1,b)/ab;\n}\n\nvector<pair<P,P> > bisector(int i,int j){\n  P a1=P(x1[i],y1_[i]),a2=P(x2[i],y2_[i]);\n  P b1=P(x1[j],y1_[j]),b2=P(x2[j],y2_[j]);\n  vector<pair<P,P> > r;\n  try{\n    P c=intersection(a1,a2,b1,b2);\n    P a=a1-a2;\n    P b=b1-b2;\n    P d=a/abs(a)+b/abs(b);\n    r.emplace_back(c,c+d);\n    r.emplace_back(c,c+d*P(0,-1));\n  }catch(...){\n    P m=(a1+b1)/2.;\n    r.emplace_back(m,m+a1-a2);\n  }\n  return r;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x1[i]>>y1_[i]>>x2[i]>>y2_[i];\n    }\n    if(n==1){\n      cout<<\"Many\"<<endl;\n    }else{\n      vector<P> points;\n      vector<pair<P,P> > lines;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<i;j++){\n\t  auto r=bisector(i,j);\n\t  if(i==1&&j==0){\n\t    for(auto e:r){\n\t      lines.push_back(e);\n\t    }\n\t  }else{\n\t    vector<pair<P,P> > nl;\n\t    vector<P> np;\n\t    for(auto e:r){\n\t      for(auto f:lines){\n\t\ttry{\n\t\t  auto cp=intersection(e.first,e.second,f.first,f.second);\n\t\t  np.push_back(cp);\n\t\t}catch(...){\n\t\t  P b=e.second-e.first;\n\t\t  if(fabs(cross(b,f.first-e.first))<eps&&fabs(cross(b,f.second-e.first))<eps){\n\t\t    nl.push_back(e);\n\t\t  }\n\t\t}\n\t      }\n\t      for(auto it=begin(points);it!=end(points);){\n\t\tif(fabs(cross(e.first-e.second,*it-e.second))<eps){\n\t\t  np.push_back(*it);\n\t\t  it=points.erase(it);\n\t\t}else{\n\t\t  ++it;\n\t\t}\n\t      }\n\t    }\n\t    swap(lines,nl);\n\t    swap(points,np);\n\t  }\n\t}\n      }\n      if(!lines.empty()||points.size()>1){\n\tcout<<\"Many\"<<endl;\n      }else if(lines.empty()&&points.empty()){\n\tcout<<\"None\"<<endl;\n      }else{\n\tauto p=*begin(points);\n\tcout<<fixed<<p.real()<<' '<<p.imag()<<endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad テ」ツ?ッティツァツ津・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテヲツ個?」ツ?淌」ツ?崚」ツつ凝」ツ?禿」ツ?ィ\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// テ・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev テ」ツ?凝」ツつ?cur テ」ツ?クティツ。ツ古」ツ?」テ」ツ?ヲ next テ」ツ?クティツ。ツ古」ツ?湘ゥツ堋崚」ツ?ョティツァツ津・ツコツヲテ」ツつ津ヲツアツづ」ツつ?」ツつ?\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //テ・ツ青古」ツ?佚」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗」ツ?凝」ツつづ」ツつ?\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\n// ------------------\n\ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n\nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n\n  int res = ccw(cp,p1,p2);\n  while( !( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n\nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n\n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n\n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n  }\n  \n  vector<Point> candidatePoints;\n\n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n\n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n\n\n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n\n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n\nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-8)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/(long double)2.0,\n                       (V[0].second+V[j].second)/(long double)2.0);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > 0){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\n#define PI (4.0*atan(1.0))\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P,i) - curr(P,i))\nenum { OUT, ON, IN };\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<L> bisector(const L &l, const L &m){\n\tvector<L> res;\n\tif(intersectLL(l,m)){\n\t\tP p=crosspoint(l,m);\n\t\tP q=(l[1]-l[0])/abs(l[1]-l[0])\n\t\t+ (m[1]-m[0])/abs(m[1]-m[0]);\n\t\tP r=(l[1]-l[0])/abs(l[1]-l[0])\n\t\t+ (m[0]-m[1])/abs(m[0]-m[1]);\n\t\tres.pb(L(p,p+q));\n\t\tres.pb(L(p,p+r));\n\t\treturn res;\n\t}\n\telse{\n\t\tP p=projection(l,m[0]);\n\t\tP q=(m[0]+p)*0.5;\n\t\tres.pb(L(q,q+l[1]-l[0]));\n\t\treturn res;\n\t}\n}\n\nint n;\nL line[111];\n\nint main(){\n\twhile(cin>>n && n){\n\t\trep(i,n){\n\t\t\tint x,y,xx,yy;\n\t\t\tcin>>x>>y>>xx>>yy;\n\t\t\tline[i].pb(P(x,y));\n\t\t\tline[i].pb(P(xx,yy));\n\t\t}\n\t\tif(n<=2){\n\t\t\tcout<<\"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> bisec01=bisector(line[0],line[1]),\n\t\tbisec02=bisector(line[0],line[2]);\n\t\tP ans(INF,INF);\n\t\trep(i,bisec01.sz)rep(j,bisec02.sz){\n\t\t\tif(intersectLL(bisec01[i],bisec02[j])){\n\t\t\t\tP p=crosspoint(bisec01[i],bisec02[j]);\n\t\t\t\tdouble dist=distanceLP(line[0],p);\n\t\t\t\trep2(k,3,n){\n\t\t\t\t\tif((distanceLP(line[k],p)-dist)>EPS){\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(abs(ans-p)>EPS){\n\t\t\t\t\tif(abs(ans)>INF){\n\t\t\t\t\t\tans=p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout<<\"Many\\n\";\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfail:;\n\t\t\t}\n\t\t}\n\t\tif(abs(ans)>INF)cout<<\"None\\n\";\n\t\telse cout<<ans.real()<<\" \"<<ans.imag()<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n \nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n \ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n \nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nvector<L> equidist(const L &a, const L &b){\n    vector<L> ret;\n    if(isParallel(a, b)){\n        P mid = (a[0]+b[0])/2.0;\n        ret.push_back( L(mid, mid+(a[1]-a[0])) );\n    }else{\n        P cp = crosspointLL(a, b);\n        P v1 = unit(a[1]-a[0]), v2 = unit(b[1]-b[0]);\n        ret.push_back( L(cp, cp+ (v1+v2)/2.0) );\n        ret.push_back( L(cp, cp+ (v1-v2)/2.0) );\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n         \n        vector<L> l(n);\n        for(int i=0; i<n; i++){\n            int x1,y1,x2,y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            l[i] = L(P(x1,y1), P(x2,y2));\n        }\n\n        if(n < 3){\n            cout << \"Many\" << endl;\n            continue;\n        }else if(isParallel(l[0], l[1]) && isParallel(l[1], l[2])){\n            cout << \"None\" << endl;\n            continue;\n        }\n\n        vector<L> ml;\n        for(int i=0; i<3; i++){\n            vector<L> cl = equidist(l[i], l[(i+1)%3]);\n            copy(cl.begin(), cl.end(), back_inserter(ml));\n        }\n        VP cand;\n        for(int i=0; i<(int)ml.size(); i++){\n            for(int j=i+1; j<(int)ml.size(); j++){\n                if(!isParallel(ml[i], ml[j])){\n                    cand.push_back(crosspointLL(ml[i], ml[j]));\n                }\n            }\n        }\n        sort(cand.begin(), cand.end());\n        cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n        int count = 0;\n        P ans;\n        for(int i=0; i<(int)cand.size(); i++){\n            bool success = true;\n            double dist = distanceLP(l[0], cand[i]);\n            for(int j=1; j<n; j++){\n                if(!EQ(dist, distanceLP(l[j], cand[i]))){\n                    success = false;\n                    break;\n                }\n            }\n            if(success){\n                count++;\n                ans = cand[i];\n            }\n        }\n\n        if(count==0){\n            cout << \"None\" << endl;\n        }else if(count >= 2){\n            cout << \"Many\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(3);\n            cout << ans.X << \" \" << ans.Y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/(long double)2.0,\n                       (V[0].second+V[j].second)/(long double)2.0);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.size() == 0) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    /*\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    */\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      cout << c << endl;\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const double EPS=1e-9;\nconst double EPS=1e-10;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){x+=p.x,y+=p.y; return *this;}\n\tPoint& operator-=(Point p){x-=p.x,y-=p.y; return *this;}\n\tPoint& operator*=(double c){x*=c,y*=c; return *this;}\n\tPoint& operator/=(double c){x/=c,y/=c; return *this;}\n};\nPoint operator+(Point a,Point b){return a+=b;}\nPoint operator-(Point a,Point b){return a-=b;}\nPoint operator*(Point a,double c){return a*=c;}\nPoint operator*(double c,Point a){return a*=c;}\nPoint operator/(Point a,double c){return a/=c;}\nbool operator==(Point a,Point b){return abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n};\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\n\ndouble DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\n\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS) return a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\n\nbool Parallel(Line a,Line b){\n\treturn abs(Cross(a.dir,b.dir))<EPS;\n}\n\nvector<Line> EquidistantLine(Line a,Line b){\n\tif(Parallel(a,b))\n\t\treturn {Line((a.pos+b.pos)/2,a.dir)};\n\tPoint p=InterPointLL(a,b);\n\ta.dir/=Abs(a.dir),b.dir/=Abs(b.dir);\n\treturn {Line(p,(a.dir+b.dir)/2),Line(p,(a.dir-b.dir)/2)};\n}\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\n\nstring solve(vector<Line> ls)\n{\n\tint n=ls.size();\n\tif(n<=2) return \"Many\"; // trivial case\n\t\n\tLine a=ls[0],b=ls[1],c=ls[2];\n\tif(Parallel(a,b) && Parallel(b,c))\n\t\treturn \"None\";\n\t\n\t// 平行な直線があるなら，aとbがそうであるようにする\n\tif(Parallel(a,c)) swap(b,c);\n\tif(Parallel(b,c)) swap(a,c);\n\t\n\tvector<Point> ps;\n\tif(Parallel(a,b)){\n\t\tLine l=EquidistantLine(a,b)[0];\n\t\tauto els=EquidistantLine(a,c);\n\t\tps.push_back(InterPointLL(l,els[0]));\n\t\tps.push_back(InterPointLL(l,els[1]));\n\t}\n\telse{\n\t\tfor(auto l1:EquidistantLine(a,b))\n\t\t\tfor(auto l2:EquidistantLine(a,c))\n\t\t\t\tps.push_back(InterPointLL(l1,l2));\n\t}\n\tsort(all(ps),[](Point a,Point b){return abs(a.x-b.x)>EPS?a.x<b.x:a.y<b.y;});\n\tps.erase(unique(all(ps)),end(ps));\n\t\n\tvector<Point> qs;\n\tfor(auto p:ps){\n\t\tbool ok=true;\n\t\trep(i,ls.size()) ok&=abs(DistLP(ls[i],p)-DistLP(ls[0],p))<EPS;\n\t\tif(ok) qs.push_back(p);\n\t}\n\t\n\tif(qs.size()==0) return \"None\";\n\tif(qs.size()>=2) return \"Many\";\n\treturn to_string(qs[0].x)+\" \"+to_string(qs[0].y);\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<Line> ls(n);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;\n\t\t\tls[i]=Line(x1,y1,x2-x1,y2-y1);\n\t\t}\n\t\tcout<<solve(ls)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  //  rep(i,b.size()&&cnt<2){\n  int i=0;\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n\tif ((cnt==0||!(EQV(ans,cand))) && check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n    //}\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = i + 1; j < s.size(); ++j) {\n\t\t\tif (isis_ss( s[i],  s[j])) {\n\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <s.size(); ++i) {\n\t\tcrss.push_back( s[i][0]);\n\t\tcrss.push_back( s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif ((adis - dis) > eps)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = p + bisvec / (abs(bis[1] - bis[0]))*dis;\n\t\t\t\tPoint kouho2 = p - bisvec / (abs(bis[1] - bis[0]))*dis;\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-5)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(all(vp));\n  res.pb(vp[0]);\n  FOR(i,1,vp.size())if(!(vp[i]==res.back()))res.pb(vp[i]);\n  return res;\n}\n\ntypedef pair<Line,Line> pll;\n\nint n;\nvector<Segment> vs;\nvector<Point> vp;\n\nbool check2(Point p){\n  double dis=getDistanceLP(vs[0],p);\n  FOR(i,1,n)\n    if(!equals(dis,getDistanceLP(vs[i],p)))return false;\n  return true;\n}\n\nvoid check1(Line a,Line b,Line c){\n  Point d=getCrossPointLL(a,c),e=getCrossPointLL(b,c);\n  Point m=d+(e-d)/2.0;\n  double dis=getDistanceLP(a,m);\n  Vector v=a.p1-a.p2;\n  v=v*dis/abs(v);\n  if(check2(m+v))vp.pb(m+v);\n  if(check2(m-v))vp.pb(m-v);\n  return;\n}\n\nvoid check3(pll a,pll b){\n  if(!isParallel(a.f,b.f)){\n    Point c=getCrossPointLL(a.f,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.f,b.s)){\n    Point c=getCrossPointLL(a.f,b.s);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.f)){\n    Point c=getCrossPointLL(a.s,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.s)){\n    Point c=getCrossPointLL(a.s,b.s);\n    if(check2(c))vp.pb(c);\n  }\n}\npair<Line,Line> getS(Line a,Line b){\n  Point m=getCrossPointLL(a,b);\n  double r=getAngle(a.p1-a.p2,b.p1-b.p2);\n  Line c(rotate(m,a.p1,r/2.0),rotate(m,a.p2,r/2.0));\n  Line d(rotate(m,a.p1,(180-r)/2.0),rotate(m,a.p2,(180-r)/2.0));\n  return mp(c,d);\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      FOR(k,j+1,n){\n        if(isParallel(vs[i],vs[j]) && isParallel(vs[i],vs[k]))continue;\n        if(isParallel(vs[i],vs[j]))check1(vs[i],vs[j],vs[k]);\n        else if(isParallel(vs[i],vs[k]))check1(vs[i],vs[k],vs[j]);\n        else if(isParallel(vs[j],vs[k]))check1(vs[j],vs[k],vs[i]);\n        else {\n          pll a=getS(vs[i],vs[j]);\n          pll b=getS(vs[j],vs[k]);\n          pll c=getS(vs[k],vs[i]);\n          check3(a,b);\n          check3(b,c);\n          check3(c,a);\n        }\n      }\n    }\n  }\n  vp=unique(vp);\n  if(vp.empty())cout<<\"None\"<<endl;\n  else if(vp.size()>1)cout<<\"Many\"<<endl;\n  else printf(\"%.10f %.10f\\n\",vp[0].x,vp[0].y);\n  return;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    vs.clear();\n    vp.clear();\n    FOR(i,0,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      vs.pb(Segment(Point(a,b),Point(c,d)));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-6)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    if(n <= 2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector< vector<Line> > bilines;\n    rep(i, n) reps(j, i+1, n) {\n      Line l = lines[i], r = lines[j];\n      Vector lv = l.p2 - l.p1, rv = r.p2 - r.p1;\n      lv = lv / abs(lv); rv = rv / abs(rv);\n      vector<Line> bi;\n      if(isParallel(l, r)) {\n\tPoint o = (l.p1+r.p1)/2;\n\tLine m = Line(o, o + lv);\n\tbi.push_back(m);\n\tbilines.push_back(bi);\n      } else {\n\tPoint p = getCrossPointLL(l, r);\n\tLine v = Line(p, p + lv + rv);\n\tLine w = Line(p, p + lv - rv);\n\tbi.push_back(v);\n\tbi.push_back(w);\n\tbilines.push_back(bi);\n      }\n    }\n    vector<Point> ans;\n    rep(i, min((int)bilines.size(), 10LL)) {\n      reps(j, i+1, min((int)bilines.size(), 10LL)) {\n\tvector<Line> a = bilines[i], b = bilines[j];\n\trep(k, a.size()) rep(l, b.size()) {\n\t  if(isParallel(a[k], b[l])) continue;\n\t  bool flag = true;\n\t  Point cp = getCrossPointLL(a[k], b[l]);\n\t  //cout<<cp.x<<\" \"<<cp.y<<endl;\n\t  double dist = getDistanceLP(lines[0], cp);\n\t  rep(x, n) {\n\t    //cout<<dist<< \" \"<< getDistanceLP(lines[x], cp) << endl;\n\t    if(!eq(dist, getDistanceLP(lines[x], cp))) flag = false;\n\t  }\n\t  rep(x, ans.size()) {\n\t    if(eq(abs(ans[x]-cp), 0)) flag = false;\n\t  }\n\t  if(flag) ans.push_back(cp);\n\t}\n      }\n    }\n    if(ans.size() == 0) cout << \"None\" << endl;\n    else if(ans.size() == 1) {\n      cout << ans[0].x << \" \" << ans[0].y << endl;\n    }\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nint  makeall(vector<Line> &a,vector<Line> &b){\n  int ret=0;\n  //rep(i,1&&a.size()){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }\n    }\n    if (i == 0)ret=b.size();\n  }\n  return ret;\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  int p=makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,p&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n\tif (cnt == 1 && EQV(ans,cand))continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n        C.push_back(A.back().first);\n        C.push_back(A.back().second);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-13, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n\tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > 3e-5)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-6;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n\toperator point<double>()const{ return (point<double>){x,y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a,b;\n\toperator line<double>()const{ return (line<double>){a,b}; }\n};\n\ntemplate<class T>\nbool intersect(const line<T> &L1,const line<T> &L2){\n\treturn cross(L1.b-L1.a,L2.b-L2.a)!=0  // L1 と L2 が平行でない\n\t\t|| cross(L1.b-L1.a,L2.a-L1.a)==0; // L1 == L2\n}\n\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1,const line<T> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(a1==0) return L1.a; // L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<int> &L,const line<int> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tpoint<double> o=(L.a+M.a)/2;\n\t\tres.push_back((line<double>){o,o+(point<double>)(L.b-L.a)});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(point<double>)(L.a==o?L.b:L.a)-o;\n\t\tpoint<double> q=(point<double>)(M.a==o?M.b:M.a)-o;\n\t\tp/=abs(p);\n\t\tq/=abs(q);\n\t\tres.push_back((line<double>){o,o+p+q});\n\t\tres.push_back((line<double>){o,o+p-q});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<int> L[100];\n\t\trep(i,n) scanf(\"%d%d%d%d\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\t\tsort(P_cand.begin(),P_cand.end());\n\t\tP_cand.erase(unique(P_cand.begin(),P_cand.end()),P_cand.end());\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist((line<double>)L[j],p)-dist((line<double>)L[0],p))>EPS) {\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst bool debug = false;\n\ntypedef long double real;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nconst real EPS = 1e-6;\n\nbool EQ(real x, real y) {\n    return abs(x - y) < EPS;\n}\n\nstruct Point {\n    real x, y;\n    Point() {}\n    Point(real x, real y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(real k) const { return Point(k * x, k * y); }\n    Point operator/(real k) const { return Point(x / k, y / k); }\n};\nreal dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\nreal cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\nreal norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nbool EQ(const Point& a, const Point& b) {\n    return EQ(a.x, b.x) && EQ(a.y, b.y);\n}\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n};\nbool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\nistream& operator>>(istream& is, Line& l) { return is >> l.a >> l.b; }\nostream& operator<<(ostream& os, const Line& l) { return os << \"Line(\" << l.a << \",\" << l.b << \")\"; }\n\nPoint projection(const Line& l, const Point& p) {\n    Point u = (p - l.a), v = (l.b - l.a);\n    return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n}\n\nPoint crosspoint(const Line& s, const Line& t) {\n    double d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n}\n\nint N;\nvector<Line> L;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    L.clear(); L.resize(N);\n    for (int i = 0; i < N; i++) cin >> L[i];\n    return true;\n}\n\nPoint unit(const Point& v) {\n    return v / norm(v);\n}\n\nLine rot90(const Line& l, const Point& c) {\n    return Line( rot90(l.a - c) + c, rot90(l.b - c) + c );\n}\n\nvector<Line> midline(const Line& s, const Line& t) {\n    if (parallel(s, t)) {\n        Point p = projection(t, s.a),\n              q = projection(t, s.b);\n        return vector<Line>(1, Line( (s.a + p) / 2, (s.b + q) / 2 ));\n    } else {\n        Point c = crosspoint(s, t);\n        Line ret;\n        Point p = projection(t, s.a);\n        real d = norm(s.a - c);\n        Point q = c + unit(t.b - t.a) * d;\n        ret.a = (s.a + q) / 2;\n\n        p = projection(t, s.b);\n        d = norm(s.b - c);\n        q = c + unit(t.b - t.a) * d;\n        ret.b = (s.b + q) / 2;\n        vector<Line> lret(2);\n        lret[0] = ret;\n        lret[1] = rot90(ret, c);\n        return lret;\n    }\n}\n\nreal dist(const Line& l, const Point& p) {\n    Point q = projection(l, p);\n    return norm(q - p);\n}\n\nvoid solve() {\n    if (N <= 2) {\n        cout << \"Many\" << endl;\n        return;\n    }\n\n    vector<Line> X, Y;\n    X = midline(L[0], L[1]);\n    Y = midline(L[1], L[2]);\n\n    vector<Point> C;\n\n    for (int i = 0; i < X.size(); i++) {\n        for (int j = 0; j < Y.size(); j++) {\n            if (parallel(X[i], Y[j])) continue;\n            C.push_back(crosspoint(X[i], Y[j]));\n        }\n    }\n\n    if (debug) {\n        cerr << \"X: \" << X << endl;\n        cerr << \"Y: \" << Y << endl;\n    }\n    \n    if (C.empty()) {\n        cout << \"None\" << endl;\n        return;\n    }\n\n    vector<Point> ans;\n    for (int i = 0; i < C.size(); i++) {\n        Point p = C[i];\n        real d = dist(L[0], p);\n        for (int i = 0; i < N; i++) {\n            if (!EQ(dist(L[i], p), d)) {\n                goto next;\n            }\n        }\n        ans.push_back(p);\n        next:;\n    }\n\n    if (ans.size() >= 2) {\n        cout << \"Many\" << endl;\n    } else if (ans.empty()) {\n        cout << \"None\" << endl;\n    } else {\n        printf(\"%.12Lf %.12Lf\\n\", ans[0].x, ans[1].y);\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(all(vp));\n  res.pb(vp[0]);\n  FOR(i,1,vp.size())if(!(vp[i]==res.back()))res.pb(vp[i]);\n  return res;\n}\n\nint n;\nvector<Segment> vs;\nvector<Point> vp;\n\nbool check2(Point p){\n  double dis=getDistanceLP(vs[0],p);\n  FOR(i,1,n)\n    if(!equals(dis,getDistanceLP(vs[i],p)))return false;\n  return true;\n}\n\nvoid check1(Line a,Line b,Line c){\n  Point d=getCrossPointLL(a,c),e=getCrossPointLL(b,c);\n  Point m=d+(e-d)/2.0;\n  double dis=getDistanceLP(a,m);\n  Vector v=a.p1-a.p2;\n  v=v*dis/abs(v);\n  if(check2(m+v))vp.pb(m+v);\n  if(check2(m-v))vp.pb(m-v);\n  return;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      FOR(k,j+1,n){\n        if(isParallel(vs[i],vs[j]) && isParallel(vs[i],vs[k]))continue;\n        if(isParallel(vs[i],vs[j]))check1(vs[i],vs[j],vs[k]);\n        else if(isParallel(vs[i],vs[k]))check1(vs[i],vs[k],vs[j]);\n        else if(isParallel(vs[j],vs[k]))check1(vs[j],vs[k],vs[i]);\n        else {\n          Point a=getCrossPointLL(vs[i],vs[j]);\n          Point b=getCrossPointLL(vs[i],vs[k]);\n          Point c=getCrossPointLL(vs[j],vs[k]);\n          if(cross(b-a,c-a)<-eps)swap(b,c);\n          double r1=getAngle(b-a,c-a);\n          double r2=getAngle(c-b,a-b);\n          Line d=Line(a,rotate(a,b,r1/2.0));\n          Line e=Line(b,rotate(b,c,r2/2.0));\n          Point f=getCrossPointLL(d,e);\n          if(check2(f))vp.pb(f);\n        }\n      }\n    }\n  }\n  vp=unique(vp);\n  if(vp.empty())cout<<\"None\"<<endl;\n  else if(vp.size()>1)cout<<\"Many\"<<endl;\n  else printf(\"%.10f %.10f\\n\",vp[0].x,vp[0].y);\n  return;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    vs.clear();\n    vp.clear();\n    FOR(i,0,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      vs.pb(Segment(Point(a,b),Point(c,d)));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-10;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ){\n\t  va = uvec(vl[t].fr-is);\n\t}else{\n\t  va = uvec(vl[t].sc-is);\n\t}\n\t\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\nconst double MAG = 800;\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= MAG;\n      y1 /= MAG;\n      x2 /= MAG;\n      y2 /= MAG;\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t//(ccw(bisector1[i].fr,bisector1[i].sc,bisector2[j].fr) & (OVER|FRONT|BACK)) &&\n\t//(ccw(bisector1[i].fr,bisector1[i].sc,bisector2[j].sc) & (OVER|FRONT|BACK)) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      if(i==1)\n\tbreak;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", MAG*res[0].real(), MAG*res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  //  rep(i,b.size()&&cnt<2){\n  int i=0;\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif ((cnt==0||!(EQV(ans,cand))) && check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n    //  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    if (n == 1||n ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\nbool EQ(double a,double b){\n\treturn fabs(a) < EPS;\n}\nbool GE(double a,double b){\n\treturn a > b - EPS;\n}\nbool LE(double a,double b){\n\treturn a < b + EPS;\n}\n\nint convex_contains(const polygon &P, const point &p) {\n  const int n = P.size();\n  point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n      if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n      else                                                  a = c;\n    } else {\n      if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nbool intersect_1pt(const point& a, const point& b,\n                   const point& c, const point& d, point &r) {\n  double D =  cross(b - a, d - c);\n  if (EQ(D, 0)) return false;\n  double t =  cross(c - a, d - c) / D;\n  double s = -cross(a - c, b - a) / D;\n  r = a + t * (b - a);\n  return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n}\npolygon convex_intersect(const polygon &P, const polygon &Q) {\n  const int n = P.size(), m = Q.size();\n  int a = 0, b = 0, aa = 0, ba = 0;\n  enum { Pin, Qin, Unknown } in = Unknown;\n  polygon R;\n  do {\n    int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n    double C = cross(P[a] - P[a1], Q[b] - Q[b1]);\n    double A = cross(P[a1] - Q[b], P[a] - Q[b]);\n    double B = cross(Q[b1] - P[a], Q[b] - P[a]);\n    point r;\n    if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n      if (in == Unknown) aa = ba = 0;\n      R.push_back( r );\n      in = B > EPS ? Pin : A > EPS ? Qin : in;\n    }\n    if ( abs(C) < EPS && abs(B)<EPS && abs(A) < 0) {\n      if (in == Pin) { b = (b + 1) % m; ++ba; }\n      else           { a = (a + 1) % m; ++aa; }\n    } else if (C >= -EPS) {\n      if (A > EPS) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n      else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n    } else {\n      if (B > EPS) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n      else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n    }\n  } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n  if (in == Unknown) {\n    if (convex_contains(Q, P[0])) return P;\n    if (convex_contains(P, Q[0])) return Q;\n  }\n  return R;\n}\n\n\nvector<L> ls;\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\ndouble PI = acos(-1);\n \n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nG gen(L l,double d){\n\tP f = l[1]-l[0];\n\tf /= abs(f);\n\tP r = f * exp(P(0,PI/2.));\n\tP a = l[0] + r * d;\n\tP b = l[0] - r * d;\n\t\n\tdouble len = 100000;\n\tG g;\n\tg.push_back(a+f*len);\n\tg.push_back(a-f*len);\n\tg.push_back(b+f*len);\n\tg.push_back(b-f*len);\n\t\n\treturn convex_hull(g);\n}\ndouble ok(double d,int f=0){\n\tvector<P> co;\n\t\n\tfor(int i = 0 ; i < ls.size() ; i++){\n\t\tauto v = gen(ls[i],d);\n\t\tif(i==0){\n\t\t\tco = v;\n\t\t}else{\n\t\t\tif( area2(co) < EPS ) co.clear();\n\t\t\tif( co.size() ) co = convex_intersect(co,v);\n\t\t}\n\t}\n\tif(f){\n\t\tprintf(\"%.10lf %.10lf\\n\",co[0].real(),co[0].imag());\n\t}\n\treturn area2(co);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble l = 0, r = 100000;\n\t\t\tif( ok(r) < EPS ){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\t\tdouble m = (l+r)/2.;\n\t\t\t\tif( ok(m) > 0 ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tok(l,1);\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point p = crosspointLL(l, m);\n    res.push_back(Line(p, p + l.vector() + m.vector()));\n    res.push_back(Line(p, p + l.vector() - m.vector()));\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 0; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n        for(int j = i + 1; j < 3; j++){\n            if(paralell(lines[i], lines[j])) continue;\n            vector<Line> mids = get_midline(lines[i], lines[j]);\n            midlines.insert(midlines.end(), mids.begin(), mids.end());\n        }\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        //cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            bool ok = true;\n            for(int k = 1; k < lines.size(); k++){\n                if(sign(distanceLP(lines[k], p) - distanceLP(lines[k - 1], p)) != 0){\n                    ok = false;\n                    break;\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.12f %.12f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-8;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\nbool intersect(const line<double> &L1,const line<double> &L2){\n\treturn abs(cross(L1.b-L1.a,L2.b-L2.a))>EPS\n\t\t|| abs(cross(L1.b-L1.a,L2.a-L1.a))<EPS;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<double> &L,const line<double> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tres.push_back((line<double>){(L.a+M.a)/2,(L.a+M.a)/2+(L.b-L.a)});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(L.a==o?L.b:L.a)-o;\n\t\tpoint<double> q=(M.a==o?M.b:M.a)-o;\n\t\tp/=abs(p);\n\t\tq/=abs(q);\n\t\tres.push_back((line<double>){o,o+p+q});\n\t\tres.push_back((line<double>){o,o+p-q});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<double> L[100];\n\t\trep(i,n) scanf(\"%lf%lf%lf%lf\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\t\tsort(P_cand.begin(),P_cand.end());\n\t\tP_cand.erase(unique(P_cand.begin(),P_cand.end()),P_cand.end());\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist(L[j],p)-dist(L[0],p))>EPS) { ok=false; break; }\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > 1e-7 )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << cp << endl;\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-4)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(all(vp));\n  res.pb(vp[0]);\n  FOR(i,1,vp.size())if(!(vp[i]==res.back()))res.pb(vp[i]);\n  return res;\n}\n\ntypedef pair<Line,Line> pll;\n\nint n;\nvector<Segment> vs;\nvector<Point> vp;\n\nbool check2(Point p){\n  double dis=getDistanceLP(vs[0],p);\n  FOR(i,1,n)\n    if(!equals(dis,getDistanceLP(vs[i],p)))return false;\n  return true;\n}\n\nvoid check1(Line a,Line b,Line c){\n  Point d=getCrossPointLL(a,c),e=getCrossPointLL(b,c);\n  Point m=d+(e-d)/2.0;\n  double dis=getDistanceLP(a,m);\n  Vector v=a.p1-a.p2;\n  v=v*dis/abs(v);\n  if(check2(m+v))vp.pb(m+v);\n  if(check2(m-v))vp.pb(m-v);\n  return;\n}\n\nvoid check3(pll a,pll b){\n  if(!isParallel(a.f,b.f)){\n    Point c=getCrossPointLL(a.f,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.f,b.s)){\n    Point c=getCrossPointLL(a.f,b.s);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.f)){\n    Point c=getCrossPointLL(a.s,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.s)){\n    Point c=getCrossPointLL(a.s,b.s);\n    if(check2(c))vp.pb(c);\n  }\n}\npair<Line,Line> getS(Line a,Line b){\n  Point m=getCrossPointLL(a,b);\n  double r=getAngle(a.p1-a.p2,b.p1-b.p2);\n  Line c(rotate(m,a.p1,r/2.0),rotate(m,a.p2,r/2.0));\n  Line d(rotate(m,a.p1,(180-r)/2.0),rotate(m,a.p2,(180-r)/2.0));\n  return mp(c,d);\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      FOR(k,j+1,n){\n        if(isParallel(vs[i],vs[j]) && isParallel(vs[i],vs[k]))continue;\n        if(isParallel(vs[i],vs[j]))check1(vs[i],vs[j],vs[k]);\n        else if(isParallel(vs[i],vs[k]))check1(vs[i],vs[k],vs[j]);\n        else if(isParallel(vs[j],vs[k]))check1(vs[j],vs[k],vs[i]);\n        else {\n          pll a=getS(vs[i],vs[j]);\n          pll b=getS(vs[j],vs[k]);\n          pll c=getS(vs[k],vs[i]);\n          check3(a,b);\n          check3(b,c);\n          check3(c,a);\n        }\n      }\n    }\n  }\n  vp=unique(vp);\n  if(vp.empty())cout<<\"None\"<<endl;\n  else if(vp.size()>1)cout<<\"Many\"<<endl;\n  else printf(\"%.10f %.10f\\n\",vp[0].x,vp[0].y);\n  return;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    vs.clear();\n    vp.clear();\n    FOR(i,0,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      vs.pb(Segment(Point(a,b),Point(c,d)));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define double long double\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-10;\nconst double eps = 1e-10;\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\nbool eq(double a,double b){return abs(a-b)<eps;}\nbool eq(P a,P b){return eq(a.real(),b.real())&&eq(a.imag(),b.imag());}\ndouble getDistanceLP(L s, P p){\n\n  assert( !eq( s.first, s.second) );\n\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\nbool isParalell(L a,L b){return  eq(0,cross(a.second-a.first,b.second-b.first));}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<L> A;\nbool check(P a){\n  double dis = getDistanceLP(A[0],a);\n\n  for(int i=0;i<(int)A.size();i++)\n    if(!eq(dis,getDistanceLP(A[i],a))) return 0;\n\n  return  1;\n}\n\nL calc(P o,P a,P b){\n  a-=o,b-=o;\n  return L(o,(a/abs(a) + b/abs(b)) + o);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    A.resize(n);\n    for(int i=0,x1,y1,x2,y2;i<n;i++){\n      cin>>x1>>y1>>x2>>y2;\n      A[i] = L(P(x1,y1),P(x2,y2));\n    }\n\n\n    if(n<=2){cout<<\"Many\"<<endl;continue;}\n    \n    vector<L> B; \n    for(int i=0;i<n;i++)\n      for(int j=0;j<i;j++){\n\tL a = A[i], b = A[j];\n\n\tif(isParalell(a,b)||B.size()>100)continue;\n\n\tP o = crossPoint(a,b);\n\tP va=a.second-a.first;\n\tP vb=b.second-b.first;\n\tva /= abs(va);\n\tvb /= abs(vb);\n\n\tB.push_back( L( o , o+va+vb) );\n\tB.push_back( L( o , o+va-vb ) );\n\n      }\n\n    vector<P> ans;\n    for(int i=0;i<(int)B.size();i++)\n      for(int j=i+1;j<(int)B.size();j++){\n\tL a = B[i], b = B[j];\n\tif(isParalell(a,b)) continue;\n\tP c = crossPoint(a,b);\n\tif(check(c)&&(ans.empty()||!eq(ans[0],c))) ans.push_back(c);\n\n      }\n    \n    if(ans.size()>=2) cout<<\"Many\"<<endl;\n    else if(ans.empty()) cout<<\"None\"<<endl;\n    else printf(\"%Lf %Lf\\n\",ans[0].real(),ans[0].imag());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-4;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n == 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<Line> ls;\n\t\trep(i, bs.size()) for (auto b : bs[i]){\n\t\t\tls.eb(b);\n\t\t}\n\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, bs.size()) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!cps.empty()) return;\n\t\t\t}\n\t\t}();\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tunique(cps);\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnone = true;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tnone = false;\n\t\t\t\tres = cps[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (none) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-9;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>0; }\nbool near(point a, point b){ return abs(b-a)<=0; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 1; i < n; ++i){\n      point is;\n      if(intersectionLL( vl[0], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[0].fr) ){\n\t  va = uvec(vl[0].fr-is);\n\t}else{\n\t  va = uvec(vl[0].sc-is);\n\t}\n\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tbisector.push_back( line( is, is+va+vb ) );\n\tbisector.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\tpoint cfr = 0.5 * dist_l( vl[i], vl[0].fr ) * unmr(vl[0].sc-vl[0].fr) + vl[0].fr;\n\tpoint csc = 0.5 * dist_l( vl[i], vl[0].fr ) * unmr(vl[0].sc-vl[0].fr) + vl[0].sc;\n\tbisector.push_back( line(cfr,csc) );\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\t//printf(\"(%.12lf %.12lf),\",  res[i].real(), res[i].imag());\n\t//printf(\"(%.12lf %.12lf)\\n\",  res[j].real(), res[j].imag());\n\t//cout << abs(res[i]-res[j]) << endl;\n\tif( abs(res[i]-res[j])<eps ){\n\t  //cout <<\"erase\" << endl;\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-4;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n == 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<Point> cps;\n\t\trep(i, bs.size()) rep(j, i){\n\t\t\tbool f = false;\n\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\tf = true;\n\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) none = true;\n\t\t}\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tunique(cps);\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnone = true;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tnone = false;\n\t\t\t\tres = cps[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (none) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-4)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.4f %.4f\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1&&a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size()&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n\tif (cnt == 1 && EQV(ans,cand))continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-8;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<sqrt(eps);\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    //P m=(a1+b1)/2.l;\n    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-4)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5f %.5f\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-10;\nconst double pi = acos(-1.0);\nconst double mag = 800;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ) va = uvec(vl[t].fr-is);\n\telse va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) ) vb = uvec(vl[i].fr-is);\n\telse vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint is;\n\tintersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[t].fr) + vl[t].fr;\n\tpoint csc = d * uvec(is-vl[t].fr) + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      break;\n      // if( i == 1 ) break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\nbool EQ(double a,double b){\n\treturn fabs(a) < EPS;\n}\nbool GE(double a,double b){\n\treturn a > b - EPS;\n}\nbool LE(double a,double b){\n\treturn a < b + EPS;\n}\n\nint convex_contains(const polygon &P, const point &p) {\n  const int n = P.size();\n  point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n      if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n      else                                                  a = c;\n    } else {\n      if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nbool intersect_1pt(const point& a, const point& b,\n                   const point& c, const point& d, point &r) {\n  double D =  cross(b - a, d - c);\n  if (EQ(D, 0)) return false;\n  double t =  cross(c - a, d - c) / D;\n  double s = -cross(a - c, b - a) / D;\n  r = a + t * (b - a);\n  return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n}\npolygon convex_intersect(const polygon &P, const polygon &Q) {\n  const int n = P.size(), m = Q.size();\n  int a = 0, b = 0, aa = 0, ba = 0;\n  enum { Pin, Qin, Unknown } in = Unknown;\n  polygon R;\n  do {\n    int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n    double C = cross(P[a] - P[a1], Q[b] - Q[b1]);\n    double A = cross(P[a1] - Q[b], P[a] - Q[b]);\n    double B = cross(Q[b1] - P[a], Q[b] - P[a]);\n    point r;\n    if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n      if (in == Unknown) aa = ba = 0;\n      R.push_back( r );\n      in = B > 0 ? Pin : A > 0 ? Qin : in;\n    }\n    if (C == 0 && B == 0 && A == 0) {\n      if (in == Pin) { b = (b + 1) % m; ++ba; }\n      else           { a = (a + 1) % m; ++aa; }\n    } else if (C >= 0) {\n      if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n      else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n    } else {\n      if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n      else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n    }\n  } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n  if (in == Unknown) {\n    if (convex_contains(Q, P[0])) return P;\n    if (convex_contains(P, Q[0])) return Q;\n  }\n  return R;\n}\n\n\nvector<L> ls;\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\ndouble PI = acos(-1);\n \n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nG gen(L l,double d){\n\tP f = l[1]-l[0];\n\tf /= abs(f);\n\tP r = f * exp(P(0,PI/2.));\n\tP a = l[0] + r * d;\n\tP b = l[0] - r * d;\n\t\n\tdouble len = 1000000;\n\tG g;\n\tg.push_back(a+f*len);\n\tg.push_back(a-f*len);\n\tg.push_back(b+f*len);\n\tg.push_back(b-f*len);\n\t\n\treturn convex_hull(g);\n}\ndouble ok(double d,int f=0){\n\tvector<P> co;\n\t\n\tfor(int i = 0 ; i < ls.size() ; i++){\n\t\tauto v = gen(ls[i],d);\n\t\tif(i==0){\n\t\t\tco = v;\n\t\t}else{\n\t\t\tif( co.size() ) co = convex_intersect(co,v);\n\t\t}\n\t}\n\tif(f){\n\t\tprintf(\"%.10lf %.10lf\\n\",co[0].real(),co[0].imag());\n\t}\n\treturn area2(co);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble l = 0, r = 100000;\n\t\t\tif( ok(r) < EPS ){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0 ; i < 256 ; i++){\n\t\t\t\tdouble m = (l+r)/2.;\n\t\t\t\tif( ok(m) > EPS ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tok(l,1);\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-6)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/(long double)2.0,\n                       (V[0].second+V[j].second)/(long double)2.0);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n \nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n \ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n \nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nvector<L> equidist(const L &a, const L &b){\n    vector<L> ret;\n    if(isParallel(a, b)){\n        P mid = (a[0]+b[0])/2.0;\n        ret.push_back( L(mid, mid+(a[1]-a[0])) );\n    }else{\n        P cp = crosspointLL(a, b);\n        P v1 = unit(a[1]-a[0])*1000.0, v2 = unit(b[1]-b[0])*1000.0;\n        ret.push_back( L(cp, cp+ (v1+v2)/2.0) );\n        ret.push_back( L(cp, cp+ (v1-v2)/2.0) );\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n         \n        vector<L> l(n);\n        for(int i=0; i<n; i++){\n            int x1,y1,x2,y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            l[i] = L(P(x1,y1), P(x2,y2));\n        }\n\n        if(n <= 2){\n            cout << \"Many\" << endl;\n            continue;\n        }else if(isParallel(l[0], l[1]) && isParallel(l[1], l[2])){\n            cout << \"None\" << endl;\n            continue;\n        }\n\n        vector<L> ml;\n        for(int i=0; i<3; i++){\n            vector<L> cl = equidist(l[i], l[(i+1)%3]);\n            copy(cl.begin(), cl.end(), back_inserter(ml));\n        }\n        VP cand;\n        for(int i=0; i<(int)ml.size(); i++){\n            for(int j=i+1; j<(int)ml.size(); j++){\n                if(!isParallel(ml[i], ml[j])){\n                    cand.push_back(crosspointLL(ml[i], ml[j]));\n                }\n            }\n        }\n        sort(cand.begin(), cand.end());\n        cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n        int count = 0;\n        P ans;\n        for(int i=0; i<(int)cand.size(); i++){\n            bool success = true;\n            double dist = distanceLP(l[0], cand[i]);\n            for(int j=1; j<n; j++){\n                if(!EQ(dist, distanceLP(l[j], cand[i]))){\n                    success = false;\n                    break;\n                }\n            }\n            if(success){\n                count++;\n                ans = cand[i];\n            }\n        }\n\n        if(count==0){\n            cout << \"None\" << endl;\n        }else if(count >= 2){\n            cout << \"Many\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans.X << \" \" << ans.Y << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  //rep(i,a.size()){\n  rep(i,2){\n    REP(j,i+1,a.size()){\n      //cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n      //<< a[j].fir <<\" \" << a[j].sec << endl;\n      //cout << j<<\" \"<< is_intersected_ll(\n      //a[i].fir,a[i].sec,\n      //a[j].fir,a[j].sec)<<\n      //\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      //cout << is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)<<endl;\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && abs(ans-cand)<1e-5)continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n\n  Point cp = crosspoint(line1,line2);\n  int res = ccw(cp,p1,p2);\n\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  double arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 30 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=abs(a[i].fir-tmp)<eps?a[i].sec:a[i].fir;\n\tP bt=abs(a[j].fir-tmp)<eps?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nvoid makecand(vector<Line> & a,vector<P> &b){\n  rep(i,a.size()){\n    REP(j,i+1,a.size()){\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size()&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (check(a,cand)){\n\t  if (cnt==0)ans=cand;\n\t  if(cnt != 0&&abs(ans-cand)<1e-05);\n\t  else cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    if (n == 1||n ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-10;\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nvector<Line> get_midline(Line l, Line m){\n    vector<Line> res;\n    Point vec1 = l.vector() / abs(l.vector());\n    Point vec2 = m.vector() / abs(m.vector());\n    if(sign(cross(vec1, vec2)) == 0){\n        res.push_back(Line((l[0] + m[0]) / 2.0, (l[1] + m[1]) / 2.0));\n    }else{\n        Point p = crosspointLL(l, m);\n        res.push_back(Line(p, p + vec1 + vec2));\n        res.push_back(Line(p, p + vec1 - vec2));\n    }\n    return res;\n}\n\nstring solve(vector<Line> lines){\n    int n = lines.size();\n    if(n <= 2){\n        return \"Many\";\n    }\n    if(paralell(lines[0], lines[1]) && paralell(lines[1], lines[2])){\n        return \"None\";\n    }\n    vector<Line> midlines;\n    for(int i = 1; i < 3; i++){\n        //cout << lines[i][0] << \" -> \" << lines[i][1] << endl;\n            //if(paralell(lines[i], lines[j])) continue;\n        vector<Line> mids = get_midline(lines[0], lines[i]);\n        midlines.insert(midlines.end(), mids.begin(), mids.end());\n    }\n    vector<Point> ps;\n    for(int i = 0; i < midlines.size(); i++){\n        for(int j = i + 1; j < midlines.size(); j++){\n            if(paralell(midlines[i], midlines[j])){\n                continue;\n            }\n            // cout << midlines[i][0] << \"->\" << midlines[i][1] << endl;\n            // cout << midlines[j][0] << \"->\" << midlines[j][1] << endl;\n            Point p = crosspointLL(midlines[i], midlines[j]);\n            // cout << p << endl;\n            bool ok = true;\n            for(int k = 0; k < lines.size(); k++){\n                for(int k2 = 0; k2 < lines.size(); k2++){\n                    if(sign(distanceLP(lines[k], p) - distanceLP(lines[k2], p)) != 0){\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            for(int k = 0; k < ps.size(); k++){\n                if(sign(abs(p - ps[k])) == 0){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                ps.push_back(p);\n            }\n        }\n    }\n    if(ps.size() >= 2) {\n        return \"Many\";\n    }else if(ps.size() == 0){\n        return \"None\";\n    }else{\n        char s[256];\n        sprintf(s, \"%.9f %.9f\", ps[0].real(), ps[0].imag());\n        return string(s);\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Line> lines;\n        REP(i, N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            lines.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        cout << solve(lines) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <assert.h>\n#include <string.h>\n\nusing namespace std;\n\ntypedef complex<double> Complex;\ntypedef Complex P;\n\nstatic const double EPS = 1e-6;\ninline bool EQ(double a, double b) { return abs(a - b) < EPS; }\ninline bool EQP(Complex a, Complex b) { return norm(a - b) < EPS; }\n\nstruct Seg;\nstruct Line;\nstruct Circle;\n\ndouble X(P p) { return p.real(); }\ndouble Y(P p) { return p.imag(); }\ndouble dot(P a, P b) { return X(conj(a) * b); }\ndouble cross(P a, P b) { return Y(conj(a) * b); }\ndouble ccw(P p1, P p2, P p3) { return cross(p2 - p1, p3 - p1); }\nP proj(P p, P q) { return q * dot(p, q) / norm(q); }\nP rot(P p) { return p * P(0, 1); }\n\n\nstruct Line {\n  P p, v;\n  double distance(P q) {\n    return abs(cross(v, q - p)) / abs(v);\n  }\n  bool is_contain(P q) {\n    return EQ(cross(v, q - p), 0.0);\n  }\n  bool is_parallel(Line rhs) {\n    return EQ(cross(v, rhs.v), 0.0);\n  }\n  P intersection(Line rhs) {\n    assert(!is_parallel(rhs));\n    return p + v * cross(rhs.v, rhs.p - p) / cross(rhs.v, v);\n  }\n};\n\n\nstruct Triangle {\n  P p1, p2, p3;\n  Triangle(P p1, P p2, P p3) : p1(p1), p2(p2), p3(p3) {;}\n  P incenter() {\n    double le1 = abs(p2 - p3), le2 = abs(p3 - p1), le3 = abs(p1 - p2);\n    return (p1 * le1 + p2 * le2 + p3 * le3) / (le1 + le2 + le3);\n  }\n\n  vector<P> excenter() {\n    vector<P> ret;\n    double le1 = abs(p2 - p3), le2 = abs(p3 - p1), le3 = abs(p1 - p2);\n    ret.push_back((-p1 * le1 + p2 * le2 + p3 * le3) / (-le1 + le2 + le3));\n    ret.push_back(( p1 * le1 - p2 * le2 + p3 * le3) / ( le1 - le2 + le3));\n    ret.push_back(( p1 * le1 + p2 * le2 - p3 * le3) / ( le1 + le2 - le3));\n    return ret;\n  }\n};\n\nLine line[300];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n  if (n < 3) {\n    puts(\"Many\");\ncontinue;\n  }\n  for (int i = 0; i < n; i++) {\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    line[i].p = Complex(x1, y1);\n    line[i].v = Complex(x2 - x1, y2 - y1);\n    line[i].v /= abs(line[i].v);\n  }\n  if (line[0].is_parallel(line[1]) && line[0].is_parallel(line[2])) {\n    puts(\"None\");\ncontinue;\n  }\n  vector<P> point;\n  vector<double> dist;\n  bool fail[4];\n  memset(fail, false, sizeof(fail));\n  if (line[0].is_parallel(line[1]) || line[0].is_parallel(line[2]) || line[1].is_parallel(line[2])) {\n    if (line[0].is_parallel(line[1])) {\n    } else if (line[0].is_parallel(line[2])) {\n      swap(line[1], line[2]);\n    } else if (line[2].is_parallel(line[2])) {\n      swap(line[0], line[2]);\n    }\n    P p1 = line[2].intersection(line[0]);\n    P p2 = line[2].intersection(line[1]);\n    P c = (p1 + p2) / 2.0;\n    point.push_back(c + line[0].v * abs(p1 - c));\n    point.push_back(c - line[0].v * abs(p1 - c));\n    dist.push_back(line[0].distance(point[0]));\n    dist.push_back(line[0].distance(point[1]));\n  } else {\n    P p1 = line[0].intersection(line[1]);\n    P p2 = line[1].intersection(line[2]);\n    P p3 = line[2].intersection(line[0]);\n    if (EQP(p1, p2) && EQP(p1, p3)) {\n      point.push_back(p1);\n      dist.push_back(0.0);\n    } else {\n      Triangle tri(p1, p2, p3);\n      point = tri.excenter();\n      point.push_back(tri.incenter());\n      dist.push_back(line[0].distance(point[0]));\n      dist.push_back(line[0].distance(point[1]));\n      dist.push_back(line[0].distance(point[2]));\n      dist.push_back(line[0].distance(point[3]));\n    }\n  }\n  int rest = (int)point.size();\n  for (int i = 3; i < n; i++) {\n    for (int j = 0; j < (int)point.size(); j++) {\n      if (fail[j]) { continue; }\n      double d = line[i].distance(point[j]);\n      if (!EQ(d, dist[j])) {\n        fail[j] = true;\n        rest--;\n      }\n    }\n  }\n  P ans;\n  for (int i = 0; i < (int)point.size(); i++) {\n    if (!fail[i]) {\n      ans = point[i];\n    }\n  }\n  if (rest == 0) {\n    puts(\"None\");\n  } else if (rest > 1) {\n    puts(\"Many\");\n  } else {\n    printf(\"%.4lf %.4lf\\n\", ans.real(), ans.imag());\n  }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*100.0 + (c-b)/abs(c-b)*100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l*100.0;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/2.0,\n                       (V[0].first+V[j].first)/2.0 + V[0].second - V[0].first);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a);\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.size() == 0) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12f %.12f\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    /*\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n    */\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    bool f = true;\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[i]);\n      bool g = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(g){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        f = false;\n        break;\n      }\n    }\n    if(f) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    /*\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n    */\n    bool f = true;\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[i]);\n      bool g = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(g){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        f = false;\n        break;\n      }\n    }\n    if(f) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){x+=p.x,y+=p.y; return *this;}\n\tPoint& operator-=(Point p){x-=p.x,y-=p.y; return *this;}\n\tPoint& operator*=(double c){x*=c,y*=c; return *this;}\n\tPoint& operator/=(double c){x/=c,y/=c; return *this;}\n};\nPoint operator+(Point a,Point b){return a+=b;}\nPoint operator-(Point a,Point b){return a-=b;}\nPoint operator*(Point a,double c){return a*=c;}\nPoint operator*(double c,Point a){return a*=c;}\nPoint operator/(Point a,double c){return a/=c;}\nbool operator==(Point a,Point b){return abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n};\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (inclusive)\n}\n\nbool IntersectLL(Line a,Line b){\n\treturn abs(Cross(a.dir,b.dir))>EPS || abs(Cross(a.dir,b.pos-a.pos))<EPS;\n}\nbool IntersectLP(Line l,Point p){\n\treturn abs(CCW(l.pos,l.pos+l.dir,p))!=1;\n}\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS) return a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Line& l){\n\treturn os<<'('<<l.pos<<','<<l.dir<<')';\n}\n\nstring solve(vector<Line> ls)\n{\n\tint n=ls.size();\n\tif(n<=2) return \"Many\"; // trivial case\n\t\n\tvector<vector<Line>> els; // equidistant lines\n\trep(i,n) repi(j,i+1,n){\n\t\tLine a=ls[i],b=ls[j];\n\t\tif(IntersectLL(a,b)){\n\t\t\t// \"The lines do not coincide each other.\"なので直線は1点で交わる\n\t\t\tPoint p=InterPointLL(a,b);\n\t\t\ta.dir/=Abs(a.dir),b.dir/=Abs(b.dir);\n\t\t\tels.push_back({Line(p,(a.dir+b.dir)/2),Line(p,(a.dir-b.dir)/2)});\n\t\t}\n\t\telse{\n\t\t\tels.push_back({Line((a.pos+b.pos)/2,a.dir)});\n\t\t}\n\t}\n\t\n\t// 全直線が平行\n\tif(all_of(all(els),[](const vector<Line>& a){return a.size()==1;})){\n\t\trepi(i,1,els.size())\n\t\t\tif(!IntersectLL(els[0][0],els[i][0]))\n\t\t\t\treturn \"None\";\n\t\treturn \"Many\";\n\t}\n\t\n\tvector<Point> ps;\n\trep(i,els.size()) repi(j,i+1,els.size()) for(Line a:els[i]) for(Line b:els[j]){\n\t\tif(abs(Cross(a.dir,b.dir))>EPS)\n\t\t\tps.push_back(InterPointLL(a,b));\n\t}\n\tsort(all(ps),[](Point a,Point b){return abs(a.x-b.x)>EPS?a.x<b.x:a.y<b.y;});\n\tps.erase(unique(all(ps)),end(ps));\n\t\n\tvector<Point> res;\n\tfor(Point p:ps){\n\t\tbool on=true;\n\t\trep(i,els.size()){\n\t\t\tbool tmp=false;\n\t\t\tfor(Line l:els[i])\n\t\t\t\ttmp|=IntersectLP(l,p);\n\t\t\tif(!tmp){\n\t\t\t\ton=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(on) res.push_back(p);\n\t}\n\t\n\tif(res.size()==0) return \"None\";\n\tif(res.size()>=2) return \"Many\";\n\t\n\tchar tmp[100];\n\tsprintf(tmp,\"%f %f\",res[0].x,res[0].y);\n\treturn tmp;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<Line> ls(n);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;\n\t\t\tls[i]=Line(x1,y1,x2-x1,y2-y1);\n\t\t}\n\t\tcout<<solve(ls)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1){\n    REP(j,i+1,a.size()){\n//       cout << a[i].fir<<\" \" << a[i].sec <<\" \" \n// \t   << a[j].fir <<\" \" << a[j].sec << endl;\n//       cout << j<<\" \"<< is_intersected_ll(\n// \t\t\t\t\t a[i].fir,a[i].sec,\n// \t\t\t\t\t a[j].fir,a[j].sec)<<\n// \t\" \" << cross(a[i].fir-a[i].sec,a[j].fir-a[j].sec) << endl;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\tb.pb(mp(tmp,tmp+rot(bt-tmp,at-tmp)));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (cnt == 1 && EQV(ans,cand))continue;\n\tif (check(a,cand)){\n\t  ans=cand;\n\t  cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nD eps=1e-7;\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool eq(P a,P b){return abs(a-b)<eps;}\nint sig(D a){return eq(a,0)?0:(a>0?1:-1);}\nD cro(P a,P b){return imag(conj(a)*b);}\nD dot(P a,P b){return real(conj(a)*b);}\nP perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\nP nor(P p){\n\tif(abs(p)<eps) return P(0,0);\n\treturn p/abs(p);\n}\nbool ispal(L a,L b){\n\treturn sig(cro(nor(a.fs-a.sc),nor(b.fs-b.sc)))==0;\n}\nbool on(L l,P p){\n\treturn sig(cro(nor(l.fs-l.sc),nor(p-l.sc)))==0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tvector<L> ls;\n\t\trep(i,N){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tls.pb(L(P(a,b),P(c,d)));\n\t\t}\n\t\tif(N<=2){\n\t\t\tputs(\"Many\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> vl;\n\t\tvector<P> vp;\n\t\trep(i,N) rep(j,i){\n\t\t\tvector<L> nvl;\n\t\t\tvector<P> nvp;\n\t\t\tL a=ls[i],b=ls[j];\n\t\t\tif(ispal(a,b)){\n\t\t\t\tP p=(perp(b,a.fs)+a.fs)/2.0,q=p+a.sc-a.fs;\n\t\t\t\tL l=L(p,q);\n\t\t\t\tif(i==1){\n\t\t\t\t\tvl.pb(l);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(L x:vl){\n\t\t\t\t\tif(ispal(l,x)){\n\t\t\t\t\t\tif(on(l,x.fs)) nvl.pb(x);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnvp.pb(intLL(x,l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(P x:vp){\n\t\t\t\t\tif(on(l,x)) nvp.pb(x);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tP p=intLL(a,b);\n\t\t\t\tif(eq(p,a.fs)) swap(a.fs,a.sc);\n\t\t\t\tif(eq(p,b.fs)) swap(b.fs,b.sc);\n\t\t\t\tP e=a.fs-p,f=b.fs-p;\n\t\t\t\te/=abs(e),f/=abs(f);//\n\t\t\t\tL l[2]={L(p,p+e+f),L(p,p-e+f)};\n//\t\t\t\tcout<<\"l[0]=\"<<l[0].fs<<\" \"<<l[0].sc<<endl;\n//\t\t\t\tcout<<\"l[1]=\"<<l[1].fs<<\" \"<<l[1].sc<<endl;\n\t\t\t\tif(i==1){\n\t\t\t\t\tvl.pb(l[0]),vl.pb(l[1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k,2){\n\t\t\t\t\tfor(L x:vl){\n\t\t\t\t\t\tif(ispal(l[k],x)){\n\t\t\t\t\t\t\tif(on(l[k],x.fs)) nvl.pb(x);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnvp.pb(intLL(x,l[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(P x:vp){\n\t\t\t\t\t\tif(on(l[k],x)) nvp.pb(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvl=nvl,vp=nvp;\n/*\t\t\tprintf(\"i=%d,j=%d\\n\",i,j);\n\t\t\tcout<<\"vl\";\n\t\t\tfor(L l:vl) cout<<\"(\"<<l.fs<<\",\"<<l.sc<<\")  \";\n\t\t\tputs(\"\");\n\t\t\tcout<<\"vp\";\n\t\t\tfor(P p:vp) cout<<p<<\"  \";\n\t\t\tputs(\"\");*/\n\t\t}\n\t\tvector<P> nvp;\n\t\tfor(P p:vp){\n\t\t\tbool ok=1;\n\t\t\tfor(P np:nvp){\n\t\t\t\tif(eq(p,np)) ok=0;\n\t\t\t}\n\t\t\tif(ok) nvp.pb(p);\n\t\t}\n\t\tvp=nvp;\n\t\tif(!vl.empty()||vp.size()>1){\n\t\t\tputs(\"Many\");\n\t\t}else if(vp.size()==0){\n\t\t\tputs(\"None\");\n\t\t}else{\n\t\t\tprintf(\"%.12f %.12f\\n\",vp[0].real(),vp[0].imag());\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-14L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\ntypedef complex<double> P;\n\nstruct L: public vector<P> {\n    L(){}\n    L(const P &a, const P &b){\n        pb(a);pb(b);\n    }\n};\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\ndouble dot(const P &a, const P &b){\n    return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>0)return +1;\n    if(cross(b,c)<0)return -1;\n    if(dot(b,c)<0)return +2;\n    if(norm(b)<norm(c))return -2;\n}\n\nbool insecLL(const L &l, const L &m){\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nP proj(const L &l, const P &p){\n    double t=dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distLP(const L &l, const P &p){\n    return abs(p - proj(l,p));\n}\n\nP crosspoint(const L &l, const L &m){\n    double A=cross(l[1]-l[0],m[1]-m[0]);\n    double B=cross(l[1]-l[0],l[1]-m[0]);\n    if(abs(A)<EPS && abs(B)<EPS)return m[0];\n    if(abs(A)<EPS)assert(0);\n    return m[0] + B/A*(m[1]-m[0]);\n}\n\nvector<L> bisector(const L &l, const L &m){\n    if(!insecLL(l,m))assert(0);\n    P p=crosspoint(l,m);\n    vector<L> res;\n    L res0,res1;\n    P l0=(l[1]-l[0])/norm(l[1]-l[0]);\n    P m0=(m[1]-m[0])/norm(m[1]-m[0]);\n    res0.pb(p); res0.pb(p+l0+m0);\n    res1.pb(p); res1.pb(p+l0-m0);\n    res.pb(res0); res.pb(res1);\n    return res;\n}\n\nint n;\nL line[111];\n\nint main(){\n\twhile(cin>>n && n){\n        int num=0;\n        P ans;\n        rep(i,n){\n            int x,y,xx,yy;\n            cin>>x>>y>>xx>>yy;\n            line[i]=L(P(x,y),P(xx,yy));\n        }\n        if(n<=2){\n            cout<<\"Many\\n\";continue;\n        }\n        L l0=line[0],l1=line[1],l2=line[2];\n        vector<L> v1,v2;\n        if(insecLL(l0,l1)){\n            v1=bisector(l0,l1);\n        }else{\n            P p=proj(l0,l1[0]);\n            P mid=(p,l1[0]);\n            v1.pb(L(mid,mid+l0[1]-l0[0]));\n        }\n        if(insecLL(l0,l2)){\n            v2=bisector(l0,l2);\n        }else{\n            P p=proj(l0,l2[0]);\n            P mid=(p,l2[0]);\n            v2.pb(L(mid,mid+l0[1]-l0[0]));\n        }\n        rep(i,v1.sz)rep(j,v2.sz){\n            if(insecLL(v1[i],v2[j])){\n                P p=crosspoint(v1[i],v2[j]);\n                double d=distLP(l0,p);\n                rep2(k,3,n){\n                    if(abs(d-distLP(line[k],p))>EPS){\n                        goto fail;\n                    }\n                }\n                if(num>0){\n                    if(norm(ans-p)>EPS){\n                        cout<<\"Many\"<<endl;\n                        goto end;\n                    }else goto fail;\n                }\n                num++;\n                ans=p;\n            fail:;\n            }\n        }\n        if(num==1)cout<<ans.real()<<\" \"<<ans.imag()<<endl;\n        else cout<<\"None\"<<endl;\n    end:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < 1; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\n#define double long double\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-5;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<eps;\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    P m=(a1+b1)/2.l;\n    //    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-3;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\t\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP pos = projection(ls[i],ls[j][0]);\n\t\t\t\t\t\tP vec = ls[j][0]-pos;\n\t\t\t\t\t\tln.push_back(L(pos,pos+vec/2.));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > EPS )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t\t//cout << ok << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-7;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n\tpoint is;\n\tif(intersectionLL( vl[i], vl[j], is)){\n\t  vec va;\n\t  vec vb;\n\t  \n\t  if( far(is,vl[i].fr) ){\n\t    va = uvec(vl[i].fr-is);\n\t  }else{\n\t    va = uvec(vl[i].sc-is);\n\t  }\n\t  \n\t  if( far(is,vl[j].fr) ){\n\t    vb = uvec(vl[j].fr-is);\n\t  }else{\n\t    vb = uvec(vl[j].sc-is);\n\t  }\n\t  \n\t  bisector.push_back( line( is, is+va+vb ) );\n\t  bisector.push_back( line( is, is+va-vb ) );\n\t  \n\t}else{\n\t  elem d = 0.5 * dist_l( vl[j], vl[i].fr );\n\t  point is;\n\t  intersectionLL( line(vl[i].fr, vl[i].fr+unmr(vl[i].sc-vl[i].fr) ), vl[j], is );\n\t  \n\t  point cfr = d * uvec(is-vl[i].fr) + vl[i].fr;\n\t  point csc = d * uvec(is-vl[i].fr) + vl[i].sc;\n\t  bisector.push_back( line(cfr,csc) );\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\n\tif( (ccw(bisector[i].fr,bisector[i].sc,bisector[j].fr) & (OVER|FRONT|BACK)) &&\n\t    (ccw(bisector[i].fr,bisector[i].sc,bisector[j].sc) & (OVER|FRONT|BACK)) ) continue;\n\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n      if(i==1)\n\tbreak;\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-1;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 1; i < n; ++i){\n      point is;\n      if(intersectionLL( vl[0], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[0].fr) ){\n\t  va = uvec(vl[0].fr-is);\n\t}else{\n\t  va = uvec(vl[0].sc-is);\n\t}\n\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tbisector.push_back( line( is, is+va+vb ) );\n\tbisector.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[0].fr );\n\tpoint is;\n\tintersectionLL( line(vl[0].fr, vl[0].fr+unmr(vl[0].sc-vl[0].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[0].fr) + vl[0].fr;\n\tpoint csc = d * uvec(is-vl[0].fr) + vl[0].sc;\n\tbisector.push_back( line(cfr,csc) );\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      //cout << bisector[i] << endl;\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-10;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n\n\n        if( isParallel(ab,bc) && isParallel(bc,ca) && isParallel(ca,ab) ){\n          continue;\n        }\n        \n        P target;\n        \n        if( !isParallel(ab,bc) ){\n          target=intersect(ab,bc);\n        }\n        if( !isParallel(ca,bc) ){\n          target=intersect(ca,bc);\n        }\n        if( !isParallel(bc,ca) ){\n          target=intersect(bc,ca);\n        }\n        \n        if( !isParallel(ab,bc) ){\n          P q2=intersect(ab,bc);\n          if( abs(target-q2) > eps )continue;\n        }\n        if( !isParallel(bc,ca) ){\n          P q0=intersect(bc,ca);\n          if( abs(target-q0) > eps )continue;\n        }\n        if( !isParallel(ca,bc) ){\n          P q1=intersect(ca,ab);         \n          if( abs(target-q1) > eps )continue;\n        }\n\n\n        \n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    reverse(t,t+n);\n    \n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n\tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > 3e-5)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\nnamespace std{\n  bool operator < (const Point& p, const Point& q){\n    if(p.real() != q.real()) return p.real() < q.real();\n    return p.imag() < q.imag();\n  }\n}\n\nint sign(double a){\n  if(a > EPS) return 1;\n  if(a < -EPS) return -1;\n  return 0;\n}\nbool equal(Point a, Point b){\n  return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n}\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b){\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\nbool intersect(const Line& l, const Point& p){\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\ndouble distanceLP(const Line& l, const Point& p){\n  return abs(p - projection(l, p));\n}\n\nPoint crosspoint(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0) assert(false);\n  return m[0] + m.vector() * B / A;\n}\n\nbool ok(const vector<Line>& l, Point p){\n  REP(i, l.size() - 1) if(sign(distanceLP(l[i], p) - distanceLP(l[i + 1], p)) != 0) return false;\n  return true;\n}\nvoid insert(vector<Point>& ans, Point p){\n  if(ans.empty() || !equal(ans.front(), p)) return ans.push_back(p);\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Line> l;\n    REP(i, N){\n      Point p[2];\n      REP(j, 2) cin >> p[j].real() >> p[j].imag();\n      sort(p, p + 2);\n      l.push_back(Line(p[0], p[1]));\n    }\n    if(N <= 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<Line> mid_lines;\n    REP(i, N) FOR(j, i + 1, N){\n      if(paralell(l[i], l[j])){\n        assert(!equalLL(l[i], l[j]));\n        Point p = projection(l[i], l[j][0]);\n        Point p1 = (p - l[j][0]) * 0.5;\n        Point p2 = p1 + l[i].vector();\n        mid_lines.push_back(Line(p1, p2));\n      }else{\n        Point p = crosspoint(l[i], l[j]);\n        Point q = p + l[i].vector() / abs(l[i].vector()) + l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n        q = p + l[i].vector() / abs(l[i].vector()) - l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n      }\n    }\n    // mid = 10000\n    vector<Point> ans;\n    int C = 0;\n    random_shuffle(mid_lines.begin(), mid_lines.end());\n    REP(i, mid_lines.size()) FOR(j, i + 1, mid_lines.size()){\n      if(C * N > 10000000) break;\n      C++;\n      if(ans.size() >= 2) break;\n      if(equalLL(mid_lines[i], mid_lines[j])){\n        REP(iter, 3){\n          double t = 1000.0 * rand() / RAND_MAX;\n          Point p = mid_lines[i][0] + mid_lines[i].vector() * t;\n          if(ok(l, p)) insert(ans, p);\n          else break;\n        }\n      }else if(!paralell(mid_lines[i], mid_lines[j])){\n        Point p = crosspoint(mid_lines[i], mid_lines[j]);\n        if(ok(l, p)) insert(ans, p);\n      }\n    }\n    if(ans.empty()) cout << \"None\" << endl;\n    else if(ans.size() == 1) printf(\"%.16lf %.16lf\\n\", ans.front().real(), ans.front().imag());\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-6)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n      //C.push_back(V.back().first);\n      //C.push_back(V.back().second);\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/(long double)2.0,\n                       (V[0].second+V[j].second)/(long double)2.0);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.size() == 0) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    vector< vector<Line> > bilines;\n    int cnt = 0;\n    rep(i, n) reps(j, i+1, n) {\n      Line l = lines[i], r = lines[j];\n      Vector lv = l.p2 - l.p1, rv = r.p2 - r.p1;\n      lv = lv / abs(lv); rv = rv / abs(rv);\n      vector<Line> bi;\n      if(isParallel(l, r)) {\n\tPoint o = (l.p1+r.p1)/2;\n\tLine m = Line(o, o + lv);\n\tbi.push_back(m);\n\tbilines.push_back(bi);\n\tcnt++;\n      } else {\n\tPoint p = getCrossPointLL(l, r);\n\tLine v = Line(p, p + lv + rv);\n\tLine w = Line(p, p + lv - rv);\n\tbi.push_back(v);\n\tbi.push_back(w);\n\tbilines.push_back(bi);\n\tcnt++;\n      }\n    }\n    /*\n    if(cnt == 0) {\n      cout << \"None\" << endl;\n      continue;\n    }\n    if(cnt == 1) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    */\n    vector<Point> ans;\n    rep(i, min((int)bilines.size(), 10LL)) {\n      reps(j, i+1, min((int)bilines.size(), 10LL)) {\n\tvector<Line> a = bilines[i], b = bilines[j];\n\trep(k, a.size()) rep(l, b.size()) {\n\t  if(isParallel(a[k], b[l])) continue;\n\t  Point cp = getCrossPointLL(a[k], b[l]);\n\t  double dist = getDistanceLP(lines[0], cp);\n\t  bool flag = true;\n\t  rep(x, n) {\n\t    if(!eq(dist, getDistanceLP(lines[x], cp))) flag = false;\n\t  }\n\t  rep(x, ans.size()) {\n\t    if(eq(abs(ans[x]-cp), 0)) flag = false;\n\t  }\n\t  if(flag) ans.push_back(cp);\n\t}\n      }\n    }\n    if(ans.size() == 0) cout << \"None\" << endl;\n    else if(ans.size() == 1) {\n      cout << ans[0].x << \" \" << ans[0].y << endl;\n    }\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-8;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n\toperator point<double>()const{ return (point<double>){x,y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a,b;\n\toperator line<double>()const{ return (line<double>){a,b}; }\n};\n\ntemplate<class T>\nbool intersect(const line<T> &L1,const line<T> &L2){\n\treturn cross(L1.b-L1.a,L2.b-L2.a)!=0  // L1 と L2 が平行でない\n\t\t|| cross(L1.b-L1.a,L2.a-L1.a)==0; // L1 == L2\n}\n\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1,const line<T> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(a1==0) return L1.a; // L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<int> &L,const line<int> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tpoint<double> o=(L.a+M.a)/2;\n\t\tres.push_back((line<double>){o,o+(point<double>)(L.b-L.a)});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(point<double>)(L.a==o?L.b:L.a)-o;\n\t\tpoint<double> q=(point<double>)(M.a==o?M.b:M.a)-o;\n\t\tp/=abs(p);\n\t\tq/=abs(q);\n\t\tres.push_back((line<double>){o,o+p+q});\n\t\tres.push_back((line<double>){o,o+p-q});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<int> L[100];\n\t\trep(i,n) scanf(\"%d%d%d%d\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\t\tsort(P_cand.begin(),P_cand.end());\n\t\tP_cand.erase(unique(P_cand.begin(),P_cand.end()),P_cand.end());\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist((line<double>)L[j],p)-dist((line<double>)L[0],p))>EPS) {\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-9;\nconst double pi = acos(-1.0);\nconst double mag = 1;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) )\n\t  va = uvec(vl[t].fr-is);\n\telse\n\t  va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) )\n\t  vb = uvec(vl[i].fr-is);\n\telse\n\t  vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d) && eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse\n\t  pt = ptr - vl[t].fr;\n\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\t//if( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-4;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>0; }\nbool near(point a, point b){ return abs(b-a)<=0; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 1; i < n; ++i){\n      point is;\n      if(intersectionLL( vl[0], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[0].fr) ){\n\t  va = uvec(vl[0].fr-is);\n\t}else{\n\t  va = uvec(vl[0].sc-is);\n\t}\n\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tbisector.push_back( line( is, is+va+vb ) );\n\tbisector.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\tpoint cfr = 0.5 * dist_l( vl[i], vl[0].fr ) * unmr(vl[0].sc-vl[0].fr) + vl[0].fr;\n\tpoint csc = 0.5 * dist_l( vl[i], vl[0].fr ) * unmr(vl[0].sc-vl[0].fr) + vl[0].sc;\n\tbisector.push_back( line(cfr,csc) );\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( abs(res[i]-res[j])<eps ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-6)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return (x!=p.x ? x-p.x<-eps : y-p.y<-eps);}\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  return r;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(all(vp));\n  res.pb(vp[0]);\n  FOR(i,1,vp.size())if(!(vp[i]==res.back()))res.pb(vp[i]);\n  return res;\n}\n\ntypedef pair<Line,Line> pll;\n\nint n;\nvector<Segment> vs;\nvector<Point> vp;\n\npll getS(Line a,Line b){\n  Point m=getCrossPointLL(a,b);\n  double r=getAngle(a.p1-a.p2,b.p1-b.p2);\n  Line c(rotate(m,a.p1,r/2.0),rotate(m,a.p1,180+r/2.0));\n  Line d(rotate(m,a.p1,(180.0-r)/2.0),rotate(m,a.p1,180+(180.0-r)/2.0));\n  return mp(c,d);\n}\n\nbool check2(Point p){\n  double dis=getDistanceLP(vs[0],p);\n  FOR(i,1,n)\n    if(!equals(dis,getDistanceLP(vs[i],p)))return false;\n  return true;\n}\n\nvoid check1(Line a,Line b,Line c){\n  Point d=getCrossPointLL(a,c),e=getCrossPointLL(b,c);\n  Point m=d+(e-d)/2.0;\n  Line L(m+(a.p1-a.p2),m);\n  pll f=getS(a,c);\n  d=getCrossPointLL(f.f,L);\n  if(check2(d))vp.pb(d);\n  d=getCrossPointLL(f.s,L);\n  if(check2(d))vp.pb(d);\n  pll s=getS(b,c);\n  d=getCrossPointLL(s.f,L);\n  if(check2(d))vp.pb(d);\n  d=getCrossPointLL(s.s,L);\n  if(check2(d))vp.pb(d);\n  return;\n}\n\nvoid check3(pll a,pll b){\n  if(!isParallel(a.f,b.f)){\n    Point c=getCrossPointLL(a.f,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.f,b.s)){\n    Point c=getCrossPointLL(a.f,b.s);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.f)){\n    Point c=getCrossPointLL(a.s,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.s)){\n    Point c=getCrossPointLL(a.s,b.s);\n    if(check2(c))vp.pb(c);\n  }\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  FOR(i,0,n){\n    FOR(j,0,n){\n      FOR(k,0,n){\n        if(i==j || i==k || j==k)continue;\n        if(isParallel(vs[i],vs[j]) && isParallel(vs[i],vs[k]))continue;\n        else if(isParallel(vs[i],vs[j]))check1(vs[i],vs[j],vs[k]);\n        //else if(isParallel(vs[j],vs[k]))check1(vs[j],vs[k],vs[i]);\n        //else if(isParallel(vs[k],vs[i]))check1(vs[k],vs[i],vs[j]);\n        else {\n          pll a=getS(vs[i],vs[j]);\n          pll b=getS(vs[j],vs[k]);\n          pll c=getS(vs[k],vs[i]);\n          check3(a,b);\n         // check3(b,c);\n         // check3(c,a);\n        }\n      }\n    }\n  }\n  vp=unique(vp);\n  if(vp.empty())cout<<\"None\"<<endl;\n  else if(vp.size()>1)cout<<\"Many\"<<endl;\n  else printf(\"%.10f %.10f\\n\",vp[0].x,vp[0].y);\n  return;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    vs.clear();\n    vp.clear();\n    FOR(i,0,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      vs.pb(Segment(Point(a,b),Point(c,d)));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  //  rep(i,1){\n  //    REP(j,i+1,a.size()){\n  rep(i,a.size()-1){\n    int j=i+1;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\t//\tb.pb(mp(tmp,tmp+rot2(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n\n\n// \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n// \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n//  \tcout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n// \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" \n// \t     <<\"[\"<<a[i].fir<<\",\" << a[i].sec<<\"],\" \n// \t     <<\"[\"<<a[j].fir<<\",\" << a[j].sec<<\"],\" <<endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  //  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n\n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n    rep(i,a.size()){\n      for(int j=(int)a.size()-1;j>i;j--){\n\tif(distance_lp(a[i].fir,a[i].sec,a[j].sec)<eps &&\n\t   distance_lp(a[i].fir,a[i].sec,a[j].fir)<eps){\n\t  a.erase(a.begin()+j);\n\t}\n      }\n    }\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-8;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n\t// operator point<double>()const{ return (point<double>){x,y}; }\n};\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\n// 整数 × 整数点, 実数 × 実数点 ( 他のバリエーションは必要になったときに用意する )\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\nbool intersect(const line<double> &L1,const line<double> &L2){\n\treturn abs(cross(L1.b-L1.a,L2.b-L2.a))>EPS\n\t\t|| abs(cross(L1.b-L1.a,L2.a-L1.a))<EPS;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<double> &L,const line<double> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tpoint<double> P[4];\n\t\tP[0]=(L.a+M.a)/2;\n\t\tP[1]=(L.a+M.b)/2;\n\t\tP[2]=(L.b+M.a)/2;\n\t\tP[3]=(L.b+M.b)/2;\n\t\tsort(P,P+4);\n\t\tunique(P,P+4);\n\t\tres.push_back((line<double>){P[0],P[1]});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(L.a==o?L.b:L.a);\n\t\tpoint<double> q=(M.a==o?M.b:M.a);\n\t\tres.push_back((line<double>){o,p+q-o});\n\t\tq+=2.*(o-q);\n\t\tres.push_back((line<double>){o,p+q-o});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<double> L[100];\n\t\trep(i,n) scanf(\"%lf%lf%lf%lf\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist(L[j],p)-dist(L[0],p))>EPS) { ok=false; break; }\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\t\tif(ans.empty()) puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-4)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12f %.12f\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#define EPS (1.0e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n  bool operator < (const Point &p) const {\n    if(!equals(x, p.x)) return x < p.x;\n    if(!equals(y, p.y)) return y < p.y;\n    return false;\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Line s1, Line s2) {\n  return isParallel(s1.p2-s1.p1, s2.p2-s2.p1);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Line s1, Line s2) {\n  Vector a = s1.p2 - s1.p1;\n  Vector b = s2.p2 - s2.p1;\n  double d1 = cross(b, s2.p1 - s1.p1);\n  double d2 = cross(b, a);\n  return s1.p1 + a * d1/d2;\n}\n\nVector getOthogonalV(Vector a) {\n  return Vector(-a.y, a.x);\n}\n\nLine getOthogonalL(Line s) {\n  Line res;\n  res.p1 = s.p1;\n  res.p2 = s.p1 + getOthogonalV(s.p2 - s.p1);\n  return res;\n}\n\ndouble getDistanceLP(Line s, Point p) {\n  return fabs(cross(s.p2 - s.p1, p - s.p1))/abs(s.p2 - s.p1);\n}\n\nint N;\nLine S[100];\n\nvoid getBisector(vector<Line> &v) {\n  for(int i = 0; i < N; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      Vector a = S[i].p2 - S[i].p1;\n      Vector b = S[j].p2 - S[j].p1;\n      if(isParallel(S[i], S[j])) {\n\tdouble d = getDistanceLP(S[i], S[j].p1)/2.0;\n\tVector vn;\n\tif(ccw(S[i].p1, S[i].p2, S[j].p1) >= 1) {\n\t  vn.x = -a.y;\n\t  vn.y = a.x;\n\t} else {\n\t  vn.x = a.y;\n\t  vn.y = -a.x;\n\t}\n\tvn = vn*d/abs(vn);\n\tLine l;\n\tl.p1 = S[i].p1 + vn;\n\tl.p2 = S[i].p2 + vn;\n\tv.push_back(l);\n      } else {\n\tPoint p = getCrossPoint(S[i], S[j]);\n\tLine l;\n\tl.p1 = p;\n\tl.p2 = p + b+a*sqrt(norm(b)/norm(a));\n\tv.push_back(l);\n\tv.push_back(getOthogonalL(l));\n      }\n    }\n  }\n}\n\nvoid solve() {\n  if(N <= 2) {\n    cout << \"Many\" << endl;\n    return;\n  }\n  if(N == 3) {\n    bool f1 = isParallel(S[0], S[1]);\n    bool f2 = isParallel(S[1], S[2]);\n    bool f3 = isParallel(S[2], S[0]);\n    if(f1 && f2 && f3) {\n      cout << \"None\" << endl;\n      return;\n    } else {\n      cout << \"Many\" << endl;\n      return;\n    }\n  }\n\n  vector<Line> v;\n  getBisector(v);\n\n  set<Point> cp;\n  for(int i = 0; i < v.size(); ++i) {\n    for(int j = i+1; j < v.size(); ++j) {\n      if(isParallel(v[i], v[j])) continue;\n      cp.insert(getCrossPoint(v[i], v[j]));\n    }\n  }\n  int count = 0;\n  Point ans;\n  for(set<Point>::iterator ii = cp.begin(); ii != cp.end(); ++ii) {\n    double d = getDistanceLP(S[0], *ii);\n    bool flag = true;\n    for(int j = 1; j < N; ++j) {\n      if(!equals(d, getDistanceLP(S[j], *ii))) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      ++count;\n      if(count >= 2) break;\n      ans = *ii;\n    }\n  }\n\n  if(count == 0) cout << \"None\" << endl;\n  else if(count == 1) printf(\"%.5f %.5f\\n\", ans.x, ans.y);\n  else if(count >= 2) cout << \"Many\" << endl;\n}\n\nmain() {\n  while((cin >> N) && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].p1.x >> S[i].p1.y >> S[i].p2.x >> S[i].p2.y;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-12L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (abs(a-b)<eps)\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid makeall(vector<Line> &a,vector<Line> &b){\n  rep(i,1&&a.size()){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=abs(a[i].fir-tmp)<eps?a[i].sec:a[i].fir;\n\tP bt=abs(a[j].fir-tmp)<eps?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  rep(i,b.size()&&cnt<2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tif (check(a,cand)){\n\t  if (cnt==0)ans=cand;\n\t  if(cnt != 0&&abs(ans-cand)<1e-05);\n\t  else cnt++;\n\t  if (cnt ==2)break;\n\t}\n      }\n    }\n  }\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    if (n == 1||n ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<random>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nmt19937 engine;\nint n;\nint x1[123],y_1[123],x2[123],y2[123];\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dist(P p,int idx){\n  P a=P(x1[idx],y_1[idx]);\n  P vb=P(x2[idx],y2[idx])-a;\n  return fabs(cross(p-a,vb)/abs(vb));\n}\n\ndouble ddiff(P p){\n  double mxd=-1,mnd=1e9;\n  for(int i=0;i<n;i++){\n    double d=dist(p,i);\n    mxd=max(mxd,d);\n    mnd=min(mnd,d);\n  }\n  return mxd-mnd;\n}\n\nbool par(int a,int b){\n  return fabs(dist(P(x1[a],y_1[a]),b)-dist(P(x2[a],y2[a]),b))<1e-9;\n}\n\nint main(){\n  for(;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x1[i]>>y_1[i]>>x2[i]>>y2[i];\n    }\n    if(n<=2){\n      cout<<\"Many\"<<endl;\n    }else if(n==3){\n      if(par(0,1)&&par(1,2)){\n\tcout<<\"None\"<<endl;\n      }else{\n\tcout<<\"Many\"<<endl;\n      }\n    }else{\n      P p=P(0,0);\n      double r=1e9;\n      for(int i=0;i<100000;i++,r*=.999){\n\tP np=p+polar(r,uniform_real_distribution<double>(0,9)(engine));\n\tif(ddiff(np)<ddiff(p)){\n\t  p=np;\n\t}\n\t//\tcout<<r<<endl;\n      }\n      if(ddiff(p)<1e-5){\n\tcout<<fixed<<p.real()<<' '<<p.imag()<<endl;\n      }else{\n\tcout<<\"None\"<<endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-5)\nclass P{                    //点\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //加算\n    P operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //減算\n    P operator * (const double k )const{ return P( x*k   , y*k    ); } //乗算\n    P operator / (const double k )const{ return P( x/k   , y/k    ); } //除算\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    bool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //ノルム\n    double abs() { return sqrt(norm()); }   //大きさ\n    void normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;}    //正規化\n};\nstruct C{P p;double r;};    //円\nstruct S{P p1,p2;};         //線分\ntypedef vector<P> Polygon;  //多角形\ntypedef P Vector;           //ベクトル\ntypedef S L;                //直線\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\n// 直線と直線の交点 vefiried AOJ CGL_2\nP getCrossPointSS(S l1, S l2){\n    double A = cross(vec(l1), vec(l2));\n    double B = cross(vec(l1), l1.p2 - l2.p1);\n    if(abs(A)<EPS && abs(B)<EPS) return l2.p1; // 二直線が重なっている\n    if(abs(A)<EPS) return P(INF,INF); // 直線が交わらない\n    return l2.p1 + vec(l2) * B / A;\n}\n\n//線分と点の距離 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n\n\nbool isParallel(L a, L b){\n    if(cross(vec(a),vec(b))<EPS){\n        return true;\n    }else{\n        return false;\n    }\n}\n\n//線分に対する点の射影 verified AOJ CGL_1_A\nP projection(S s, P p){\n    Vector base = s.p2-s.p1;\n    double r = dot(p-s.p1, base)/norm(base);\n    return (base*r)+s.p1;\n}\n\nP normalize(P p) {\n    return p/abs(p);\n}\nvector<L> angle_bisector(const L &l, const L &m) {\n    vector<L> res;\n    if (abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS) { // non-parallel\n        P pos1 = getCrossPointSS(l,m);\n        P pos2 = pos1+(normalize(l.p2-l.p1) + normalize(m.p2-m.p1))*0.5;\n        res.push_back(L{pos1,pos2});\n        pos2 = pos1+(normalize(l.p2-l.p1) + normalize(m.p1-m.p2))*0.5;\n        res.push_back(L{pos1,pos2});\n        \n    } else {\n        P pos1 = (projection(l,m.p1)+m.p1)*0.5;\n        res.push_back(L{pos1,pos1+l.p2-l.p1});\n    }\n    \n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<L> lines(n);\n        rep(i,n){\n            P p1,p2;\n            cin>>p1.x>>p1.y>>p2.x>>p2.y;\n            lines[i] = L{p1, p2};\n        }\n        \n        if(n<=2){ cout<<\"Many\"<<endl; }\n        else{\n            vector<L> ls[2];\n            \n            ls[0] = angle_bisector(lines[0], lines[1]);\n            ls[1] = angle_bisector(lines[1], lines[2]);\n            \n            vector<P> vp;\n            rep(i,ls[0].size()){\n                rep(j,ls[1].size()){\n                    vp.pb( getCrossPointSS(ls[0][i], ls[1][j]) );\n                }\n            }\n            sort(all(vp));\n            vector<P> v;\n            v.pb(vp[0]);\n            rep(i,vp.size()-1){\n                P t = vp[i]-vp[i+1];\n                if( (t.x)<(1e-12) && abs(t.y)<(1e-12) )continue;\n                v.pb(vp[i+1]);\n            }\n            vp = v;\n            rep(i,vp.size()-1){\n                P t = vp[i]-vp[i+1];\n                assert( abs(t.x)>(1e-12) || abs(t.y)>(1e-12) );\n            }\n            \n            vector<P> ans;\n            for(auto elm:vp){\n                \n                bool flag = true;\n                for(int i=1;i<n;i++){\n                    if( abs(dLP(lines[0],elm) - dLP(lines[i],elm))<EPS ){\n                        ;\n                    }else{\n                        flag = false;\n                    }\n                }\n                if(flag){\n                    ans.pb(elm);\n                }\n            }\n            if(ans.size()>1){\n                cout<<\"Many\"<<endl;\n            }else if(ans.size()==1){\n                printf(\"%.20lf %.20lf\\n\",ans[0].x, ans[0].y);\n            }else{\n                cout<<\"None\"<<endl;\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-12)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define double long double\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-10;\nconst double eps = 1e-10;\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\nbool eq(double a,double b){return abs(a-b)<eps;}\nbool eq(P a,P b){return eq(a.real(),b.real())&&eq(a.imag(),b.imag());}\ndouble getDistanceLP(L s, P p){\n\n  assert( !eq( s.first, s.second) );\n\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\nbool isParalell(L a,L b){return  eq(0,cross(a.second-a.first,b.second-b.first));}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<L> A;\nbool check(P a){\n  double dis = getDistanceLP(A[0],a);\n\n  for(int i=0;i<(int)A.size();i++)\n    if(!eq(dis,getDistanceLP(A[i],a))) return 0;\n\n  return  1;\n}\n\nL calc(P o,P a,P b){\n  a-=o,b-=o;\n  return L(o,(a/abs(a) + b/abs(b)) + o);\n}\n\n/*\nL StoL(L a){\n  P t=a.second - a.first;\n  t = (t/abs(t)) * (double)1e6;\n  return L(-t+a.first,t+a.first);\n}\n*/\n\nP gv(L l){\n  return l.second-l.first;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    A.resize(n);\n    for(int i=0,x1,y1,x2,y2;i<n;i++){\n      cin>>x1>>y1>>x2>>y2;\n      A[i] = L(P(x1,y1),P(x2,y2));\n    }\n\n\n    if(n<=2){cout<<\"Many\"<<endl;continue;}\n    \n    vector<L> B; \n    for(int i=0;i<n;i++)\n      for(int j=0;j<i;j++){\n\tL a = A[i], b = A[j];\n\n\tif(isParalell(a,b)||B.size()>100)continue;\n\n\tP o = crossPoint(a,b);\n\n\t//printf(\"%.8Lf %.8Lf\\n\", (double)o.real(), (double)o.imag() );\n\n\t//cout<<\"ij\"<<i<<j<<endl;\n\t//printf(\"o=(%Lf,%Lf)\\n\",o.real(),o.imag());\n\t//cout<<\"o=\"<<o<<endl;\n\t//cout<<\"a=\"<<a.first<<\" \"<<a.second<<endl;\n\t//cout<<\"b=\"<<b.first<<\" \"<<b.second<<endl<<endl;\n\n\tP va=a.second-a.first;\n\tP vb=b.second-b.first;\n\tva /= abs(va);\n\tvb /= abs(vb);\n\n\tB.push_back( L( o , o+va+vb) );\n\tB.push_back( L( o , o+va-vb ) );\n\n      }\n\n\n    //  for(int i=0;i<B.size();i++)cout<<B[i].first<<\" \"<<B[i].second<<endl;\n       \n    vector<P> ans;\n    for(int i=0;i<(int)B.size();i++)\n      for(int j=i+1;j<(int)B.size();j++){\n\n\n\tL a = B[i], b = B[j];\n\n\tif(isParalell(a,b)) continue;\n\n\tP c = crossPoint(a,b);\n\n\tif(check(c)&&(ans.empty()||!eq(ans[0],c))) ans.push_back(c);\n\n      }\n    \n    if(ans.size()>=2) cout<<\"Many\"<<endl;\n    else if(ans.empty()) cout<<\"None\"<<endl;\n    else printf(\"%Lf %Lf\\n\",ans[0].real(),ans[0].imag());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-5)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,(V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          /*\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          */\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.5Lf %.5Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n\n#define sc second\n#define fr first\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\nconst double mag = 1;\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool far(point a, point b){ return abs(b-a)>eps; }\nbool near(point a, point b){ return abs(b-a)<=eps; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nvoid make_bisectors(int t, const vector<line> &vl, vector<line> &ret){\n  for(int i = 0; i < (int)vl.size(); ++i){\n    if( i != t ){\n      point is;\n      if(intersectionLL( vl[t], vl[i], is )){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[t].fr) ) va = uvec(vl[t].fr-is);\n\telse va = uvec(vl[t].sc-is);\n\t\n\tif( far(is,vl[i].fr) ) vb = uvec(vl[i].fr-is);\n\telse vb = uvec(vl[i].sc-is);\n\t\n\tret.push_back( line( is, is+va+vb ) );\n\tret.push_back( line( is, is+va-vb ) );\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[t].fr );\n\tpoint ptl = vl[t].fr + d * unml(vl[t].sc-vl[t].fr);\n\tpoint ptr = vl[t].fr + d * unmr(vl[t].sc-vl[t].fr);\n\t//intersectionLL( line(vl[t].fr, vl[t].fr+unmr(vl[t].sc-vl[t].fr) ), vl[i], is );\n\tpoint pt;\n\tif( eq(dist_l(vl[t],ptl),d)&&eq(dist_l(vl[i],ptl),d) )\n\t  pt = ptl - vl[t].fr;\n\telse pt = ptr - vl[t].fr;\n\tpoint cfr = pt + vl[t].fr;\n\tpoint csc = pt + vl[t].sc;\n\tret.push_back( line(cfr,csc) );\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    vector<line> vl;\n    vector<line> bisector1;\n    vector<line> bisector2;\n    vector< point > res;\n\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      x1 /= mag; y1 /= mag;\n      x2 /= mag; y2 /= mag;\n      vl.push_back(line(point(x1,y1),point(x2,y2)));\n    }\n\n    if( n<=2 ){\n      puts(\"Many\");\n      continue;\n    }\n\n    make_bisectors(0,vl,bisector1);\n    make_bisectors(1,vl,bisector2);\n\n    for(int i = 0; i < (int)bisector1.size(); ++i){\n      for(int j = 0; j < (int)bisector2.size(); ++j){\n\tpoint is;\n\t\n\tif( prll(bisector1[i].sc-bisector1[i].fr,bisector2[j].sc-bisector2[j].fr) ) continue;\n\t\n\tif( intersectionLL( bisector1[i], bisector2[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ) res.push_back(is);\n\t}\n      }\n      if(i == 1)break;\n    }\n    \n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( near(res[i],res[j]) ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n    \n    if( res.size() > 1 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 )\n\tprintf(\"%.12lf %.12lf\\n\", mag*res[0].real(), mag*res[0].imag());\n      else\n\tputs(\"None\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-7;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n <= 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tshuffle(all(bs), mt19937());\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, std::min<int>(bs.size(), 15)) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}();\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i, cps.size()) rep(j, i){\n\t\t\tif (cps[i] == cps[j]){\n\t\t\t\tswap(cps[i], cps.back());\n\t\t\t\tcps.pb();\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tcnt++;\n\t\t\t\tres = cps[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (cnt >= 2) cout << \"Many\\n\";\n\t\telse if (cnt == 0) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tok++;\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-8)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    if(n <= 2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector< vector<Line> > bilines;\n    rep(i, n) reps(j, i+1, n) {\n      Line l = lines[i], r = lines[j];\n      Vector lv = l.p2 - l.p1, rv = r.p2 - r.p1;\n      lv = lv / abs(lv); rv = rv / abs(rv);\n      vector<Line> bi;\n      if(isParallel(l, r)) {\n\tPoint o = (l.p1+r.p1)/2;\n\tLine m = Line(o, o + lv);\n\tbi.push_back(m);\n\tbilines.push_back(bi);\n      } else {\n\tPoint p = getCrossPointLL(l, r);\n\tLine v = Line(p, p + lv + rv);\n\tLine w = Line(p, p + lv - rv);\n\tbi.push_back(v);\n\tbi.push_back(w);\n\tbilines.push_back(bi);\n      }\n    }\n    vector<Point> ans;\n    rep(i, min((int)bilines.size(), 10LL)) {\n      reps(j, i+1, min((int)bilines.size(), 10LL)) {\n\tvector<Line> a = bilines[i], b = bilines[j];\n\trep(k, a.size()) rep(l, b.size()) {\n\t  if(isParallel(a[k], b[l])) continue;\n\t  bool flag = true;\n\t  Point cp = getCrossPointLL(a[k], b[l]);\n\t  //cout<<cp.x<<\" \"<<cp.y<<endl;\n\t  double dist = getDistanceLP(lines[0], cp);\n\t  rep(x, n) {\n\t    //cout<<dist<< \" \"<< getDistanceLP(lines[x], cp) << endl;\n\t    if(!eq(dist, getDistanceLP(lines[x], cp))) flag = false;\n\t  }\n\t  rep(x, ans.size()) {\n\t    if(eq(abs(ans[x]-cp), 0)) flag = false;\n\t  }\n\t  if(flag) ans.push_back(cp);\n\t}\n      }\n    }\n    if(ans.size() == 0) cout << \"None\" << endl;\n    else if(ans.size() == 1) {\n      cout << ans[0].x << \" \" << ans[0].y << endl;\n    }\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-5;\n\nbool eq(double a,double b){\n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        P q0=intersect(bc,ca);\n        P q1=intersect(ca,ab);\n        if( abs(target-q0) > eps )continue;\n        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.8f %.8f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n      for(int j=0;j<i;j++){\n        if( isParallel(t[i],t[j]) && eq(distance( t[i], t[j].s ),0 ) ){\n          \n          assert(0);\n        }\n      }\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first)){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n        }\n        P a = A.back().first, v = n_vector(A.back().second-a);\n        B.emplace_back(a,a+v);\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    if(abs(cross(A[0].first-A[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(A[0],A[1]));\n    }\n    if(abs(cross(A[0].first-A[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(A[0],B[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,A[1].first-A[1].second)) > EPS){\n      C.push_back(intersection(B[0],A[1]));\n    }\n    if(abs(cross(B[0].first-B[0].second,B[1].first-B[1].second)) > EPS){\n      C.push_back(intersection(B[0],B[1]));\n    }\n    if(C.size() < 1){\n      cout << \"None\" << endl;\n    }\n    bool g = true;\n    for(int j = 0; j < C.size(); ++j){\n      P c = C[j];\n      bool f = true;\n      for(int i = 0; i < A.size(); ++i){\n        if(p_to_l_dist(c,A[i]) > EPS && p_to_l_dist(c,B[i]) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        printf(\"%.12f %.12f\\n\",c.X,c.Y);\n        g = false;\n        break;\n      }\n    }\n    if(g) cout << \"None\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n\n  Point cp = crosspoint(line1,line2);\n  int res = ccw(cp,p1,p2);\n\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  double arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 8 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; break; }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-9)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tlong double d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tlong double A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n\n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n\n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n    \n    //FOR(it,ans) cout << *it << endl;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-8)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x_1[100],y_1[100],x_2[100],y_2[100];\ndouble eps=1e-5;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool on(P a,pair<P,P> l){\n  return fabs(cross(a-l.first,l.second-l.first))<eps;\n}\n\nP cp(pair<P,P> e,pair<P,P> f){\n  P a=e.second-e.first;\n  P b=f.second-f.first;\n  double acb=cross(a,b);\n  if(fabs(acb)<eps)throw 0;\n  return e.first+a*cross(f.first-e.first,b)/acb;\n}  \n\nvector<pair<P,P> > elines(int x1,int x2){\n  P a1=P(x_1[x1],y_1[x1]),a2=P(x_2[x1],y_2[x1]);\n  P b1=P(x_1[x2],y_1[x2]),b2=P(x_2[x2],y_2[x2]);\n  vector<pair<P,P> > v;\n  try{\n    auto cpab=cp(make_pair(a1,a2),make_pair(b1,b2));\n    P ac=a1-a2,bc=b1-b2;\n    P d=ac/abs(ac)+bc/abs(bc);\n    v.emplace_back(cpab,cpab+d);\n    v.emplace_back(cpab,cpab+d*P(0,1));\n  }catch(...){\n    P m=(a1+b1)/2.;\n    v.emplace_back(m,m+a2-a1);\n  }\n  return v;\n}\n    \nint main(){\n  for(int n;cin>>n,n;){\n    vector<pair<P,P> > lines;\n    vector<P> points;\n    for(int i=0;i<n;i++){\n      cin>>x_1[i]>>y_1[i]>>x_2[i]>>y_2[i];\n      for(int j=0;j<i;j++){\n\tif(i==1){\n\t  lines=elines(i,j);\n\t}else{\n\t  vector<pair<P,P> > nl;\n\t  vector<P> np;\n\t  for(auto e:elines(i,j)){\n\t    for(auto f:lines){\n\t      try{\n\t\tauto cpef=cp(e,f);\n\t\tnp.push_back(cpef);\n\t      }catch(...){\n\t\tif(on(f.first,e)&&on(f.second,e)){\n\t\t  nl.push_back(f);\n\t\t}\n\t      }\n\t    }\n\t    for(auto f:points){\n\t      if(on(f,e)){\n\t\tnp.push_back(f);\n\t      }\n\t    }\n\t  }\n\t  lines=nl;\n\t  points.clear();\n\t  for(int i=0;i<np.size();i++){\n\t    bool has=false;\n\t    for(auto e:points){\n\t      has|=abs(e-np[i])<eps;\n\t    }\n\t    if(!has){\n\t      points.push_back(np[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(n==1||!lines.empty()||points.size()>1){\n      cout<<\"Many\"<<endl;\n    }else if(points.empty()){\n      cout<<\"None\"<<endl;\n    }else{\n      cout<<fixed<<points[0].real()<<' '<<points[0].imag()<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    vector<Line> bilines;\n    int cnt = 0;\n    rep(i, n) reps(j, i+1, n) {\n      Line l = lines[i], r = lines[j];\n      if(isParallel(l, r)) {\n\tdouble d = getDistance(l, r)/2;\n\tauto lt = getTranslation(l, d);\n\tauto rt = getTranslation(r, d);\n\tLine m;\n\trep(i, 2) rep(j, 2) {\n\t  if(eq(getDistance(lt[i], rt[j]), 0)) {\n\t    m = lt[i];\n\t  }\n\t}\n\tbilines.push_back(m);\n\tcnt++;\n      } else {\n\tPoint p = getCrossPointLL(l, r);\n\tLine v = Line(p, (l.p2-l.p1) + (r.p2-r.p1) + p);\n\tLine w = Line(p, (l.p2-l.p1) - (r.p2-r.p1) + p);\n\tbilines.push_back(v);\n\tbilines.push_back(w);\n\tcnt++;\n      }\n    }\n    /*\n    if(cnt == 0) {\n      cout << \"None\" << endl;\n      continue;\n    }\n    if(cnt == 1) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    */\n    vector<Point> ans;\n    rep(i, min((int)bilines.size(), 10LL)) {\n      reps(j, i+1, min((int)bilines.size(), 10LL)) {\n\tLine a = bilines[i], b = bilines[j];\n\tif(isParallel(a, b)) continue;\n\tPoint cp = getCrossPointLL(a, b);\n\tdouble dist = getDistanceLP(lines[0], cp);\n\tbool flag = true;\n\trep(k, n) {\n\t  if(!eq(dist, getDistanceLP(lines[k], cp))) flag = false;\n\t}\n\trep(k, ans.size()) {\n\t  if(eq(abs(ans[k]-cp), 0)) flag = false;\n\t}\n\tif(flag) ans.push_back(cp);\n      }\n    }\n    if(ans.size() == 0) cout << \"None\" << endl;\n    else if(ans.size() == 1) {\n      cout << ans[0].x << \" \" << ans[0].y << endl;\n    }\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = long double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-9;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\nbool eqq(Point x,Point y){\n\treturn eq(x.real(),y.real())&&eq(x.imag(),y.imag());\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Line> calc(Line l,Line r){\n    if(abs(cross(l.b-l.a,r.b-r.a))<eps){\n        Point mid=(l.a+r.a)/(ld)2.0;\n        return {{mid, mid + l.b-l.a}};\n    }\n    Point mid=is_ll(l,r);\n    Point pl = (l.b-l.a)/abs(l.b-l.a);\n    Point pr = (r.b-r.a)/abs(r.b-r.a);\n    vector<Line> ret;\n    ret.push_back(Line{mid,mid+(pl+pr)/(ld)2.0});\n    ret.push_back(Line{mid,mid+(pl-pr)/(ld)2.0});\n    return ret;\n}\nvoid solve(int n){\n    Line l[n];\n    rep(i,n){\n        int x,y,xx,yy;\n        cin>>x>>y>>xx>>yy;\n        l[i]=Line{Point(x,y),Point(xx,yy)};\n    }\n    if(n<=2){\n        cout<<\"Many\"<<endl;\n        return;\n    }\n    auto v1=calc(l[0],l[1]);\n    auto v2=calc(l[0],l[2]);\n    vector<Point> p;\n    for(auto e : v1)for(auto f : v2){\n        if(abs(cross(e.a-e.b,f.a-f.b))<eps)continue;\n        p.push_back(is_ll(e,f));\n    }\n    vector<Point> ans;\n    for(auto q : p){\n        bool ok=true;\n        ld dist = dist_lp(l[0],q);\n        rep(i,n){\n            if(!eq(dist_lp(l[i],q),dist))ok=false;\n        }\n        if(ok)ans.push_back(q);\n    }\n    sort(ans.begin(),ans.end(),cmp);\n    ans.erase(unique(ans.begin(),ans.end(),eqq),ans.end());\n    if(ans.size()>1){\n        cout<<\"Many\"<<endl;\n    }\n    else if(ans.size()==0){\n        cout<<\"None\"<<endl;\n    }\n    else cout<<ans[0].real()<<\" \"<<ans[0].imag()<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\nnamespace std{\n  bool operator < (const Point& p, const Point& q){\n    if(p.real() != q.real()) return p.real() < q.real();\n    return p.imag() < q.imag();\n  }\n}\n\nint sign(double a){\n  if(a > EPS) return 1;\n  if(a < -EPS) return -1;\n  return 0;\n}\nbool equal(Point a, Point b){\n  return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n}\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b){\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\nbool intersect(const Line& l, const Point& p){\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\ndouble distanceLP(const Line& l, const Point& p){\n  return abs(p - projection(l, p));\n}\n\nPoint crosspoint(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0) assert(false);\n  return m[0] + m.vector() * B / A;\n}\n\nbool ok(const vector<Line>& l, Point p){\n  REP(i, l.size() - 1) if(sign(distanceLP(l[i], p) - distanceLP(l[i + 1], p)) != 0) return false;\n  return true;\n}\nvoid insert(vector<Point>& ans, Point p){\n  if(ans.empty() || !equal(ans.front(), p)) return ans.push_back(p);\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Line> l;\n    REP(i, N){\n      Point p[2];\n      REP(j, 2) cin >> p[j].real() >> p[j].imag();\n      sort(p, p + 2);\n      l.push_back(Line(p[0], p[1]));\n    }\n    if(N <= 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<Line> mid_lines;\n    REP(i, N) FOR(j, i + 1, N){\n      if(paralell(l[i], l[j])){\n        assert(!equalLL(l[i], l[j]));\n        Point p = projection(l[i], l[j][0]);\n        Point p1 = (p - l[j][0]) * 0.5;\n        Point p2 = p1 + l[i].vector();\n        mid_lines.push_back(Line(p1, p2));\n      }else{\n        Point p = crosspoint(l[i], l[j]);\n        Point q = p + l[i].vector() / abs(l[i].vector()) + l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n        q = p + l[i].vector() / abs(l[i].vector()) - l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n      }\n    }\n    vector<Point> ans;\n    REP(i, mid_lines.size()) FOR(j, i + 1, mid_lines.size()){\n      if(ans.size() >= 2) break;\n      if(equalLL(mid_lines[i], mid_lines[j])){\n        REP(iter, 3){\n          double t = 1000.0 * rand() / RAND_MAX;\n          Point p = mid_lines[i][0] + mid_lines[i].vector() * t;\n          if(ok(l, p)) insert(ans, p);\n        }\n      }else if(!paralell(mid_lines[i], mid_lines[j])){\n        Point p = crosspoint(mid_lines[i], mid_lines[j]);\n        if(ok(l, p)) insert(ans, p);\n      }\n    }\n    if(ans.empty()) cout << \"None\" << endl;\n    else if(ans.size() == 1) printf(\"%.16lf %.16lf\\n\", ans.front().real(), ans.front().imag());\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-11L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    /*\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n          vector<P> nans;\n          rep(i,SZ(ans)){\n            bool ok = true;\n            rep(j,i)\n              ok &= !EQ(ans[i],ans[j]);\n            if(ok) nans.pb(ans[i]);\n          }\n              \n          //sort(ALL(ans));\n          //ans.erase(unique(ALL(ans)), ans.end());\n          ans = nans;\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-1;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\n\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\nPoint projection(Line l, Point p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) throw 0; // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\nnamespace std{\n    bool operator < (const Point& p, const Point& q){\n        if(p.real() != q.real()) return p.real() < q.real();\n        return p.imag() < q.imag();\n    }\n};\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<Line> ls;\n        REP(i, n){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n        }\n        if(n <= 2){\n            cout << \"Many\" << endl;\n            continue;\n        }\n        vector<Line> cand_line;\n        for(int i = 0; i < n; i++)\n        for(int j = i + 1; j < n; j++){\n            if(paralell(ls[i], ls[j])){\n                Point t = projection(ls[j], ls[i][0]);\n                Line l(ls[i][0] + 0.5 * t, ls[i][1] + 0.5 * t);\n                cand_line.push_back(l);\n            }else{\n                Point t = crosspointLL(ls[i], ls[j]);\n                Line l(t, t + ls[i].vector() + ls[j].vector());\n                cand_line.push_back(l);\n                Line m(t, t + ls[i].vector() - ls[j].vector());\n                cand_line.push_back(m);\n            }\n        }\n\n        bool ans_exist = false;\n        bool many = false;\n        Point answer;\n        set<Point> used;\n        for(int i = 0; i < cand_line.size(); i++)\n        for(int j = i + 1; j < cand_line.size(); j++){\n            try{\n                Point p = crosspointLL(cand_line[i], cand_line[j]);\n                if(used.count(p)) continue;\n                used.insert(p);\n                double d = distanceLP(ls[0], p);\n                bool ok = true;\n                for(int k = 0; k < n; k++){\n                    if(abs(d - distanceLP(ls[k], p)) > EPS){\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok){\n                    if(ans_exist && abs(answer - p) > EPS){\n                        many = true;\n                        goto OUTPUT;\n                    }\n                    if(!ans_exist){\n                        ans_exist = true;\n                        answer = p;\n                    }\n                }\n            }catch(...){\n            }\n        }\n        OUTPUT:\n        if(many){\n            cout << \"Many\" << endl;\n        }else if(ans_exist){\n            printf(\"%.12f %.12f\\n\", answer.real(), answer.imag());\n        }else{\n            cout << \"None\" << endl;\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-6;\n\nusing namespace std;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n\toperator point<double>()const{ return (point<double>){x,y}; }\n};\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){\n\treturn (point<double>){a.x/c,a.y/c};\n}\n\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a,b;\n\toperator line<double>()const{ return (line<double>){a,b}; }\n};\n\ntemplate<class T>\nbool intersect(const line<T> &L1,const line<T> &L2){\n\treturn cross(L1.b-L1.a,L2.b-L2.a)!=0  // L1 と L2 が平行でない\n\t\t|| cross(L1.b-L1.a,L2.a-L1.a)==0; // L1 == L2\n}\n\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1,const line<T> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(a1==0) return L1.a; // L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n\treturn abs(cross(L.b-L.a,p-L.a))/dist(L.a,L.b);\n}\n\nvector< line<double> > get_equal_dist_line(const line<int> &L,const line<int> &M){\n\tvector< line<double> > res;\n\tif(!intersect(L,M)){ // 二直線が平行のとき\n\t\tpoint<double> o=(L.a+M.a)/2;\n\t\tres.push_back((line<double>){o,o+(point<double>)(L.b-L.a)});\n\t}\n\telse{\n\t\tpoint<double> o=get_intersect(L,M);\n\t\tpoint<double> p=(point<double>)(L.a==o?L.b:L.a)-o;\n\t\tpoint<double> q=(point<double>)(M.a==o?M.b:M.a)-o;\n\t\tp/=abs(p);\n\t\tq/=abs(q);\n\t\tres.push_back((line<double>){o,o+p+q});\n\t\tres.push_back((line<double>){o,o+p-q});\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tline<int> L[100];\n\t\trep(i,n) scanf(\"%d%d%d%d\",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\n\n\t\tif(n<=2){ puts(\"Many\"); continue; }\n\n\t\tvector< point<double> > P_cand; // 答えの候補点\n\t\tvector< line<double> > M=get_equal_dist_line(L[0],L[1]);\n\t\tvector< line<double> > N=get_equal_dist_line(L[0],L[2]);\n\t\trep(i,M.size()) rep(j,N.size()) {\n\t\t\tif(intersect(M[i],N[j])) P_cand.push_back(get_intersect(M[i],N[j]));\n\t\t}\n\t\tsort(P_cand.begin(),P_cand.end());\n\t\tP_cand.erase(unique(P_cand.begin(),P_cand.end()),P_cand.end());\n\n\t\tvector< point<double> > ans;\n\t\trep(i,P_cand.size()){\n\t\t\tconst point<double> &p=P_cand[i];\n\t\t\tbool ok=true;\n\t\t\trep(j,n) if(abs(dist((line<double>)L[j],p)-dist((line<double>)L[0],p))>EPS) {\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok) ans.push_back(p);\n\t\t}\n\n\t\tif     (ans.empty())   puts(\"None\");\n\t\telse if(ans.size()>=2) puts(\"Many\");\n\t\telse printf(\"%.9f %.9f\\n\",ans[0].x,ans[0].y);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-13, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??´????????´????????????\nbool lisonl(const Line&l, const Line&m) {\n\treturn isis_lp(l, m[0]) && isis_lp(l, m[1]);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\n//???????????????a ??¨???a ??????????????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tif (!isis_ll(s, t)) {\n\t\tif (abs(Point((s[0] + t[0])*0.5l) - Point((s[1] + t[1])*0.5l)) < eps) {\n\t\t\treturn Line(Point((s[0] + t[1])*0.5l), Point((s[1] + t[0])*0.5l));\n\t\t}\n\t\telse {\n\n\t\t\treturn Line(Point((s[0] + t[0])*0.5l), Point((s[1] + t[1])*0.5l));\n\t\t}\n\t}\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = (abs(laglanju - s[0])<eps*100) ? s[1] - laglanju : s[0] - laglanju;\n\tconst Point bvec = (abs(laglanju - t[0])<eps*100) ? t[1] - laglanju : t[0] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1] ),Line(vertics[0], vertics[2] )));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < ls.size(); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\t\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0],ls[1]));\n\tvector<Point>ecs;\n\t\n\t\tLine abi(bisection(Line(vertics[0],vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis,abi));\n\t\n\t\n\t\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0]-vertics[1]), ls[0]));\n\t\tecs.push_back(is_ll(bis, bbi));\n\t\n\treturn ecs;\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\nbool check(const Point& kouho, const vector<Line>&ls,const ld dis) {\n\tfor (auto l : ls) {\n\t\tld adis = abs(dist_lp(l, kouho));\n\t\tif (abs(adis - dis) > eps)return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << setprecision(11) << fixed;\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Line>nls;\n\t\t{\n\t\t\tvector<Line>ls;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\t\tif (lisonl(ls[i], ls[j])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)nls.push_back(ls[i]);\n\t\t\t}\n\t\t}\n\t\tif (nls.size() <= 2) {\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tLine a(nls[0]);\n\t\t\tLine b(nls[1]);\n\t\t\tLine c(nls[2]);\n\t\t\tif (dist_ll(a, b) > eps&&dist_ll(b, c)>eps) {\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (dist_ll(a, b) < eps&&dist_ll(b, c) < eps&&dist_ll(c, a)<eps) {\n\t\t\t\tvector<Point >ps;\n\t\t\t\tPoint nai(inner_center(vector<Line>{a, b, c}));\n\t\t\t\tvector<Point>bou(ex_center(vector<Line>{a, b, c}));\n\t\t\t\tps.push_back(nai);\n\t\t\t\tfor (int i = 0; i < bou.size(); ++i) {\n\t\t\t\t\tps.push_back(bou[i]);\n\t\t\t\t}\n\t\t\t\tvector<bool>oks(ps.size());\n\t\t\t\tint num = 0;\n\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\tld dis = dist_lp(a, ps[i]);\n\t\t\t\t\tld dis1 = dist_lp(b, ps[i]);\n\t\t\t\t\tld dis2 = dist_lp(c, ps[i]);\n\t\t\t\t\toks[i] = check(ps[i], nls, dis);\n\t\t\t\t\tif (oks[i])num++;\n\t\t\t\t}\n\t\t\t\tif (num >= 2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (num == 1) {\n\t\t\t\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\t\t\tif (oks[i]) {\n\t\t\t\t\t\t\tcout << ps[i].real() << \" \" << ps[i].imag() << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_ll(b, c) > eps) {\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif (dist_ll(c, a) > eps) {\n\t\t\t\t\tswap(b, c);\n\t\t\t\t}\n\t\t\t\tassert(dist_ll(a, b) > eps);\n\t\t\t\tvector<Point>kouhos(same_dis(vector<Line>{a, b, c}));\n\t\t\t\tLine bis(bisection(a,b));\n\t\t\t\tPoint bisvec = bis[1] - bis[0];\n\t\t\t\tld dis = dist_ll(a,b) / 2;\n\t\t\t\tPoint p = is_ll(bis, c);\n\t\t\t\tPoint kouho1 = kouhos[0];\n\t\t\t\tPoint kouho2 = kouhos[1];\n\n\t\t\t\tbool ok1 = check(kouho1, nls, dis);\n\t\t\t\tbool ok2 = check(kouho2, nls, dis);\n\t\t\t\tif (ok1&&ok2) {\n\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t}\n\t\t\t\telse if (ok1&&!ok2) {\n\t\t\t\t\tcout << kouho1.real() << \" \" << kouho1.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse if (!ok1&&ok2) {\n\t\t\t\t\tcout << kouho2.real() << \" \" << kouho2.imag() << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"None\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); \n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n\n  Point cp = crosspoint(line1,line2);\n  int res = ccw(cp,p1,p2);\n\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  double arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) { cout << MANY << endl; return; }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 10 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n    }\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  int n;\n  while( cin >> n, n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-7;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator - () const {\n\t\treturn Point(-x, -y);\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (neq(x, r.x)) return x < r.x;\n\t\treturn lt(y, r.y);\n\t}\n\t\n\tbool operator == (const Point &r) const {\n\t\treturn eq(x, r.x) && eq(y, r.y);\n\t}\n\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n\npair<Polygon, Polygon> convexCut(const Polygon &g, const Line &l){\n\tpair<Polygon, Polygon> res;\n\trep(i, g.size()){\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l[0], l[1], a) != -1) res.fi.eb(a);\n\t\tif (ccw(l[0], l[1], a) != 1) res.se.eb(a);\n\t\tif (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0){\n\t\t\tres.fi.eb(crossPoint(Line(a, b), l));\n\t\t\tres.se.eb(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\treturn res;\n}\n\n// }}}\n\n\nint main()\n{\n\tint n;\n\tLine l[100];\n\t\n\twhile (cin >> n, n){\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tl[i] = {{a[0], a[1]}, {a[2], a[3]}};\n\t\t\tPoint v = l[i][1] - l[i][0];\n\t\t\tv *= 20010 / abs(v);\n\t\t\tl[i][0] -= v;\n\t\t\tl[i][1] += v;\n\t\t}\n\t\t\n\t\tif (n <= 2){\n\t\t\tcout << \"Many\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool none = false;\n\t\trep(i, n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, i){\n\t\t\t\tif (parallel(l[i], l[j])) cnt++;\n\t\t\t}\n\t\t\tif (cnt >= 2) none = true;\n\t\t}\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tvector<vector<Line>> bs;\n\t\trep(i, n) rep(j, i){\n\t\t\tbs.eb();\n\t\t\tLine a = l[i], b = l[j];\n\t\t\tif (parallel(a, b)){\n\t\t\t\tPoint no = (project(b, a[0]) - a[0]) / 2.0;\n\t\t\t\tbs.back().eb(a[0] + no, a[1] + no);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint cp = crossPoint(a, b);\n\t\t\t\tPoint u = a[0] - cp; u *= 20010 / abs(u);\n\t\t\t\tPoint v = b[0] - cp; v *= 20010 / abs(v);\n\t\t\t\tLine b1(u + v, -(u + v));\n\t\t\t\tLine b2 = b1;\n\t\t\t\tb2[0] *= Point(0, 1); b2[1] *= Point(0, 1);\n\t\t\t\tb1[0] += cp; b1[1] += cp;\n\t\t\t\tb2[0] += cp; b2[1] += cp;\n\t\t\t\tbs.back().eb(b1);\n\t\t\t\tbs.back().eb(b2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<Line> ls;\n\t\trep(i, bs.size()) for (auto b : bs[i]){\n\t\t\tls.eb(b);\n\t\t}\n\n\t\tvector<Point> cps;\n\t\t[&](){\n\t\t\trep(i, std::min<int>(bs.size(), 5)) rep(j, i){\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto a : bs[i]) for (auto b : bs[j]){\n\t\t\t\t\tif (!parallel(a, b)){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tcps.eb(crossPoint(a, b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tnone = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}();\n\n\t\tif (none){\n\t\t\tcout << \"None\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i, cps.size()) rep(j, i){\n\t\t\tif (cps[i] == cps[j]){\n\t\t\t\tswap(cps[i], cps.back());\n\t\t\t\tcps.pb();\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<bool> f(cps.size(), true);\n\t\trep(i, bs.size()){\n\t\t\trep(j, cps.size()){\n\t\t\t\tbool g = false;\n\t\t\t\tfor (auto b : bs[i]){\n\t\t\t\t\tif (intersect(b, cps[j])) g = true;\n\t\t\t\t}\n\t\t\t\tif (!g) f[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tPoint res;\n\t\trep(i, cps.size()){\n\t\t\tif (f[i]){\n\t\t\t\tcnt++;\n\t\t\t\tres = cps[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i, bs.size()){\n\t\t\tcout << i << endl;\n\t\t\tfor (auto b : bs[i]){\n\t\t\t\tprintf(\"%.4Lf %.4Lf %.4Lf %.4Lf\\n\", b[0].x, b[0].y, b[1].x, b[1].y);\n\t\t\t}\n\t\t}\n\t\tfor (auto cp : cps){\n\t\t\tprintf(\"%.3Lf %.3Lf\\n\", cp.x, cp.y);\n\t\t}\n\t\t*/\n\n\t\tif (cnt >= 2) cout << \"Many\\n\";\n\t\telse if (cnt == 0) cout << \"None\\n\";\n\t\telse printf(\"%.20Lf %.20Lf\\n\", res.x, res.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 5e-7;\n\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return P(rand(), rand()); // same line\n  if (abs(A) < EPS) return P(rand(), rand());// !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\nP incenter(const P &x, const P &y, const P &z){\n\tP a = y - x, b = z - x;\n\tP d1 = a / abs(a) + b / abs(b);\n\tP d2 = -a / abs(a) + (b - a) / abs(b - a);\n\treturn crosspoint(L(P(0, 0), d1), L(a, a + d2)) + x;\n}\nG excenter(const G &t){\n\tG res;\n\trep(i, 3){\n\t\tP a = t[i], b = t[(i + 1) % 3], c = t[(i + 2) % 3];\n\t\tres.pb(crosspoint(L(a, a + (a - c) / abs(a - c) + (b - a) / abs(b - a)),\n\t\tL(b, b + (b - c) / abs(b - c) + (a - b) / abs(a - b))));\n\t}\n\treturn res;\n}\nbool parallel(const L &l, const L &m){\n\treturn abs(cross(l[0] - l[1], m[0] - m[1])) < EPS;\n}\n\nint n;\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<L> ls;\n\t\trep(i, n){\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tL l(P(a, b), P(c, d));\n\t\t\trep(j, i) if(parallel(ls[j], l) && abs(cross(ls[j][0] - l[1], l[0] - l[1])) < EPS) goto SKIP;\n\t\t\t\n\t\t\tls.pb(l);\n\t\t\tSKIP:;\n\t\t}\n\t\tn = ls.size();\n\t\tif(n < 3){\n\t\t\tcout << \"Many\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tP p(INF, INF);\n\t\tG cand;\n\t\tbool pa[100][100] = {};\n\t\trep(i, n) rep(j, i) pa[i][j] = pa[j][i] = parallel(ls[i], ls[j]);\n\t\trep(i, n) rep(j, i) if(pa[i][j]) rep(k, j) if(pa[j][k]){\n\t\t\tcout << \"None\" << endl;\n\t\t\tgoto END;\n\t\t}\n\t\t\n\t\trep(i, n) rep(j, i) rep(k, j){\n\t\t\tif(pa[i][j] || pa[j][k] || pa[k][i]) continue;\n\t\t\tP x = crosspoint(ls[i], ls[j]), y = crosspoint(ls[j], ls[k]), z = crosspoint(ls[k], ls[i]);\n\t\t\tif(abs(x - y) < EPS && abs(y - z) < EPS){\n\t\t\t\tcand.pb(x);\n\t\t\t\tgoto OUT;\n\t\t\t}\n\t\t\t\n\t\t\tcand.pb(incenter(x, y, z));\n\t\t\tG g; g.pb(x); g.pb(y); g.pb(z);\n\t\t\tg = excenter(g);\n\t\t\tcand.insert(cand.end(), all(g));\n\t\t\tgoto OUT;\n\t\t}\n\t\tOUT:\n\t\t//each(i, cand) dbg(*i);\n\t\t\n\t\t\n\t\tif(cand.size()){\n\t\t\trep(it, cand.size()){\n\t\t\t\tbool ok = 1;\n\t\t\t\tdouble dist = distanceLP(ls[0], cand[it]);\n\t\t\t\trep(i, n) if(abs(dist - distanceLP(ls[i], cand[it])) > EPS){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tif(p.real() != INF){\n\t\t\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\t\t\tgoto END;\n\t\t\t\t\t}\n\t\t\t\t\tp = cand[it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p.real() == INF){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(n < 4){\n\t\t\t\tcout << \"Many\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(all(ls));\n\t\t\tdo{\n\t\t\t\tif(parallel(ls[0], ls[1]) && parallel(ls[2], ls[3])) break;\n\t\t\t}while(next_permutation(all(ls)));\n\t\t\t\n\t\t\tvector<L> t;\n\t\t\trep(i, 2){\n\t\t\t\tP m = (ls[i * 2][0] + ls[i * 2 + 1][0]) * 0.5;\n\t\t\t\tt.pb(L(m, m + ls[i * 2][1] - ls[i * 2][0]));\n\t\t\t}\n\t\t\tp = crosspoint(t[0], t[1]);\n\t\t\tdouble dist = distanceLP(ls[0], p);\n\t\t\trep(i, 4) if(abs(distanceLP(ls[i], p) - dist) > EPS){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.9f %.9f\\n\", p.real(), p.imag());\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\n\nPt p1[110];\nPt p2[110];\ndouble rd[100];\ndouble ld[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble X1,X2,Y1,Y2;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&X1,&Y1,&X2,&Y2);\n\t\t\tp1[i]=Pt(X1,Y1);\n\t\t\tp2[i]=Pt(X2,Y2);\n\t\t}\n\t\tif(a<=2){\n\t\t\tprintf(\"Many\\n\");continue;\n\t\t}\n\t\tif(iLL(p1[0],p2[0],p1[1],p2[1])==0&&iLL(p1[1],p2[1],p1[2],p2[2])==0){\n\t\t\tprintf(\"None\\n\");continue;\n\t\t}\n\t\tvector<pair<Pt,Pt> >L1;\n\t\tvector<pair<Pt,Pt> >L2;\n\t\tif(iLL(p1[0],p2[0],p1[1],p2[1])==0){\n\t\t\tPt L=(p1[0]+p1[1])/2;\n\t\t\tPt R=(p2[0]+p2[1])/2;\n\t\t\tif((L-R).ABS()<EPS){\n\t\t\t\tL=(p1[0]+p2[1])/2;\n\t\t\t\tR=(p2[0]+p1[1])/2;\n\t\t\t}\n\t\t\tL1.push_back(make_pair(L,R));\n\t\t}else{\n\t\t\tPt p=pLL(p1[0],p2[0],p1[1],p2[1]);\n\t\t\tdouble th=((p2[0]-p).arg()+(p2[1]-p).arg())/2;\n\t\t\tL1.push_back(make_pair(p,p+Pt(cos(th),sin(th))*10.0));\n\t\t\tL1.push_back(make_pair(p,p+Pt(-sin(th),cos(th))*10.0));\n\t\t}\n\t\tif(iLL(p1[2],p2[2],p1[1],p2[1])==0){\n\t\t\tPt L=(p1[2]+p1[1])/2;\n\t\t\tPt R=(p2[2]+p2[1])/2;\n\t\t\tif((L-R).ABS()<EPS){\n\t\t\t\tL=(p1[2]+p2[1])/2;\n\t\t\t\tR=(p2[2]+p1[1])/2;\n\t\t\t}\n\t\t\tL2.push_back(make_pair(L,R));\n\t\t}else{\n\t\t\tPt p=pLL(p1[2],p2[2],p1[1],p2[1]);\n\t\t\tdouble th=((p2[2]-p).arg()+(p2[1]-p).arg())/2;\n\t\t\tL2.push_back(make_pair(p,p+Pt(cos(th),sin(th))*10.0));\n\t\t\tL2.push_back(make_pair(p,p+Pt(-sin(th),cos(th))*10.0));\n\t\t}\n\t\tvector<Pt>hb;\n\t\tfor(int i=0;i<L1.size();i++)for(int j=0;j<L2.size();j++){\n\t\t\thb.push_back(pLL(L1[i].first,L1[i].second,L2[j].first,L2[j].second));\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<hb.size();i++){\n\t\t\trd[i]=-999999999;ld[i]=999999999;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble dist=dLP(p1[j],p2[j],hb[i]);\n\t\t\t\trd[i]=max(rd[i],dist);\n\t\t\t\tld[i]=min(ld[i],dist);\n\t\t\t}\n\t\t\tif(rd[i]-ld[i]<EPS)ans++;\n\t\t}\n\t\tif(ans>1)printf(\"Many\\n\");\n\t\telse if(ans==0)printf(\"None\\n\");\n\t\telse{\n\t\t\tfor(int i=0;i<hb.size();i++){\n\t\t\t\tif(rd[i]-ld[i]<EPS)printf(\"%f %f\\n\",hb[i].x,hb[i].y);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return (x!=p.x ? x-p.x<-eps : y-p.y<-eps);}\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n  return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  return r;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(all(vp));\n  res.pb(vp[0]);\n  FOR(i,1,vp.size())if(!(vp[i]==res.back()))res.pb(vp[i]);\n  return res;\n}\n\ntypedef pair<Line,Line> pll;\n\nint n;\nvector<Segment> vs;\nvector<Point> vp;\n\nbool check2(Point p){\n  double dis=getDistanceLP(vs[0],p);\n  FOR(i,1,n)\n    if(!equals(dis,getDistanceLP(vs[i],p)))return false;\n  return true;\n}\n\nvoid check1(Line a,Line b,Line c){\n  Point d=getCrossPointLL(a,c),e=getCrossPointLL(b,c);\n  Point m=d+(e-d)/2.0;\n  double dis=getDistanceLP(a,m);\n  Vector v=a.p1-a.p2;\n  v=v*dis/abs(v);\n  if(check2(m+v))vp.pb(m+v);\n  if(check2(m-v))vp.pb(m-v);\n  return;\n}\n\nvoid check3(pll a,pll b){\n  if(!isParallel(a.f,b.f)){\n    Point c=getCrossPointLL(a.f,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.f,b.s)){\n    Point c=getCrossPointLL(a.f,b.s);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.f)){\n    Point c=getCrossPointLL(a.s,b.f);\n    if(check2(c))vp.pb(c);\n  }\n  if(!isParallel(a.s,b.s)){\n    Point c=getCrossPointLL(a.s,b.s);\n    if(check2(c))vp.pb(c);\n  }\n}\n\npair<Line,Line> getS(Line a,Line b){\n  Point m=getCrossPointLL(a,b);\n  double r=getAngle(a.p1-a.p2,b.p1-b.p2);\n  Line c(rotate(m,a.p1,r/2.0),rotate(m,a.p2,r/2.0));\n  Line d(rotate(m,a.p1,(180.0-r)/2.0),rotate(m,a.p2,(180.0-r)/2.0));\n  return mp(c,d);\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      FOR(k,j+1,n){\n        if(isParallel(vs[i],vs[j]) && isParallel(vs[i],vs[k]))continue;\n        if(isParallel(vs[i],vs[j]))check1(vs[i],vs[j],vs[k]);\n        else if(isParallel(vs[i],vs[k]))check1(vs[i],vs[k],vs[j]);\n        else if(isParallel(vs[j],vs[k]))check1(vs[j],vs[k],vs[i]);\n        else {\n          pll a=getS(vs[i],vs[j]);\n          pll b=getS(vs[j],vs[k]);\n          pll c=getS(vs[k],vs[i]);\n          check3(a,b);\n          check3(b,c);\n          check3(c,a);\n        }\n      }\n    }\n  }\n  vp=unique(vp);\n  if(vp.empty())cout<<\"None\"<<endl;\n  else if(vp.size()>1)cout<<\"Many\"<<endl;\n  else printf(\"%.10f %.10f\\n\",vp[0].x,vp[0].y);\n  return;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    vs.clear();\n    vp.clear();\n    FOR(i,0,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      vs.pb(Segment(Point(a,b),Point(c,d)));\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (long double)(1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)\n    /(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))\n    *(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*(long double)100.0 + (c-b)/abs(c-b)*(long double)100.0;\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n\n    for(int j = 1; j < n; ++j){\n      if(abs(cross(V[0].first-V[0].second,V[j].first-V[j].second)) < EPS){\n        A.emplace_back((V[0].first+V[j].first)/(long double)2.0,\n                       (V[0].first+V[j].first)/(long double)2.0 + V[0].second - V[0].first);\n        B.emplace_back(A.back());\n      }else{\n        P c = intersection(V[0],V[j]);\n        A.push_back(angle_bisector(c+V[0].first-V[0].second,c,c+V[j].first-V[j].second));\n        P a = A.back().first, v = n_vector(A.back().second-a)*(long double)100.0;\n        B.emplace_back(a,a+v);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,A[0]) < EPS && p_to_l_dist(A[i].second,A[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,A[0]) < EPS && p_to_l_dist(B[i].second,A[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }else if(p_to_l_dist(A[i].second,B[0]) < EPS && p_to_l_dist(A[i].second,B[0]) < EPS){\n        C.push_back(A[i].first);\n        C.push_back(A[i].second);\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }else if(p_to_l_dist(B[i].second,B[0]) < EPS && p_to_l_dist(B[i].second,B[0]) < EPS){\n        C.push_back(B[i].first);\n        C.push_back(B[i].second);\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 1; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.size() == 0) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nvector<L> angleBisector(const L &l, const L &m) {\n  vector<L> res;\n  if (abs(cross(l[1]-l[0], m[1]-m[0])) > EPS) { // non-parallel\n    P p1 = crosspoint(l,m);\n    P p2 = p1+(l[1]-l[0] + m[1]-m[0])*0.5;\n    res.push_back(L(p1,p2));\n    p2 = p1+(l[1]-l[0] + m[0]-m[1])*0.5;\n    res.push_back(L(p1,p2));\n  } else {                      \n    P p1 = (projection(l,m[0])+m[0])*0.5;\n    res.push_back(L(p1,p1+l[1]-l[0]));\n  }\n  \n  return res;\n}\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<L> v;\n    REP(i,n) {\n      P p1, p2;\n      cin>>p1.real()>>p1.imag()>>p2.real()>>p2.imag();\n      v.push_back(L(p1,p2));\n    }\n    if (n<=2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> vl1 = angleBisector(v[0],v[1]);\n    vector<L> vl2 = angleBisector(v[0],v[2]);\n    set<P> se;\n    FOR(it, vl1) FOR(jt, vl2)\n      if (intersectLL(*it,*jt))\n        se.insert(crosspoint(*it,*jt));\n    vector<P> ans;\n    FOR(it, se) {\n      double d = -1;\n      bool dame = 0;\n      FOR(jt, v) {\n        if (d == -1) d = distanceLP(*jt, *it);\n        else if (abs(d-distanceLP(*jt,*it))>EPS) {\n          dame = 1;\n          break;\n        }\n      }\n      if (!dame) ans.push_back(*it);\n    }\n    if (ans.size() > 1) cout << \"Many\" << endl;\n    else if (ans.size() == 0) cout << \"None\" << endl;\n    else {\n      printf(\"%.5f %.5f\\n\", ans[0].real(), ans[0].imag());\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    //    REP(j,i+1,a.size()){\n    REP(j,i+1,i+3){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\t//\tb.pb(mp(tmp,tmp+rot2(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n\n\n//  \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n//  \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n//   \tcout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n//  \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" \n//  \t     <<\"[\"<<a[i].fir<<\",\" << a[i].sec<<\"],\" \n//  \t     <<\"[\"<<a[j].fir<<\",\" << a[j].sec<<\"],\" <<endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n//  \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n//  \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n//   \tcout <<\"[\"<< b[b.size()-1].fir<<\",\" << b[b.size()-1].sec<<\"],\"  \n//  \t     <<\"[\"<< b[b.size()-2].fir<<\",\" << b[b.size()-2].sec<<\"],\" \n//  \t     <<\"[\"<<a[i].fir<<\",\" << a[i].sec<<\"],\" \n//  \t     <<\"[\"<<a[j].fir<<\",\" << a[j].sec<<\"],\" <<endl;\n\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  rep(i,candy.size()){\n    //cout << candy[i] << endl;\n  }\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  //cout << sin(phi/2) <<\" \" << sin(arg(b/a)/2) << endl;\n\n  phi/=2;\n  phi=arg(b*conj(a))/2;\n\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-4;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-14L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    long double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nlong double dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\nlong double cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nlong double p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  long double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    long double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    vector<P> C, D;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/(long double)2.0,\n                         (V[i].second+V[j].second)/(long double)2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          A.push_back(angle_bisector(c+V[i].first-V[i].second,c,c+V[j].first-V[j].second));\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n        C.push_back(A.back().first);\n        C.push_back(A.back().second);\n      }\n    }\n\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      long double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n        if(D.size() > 1) break;\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12Lf %.12Lf\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n\nvector<L> ls;\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\n\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble PI = acos(-1);\n\t\t\tvector<L> ln;\n\t\t\tfor(int i = 0 ; i < min(n,10) ; i++){\n\t\t\t\tfor(int j = i+1 ; j < min(n,10) ; j++){\n\t\t\t\t\tdouble d = distanceLL(ls[i],ls[j]) / 2.;\n\t\t\t\t\tif( d > EPS ){\n\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t//f /= abs(f);\n\t\t\t\t\t\tP p = (ls[i][0]+ls[j][0])/2.;\n\t\t\t\t\t\tln.push_back(L(p,p+f));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector<L> l;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[i][1]-ls[i][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tP p = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]-r,ls[i][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[i][0]+r,ls[i][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP f = ls[j][1]-ls[j][0];\n\t\t\t\t\t\t\tf /= abs(f);\n\t\t\t\t\t\t\tP r = f * exp(P(0,PI/2.)); \n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]-r,ls[j][0]-r+f));\n\t\t\t\t\t\t\tl.push_back(L(ls[j][0]+r,ls[j][0]+r+f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p1 = crosspoint(ls[i],ls[j]);\n\t\t\t\t\t\t//cout << ls[i][0] << \"-\" << ls[i][1] << endl;\n\t\t\t\t\t\t//cout << ls[j][0] << \"-\" << ls[j][1] << endl;\n\t\t\t\t\t\t//cout << \"=\" << p1 << endl;\n\t\t\t\t\t\tfor(int k = 0 ; k < l.size() ; k++){\n\t\t\t\t\t\t\tfor(int w = k + 1 ; w < l.size() ; w++){\n\t\t\t\t\t\t\t\tif( intersectLL(l[k],l[w]) ){\n\t\t\t\t\t\t\t\t\tP p2 = crosspoint(l[k],l[w]);\n\t\t\t\t\t\t\t\t\tln.push_back(L(p1,p2));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<P> cand;\n\t\t\tP answer;\n\t\t\tint ok = 0;\n\t\t\tint many = 0;\n\t\t\tfor(int i = 0 ; i < ln.size() ; i++){\n\t\t\t\tfor(int j = i+1 ; j < ln.size() ; j++){\n\t\t\t\t\tP cp = crosspoint(ln[i],ln[j]);\n\t\t\t\t\tif( !intersectLL(ln[i],ln[j]) ) continue;\n\t\t\t\t\tdouble d = distanceLP(ls[0],cp);\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor(int k = 0 ; k < ls.size() ; k++){\n\t\t\t\t\t\tif( abs(d-distanceLP(ls[k],cp)) > EPS ){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif( ok++ ){\n\t\t\t\t\t\t\tif( abs(answer-cp) > 1e-7 )\n\t\t\t\t\t\t\t\tmany = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << cp << endl;\n\t\t\t\t\t\tanswer = cp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( many ){ puts(\"Many\"); }\n\t\t\telse if(ok) printf(\"%.10lf %.10lf\\n\",answer.real(),answer.imag());\n\t\t\telse puts(\"None\");\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble distance_lp(P a,P b,P c){\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !EQ( cross(a1-a2,b1-b2),0.0);\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a= a2-a1,b=b2-b1;\n  return a1+ a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  //cout << sin(phi/2) <<\" \" << sin(arg(b/a)/2) << endl;\n\n  phi/=2;\n  phi=arg(b/a)/2;\n\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  rep(i,1){\n    REP(j,i+1,a.size()){\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps);\n    else return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n  \n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n  \n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n    \n\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<set>\n \nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n \nusing namespace std;\n \ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n \nconst double infty = 1e40;\nconst double eps = 1.0e-6;\nconst double pi = acos(-1.0);\npoint base(0,0);\n \n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n \n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n \n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n \n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n \n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>0; }\nbool near(point a, point b){ return abs(b-a)<=0; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n \n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n \n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n \n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n \n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n \n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n \n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n \n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n \n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n \n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n \n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    scanf(\"%d\", &n);\n    if ( n == 0 ) break;\n\n    vector<line> vl;\n    for(int i = 0; i < n; ++i){\n      elem x1,y1,x2,y2;\n      scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n      point a(x1,y1);\n      point b(x2,y2);\n      vl.push_back(line(a,b));\n    }\n    vector<line> bisector;\n    vector< point > res;\n\n    for(int i = 1; i < n; ++i){\n      point is;\n      if(intersectionLL( vl[0], vl[i], is)){\n\tvec va;\n\tvec vb;\n\t\n\tif( far(is,vl[0].fr) ){\n\t  va = uvec(vl[0].fr-is);\n\t}else{\n\t  va = uvec(vl[0].sc-is);\n\t}\n\n\tif( far(is,vl[i].fr) ){\n\t  vb = uvec(vl[i].fr-is);\n\t}else{\n\t  vb = uvec(vl[i].sc-is);\n\t}\n\t\n\tbisector.push_back( line( is, is+va+vb ) );\n\tbisector.push_back( line( is, is+va-vb ) );\n\t\n      }else{\n\telem d = 0.5 * dist_l( vl[i], vl[0].fr );\n\tpoint is;\n\tintersectionLL( line(vl[0].fr, vl[0].fr+unmr(vl[0].sc-vl[0].fr) ), vl[i], is );\n\t\n\tpoint cfr = d * uvec(is-vl[0].fr) + vl[0].fr;\n\tpoint csc = d * uvec(is-vl[0].fr) + vl[0].sc;\n\tbisector.push_back( line(cfr,csc) );\n      }\n    }\n\n    for(int i = 0; i < (int)bisector.size(); ++i){\n      for(int j = i+1; j < (int)bisector.size(); ++j){\n\tpoint is;\n\tif( intersectionLL( bisector[i], bisector[j], is ) ){\n\t  elem d = dist_l( vl[0], is );\n\t  bool ng = false;\n\t  for(int k = 1; k < n; ++k){\n\t    if( !eq( d, dist_l( vl[k], is ) ) ){\n\t      ng = true;\n\t      break;\n\t    }\n\t  }\n\t  if( !ng ){\n\t    res.push_back(is);\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < (int)res.size(); ++i){\n      for(int j = i+1; j < (int)res.size(); ++j){\n\tif( abs(res[i]-res[j])<eps ){\n\t  res.erase( res.begin() + j );\n\t  i = -1;\n\t  break;\n\t}\n      }\n    }\n\n    //cout << res.size() << endl;\n    if( res.size() > 1 || n <= 2 ){\n      puts(\"Many\");\n    }else{\n      if( res.size() == 1 ){\n\tprintf(\"%.12lf %.12lf\\n\", res[0].real(), res[0].imag());\n      }else{\n\tputs(\"None\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          //cout << \"intersection \" << i << \" \" << j << \" \"  << c << endl;\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C;\n    vector<P> D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f){\n        D.push_back(c);\n\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else{\n      vector<P> D_;\n      sort(D.begin(),D.end());\n      D_.push_back(D[0]);\n      for(int i = 1; i < D.size(); ++i){\n        if(abs(D_.back()-D[i]) > (1e-5)){\n          D_.push_back(D[i]);\n        }\n      }\n      if(D_.size() == 1) printf(\"%.12f %.12f\\n\",D_[0].X,D_[0].Y);\n      else cout << \"Many\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x1, x2, y1, y2;\n    vector<L> V;\n    for(int i = 0; i < n; ++i){\n      cin >> x1 >> y1 >> x2 >> y2;\n      V.emplace_back(P(x1,y1),P(x2,y2));\n    }\n    if(n < 3){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<L> A, B;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if(abs(cross(V[i].first-V[i].second,V[j].first-V[j].second)) < EPS){\n          A.emplace_back((V[i].first+V[j].first)/2.0,(V[i].second+V[j].second)/2.0);\n          B.emplace_back(A.back());\n        }else{\n          P c = intersection(V[i],V[j]);\n          if(abs(c-V[i].first) > EPS && abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].first));\n          }else if(abs(c-V[i].first) > EPS){\n            A.push_back(angle_bisector(V[i].first,c,V[j].second));\n          }else if(abs(c-V[j].first) > EPS){\n            A.push_back(angle_bisector(V[i].second,c,V[j].first));\n          }else{\n            A.push_back(angle_bisector(V[i].second,c,V[j].second));\n          }\n          P a = A.back().first, v = n_vector(A.back().second-a);\n          B.emplace_back(a,a+v);\n        }\n      }\n    }\n    if(A.size() < 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<P> C, D;\n    for(int i = 1; i < A.size(); ++i){\n      if(abs(cross(A[0].first-A[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(A[0],A[i]));\n      }\n      if(abs(cross(A[0].first-A[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(A[0],B[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,A[i].first-A[i].second)) > EPS){\n        C.push_back(intersection(B[0],A[i]));\n      }\n      if(abs(cross(B[0].first-B[0].second,B[i].first-B[i].second)) > EPS){\n        C.push_back(intersection(B[0],B[i]));\n      }\n    }\n    sort(C.begin(),C.end());\n    for(int i = 0; i < C.size(); ++i){\n      P c = C[i];\n      double d = p_to_l_dist(c,V[0]);\n      bool f = true;\n      for(int j = 0; j < n; ++j){\n        if(abs(p_to_l_dist(c,V[j]) - d) > EPS){\n          f = false;\n          break;\n        }\n      }\n      if(f && (D.empty() || abs(D.back()-c) > EPS)){\n        D.push_back(c);\n      }\n    }\n    if(D.empty()) cout << \"None\" << endl;\n    else if(D.size() == 1) printf(\"%.12f %.12f\\n\",D[0].X,D[0].Y);\n    else cout << \"Many\" << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\nnamespace std{\n  bool operator < (const Point& p, const Point& q){\n    if(p.real() != q.real()) return p.real() < q.real();\n    return p.imag() < q.imag();\n  }\n}\n\nint sign(double a){\n  if(a > EPS) return 1;\n  if(a < -EPS) return -1;\n  return 0;\n}\nbool equal(Point a, Point b){\n  return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n}\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b){\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\nbool intersect(const Line& l, const Point& p){\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\ndouble distanceLP(const Line& l, const Point& p){\n  return abs(p - projection(l, p));\n}\n\nPoint crosspoint(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0) assert(false);\n  return m[0] + m.vector() * B / A;\n}\n\nbool ok(const vector<Line>& l, Point p){\n  REP(i, l.size() - 1) if(sign(distanceLP(l[i], p) - distanceLP(l[i + 1], p)) != 0) return false;\n  return true;\n}\nvoid insert(vector<Point>& ans, Point p){\n  if(ans.empty() || !equal(ans.front(), p)) return ans.push_back(p);\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Line> l;\n    REP(i, N){\n      Point p[2];\n      REP(j, 2) cin >> p[j].real() >> p[j].imag();\n      sort(p, p + 2);\n      l.push_back(Line(p[0], p[1]));\n    }\n    if(N <= 2){\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector<Line> mid_lines;\n    REP(i, N) FOR(j, i + 1, N){\n      if(paralell(l[i], l[j])){\n        assert(!equalLL(l[i], l[j]));\n        Point p = projection(l[i], l[j][0]);\n        Point p1 = (p - l[j][0]) * 0.5;\n        Point p2 = p1 + l[i].vector();\n        mid_lines.push_back(Line(p1, p2));\n      }else{\n        Point p = crosspoint(l[i], l[j]);\n        Point q = p + l[i].vector() / abs(l[i].vector()) + l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n        q = p + l[i].vector() / abs(l[i].vector()) - l[j].vector() / abs(l[j].vector());\n        mid_lines.push_back(Line(p, q));\n      }\n    }\n    // mid = 10000\n    vector<Point> ans;\n    int C = 0;\n    REP(i, mid_lines.size()) FOR(j, i + 1, mid_lines.size()){\n      if(C * N > 1000000) break;\n      C++;\n      if(ans.size() >= 2) break;\n      if(equalLL(mid_lines[i], mid_lines[j])){\n        REP(iter, 3){\n          double t = 1000.0 * rand() / RAND_MAX;\n          Point p = mid_lines[i][0] + mid_lines[i].vector() * t;\n          if(ok(l, p)) insert(ans, p);\n          else break;\n        }\n      }else if(!paralell(mid_lines[i], mid_lines[j])){\n        Point p = crosspoint(mid_lines[i], mid_lines[j]);\n        if(ok(l, p)) insert(ans, p);\n      }\n    }\n    if(ans.empty()) cout << \"None\" << endl;\n    else if(ans.size() == 1) printf(\"%.16lf %.16lf\\n\", ans.front().real(), ans.front().imag());\n    else cout << \"Many\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, long double> C;\nnamespace std {\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\n}\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n \n \n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\nlong double cross(const P &a, const P &b) { return imag(conj(a)*b); }\nlong double dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n    long double d = cross(b -= a, c -= a);\n    return d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n \nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); }\nP reflection(const L &l, const P &p) { return 2.0L * projection(l, p) - p; }\nlong double distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\nlong double distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\nlong double distanceSP(const L &s, const P &p) {\n    P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r-p);\n    return min(abs(s.first-p), abs(s.second-p));\n}\nlong double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n    P a = DI(l), b = DI(m);\n    long double A = cross(a, b), B = cross(a, l.second-m.first);\n \n    assert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n    /*    \n    double\n      x1 = l.first.real(),\n      y1 = l.first.imag(),\n      x2 = l.second.real(),\n      y2 = l.second.imag(),\n      x3 = m.first.real(),\n      y3 = m.first.imag(),\n      x4 = m.second.real(),\n      y4 = m.second.imag();\n    long double det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);\n    return\n      P((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),\n        (x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/det;\n    */\n    return m.first + B / A * b;\n}\n \nint n;\nL ls[110];\n \nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n \n  long double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n \nint main() {\n  while(cin >> n && n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n \n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n \n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (!parallel(ls[i], ls[j]) && !parallel(ls[i], ls[k])) {\n          found = true;\n \n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n \n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n \n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n \n          /*\n          cout << l1.first << \" \" << d1 << endl;\n          cout << l2.first << \" \" << d2 << endl;\n \n          FOR(it, ans) printf(\"%.20f %.20f\\n\", it->real(), it->imag());\n          */\n \n          sort(ALL(ans));\n          ans.erase(unique(ALL(ans)), ans.end());\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n     \n    //FOR(it,ans) cout << *it << endl;\n \n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1)\n        printf(\"%.8Lf %.8Lf\\n\", ans[0].real(), ans[0].imag());\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n       else {\n         assert(ok);\n         cout << \"None\" << endl;\n       }\n \n    }\n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = (m); i < (n); ++i)\n#define pb push_back\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> Pt;\ndouble dot(const Pt &a, const Pt &b) { return real(conj(a) * b); }\ndouble cross(const Pt &a, const Pt &b) { return imag(conj(a) * b); }\nnamespace std {\n    bool operator == (const Pt &a, const Pt &b) {\n        return abs(real(a) - real(b)) < EPS && abs(imag(a) - imag(b)) < EPS;\n    }\n}\n\nstruct Line : public vector<Pt>\n{\n    Line(){};\n    Line(const Pt &a, const Pt &b) {\n        pb(a); pb(b);\n    }\n};\n\nPt projection(const Line &l, const Pt &p)\n{\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distLP(const Line &l, const Pt &p)\n{\n    return abs(p - projection(l, p));\n}\n\nbool is_parallel(const Line &l, const Line &m)\n{\n    return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\nPt crosspoint(const Line &l, const Line &m)\n{\n    double a = cross(l[1] - l[0], m[1] - m[0]);\n    double b = cross(l[1] - l[0], l[1] - m[0]);\n    return m[0] + b / a * (m[1] - m[0]);\n}\n\n\nint main()\n{\n    int n, x1, y1, x2, y2;\n    cout << fixed << setprecision(4);\n    \n    while (cin >> n && n)\n    {\n        vector<Line> line;\n        rep(i, n) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            line.pb(Line(Pt(x1, y1), Pt(x2, y2)));\n        }\n        if(n < 3) { cout << \"Many\" << endl; continue; }\n        \n        vector<Pt> cand;\n        vector<Pt> insec;\n        vector<Line> bis;\n        vector<double> dist;\n        rep(i, 3)\n        {\n            Line &l1 = line[i], &l2 = line[(i+1)%3];\n            if(!is_parallel(l1, l2))\n            {\n                Pt p1 = l1[1] - l1[0], p2 = l2[1] - l2[0];\n                p1 /= abs(p1); p2 /= abs(p2);\n                Pt c = crosspoint(l1, l2);\n                bis.pb(Line(c, c + p1 + p2));\n                bis.pb(Line(c, c + p1 - p2));\n                insec.pb(c);\n            }\n            else\n            {\n                Pt p((real(l1[0]) + real(l2[0])) / 2, (imag(l1[0]) + imag(l2[0])) / 2);\n                bis.pb(Line(p, p + l1[1] - l1[0]));\n            }\n        }\n        rep(i, bis.size()) rep2(j, i + 1, bis.size())\n        {\n        \tif(is_parallel(bis[i], bis[j])) continue;\n            bool same = false;\n            Pt p = crosspoint(bis[i], bis[j]);\n            rep(k, cand.size()) if(p == cand[k]) same = true;\n            rep(k, insec.size()) if(p == insec[k]) same = true;\n            if(!same) cand.pb(p);\n        }\n        rep(i, cand.size()) dist.pb(distLP(line[0], cand[i]));\n        \n        rep2(i, 3, n) rep(j, cand.size()) if(abs(dist[j] - distLP(line[i], cand[j])) > EPS)\n        {\n            cand.erase(cand.begin() + j);\n            dist.erase(dist.begin() + j);\n            --j;\n        }\n        \n        if(cand.size() > 1)  cout << \"Many\" << endl;\n        if(cand.size() == 1) cout << real(cand[0]) << ' ' << imag(cand[0]) << endl;\n        if(cand.size() == 0) cout << \"None\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\nbool operator < (const P &a, const P &b) { return make_pair(real(a), imag(a)) < make_pair(real(b), imag(b)); }\nistream& operator >>(istream &in, P &p) { return in >> p.real() >> p.imag(); }\nistream& operator >>(istream &in, L &l) { return in >> l.first >> l.second; }\nistream& operator >>(istream &in, C &c) { return in >> c.first >> c.second; }\n\n\n#define DI(l) ((l).second-(l).first)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\ndouble cross(const P &a, const P &b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n/* ccw(a, b, c)\n * +1: counter clockwise\n * -1: clockwise\n * +2: c--a--b    on L\n * -2:    a--b--c on L\n *  0: c is on a--b\n */\nint ccw(P a, P b, P c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\nbool intersectLL(const L &l, const L &m) { return !parallel(l, m) || sameline(l, m); }\nbool intersectLP(const L &l, const P &p) { return EQ(cross(l.second-p, l.first-p), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nP projection(const L &l, const P &p) { return l.first + dot(p-l.first, DI(l)) / norm(DI(l)) * DI(l); } \nP reflection(const L &l, const P &p) { return 2.0 * projection(l, p) - p; }\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const L &l, const L &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m.first); }\ndouble distanceSP(const L &s, const P &p) {\n\tP r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s.first-p), abs(s.second-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)), min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\nP crosspoint(const L &l, const L &m) {\n\tP a = DI(l), b = DI(m);\n\tdouble A = cross(a, b), B = cross(a, l.second-m.first);\n\n  \tassert(!EQ(abs(A), 0)); // should not be parallel (if A = B = 0, then the same L)\n\treturn m.first + B / A * b;\n}\n\nint n;\nL ls[110];\n\nbool check(L l1, L l2) {\n  if (parallel(l1, l2)) return false;\n  P p = crosspoint(l1, l2);\n\n  double d = distanceLP(ls[0], p);\n  rep(i, n) {\n    if (!EQ(d, distanceLP(ls[i], p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> n, n) {\n    rep(i, n) cin >> ls[i];\n    vector<L> lss;\n    rep(i, n) {\n      bool ok = true;\n      rep(j, i) if (sameline(ls[i], ls[j])) ok = false;\n      if (ok) lss.pb(ls[i]);\n    }\n\n    n = SZ(lss);\n    rep(i, n) ls[i] = lss[i];\n\n    bool found = false;\n    vector<P> ans;\n    rep(i, n) {\n      rep(j, n) rep(k, j) {\n        if (j == i || k == i) continue;\n        if (intersectLL(ls[i], ls[j]) && intersectLL(ls[i], ls[k])) {\n          found = true;\n\n          P p = crosspoint(ls[i], ls[j]);\n          P d1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[j])/abs(DI(ls[j]));\n          P d2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[j])/abs(DI(ls[j]));\n          L l1(p, p + d1), l2(p, p + d2);\n\n          P q = crosspoint(ls[i], ls[k]);\n          P dq1 = DI(ls[i])/abs(DI(ls[i])) + DI(ls[k])/abs(DI(ls[k]));\n          P dq2 = DI(ls[i])/abs(DI(ls[i])) - DI(ls[k])/abs(DI(ls[k]));\n          L l3(q, q + dq1), l4(q, q + dq2);\n\n          if (check(l1, l3)) ans.pb(crosspoint(l1, l3));\n          if (check(l1, l4)) ans.pb(crosspoint(l1, l4));\n          if (check(l2, l3)) ans.pb(crosspoint(l2, l3));\n          if (check(l2, l4)) ans.pb(crosspoint(l2, l4));\n\n          goto AAA;\n        }\n      }\n    }\n  AAA:;\n\n    if (found) {\n      if (SZ(ans) == 0) cout << \"None\" << endl;\n      else if (SZ(ans) == 1) cout << fixed << ans[0].real() << \" \" << ans[0].imag() << endl;\n      else cout << \"Many\" << endl;\n    } else {\n      bool ok = true;\n      rep(i, n) if (!parallel(ls[0], ls[i])) ok = false;\n      if (n <= 2) cout << \"Many\" << endl;\n      else cout << \"None\" << endl;\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-8)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n#define PI acos(-1)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\nPoint rotateBasedOrigin(Point p, double theta) {\n  double rad = theta * PI/180;\n  return Point(p.x*cos(rad)-p.y*sin(rad), p.x*sin(rad)+p.y*cos(rad));\n}\n\nPoint rotate(Point o, Point p, double theta) {\n  Point q = p - o;\n  Point r = rotateBasedOrigin(q, theta);\n  return o + r;\n}\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vector<Line> lines;\n    rep(i, n) {\n      Point p, q;\n      cin >> p.x >> p.y >> q.x >> q.y;\n      lines.emplace_back(p, q);\n    }\n    if(n <= 2) {\n      cout << \"Many\" << endl;\n      continue;\n    }\n    vector< vector<Line> > bilines;\n    rep(i, n) reps(j, i+1, n) {\n      Line l = lines[i], r = lines[j];\n      Vector lv = l.p2 - l.p1, rv = r.p2 - r.p1;\n      lv = lv / abs(lv); rv = rv / abs(rv);\n      vector<Line> bi;\n      if(isParallel(l, r)) {\n\tPoint o = (l.p1+r.p1)/2;\n\tLine m = Line(o, o + lv);\n\tbi.push_back(m);\n\tbilines.push_back(bi);\n      } else {\n\tPoint p = getCrossPointLL(l, r);\n\tLine v = Line(p, p + lv + rv);\n\tLine w = Line(p, p + lv - rv);\n\tbi.push_back(v);\n\tbi.push_back(w);\n\tbilines.push_back(bi);\n      }\n    }\n    vector<Point> ans;\n    rep(i, min((int)bilines.size(), 10LL)) {\n      reps(j, i+1, min((int)bilines.size(), 10LL)) {\n\tvector<Line> a = bilines[i], b = bilines[j];\n\trep(k, a.size()) rep(l, b.size()) {\n\t  if(isParallel(a[k], b[l])) continue;\n\t  bool flag = true;\n\t  Point cp = getCrossPointLL(a[k], b[l]);\n\t  //cout<<cp.x<<\" \"<<cp.y<<endl;\n\t  double dist = getDistanceLP(lines[0], cp);\n\t  rep(x, n) {\n\t    //cout<<dist<< \" \"<< getDistanceLP(lines[x], cp) << endl;\n\t    if(!eq(dist, getDistanceLP(lines[x], cp))) flag = false;\n\t  }\n\t  rep(x, ans.size()) {\n\t    if(eq(abs(ans[x]-cp), 0)) flag = false;\n\t  }\n\t  if(flag) ans.push_back(cp);\n\t}\n      }\n    }\n    if(ans.size() == 0) cout << \"None\" << endl;\n    else if(ans.size() == 1) {\n      cout << ans[0].x << \" \" << ans[0].y << endl;\n    }\n    else cout << \"Many\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define mp         make_pair\n#define pb         push_back\n#define fir        first\n#define sec        second\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nconst double eps = 1e-10;\nconst double pi = acos(-1);\n#define EQ(a,b) (fabs(a-b)<eps)\n#define EQV(a,b) ( EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n#define EQ2(a,b) (fabs(a-b)<1e-05)\n#define EQV2(a,b) ( EQ2((a).real(),(b).real())&&EQ2((a).imag(),(b).imag()))\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    if (!(EQ(a.real(),b.real())))return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n  bool operator==(const P &a,const P &b){\n    return EQV2(a,b);\n  }\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_lp(P a,P b,P c){\n  return fabs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_ll(P a1,P a2,P b1,P b2){\n  return !(EQ(cross(a1-a2,b1-b2),0.0));\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nP rot(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\nP rot2(P a,P b){\n  double theta=arg(a);\n  double phi=arg(b);\n  swap(phi,theta);\n  if (phi < theta)phi+=2*pi;\n  phi-=theta;\n  phi/=2;\n  P ret;\n  ret.real()=cos(phi)*a.real()-sin(phi)*a.imag();\n  ret.imag()=sin(phi)*a.real()+cos(phi)*a.imag();\n  return ret;\n}\n\n\nvoid  makeall(vector<Line> &a,vector<Line> &b){\n\n  //  rep(i,1){\n  //    REP(j,i+1,a.size()){\n  rep(i,a.size()-1){\n    int j=i+1;\n      if (is_intersected_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec)){\n\tP tmp = intersection_ll(a[i].fir,a[i].sec,a[j].fir,a[j].sec);\n\tP at=EQV(a[i].fir,tmp)?a[i].sec:a[i].fir;\n\tP bt=EQV(a[j].fir,tmp)?a[j].sec:a[j].fir;\n\tb.pb(mp(tmp,tmp+rot(at-tmp,bt-tmp)));\n\t//\tb.pb(mp(tmp,tmp+rot2(at-tmp,bt-tmp)));\n \tP tmp2=b[b.size()-1].sec;\n \ttmp2-=tmp;\n \tswap(tmp2.real(),tmp2.imag());\n \ttmp2.real()*=-1;\n \ttmp2+=tmp;\n \tb.pb(mp(tmp,tmp2));\n\n\n// \tcout << cos(arg(b[b.size()-2].sec-b[b.size()-1].sec))<<\" \" \n// \t     << cos(arg(b[b.size()-1].sec-b[b.size()-2].sec)) <<endl;\n//  \tcout <<\"[\"<< tmp<<\",\" << b[b.size()-1].sec<<\"],\"  \n// \t     <<\"[\"<<tmp<<\",\" << b[b.size()-2].sec<<\"],\" \n// \t     <<\"[\"<<a[i].fir<<\",\" << a[i].sec<<\"],\" \n// \t     <<\"[\"<<a[j].fir<<\",\" << a[j].sec<<\"],\" <<endl;\n\n      }else {\n\tdouble d=distance_lp(a[i].fir,a[i].sec,a[j].fir)/2.;\n\tP hoge=a[i].sec-a[i].fir;\n\tswap(hoge.real(),hoge.imag());\n\thoge.real()*=-1;\n\thoge/=abs(hoge);\n\thoge*=d;\n\tb.pb(mp(a[i].fir+hoge,a[i].sec+hoge));\n\tb.pb(mp(a[j].fir+hoge,a[j].sec+hoge));\n      }\n    }\n  //  }\n}\n\nbool check(vector<Line> &a,P &b){\n  double tmp = distance_lp(a[0].fir,a[0].sec,b);\n  REP(i,1,a.size()){\n    if (!(fabs(tmp-distance_lp(a[i].fir,a[i].sec,b))<eps))return false;\n  }\n  return true;\n}\n\nvoid solve(vector<Line> &a){\n  vector<Line> b;\n  makeall(a,b);\n  P ans;\n  int cnt=0;\n  vector<P> candy;\n  rep(i,b.size() && cnt < 2){\n    REP(j,i+1,b.size()&&cnt<2){\n      if (is_intersected_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec)){\n\tP cand=intersection_ll(b[i].fir,b[i].sec,b[j].fir,b[j].sec);\n\tcandy.pb(cand);\n      }\n    }\n  }\n  \n  sort(candy.begin(),candy.end());\n  candy.erase(unique(candy.begin(),candy.end()),candy.end());\n\n  rep(i,candy.size()){\n    if (check(a,candy[i])){\n      ans=candy[i];\n      cnt++;\n      if (cnt ==2)break;\n    }\n  }\n\n\n  if (cnt == 0){\n    printf(\"None\\n\");\n  }else if(cnt == 1){\n    printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n  }else {\n    printf(\"Many\\n\");\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<Line> a(n);\n    rep(i,n){\n      rep(j,2){\n\tcin>>a[i].fir.real()>>a[i].fir.imag();\n\tswap(a[i].fir,a[i].sec);\n      }\n    }\n\n\n    sort(a.begin(),a.end());\n    if (a.size() == 1||a.size() ==2){\n      printf(\"Many\\n\");\n    }else solve(a);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-6)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n  \nusing namespace std;\n  \nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0,double y = 0): x(x),y(y){}\n  \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n  \n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n  \n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n  \n};\n  \nstruct Segment{\n  Point p1,p2;\n  int index;\n  Segment(Point p1 = Point(),Point p2 = Point(),int index=-1):p1(p1),p2(p2),index(index){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n  \n};\n  \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n  \nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n  \nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n  \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n  \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n  \ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n  \ndouble abs(Point a){ return sqrt(norm(a)); }\n  \n//rad ??????§?????????????????¢???????§???????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n  \n// ????????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n  \n// a => prev, b => cur, c=> next\n// prev ?????? cur ??????????£??? next ??????????????????§??????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n  \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n  \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n  \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n  \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n  \nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //?????????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n  \n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n    \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n    \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n   \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n// ------------------\n  \ndouble heron(Point A,Point B,Point C){\n  double a = abs(B-C);\n  double b = abs(A-C);\n  double c = abs(A-B);\n  double s = ( a + b + c ) / 2;\n  return sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n}\n  \nLine calcLine(Line line1,Line line2,Point p1,Point p2){\n  Point cp = crosspoint(line1,line2);\n  double S = heron(p1,cp,p2);\n  double a = abs(p1-cp);\n  double b = abs(p2-cp);\n  double arg_a = asin((2.0*S)/(a*b));\n  if( equals(2*S,a*b) ) arg_a = toRad(90);\n  //arg_a = getArg(p1,cp,p2);\n\n  assert( !( cp == p1 || cp == p2 || p1 == p2 ) );  \n\n  int res = ccw(cp,p1,p2);\n  //assert( ( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  //while( !( res == CLOCKWISE || res == COUNTER_CLOCKWISE ));\n  Point base;\n  if( res == COUNTER_CLOCKWISE ) base = p1;\n  else                           base = p2;\n  Point not_base = (base==p1)?p2:p1;\n  //cout << base << \" -> \" << cp << \" -> \" << not_base << endl;\n  arg_a = (toRad(180.0)-getArg(base,cp,not_base));\n  //puts(\"^^^^^\");\n  //cout << \"base = \" << base << \" | \" << (arg_a*180/M_PI)<< endl;\n  //cout << line1 << \" and \" << line2 << endl;\n  //cout << cp << \" | \" << p1 << \" | \" << p2 << endl;\n\n  Vector e = ( base - cp ) / abs( base - cp );\n  e = rotate(e,arg_a/2.0);\n  Line tmp = Line(cp,cp+e*100);\n  //cout << \"return = \" << tmp << endl;\n  //puts(\"_____\");  \n  return tmp;\n}\n  \nconst string MANY = \"Many\";\nconst string NONE = \"None\";\n#define all(x) (x.begin(),x.end())\nvoid compute(vector<Line> &vec){\n  \n  if( vec.size() <= 2 ) {\n    cout << MANY << endl;\n    return;\n  }\n  \n  vector<Line> candidateLines;\n  int n = vec.size();\n  rep(i,n) REP(j,i+1,n){\n    if( equals(cross(vec[i].p1-vec[i].p2,vec[j].p1-vec[j].p2),0.0) ) {\n      Vector e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      e = rotate(e,toRad(90));\n      Line line = Line(vec[i].p1,vec[i].p1+e*100);\n      Point cp1 = crosspoint(line,vec[i]);\n      Point cp2 = crosspoint(line,vec[j]);\n      Point mp = ( cp1 + cp2 ) / 2.0;\n      e = ( vec[i].p2 - vec[i].p1 ) / abs( vec[i].p2 - vec[i].p1 );\n      line = Line(mp,mp+e*100);\n      line.index = candidateLines.size();\n      candidateLines.push_back(line);\n    } else {\n      //cout << vec[i] << \" x \" << vec[j] << endl;\n      Point cp = crosspoint(vec[i],vec[j]);\n      Point I = ( vec[i].p1 == cp ) ? vec[i].p2 : vec[i].p1;\n      Point J = ( vec[j].p1 == cp ) ? vec[j].p2 : vec[j].p1;\n      Vector e1 = ( I - cp ) / abs( I - cp );\n      Vector e2 = ( J - cp ) / abs( J - cp );\n      Line tmp = calcLine(vec[i],vec[j],cp+e1*100,cp+e2*100);\n      //cout << \"tmp = \" << tmp << endl;\n      int Index = candidateLines.size();\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n      tmp = calcLine(vec[i],vec[j],cp+e1*100,cp-e2*100);\n      //cout << \"tmp = \" << tmp << endl;\n      tmp.index = Index;\n      candidateLines.push_back(tmp);\n    }\n    if( candidateLines.size() >= 50 ) break;\n  }\n    \n  vector<Point> candidatePoints;\n  \n  rep(i,candidateLines.size()) REP(j,i+1,candidateLines.size()) {\n    Line line1 = candidateLines[i];\n    Line line2 = candidateLines[j];\n    if( equals(cross(line1.p1-line1.p2,line2.p1-line2.p2),0.0) ) continue;\n    Point cp = crosspoint(line1,line2);    \n    candidatePoints.push_back(cp);\n  }\n  \n  vector<Point> &v = candidatePoints;\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  \n  vector<Point> answer;\n  rep(i,candidatePoints.size()){\n    Point p = candidatePoints[i];\n    //puts(\"\");\n    //cout << \"p = \" << p << endl;\n    double dist = -1;\n    bool success = true;\n    rep(j,vec.size()){\n      double tmp = distanceLP(vec[j],p);\n      if( equals(dist,-1) ) dist = tmp;\n      else if( !equals(dist,tmp) ) { success = false; /*break;*/ }\n      //cout << dist << \" ?? \" << tmp << endl;\n    }\n    //cout << \"success ?= \" << success << endl;\n    if( success ) answer.push_back(p);\n    if( answer.size() >= 2 ) break;\n  }\n  \n  if( answer.size() == 1 ) printf(\"%.10f %.10f\\n\",answer[0].x,answer[0].y);\n  else if( answer.empty() ) cout << NONE << endl;\n  else cout << MANY << endl;\n}\n  \nint main(){\n  /*\n  Point p = Point(0,1);\n  cout << rotate(p,toRad(90)) << endl;\n  */\n  int n;\n  while( cin >> n,n ){  \n    vector<Line> vec(n);\n    rep(i,n) cin >> vec[i].p1.x >> vec[i].p1.y >> vec[i].p2.x >> vec[i].p2.y;\n    compute(vec);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<random>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nmt19937 engine;\nint n;\nint x1[123],y_1[123],x2[123],y2[123];\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dist(P p,int idx){\n  P a=P(x1[idx],y_1[idx]);\n  P vb=P(x2[idx],y2[idx])-a;\n  return fabs(cross(p-a,vb)/abs(vb));\n}\n\ndouble ddiff(P p){\n  double mxd=-1,mnd=1e9;\n  for(int i=0;i<n;i++){\n    double d=dist(p,i);\n    mxd=max(mxd,d);\n    mnd=min(mnd,d);\n  }\n  return mxd-mnd;\n}\n\nbool par(int a,int b){\n  return fabs(dist(P(x1[a],y_1[a]),b)-dist(P(x2[a],y2[a]),b))<1e-9;\n}\n\nint main(){\n  for(;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x1[i]>>y_1[i]>>x2[i]>>y2[i];\n    }\n    if(n<=2){\n      cout<<\"Many\"<<endl;\n    }else if(n==3){\n      if(par(0,1)&&par(1,2)){\n\tcout<<\"None\"<<endl;\n      }else{\n\tcout<<\"Many\"<<endl;\n      }\n    }else{\n      P p=P(0,0);\n      double r=1e9;\n      for(int i=0;i<100000;i++,r*=.99){\n\tP np=p+polar(r,uniform_real_distribution<double>(0,9)(engine));\n\tif(ddiff(np)<ddiff(p)){\n\t  p=np;\n\t}\n      }\n      if(ddiff(p)<1e-5){\n\tcout<<fixed<<p.real()<<' '<<p.imag()<<endl;\n      }else{\n\tcout<<\"None\"<<endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\nconst D eps=1e-6;\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nbool intersectLL(L l,L m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nint main(){\n  while(1){\n    int N;\n    vector<L> ls;\n    cin>>N;\n    if(N==0)break;\n    rep(i,N){\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2;\n      ls.push_back(L(P(x1,y1),P(x2,y2)));\n    }\n    if(N<=2){\n      cout<<\"Many\"<<endl;\n      continue;\n    }\n    vector<P> candps;\n    {\n      vector<L> cls[3];\n      rep(i,3){\n        int j=(i+1)%3;\n        if(intersectLL(ls[i],ls[j])){\n          P cp=crosspoint(ls[i],ls[j]);\n          P v1=ls[i][1]-ls[i][0];\n          P v2=ls[j][1]-ls[j][0];\n          P v3=(abs(v2)*(abs(v1)+abs(v2)))*v1+(abs(v1)*(abs(v1)+abs(v2)))*v2;\n          cls[i].push_back(L(cp,cp+v3));\n          cls[i].push_back(L(cp,cp+P(-v3.Y,v3.X)));\n        }else{\n          P vv=P(ls[i][0].Y-ls[i][1].Y,ls[i][1].X-ls[i][0].X);\n          L vl=L(ls[i][0],ls[i][0]+vv);\n          P c1=crosspoint(vl,ls[i]); P c2=crosspoint(vl,ls[j]);\n          P mp=(c1+c2)/(long double)2.0;\n          cls[i].push_back(L(mp,mp+(ls[i][1]-ls[i][0])));\n        }\n      }\n      rep(a,cls[0].size())rep(b,cls[1].size())rep(c,cls[2].size()){\n        if(!intersectLL(cls[0][a],cls[1][b]))continue;\n        if(!intersectLL(cls[1][b],cls[2][c]))continue;\n        if(!intersectLL(cls[2][c],cls[0][a]))continue;\n        P p1=crosspoint(cls[0][a],cls[1][b]);\n        P p2=crosspoint(cls[1][b],cls[2][c]);\n        P p3=crosspoint(cls[2][c],cls[0][a]);\n        if(abs(p1-p2)<1e-4&&abs(p2-p3)<1e-4&&abs(p3-p1)<1e-4){\n          bool ok=true;\n          rep(z,candps.size())if(abs(candps[z]-p1)<eps){\n            ok=false;\n          }\n          if(ok)candps.push_back(p1);\n        }\n      }\n    }\n    vector<P> res;\n    rep(i,candps.size()){\n      vector<D> ds;\n      rep(j,N){\n        ds.push_back(distanceLP(ls[j],candps[i]));\n      }\n      bool ok=true;\n      rep(j,ds.size())rep(k,j){\n        if(abs(ds[j]-ds[k])>eps)ok=false;\n      }\n      if(ok)res.push_back(candps[i]);\n    }\n    if(res.size()==0)cout<<\"None\"<<endl;\n    else if(res.size()==1)printf(\"%.10Lf %.10Lf\\n\", res[0].X,res[0].Y);\n    else cout<<\"Many\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-5)\nclass P{                    //点\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //加算\n    P operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //減算\n    P operator * (const double k )const{ return P( x*k   , y*k    ); } //乗算\n    P operator / (const double k )const{ return P( x/k   , y/k    ); } //除算\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    bool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //ノルム\n    double abs() { return sqrt(norm()); }   //大きさ\n    void normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;}    //正規化\n};\nstruct C{P p;double r;};    //円\nstruct S{P p1,p2;};         //線分\ntypedef vector<P> Polygon;  //多角形\ntypedef P Vector;           //ベクトル\ntypedef S L;                //直線\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\n// 直線と直線の交点 vefiried AOJ CGL_2\nP getCrossPointSS(S l1, S l2){\n    double A = cross(vec(l1), vec(l2));\n    double B = cross(vec(l1), l1.p2 - l2.p1);\n    if(abs(A)<EPS && abs(B)<EPS) return l2.p1; // 二直線が重なっている\n    if(abs(A)<EPS) return P(INF,INF); // 直線が交わらない\n    return l2.p1 + vec(l2) * B / A;\n}\n\n//線分と点の距離 verified ARC042-B\ndouble dLP(S l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n\n\nbool isParallel(L a, L b){\n    if(cross(vec(a),vec(b))<EPS){\n        return true;\n    }else{\n        return false;\n    }\n}\n\n//線分に対する点の射影 verified AOJ CGL_1_A\nP projection(S s, P p){\n    Vector base = s.p2-s.p1;\n    double r = dot(p-s.p1, base)/norm(base);\n    return (base*r)+s.p1;\n}\n\nP normalize(P p) {\n    return p/abs(p);\n}\nvector<L> angle_bisector(const L &l, const L &m) {\n    vector<L> res;\n    if (abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS) { // non-parallel\n        P pos1 = getCrossPointSS(l,m);\n        P pos2 = pos1+(normalize(l.p2-l.p1) + normalize(m.p2-m.p1))*0.5;\n        res.push_back(L{pos1,pos2});\n        pos2 = pos1+(normalize(l.p2-l.p1) + normalize(m.p1-m.p2))*0.5;\n        res.push_back(L{pos1,pos2});\n        \n    } else {\n        P pos1 = (projection(l,m.p1)+m.p1)*0.5;\n        res.push_back(L{pos1,pos1+l.p2-l.p1});\n    }\n    \n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<L> lines(n);\n        rep(i,n){\n            P p1,p2;\n            cin>>p1.x>>p1.y>>p2.x>>p2.y;\n            lines[i] = L{p1, p2};\n        }\n        \n        if(n<=2){ cout<<\"Many\"<<endl; }\n        else{\n            vector<L> ls[2];\n            \n            ls[0] = angle_bisector(lines[0], lines[1]);\n            ls[1] = angle_bisector(lines[1], lines[2]);\n            \n            vector<P> vp;\n            rep(i,ls[0].size()){\n                rep(j,ls[1].size()){\n                    vp.pb( getCrossPointSS(ls[0][i], ls[1][j]) );\n                }\n            }\n            sort(all(vp));\n            vector<P> v;\n            v.pb(vp[0]);\n            rep(i,vp.size()-1){\n                P t = vp[i]-vp[i+1];\n                if( (t.x)<(1e-12) && abs(t.y)<(1e-12) )continue;\n                v.pb(vp[i+1]);\n            }\n            vp = v;\n            rep(i,vp.size()-1){\n                P t = vp[i]-vp[i+1];\n                assert( abs(t.x)>(1e-12) || abs(t.y)>(1e-12) );\n            }\n            \n            vector<P> ans;\n            for(auto elm:vp){\n                \n                bool flag = true;\n                for(int i=1;i<n;i++){\n                    if( abs(dLP(lines[0],elm) - dLP(lines[i],elm))<EPS ){\n                        ;\n                    }else{\n                        flag = false;\n                    }\n                }\n                if(flag){\n                    ans.pb(elm);\n                }\n            }\n            if(ans.size()>1){\n                cout<<\"Many\"<<endl;\n            }else if(ans.size()==1){\n                printf(\"%.20lf %.20lf\\n\",ans[0].x, ans[0].y);\n            }else{\n                cout<<\"None\"<<endl;\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 105\ntypedef complex<double> P;\n\ndouble eps=1e-6;\n\nbool eq(double a,double b){\n  \n  return (-eps < a-b && a-b < eps);\n}\n\nstruct S{\n  P s,t;\n};\n\nP intersect(P a,P b,P c,P d){\n  a-=d,b-=d,c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\nP intersect(S a,S b){\n  return intersect(a.s,a.t,b.s,b.t);\n}\n\nbool isParallel(S a,S b){\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  return eq( 0 , imag( ap/bp ) );\n}\n\ndouble distance(S a,P p){\n  return imag( (p-a.s)*conj(a.t-a.s) )/abs(a.t-a.s);\n}\n\nint n;\nS t[MAX_N];\n\nvector<S> calc(S a,S b){\n  vector<S> res;\n\n  P ap=a.t-a.s;\n  P bp=b.t-b.s;\n  \n  if( isParallel(a,b) ){\n    P o=(a.s+b.s)*0.5;\n    res.push_back( (S){o , o+ap } );\n    return res;\n  }\n  \n  P base=intersect(a,b);\n\n  ap/=abs(ap);\n  bp/=abs(bp);\n  res.push_back( (S){ base,base+ap+bp  });\n  res.push_back( (S){ base,base+ap-bp  });\n  return res;\n}\n\nvoid solve(){\n  if(n<=2){\n    cout<<\"Many\"<<endl;\n    return;\n  }\n  vector< P > vec;\n  \n  S a=t[0],b=t[1],c=t[2];\n  vector< S > va=calc(a,b),vb=calc(b,c),vc=calc(c,a);\n  for(int i=0;i<(int)va.size();i++){\n    for(int j=0;j<(int)vb.size();j++){\n      for(int k=0;k<(int)vc.size();k++){\n        S ab=va[i];\n        S bc=vb[j];\n        S ca=vc[k];\n        if( isParallel(ab,bc) || isParallel(bc,ca) || isParallel(ca,ab) ){\n          continue;\n        }\n\n\n        P target=intersect(ab,bc);\n        //        P q0=intersect(bc,ca);\n        //        P q1=intersect(ca,ab);\n        //        if( abs(target-q0) > eps )continue;\n        //        if( abs(target-q1) > eps )continue;\n        bool flg=true;\n        double dist= abs( distance( t[0] , target) );\n        for(int id=0;id<n;id++){\n          if( !eq( dist, abs(distance( t[id] , target) ) ) )\n            flg=false;\n        }\n\n        if(flg)vec.push_back(target);\n        \n      }\n    }\n  }\n  vector< P > ans;\n  for(int i=0;i<(int)vec.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)ans.size();j++){\n      if( abs(vec[i]-ans[j]) < eps )flg=false;\n    }\n    if(flg)ans.push_back(vec[i]);\n  }\n\n  \n  if(ans.size()==0){\n    cout<<\"None\"<<endl;\n  }else if(ans.size()==1){\n    printf(\"%.10f %.10f\\n\",real(ans[0]),imag(ans[0]));\n  }else{\n    cout<<\"Many\"<<endl;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      t[i].s=P(x,y);\n      cin>>x>>y;\n      t[i].t=P(x,y);\n\n\n      \n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-7;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\nbool EQ(double a,double b){\n\treturn fabs(a) < EPS;\n}\nbool GE(double a,double b){\n\treturn a > b - EPS;\n}\nbool LE(double a,double b){\n\treturn a < b + EPS;\n}\n\nint convex_contains(const polygon &P, const point &p) {\n  const int n = P.size();\n  point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n      if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n      else                                                  a = c;\n    } else {\n      if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nbool intersect_1pt(const point& a, const point& b,\n                   const point& c, const point& d, point &r) {\n  double D =  cross(b - a, d - c);\n  if (EQ(D, 0)) return false;\n  double t =  cross(c - a, d - c) / D;\n  double s = -cross(a - c, b - a) / D;\n  r = a + t * (b - a);\n  return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n}\npolygon convex_intersect(const polygon &P, const polygon &Q) {\n  const int n = P.size(), m = Q.size();\n  int a = 0, b = 0, aa = 0, ba = 0;\n  enum { Pin, Qin, Unknown } in = Unknown;\n  polygon R;\n  do {\n    int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n    double C = cross(P[a] - P[a1], Q[b] - Q[b1]);\n    double A = cross(P[a1] - Q[b], P[a] - Q[b]);\n    double B = cross(Q[b1] - P[a], Q[b] - P[a]);\n    point r;\n    if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n      if (in == Unknown) aa = ba = 0;\n      R.push_back( r );\n      in = B > 0 ? Pin : A > 0 ? Qin : in;\n    }\n    if (C == 0 && B == 0 && A == 0) {\n      if (in == Pin) { b = (b + 1) % m; ++ba; }\n      else           { a = (a + 1) % m; ++aa; }\n    } else if (C >= 0) {\n      if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n      else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n    } else {\n      if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n      else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n    }\n  } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n  if (in == Unknown) {\n    if (convex_contains(Q, P[0])) return P;\n    if (convex_contains(P, Q[0])) return Q;\n  }\n  return R;\n}\n\n\nvector<L> ls;\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\ndouble PI = acos(-1);\n \n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nG gen(L l,double d){\n\tP f = l[1]-l[0];\n\tf /= abs(f);\n\tP r = f * exp(P(0,PI/2.));\n\tP a = l[0] + r * d;\n\tP b = l[0] - r * d;\n\t\n\tdouble len = 100000;\n\tG g;\n\tg.push_back(a+f*len);\n\tg.push_back(a-f*len);\n\tg.push_back(b+f*len);\n\tg.push_back(b-f*len);\n\t\n\treturn convex_hull(g);\n}\ndouble ok(double d,int f=0){\n\tvector<P> co;\n\t\n\tfor(int i = 0 ; i < ls.size() ; i++){\n\t\tauto v = gen(ls[i],d);\n\t\tif(i==0){\n\t\t\tco = v;\n\t\t}else{\n\t\t\tif( area2(co) < EPS ) co.clear();\n\t\t\tif( co.size() ) co = convex_intersect(co,v);\n\t\t}\n\t}\n\tif(f){\n\t\tprintf(\"%.10lf %.10lf\\n\",co[0].real(),co[0].imag());\n\t}\n\treturn area2(co);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tls.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,c,d;\n\t\t\tcin >> x >> y >> c >> d;\n\t\t\tls.push_back(L(P(x,y),P(c,d)));\n\t\t}\n\t\tif( n <= 2 ){\n\t\t\tcout << \"Many\" << endl;\n\t\t}else{\n\t\t\tdouble l = 0, r = 100000;\n\t\t\tif( ok(r) < EPS ){\n\t\t\t\tcout << \"None\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0 ; i < 64 ; i++){\n\t\t\t\tdouble m = (l+r)/2.;\n\t\t\t\tif( ok(m) > 0 ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tok(l,1);\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#define EPS (1.0e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n  bool operator < (const Point &p) const {\n    if(!equals(x, p.x)) return x < p.x;\n    if(!equals(y, p.y)) return y < p.y;\n    return false;\n  }\n  bool operator == (const Point &p) const {\n    return equals(x, p.x) && equals(y, p.y);\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Line s1, Line s2) {\n  return isParallel(s1.p2-s1.p1, s2.p2-s2.p1);\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Line s1, Line s2) {\n  Vector a = s1.p2 - s1.p1;\n  Vector b = s2.p2 - s2.p1;\n  double d1 = cross(b, s2.p1 - s1.p1);\n  double d2 = cross(b, a);\n  return s1.p1 + a * d1/d2;\n}\n\nVector getOthogonalV(Vector a) {\n  return Vector(-a.y, a.x);\n}\n\nLine getOthogonalL(Line s) {\n  Line res;\n  res.p1 = s.p1;\n  res.p2 = s.p1 + getOthogonalV(s.p2 - s.p1);\n  return res;\n}\n\ndouble getDistanceLP(Line s, Point p) {\n  return fabs(cross(s.p2 - s.p1, p - s.p1))/abs(s.p2 - s.p1);\n}\n\nint N;\nLine S[100];\n\nvoid getBisector(vector<Line> &v) {\n  for(int i = 0; i < N; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      Vector a = S[i].p2 - S[i].p1;\n      Vector b = S[j].p2 - S[j].p1;\n      if(isParallel(S[i], S[j])) {\n\tdouble d = getDistanceLP(S[i], S[j].p1)/2.0;\n\tVector vn;\n\tif(ccw(S[i].p1, S[i].p2, S[j].p1) >= 1) {\n\t  vn.x = -a.y;\n\t  vn.y = a.x;\n\t} else {\n\t  vn.x = a.y;\n\t  vn.y = -a.x;\n\t}\n\tvn = vn*d/abs(vn);\n\tLine l;\n\tl.p1 = S[i].p1 + vn;\n\tl.p2 = S[i].p2 + vn;\n\tv.push_back(l);\n      } else {\n\tPoint p = getCrossPoint(S[i], S[j]);\n\tLine l;\n\tl.p1 = p;\n\tl.p2 = p + b+a*sqrt(norm(b)/norm(a));\n\tv.push_back(l);\n\tv.push_back(getOthogonalL(l));\n      }\n    }\n  }\n}\n\nvoid solve() {\n  if(N <= 2) {\n    cout << \"Many\" << endl;\n    return;\n  }\n  if(N == 3) {\n    bool f1 = isParallel(S[0], S[1]);\n    bool f2 = isParallel(S[1], S[2]);\n    bool f3 = isParallel(S[2], S[0]);\n    if(f1 && f2 && f3) {\n      cout << \"None\" << endl;\n      return;\n    } else {\n      cout << \"Many\" << endl;\n      return;\n    }\n  }\n\n  vector<Line> v;\n  getBisector(v);\n\n  vector<Point> cp;\n  for(int i = 0; i < v.size(); ++i) {\n    for(int j = i+1; j < v.size(); ++j) {\n      if(isParallel(v[i], v[j])) continue;\n      cp.push_back(getCrossPoint(v[i], v[j]));\n    }\n  }\n  sort(cp.begin(), cp.end());\n  cp.erase(unique(cp.begin(), cp.end()), cp.end());\n  int count = 0;\n  Point ans;\n  for(vector<Point>::iterator ii = cp.begin(); ii != cp.end(); ++ii) {\n    double d = getDistanceLP(S[0], *ii);\n    bool flag = true;\n    for(int j = 1; j < N; ++j) {\n      if(!equals(d, getDistanceLP(S[j], *ii))) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      ++count;\n      if(count >= 2) break;\n      ans = *ii;\n    }\n  }\n\n  if(count == 0) cout << \"None\" << endl;\n  else if(count == 1) printf(\"%.5f %.5f\\n\", ans.x, ans.y);\n  else if(count >= 2) cout << \"Many\" << endl;\n}\n\nmain() {\n  while((cin >> N) && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].p1.x >> S[i].p1.y >> S[i].p2.x >> S[i].p2.y;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2167 Find the Point\n// 2018.3.12 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\n\n#define INF\t\t\t1e8\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\nint ccw(PP p0, PP p1, PP p2) { PP a, b;\tdouble t;\n\ta = vsub(p1, p0), b = vsub(p2, p0), t = cross(a, b);\n\tif (t >  EPS) return 1;\tif (t < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nint zero_ccw(PP p0, PP p1, PP p2) { PP a = vsub(p1, p0), b = vsub(p2, p0);\n\treturn EQ(cross(a, b), 0);\t//3点が一直線か\n}\nPP dir(SEG s) { return vsub(s.e, s.s); }\nint is_intersectSS(SEG s1, SEG s2)\n{\n\treturn ccw(s1.s, s1.e, s2.s) * ccw(s1.s, s1.e, s2.e) <= 0 &&\n\t\t   ccw(s2.s, s2.e, s1.s) * ccw(s2.s, s2.e, s1.e) <= 0;\n}\n\nPP crossPointSS(int *ok, SEG s1, SEG s2)\n{\n\tdouble n, d;\n\tPP one = {1,1};\n\tn = cross(vsub(s2.s, s1.s), dir(s2));\n\td = cross(dir(s1), dir(s2));\n\tif (EQ(d,0)) { *ok = 0; return one; } \n\t*ok = 1;\n\treturn vadd(s1.s, vsmul(dir(s1), n/d));\n}\n\nPP crossPointLL(LINE ln1, LINE ln2)\n{\n\tPP u = vsub(ln1.e, ln1.s), v = vsub(ln2.e, ln2.s);\n\treturn vadd(ln1.s, vsmul(u, cross(v, vsub(ln2.s, ln1.s))/cross(v, u)));\n}\n\n// 点到直线的距离\ndouble distancePL(PP p, LINE ln) { PP a = vsub(ln.e, ln.s);\n\treturn fabs(cross(vsub(p, ln.s), a)) / vabs(a);\n}\n\nint is_parallelLL(LINE ln1, LINE ln2) {\n\treturn EQ(fabs(cross(vsub(ln1.s, ln1.e), vsub(ln2.s, ln2.e))), 0); }\n\n// 両平行線の中央線\nvoid centerlnLL(LINE *r, LINE ln1, LINE ln2) { PP s1, s2, e1, e2;\n\tif (ln1.s.x < ln1.e.x) s1 = ln1.s, e1 = ln1.e; else s1 = ln1.e, e1 = ln1.s;\n\tif (ln2.s.x < ln2.e.x) s2 = ln2.s, e2 = ln2.e; else s2 = ln2.e, e2 = ln2.s; \n\tr->s = vsmul(vadd(s1, s2), 0.5), r->e = vsmul(vadd(e1, e2), 0.5);\n}\n\nvoid bisectorlnLL(LINE *u, LINE *v, LINE ln1, LINE ln2)\n{\n\tPP x, y, p0 = crossPointLL(ln1, ln2);\n\tdouble a1, a2, w1, w2;\n\tw1 = vabs(vsub(ln1.s, p0)), w2 = vabs(vsub(ln1.e, p0));\n\tif (w1 >= w2) x = vsub(ln1.s, p0), a1 = w1; else x = vsub(ln1.e, p0), a1 = w2;\n\tw1 = vabs(vsub(ln2.s, p0)), w2 = vabs(vsub(ln2.e, p0));\n\tif (w1 >= w2) y = vsub(ln2.s, p0), a2 = w1; else y = vsub(ln2.e, p0), a2 = w2;\n\tu->s = vsmul(vadd(vadd(p0, x), vadd(p0, vsmul(y, a1/a2))), 0.5), u->e = p0;\n\tv->s = vadd(p0, vmul(vsub(u->s, p0), vset(0, 1))), v->e = p0;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') {\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nPP oddpoint[20]; int sz;\nLINE line[102];\nLINE candiln[100]; int candiln_id[100], sl;\n\nint pushback(LINE u, int id)\n{\n\tint i, j;\n\tPP p;\n\n\tfor (i = 0; i < sl; i++) {\n\t\tif (candiln_id[i] == id) continue;\n\t\tif (is_parallelLL(u, candiln[i])) {\n\t\t\tif (zero_ccw(u.s, u.e, candiln[i].s)) return sl;\n\t\t\telse return -1;\n\t\t} else {\n\t\t\tp = crossPointLL(u, candiln[i]);\n\t\t\tfor (j = 0; j < sz; j++) if (PPeQ(p, oddpoint[j])) break;\n\t\t\tif (j == sz) oddpoint[sz++] = p;\n\t\t}\n\t}\n\tcandiln[sl] = u, candiln_id[sl++] = id;\n\treturn sz;\n}\n\nint main()\n{\n\tint n, i, j, f, ans;\n\tPP anspoint;\n\tdouble dist, d;\n\tLINE u, v;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tline[i].s.x = in(), line[i].s.y = in();\n\t\t\tline[i].e.x = in(), line[i].e.y = in();\n\t\t}\n\t\tif (n <= 2) { puts(\"Many\"); continue; }\n\n\t\tsl = sz = 0;\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (is_parallelLL(line[i], line[j])) {\n\t\t\t\tcenterlnLL(&u, line[i], line[j]);\n\t\t\t\tpushback(u, (i<<7) | j);\n\t\t\t} else {\n\t\t\t\tbisectorlnLL(&u, &v, line[i], line[j]);\n\t\t\t\tpushback(u, (i<<7) | j);\n\t\t\t\tpushback(v, (i<<7) | j);\n\t\t\t}\n\t\t\tif (sz < 0) goto none;\n\t\t\tif (sz > 10) goto next;\n\t\t}\n\n\t\tnext: ans = 0; for (i = 0; i < sz; i++) {\n\t\t\tf = 1, dist = distancePL(oddpoint[i], line[0]);\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\td = distancePL(oddpoint[i], line[j]);\n\t\t\t\tif (!EQ(dist, d)) { f = 0; break; }\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tanspoint = oddpoint[i];\n\t\t\t\tif (++ans >= 2) break;\n\t\t\t}\n\t\t}\n\n\t\tif (ans == 0) {\n\t\t\tnone: puts(\"None\");\n\t\t} else if (ans >= 2) puts(\"Many\");\n\t\telse printf(\"%lf %lf\\n\", anspoint.x, anspoint.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2167 Find the Point\n// 2018.3.12 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\n\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\nint zero_ccw(PP p0, PP p1, PP p2) { PP a = vsub(p1, p0), b = vsub(p2, p0);\n\treturn EQ(cross(a, b), 0);\t//3点が一直線か\n}\n\n// 直線２本の交点\nPP crossPointLL(LINE ln1, LINE ln2)\n{\n\tPP u = vsub(ln1.e, ln1.s), v = vsub(ln2.e, ln2.s);\n\treturn vadd(ln1.s, vsmul(u, cross(v, vsub(ln2.s, ln1.s))/cross(v, u)));\n}\n\n// 点到直线的距离\ndouble distancePL(PP p, LINE ln) { PP a = vsub(ln.e, ln.s);\n\treturn fabs(cross(vsub(p, ln.s), a)) / vabs(a);\n}\n\nint is_parallelLL(LINE ln1, LINE ln2) {\n\treturn EQ(fabs(cross(vsub(ln1.s, ln1.e), vsub(ln2.s, ln2.e))), 0); }\n\n// 両平行線の中央線\nvoid centerlnLL(LINE *r, LINE ln1, LINE ln2) { PP s1, s2, e1, e2;\n\tif (ln1.s.x < ln1.e.x) s1 = ln1.s, e1 = ln1.e; else s1 = ln1.e, e1 = ln1.s;\n\tif (ln2.s.x < ln2.e.x) s2 = ln2.s, e2 = ln2.e; else s2 = ln2.e, e2 = ln2.s; \n\tr->s = vsmul(vadd(s1, s2), 0.5), r->e = vsmul(vadd(e1, e2), 0.5);\n}\n\n// 2等分線\nvoid bisectorlnLL(LINE *u, LINE *v, LINE ln1, LINE ln2)\n{\n\tPP x, y, p0 = crossPointLL(ln1, ln2);\n\tdouble a1, a2, w1, w2;\n\tw1 = vabs(vsub(ln1.s, p0)), w2 = vabs(vsub(ln1.e, p0));\n\tif (w1 >= w2) x = vsub(ln1.s, p0), a1 = w1; else x = vsub(ln1.e, p0), a1 = w2;\n\tw1 = vabs(vsub(ln2.s, p0)), w2 = vabs(vsub(ln2.e, p0));\n\tif (w1 >= w2) y = vsub(ln2.s, p0), a2 = w1; else y = vsub(ln2.e, p0), a2 = w2;\n\tu->s = vsmul(vadd(vadd(p0, x), vadd(p0, vsmul(y, a1/a2))), 0.5), u->e = p0;\n\tv->s = vadd(p0, vmul(vsub(u->s, p0), vset(0, 1))), v->e = p0;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') {\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nPP oddpoint[20]; int sz;\nLINE line[102];\nLINE candiln[100]; int candiln_id[100], sl;\n\nint pushback(LINE u, int id)\n{\n\tint i, j;\n\tPP p;\n\n\tfor (i = 0; i < sl; i++) {\n\t\tif (candiln_id[i] == id) continue;\n\t\tif (is_parallelLL(u, candiln[i])) {\n\t\t\tif (zero_ccw(u.s, u.e, candiln[i].s)) return sl;\n\t\t\telse return -1;\n\t\t} else {\n\t\t\tp = crossPointLL(u, candiln[i]);\n\t\t\tfor (j = 0; j < sz; j++) if (PPeQ(p, oddpoint[j])) break;\n\t\t\tif (j == sz) oddpoint[sz++] = p;\n\t\t}\n\t}\n\tcandiln[sl] = u, candiln_id[sl++] = id;\n\treturn sz;\n}\n\nint main()\n{\n\tint n, i, j, f, ans;\n\tPP anspoint;\n\tdouble dist, d;\n\tLINE u, v;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tline[i].s.x = in(), line[i].s.y = in();\n\t\t\tline[i].e.x = in(), line[i].e.y = in();\n\t\t}\n\t\tif (n <= 2) { puts(\"Many\"); continue; }\n\n\t\tsl = sz = 0;\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (is_parallelLL(line[i], line[j])) {\n\t\t\t\tcenterlnLL(&u, line[i], line[j]);\t\t// center line between two parallel lines\n\t\t\t\tpushback(u, (i<<7) | j);\n\t\t\t} else {\n\t\t\t\tbisectorlnLL(&u, &v, line[i], line[j]);\t// two bisector lines\n\t\t\t\tpushback(u, (i<<7) | j);\n\t\t\t\tpushback(v, (i<<7) | j);\n\t\t\t}\n\t\t\tif (sz < 0) goto none;\t\t\t// the case: 4 parallel lines or more\n\t\t\tif (sz > 10) goto next;\n\t\t}\n\n\t\tnext: ans = 0; for (i = 0; i < sz; i++) {\n\t\t\tf = 1, dist = distancePL(oddpoint[i], line[0]);\n\t\t\tfor (j = 1; j < n; j++) {\n\t\t\t\td = distancePL(oddpoint[i], line[j]);\n\t\t\t\tif (!EQ(dist, d)) { f = 0; break; }\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tanspoint = oddpoint[i];\n\t\t\t\tif (++ans >= 2) break;\n\t\t\t}\n\t\t}\n\n\t\tif (ans == 0) {\n\t\t\tnone: puts(\"None\");\n\t\t} else if (ans >= 2) puts(\"Many\");\n\t\telse printf(\"%lf %lf\\n\", anspoint.x, anspoint.y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "ERROR = 1e-7\n\nrequire 'mathn'\ninclude Math\nclass Line\n\trequire 'matrix'\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c)\n\tend\n\n\tdef self.through_one_point(x, y, rad)\n\t\ta = sin(rad)\n\t\tb = -cos(rad)\n\t\tc = a * x + b * y\n\t\tnew(a, b, c)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tdef vertical?\n\t\tb == 0\n\tend\n\n\tdef y(x)\n\t\t(c - a * x) / b\n\tend\n\n\tdef x(y)\n\t\t(c - b * y) / a\n\tend\n\n\tdef parallel?(l)\n\t\t(@a * l.b - @b * l.a).abs < ERROR\n\tend\n\n\tdef angle\n\t\tatan2(@a, -@b)\n\tend \n\n\tdef dist(s, t)\n\t\tu, v = nil\n\t\tu = Vector[b, -a]\n\t\tif vertical?\n\t\t\tv = Vector[s, t]\t\n\t\telse\n\t\t\tv = Vector[s, t - y(0)]\n\t\tend\n\n\t\ta = u.inner_product(v) / u.r\n\t\tx = v.r ** 2 - a ** 2\n\t\tx = 0 if x < 0\n\t\tsqrt(x)\n\tend\n\n\tdef through?(x, y)\n\t\t(@a * x + @b * y - c).abs < ERROR\n\tend\n\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tpara_num = {}\n\tlines = []\n\tn.times do\n\t\tl = Line.through_two_points(*gets.split.map(&:to_i))\n\t\tif rep = para_num.keys.find {|rep| l.parallel?(rep)}\n\t\t\tpara_num[rep] += 1\n\t\telse\n\t\t\tpara_num[l] = 1\n\t\tend\n\t\tlines << l\n\tend\n\n\tif para_num.size == 1\n\t\tif para_num.values[0] < 3\n\t\t\tputs 'Many'\n\t\telse\n\t\t\tputs 'None'\n\t\tend\n\telsif para_num.values.max >= 3\n\t\tputs 'None'\n\telsif para_num.size == 2\n\t\tif para_num.values.max == 1\n\t\t\tputs 'Many'\n\t\telsif para_num.values.min == 1\n\t\t\tputs 'Many'\n\t\telse\n\t\t\tl1 = lines.shift\n\t\t\tl2 = lines.find {|l| l.parallel?(l1)}\n\t\t\tl3, l4 = lines - [l2]\n\t\t\tl5, l6 = nil, nil\n\t\t\tif l1.vertical?\n\t\t\t\tl5 = Line.through_two_points((l1.x(0) + l2.x(0)) / 2, 0, (l1.x(1) + l2.x(1)) / 2, 1)\n\t\t\telse\n\t\t\t\tl5 = Line.through_two_points(0, (l1.y(0) + l2.y(0)) / 2, 1, (l1.y(1) + l2.y(1)) / 2)\n\t\t\tend\n\t\t\tif l3.vertical?\n\t\t\t\tl6 = Line.through_two_points((l3.x(0) + l4.x(0)) / 2, 0, (l3.x(1) + l4.x(1)) / 2, 1)\n\t\t\telse\n\t\t\t\tl6 = Line.through_two_points(0, (l3.y(0) + l4.y(0)) / 2, 1, (l3.y(1) + l4.y(1)) / 2)\n\t\t\tend\n\n\t\t\tx, y = l5.cross_point(l6)\n\t\t\tif (l1.dist(x, y) - l3.dist(x, y)).abs < ERROR\n\t\t\t\tputs [x.to_f, y.to_f].join \" \"\n\t\t\telse\n\t\t\t\tputs 'Many'\n\t\t\tend\n\t\tend\n\telse\n\t\tcandidates = []\n\t\tl1, l2, l3 = para_num.keys[0..2]\n\t\tx, y = l1.cross_point(l2)\n\t\tif l3.through?(x, y)\n\t\t\tcandidates << [x, y]\n\t\telse\n\t\t\tbisec = []\n\t\t\t[l1, l2, l3].combination(2) do |la, lb|\n\t\t\t\tbisec << Line.through_one_point(*la.cross_point(lb), (la.angle + lb.angle) / 2)\n\t\t\t\tbisec << Line.through_one_point(*la.cross_point(lb), (la.angle + lb.angle + PI) / 2)\n\t\t\tend\n\t\t\tbisec.combination(3) do |la, lb, lc|\n\t\t\t\tnext if la.parallel?(lb) or la.parallel?(lc)\n\t\t\t\tx, y = la.cross_point(lb)\n\t\t\t\tcandidates << [x, y] if lc.through?(x, y)\n\t\t\tend\n\t\t\tans = []\n\t\t\tcandidates.each do |x, y|\n\t\t\t\tds = lines.map{|l| l.dist(x, y)}\n\t\t\t\td0 = ds.shift\n\t\t\t\tif ds.all?{|d| (d - d0).abs < ERROR}\n\t\t\t\t\tans << [x, y]\n\t\t\t\tend\n\t\t\tend\n\t\t\tif ans.size > 1\n\t\t\t\tputs 'Many'\n\t\t\telsif ans.size == 1\n\t\t\t\tputs ans.flatten.join \" \"\n\t\t\telse \n\t\t\t\tputs 'None'\n\t\t\tend\n\t\tend\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "ERROR = 1e-5\n\nrequire 'mathn'\ninclude Math\nclass Line\n\trequire 'matrix'\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c)\n\tend\n\n\tdef self.through_one_point(x, y, rad)\n\t\ta = sin(rad)\n\t\tb = -cos(rad)\n\t\tc = a * x + b * y\n\t\tnew(a, b, c)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tdef vertical?\n\t\tb == 0\n\tend\n\n\tdef y(x)\n\t\t(c - a * x) / b\n\tend\n\n\tdef x(y)\n\t\t(c - b * y) / a\n\tend\n\n\tdef parallel?(l)\n\t\t(@a * l.b - @b * l.a).abs < ERROR\n\tend\n\n\tdef angle\n\t\tatan2(@a, -@b)\n\tend \n\n\tdef dist(x, y)\n\t\t(@a * x + @b * y - c).abs / sqrt(@a ** 2 + @b ** 2)\n\tend\n\n\tdef through?(x, y)\n\t\t(@a * x + @b * y - c).abs < ERROR\n\tend\n\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tpara_num = {}\n\tlines = []\n\tn.times do\n\t\tl = Line.through_two_points(*gets.split.map(&:to_i))\n\t\tif rep = para_num.keys.find {|rep| l.parallel?(rep)}\n\t\t\tpara_num[rep] += 1\n\t\telse\n\t\t\tpara_num[l] = 1\n\t\tend\n\t\tlines << l\n\tend\n\n\tif para_num.size == 1\n\t\tif para_num.values[0] < 3\n\t\t\tputs 'Many'\n\t\telse\n\t\t\tputs 'None'\n\t\tend\n\telsif para_num.values.max >= 3\n\t\tputs 'None'\n\telsif para_num.size == 2\n\t\tif para_num.values.max == 1\n\t\t\tputs 'Many'\n\t\telsif para_num.values.min == 1\n\t\t\tputs 'Many'\n\t\telse\n\t\t\tl1 = lines.shift\n\t\t\tl2 = lines.find {|l| l.parallel?(l1)}\n\t\t\tl3, l4 = lines - [l2]\n\t\t\tl5, l6 = nil, nil\n\t\t\tif l1.vertical?\n\t\t\t\tl5 = Line.through_two_points((l1.x(0) + l2.x(0)) / 2, 0, (l1.x(1) + l2.x(1)) / 2, 1)\n\t\t\telse\n\t\t\t\tl5 = Line.through_two_points(0, (l1.y(0) + l2.y(0)) / 2, 1, (l1.y(1) + l2.y(1)) / 2)\n\t\t\tend\n\t\t\tif l3.vertical?\n\t\t\t\tl6 = Line.through_two_points((l3.x(0) + l4.x(0)) / 2, 0, (l3.x(1) + l4.x(1)) / 2, 1)\n\t\t\telse\n\t\t\t\tl6 = Line.through_two_points(0, (l3.y(0) + l4.y(0)) / 2, 1, (l3.y(1) + l4.y(1)) / 2)\n\t\t\tend\n\n\t\t\tx, y = l5.cross_point(l6)\n\t\t\tif (l1.dist(x, y) - l3.dist(x, y)).abs < ERROR\n\t\t\t\tputs [x.to_f, y.to_f].join \" \"\n\t\t\telse\n\t\t\t\tputs 'Many'\n\t\t\tend\n\t\tend\n\telse\n\t\tcandidates = []\n\t\tl1, l2, l3 = para_num.keys[0..2]\n\t\tx, y = l1.cross_point(l2)\n\t\tif l3.through?(x, y)\n\t\t\tcandidates << [x, y]\n\t\telse\n\t\t\tbisec = []\n\t\t\t[l1, l2, l3].combination(2) do |la, lb|\n\t\t\t\tbisec << Line.through_one_point(*la.cross_point(lb), (la.angle + lb.angle) / 2)\n\t\t\t\tbisec << Line.through_one_point(*la.cross_point(lb), (la.angle + lb.angle + PI) / 2)\n\t\t\tend\n\t\t\tbisec.combination(3) do |la, lb, lc|\n\t\t\t\tnext if la.parallel?(lb) or la.parallel?(lc)\n\t\t\t\tx, y = la.cross_point(lb)\n\t\t\t\tcandidates << [x, y] if lc.through?(x, y)\n\t\t\tend\n\t\tend\n\n\t\tans = []\n\t\tcandidates.each do |x, y|\n\t\t\tds = lines.map{|l| l.dist(x, y)}\n\t\t\td0 = ds.shift\n\t\t\tif ds.all?{|d| (d - d0).abs < ERROR}\n\t\t\t\tans << [x, y]\n\t\t\tend\n\t\tend\n\n\t\tif ans.size > 1\n\t\t\tputs 'Many'\n\t\telsif ans.size == 1\n\t\t\tputs ans.flatten.join \" \"\n\t\telse \n\t\t\tputs 'None'\n\t\tend\n\tend\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nEPS = 1e-9\ndef line_cross_point(P1, P2, Q1, Q2):\n    x0, y0 = P1; x1, y1 = P2\n    x2, y2 = Q1; x3, y3 = Q2\n\n    dx0 = x1 - x0; dy0 = y1 - y0\n    dx1 = x3 - x2; dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if -EPS < sm < EPS:\n        return None\n    return x0 + s*dx0/sm, y0 + s*dy0/sm\n\ndef bisector(P1, P2, Q1, Q2):\n    x0, y0 = P1; x1, y1 = P2\n    x2, y2 = Q1; x3, y3 = Q2\n\n    dx0 = x1 - x0; dy0 = y1 - y0\n    dx1 = x3 - x2; dy1 = y3 - y2\n\n    cp = line_cross_point(P1, P2, Q1, Q2)\n    if cp is None:\n        return None\n\n    cx, cy = cp\n\n    d0 = (dx0**2 + dy0**2)**.5\n    d1 = (dx1**2 + dy1**2)**.5\n    return [\n        ((cx, cy), (cx + (dx0*d1 + dx1*d0), cy + (dy0*d1 + dy1*d0))),\n        ((cx, cy), (cx + (dx0*d1 - dx1*d0), cy + (dy0*d1 - dy1*d0))),\n    ]\n\ndef line_point_dist2(p1, p2, q):\n    x, y = q\n\n    x1, y1 = p1; x2, y2 = p2\n    dx = x2 - x1; dy = y2 - y1\n    dd = dx**2 + dy**2\n    sv = (x - x1) * dy - (y - y1) * dx\n    return abs(sv / dd**.5)\n\n\ndef check(LS, q):\n    ds = [line_point_dist2(p1, p2, q) for p1, p2 in LS]\n    return all(abs(ds[0] - e) < EPS for e in ds)\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    P = []\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, readline().split())\n        P.append(((x1, y1), (x2, y2)))\n    if N <= 2:\n        write(\"Many\\n\")\n        return True\n\n    s = []\n    for i in range(N):\n        p1, p2 = P[i]\n        for j in range(i):\n            q1, q2 = P[j]\n            bs = bisector(p1, p2, q1, q2)\n            if bs is None:\n                continue\n            s.append(bs)\n            if len(s) > 1:\n                break\n        else:\n            continue\n        break\n    if len(s) < 2:\n        write(\"None\\n\")\n        return True\n    ans = []\n    b1, b2 = s\n    for p1, p2 in b1:\n        for q1, q2 in b2:\n            cp = line_cross_point(p1, p2, q1, q2)\n            if cp is None:\n                continue\n            if check(P, cp):\n                cx, cy = cp\n                for ax, ay in ans:\n                    if abs(cx - ax) < EPS and abs(cy - ay) < EPS:\n                        break\n                else:\n                    ans.append(cp)\n    if len(ans) == 0:\n        write(\"None\\n\")\n    elif len(ans) > 1:\n        write(\"Many\\n\")\n    else:\n        write(\"%.16f %.16f\\n\" % ans[0])\n    return True\nwhile solve():\n    ...\n"
  }
]