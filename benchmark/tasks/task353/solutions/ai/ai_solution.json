[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EPS 1e-8\n\ntypedef struct {\n    double a, b, c;\n} Line;\n\ntypedef struct {\n    double x, y;\n} Point;\n\nLine lines[100];\nint n;\n\ndouble det(double a, double b, double c, double d) {\n    return a * d - b * c;\n}\n\nPoint intersect(Line l1, Line l2) {\n    double d = det(l1.a, l1.b, l2.a, l2.b);\n    if (fabs(d) < EPS) {\n        return (Point){NAN, NAN};\n    }\n    double x = det(l1.b, l1.c, l2.b, l2.c) / d;\n    double y = det(l1.c, l1.a, l2.c, l2.a) / d;\n    return (Point){-x, -y};\n}\n\ndouble distance(Point p, Line l) {\n    return fabs(l.a * p.x + l.b * p.y + l.c) / sqrt(l.a * l.a + l.b * l.b);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf\", &lines[i].a, &lines[i].b, &lines[i].c);\n    }\n\n    if (n == 1) {\n        printf(\"Multiple solutions. All points on the line are equidistant.\\n\");\n        return 0;\n    }\n\n    Point sol;\n    int found = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point p = intersect(lines[i], lines[j]);\n            if (isnan(p.x)) continue;\n\n            int valid = 1;\n            double dist = distance(p, lines[0]);\n            for (int k = 1; k < n; k++) {\n                if (fabs(distance(p, lines[k]) - dist) > EPS) {\n                    valid = 0;\n                    break;\n                }\n            }\n\n            if (valid) {\n                if (found) {\n                    printf(\"Multiple solutions.\\n\");\n                    return 0;\n                }\n                sol = p;\n                found = 1;\n            }\n        }\n    }\n\n    if (found) {\n        printf(\"Solution: (%.6f, %.6f)\\n\", sol.x, sol.y);\n    } else {\n        printf(\"No solution.\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct Line {\n    double a, b, c; // ax + by + c = 0\n    Line(double a = 0, double b = 0, double c = 0) : a(a), b(b), c(c) {}\n};\n\nPoint computeIntersection(const Line& l1, const Line& l2) {\n    double det = l1.a * l2.b - l2.a * l1.b;\n    if (fabs(det) < EPS) return Point(NAN, NAN); // parallel or coincident\n    double x = (l1.b * l2.c - l2.b * l1.c) / det;\n    double y = (l2.a * l1.c - l1.a * l2.c) / det;\n    return Point(x, y);\n}\n\ndouble distanceFromPointToLine(const Point& p, const Line& l) {\n    return fabs(l.a * p.x + l.b * p.y + l.c) / sqrt(l.a * l.a + l.b * l.b);\n}\n\nbool isEquidistant(const Point& p, const vector<Line>& lines) {\n    if (lines.empty()) return false;\n    double dist = distanceFromPointToLine(p, lines[0]);\n    for (size_t i = 1; i < lines.size(); ++i) {\n        if (fabs(distanceFromPointToLine(p, lines[i]) - dist) > EPS) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Line> lines(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> lines[i].a >> lines[i].b >> lines[i].c;\n    }\n\n    vector<Point> candidates;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            Point p = computeIntersection(lines[i], lines[j]);\n            if (!isnan(p.x) && !isnan(p.y)) {\n                candidates.push_back(p);\n            }\n        }\n    }\n\n    vector<Point> solutions;\n    for (const Point& p : candidates) {\n        if (isEquidistant(p, lines)) {\n            solutions.push_back(p);\n        }\n    }\n\n    if (solutions.empty()) {\n        cout << \"No solution\" << endl;\n    } else {\n        sort(solutions.begin(), solutions.end(), [](const Point& a, const Point& b) {\n            if (fabs(a.x - b.x) > EPS) return a.x < b.x;\n            return a.y < b.y;\n        });\n        solutions.erase(unique(solutions.begin(), solutions.end(), [](const Point& a, const Point& b) {\n            return fabs(a.x - b.x) < EPS && fabs(a.y - b.y) < EPS;\n        }), solutions.end());\n        if (solutions.size() == 1) {\n            cout << \"The equidistant point is (\" << solutions[0].x << \", \" << solutions[0].y << \").\" << endl;\n        } else {\n            cout << \"Multiple solutions\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Point {\n    double x, y;\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Line {\n    double a, b, c;\n    Line(double a, double b, double c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n}\n\npublic class EquidistantPointFinder {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Line> lines = new ArrayList<>();\n        \n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine().trim();\n            if (line.isEmpty()) break;\n            String[] parts = line.split(\" \");\n            double a = Double.parseDouble(parts[0]);\n            double b = Double.parseDouble(parts[1]);\n            double c = Double.parseDouble(parts[2]);\n            lines.add(new Line(a, b, c));\n        }\n        \n        if (lines.size() < 2) {\n            System.out.println(\"At least two lines are required.\");\n            return;\n        }\n        \n        List<Point> intersectionPoints = new ArrayList<>();\n        for (int i = 0; i < lines.size(); i++) {\n            for (int j = i + 1; j < lines.size(); j++) {\n                Line l1 = lines.get(i);\n                Line l2 = lines.get(j);\n                \n                double det = l1.a * l2.b - l2.a * l1.b;\n                if (Math.abs(det) < 1e-10) {\n                    continue;\n                }\n                \n                double x = (l1.b * l2.c - l2.b * l1.c) / det;\n                double y = (l2.a * l1.c - l1.a * l2.c) / det;\n                intersectionPoints.add(new Point(x, y));\n            }\n        }\n        \n        if (intersectionPoints.isEmpty()) {\n            System.out.println(\"No intersection points found. All lines are parallel.\");\n            return;\n        }\n        \n        Point center = intersectionPoints.get(0);\n        boolean isEquidistant = true;\n        for (Point p : intersectionPoints) {\n            if (Math.abs(p.x - center.x) > 1e-10 || Math.abs(p.y - center.y) > 1e-10) {\n                isEquidistant = false;\n                break;\n            }\n        }\n        \n        if (isEquidistant) {\n            System.out.println(\"The equidistant point is at (\" + center.x + \", \" + center.y + \").\");\n        } else {\n            System.out.println(\"Multiple intersection points found. No unique equidistant point.\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:12:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class EqualDistancePoint {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Line> lines = new ArrayList<>();\n\n        while (true) {\n            System.out.println(\"Enter line (x1 y1 x2 y2) or 'done' to finish:\");\n            String input = scanner.nextLine();\n            if (input.equals(\"done\")) break;\n\n            String[] coords = input.split(\" \");\n            if (coords.length != 4) {\n                System.out.println(\"Invalid input. Try again.\");\n                continue;\n            }\n\n            double x1 = Double.parseDouble(coords[0]);\n            double y1 = Double.parseDouble(coords[1]);\n            double x2 = Double.parseDouble(coords[2]);\n            double y2 = Double.parseDouble(coords[3]);\n            lines.add(new Line(x1, y1, x2, y2));\n        }\n\n        Point2D result = findEqualDistancePoint(lines);\n        if (result == null) {\n            System.out.println(\"No solution exists.\");\n        } else {\n            System.out.printf(\"Point: (%.2f, %.2f)%n\", result.getX(), result.getY());\n        }\n    }\n\n    static Point2D findEqualDistancePoint(List<Line> lines) {\n        if (lines.size() < 2) return null;\n\n        for (int i = 0; i < lines.size(); i++) {\n            for (int j = i + 1; j < lines.size(); j++) {\n                Point2D candidate = findIntersection(lines.get(i), lines.get(j));\n                if (candidate != null && isEqualDistance(candidate, lines)) {\n                    return candidate;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    static Point2D findIntersection(Line l1, Line l2) {\n        double x1 = l1.x1, y1 = l1.y1, x2 = l1.x2, y2 = l1.y2;\n        double x3 = l2.x1, y3 = l2.y1, x4 = l2.x2, y4 = l2.y2;\n\n        double denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (Math.abs(denominator) < 1e-9) return null;\n\n        double px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator;\n        double py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator;\n\n        return new Point2D.Double(px, py);\n    }\n\n    static boolean isEqualDistance(Point2D point, List<Line> lines) {\n        double firstDistance = distanceToLine(point, lines.get(0));\n        for (Line line : lines) {\n            if (Math.abs(distanceToLine(point, line) - firstDistance) > 1e-9) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static double distanceToLine(Point2D point, Line line) {\n        double x0 = point.getX(), y0 = point.getY();\n        double x1 = line.x1, y1 = line.y1, x2 = line.x2, y2 = line.y2;\n\n        return Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / \n               Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));\n    }\n\n    static class Line {\n        double x1, y1, x2, y2;\n        Line(double x1, double y1, double x2, double y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:12:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_LINES 100\n#define EPSILON 1e-9\n\ntypedef struct {\n    double a, b, c;  // Line in form ax + by + c = 0\n} Line;\n\ndouble distance_point_to_line(double x, double y, Line* line) {\n    return fabs(line->a * x + line->b * y + line->c) / \n           sqrt(line->a * line->a + line->b * line->b);\n}\n\nint main() {\n    int n;\n    Line lines[MAX_LINES];\n    \n    printf(\"Enter number of lines: \");\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"Enter line %d (a b c for ax + by + c = 0): \", i+1);\n        scanf(\"%lf %lf %lf\", &lines[i].a, &lines[i].b, &lines[i].c);\n    }\n    \n    int solutions = 0;\n    double solution_x = 0, solution_y = 0;\n    \n    for (double x = -1000; x <= 1000; x += 0.1) {\n        for (double y = -1000; y <= 1000; y += 0.1) {\n            int is_solution = 1;\n            double first_distance = distance_point_to_line(x, y, &lines[0]);\n            \n            for (int i = 1; i < n; i++) {\n                double current_distance = distance_point_to_line(x, y, &lines[i]);\n                if (fabs(current_distance - first_distance) > EPSILON) {\n                    is_solution = 0;\n                    break;\n                }\n            }\n            \n            if (is_solution) {\n                solutions++;\n                solution_x = x;\n                solution_y = y;\n                \n                if (solutions > 1) break;\n            }\n        }\n        if (solutions > 1) break;\n    }\n    \n    if (solutions == 0) {\n        printf(\"No solution exists.\\n\");\n    } else if (solutions > 1) {\n        printf(\"Multiple solutions exist.\\n\");\n    } else {\n        printf(\"Solution point: (%.2f, %.2f)\\n\", solution_x, solution_y);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <iomanip>\n#include <algorithm>\n\nconst double EPS = 1e-9;\n\nstruct Line {\n    double a, b, c;\n};\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Line& line, const Point& point) {\n    return std::abs(line.a * point.x + line.b * point.y + line.c) / \n           std::sqrt(line.a * line.a + line.b * line.b);\n}\n\nPoint intersect(const Line& l1, const Line& l2) {\n    double det = l1.a * l2.b - l2.a * l1.b;\n    if (std::abs(det) < EPS) {\n        return {std::numeric_limits<double>::quiet_NaN(), \n                std::numeric_limits<double>::quiet_NaN()};\n    }\n    return {\n        (l1.b * l2.c - l2.b * l1.c) / det,\n        (l2.a * l1.c - l1.a * l2.c) / det\n    };\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<Line> lines(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> lines[i].a >> lines[i].b >> lines[i].c;\n    }\n    \n    std::vector<Point> candidates;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            Point p = intersect(lines[i], lines[j]);\n            if (std::isnan(p.x)) continue;\n            \n            bool valid = true;\n            double dist = distance(lines[0], p);\n            \n            for (const auto& line : lines) {\n                if (std::abs(distance(line, p) - dist) > EPS) {\n                    valid = false;\n                    break;\n                }\n            }\n            \n            if (valid) candidates.push_back(p);\n        }\n    }\n    \n    std::sort(candidates.begin(), candidates.end(), \n        [](const Point& a, const Point& b) {\n            return a.x < b.x || (a.x == b.x && a.y < b.y);\n        });\n    \n    candidates.erase(\n        std::unique(candidates.begin(), candidates.end(), \n            [](const Point& a, const Point& b) {\n                return std::abs(a.x - b.x) < EPS && \n                       std::abs(a.y - b.y) < EPS;\n            }), \n        candidates.end()\n    );\n    \n    if (candidates.empty()) {\n        std::cout << \"No solution\" << std::endl;\n    } else if (candidates.size() > 1) {\n        std::cout << \"Multiple solutions\" << std::endl;\n    } else {\n        std::cout << std::fixed << std::setprecision(10)\n                  << candidates[0].x << \" \" << candidates[0].y << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from sympy import symbols, Eq, solve, sqrt\nfrom sympy.geometry import Line, Point\n\ndef find_equidistant_point(lines):\n    if not lines or len(lines) < 2:\n        return \"No solutions\"\n\n    # To handle only 2D case\n    x, y = symbols('x y')\n    points = []\n\n    for line in lines:\n        if ' ' in line:\n            line = line.split()\n        else:\n            return \"Invalid line format\"\n\n        try:\n            a, b, c = map(float, line)\n            if a == 0 and b == 0:\n                return \"Invalid line parameters\"\n        except:\n            return \"Invalid line parameters\"\n\n        # Get a point on the line\n        if b != 0:\n            pt = Point(0, -c / b)\n        elif a != 0:\n            pt = Point(-c / a, 0)\n        else:\n            return \"Invalid line parameters\"\n\n        # Normal vector to line\n        normal = (a, b)\n        points.append((pt, normal))\n\n    n = len(points)\n    sym_points = [symbols(f'x{i}, y{i}') for i in range(n)]\n    eqs = []\n\n    for i, (spi, ni) in enumerate(zip(sym_points, points)):\n        pi, ni = points[i]\n        xi, yi = spi\n\n        for j in range(i + 1, n):\n            pj, nj = points[j]\n            xj, yj = sym_points[j]\n\n            dist_i = abs(a * xi + b * yi + c) / sqrt(a * a + b * b)\n            dist_j = abs(a * xj + b * yj + c) / sqrt(a * a + b * b)\n\n            eq = Eq(dist_i, dist_j)\n            eqs.append(eq)\n\n    solution = solve(eqs, [x, y])\n    \n    if not solution:\n        return \"No solutions\"\n    elif isinstance(solution, dict):\n        return f\"Equidistant Point: ({solution[x]}, {solution[y]})\"\n    else:\n        return \"Multiple solutions\"\n\nif __name__ == \"__main__\":\n    lines = [\n        \"1 1 -3\",\n        \"-1 1 -1\",\n        \"0 1 2\"\n    ]\n    result = find_equidistant_point(lines)\n    print(result)",
    "timestamp": "2025-08-13 05:24:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class EquidistantPointFinder {\n    \n    static class Line {\n        double a, b, c;\n        \n        Line(double a, double b, double c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        Line[] lines = new Line[n];\n        \n        for (int i = 0; i < n; i++) {\n            double a = scanner.nextDouble();\n            double b = scanner.nextDouble();\n            double c = scanner.nextDouble();\n            lines[i] = new Line(a, b, c);\n        }\n        \n        // Use the first two lines to determine possible equidistant point\n        if (n < 2) {\n            System.out.println(\"No solution\");\n            return;\n        }\n        \n        Line line1 = lines[0];\n        Line line2 = lines[1];\n        \n        double a1 = line1.a, b1 = line1.b, c1 = line1.c;\n        double a2 = line2.a, b2 = line2.b, c2 = line2.c;\n        \n        double determinant = a1 * b2 - a2 * b1;\n        \n        if (determinant == 0) {\n            System.out.println(\"Multiple solutions\");\n            return;\n        }\n        \n        double x = (b2 * c1 - b1 * c2) / determinant;\n        double y = (a1 * c2 - a2 * c1) / determinant;\n        \n        boolean isEquidistant = true;\n        \n        for (int i = 2; i < n; i++) {\n            Line line = lines[i];\n            double dist1 = Math.abs(line1.a * x + line1.b * y + line1.c) / Math.sqrt(line1.a * line1.a + line1.b * line1.b);\n            double dist2 = Math.abs(line.a * x + line.b * y + line.c) / Math.sqrt(line.a * line.a + line.b * line.b);\n            if (dist1 != dist2) {\n                isEquidistant = false;\n                break;\n            }\n        }\n        \n        if (isEquidistant) {\n            System.out.printf(\"Equidistant point: (%.2f, %.2f)%n\", x, y);\n        } else {\n            System.out.println(\"No solution\");\n        }\n    }\n}",
    "timestamp": "2025-08-13 05:24:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EPSILON 1e-9\n\ntypedef struct {\n    double a, b, c;\n} Line;\n\n// Function to check if two doubles are approximately equal\nint approximatelyEqual(double d1, double d2) {\n    return fabs(d1 - d2) < EPSILON;\n}\n\n// Function to find the intersection point of two lines\nint findIntersection(Line l1, Line l2, double* x, double* y) {\n    double det = l1.a * l2.b - l2.a * l1.b;\n    if (approximatelyEqual(det, 0)) {\n        return 0; // Lines are parallel\n    }\n    *x = (l2.c * l1.b - l1.c * l2.b) / det;\n    *y = (l1.c * l2.a - l2.c * l1.a) / det;\n    return 1;\n}\n\n// Function to check if a point is equidistant from a set of lines\nint isEquidistant(Line lines[], int n, double x, double y) {\n    double distance = fabs(lines[0].a * x + lines[0].b * y + lines[0].c) /\n                      sqrt(lines[0].a * lines[0].a + lines[0].b * lines[0].b);\n    for (int i = 1; i < n; i++) {\n        double d = fabs(lines[i].a * x + lines[i].b * y + lines[i].c) /\n                   sqrt(lines[i].a * lines[i].a + lines[i].b * lines[i].b);\n        if (!approximatelyEqual(d, distance)) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int n;\n    printf(\"Enter the number of lines: \");\n    scanf(\"%d\", &n);\n\n    if (n < 2) {\n        printf(\"No solutions or multiple solutions.\\n\");\n        return 0;\n    }\n\n    Line lines[n];\n    printf(\"Enter the lines in the format a, b, c (ax + by + c = 0):\\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf\", &lines[i].a, &lines[i].b, &lines[i].c);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double x, y;\n            if (findIntersection(lines[i], lines[j], &x, &y)) {\n                if (isEquidistant(lines, n, x, y)) {\n                    printf(\"Equidistant point: (%.6f, %.6f)\\n\", x, y);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    printf(\"No solutions or multiple solutions.\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 05:24:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport numpy as np\n\ndef equally_distant_point(lines: List[Tuple[float, float, float]]) -> str:\n    n = len(lines)\n    if n < 2:\n        return \"Insufficient lines\"\n\n    # Create matrix A and vector b for system of equations\n    A = np.zeros((n, 2))\n    b = np.zeros(n)\n\n    for i, (a, b_i, c) in enumerate(lines):\n        # Normalize line equation ax + by + c = 0\n        norm = np.sqrt(a**2 + b_i**2)\n        A[i, 0] = a / norm\n        A[i, 1] = b_i / norm\n        b[i] = -c / norm\n\n    # Try to solve the system\n    try:\n        x = np.linalg.lstsq(A, b, rcond=None)[0]\n\n        # Verify point is equidistant\n        distances = [abs(a*x[0] + b_i*x[1] + c) / np.sqrt(a**2 + b_i**2) \n                     for a, b_i, c in lines]\n        \n        if len(set(round(d, 10) for d in distances)) == 1:\n            return f\"Point: {x[0]}, {x[1]}\"\n        else:\n            return \"No unique solution\"\n\n    except np.linalg.LinAlgError:\n        return \"No solution\"\n\n# Example usage\nlines = [(1, -1, 0), (1, 1, 0), (-1, 0, 0)]\nprint(equally_distant_point(lines))",
    "timestamp": "2025-08-13 05:25:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom numpy.linalg import solve, LinAlgError\n\ndef find_equidistant_point(lines):\n    A = []\n    b = []\n    \n    for i in range(len(lines)):\n        a1, b1, c1 = lines[i]\n        for j in range(i + 1, len(lines)):\n            a2, b2, c2 = lines[j]\n            \n            # Equation: (a1x + b1y + c1)/sqrt(a1^2 + b1^2) = ± (a2x + b2y + c2)/sqrt(a2^2 + b2^2)\n            # To avoid square roots, square both sides\n            denom1 = a1**2 + b1**2\n            denom2 = a2**2 + b2**2\n            \n            # Case 1: + sign\n            eq1_coeff = [\n                (a1 * denom2 - a2 * denom1),\n                (b1 * denom2 - b2 * denom1)\n            ]\n            eq1_const = (c2 * denom1 - c1 * denom2)\n            \n            # Case 2: - sign\n            eq2_coeff = [\n                (a1 * denom2 + a2 * denom1),\n                (b1 * denom2 + b2 * denom1)\n            ]\n            eq2_const = (-c2 * denom1 - c1 * denom2)\n            \n            # Add both cases to the system\n            A.append(eq1_coeff)\n            b.append(eq1_const)\n            A.append(eq2_coeff)\n            b.append(eq2_const)\n    \n    if not A:\n        return \"No solution (only one line provided)\"\n    \n    A = np.array(A)\n    b = np.array(b)\n    \n    try:\n        solution = solve(A, b)\n        x, y = solution[0], solution[1]\n        \n        # Verify the solution against all lines\n        distances = []\n        for a, bb, c in lines:\n            dist = abs(a * x + bb * y + c) / np.sqrt(a**2 + bb**2)\n            distances.append(dist)\n        \n        if all(np.isclose(distances[0], d) for d in distances):\n            return (x, y)\n        else:\n            return \"No solution (inconsistent system)\"\n    except LinAlgError:\n        return \"Multiple solutions (underdetermined system)\"",
    "timestamp": "2025-08-13 05:25:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nstruct Line {\n    double a, b, c;\n};\n\nbool isParallel(const Line &l1, const Line &l2) {\n    return fabs(l1.a * l2.b - l2.a * l1.b) < 1e-9;\n}\n\npair<double, double> findIntersection(const Line &l1, const Line &l2) {\n    double det = l1.a * l2.b - l2.a * l1.b;\n    return {\n        (l2.b * l1.c - l1.b * l2.c) / det,\n        (l1.a * l2.c - l2.a * l1.c) / det\n    };\n}\n\nint main() {\n    int n;\n    cout << \"Enter the number of lines: \";\n    cin >> n;\n\n    vector<Line> lines(n);\n    cout << \"Enter the coefficients (a, b, c) for each line:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        cin >> lines[i].a >> lines[i].b >> lines[i].c;\n    }\n\n    // Check for parallel lines\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (isParallel(lines[i], lines[j])) {\n                cout << \"No solution: lines are parallel or coincident.\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    // Assuming n >= 2, since a single line does not define a unique point\n    pair<double, double> intersection = findIntersection(lines[0], lines[1]);\n\n    // Check if this intersection point satisfies being equidistant\n    double distance = abs(lines[0].a * intersection.first + lines[0].b * intersection.second + lines[0].c) / \n                      sqrt(lines[0].a * lines[0].a + lines[0].b * lines[0].b);\n\n    for (int i = 1; i < n; ++i) {\n        double currentDistance = abs(lines[i].a * intersection.first + lines[i].b * intersection.second + lines[i].c) / \n                                 sqrt(lines[i].a * lines[i].a + lines[i].b * lines[i].b);\n        if (fabs(currentDistance - distance) > 1e-9) {\n            cout << \"No solution: no common equidistant point.\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Equidistant point: (\" << intersection.first << \", \" << intersection.second << \")\" << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:58"
  }
]